'
' ************************
' ***** FIDOST  .PRG *****
' ************************
'
' ******   V 3.0    ******
'
' Dieses  PRG  ersetzt das
' FIDO24ST - Packet.
'
'   (C)92 by sector99
'
' ******* 08/03/92 *******
'
'
CLS
DEFMOUSE 0
'
x_c%=INT{L~A-44}+1        ! Anz. der Chars pro Zeile
y_c%=INT{L~A-42}+1        ! Anz. der Zeilen
x_h%=INT{L~A-12}          ! Anz. der horizontalen Pixel
y_h%=INT{L~A-4}           ! Anz. der vertikalen Pixel
x_z%=x_h%/x_c%            !INT{L~A+80}          ! Breite eines Zeichens
y_z%=y_h%/y_c%            !INT{L~A+82}          ! Hoehe eines Zeichens
'
' CHDRIVE "J:\"   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
old.drive$=CHR$(65+GEMDOS(25))
old.dir$=DIR$(0)
'
call_basepage
'
'
PROCEDURE call_basepage
  ' *****************************************************
  ' Es wird die Basepage auf Eingaben untersucht, die aus
  ' folgenden Kuerzel bestehen koennen :
  '                                     POINT - Alles f. Point-list
  '                                     NODE  - Alles f. Node-list
  '                                     LIST  - Erst. Nodelist-Inh.
  '                                   NOAUTO  - Umgeht aktives AUTO
  '                                   CUTLOG  - Kuerzt das LOG-File
  '                                   MNL x:yy- Erstellt kl. NL
  '
  LOCAL cmdline$,adr%,pos|,arg|,c%
  IF BYTE{BASEPAGE+128}>0
    adr%=BASEPAGE+129
    DO UNTIL BYTE{adr%}=13 OR BYTE{adr%}=0
      cmdline$=cmdline$+CHR$(BYTE{adr%})
      INC adr%
    LOOP
    cmdline$=TRIM$(cmdline$)
    INC argc|
    DIM argv$(argc|)
    FOR arg|=1 TO argc|-1
      pos|=INSTR(cmdline$," ")
      argv$(arg|)=TRIM$(LEFT$(cmdline$,pos|))
      cmdline$=RIGHT$(cmdline$,LEN(cmdline$)-pos|)
    NEXT arg|
    argv$(argc|)=cmdline$
    bp$=argv$(argc|)
    bp$=UPPER$(bp$)
    ERASE argv$()
  ENDIF
  variable
  '
  IF LEN(bp$)<>0
    IF MID$(bp$,1,6)<>"NOAUTO" AND MID$(bp$,1,5)<>"POINT" AND MID$(bp$,1,4)<>"NODE" AND MID$(bp$,1,4)<>"LIST" AND MID$(bp$,1,6)<>"CUTLOG" AND MID$(bp$,1,4)<>"MNL " AND EXIST(bp$)
      cfg$=bp$
    ENDIF
    IF MID$(bp$,1,6)="NOAUTO" OR MID$(bp$,1,5)="POINT" OR MID$(bp$,1,4)="NODE" OR MID$(bp$,1,4)="LIST" OR MID$(bp$,1,6)="CUTLOG" OR MID$(bp$,1,4)="MNL "
      na!=TRUE
    ENDIF
  ENDIF
  '
  lade_cfg
  '
  IF v.var!(23)
    anfang
  ENDIF
  main_menu
  fenster_init
  IF v.var!(1)=FALSE OR na!
    IF MID$(bp$,1,5)="POINT"
      i_zeile(yb$+"POINT")
      titel(" POINT"+act$)
      point_act
    ELSE IF MID$(bp$,1,4)="NODE"
      i_zeile(yb$+"NODE")
      titel(" NODE"+act$)
      node_act
    ELSE IF MID$(bp$,1,4)="LIST"
      i_zeile(yb$+"LIST")
      titel(" LISTZONE"+act$)
      zone_list
    ELSE IF MID$(bp$,1,6)="CUTLOG" AND k.var!(8)
      i_zeile(yb$+cfg.v$(20))
      cut_log
      log_end
      end_screen(0)
    ELSE IF MID$(bp$,1,4)="MNL " AND k.var!(6) AND k.var!(4)
      test(cfg.k$(4)+cfg.k$(6)+".*")
      IF var1%=0 AND suffix%<>0
        nl!=TRUE
        bp$=TRIM$(MID$(bp$,INSTR(bp$,CHR$(32))))
        IF VAL(LEFT$(bp$))>0
          i_zeile(yb$+"MNL")
          titel(" MNL"+act$)
          z$=LEFT$(bp$)
          cfg.k$(9)=bp$
          IF VAL(MID$(bp$,INSTR(bp$,CHR$(58))+1))>0
            r$=MID$(bp$,INSTR(bp$,CHR$(58))+1)
            i_zeile("Create a little NODELIST ("+cfg.k$(9)+")")
            my_list
          ELSE IF MID$(bp$,INSTR(bp$,CHR$(58))+1)="ALL"
            i_zeile("Create a little NODELIST ("+cfg.k$(9)+")")
            big_list
          ELSE
            f_zeile("?  ERROR in CommandLine")
            log_end
            end_screen(1)
          ENDIF
        ELSE
          f_zeile("?  ERROR in CommandLine")
          log_end
          end_screen(1)
        ENDIF
      ELSE
        f_zeile("?  Can't find a NODELIST")
        log_end
        end_screen(1)
      ENDIF
    ELSE
      INFOW #1," Your CHOICE"
      PRINT SPACE$(x_c%/2-10);"0 - Return to DESKTOP"
      PRINT SPACE$(x_c%/2-10);"1 - POINT - Activity"
      PRINT SPACE$(x_c%/2-10);"2 - NODE - Activity"
      PRINT SPACE$(x_c%/2-10);"3 - LIST Nodelist"
      PRINT SPACE$(x_c%/2-10);"4 - CUT Log-File"
      '  PRINT SPACE$(x_c%/2-10);"? - Phone - Cost"
      '  PRINT SPACE$(x_c%/2-10);"? - MSG - Cruncher"
      REPEAT
      UNTIL INP?(2)
      CLS
      clear_screen
      taste%=INP(2)
      IF taste%<48 OR taste%>52
        f_zeile("?  Why do you select '"+CHR$(taste%)+"'   <KEY>")
        ~INP(2)
        log_end
        end_screen(1)
      ENDIF
      IF taste%=48
        i_zeile("Return to DESKTOP")
        log_end
        end_screen(1)
      ENDIF
      IF taste%=49
        titel(" POINT"+act$)
        point_act
      ENDIF
      IF taste%=50
        titel(" NODE"+act$)
        node_act
      ENDIF
      IF taste%=51
        titel(" LISTZONE"+act$)
        zone_list
      ENDIF
      IF taste%=52 AND k.var!(8)
        cut_log
      ENDIF
    ENDIF
  ELSE
    IF v.var!(20) AND k.var!(8)
      cut_log
    ENDIF
    IF pre.var!
      ext!=TRUE
      titel(" PRE"+act$)
      i_zeile(st$+"PRE"+act$)
      REPEAT
        titel(" PRE"+act$+" No."+STR$(anz%+1))
        i_zeile("[ PRE"+act$+" No."+STR$(anz%+1)+" ]")
        utility("PRE",8)
        INC anz%
      UNTIL anz%=16 OR pre$(anz%)=CHR$(255)
      i_zeile(en$+"PRE"+act$)
      ext!=FALSE
    ENDIF
    ERASE pre$()
    IF v.var!(24)=FALSE
      titel(" POINT"+act$)
      point_act
    ELSE
      i_zeile("[ POINT - Activities are disabled ]")
    ENDIF
    IF v.var!(25)=FALSE
      titel(" NODE"+act$)
      node_act
    ELSE
      i_zeile("[ NODE  - Activities are disabled ]")
    ENDIF
    anz%=0
    IF last.var!
      DIM pre$(15)
      ext!=TRUE
      titel(" LAST"+act$)
      i_zeile(st$+"LAST"+act$)
      REPEAT
        pre$(anz%)=last$(anz%)
        titel(" LAST"+act$+" No."+STR$(anz%+1))
        i_zeile("[ LAST"+act$+" No."+STR$(anz%+1)+" ]")
        utility("LAST",9)
        INC anz%
      UNTIL anz%=16 OR last$(anz%)=CHR$(255)
      i_zeile(en$+"LAST"+act$)
      ext!=FALSE
    ENDIF
    ERASE pre$(),last$()
  ENDIF
  DELAY del|
  i_zeile("End of my work...")
  taste
  log_end
  end_screen(0)
RETURN
'
PROCEDURE anfang
  LOCAL x%,y%,zu|,anz%,durch%,d%
  x%=INT(x_c%/2)
  y%=INT(y_c%/2)
  '
  IF EXIST(bcfg$)
    PRINT AT(x%-2,2);"Hi,"
    DIM sys_name$(0)
    OPEN "I",#1,bcfg$
    REPEAT
      RECALL #1,sys_name$(),1,dummy%
      IF UPPER$(MID$(sys_name$(0),1,6))="SYSOP "
        sys_name$(0)=TRIM$(sys_name$(0))
        sys_name$(0)=TRIM$(MID$(sys_name$(0),INSTR(sys_name$(0),CHR$(32))))
        sys_name$(0)=MID$(sys_name$(0),1,INSTR(sys_name$(0),CHR$(32)))
        PRINT AT((x%-LEN(sys_name$(0))/2),4);sys_name$(0)
        PRINT AT((x%-LEN(sys_name$(0))/2)-2,6);"YOU are using..."
      ENDIF
    UNTIL EOF(#1)
    CLOSE #1
  ENDIF
  REPEAT
    READ d%
    zufall(d%)
    INC durch%
  UNTIL durch%=18
  DATA 91,32,70,73,68,79,45,83,84,32,93,32,32,86,51,46,48,48
  PRINT AT(x%+zu|-28,y%);
  DELAY 5
  PRINT CHR$(27)+"p";
  PRINT " is PUBLIC DOMAIN !!! ";
  FOR anz%=0 TO 31
    PRINT AT(x%-15+anz%,y%-4);" "
    PRINT AT(x%-15+anz%,y%+2);" "
  NEXT anz%
  FOR anz%=0 TO 4
    PRINT AT(x%-15,y%-3+anz%);" "
    PRINT AT(x%+16,y%-3+anz%);" "
  NEXT anz%
  PRINT CHR$(27)+"q"
  DELAY 5
  CLS
  ERASE sys_name$()
RETURN
'
PROCEDURE zufall(zuf|)
  REPEAT
    intro1$=CHR$(RANDOM(220)+32)
    PRINT AT(x%+zu|-8,y%-2);intro1$
  UNTIL intro1$=CHR$(zuf|)
  PRINT CHR$(7)
  INC zu|
RETURN
'
PROCEDURE taste
  IF v.var!(19)
    PRINT "Please select a <KEY>..."
    ~INP(2)
  ENDIF
RETURN
'
PROCEDURE utility(anf$,pa%)
  dr$=MID$(pre$(anz%),INSTR(pre$(anz%),CHR$(32))+1)
  IF MID$(pre$(anz%),1,pa%)=anf$+"CALL "
    IF INSTR(dr$,CHR$(32))=0
      comm$=""
    ELSE
      comm$=TRIM$(MID$(dr$,INSTR(dr$,CHR$(32))))
      dr$=MID$(dr$,1,INSTR(dr$,CHR$(32)))
    ENDIF
    IF EXIST(dr$)
      lauf$=LEFT$(dr$)
      prg$=TRIM$(MID$(dr$,RINSTR(dr$,CHR$(92))+1))
      dr$=MID$(dr$,INSTR(dr$,CHR$(92))+1)
      IF RINSTR(dr$,CHR$(92))<>0
        dr$=MID$(dr$,1,RINSTR(dr$,CHR$(92))-1)
      ELSE
        dr$=""
      ENDIF
      i_zeile("Execute "+UPPER$(prg$)+" "+comm$)
      starte
    ELSE
      f_zeile("!  Can't execute "+dr$)
    ENDIF
  ENDIF
  IF MID$(pre$(anz%),1,pa%-1)=anf$+"DEL "
    del_file(dr$)
  ENDIF
  IF MID$(pre$(anz%),1,pa%)=anf$+"COPY "
    copy(TRIM$(MID$(dr$,1,INSTR(dr$,CHR$(32)))),TRIM$(MID$(dr$,INSTR(dr$,CHR$(32)))))
  ENDIF
  IF MID$(pre$(anz%),1,pa%-1)=anf$+"REN "
    source$=TRIM$(UPPER$(MID$(dr$,1,INSTR(dr$,CHR$(32)))))
    dest$=TRIM$(UPPER$(MID$(dr$,INSTR(dr$,CHR$(32)))))
    dest$=MID$(dest$,RINSTR(dest$,CHR$(92)))
    IF dest$=""
      f_zeile("!  Error in "+anf$+"REN")
    ELSE
      IF EXIST(source$)
        dest$=MID$(source$,1,RINSTR(source$,CHR$(92)))+MID$(dest$,RINSTR(dest$,CHR$(92))+1)
        d_file(dest$)
        i_zeile("Rename "+source$+" as "+dest$)
        RENAME source$ AS dest$
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE variable
  LOCAL anz|
  '
  DIM monat$(12)
  monat$(1)="Jan"
  monat$(2)="Feb"
  monat$(3)="Mar"
  monat$(4)="Apr"
  monat$(5)="May"
  monat$(6)="Jun"
  monat$(7)="Jul"
  monat$(8)="Aug"
  monat$(9)="Sep"
  monat$(10)="Oct"
  monat$(11)="Nov"
  monat$(12)="Dec"
  MODE &X0
  '
  xk|=11
  DIM cfg.k$(xk|),k.var!(xk|)
  cfg.k$(0)="PDIFF"
  cfg.k$(1)="NPDIFF"
  cfg.k$(2)="PL"
  cfg.k$(3)="INBOUND"
  cfg.k$(4)="NDIFF"
  cfg.k$(5)="NNDIFF"
  cfg.k$(6)="NL"
  cfg.k$(7)="FIDOUSER"
  cfg.k$(8)="LOG"
  cfg.k$(9)="MNL"
  cfg.k$(10)="COPY"
  cfg.k$(11)="MAXDIFF"
  xv|=27
  DIM cfg.v$(xv|),v.var!(xv|)
  cfg.v$(0)="PRVNL"
  cfg.v$(1)="AUTO"
  cfg.v$(2)="DELAPDIFF"
  cfg.v$(3)="DELANDIFF"
  cfg.v$(4)="DELPDIFF"
  cfg.v$(5)="DELNDIFF"
  cfg.v$(6)="CAPDIFF"
  cfg.v$(7)="CANDIFF"
  cfg.v$(8)="CPDIFF"
  cfg.v$(9)="CNDIFF"
  cfg.v$(10)="BUPL"
  cfg.v$(11)="BUNL"
  cfg.v$(12)="BUFU"
  cfg.v$(13)="CNL"
  cfg.v$(14)="ALLP"
  cfg.v$(15)="ALLN"
  cfg.v$(16)="HELP"
  cfg.v$(17)="TIMER"
  cfg.v$(18)="CLOCK"
  cfg.v$(19)="WAIT"
  cfg.v$(20)="CUTLOG"
  cfg.v$(21)="QCHECK"
  cfg.v$(22)="SPLITLOG"
  cfg.v$(23)="INTRO"
  cfg.v$(24)="NOPOINT"
  cfg.v$(25)="NONODE"
  cfg.v$(26)="GETPL"
  cfg.v$(27)="GETNL"
  xp|=4
  DIM cfg.p$(xp|),p.var!(xp|)
  cfg.p$(0)="NLCOMP"
  cfg.p$(1)="ARC"
  cfg.p$(2)="LHARC"
  cfg.p$(3)="ZIP"
  cfg.p$(4)="ARJ"
  '
  st$="Start :  "
  en$="End   :  "
  act$=" - Activities"
  pu$="POINT - Updating"
  nu$="NODE - Updating"
  yb$="Your Basepage : "
  '
  n.bt$="LOG.$$$"
  ende1$="End of"
  ende2$="Lost Carrier"
  ende3$="Timeout"
  ende4$="Remote didn't respond"
  ende5$="Keyboard"
  ende6$="Session with"
  '
  DIM pre$(15),last$(15),point$(15),node$(15),ppoint$(15),pnode$(15)
  cfg$="FIDOST.CFG"
  version$="V3.0"          ! Bei offizieller Version
  bcfg$="BINKLEY.CFG"
  fst$="FIDO-ST"
  tw1$=" [ FIDOST - Information Area ] "
  tw2$=" [ FIDOST - Error Area ] "
  TITLEW #1,tw1$
  INFOW #1," "
  TITLEW #2,tw2$
  INFOW #2," "
RETURN
'
PROCEDURE main_menu
  PRINT CHR$(27)+"p";
  PRINT " "+fst$+"   "+version$+" ";CHR$(27)+"q";
  PRINT SPACE$(x_c%-LEN(fst$+version$)-27);"(c)'92  by  G. Paczia"
  PRINT SPACE$(x_c%-22);"( FIDO 2:241/4407.7 )"
  PRINT AT(2,2);"Use "+cfg$
RETURN
'
PROCEDURE fenster_init
  LOCAL anz%
  OPENW #2,x_z%,(y_h%/2)+y_z%,x_h%-(2*x_z%),(y_h%-(4*y_z%))/2,25  !473
  clear_screen
  OPENW #1,x_z%,2*y_z%,x_h%-(2*x_z%),(y_h%-(4*y_z%))/2,25       !473
  clear_screen
RETURN
'
PROCEDURE clear_screen
  LOCAL cs%
  FOR cs%=1 TO INT(y_h%/y_z%)
    PRINT
  NEXT cs%
RETURN
'
PROCEDURE conf_timer(vt!)
  IF v.var!(17)
    IF vt!
      t1%=TIMER/200
    ELSE
      t2%=TIMER/200
      t3%=t2%-t1%
      zeit
      i_zeile("[ Convert-Time : "+STR$(t3%)+" sec ]")
    ENDIF
  ENDIF
RETURN
'
PROCEDURE zeit
  IF v.var!(18)
    uhr$=TIME$
  ENDIF
RETURN
'
PROCEDURE cut_log
  LOCAL var%,cta%,ctb%,ctc%,ctp$,dim%,dim1%,zeile$,con_str$
  TOPW #1
  INFOW #1," Cut "+cfg.k$(8)
  ctp$=MID$(cfg.k$(8),1,RINSTR(cfg.k$(8),CHR$(92)))
  n.bt$=ctp$+n.bt$
  var%=FSFIRST(cfg.k$(8),0)
  old.len%={FGETDTA()+26}
  IF var%=0 AND old.len%>0
    dim%=SUCC({FGETDTA()+26}/10)
    DIM old_zeile$(dim%)
    i_zeile("Loading "+cfg.k$(8))
    OPEN "I",#5,cfg.k$(8)
    RECALL #5,old_zeile$(),dim%,dummy%
    CLOSE #5
    dim1%=dummy%
    '
    INFOW #1," Cut "+cfg.k$(8)+" [ 1.Pass ]"
    i_zeile("Analyse "+cfg.k$(8)+" [ 1.Pass ]")
    OPEN "O",#7,n.bt$
    REPEAT
      IF LEFT$(old_zeile$(cta%))=CHR$(42) OR LEFT$(old_zeile$(cta%))=CHR$(35) OR LEFT$(old_zeile$(cta%))=CHR$(32)
        IF MID$(old_zeile$(cta%),19,4)="BINK"
          IF MID$(old_zeile$(cta%),24,10)="Processing" AND MID$(old_zeile$(cta%+1),24,7)="Dialing"
            PRINT
            PRINT old_zeile$(cta%)
            PRINT old_zeile$(cta%+1)
            PRINT #7
            PRINT #7,old_zeile$(cta%)
            PRINT #7,old_zeile$(cta%+1)
          ELSE IF MID$(old_zeile$(cta%),24,7)="Connect"
            PRINT old_zeile$(cta%)
            PRINT #7,old_zeile$(cta%)
          ELSE IF MID$(old_zeile$(cta%),24,6)=ende1$ OR MID$(old_zeile$(cta%),24)=ende2$ OR MID$(old_zeile$(cta%),24)=ende3$ OR MID$(old_zeile$(cta%),24)=ende4$ OR MID$(old_zeile$(cta%),24,8)=ende5$
            PRINT old_zeile$(cta%)
            PRINT #7,old_zeile$(cta%)
          ELSE IF MID$(old_zeile$(cta%),24,12)=ende6$
            PRINT old_zeile$(cta%)
            PRINT #7,old_zeile$(cta%)
          ENDIF
        ELSE IF MID$(old_zeile$(cta%),19,4)="RFUS"
          IF MID$(old_zeile$(cta%),24,7)="Connect"
            PRINT
            PRINT old_zeile$(cta%)
            PRINT #7
            PRINT #7,old_zeile$(cta%)
          ELSE IF MID$(old_zeile$(cta%),24)="Online" OR MID$(old_zeile$(cta%),24)="Offline"
            PRINT old_zeile$(cta%)
            PRINT #7,old_zeile$(cta%)
          ENDIF
        ENDIF
      ENDIF
      INC cta%
    UNTIL cta%-1=dim1%
    CLOSE #7
    ERASE old_zeile$()
    KILL cfg.k$(8)
    RENAME n.bt$ AS cfg.k$(8)
    ~FSFIRST(cfg.k$(8),0)
    IF {FGETDTA()+26}>0
      dim%=SUCC({FGETDTA()+26}/10)
      DIM old_zeile$(dim%)
      CLS
      OPEN "I",#5,cfg.k$(8)
      RECALL #5,old_zeile$(),dim%,dummy%
      CLOSE #5
      dim1%=dummy%
      INFOW #1," Cut "+cfg.k$(8)+" [ 2.Pass ]"
      i_zeile("Analyse "+cfg.k$(8)+" [ 2.Pass ]")
      cta%=0
      dat%=VAL(MID$(DATE$,4,2))
      dat_str$=monat$(dat%)
      handle|=7
      OPEN "O",#handle|,n.bt$
      REPEAT
        IF MID$(old_zeile$(cta%),24,10)="Processing"
          IF LEN(old_zeile$(cta%+2))<>0 AND LEN(old_zeile$(cta%+3))<>0
            IF v.var!(22)
              split_log
            ENDIF
            PRINT
            PRINT #handle|
            REPEAT
              PRINT old_zeile$(cta%)
              PRINT #handle|,old_zeile$(cta%)
              INC cta%
            UNTIL LEN(old_zeile$(cta%))=0
            IF vs!
              CLOSE #8
              vs!=FALSE
              handle|=7
            ENDIF
            cta%=cta%-1
          ENDIF
        ELSE IF MID$(old_zeile$(cta%),19,4)="RFUS"
          IF v.var!(22)
            split_log
          ENDIF
          PRINT
          PRINT #handle|
          REPEAT
            PRINT old_zeile$(cta%)
            PRINT #handle|,old_zeile$(cta%)
            INC cta%
          UNTIL LEN(old_zeile$(cta%))=0
          IF vs!
            CLOSE #8
            vs!=FALSE
            handle|=7
          ENDIF
        ENDIF
        INC cta%
      UNTIL cta%-1=dim1%
      CLOSE #7
      ERASE old_zeile$()
      KILL cfg.k$(8)
      RENAME n.bt$ AS cfg.k$(8)
      ~FSFIRST(cfg.k$(8),0)
    ENDIF
    '
    new.len%={FGETDTA()+26}
    log_anf
    i_zeile("Old length ("+cfg.k$(8)+") : "+STR$(old.len%))
    i_zeile("New length ("+cfg.k$(8)+") : "+STR$(new.len%))
  ENDIF
RETURN
'
PROCEDURE split_log
  IF dat_str$<>MID$(old_zeile$(cta%),6,3)
    vs!=TRUE
    handle|=8
    IF vs1!=FALSE
      INFOW #1," Split-Log is active..."
      vs1!=TRUE
    ENDIF
    IF EXIST(ctp$+"BT_"+UPPER$(MID$(old_zeile$(cta%),6,3))+".LOG")
      OPEN "A",#handle|,ctp$+"BT_"+UPPER$(MID$(old_zeile$(cta%),6,3))+".LOG"
    ELSE
      OPEN "O",#handle|,ctp$+"BT_"+UPPER$(MID$(old_zeile$(cta%),6,3))+".LOG"
    ENDIF
  ENDIF
RETURN
'
PROCEDURE delete_diff(diff_name$)
  LOCAL anz.d%,anz.diff%
  IF k.var!(10) AND k.var!(11)
    maxdiff%=VAL(cfg.k$(11))
    IF maxdiff%>0
      var%=FSFIRST(diff_name$,0)
      IF var%=0
        REPEAT
          INC anz.diff%
          var%=FSNEXT()
        UNTIL var%<>0
        IF maxdiff%<anz.diff%
          DIM d.zeile$(anz.diff%)
          ~FSFIRST(diff_name$,0)
          REPEAT
            INC anz.d%
            d.zeile$(anz.d%)=STR$(CARD{FGETDTA()+24})+" "+CHAR{FGETDTA()+30}
            ~FSNEXT()
          UNTIL anz.d%=anz.diff%
          QSORT d.zeile$()
          i_zeile("You want to have "+STR$(maxdiff%)+" "+npd$+"s")
          i_zeile("I found "+STR$(anz.diff%)+" and delete "+STR$(anz.diff%-maxdiff%))
          FOR anz.d%=1 TO anz.diff%-maxdiff%
            IF v.var!(16)
              i_zeile("Deleted : "+MID$(d.zeile$(anz.d%),INSTR(d.zeile$(anz.d%),CHR$(32))+1))
            ENDIF
            KILL cfg.k$(10)+MID$(d.zeile$(anz.d%),INSTR(d.zeile$(anz.d%),CHR$(32))+1)
          NEXT anz.d%
          IF v.var!(16)
            i_zeile("Now you have "+STR$(maxdiff%)+" "+npd$+"s")
          ENDIF
          ERASE d.zeile$()
        ELSE
          IF v.var!(16)
            f_zeile("!  Not enough "+diff_name$+" to delete")
          ENDIF
        ENDIF
      ELSE
        IF v.var!(16)
          f_zeile("!  Can't find a "+diff_name$+" to delete")
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE starte
  comm$=CHR$(LEN(comm$))+comm$
  CHDRIVE lauf$
  CHDIR "\"
  CHDIR dr$
  close_screen
  PRINT AT(1,1);
  RESERVE 20480
  EXEC 0,prg$,comm$,""
  RESERVE
  PRINT AT(1,1);
  PRINT CHR$(27)+"f";
  CLS
  CHDRIVE old.drive$
  CHDIR "\"
  CHDIR old.dir$
  main_menu
  OPENW 2
  clear_screen
  OPENW 1
  clear_screen
RETURN
'
PROCEDURE show_error
  IF ch!=FALSE
    close_screen
    PRINT "  ERRORs in ";cfg$;" :"
    PRINT
  ENDIF
  ch!=TRUE
RETURN
'
PROCEDURE check_drive(cdr$)
  IF MID$(cdr$,2,1)<>CHR$(58)
    show_error
    PRINT "  ?  Missing Drive :  "+CHR$(27)+"p"'cdr$'CHR$(27)+"q"
  ENDIF
RETURN
'
PROCEDURE check_dir(cd$)
  check_drive(cd$)
  IF RIGHT$(cd$)<>CHR$(92)
    show_error
    PRINT "  ?  Missing '\' as last char at  "+CHR$(27)+"p"'cd$'CHR$(27)+"q"
  ELSE
    IF LEN(cd$)<>3
      ok%=FSFIRST(MID$(cd$,1,LEN(cd$)-1),16)
      IF ok%<>0
        show_error
        PRINT "  ?  Can't find the DIR  "+CHR$(27)+"p"'cd$'CHR$(27)+"q"
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE check_nam(cn$)
  check_drive(cn$)
  ok%=FSFIRST(cn$,0)
  IF ok%<>0
    show_error
    PRINT "  ?  Can't find the FILE  "+CHR$(27)+"p"'cn$'CHR$(27)+"q"
    taste
  ENDIF
RETURN
'
PROCEDURE lade_cfg
  LOCAL anz|,anz1|
  '
  IF EXIST(cfg$)
    DIM cfg.zeile$(254)
    OPEN "I",#1,cfg$
    RECALL #1,cfg.zeile$(),255,dummy%
    CLOSE #1
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF cfg.k$(anz1|)+" "=MID$(cfg.z$,1,LEN(cfg.k$(anz1|))+1)
        cfg.k$(anz1|)=TRIM$(UPPER$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32)))))
        INC anz1|
        anz|=0
      ELSE
        INC anz|
      ENDIF
      IF cfg.zeile$(anz|)=""
        cfg.k$(anz1|)=""
        anz|=0
        INC anz1|
      ENDIF
    UNTIL anz1|=xk|+1
    log_cfg.k
    IF k.var!(8)=FALSE
      del|=5
    ENDIF
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(cfg.zeile$(anz|))
      IF cfg.v$(anz1|)=MID$(cfg.z$,1,LEN(cfg.v$(anz1|)))
        cfg.v$(anz1|)=TRIM$(UPPER$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32)))))
        INC anz1|
        anz|=0
      ELSE
        INC anz|
      ENDIF
      IF cfg.zeile$(anz|)=""
        cfg.v$(anz1|)=""
        anz|=0
        INC anz1|
      ENDIF
    UNTIL anz1|=xv|+1
    log_cfg.v
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF cfg.p$(anz1|)+" "=MID$(cfg.z$,1,LEN(cfg.p$(anz1|))+1)
        cfg.p$(anz1|)=TRIM$(UPPER$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32)))))
        INC anz1|
        anz|=0
      ELSE
        INC anz|
      ENDIF
      IF cfg.zeile$(anz|)=""
        cfg.p$(anz1|)=""
        anz|=0
        INC anz1|
      ENDIF
    UNTIL anz1|=xp|+1
    log_cfg.p
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "PRE"=MID$(cfg.z$,1,3)
        pre.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        pre$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF pre$(anz|)=""
        pre$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(pre$(anz|),1,INSTR(pre$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(pre$(ind%(anz|)),INSTR(pre$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        pre$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "LAST"=MID$(cfg.z$,1,4)
        last.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        last$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF last$(anz|)=""
        last$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(last$(anz|),1,INSTR(last$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(last$(ind%(anz|)),INSTR(last$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        last$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "PPOINT"=MID$(cfg.z$,1,6)
        ppoint.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        ppoint$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF ppoint$(anz|)=""
        ppoint$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(ppoint$(anz|),1,INSTR(ppoint$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(ppoint$(ind%(anz|)),INSTR(ppoint$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        ppoint$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "POINT"=MID$(cfg.z$,1,5)
        point.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        point$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF point$(anz|)=""
        point$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(point$(anz|),1,INSTR(point$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(point$(ind%(anz|)),INSTR(point$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        point$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "PNODE"=MID$(cfg.z$,1,5)
        pnode.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        pnode$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF pnode$(anz|)=""
        pnode$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(pnode$(anz|),1,INSTR(pnode$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(pnode$(ind%(anz|)),INSTR(pnode$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        pnode$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    DIM ind%(15),index$(15)
    FOR anz|=0 TO 15
      ind%(anz|)=anz|
    NEXT anz|
    CLR anz|,anz1|
    REPEAT
      cfg.z$=UPPER$(MID$(cfg.zeile$(anz|),1,INSTR(cfg.zeile$(anz|),CHR$(32))))+MID$(cfg.zeile$(anz|),INSTR(cfg.zeile$(anz|),CHR$(32)))
      IF "NODE"=MID$(cfg.z$,1,4)
        node.var!=TRUE
        art$=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))
        cfg.z$=TRIM$(MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))))
        node$(anz1|)=MID$(cfg.z$,1,INSTR(cfg.z$,CHR$(32)))+art$+MID$(cfg.z$,INSTR(cfg.z$,CHR$(32))+1)
        INC anz1|
      ENDIF
      INC anz|
    UNTIL anz1|=16 OR cfg.zeile$(anz|)=""
    FOR anz|=0 TO 15
      IF node$(anz|)=""
        node$(anz|)=CHR$(255)
      ELSE
        index$(anz|)=TRIM$(MID$(node$(anz|),1,INSTR(node$(anz|),CHR$(32))))
      ENDIF
    NEXT anz|
    IF anz1|>0
      QSORT index$(),anz1|,ind%()
      FOR anz|=0 TO anz1|-1
        index$(ind%(anz|))=MID$(node$(ind%(anz|)),INSTR(node$(ind%(anz|)),CHR$(32))+1)
      NEXT anz|
      FOR anz|=0 TO anz1|-1
        node$(anz|)=index$(ind%(anz|))
      NEXT anz|
    ENDIF
    ERASE index$(),ind%()
    CLR anz|,anz1|
  ELSE
    ALERT 3,"Can't find|"+cfg$,1,"DESKTOP",al|
    end_screen(1)
  ENDIF
  '
  IF k.var!(0)
    check_dir(cfg.k$(0))
  ENDIF
  IF k.var!(3)
    check_dir(cfg.k$(3))
  ENDIF
  IF k.var!(4)
    check_dir(cfg.k$(4))
  ENDIF
  IF k.var!(7)
    check_drive(cfg.k$(7))
  ENDIF
  IF k.var!(8)
    check_drive(cfg.k$(8))
  ENDIF
  IF k.var!(10)
    check_dir(cfg.k$(10))
  ENDIF
  FOR anz|=0 TO 4
    IF p.var!(anz|)
      IF INSTR(cfg.p$(anz|),CHR$(32))<>0
        check_nam(MID$(cfg.p$(anz|),1,INSTR(cfg.p$(anz|),CHR$(32))-1))
      ELSE
        check_nam(cfg.p$(anz|))
      ENDIF
    ENDIF
  NEXT anz|
  '
  IF na!=FALSE
    IF v.var!(21)
      var%=FSFIRST(cfg.k$(3)+"*.*",0)
      IF var%<>0
        end_screen(0)
      ENDIF
    ENDIF
  ENDIF
  '
  log_anf
  anz|=0
  ok%=0
  cd$=""
  cn$=""
  IF ch!
    TOPW #1
    PRINT
    PRINT "  Please select a <KEY>..."
    PRINT "  ... to return back to the DESKTOP !!!"
    ~INP(2)
    end_screen(2)
  ENDIF
RETURN
'
PROCEDURE log_cfg.k
  LOCAL anz|
  FOR anz|=0 TO xk|
    IF cfg.k$(anz|)<>""
      k.var!(anz|)=TRUE
    ENDIF
  NEXT anz|
RETURN
'
PROCEDURE log_cfg.v
  LOCAL anz|
  FOR anz|=0 TO xv|
    IF cfg.v$(anz|)<>""
      v.var!(anz|)=TRUE
    ENDIF
  NEXT anz|
RETURN
'
PROCEDURE log_cfg.p
  LOCAL anz|
  FOR anz|=0 TO xp|
    IF cfg.p$(anz|)<>""
      p.var!(anz|)=TRUE
    ENDIF
  NEXT anz|
RETURN
'
PROCEDURE log_anf
  IF k.var!(8)
    msg$=fst$+" "+version$+" ******** START ********"
    datum$=DATE$
    IF EXIST(cfg.k$(8))
      OPEN "A",#3,cfg.k$(8)
    ELSE
      OPEN "O",#3,cfg.k$(8)
    ENDIF
    PRINT #3
    PRINT #3,"* "+MID$(datum$,1,2)+" "+monat$(VAL(MID$(datum$,4,2)))+" "+TIME$+" FST  "+msg$
    CLOSE #3
  ELSE
    PRINT "?  You don't need a LOG-FILE ???"
    DELAY del|
    CLS
  ENDIF
RETURN
'
PROCEDURE log_dat(msg$)
  IF k.var!(8)
    datum$=DATE$
    OPEN "A",#3,cfg.k$(8)
    PRINT #3,"* "+MID$(datum$,1,2)+" "+monat$(VAL(MID$(datum$,4,2)))+" "+TIME$+" FST  "+msg$
    CLOSE #3
  ENDIF
RETURN
'
PROCEDURE log_end
  msg$="********* END *********"
  IF k.var!(8)
    msg$=fst$+" "+version$+" "+msg$
    datum$=DATE$
    OPEN "A",#3,cfg.k$(8)
    PRINT #3,"* "+MID$(datum$,1,2)+" "+monat$(VAL(MID$(datum$,4,2)))+" "+TIME$+" FST  "+msg$
    PRINT #3
    CLOSE #3
  ENDIF
RETURN
'
PROCEDURE i_zeile(i.z$)
  TOPW #1
  zeit
  PRINT uhr$+"  "+i.z$
  DELAY del|
  log_dat(i.z$)
RETURN
'
PROCEDURE f_zeile(f.z$)
  TOPW #2
  PRINT CHR$(7);
  zeit
  PRINT uhr$+"  "+f.z$
  DELAY del|
  log_dat(f.z$)
RETURN
'
PROCEDURE titel(ft$)
  INFOW #1,ft$
  INFOW #2,ft$
RETURN
'
PROCEDURE d_file(file$)
  IF EXIST(file$)
    KILL file$
  ENDIF
RETURN
'
PROCEDURE del_file(file$)
  v%=FSFIRST(file$,0)
  IF v%=0
    IF v.var!(16) OR ext!
      df$=UPPER$(MID$(file$,1,RINSTR(file$,CHR$(92)))+CHAR{FGETDTA()+30})
      i_zeile("Deleted : "+df$)
    ENDIF
    KILL file$
    REPEAT
      v%=FSNEXT()
      IF v%=0
        IF v.var!(16) OR ext!
          df$=UPPER$(MID$(file$,1,RINSTR(file$,CHR$(92)))+CHAR{FGETDTA()+30})
          i_zeile("Deleted : "+df$)
        ENDIF
        KILL file$
      ENDIF
    UNTIL v%=-49
  ELSE
    IF v.var!(16) OR ext!=FALSE
      f_zeile("!  Can't find "+UPPER$(file$)+" to delete")
    ENDIF
  ENDIF
RETURN
'
PROCEDURE check_entpacken(inf$)
  LOCAL arca%,arcs$,a%
  exi!=FALSE
  diff_da(cfg.k$(3)+npd$+".*")
  IF v%=0                                  ! gepacktes DIFF-File vorhanden
    IF ce.var!
      IF f!=FALSE
        ppoint
      ELSE
        pnode
      ENDIF
      ce.var!=FALSE
      diff_da(cfg.k$(3)+npd$+".*")
    ENDIF
    REPEAT
      IF v%=0
        INC a%
        fg$=CHAR{FGETDTA()+30}
        arcs$=arcs$+fg$+CHR$(32)
        i_zeile("Found "+cfg.k$(3)+fg$+" to decompress")
        v.t!=FALSE
        v%=FSNEXT()
      ENDIF
    UNTIL v%<>0
    DIM arc$(a%)
    FOR arca%=0 TO a%-1
      arc$(arca%)=MID$(arcs$,1,INSTR(arcs$,CHR$(32))-1)
      arcs$=MID$(arcs$,INSTR(arcs$,CHR$(32))+1)
      welcher_packer(arc$(arca%))
    NEXT arca%
    ERASE arc$()
    vergleich
  ELSE
    f_zeile("!  No "+inf$+" to decompress")
    IF v.durch!
      v.t!=FALSE
      vergleich
    ELSE
      v.t!=TRUE
    ENDIF
  ENDIF
RETURN
'
PROCEDURE diff_da(diff$)
  v%=FSFIRST(diff$,0)
RETURN
'
PROCEDURE welcher_packer(fg$)
  LOCAL anz|,anz1|
  OPEN "I",#1,cfg.k$(3)+fg$
  DIM wert|(5)
  FOR anz|=0 TO 5
    wert|(anz|)=INP(#1)
  NEXT anz|
  CLOSE #1
  IF wert|(0)=26 AND wert|(1)=<9
    ERASE wert|()
    ex$="*.*"
    check_packer(1)
  ELSE IF wert|(0)=80 AND wert|(1)=75
    ERASE wert|()
    ex$=""
    check_packer(3)
  ELSE IF wert|(3)=108 AND VAL(CHR$(wert|(5)))=<9
    ERASE wert|()
    ex$=""
    check_packer(2)
    '
  ELSE IF wert|(0)=96 AND wert|(1)=234
    ERASE wert|()
    ex$=""
    check_packer(4)
  ELSE
    f_zeile("!  No ARC/LHARC/ZIP/ARJ-compatibility")
    ERASE wert|()
  ENDIF
RETURN
'
PROCEDURE check_packer(pvar|)
  IF p.var!(pvar|)
    IF INSTR(cfg.p$(pvar|),CHR$(32))<>0
      packer$=MID$(cfg.p$(pvar|),1,INSTR(cfg.p$(pvar|),CHR$(32))-1)
    ELSE
      packer$=cfg.p$(pvar|)
    ENDIF
    IF EXIST(packer$)
      i_zeile("Decompress with "+packer$)
      i_zeile("to "+pd$+"*.*")
      IF INSTR(cfg.p$(pvar|),CHR$(32))=0
        comm$=""
        prg$=TRIM$(cfg.p$(pvar|))
      ELSE
        comm$=TRIM$(MID$(cfg.p$(pvar|),INSTR(cfg.p$(pvar|),CHR$(32))))
        prg$=TRIM$(MID$(cfg.p$(pvar|),1,INSTR(cfg.p$(pvar|),CHR$(32))))
      ENDIF
      lauf$=LEFT$(packer$)
      dr$=MID$(packer$,INSTR(packer$,CHR$(92))+1)
      IF RINSTR(dr$,CHR$(92))<>0
        dr$=MID$(dr$,1,RINSTR(dr$,CHR$(92))-1)
      ELSE
        dr$=""
      ENDIF
      IF (v.var!(26) AND f!=FALSE) OR (v.var!(27) AND f!)
        test(pd$+l$+".*")
        IF var1%=0 AND suffix%<>0
          IF v.lbu!
            IF v.var!(16)
              i_zeile("Create "+pf$+"-BackUp ("+MID$(pf$,1,5)+".OLD)")
            ENDIF
            d_file(pd$+MID$(pf$,1,5)+".OLD")
            RENAME pd$+pf$ AS pd$+MID$(pf$,1,5)+".OLD"
          ELSE
            del_file(pd$+pf$)
          ENDIF
        ENDIF
      ENDIF
      comm$=comm$+" "+cfg.k$(3)+fg$+" "+pd$+ex$
      comm$=TRIM$(comm$)
      lauf$=LEFT$(prg$)
      starte
      IF v.cpd! AND k.var!(10)
        copy(cfg.k$(3)+fg$,cfg.k$(10))
        IF v.var!(16)
          i_zeile("Delete : "+cfg.k$(3)+fg$)
        ENDIF
        d_file(cfg.k$(3)+fg$)
      ENDIF
      IF v.dpd! AND v.cpd!=FALSE
        del_file(cfg.k$(3)+fg$)
      ENDIF
    ELSE
      IF v.var!(16)
        i_zeile("! Where is "+packer$)
      ENDIF
      f_zeile("?  Can't find "+packer$)
    ENDIF
  ELSE
    f_zeile("?  ERROR in CFG-File (ARC/LHARC/ZIP/ARJ)")
  ENDIF
RETURN
'
PROCEDURE test(pfad$)
  LOCAL l.f%
  var1%=FSFIRST(pfad$,0)
  IF var1%=0
    pfad$=CHAR{FGETDTA()+30}
    suffix%=VAL(MID$(pfad$,RINSTR(pfad$,CHR$(46))+1))
    IF suffix%<>0
      l.f%={FGETDTA()+26}
      f.l%=l.f%
    ENDIF
  ENDIF
  IF var1%=0 AND suffix%=0
    REPEAT
      var1%=FSNEXT()
      pfad$=CHAR{FGETDTA()+30}
      suffix%=VAL(MID$(pfad$,RINSTR(pfad$,CHR$(46))+1))
      IF suffix%<>0
        l.f%={FGETDTA()+26}
        f.l%=l.f%
      ENDIF
    UNTIL var1%=-49 OR suffix%<>0
  ENDIF
  pf$=pfad$
RETURN
'
PROCEDURE vergleich
  LOCAL a%,darc$,var1%
  IF (v.var!(26)=FALSE AND f!=FALSE) OR (v.var!(27)=FALSE AND f!)             !!!!!!!!!!!!
    test(pd$+npd$+".*")
    IF var1%=0 AND suffix%<>0
      REPEAT
        INC a%
        OPEN "I",#1,pd$+CHAR{FGETDTA()+30}
        DIM z$(0)
        RECALL #1,z$(),1,dummy%
        CLOSE #1
        darc$=darc$+CHAR{FGETDTA()+30}+CHR$(10)+z$(0)+CHR$(13)
        ERASE z$()
        var1%=FSNEXT()
      UNTIL var1%<>0
      DIM z$(a%-1)
      FOR darca%=0 TO a%-1
        z$(darca%)=MID$(darc$,1,INSTR(darc$,CHR$(13))-1)
        darc$=MID$(darc$,INSTR(darc$,CHR$(13))+1)
      NEXT darca%
      l!=TRUE
      DO
        test(pd$+l$+".*")
        IF var1%=0 AND suffix%<>0
          na2$=pf$
          n2a%=f.l%
          ERASE z1$()
          OPEN "I",#1,pd$+na2$
          DIM z1$(0)
          RECALL #1,z1$(),1,dummy%
          CLOSE #1
          FOR darca%=0 TO a%-1
            na1$=MID$(z$(darca%),1,INSTR(z$(darca%),CHR$(10))-1)
            IF z1$(0)=MID$(z$(darca%),INSTR(z$(darca%),CHR$(10))+1)
              test(pd$+MID$(z$(darca%),1,INSTR(z$(darca%),CHR$(10))-1))
              na1$=pf$
              n1a%=f.l%
              darca%=0
              IF v.var!(16)
                i_zeile("Compare "+pd$+na2$)
                i_zeile("  with  "+pd$+na1$)
              ENDIF
              OPEN "I",#1,pd$+na1$
              DIM z2$(0)
              RECALL #1,z2$(),1,dummy%
              CLOSE #1
              IF z2$(0)<>z1$(0) OR z2$(0)<>z1$(0) AND MID$(z2$,RINSTR(z2$,".")+1)<>MID$(z2$(0),INSTR(z2$(0),"number")+7,3)
                f_zeile("?  "+na1$+" is not compatible with "+na2$)
              ELSE
                exi!=TRUE
                l!=FALSE
                d_free
                i_zeile("Convert "+na2$+" to "+l$+"."+MID$(na1$,RINSTR(na1$,CHR$(46))+1))
                conf_timer(-1)
                OPEN "I",#1,pd$+na2$
                OPEN "O",#2,pd$+l$+"."+MID$(na1$,RINSTR(na1$,CHR$(46))+1)
                OPEN "I",#3,pd$+na1$
                conv_diff
                CLOSE #1
                PRINT #2;CHR$(26);
                CLOSE #2
                CLOSE #3
                conf_timer(0)
                IF v.cd!
                  copy(pd$+na1$,cfg.k$(10))
                ENDIF
                IF v.dd!
                  del_file(pd$+na1$)
                ENDIF
                IF v.lbu!
                  IF v.var!(16)
                    i_zeile("Create "+na2$+"-BackUp ("+MID$(na2$,1,5)+".OLD)")
                  ENDIF
                  d_file(pd$+MID$(na2$,1,5)+".OLD")
                  RENAME pd$+na2$ AS pd$+MID$(na2$,1,5)+".OLD"
                ELSE
                  del_file(pd$+na2$)
                ENDIF
                darca%=a%
              ENDIF
            ENDIF
            ERASE z2$()
          NEXT darca%
        ELSE
          f_zeile("!  Can't find "+pd$+l$+".*")
        ENDIF
        EXIT IF darca%=a%
      LOOP
      ERASE z$(),z1$(),z2$()
      IF l!
        f_zeile("?  Can't find a compatible "+npd$)
      ENDIF
    ELSE
      f_zeile("!  Can't find "+pd$+npd$+".*")
    ENDIF
  ELSE
    exi!=TRUE
  ENDIF
RETURN
'
PROCEDURE conv_diff
  LOCAL a_anz%
  REPEAT
    RECALL #3,z1$(),1,dummy%
    SELECT ASC(LEFT$(z1$(0)))
    CASE 65                   ! A
      a_anz%=VAL(MID$(z1$(0),2))
      DIM a_a$(a_anz%-1)
      RECALL #3,a_a$(),a_anz%,dummy%
      STORE #2,a_a$()
      ERASE a_a$()
    CASE 67                   ! C
      a_anz%=VAL(MID$(z1$(0),2))
      DIM a_a$(a_anz%-1)
      RECALL #1,a_a$(),a_anz%,dummy%
      STORE #2,a_a$()
      ERASE a_a$()
    CASE 68                   ! D
      a_anz%=VAL(MID$(z1$(0),2))
      DIM a_a$(a_anz%-1)
      RECALL #1,a_a$(),a_anz%,dummy%
      ERASE a_a$()
    ENDSELECT
  UNTIL EOF(#3)
RETURN
'
PROCEDURE d_free
  IF DFREE(0)<=n1a%+n2a%
    f_zeile("?  Not enough space on disc/partition !!!")
    log_end
    DELAY del|
    end_screen(3)
  ENDIF
RETURN
'
PROCEDURE copy(source$,dest$)
  LOCAL anz%,file1$,file2$,handle%
  var%=FSFIRST(source$,0)
  ns$=MID$(source$,RINSTR(source$,CHR$(92))+1)
  source$=MID$(source$,1,RINSTR(source$,CHR$(92)))
  IF var%=0
    REPEAT
      IF var%=0
        anz%=0
        ns$=CHAR{FGETDTA()+30}
        fl%={FGETDTA()+26}
        f%=FRE(0)
        IF f%<32000
          f_zeile("?  Not enough memory !!!")
          var%=-1
        ELSE
          IF DFREE(ASC(LEFT$(UPPER$(dest$)))-64)<fl%
            f_zeile("?  Not enough space on "+LEFT$(UPPER$(dest$))+":\ !!!")
          ELSE
            IF v.var!(16)
              i_zeile("Copy "+UPPER$(source$+ns$))
              i_zeile("  to "+UPPER$(dest$+ns$))
            ENDIF
            IF fl%>32000
              m%=INT(fl%/32000)
              buff$=SPACE$(32000)
              OPEN "I",#1,source$+ns$
              BGET #1,VARPTR(buff$),32000
              CLOSE #1
              OPEN "O",#2,dest$+ns$
              BPUT #2,VARPTR(buff$),32000
              CLOSE #2
              buff$=""
              fl%=fl%-32000
              OPEN "I",#1,source$+ns$
              RELSEEK #1,32000
              OPEN "A",#2,dest$+ns$
              REPEAT
                IF fl%>32000
                  frei%=32000
                  fl%=fl%-32000
                  buff$=SPACE$(frei%)
                ELSE
                  frei%=fl%
                  buff$=SPACE$(frei%)
                ENDIF
                BGET #1,VARPTR(buff$),frei%
                BPUT #2,VARPTR(buff$),frei%
                buff$=""
                INC anz%
              UNTIL anz%=m%
              CLOSE #1
              CLOSE #2
            ELSE
              buff$=SPACE$(fl%)
              BLOAD source$+ns$,VARPTR(buff$)
              BSAVE dest$+ns$,VARPTR(buff$),fl%
              buff$=""
            ENDIF
            '
            file1$=source$+ns$                              ! Lesen
            file2$=dest$+ns$                                ! Schreiben
            '
            buffer$=SPACE$(4)
            '
            handle%=GEMDOS(61,L:VARPTR(file1$),0)           ! Lesen
            ~GEMDOS(87,L:VARPTR(buffer$),handle%,0)
            ~GEMDOS(62,handle%)
            '
            handle%=GEMDOS(61,L:VARPTR(file2$),1)           ! Schreiben
            ~GEMDOS(87,L:VARPTR(buffer$),handle%,1)
            ~GEMDOS(62,handle%)
            '
            buffer$=""
          ENDIF
          var%=FSNEXT()
        ENDIF
      ENDIF
    UNTIL var%<>0
  ELSE
    IF ext!=FALSE OR (v.var!(16) AND ext!)
      f_zeile("!  Can't find "+source$+ns$+" to copy")
    ENDIF
  ENDIF
RETURN
'
PROCEDURE check
  IF RIGHT$(pd$)<>CHR$(92)
    f_zeile("?  Error in CFG-File (DIFF-Dir) !!!")
    log_end
    DELAY del|
    end_screen(2)
  ENDIF
  IF (LEN(npd$)=0 OR LEN(npd$)>8) OR (LEN(l$)=0 OR LEN(l$)>8)
    f_zeile("?  Error in CFG-File (DIFF-/LIST-Name) !!!")
    log_end
    DELAY del|
    end_screen(2)
  ENDIF
RETURN
'
PROCEDURE close_screen
  CLOSEW 2
  CLOSEW 1
  CLOSEW 0
  CLS
RETURN
'
PROCEDURE end_screen(q%)
  close_screen
  QUIT q%
RETURN
'
' ********************  PROCEDUREs fuer POINT-Act  ************************
PROCEDURE point_act
  pd$=cfg.k$(0)
  npd$=cfg.k$(1)
  l$=cfg.k$(2)
  v.dpd!=v.var!(2)
  v.dd!=v.var!(4)
  v.cpd!=v.var!(6)
  v.cd!=v.var!(8)
  v.lbu!=v.var!(10)
  v.durch!=v.var!(14)
  ce.var!=ppoint.var!
  i_zeile(st$+pu$)
  IF v.var!(26)
    npd$=cfg.k$(2)
    IF k.var!(0)=FALSE OR k.var!(2)=FALSE OR k.var!(3)=FALSE
      f_zeile("?  ERROR in CFG-File (POINT)")
      i_zeile(en$+pu$)
      IF v.var!(1)=FALSE
        log_end
        end_screen(2)
      ELSE
        z.var!=TRUE
      ENDIF
    ENDIF
  ELSE
    FOR anz%=0 TO 3
      IF k.var!(anz%)=FALSE
        f_zeile("?  ERROR in CFG-File (POINT)")
        i_zeile(en$+pu$)
        anz%=3
        IF v.var!(1)=FALSE
          log_end
          end_screen(2)
        ELSE
          z.var!=TRUE
        ENDIF
      ENDIF
    NEXT anz%
  ENDIF
  check
  IF z.var!=FALSE
    check_entpacken(npd$)
  ENDIF
  IF exi! OR v.durch!
    IF k.var!(7) AND v.t!=FALSE
      test(pd$+cfg.k$(2)+".*")
      IF var1%=0 AND suffix%<>0
        cfg.k$(2)=pf$
        dim.gl%=f.l%/25
        i_zeile("Load "+pd$+cfg.k$(2))
        convertiere
        anz%=0
        delete_diff(cfg.k$(10)+npd$+".*")
      ELSE
        f_zeile("!  Can't find "+pd$+l$+".*")
      ENDIF
    ENDIF
  ENDIF
  anz%=0
  IF point.var! AND exi!
    DIM pre$(15)
    ext!=TRUE
    i_zeile("POINT"+act$+"...")
    REPEAT
      pre$(anz%)=point$(anz%)
      utility("POINT",10)
      INC anz%
    UNTIL anz%=16 OR point$(anz%)=CHR$(255)
    i_zeile("...POINT"+act$)
    ext!=FALSE
  ENDIF
  ERASE pre$(),point$()
  i_zeile(en$+pu$)
RETURN
'
PROCEDURE convertiere
  DIM agl$(dim.gl%),new.list$(dim.gl%)
  OPEN "I",#1,cfg.k$(0)+cfg.k$(2)
  RECALL #1,agl$(),dim.gl%,dummy%
  CLOSE #1
  IF RIGHT$(cfg.k$(7))=CHR$(92)
    f_zeile("?  Error in CFG-File (UserList-Name) !!!")
    log_end
    DELAY del|
    end_screen(2)
  ENDIF
  i_zeile("Convert "+cfg.k$(2)+" to "+MID$(cfg.k$(7),RINSTR(cfg.k$(7),CHR$(92))+1))
  a%=0
  anz%=0
  conf_timer(-1)
  REPEAT
    zeile$=agl$(anz%)
    IF RINSTR(zeile$,"_")<>0 AND LEFT$(zeile$)<>";"
      nn$=MID$(zeile$,RINSTR(zeile$,"_")+1)
      nn$=MID$(nn$,1,INSTR(nn$,","))
      vn$=MID$(zeile$,1,RINSTR(zeile$,"_")-1)
      vn$=MID$(vn$,RINSTR(vn$,",")+1)
      IF UPPER$(MID$(zeile$,1,5))="HOST,"
        node$=MID$(zeile$,INSTR(zeile$,","))
        node$=MID$(node$,INSTR(node$,",")+1)
        node$=MID$(node$,INSTR(node$,",")+1)
        node$=MID$(node$,1,INSTR(node$,",")-1)
        new.list$(a%)=nn$+" "+vn$+SPACE$(45-LEN(nn$+vn$))+node$
        INC a%
      ELSE IF LEFT$(zeile$)="," AND VAL(MID$(zeile$,2,1))<>0
        add$=MID$(zeile$,2)
        add$=MID$(add$,1,INSTR(add$,",")-1)
        add$=node$+"."+add$
        new.list$(a%)=nn$+" "+vn$+SPACE$(45-LEN(nn$+vn$))+add$
        INC a%
      ENDIF
    ENDIF
    INC anz%
  UNTIL agl$(anz%+1)=""
  conf_timer(0)
  '
  ERASE agl$()
  DIM n.l$(a%-1)
  REPEAT
    n.l$(a1%)=new.list$(a1%)
    INC a1%
  UNTIL new.list$(a1%)=""
  ERASE new.list$()
  '
  QSORT n.l$()
  IF EXIST(cfg.k$(7))
    IF v.var!(12)
      IF v.var!(16)
        i_zeile("Create "+MID$(cfg.k$(7),RINSTR(cfg.k$(7),CHR$(92))+1)+"-BackUp (*.OLD)")
      ENDIF
      d_file(MID$(cfg.k$(7),1,RINSTR(cfg.k$(7),CHR$(46)))+"OLD")
      RENAME cfg.k$(7) AS MID$(cfg.k$(7),1,RINSTR(cfg.k$(7),CHR$(46)))+"OLD"
    ENDIF
  ENDIF
  i_zeile("Create "+cfg.k$(7))
  OPEN "O",#1,cfg.k$(7)
  STORE #1,n.l$()
  CLOSE #1
  ERASE n.l$()
RETURN
'
PROCEDURE ppoint
  anz%=0
  DIM pre$(15)
  ext!=TRUE
  i_zeile("PRE-POINT"+act$+"...")
  REPEAT
    pre$(anz%)=ppoint$(anz%)
    utility("PPOINT",11)
    INC anz%
  UNTIL anz%=16 OR ppoint$(anz%)=CHR$(255)
  i_zeile("...PRE-POINT"+act$)
  ext!=FALSE
  ERASE pre$(),ppoint$()
RETURN
' ********************  PROCEDUREs fuer NODE-Act   ************************
PROCEDURE node_act
  pd$=cfg.k$(4)
  npd$=cfg.k$(5)
  l$=cfg.k$(6)
  v.dpd!=v.var!(3)
  v.dd!=v.var!(5)
  v.cpd!=v.var!(7)
  v.cd!=v.var!(9)
  v.lbu!=v.var!(11)
  v.durch!=v.var!(15)
  ce.var!=pnode.var!
  f!=TRUE
  i_zeile(st$+nu$)
  IF v.var!(27)
    npd$=cfg.k$(6)
    IF k.var!(4)=FALSE OR k.var!(6)=FALSE OR k.var!(3)=FALSE
      f_zeile("?  ERROR in CFG-File (NODE)")
      i_zeile(en$+nu$)
      IF v.var!(1)=FALSE
        log_end
        end_screen(2)
      ELSE
        z.var!=TRUE
      ENDIF
    ENDIF
  ELSE
    FOR anz%=0 TO 3
      IF k.var!(anz%)=FALSE
        f_zeile("?  ERROR in CFG-File (NODE)")
        i_zeile(en$+nu$)
        anz%=3
        IF v.var!(1)=FALSE
          log_end
          end_screen(2)
        ELSE
          z.var!=TRUE
        ENDIF
      ENDIF
    NEXT anz%
  ENDIF
  check
  IF z.var!=FALSE
    check_entpacken(npd$)
  ENDIF
  IF exi! OR v.durch!
    IF k.var!(9) AND v.t!=FALSE
      delete_diff(cfg.k$(10)+npd$+".*")
      IF VAL(LEFT$(cfg.k$(9)))>0 AND VAL(MID$(cfg.k$(9),3,2))>0
        z$=LEFT$(cfg.k$(9))
        r$=MID$(cfg.k$(9),3,2)
        i_zeile("Create a little NODELIST ("+LEFT$(cfg.k$(9))+":"+MID$(cfg.k$(9),3,2)+")")
        test(cfg.k$(4)+cfg.k$(6)+".*")
        my_list
      ELSE IF VAL(LEFT$(cfg.k$(9)))>0 AND MID$(cfg.k$(9),3,3)="ALL"
        z$=LEFT$(cfg.k$(9))
        i_zeile("Create a little NODELIST ("+LEFT$(cfg.k$(9))+":"+"ALL)")
        test(cfg.k$(4)+cfg.k$(6)+".*")
        big_list
      ELSE
        f_zeile("?  ERROR in CFG-File (MNL)")
      ENDIF
    ENDIF
    IF v.t!=FALSE AND v.var!(13)
      prg$=cfg.p$(0)
      lauf$=LEFT$(prg$)
      dr$=MID$(cfg.k$(4),INSTR(cfg.k$(4),CHR$(92)))
      IF RINSTR(dr$,CHR$(92))<>0
        dr$=MID$(dr$,1,RINSTR(dr$,CHR$(92))-1)
      ELSE
        dr$=""
      ENDIF
      IF INSTR(prg$,CHR$(32))=0
        comm$=""
      ELSE
        comm$=MID$(prg$,INSTR(prg$,CHR$(32)))
        prg$=MID$(prg$,1,INSTR(prg$,CHR$(32)))
      ENDIF
      prg$=MID$(prg$,RINSTR(prg$,CHR$(92))+1)
      prg$=MID$(prg$,1,RINSTR(prg$,CHR$(46))+3)
      test(pd$+npd$+".*")
      i_zeile("Compile "+pf$+" with "+prg$)
      starte
    ENDIF
  ENDIF
  anz%=0
  IF node.var! AND exi!
    DIM pre$(15)
    ext!=TRUE
    i_zeile("NODE"+act$+"...")
    REPEAT
      pre$(anz%)=node$(anz%)
      utility("NODE",9)
      INC anz%
    UNTIL anz%=16 OR node$(anz%)=CHR$(255)
    i_zeile("...NODE"+act$)
    ext!=FALSE
  ENDIF
  ERASE pre$(),node$()
  i_zeile(en$+nu$)
RETURN
'
PROCEDURE my_list
  i_zeile("Create MNL"+cfg.k$(9)+"."+STRING$(3-LEN(STR$(suffix%)),CHR$(48))+STR$(suffix%))
  d_file(cfg.k$(4)+"MNL"+cfg.k$(9)+".*")
  var!=FALSE
  DIM n.a$(0)
  OPEN "O",#2,cfg.k$(4)+"mnl"+cfg.k$(9)+"."+STRING$(3-LEN(STR$(suffix%)),CHR$(48))+STR$(suffix%)
  OPEN "I",#1,cfg.k$(4)+pf$
  REPEAT
    RECALL #1,n.a$(),1,dummy%
    IF MID$(n.a$(0),1,6)="Zone,"+z$
      PRINT #2,CHR$(59)
      var!=TRUE
    ENDIF
  UNTIL var! OR EOF(#1)
  IF var!
    var!=FALSE
    REPEAT
      PRINT #2,n.a$(0)
      RECALL #1,n.a$(),1,dummy%
      IF MID$(n.a$(0),1,7)="Region,"
        var!=TRUE
      ENDIF
    UNTIL var! OR EOF(#1)
    IF var!
      var!=FALSE
      REPEAT
        IF MID$(n.a$(0),1,9)="Region,"+r$
          var!=TRUE
        ELSE
          RECALL #1,n.a$(),1,dummy%
        ENDIF
      UNTIL var!=TRUE OR EOF(#1)
    ENDIF
    IF var!
      REPEAT
        PRINT #2,n.a$(0)
        RECALL #1,n.a$(),1,dummy%
      UNTIL MID$(n.a$(0),1,7)="Region," OR MID$(n.a$(0),1,5)="Zone," OR EOF(#1)
    ENDIF
  ENDIF
  CLOSE #1
  CLOSE #2
  ERASE n.a$()
  IF v.var!(0) AND v.var!(13) AND nl!=FALSE
    npd$="MNL"+cfg.k$(9)
  ENDIF
RETURN
'
PROCEDURE big_list
  i_zeile("Create MNL"+cfg.k$(9)+"."+STRING$(3-LEN(STR$(suffix%)),CHR$(48))+STR$(suffix%))
  d_file(cfg.k$(4)+"MNL"+cfg.k$(9)+".*")
  var!=FALSE
  DIM n.a$(0)
  OPEN "O",#2,cfg.k$(4)+"mnl"+cfg.k$(9)+"."+STRING$(3-LEN(STR$(suffix%)),CHR$(48))+STR$(suffix%)
  OPEN "I",#1,cfg.k$(4)+pf$
  REPEAT
    RECALL #1,n.a$(),1,dummy%
    IF MID$(n.a$(0),1,6)="Zone,"+z$
      PRINT #2,CHR$(59)
      var!=TRUE
    ENDIF
  UNTIL var! OR EOF(#1)
  IF var!
    REPEAT
      PRINT #2,n.a$(0)
      RECALL #1,n.a$(),1,dummy%
    UNTIL MID$(n.a$(0),1,5)="Zone," OR EOF(#1)
  ENDIF
  CLOSE #2
  CLOSE #1
  ERASE n.a$()
  IF v.var!(0) AND v.var!(13) AND nl!=FALSE
    npd$="MNL"+cfg.k$(9)
  ENDIF
RETURN
'
PROCEDURE pnode
  anz%=0
  DIM pre$(15)
  ext!=TRUE
  i_zeile("PRE-NODE"+act$+"...")
  REPEAT
    pre$(anz%)=pnode$(anz%)
    utility("PNODE",10)
    INC anz%
  UNTIL anz%=16 OR pnode$(anz%)=CHR$(255)
  i_zeile("...PRE-NODE"+act$)
  ext!=FALSE
  ERASE pre$(),pnode$()
RETURN
'
' ********************  PROCEDUREs fuer LIST-NODES  ***********************
PROCEDURE zone_list
  IF k.var!(4) AND k.var!(6)
    test(cfg.k$(4)+cfg.k$(6)+".*")
    IF suffix%=0
      f_zeile("?  Can't find a NODELIST !!!")
      log_end
      end_screen(1)
    ENDIF
    make_list
  ELSE
    f_zeile("?  ERROR in CFG-File (NODE)")
    log_end
    end_screen(2)
  ENDIF
RETURN
'
PROCEDURE make_list
  LOCAL d%,anz%,anz1%
  d%=150
  DIM n.l$(d%)
  i_zeile("Analysing "+cfg.k$(4)+pf$)
  OPEN "I",#1,cfg.k$(4)+pf$
  RECALL #1,n.l$(),d%+1,dummy%
  list.zone$=cfg.k$(4)+"LISTZONE.DAT"
  i_zeile("and creating "+cfg.k$(4)+"LISTZONE.DAT")
  OPEN "O",#2,list.zone$
  REPEAT
    IF MID$(n.l$(anz%),1,5)="Zone,"
      z$=MID$(n.l$(anz%),6,1)
      zn$=MID$(n.l$(anz%),8)
      zn$=MID$(zn$,1,INSTR(zn$,CHR$(44))-1)
      del_space(zn$)
      i_zeile(z$+" ( "+neu_ds$+" )")
      PRINT #2,"ZONE ";z$;" ( ";neu_ds$;" )"
      neu_ds$=""
      ds$=""
      INC anz1%
      REPEAT
        IF MID$(n.l$(anz%),1,7)="Region,"
          r$=MID$(n.l$(anz%),8,2)
          rn$=MID$(n.l$(anz%),11)
          rn$=MID$(rn$,1,INSTR(rn$,CHR$(44))-1)
          del_space(rn$)
          PRINT #2;r$;"  ";neu_ds$
          neu_ds$=""
          ds$=""
        ENDIF
        INC anz%
        IF d%=anz%
          ERASE n.l$()
          DIM n.l$(d%)
          RECALL #1,n.l$(),d%+1,dummy%
          anz%=0
        ENDIF
      UNTIL MID$(n.l$(anz%),1,5)="Zone," OR n.l$(anz%)=""
      PRINT #2
      anz%=anz%-2
    ELSE
      INC anz%
      IF d%=anz%
        ERASE n.l$()
        DIM n.l$(d%)
        RECALL #1,n.l$(),d%+1,dummy%
        anz%=0
      ENDIF
    ENDIF
  UNTIL n.l$(anz%)=""
  CLOSE #1
  CLOSE #2
  i_zeile("Ready to analyse "+pf$)
  IF EXIST(list.zone$)
    IF {FGETDTA()+26}=0
      KILL list.zone$
    ENDIF
  ENDIF
RETURN
'
PROCEDURE del_space(ds$)
  FOR r%=1 TO LEN(ds$)+1
    IF MID$(ds$,r%,1)=CHR$(95)
      neu_ds$=neu_ds$+CHR$(32)
    ELSE
      neu_ds$=neu_ds$+MID$(ds$,r%,1)
    ENDIF
  NEXT r%
RETURN
'
' ************************************************************************
' ************************************************************************
