'                                               Version vom 09.09.87      17:30
ON BREAK GOSUB break
DEFLIST 0
OPENW 0
GOSUB initall
ON ERROR GOSUB fehler
GOSUB edit
'
PROCEDURE initall
  ON ERROR GOSUB initerror
  filemax%=1000
  DIM takt$(2),takte$(2,filemax%),taktbuf$(2),volume%(2),tsave$(2)
  ARRAYFILL volume%(),11
  pfad$="\STUECKE.MUS\"
  IF NOT EXIST(pfad$+"*.MUS")
    pfad$="\"
  ENDIF
  y1%=60              ! Zeilenabstand
  okt%=4              ! Verschiebt oktavenweise
  y0%=60              ! oberste Zeile
  x0%=8               ! linker Rand
  dist%=4             ! Abstand zwischen Noten in Bytes (gerade Anzahl!)
  GOSUB initmenu
  GOSUB initmc
  GOSUB initmouse
  GOSUB initplot
  GOSUB initedit
  GOSUB initcomp
RETURN
'
PROCEDURE initerror
  IF ERR=-33
    ALERT 3,"Das file 'MUSIC.IMG' muû sich|im selben Ordner befinden,|von dem aus das Programm|gestartet wurde!",1,"Abbruch",dummy
  ENDIF
  RESUME
RETURN
'
PROCEDURE edit
  LOCAL i%,j%,x%,y%,k%,laenge%,hoehe%,hals%,not$,laenge$,oktave$
  LOCAL punkt$
  MENU grundmenue$()
  ON MENU  GOSUB grundmenue
  laenge%=8
  FOR i%=0 TO 2
    takt$(i%)=takte$(i%,filep%)
  NEXT i%
  PRINT AT(1,3);"Taktnr. ";filep%,,
  GOSUB headline
  IF LEN(takt$(1)+takt$(2)+takt$(0))<>0
    @plottakt(yedit%(0)-1,abst%)
  ELSE
    FOR i%=0 TO 2
      @drawline(yedit%(i%)-1)
      @schluessel(yedit%(i%))
    NEXT i%
    @taktstrich(lrand%-2,yedit%(0),abst%)
  ENDIF
  CLR y0hilfsalt%
  DEFMOUSE mouse$(laenge%)
  DEFTEXT ,1,,13
  RBOX 220,360,300,379
  TEXT 230,375,62,"ZurÅck"
  RBOX 300,360,380,379
  TEXT 310,375,62,"Weiter"
  DEFTEXT ,0,,13
  @disable
  DO
    MOUSE x%,y%,k%
    neu!=FALSE
    IF y%>=400
      GOSUB edithilfs(x%-16*(laenge%=22 OR laenge%=23),yedit%(0),yedit%(0))
      CLR y0hilfsalt%
      DEFMOUSE 3
      no_menue!=TRUE
      REPEAT
        MOUSE x%,y%,k%
        ON MENU
      UNTIL y%<400 AND MENU(9)=34
      DEFMOUSE mouse$(laenge%)
      IF NOT no_menue!
        IF neu!
          @eraeditfeld
          FOR i%=0 TO 2
            takt$(i%)=takte$(i%,filep%)
          NEXT i%
          PRINT AT(1,3);"Taktnr. ";filep%,,
        ENDIF
        @plottakt(yedit%(0)-1,abst%)
      ENDIF
    ELSE
      IF y%>360 AND x%>220 AND x%<380 AND k%                 !ZurÅck/Weiter
        CLR y0hilfsalt%
        IF edflag!
          IF filep%<maxfilep%
            @ask
          ELSE
            @put_t_to_taktfeld
            @insert
          ENDIF
          CLR edflag!
        ENDIF
        IF x%<300                           !ZurÅck
          filep%=MAX(0,filep%-1)
          @find_akt_vorz
        ELSE                                !Weiter
          filep%=MIN(maxfilep%,filep%+1)
        ENDIF
        PRINT AT(1,3);"Taktnr. ";filep%,,
        @eraeditfeld
        FOR i%=0 TO 2
          takt$(i%)=takte$(i%,filep%)
        NEXT i%
        @plottakt(yedit%(0)-1,abst%)
      ELSE
        IF y%<27 AND x%<24*26 AND k%=1
          IF x% DIV 24<>laenge%
            PRINT CHR$(7);
            laenge%=x% DIV 24
            DEFMOUSE mouse$(laenge%)
          ENDIF
        ENDIF
        chan%=-(y%>grenz1%)-(y%>grenz2%)
        IF k%=0
          GOSUB edithilfs(x%-16*(laenge%=22 OR laenge%=23),MIN(MAX(y%,grenz0%),grenz3%),yedit%(chan%)-1)
        ENDIF
        IF k%<>0 AND y%>grenz0% AND y%<grenz3%
          IF x%>=lrand%*8
            CLR y0hilfsalt%
            CLR vorz$
            IF laenge%>=22 AND laenge%<=25
              ADD x%,16
              not$=t$(chan%,x% DIV 16)       ! schlechter Stil ...
              CLR oktave$,laenge$,punkt$
              vorz$="b"
              IF laenge%=23
                vorz$="#"
              ENDIF
              IF laenge%=24
                vorz$="›"
              ENDIF
              IF laenge%=25
                vorz$="@"
              ENDIF
              t$(chan%,x% DIV 16)=vorz$
            ELSE
              IF laenge%<14
                ADD y%,2
                hoehe%=(y%-yedit%(chan%)+33)/3            ! hîchstes C
                not$=noten$(7-(hoehe% MOD 7))
                oktave$=STR$(maxokt%-(hoehe% DIV 7)-(not$="C"))
                laenge$=STR$((laenge% DIV 2)+1)
              ELSE
                not$="P"
                oktave$="P"
                y%=yedit%(chan%)
                laenge$=STR$((laenge% DIV 2)-5)
              ENDIF
              CLR punkt$,vorz$
              IF ODD(laenge%)
                punkt$="."
              ENDIF
            ENDIF
            edflag!=TRUE
            replace!=t$(chan%,x% DIV 16)<>""
            IF k%=1
              t$(chan%,x% DIV 16)=vorz$+not$+oktave$+laenge$+punkt$
            ELSE
              t$(chan%,x% DIV 16)=""
            ENDIF
            IF replace!
              @put_t_to_taktfeld
              @plottakt(yedit%(0)-1,abst%)
            ELSE
              IF k%=1
                IF y%>yedit%(chan%)+12
                  hals%=1
                ELSE
                  hals%=-1
                ENDIF
                HIDEM
                @plotnote(laenge%,hals%,TRUE,2*(x% DIV 16),3*(y% DIV 3),vorz$)
                SHOWM
              ENDIF
            ENDIF
            REPEAT
            UNTIL MOUSEK=0
          ELSE
            IF laenge%>=22 AND laenge%<=24
              WHILE y%>grenz1%
                SUB y%,abst%
              WEND
              IF y%>=yedit%(0)-6 AND y%<yedit%(0)+30 AND x% DIV 8<lrand%-4
                hoehe%=(y%-yedit%(0)+2-(laenge%=22)) DIV 3
                not$=CHR$(97+(6-(hoehe% MOD 7)))
                IF not$="b"
                  not$="h"
                ENDIF
                vorz$="›"
                IF laenge%=23
                  vorz$="#"
                ENDIF
                IF laenge%=22
                  vorz$="b"
                ENDIF
                @put_t_to_taktfeld
                IF LEFT$(takt$(0),2)="c›"
                  takt$(0)=MID$(takt$(0),3)
                ENDIF
                takt$(0)=not$+vorz$+takt$(0)
                IF k%=2 OR vorz$="›"
                  WHILE LEFT$(takt$(0))>="a" AND LEFT$(takt$(0))<="h" AND LEFT$(takt$(0))<>"b"
                    takt$(0)=MID$(takt$(0),3)
                  WEND
                  @clear_vorz
                ENDIF
                IF vorz$="›" AND k%=1
                  takt$(0)="c›"+takt$(0)
                ENDIF
                @plottakt(yedit%(0)-1,abst%)
                edflag!=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      inp$=INKEY$
      IF inp$=" "
        CLR y0hilfsalt%
        @put_t_to_taktfeld
        @plottakt(yedit%(0)-1,abst%)
      ELSE
        IF RIGHT$(inp$)=CHR$(&H62)
          @anleitung
        ENDIF
      ENDIF
    ENDIF
  LOOP
  @put_t_to_taktfeld
  DEFMOUSE 0
RETURN
'
PROCEDURE edithilfs(x%,y%,y0%)
  LOCAL i%,xtemp%
  xtemp%=x% AND &HFFFFFFF0
  IF xtemp%<>xhilfsalt% OR y%<>yhilfsalt%
    GRAPHMODE 3
    IF y0hilfsalt%<>0
      FOR i%=y0hilfsalt% TO yhilfsalt% STEP stephilfsalt%
        LINE xhilfsalt%-2,i%,xhilfsalt%+10,i%
      NEXT i%
    ENDIF
    xhilfsalt%=xtemp%
    yhilfsalt%=y%
    CLR y0hilfsalt%
    IF y%<y0%-4
      FOR i%=y0%-6 TO y% STEP -6
        LINE xhilfsalt%-2,i%,xhilfsalt%+10,i%
      NEXT i%
      stephilfsalt%=-6
      y0hilfsalt%=y0%-6
    ENDIF
    IF y%>y0%+28
      FOR i%=y0%+30 TO y% STEP 6
        LINE xhilfsalt%-2,i%,xhilfsalt%+10,i%
      NEXT i%
      stephilfsalt%=6
      y0hilfsalt%=y0%+30
    ENDIF
    GRAPHMODE 1
  ENDIF
RETURN
'
PROCEDURE put_t_to_taktfeld
  LOCAL i%,j%,t$,k%
  FOR i%=0 TO 2
    t$=""
    FOR j%=0 TO 40
      t$=t$+t$(i%,j%)
      t$(i%,j%)=""
    NEXT j%
    k%=1
    WHILE MID$(t$,k%,1)>="a" AND MID$(t$,k%,1)<="h"
      ADD k%,2
    WEND
    REPEAT
      j%=INSTR(t$,"#@",k%) OR INSTR(t$,"b@",k%) OR INSTR(t$,"›@",k%)
      IF j%
        MID$(t$,j%,2)="@"+MID$(t$,j%,1)
      ENDIF
    UNTIL j%=0
    FOR j%=k% TO LEN(t$)-1
      temp$=MID$(t$,j%,1)
      IF temp$="#" OR temp$="b" OR temp$="›"
        temp2$=MID$(t$,j%+1,1)
        IF temp2$="#" OR temp2$="b" OR temp2$="›"
          t$=LEFT$(t$,j%)+MID$(t$,j%+2)
        ENDIF
        IF temp2$="P"
          t$=LEFT$(t$,j%-1)+MID$(t$,j%+1)
        ENDIF
      ENDIF
    NEXT j%
    IF RIGHT$(t$)="b" OR RIGHT$(t$)="#" OR RIGHT$(t$)="›" OR RIGHT$(t$)="@"
      IF MID$(t$,LEN(t$)-1,1)>"h" OR MID$(t$,LEN(t$)-1,1)<"a"
        t$=LEFT$(t$,LEN(t$)-1)
      ENDIF
    ENDIF
    takt$(i%)=t$+"|"
  NEXT i%
RETURN
'
PROCEDURE headline
  LOCAL laenge%
  DEFFILL 0
  HIDEM
  PBOX 0,0,639,32
  LINE 0,27,639,27
  FOR laenge%=0 TO 21
    IF laenge%<14
      y%=24
    ELSE
      y%=8
    ENDIF
    @plotnote(laenge%,1,TRUE,laenge%*2,y%,"")
  NEXT laenge%
  INC laenge%
  y%=16
  @plotvorz(laenge%*2,y%,0)
  @plotvorz(laenge%*2+2,y%,1)
  @plotvorz(laenge%*2+4,y%,2)
  DEFTEXT ,1,,6
  TEXT (laenge%*2+6)*8,y%,"3"
  DEFTEXT ,0,,13
  x%=0
  FOR i%=1 TO laenge%+1
    GET x%,19,639-8,26+19,temp$
    PBOX x%,0,x%+8,26
    PUT x%+8,19,temp$
    ADD x%,24
  NEXT i%
  SHOWM
RETURN
'
PROCEDURE plottakt(y0%,y1%)
  LOCAL x%,i%,xmin%,v%,tsave$
  DIM index%(2)
  tsave$=takt$(0)
  ARRAYFILL index%(),1
  ARRAYFILL c%(),0
  DEFFILL 0
  HIDEM
  PBOX 0,y0%-35,639,y0%+3*y1%
  IF LEFT$(takt$(0))>="a" AND LEFT$(takt$(0))<="h" AND LEFT$(takt$(0))<>"b"
    @set_glob_vorz
    PRINT AT(50,3);"Vorzeichen in Taktnr. ";filep%;"  "
  ENDIF
  @put_glob_vorz
  @taktstrich(lrand%-1,yedit%(0),abst%)
  IF LEN(takt$(1)+takt$(2)+takt$(0))=0
    FOR i%=0 TO 2
      @drawline(y0%+i%*y1%)
      @schluessel(y0%+i%*y1%)
    NEXT i%
  ELSE
    FOR i%=0 TO 2
      @drawline(i%*y1%+y0%)           ! Notenzeile
      @schluessel(i%*y1%+y0%)
      @gettakt(i%,takt$(i%))          ! belegt Felder fÅr Tonkanal i% (s. gettakt)
    NEXT i%
    x%=lrand%
    ADD x%,2
    ' Ordnet Noten der drei KanÑle passend nach Dauer untereinander an
    WHILE c%(0)<>count%(0) OR c%(1)<>count%(1) OR c%(2)<>count%(2)
      xmin%=MIN(x%(0,c%(0)),x%(1,c%(1)),x%(2,c%(2)))
      FOR i%=0 TO 2
        j%=c%(i%)
        IF x%(i%,j%)=xmin%
          @restore_t_string(i%,x% DIV 2)
          vorz$=vorz$(vorz%(i%,j%))
          '
          IF triole!(i%,j%)
            @plottriole(i%,x%)
          ENDIF
          @plotnote(laenge%(i%,j%),hhals%(i%,j%),sep!(i%,j%),x%,y0%+y1%*i%+y%(i%,j%),vorz$)
          @hilfszeilen(y1%*i%+y0%,x%,y%(i%,j%))
          INC c%(i%)
        ENDIF
      NEXT i%
      ADD x%,dist%
    WEND
    @taktstrich(x%,y0%,y1%)
  ENDIF
  takt$(0)=tsave$
  ERASE index%()
  SHOWM
RETURN
'
PROCEDURE plottriole(chan%,x%)
  DEFTEXT ,1,,6
  TEXT x%*8-2,y0%+y1%*chan%+y%(chan%,j%),"3"
  DEFTEXT ,0,,13
RETURN
'
PROCEDURE put_glob_vorz
  LOCAL j%,h%
  FOR j%=5 TO 29 STEP 4
    h%=j% MOD 7
    IF vorzeichen$(h%)<>""
      FOR i%=0 TO 2
        y%=15-3*h%+yedit%(i%)
        @plotvorz(j% DIV 4+3,y%,-(vorzeichen$(h%)="#")-2*vorzeichen$(h%)="›")
      NEXT i%
    ENDIF
  NEXT j%
RETURN
'
PROCEDURE plotvorz(x%,y%,v%)
  LOCAL k%,bildadr%
  bildadr%=XBIOS(2)+(y%-10+v%+19)*80+x%-1
  FOR k%=0 TO 15
    POKE bildadr%,PEEK(bildadr%) OR vorzplot%(v%,k%)
    ADD bildadr%,80
  NEXT k%
RETURN
'
PROCEDURE restore_t_string(chan%,x%)
  LOCAL t$,temp$
  t$=MID$(takt$(chan%),index%(chan%),3)
  ADD index%(chan%),3
  temp$=MID$(takt$(chan%),index%(chan%),1)
  WHILE temp$<>"@" AND temp$<>"|" AND temp$<>"b" AND temp$<>"#" AND temp$<>"›" AND (temp$<"A" OR temp$>"P")
    t$=t$+temp$
    INC index%(chan%)
    temp$=MID$(takt$(chan%),index%(chan%),1)
  WEND
  IF x%>40
    ALERT 1,"        Zeile zu lang!        ",1,"  Stop  |  Cont  ",x%
    IF x%=1
      ERROR 100
    ENDIF
  ELSE
    t$(chan%,x%)=t$
  ENDIF
RETURN
'
PROCEDURE taktstrich(x%,y0%,y1%)
  LINE x%*8,y0%,x%*8,y0%+2*y1%+24          ! Taktstrich
  LINE x%*8+1,y0%,x%*8+1,y0%+2*y1%+24
RETURN
'
PROCEDURE schluessel(z%)
  LOCAL i%
  HIDEM
  LET lpoke%=VARPTR(lpoke$)
  CALL lpoke%((z%-12+19)*80,VARPTR(schluessel%(0)),50,0)
  SHOWM
RETURN
schluessel:
DATA 30720,63488,116736,231424,198656
DATA 395264,395264,264192,268288,268288
DATA 274432,290816,319488,376832,491520
DATA 458752,917504,1835008,3932160,7602176
DATA 14942208,29622272,58982400,119521280,239067136
DATA 209711104,417609728,281286656,277089280,277089280
DATA 277087232,277087232,277087232,272892928,136579072
DATA 67373056,33820672,25452544,8355840,262144
DATA 262144,262144,262144,262144,29622272
DATA 65273856,65273856,46399488,50855936,32505856
'
PROCEDURE drawline(y1%)     ! Notenzeile
  LOCAL i%
  FOR i%=0 TO 4
    LINE 0,y1%+6*i%,639,y1%+6*i%
  NEXT i%
RETURN
'
PROCEDURE gettakt(chan%,takt$)
  ' öbergibt Ergebnisse fÅr einen Takt in:
  ' laenge%(chan%,count%)  : TonlÑnge von 0 bis 12
  ' hhals%(      "      )  : Richtung bzw. LÑnge des Notenhalses
  ' vorz%(       "      )  : +1 = # ; -1 = b   | 1=b 2=# 3=›
  ' sep!(        "      )  : Einzelnote
  ' x%  (        "      )  : Spalte in Bytes
  ' y%  (        "      )  : Pixelreihe ohne y0%!
  LOCAL j%,hoehe%,laenge%,y%,i%,c%,hals%,x%,temp%
  CLR x%,c%
  j%=1
  WHILE j%<LEN(takt$)
    CLR hoehe%
    vorz%(chan%,c%)=0
    triole!(chan%,c%)=MID$(takt$,j%,1)="@"
    IF triole!(chan%,c%)
      INC j%
    ENDIF
    IF MID$(takt$,j%,1)="b"
      vorz%(chan%,c%)=1
      INC j%
    ELSE
      IF MID$(takt$,j%,1)="#"
        vorz%(chan%,c%)=2
        INC j%
      ELSE
        IF MID$(takt$,j%,1)="›"
          vorz%(chan%,c%)=3
          INC j%
        ENDIF
      ENDIF
    ENDIF
    IF MID$(takt$,j%,1)="@"
      triole!(chan%,c%)=TRUE
      INC j%
    ENDIF
    IF MID$(takt$,j%,1)="P"
      y%=8
      ADD j%,2
      laenge%=2*(ASC(MID$(takt$,j%))-48)+10
    ELSE
      FOR hoehe%=0 TO 7
        EXIT IF MID$(takt$,j%,1)=noten$(hoehe%)
      NEXT hoehe%
      IF hoehe%>7
        ALERT 3,"Schlechter Takt!|Pointer: "+STR$(j%)+"|"+takt$,1," Stop ",dummy
        END
      ENDIF
      INC j%
      y%=10-(hoehe%*3+21*(ASC(MID$(takt$,j%))-48-okt%))
      INC j%
      laenge%=2*(ASC(MID$(takt$,j%))-48)-2
    ENDIF
    temp%=2^(ASC(MID$(takt$,j%))-48)
    INC j%
    IF MID$(takt$,j%,1)="."
      INC laenge%
      INC j%
      MUL temp%,1.5
    ENDIF
    hals%=16
    IF y%<12
      hals%=-hals%
    ENDIF
    laenge%(chan%,c%)=laenge%
    hhals%(chan%,c%)=hals%
    sep!(chan%,c%)=TRUE
    x%(chan%,c%)=x%
    y%(chan%,c%)=y%
    ADD x%,temp%
    INC c%
    IF MID$(takt$,j%,1)="-"
      INC j%                              ! Bîgen noch nicht implementiert.
    ENDIF
  WEND
  x%(chan%,c%)=&H7FFFFFFF
  count%(chan%)=c%
RETURN
'
PROCEDURE initmc
  LOCAL a$
  cmc$=STRING$(2048,CHR$(0))
  vorzeichen$="12345678"
  BLOAD "MUSIC.IMG",VARPTR(cmc$)
  CLR lpoke$
  RESTORE llpoke
  READ a$
  WHILE LEFT$(a$)<>"*"
    LET lpoke$=lpoke$+MKI$(VAL("&H"+a$))
    READ a$
  WEND
  llpoke:
  DATA 206F,0006,5848,2A58,2C58,2E18,4285,7C50,046F,0004,0004,6704,2C18
  DATA 2A18,3F3C,0002,4E4E,544F,2200,0681,0000,7D00,DBC0,5347,B28D,651E
  DATA BBC0,651A,241E,4A45,670A,6B04,EBAA,6004,3805,EAAA,8495,2A82,DBC6
  DATA 51CF,FFE0,4E75,*
RETURN
'
PROCEDURE initedit
  DIM t$(2,80)            ! wird normalerweise nur bis 40 gebraucht
  DIM yedit%(2),triole!(2,80)
  maxokt%=5
  lrand%=14
  rrand%=78
  abst%=80
  abst%=3*(abst% DIV 3)
  yedit%(0)=120
  yedit%(1)=yedit%(0)+abst%
  yedit%(2)=yedit%(1)+abst%
  grenz0%=yedit%(0)-35
  grenz1%=yedit%(0)+abst%/2+12
  grenz2%=grenz1%+abst%
  grenz3%=grenz2%+abst%
RETURN
'
PROCEDURE eraeditfeld
  ERASE t$()
  DIM t$(2,80)
RETURN
'
PROCEDURE initmouse
  LOCAL i%,j%
  DIM mouse$(25)
  RESTORE mmousedat
  FOR i%=0 TO 25
    LET mouse$(i%)=MKI$(6)+MKI$(11)+MKI$(1)
    LET mouse$(i%)=mouse$(i%)+MKI$(0)+MKI$(1)
    FOR j%=1 TO 16
      READ hinten%
      LET mouse$(i%)=mouse$(i%)+MKI$(hinten%)
    NEXT j%
    FOR j%=1 TO 16
      READ vorn%
      LET mouse$(i%)=mouse$(i%)+MKI$(vorn%)
    NEXT j%
  NEXT i%
  '
  mmousedat:
  DATA 240,136,132,146,137,133,145,137,3973,4241,8201,16389,16401,8233,4165,3970
  DATA 0,112,120,108,118,122,110,118,122,3950,8182,16378,16366,8134,3970,0
  DATA 960,544,528,584,548,532,580,548,15892,16964,32804,23,68,32932,16663,15880
  DATA 0,448,480,432,472,488,440,472,488,15800,32728,65512,65467,32539,15880,0
  DATA 240,136,132,146,137,133,145,137,3973,4241,8217,16405,16405,8226,4160,3968
  DATA 0,112,120,108,118,122,110,118,122,3950,8166,16354,16354,8128,3968,0
  DATA 240,136,132,146,137,133,145,137,3973,4241,8217,16413,16403,8242,4172,3968
  DATA 0,112,120,108,118,122,110,118,122,3950,8166,16354,16364,8140,3968,0
  DATA 240,136,132,146,137,133,145,153,3989,4245,8210,16400,16400,8224,4160,3968
  DATA 0,112,120,108,118,122,110,102,98,3938,8160,16352,16352,8128,3968,0
  DATA 240,136,132,146,137,133,145,153,3989,4245,8210,16406,16409,8233,4166,3968
  DATA 0,112,120,108,118,122,110,102,98,3938,8160,16352,16358,8134,3968,0
  DATA 240,136,132,146,153,149,149,149,3986,4240,8208,16400,16384,8224,4160,3968
  DATA 0,112,120,108,102,98,98,98,96,3936,8160,16352,16352,8128,3968,0
  DATA 240,136,132,146,153,149,149,149,3986,4240,8208,16406,16409,8233,4166,3968
  DATA 0,112,120,108,102,98,98,98,96,3936,8160,16352,16358,8134,3968,0
  DATA 240,144,144,144,144,144,144,144,3984,4112,8208,16400,16400,8224,4160,3968
  DATA 0,96,96,96,96,96,96,96,96,3936,8160,16352,16352,8128,3968,0
  DATA 240,144,144,144,144,144,144,144,3984,4240,8214,16409,16409,8230,4160,3968
  DATA 0,96,96,96,96,96,96,96,96,3936,8160,16358,16358,8128,3968,0
  DATA 240,144,144,144,144,144,144,144,3984,4240,8208,20368,20368,8224,4160,3968
  DATA 0,96,96,96,96,96,96,96,96,3936,8160,12384,12384,8128,3968,0
  DATA 240,144,144,144,144,144,144,144,3984,4240,8214,20377,20377,8230,4160,3968
  DATA 0,96,96,96,96,96,96,96,96,3936,8160,12390,12390,8128,3968,0
  DATA 0,0,0,0,0,0,0,0,3968,4160,8224,20368,20368,8224,4160,3968
  DATA 0,0,0,0,0,0,0,0,0,3968,8128,12384,12384,8128,3968,0
  DATA 0,0,0,0,0,0,0,0,3968,4160,8230,20377,20377,8230,4160,3968
  DATA 0,0,0,0,0,0,0,0,0,3968,8128,12390,12390,8128,3968,0
  ' pausen:
  ' 1/32 pause
  DATA 1172,2132,2132,1252,1544,2536,4328,4296,2512,3600,5072,8592,8608,5024,3104,832
  DATA 776,1928,1928,792,496,1552,3856,3888,1568,480,3104,7776,7744,3136,960,128
  ' 1/32 punkt.pause
  DATA 4688,8528,8528,5015,6184,10152,17320,17191,10048,14400,20288,34368,34432,20096,12416,3328
  DATA 3104,7712,7712,3168,1991,6215,15431,15552,6272,1920,12416,31104,30976,12544,3840,512
  ' 1/16 pause
  DATA 3104,4688,8528,8528,5008,6176,10144,17312,17184,10048,6208,1856,576,640,640,640
  DATA 0,3104,7712,7712,3168,1984,6208,15424,15552,6272,1920,128,384,256,256,256
  ' 1/16 punkt.pause
  DATA 9376,17056,17070,10033,12369,20305,34638,34368,20096,12416,3712,1152,1280,1280,1280,1280
  DATA 6208,15424,15424,6350,3982,12430,30848,31104,12544,3840,256,768,512,512,512,512
  ' 1/8 pause
  DATA 0,0,0,3104,4688,8528,8592,8992,9888,4512,3872,320,320,576,640,640
  DATA 0,0,0,0,3104,7712,7776,7360,6464,3648,192,128,128,384,256,256
  ' 1/8 punkt.pause
  DATA 0,0,0,6208,9390,17073,17201,18001,19790,9024,7744,640,640,1152,1280,1280
  DATA 0,0,0,0,6208,15438,15566,14734,12928,7296,384,256,256,768,512,512
  ' 1/4 pause
  DATA 6144,5120,2560,1280,640,576,1088,2176,1280,640,832,1056,2240,2304,1280,640
  DATA 0,2048,1024,512,256,384,896,1792,512,256,128,960,1792,1536,512,256
  ' 1/4 punkt.pause
  DATA 6144,5120,2560,1280,654,593,1105,2193,1294,640,832,1056,2240,2304,1280,640
  DATA 0,2048,1024,512,256,398,910,1806,512,256,128,960,1792,1536,512,256
  ' b-Vorz.
  DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DATA 128,128,128,128,128,128,176,200,136,136,144,160,192,128,0,0
  ' #-Vorz.
  DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DATA 8,8,72,72,76,88,104,200,72,76,88,104,200,72,64,64
  ' Auflîsungszeichen
  DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DATA 64,64,64,76,124,116,68,68,68,92,124,100,4,4,4,0
  '
  DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DATA 0,0,0,0,0,0,62,63,3,3,14,14,3,51,63,30
  '
RETURN
PROCEDURE initplot
  DIM laenge%(2,64),hhals%(2,64),vorz%(2,64),sep!(2,64),x%(2,64),y%(2,64),count%(2)
  DIM vorzplot%(2,15),vorz$(3)
  RESTORE vorz
  FOR i%=0 TO 3
    READ vorz$(i%)
  NEXT i%
  vorz:
  DATA "",b,#,›
  RESTORE vorzplot
  FOR j%=0 TO 2
    FOR i%=0 TO 15
      READ vorzplot%(j%,i%)
    NEXT i%
  NEXT j%
  vorzplot:
  ' b-Vorz.
  DATA 128,128,128,128,128,128,176,200,136,136,144,160,192,128,0,0
  ' #-Vorz.
  DATA 8,8,72,72,76,88,104,200,72,76,88,104,200,72,64,64
  ' Auflîsungszeichen
  DATA 64,64,64,76,124,116,68,68,68,92,124,100,4,4,4,0
  '
  DIM c%(2),schluessel%(50)
  RESTORE schluessel
  FOR i%=0 TO 49
    READ schluessel%(i%)
  NEXT i%
  RESTORE kopfdat
  DIM kopf%(1,4)
  FOR i%=0 TO 1
    FOR j%=0 TO 4
      READ kopf%(i%,j%)
    NEXT j%
  NEXT i%
  kopfdat:
  DATA 126,195,129,195,126
  DATA 126,255,255,255,126
  '
  RESTORE ppausendat
  DIM pausen%(11,15)
  FOR i%=0 TO 7
    FOR j%=0 TO 15
      READ temp%
      LET pausen%(i%,j%)=temp%
    NEXT j%
  NEXT i%
  ppausendat:
  DATA 776,1928,1928,792,496,1552,3856,3888,1568,480,3104,7776,7744,3136,960,128
  DATA 3104,7712,7712,3168,1991,6215,15431,15552,6272,1920,12416,31104,30976,12544,3840,512
  DATA 0,3104,7712,7712,3168,1984,6208,15424,15552,6272,1920,128,384,256,256,256
  DATA 6208,15424,15424,6350,3982,12430,30848,31104,12544,3840,256,768,512,512,512,512
  DATA 0,0,0,0,3104,7712,7776,7360,6464,3648,192,128,128,384,256,256
  DATA 0,0,0,0,6208,15438,15566,14734,12928,7296,384,256,256,768,512,512
  DATA 0,2048,1024,512,256,384,896,1792,512,256,128,960,1792,1536,512,256
  DATA 0,2048,1024,512,256,398,910,1806,512,256,128,960,1792,1536,512,256
  '
  RESTORE halsdat
  DIM hals%(21,6,1)
  FOR i%=0 TO 3
    FOR j%=21 DOWNTO 0
      READ temp%
      hals%(j%,i%,0)=temp%
      IF j%<=18
        hals%(j%+3,i%,1)=temp%*512
      ELSE
        hals%(j%-19,i%,1)=128*512
      ENDIF
    NEXT j%
  NEXT i%
  FOR j%=0 TO 15
    hals%(j%,4,0)=128
    hals%(j%,5,0)=128
    hals%(j%,4,1)=128*512
    hals%(j%,5,1)=128*512
  NEXT j%
  halsdat:
  DATA 224,240,184,220,236,246,186,222,238,246,186,222,238,246,186,158,142,134,130,130,132,128
  DATA 0,128,192,224,240,184,220,238,246,186,222,238,246,186,158,142,134,130,130,132,128,128
  DATA 0,0,0,0,0,128,128,192,224,240,184,220,238,246,186,158,142,134,130,130,132,128
  DATA 0,0,0,0,0,0,0,0,128,128,192,224,240,184,156,142,134,130,130,132,128,128
  '
  RESTORE notenbezeichner
  DIM noten$(7)
  FOR i%=0 TO 7
    READ noten$(i%)
  NEXT i%
  notenbezeichner:
  DATA C,D,E,F,G,A,H,C
RETURN
'
PROCEDURE plotnote(laenge%,hals%,sep!,x%,y%,vorz$)
  ' ErklÑrung der Parameter:
  ' laenge% = Notendauer von 0 bis 12
  ' hals%   = LÑnge des Notenhalses ( >0 => nach oben; <0 => nach unten )
  ' sep!    = Note einzeln setzen (ohne gemeinsame Achtel-balken)
  '           das Vorzeichen von Hals% gibt an, ob Hals nach oben oder unten.
  ' x%,y%   = Position der Note (y% in Pixelreihen, x% in Byte-spalten.).
  ' vorz$   = # oder b oder ›
  LOCAL i%,bildadr%,temp%,zwi%,shift!,bild%
  HIDEM
  bild%=XBIOS(2)+1520
  IF x%>=80
    ALERT 3,"ERROR in PROCEDUR plotnote !|Nicht Åber Bildschirmrand|hinaus plotten!|( x = "+STR$(x%)+" )",1,"  Stop  ",dummy
    ERROR 100
  ENDIF
  IF ODD(x%)
    ALERT 3,"ERROR in PROCEDURE plotnote !|Plotten von Note nur an|gerade Bildschirm-Adresse!|( x = "+STR$(x%)+" )",1,"  Stop  ",dummy%
    ERROR 100
  ENDIF
  temp%=(y%-3)*80+x%
  IF temp%>32000 OR temp%<0
    ALERT 3,"ERROR in PROCEDURE plotnote !|Versuch auûerhalb des |Bildschirms zu poken!|( XBIOS(2)+"+STR$(temp%)+" )",1,"  Stop  ",dummy
    ERROR 100
  ENDIF
  bildadr%=bild%+temp%
  shift!=(PEEK(bildadr%)<>0) OR (PEEK(bildadr%+320)<>0)
  IF laenge%<14
    kopf%=-(laenge%<10)                     ! 10 bis 12 => ganze und halbe Noten
    SUB bildadr%,shift!
    zwi%=bildadr%
    IF vorz$<>""
      @plotvorz(x%,y%,-(vorz$="#")-2*(vorz$="›"))
    ENDIF
    FOR i%=0 TO 4
      IF bildadr%-bild%>30480 OR bildadr%-bild%<0
        ALERT 3,"ERROR in PROCEDURE plotnote !|Versuch auûerhalb des |Bildschirms zu poken!|( "+STR$(bildadr%)+" )",1,"  Stop  ",dummy
        ERROR 100
      ENDIF
      POKE bildadr%,kopf%(kopf%,i%) OR PEEK(bildadr%)
      ADD bildadr%,80
    NEXT i%
    IF ODD(laenge%)                        ! => punktierte Note
      bildadr%=zwi%+1
      FOR i%=0 TO 2
        ADD bildadr%,80
        IF bildadr%-bild%>30480 OR bildadr%-bild%<0
          ALERT 3,"ERROR in PROCEDURE plotnote !|Versuch auûerhalb des |Bildschirms zu poken!|( "+STR$(bildadr%)+" )",1,"  Stop  ",dummy
          ERROR 100
        ENDIF
        POKE bildadr%,&X111000 OR PEEK(bildadr%)
      NEXT i%
    ENDIF
    IF laenge%<12
      IF laenge%>13
        sep!=TRUE
      ENDIF
      bildadr%=zwi%+158+shift!
      IF hals%>0
        d%=-80
      ELSE
        d%=80
      ENDIF
      IF sep!
        LET lpoke%=VARPTR(lpoke$)
        b%=(bildadr%-bild%)-shift!*2+1520
        v%=VARPTR(hals%(0,INT(laenge%/2),-(hals%<0)))
        CALL lpoke%(b%,v%,21,d%,-8*shift!,0)
      ELSE
        IF hals%>0
          temp%=&H80
        ELSE
          temp%=&H10000
        ENDIF
        FOR i%=0 TO hals% STEP SGN(hals%)
          IF bildadr%-bild%>30480 OR bildadr%-bild%<0
            ALERT 3,"ERROR in PROCEDURE plotnote !|Versuch auûerhalb des |Bildschirms zu poken!|( "+STR$(bildadr%)+" )",1,"  Stop  ",dummy
            ERROR 100
          ENDIF
          LPOKE bildadr%,temp% OR LPEEK(bildadr%)
          ADD bildadr%,d%
        NEXT i%
      ENDIF
    ENDIF
  ELSE
    FOR i%=0 TO 15
      IF bildadr%-bild%>30480 OR bildadr%-bild%<0
        ALERT 3,"ERROR in PROCEDURE plotnote !|Versuch auûerhalb des |Bildschirms zu poken!|( "+STR$(bildadr%)+" )",1,"  Stop  ",dummy
        ERROR 100
      ENDIF
      IF NOT shift!
        DPOKE bildadr%,DPEEK(bildadr%) OR pausen%(laenge%-14,i%)
      ELSE
        LPOKE bildadr%,LPEEK(bildadr%) OR 256*pausen%(laenge%-14,i%)
      ENDIF
      ADD bildadr%,80
    NEXT i%
  ENDIF
RETURN
'
PROCEDURE hilfszeilen(y1%,x%,y%)
  LOCAL i%
  ADD y%,y1%
  i%=y1%+30
  WHILE i%<y%
    LINE x%*8-2,i%,x%*8+10,i%
    ADD i%,6
  WEND
  i%=y1%
  WHILE i%>y%-2
    LINE x%*8-2,i%,x%*8+10,i%
    SUB i%,6
  WEND
RETURN
'
PROCEDURE select_file(a$)
  LOCAL i%,inp%,newname$
  IF INSTR(name$,".")<>0
    LET name$=LEFT$(name$,INSTR(name$,"."))+a$
  ENDIF
  FILESELECT pfad$+"*."+a$,name$,newname$
  i%=LEN(newname$)
  IF i%
    LET name$=newname$
    WHILE MID$(name$,i%,1)<>"\"
      DEC i%
    WEND
    pfad$=LEFT$(name$,i%)
    LET name$=MID$(name$,i%+1)
    IF INSTR(name$,".")=0
      LET name$=name$+"."+a$
    ENDIF
  ENDIF
  sel!=i%>0
RETURN
'
PROCEDURE open_file(voll_name$)
  @select_file("MUS")
  IF sel!
    OPEN "R",#0,pfad$+name$
  ENDIF
RETURN
'
PROCEDURE read_file
  LOCAL i%,load$,temp%,p%,pa%
  @select_file("MUS")
  IF sel! AND EXIST(pfad$+name$)
    LET load$=STRING$(32760,CHR$(0))
    BLOAD pfad$+name$,VARPTR(load$)
    ERASE takte$()
    DIM takte$(2,1000)
    pa%=1
    FOR j%=0 TO 1000
      FOR i%=0 TO 2
        p%=INSTR(load$,"|",pa%)
        EXIT IF p%=0
        takte$(i%,j%)=MID$(load$,pa%,p%-pa%+1)
        pa%=p%+3
      NEXT i%
      EXIT IF p%=0
    NEXT j%
    filep%=j%
    maxfilep%=j%
    CLR edflag!
    CLR compileflag!
    @clear_vorz
  ENDIF
RETURN
'
PROCEDURE merge_file
  LOCAL i%,screen$,temp%,k%,temp$,j%,n%
  ALERT 2,"Das File wird vor dem|aktuellen Takt eingefÅgt!| ",1,"   Ok   |Abbruch",temp%
  IF temp%=1
    @open_file(pfad$+name$)
    IF sel!
      j%=filep%
      SGET screen$
      CLOSEW 0
      CLS
      PRINT "Inserting file: ";pfad$;name$
      PRINT
      PRINT
      k%=NOT 0
      WHILE NOT EOF(#0)
        IF k%
          PRINT
        ENDIF
        CLR temp%
        FOR i%=0 TO 2
          LINE INPUT #0;takt$(i%)
          IF k%
            PRINT takt$(i%)
          ENDIF
          ADD temp%,LEN(takt$(i%))
          '
        NEXT i%
        IF temp%
          @insert
        ENDIF
        IF MOUSEK
          k%=NOT k%
          REPEAT
          UNTIL MOUSEK=0
        ENDIF
      WEND
      REPEAT
      UNTIL MOUSEK OR INKEY$<>"" OR k%=0
      CLR compileflag!
      OPENW 0
      SPUT screen$
      CLR screen$
      CLOSE
    ENDIF
  ENDIF
RETURN
'
PROCEDURE write_part
  LOCAL i%,screen$,inp$
  SGET screen$
  PRINT AT(1,4);"Abspeichern von aktuellem Takt bis einschlieûlich (maximal ";
  PRINT maxfilep%-1;") ";
  INPUT inp$
  IF inp$<>"" AND VAL(inp$)>=filep%
    CLR name$
    @write_file(filep%,MIN(maxfilep%-1,VAL(inp$)))
  ENDIF
  SPUT screen$
  CLR screen$
RETURN
'
PROCEDURE write_file(von%,bis%)
  LOCAL i%,j%
  @select_file("MUS")
  IF sel!
    IF EXIST(pfad$+name$)
      KILL pfad$+name$
    ENDIF
    OPEN "R",#0,pfad$+name$
    FOR j%=von% TO bis%
      FOR i%=0 TO 2
        PRINT AT(1,3);"Writing Takt ";j%,,
        PRINT #0;takte$(i%,j%)
      NEXT i%
    NEXT j%
    CLOSE
  ENDIF
RETURN
'
PROCEDURE initcomp
  transpose=1
  tempo=1
  gap%=2
  DIM nd%(2),compt$(2),vorzeichen$(7)
  DIM nnote%(23)
  RESTORE periodendauer
  FOR i%=0 TO 23
    READ nnote%(i%)
  NEXT i%
  periodendauer:
  '
  ' Diese PeriodenlÑngen entsprechen den Kehrwerten der Frequenzen, die in
  ' SPECTRUM DER WISSENSCHAFT 7/1987 Seite 8 abgedruckt sind.
  ' Sie sind auf Kammerton a = 440.0 Hz getrimmt.
  '
  DATA 2273,2025,3823,3405,3034,2864,2551,2025
  '      A    H    C    D    E    F    G    H
  DATA 2145,1911,3608,3214,2864,2703,2408,1911
  '     #A  #H    #C   #D   #E   #F   #G   #H
  DATA 2419,2145,4049,3608,3214,3034,2703,2145
  '     bA   bH   bC   bD   bE   bF   bG   bH
  '
  ' Diese PeriodenlÑngen sind selbst errechnet, so daû das Produkt einer Note
  ' mit einem bestimmten Faktor die nÑchste Note ergibt, wobei sich nach zwîlf
  ' Iterationen genau die halbe Periodendauer ergibt.
  ' Der Faktor ist 2^(1/12). Nach demselben Algorithmus wurden auch die
  ' Frequenzen in SPEKTRUM DER WISSENSCHAFT berechnet.
  ' Kammerton a = 438.0 Hz.
  '
  '  DATA 2283,2034,3840,3421,3048,2877,2563,2034
  '      A    H    C    D    E    F    G    H
  '  DATA 2155,1920,3624,3229,2877,2715,2419,1920
  '     #A  #H    #C   #D   #E   #F   #G   #H
  '  DATA 2419,2155,4068,3624,3229,3048,2715,2155
  '     bA   bH   bC   bD   bE   bF   bG   bH
  '
  '
RETURN
'
PROCEDURE set_glob_vorz
  LOCAL i%
  @clear_vorz
  CLR i%
  REPEAT
    IF vorzeichen$(ASC(takt$(0))-97)=""
      vorzeichen$(ASC(takt$(0))-97)=MID$(takt$(0),2,1)
      t$(0,i%)=LEFT$(takt$(0),2)
    ENDIF
    takt$(0)=MID$(takt$(0),3)
    INC i%
  UNTIL LEFT$(takt$(0))<"a" OR LEFT$(takt$(0))>"h"
  vorzeichen$(1)=vorzeichen$(7)
  CLR vorzeichen$
  FOR i%=0 TO 7
    IF vorzeichen$(i%)<>""
      vorzeichen$=vorzeichen$+vorzeichen$(i%)
    ELSE
      vorzeichen$=vorzeichen$+" "
    ENDIF
  NEXT i%
  IF INSTR(vorzeichen$,"›")
    vorzeichen$="01234567"
  ENDIF
RETURN
'
PROCEDURE clear_vorz
  LOCAL i%
  FOR i%=0 TO 7
    vorzeichen$(i%)=""
  NEXT i%
  vorzeichen$="01234567"
RETURN
'
PROCEDURE comptakt(rueck%)
  LOCAL compilat$,i%,j%,n%,temp$
  LOCAL meld%,len%
  compilat$=STRING$(1025,CHR$(0))
  compt$(0)=takt$(0)
  compt$(1)=takt$(1)
  compt$(2)=takt$(2)
  IF LEFT$(takt$(0))>="a" AND LEFT$(takt$(0))<="h" AND LEFT$(takt$(0))<>"b"
    @set_glob_vorz
  ENDIF
  SWAP compt$(0),takt$(0)
  IF (INSTR(compt$(0),"|")>0) AND (INSTR(compt$(1),"|")>0) AND (INSTR(compt$(2),"|")>0)
    VOID FRE(8)
    len%=256
    meld%=0
    cmc%=VARPTR(cmc$)
    CALL cmc%(compt$(0),compt$(1),compt$(2),VARPTR(volume%(0)),vorzeichen$,VARPTR(nnote%(0)),transpose*256,gap%,tempo*256,compilat$,VARPTR(len%),VARPTR(nd%(0)),VARPTR(meld%),0)
    compileerror!=meld%
    IF meld%=1
      err$="chan0: "+STR$(nd%(0))+"|chan1: "+STR$(nd%(1))+"|chan2: "+STR$(nd%(2))
      ALERT 3,"Fehler bei der TaktlÑnge !|"+err$,1,"   OK   ",temp%
    ENDIF
    IF meld%=2
      ALERT 3,"Fehler bei der Tonhîhe:|"+takt$(0)+takt$(1)+takt$(2),1,"   OK   ",temp%
    ENDIF
    *rueck%=LEFT$(compilat$,len%)
  ELSE
    *rueck%=""
  ENDIF
RETURN
'
PROCEDURE initmenu
  DIM grundmenue$(70)
  RESTORE grundmenue
  FOR i%=0 TO 70
    READ grundmenue$(i%)
    IF grundmenue$(i%)="***Key klick"
      IF PEEK(&H484) AND 1       ! Key-klick ist an.
        grundmenue$(i%)="Key klick off"
      ELSE
        grundmenue$(i%)="Key klick on"
      ENDIF
    ENDIF
    EXIT IF grundmenue$(i%)="***"
    IF LEFT$(grundmenue$(i%))<>"-" AND grundmenue$(i%)<>""
      grundmenue$(i%)="  "+grundmenue$(i%)
    ENDIF
  NEXT i%
  grundmenue$(i%)=""
  grundmenue$(i%+1)=""
  grundmenue:
  DATA Desk  ,Music Writer
  DATA ----------------------,1,2,3,4,5,6,""
  DATA File  ,Clear,Write,Write Part,---------------
  DATA Read,Merge,---------------,Quit,---------------,Delete File,""
  DATA Edit  ,Next,Preceeding,--------------------,Goto nr.
  DATA Goto first,Goto last,--------------------,Skip Edits,Clear Takt
  DATA ""
  DATA Put  ,Put into Buffer,Get from Buffer,-------------------
  DATA Replace,Insert,-------------------,Skip Edits,Delete aktual,""
  DATA Actions  ,Compile Takt,Play Takt,--------------------
  DATA Compile all,Play all,Play from actual
  DATA --------------------,Double Speed,Half Speed,--------------------
  DATA Save Sound,Read Sound,""
  DATA Specials  ,***Key klick,Noten eng
  DATA -----------------,Volume,Transpose,Tempo,Gap,""
  DATA ***
RETURN
'
PROCEDURE grundmenue
  LOCAL m$,i%,inp%,temp$,temp2$
  m$=UPPER$(grundmenue$(MENU(0)))
  REPEAT
    i%=INSTR(m$," ")
    IF i%
      m$=LEFT$(m$,i%-1)+MID$(m$,i%+1)
    ENDIF
  UNTIL i%=0
  no_menue!=FALSE
  neu!=TRUE
  IF m$="MUSICWRITER"
    @anleitung
  ENDIF
  IF m$="CLEAR"
    ALERT 2," | Wirklich alles lîschen? | ",1,"   Ja   |  nein  ",inp%
    IF inp%=1
      ALERT 2," | Ganz hundertprozent sicher ? | ",1,"doch, ja|ach nein",inp%
      IF inp%=1
        RUN
      ENDIF
    ENDIF
  ENDIF
  IF m$="WRITE"
    @ask
    @write_file(0,maxfilep%)
  ENDIF
  IF m$="WRITEPART"
    @ask
    @write_part
  ENDIF
  IF m$="READ"
    @read_file
    @find_akt_vorz
  ENDIF
  IF m$="MERGE"
    @ask
    @merge_file
    @find_akt_vorz
  ENDIF
  IF m$="QUIT"
    ALERT 2,"Haben sie alles gesichert?",2,"  Ende  | Weiter ",inp%
    IF inp%=1
      MENU KILL
      END
    ENDIF
  ENDIF
  IF m$="DELETEFILE"
    temp$=name$
    temp2$=pfad$
    LET name$=""
    @select_file("*")
    IF sel! AND name$<>".*"
      ALERT 3,"Soll ich |"+UPPER$(name$)+"|wirklich lîschen?| ",2,"   Ja   |  nein  ",inp%
      IF inp%=1 AND EXIST(pfad$+name$)
        KILL pfad$+name$
      ENDIF
    ENDIF
    LET name$=temp$
    pfad$=temp2$
  ENDIF
  IF m$="NEXT"
    @ask
    filep%=filep%-(filep%<maxfilep%)
  ENDIF
  IF m$="PRECEEDING"
    @ask
    filep%=filep%+(filep%>0)
    @find_akt_vorz
  ENDIF
  IF m$="GOTONR."
    @ask
    REPEAT
      PRINT AT(1,4);"Bitte Taktnummer eingeben (0 bis ";maxfilep%;") : ";
      INPUT temp$
      IF LEN(temp$)
        filep%=VAL(temp$)
      ENDIF
    UNTIL filep%>=0 AND filep%<=maxfilep%
    PRINT AT(1,4);SPACE$(80)
    @find_akt_vorz
  ENDIF
  IF m$="GOTOFIRST"
    @ask
    @clear_vorz
    CLR filep%
  ENDIF
  IF m$="GOTOLAST"
    @ask
    filep%=maxfilep%
    @find_akt_vorz
  ENDIF
  IF m$="CLEARTAKT"
    @eraeditfeld
    @put_t_to_taktfeld
    edflag!=TRUE
    CLR neu!
  ENDIF
  IF m$="DELETEAKTUAL"
    ALERT 2," |  Wirklich ?  | | ",0,"na klar!|ne,ne !",delinp%
    IF delinp%=1
      @delete
      @find_akt_vorz
    ELSE
      neu!=FALSE
    ENDIF
  ENDIF
  IF m$="COMPILEALL"
    @ask
    @compile_all(0)
  ENDIF
  IF m$="PLAYALL"
    @ask
    @play_all(0)
  ENDIF
  IF m$="PLAYFROMACTUAL"
    @ask
    CLR compileflag!
    @play_all(filep%)
  ENDIF
  IF m$="DOUBLESPEED"
    @change_speed(-1)
  ENDIF
  IF m$="HALFSPEED"
    @change_speed(1)
  ENDIF
  IF m$="READSOUND"
    neu!=FALSE
    @read_sound
  ENDIF
  IF m$="SAVESOUND"
    neu!=FALSE
    @save_sound
  ENDIF
  IF m$="PUTINTOBUFFER"
    neu!=FALSE
    @put_to_buf
  ENDIF
  IF m$="GETFROMBUFFER"
    @get_from_buf
  ENDIF
  IF m$="INSERT"
    @put_t_to_taktfeld
    @insert
  ENDIF
  IF m$="REPLACE"
    @put_t_to_taktfeld
    @replace
  ENDIF
  IF m$="SKIPEDITS"
    @skip
    CLR edflag!
  ENDIF
  IF m$="COMPILETAKT"
    @put_t_to_taktfeld
    @comptakt(*taktsound$)
    neu!=FALSE
  ENDIF
  IF m$="PLAYTAKT"
    @put_t_to_taktfeld
    @play_takt
  ENDIF
  IF m$="VOLUME"
    @volume
    neu!=FALSE
    CLR compileflag!
  ENDIF
  IF m$="KEYKLICKON"
    grundmenue$(MENU(0))="  Keyklick off  "
    MENU grundmenue$()
    ' klick on
    SPOKE &H484,PEEK(&H484) OR 5
    neu!=FALSE
    @disable
  ENDIF
  IF m$="KEYKLICKOFF"
    grundmenue$(MENU(0))="  Keyklick on  "
    MENU grundmenue$()
    SPOKE &H484,PEEK(&H484) AND NOT 5
    neu!=FALSE
    @disable
  ENDIF
  IF m$="NOTENENG"
    grundmenue$(MENU(0))="  Noten weit  "
    @put_t_to_taktfeld
    MENU grundmenue$()
    neu!=FALSE
    dist%=2
  ENDIF
  IF m$="NOTENWEIT"
    grundmenue$(MENU(0))="  Noten eng  "
    @put_t_to_taktfeld
    MENU grundmenue$()
    neu!=FALSE
    dist%=4
  ENDIF
  IF m$="TRANSPOSE"
    neu!=FALSE
    @transpose
  ENDIF
  IF m$="TEMPO"
    neu!=FALSE
    @tempo
  ENDIF
  IF m$="GAP"
    neu!=FALSE
    @gap
  ENDIF
  MENU OFF
RETURN
'
PROCEDURE play_takt
  @comptakt(*taktsound$)
  LET temp$=CHR$(7)+CHR$(56)
  FOR i%=0 TO 2
    temp$=temp$+CHR$(i%+8)+CHR$(volume%(i%))
  NEXT i%
  LET taktsound$=temp$+taktsound$+CHR$(255)+CHR$(0)
  VOID XBIOS(32,L:VARPTR(taktsound$))
  neu!=FALSE
RETURN
'
PROCEDURE transpose
  LOCAL screen$,inp%,inp$,h%,sound$,okt%,step,i%,temp$,temp%
  ALERT 2," |Explizite Eingabe oder Tunen?| ",1,"Explizit|Tuning|Abbruch",inp%
  SGET screen$
  IF inp%=1
    PBOX 8,0,631,60
    BOX 8,0,631,60
    PRINT AT(3,1);"1000 ist normal."''
    PRINT "2000 ist eine Oktave tiefer ; 500 ist eine Oktave hîher"
    PRINT AT(3,3);"Bitte Transpose eingeben! ";transpose*1000''
    INPUT temp$
    IF LEN(temp$)
      transpose=VAL(temp$)/1000
    ENDIF
  ENDIF
  IF inp%=2
    temp%=volume%(0)
    volume%(0)=13
    PBOX 8,0,631,200
    BOX 8,0,631,200
    REPEAT
      REPEAT
        PRINT AT(3,1);"Auf welchen Ton? (zB: C oder #C)"'''
        INPUT inp$
      UNTIL LEN(inp$)<=2
      inp$=UPPER$(inp$)
      IF RIGHT$(inp$)="B"
        inp$="#H"
      ENDIF
      FOR h%=0 TO 7
        EXIT IF RIGHT$(inp$)=noten$(h%)
      NEXT h%
    UNTIL h%<7 OR inp$=""
    IF h%<7 AND inp$<>""
      SWAP tsave$(),takt$()
      takt$(2)="PP3|"
      takt$(1)=takt$(2)
      PRINT AT(3,2);"Oktave (zB: 3)"'''
      INPUT temp$
      okt%=VAL(temp$)
      takt$(0)=inp$+STR$(okt%)+"3|"
      step=0.001
      PRINT AT(3,4);"DrÅcken der linken  Maustaste erhîht den Ton."
      PRINT AT(3,5);"    ""      rechten     ""    erniedrigt """
      PRINT AT(3,6);"Mit der + bzw - Taste kann die Schrittweite verÑndert werden."
      PRINT AT(3,7);"ZurÅck mit < ENTER >"
      HIDEM
      REPEAT
        ADD transpose,step*((MOUSEK=1)-(MOUSEK=2))
        transpose=MIN(8.574,MAX(0,transpose))
        PRINT AT(16,10);"Transpose:    ";1000*MIN(0.001,step)*INT(transpose/MIN(0.001,step));"            "
        PRINT AT(16,11);"Schrittweite: ";step*1000'''
        @play_takt
        i$=INKEY$
        IF i$="+"
          step=MIN(1,step*10)
        ENDIF
        IF i$="-"
          step=MAX(1.0E-06,step/10)
        ENDIF
      UNTIL i$=CHR$(13)
      SWAP takt$(),tsave$()
    ENDIF
    SHOWM
    volume%(0)=temp%
  ENDIF
  SPUT screen$
  CLR screen$
  CLR compileflag!
RETURN
'
PROCEDURE tempo
  LOCAL screen$,temp$
  SGET screen$
  PBOX 8,0,631,60
  BOX 8,0,631,60
  PRINT AT(3,1);"1000 ist normal;  ";
  PRINT "> 1000: langsamer / < 1000: schneller"
  PRINT AT(10,2);"{ Mîglichst 'glatte' Werte wÑhlen!  ( zB: 750 ) }"
  PRINT AT(3,3);"Bitte Tempo eingeben! ";tempo*1000''
  INPUT temp$
  IF LEN(temp$)
    tempo=VAL(temp$)/1000
  ENDIF
  SPUT screen$
  CLR screen$
  CLR compileflag!
RETURN
'
PROCEDURE gap
  LOCAL inp%
  REPEAT
    ALERT 0,"Gap bedeutet die LÅcke|zwischen unverbundenen Tînen.|Momentan haben wir: "+STR$(gap%),0," lÑnger |  OK  | kÅrzer ",inp%
    ADD gap%,(inp%=3)-(inp%=1)
  UNTIL inp%=2
  CLR compileflag!
RETURN
'
PROCEDURE skip
  @eraeditfeld
RETURN
'
PROCEDURE ask
  LOCAL inp%
  IF edflag!
    PRINT CHR$(7);
    WHILE MOUSEK
    WEND
    ALERT 2,"  Was machen wir mit dem  |  aktuellen Takt ?| ",1,"Replace|Insert|Skip",inp%
    IF inp%<>3
      @put_t_to_taktfeld
    ENDIF
    ON inp% GOSUB replace,insert,skip
  ENDIF
  CLR edflag!
RETURN
'
PROCEDURE insert
  LOCAL i%,j%
  j%=filep%
  WHILE LEN(takt$(1)+takt$(2)+takt$(0))<>0
    FOR i%=0 TO 2
      SWAP takt$(i%),takte$(i%,j%)
    NEXT i%
    INC j%
  WEND
  INC filep%
  INC maxfilep%
  CLR compileflag!,edflag!
RETURN
'
PROCEDURE replace
  LOCAL i%
  FOR i%=0 TO 2
    takte$(i%,filep%)=takt$(i%)
  NEXT i%
  SUB maxfilep%,maxfilep%=filep%
  CLR compileflag!,edflag!
RETURN
'
PROCEDURE volume
  LOCAL i%,screen$,inp$
  SGET screen$
  PBOX 8,0,631,60
  BOX 8,0,631,60
  FOR i%=0 TO 2
    REPEAT
      PRINT AT(3,1+i%);"LautstÑrke von Stimme ";i%;" : ";STR$(volume%(i%));" ? ";
      FORM INPUT 2,inp$
      IF inp$<>""
        volume%(i%)=VAL(inp$)
      ENDIF
    UNTIL volume%(i%)>=0 AND volume%(i%)<=15
  NEXT i%
  SPUT screen$
  CLR screen$
RETURN
'
PROCEDURE compile_all(j%)
  LOCAL i%,tt$,inp%,p%
  CLR inp%
  IF j%=0
    @clear_vorz
  ENDIF
  LET sound$=CHR$(7)+CHR$(56)
  FOR i%=0 TO 2
    LET sound$=sound$+CHR$(i%+8)+CHR$(volume%(i%))
  NEXT i%
  p%=LEN(sound$)+1
  LET sound$=sound$+STRING$(32760-LEN(sound$),CHR$(0))
  compileflag!=TRUE
  WHILE takte$(0,j%)<>"" AND takte$(1,j%)<>"" AND takte$(2,j%)<>""
    PRINT AT(1,3);"Compiling Takt ";j%
    takt$(0)=takte$(0,j%)
    takt$(1)=takte$(1,j%)
    takt$(2)=takte$(2,j%)
    @comptakt(*tt$)
    IF compileerror!
      ALERT 2,"Weiter machen?",2," ja | Edit ",inp%
      IF inp%=2
        CLR compileflag!
        filep%=j%
      ENDIF
    ENDIF
    EXIT IF inp%=2
    MID$(sound$,p%)=tt$
    ADD p%,LEN(tt$)
    INC j%
  WEND
  @find_akt_vorz
  PRINT AT(1,3),,,
  MID$(sound$,p%)=CHR$(255)+CHR$(0)
  LET sound$=LEFT$(sound$,p%+1)
RETURN
'
PROCEDURE play_all(start%)
  IF NOT compileflag!
    @compile_all(start%)
  ENDIF
  VOID FRE(0)
  VOID XBIOS(32,L:VARPTR(sound$))
RETURN
'
PROCEDURE read_sound
  LOCAL lof%
  @select_file("SON")
  IF sel!
    IF EXIST(pfad$+name$)
      OPEN "R",#69,pfad$+name$
      lof%=LOF(#69)
      CLOSE #69
      IF lof%>0
        LET sound$=STRING$(lof%,CHR$(0))
        BLOAD pfad$+name$,VARPTR(sound$)
        compileflag!=TRUE
      ELSE
        ALERT 3,"DateilÑnge ist NULL",1,"   OK   ",dummy
      ENDIF
    ELSE
      ALERT 3,"Es existiert keine Datei mit|Namen:|"+name$,1,"   OK   ",dummy
    ENDIF
  ENDIF
RETURN
'
PROCEDURE save_sound
  IF NOT compileflag!
    @compile_all(0)
  ENDIF
  @select_file("SON")
  IF sel!
    BSAVE pfad$+name$,VARPTR(sound$),LEN(sound$)
  ENDIF
RETURN
'
PROCEDURE delete
  LOCAL inp%,i%,j%
  ALERT 2," Haben sie sich das grÅndlich |      Åberlegt ? | ",2,"freilich|nicht so",inp%
  IF inp%=1
    j%=filep%
    REPEAT
      FOR i%=0 TO 2
        takte$(i%,j%)=takte$(i%,j%+1)
      NEXT i%
      INC j%
    UNTIL takte$(0,j%)="" OR takte$(1,j%)="" OR takte$(2,j%)=""
    DEC maxfilep%
    CLR compileflag!
  ENDIF
RETURN
'
PROCEDURE fehler
  LOCAL inp%,i%,j%
  IF ERR=-33
    fileerror!=TRUE
    ON ERROR GOSUB fehler
    RESUME NEXT
  ELSE
    ALERT 1," Katastrophaler Fehler! | | Retten, was zu retten ist ?| ",0," Jaaa.. |Weg mit!",inp%
    IF inp%=1
      CLR name$
      GOSUB write_file(0,maxfilep%)
    ENDIF
    ALERT 2," | |         Was nun ?           | ",0,"Abbruch|Neustart",inp%
    IF inp%=2
      RUN
    ELSE
      RESUME
    ENDIF
  ENDIF
RETURN
'
PROCEDURE put_to_buf
  LOCAL i%
  @put_t_to_taktfeld
  FOR i%=0 TO 2
    taktbuf$(i%)=takt$(i%)
  NEXT i%
RETURN
'
PROCEDURE get_from_buf
  LOCAL i%
  FOR i%=0 TO 2
    takt$(i%)=taktbuf$(i%)
  NEXT i%
  @eraeditfeld
  CLR neu!
  edflag!=TRUE
RETURN
'
PROCEDURE change_speed(s%)
  LOCAL i%,j%
  @put_t_to_taktfeld
  FOR i%=0 TO 2
    FOR j%=3 TO LEN(takt$(i%))
      IF VAL(MID$(takt$(i%),j%))
        IF VAL(MID$(takt$(i%),j%-1))<>0 OR MID$(takt$(i%),j%-1,1)="P"
          MID$(takt$(i%),j%)=CHR$(ASC(MID$(takt$(i%),j%))+s%)
        ENDIF
      ENDIF
    NEXT j%
    takte$(i%,filep%)=takt$(i%)
  NEXT i%
  edflag!=FALSE
RETURN
'
PROCEDURE find_akt_vorz
  LOCAL i%,temp$
  FOR i%=filep% DOWNTO 0
    temp$=LEFT$(takte$(0,i%))
    EXIT IF temp$>="a" AND temp$<="h" AND temp$<>"b"
  NEXT i%
  IF i%>=0
    temp$=takt$(0)
    takt$(0)=takte$(0,i%)
    @set_glob_vorz
    takt$(0)=temp$
    PRINT AT(50,3);"Vorzeichen in Taktnr. ";i%;"  "
  ENDIF
RETURN
'
PROCEDURE anleitung
  LOCAL screen$,d$,lc%,inp$,fileerror!
  fileerror!=FALSE
  OPEN "I",#68,"MUSIC.DOC"
  IF fileerror!
    ALERT 3,"Das file 'MUSIC.DOC' muû sich|im selben Ordner befinden,|von dem aus das Programm|gestartet wurde!",1,"Abbruch",dummy
  ELSE
    SGET screen$
    CLOSEW 0
    CLS
    WHILE NOT EOF(#68)
      LINE INPUT #68,d$
      INC lc%
      IF lc%>22
        PRINT "-MEHR-";CHR$(27);"p ";CHR$(27);"q";CHR$(13);
        REPEAT
          inp$=INKEY$
        UNTIL inp$<>""
        lc%=-22*inp$<>" "
      ENDIF
      PRINT SPACE$(20);CHR$(13);d$
      EXIT IF inp$=CHR$(3)
    WEND
    IF inp$<>CHR$(3)
      REPEAT
      UNTIL INKEY$<>""
    ENDIF
    OPENW 0
    SPUT screen$
    CLOSE #68
    CLR screen$
  ENDIF
RETURN
'
PROCEDURE break
RETURN
'
PROCEDURE disable
  LOCAL i%
  FOR i%=0 TO 5
    MENU i%+3,2
  NEXT i%
RETURN
