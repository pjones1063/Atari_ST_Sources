                                    GFA
                                  Class 6


    By now you must be wishing there were some way you could save and load 
data generated by your programs to and from disk. Well, that's what this 
lesson will cover. The command that allows us to do this is the OPEN 
command. It can be a very simple or a very complex command to use depending 
on how much you want to do with it. Lets examine its simplest forms here, 
enough to get you saving and loading data from disk. Its usage is: OPEN 
"Mode",#X,"Filename" where Mode may be 'O' for output to disk, 'I' for 
input from disk, 'A' for append to a disk file, 'U' for reading and writing 
to a disk file (update) and 'R' for a random access file. #X simply stands 
for a 'channel' number to use (normally 1) although you can use any channel 
number between 0 and 99 (who would ever have 100 open files at once?). 
Filename stands for the name of the file you want to create, load or append 
to. When you open a channel number to a disk file, you must always be sure 
you issue the CLOSE command when you're finished manipulating your data. 
Using the CLOSE command is easy, CLOSE #X where X is the same number you 
opened the file with. This all may sound a bit frightening now but bear 
with me, it will come easily soon enough. We OPEN a file with 'O' when we 
want to create a new disk file to store data in. Use an 'I' when you want 
to input data from disk into your program and use an 'A' when you want to 
append new data to an existing data file you created. 'U' and 'R' will be 
saved for future lessons when we've all covered and learned all the basics. 
They can get very involved and their use is outside the scope of this class 
at this time. Lets look at a simple example to help clarify what we've 
stated here (EX61):

Open "O",#1,"ourfile.dat" !Open with 'O' to create a file
Print #1,"Tom" !We print to our open channel (disk)
Print #1,"Chris"
Print #1,"Celia"
Close #1 !Must always close open channels when done
Edit

     This short routine created a file on our disk called 'Ourfile.dat' and 
'Printed to disk' the three names we told it to print. It then closes the 
channel number 1 (closes the channel between the computer and the disk) and 
then returns to the editor. If we exited GFA now and 'double clicked' on 
the file on our disk named 'Ourfile.dat', you'd see it printed to the 
desktop and it would look like this:
Tom
Chris
Celia
    You could actually load this file into any word processor as it's saved 
in straight ASCII format. Now to see how we could use a program to read our 
data back in (EX62):

Open "I",#1,"ourfile.dat" !Open our file for input ('I')
Input #1,A$ !Input from disk, not keyboard
Input #1,B$
Input #1,C$
Close #1 !Make sure you close the file
Print
Print "Our names were ";A$;", ";B$;" and ";C$;" on disk!"
Pause 200
Edit

 In the example above, A$,B$ and C$ could have been any string variable you 
assigned. All this routine did was to open the file for input from disk, 
use the Input #1 to input from our open channel (file) as opposed to 
getting the input from the keyboard, assign the data items input to our 
variables, close the file and then print our 3 variables (names). Getting a 
little clearer now? Lets see how we could append more names to our file on 
disk (EX63):

Open "A",#1,"ourfile.dat" !Open the file for 'A'ppend
Print #1,"Lisa" !Print another name to the file
Print #1,"Joe"
Close #1 !As always, close this baby
Edit

    GFA is smart enough to know that when we open a file in the 'A' mode, 
it doesn't touch the data at the top of the file, it simply adds our new 
data to the end of the file. Now we have 5 names on our disk file. Simple 
huh? There are of course as I mentioned several variations to this command 
but for this beginners class we'll stick with this method until we have it 
mastered. Once you've experimented with opening, creating, appending etc. 
disk files, I suggest you return to your GFA owners manual and study the 
examples presented in the book. You can learn a lot just from trying 
different methods.

     Now it's time to learn another useful (and necessary) command, DIM. It 
stands for dimension and it lets you define how many occurrences you may 
have of a particular variable. I'm sure you can see where if we had a disk 
file with 500 names, it would get very tedious typing all those input lines 
and it would be hard to remember which variable went to which name! This is 
where the DIM command really shines and saves us tons of typing. Usage is: 
DIM A$(X) where A$ is any variable you choose and X is how many of them you 
want to have. For example, lets say we DIM A$(5), this tells our program 
there will be 5 variables called A$ and they will be A$(1), A$(2), A$(3) 
etc up to 5.. Ahhh...should be getting clear(er) now....
    Lets consider our previous example that reads our names from disk. How 
many lines would it take using that method to load 50 names? Look at this 
next example closely as it will stay the same size whether you have 5 names 
or 500 (assuming you DIM A$(500) instead of 6) (EX64):

Dim A$(6) !We will have 6 'A$'s
Open "I",#1,"ourfile.dat" !Open our file for input from disk
For X=1 To 5 !Set up a counter
 Input #1,A$(X) !Input A$(1) then A$(2) etc up to 5
Next X
Close #1 !Close it
Print
Print "Our names on disk are:"
For X=1 To 5 !Set up another counter
 Print A$(X) !Print A$(1) then A$(2) etc up to 5
Next X
Pause 200
Edit

    The advantages would be much more apparent if we had a hundred names in 
our file. Since we don't always know how many items are in our disk files, 
GFA provides us with a command that prevents us from getting an error when 
we try to read more data than is in the file. If you try the previous 
example with only 3 names on the disk, you WILL get an error and it will 
stop your program cold. The EOF (stands for End Of File) command prevents 
this (as long as we use it!). Usage is EOF #x where X is the number of the 
channel (file) you opened in the OPEN command. It simply determines if 
you've reached the end of a file while reading it. Look at the following 
example (EX65):

Dim Nam$(50) !Dimension our variable to 50
For X=1 To 50 !Set up a counter
 Print At(24,24);"Enter 'END' to quit entering names..."
 Print At(10,10);
 Input "Please enter a name -> ",Nam$(X)
 Exit If Nam$(X)="End" Or Nam$(X)="END" Or Nam$(X)="end"
 Cls
Next X !First we get ALL our names (up to 50)
Open "O",#1,"NAMES.DAT" !Now we print them all to disk
For X=1 To 50
 Print #1,Nam$(X) !Each time through it increments NAM$(x)
 Exit If Nam$(X)="end" Or Nam$(X)="End" Or Nam$(X)="END"
Next X !Notice it exits if 'End' was in there
Close #1
'
Rem Now to see how EOF is used
'
Open "I",#1,"NAMES.DAT" !Open to input from disk
For X=1 To 50
 Exit If Eof(#1) !Exit if end of file #1 is reached
 Input #1,Nam$(X) !Input each item, 1 at a time
Next X
X=X-2 !Do you know why I subtract 2?
View_them:
Cls
Print
Print "There are ";X;" names in this file, which do you want to see";
Input Y
If Y=<X And Y>0 !Make sure we have the one you want to see
 Print At(30,11);Nam$(Y) !Prints your choice
 Print At(27,24);"Press any key to continue..."
 Key=Inp(2)
 Goto View_them !Keeps viewing until 'Y' is outside of 'X'
Else
 Edit
Endif

    Routines like this can be easily added to and expanded and turned into 
a full blown name and address type of database with very little else needed 
to make it the way you want it. One important thing to remember when you 
start working with a lot of variables is that you may only dimension (DIM) 
a variable once UNLESS you use the ERASE command to erase the variable and 
its' associated dimension. ERASE A$ would erase all your variables and 
allow to to redimension it and reuse the variable for something else. 
Another way to ERASE or release your variables is with the CLEAR command. 
Be careful when you use CLEAR though as it sets all numeric variables to 0 
and all string variables to "" (nothing!). If you just want to CLEAR 
certain variables you can use the abbreviated command CLR by specifying 
what you want to CLR (i.E. CLR A$,B$,NAM$,X,Y).

    Another valuable little tidbit is the CHR$ function. This function 
converts characters the ST is capable of producing (but doesn't have the 
keys for) so you can display them in your programs. With CHR$ you can 
display most of the ST's 255 characters. Usage is CHR$(X) where X is the 
ASCII number of the character you want to produce (refer again to appendix 
C of your GFA owners manual). Lets try another example (EX66):

Print At(1,8);
For X=128 To 255 !These are the numbers we'll show
 Print " ";Chr$(X);""; !Print them
Next X
Print At(18,22);"Did you know you had all these keys?"
Print At(24,24);"Press any key to exit..."
Void Inp(2)
Edit

    Another necessary command is the RANDOM command. It generates RANDOM 
numbers which you'll sometimes need. Usage is: RANDOM(X) where X is the 
upper limit (number) you want RANDOM numbers generated for. It always gives 
you numbers between 0 (inclusive) and X (exclusive). The following example 
simulates the RANDOM roll of a die (EX67):

Print At(24,24);"Press any mouse button to quit!"
Do
 X=Random(6)+1 !See below
 Print At(39,11);
 Print X
 Pause 50
 Exit If Mousek<>0
Loop
Edit

    The reason the '+1' is there is because with RANDOM(6), you'll get 6 
RANDOM numbers between 0 and 5 so we add 1 which makes our numbers between 
1 and 6!

    Another handy command is the UPPER$ command. Its' purpose is to convert 
any string variable to all uppercase characters. Usage is: UPPER$(A$) where 
A$ is the variable you supply. Examine the following example (EX68):

Top:
Cls
Print At(1,11);"Please enter some lowercase text and press return -> ";
Form Input 25,A$ !Get up to 25 characters
Print At(36,13);"Thanks!"
Pause 75
B$=Upper$(A$) !Convert them to uppercase
Print At(1,15);"Here's what you entered -> ";A$;"" !Print originals
Print At(1,17);"Here's after 'UPPER$' fixed it to all capitols -> ";B$;""
Print At(10,24);"Press left mouse button to do it again or right button to 
exit..."
Repeat
 Exit If Mousek=1
 If Mousek=2
 Edit
 Endif
Until Mousek<>0
Goto Top

    This wraps up another lesson, we're getting there. We've already 
discussed the majority of the commands available to us in GFA however, I've 
held off on some of the juicier ones till the end. If you're studying these 
examples and experimenting with the code, you're learning. Use your GFA 
manual to refer to their examples once you understand the basic concepts of 
the commands. When we get to the more powerful functions (read, more 
complicated), being able to interpret the manual and their examples will 
almost be a necessity. Happy coding!!

 Tom Hayslett
 STar Users Group

