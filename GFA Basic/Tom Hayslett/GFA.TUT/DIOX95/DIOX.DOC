
                           DIOX version 0.95
                            Copyright 1987
                          by Paul Huntington
                           ----------------
     
     A complete DIOX system should have the following ...
               
               DIOXMH95.PRG   ---------> The program itself
                                         (med/hi res, v0.95)     
               DIOX.DOC   -------------> This documentation
               DRAW_BTN.LST  ----------> Procedure to be merged
               BOXTEST.BAS   ----------> The dialog box tester
               
     Plus an example ------------------------------------------     
               EXAMPLE.DAT/.DSH -------> Exmples to create with
               EXAMPLE.LST  -----------> Example dialog box
     
     (Part 1)
     INTRODUCTION:                    
     ---------------------------------------------------------
          The purpose of DIOX is to allow the GFA BASIC programmer 
     to quickly and easily create and edit dialog boxes. It 
     will do this by allowing the programmer to visually place 
     and edit the various dialog box buttons, choose thier 
     'properties' and then generate the actual source code to 
     implement the dialog box. My goal is to eliminate the chore 
     of writing user interfaces so that programmers can 
     concentrate on writting JUST thier applications. No time 
     should be spent on user interface mechanics, instead most of 
     the time should be spent on user interface layout and 
     proccessing the data in a programmers application. Will DIOX 
     accomplish this for you? In my opinion, it should. BUT YOUR 
     OPINION IS WHAT DETERMINES IF DIOX WILL DO ANY GOOD FOR YOU, 
     NOT MY OPINION! What that means is, if for any reason, any 
     version of DIOX won't do a job you're using it for in any 
     particular way, manner, or form, THAT IS NOT MY LIABILTY, IT 
     IS YOURS. IF DIOX screws you up due to a bug, or any other 
     shortcomming, then YOUR the one who got screwed up, not ME, 
     because I'm not legaly responsible for your use of DIOX. I 
     do feel morally responsible for DIOX itself, so I plan to  
     to support it. Your use of it is up to you. In case 
     you didn't recognize what I've just said, it is called a 
     'WARRANTY DISCLAIMER', only this is in plain English. I've 
     taken every step I know to insure that DIOX is reliable and 
     bug free, but nothing is ever perfect. 
     
          Version 0.95 has everything I wanted to add EXCEPT 
     EDITABLE BUTTONS. DIOX v1.0 will have editable buttons! 
     This present version will allow you to graphically layout, 
     edit, save, and load an entire dialog box at a time. You can
     have RADIO, TOGGLE, and EXIT buttons in your box. You can 
     also have one ENTER and one CANCEL button for each box. More
     on those two shortly. DIOX will work in ALL resolutions.
               
     FILES FOR DIOX  v 0.95 :
          
          DIOX.PRG is DIOX itself. DIOX v 0.95 is 238,508 bytes of 
     pure, 100%, GFA BASIC, compiled with version 1.8 (US) GFA 
     Compiler. The source code will be uploaded to various BBSs 
     if there is a whopping demand for it.

          DRAW_BTN.LST is to be merged in with your GFA program. 
     You need not know how it works (read the TEST_BOX.BAS listing 
     if you're curious about it). The DRAW_BTN.LST file is a 
     procedure which draws a line of text centered in an optional 
     box frame. ALL DIOX DIALOG BOXES CALL THIS! Just merge it 
     and forget it. The DRAW_BTN.LST file with DIOX v0.95 is 
     DIFFERENT from the one with v 0.90. USE v0.95s' instead 
     of 0.90s'. It will be compatible with any DIOX v0.90 buttons.

          DIOX.DOC is, of course, this documentation to DIOX. 
     It is divided into THREE parts :
                    1) Introduction
                    2) "EDITING" tutorial to get you quickly into 
                       editing dialog boxes
                    3) "INTERFACING" explains how to interface
                       your new dialog box into your program.
     
          BOXTEST.BAS is a short program to test any dialog box 
     that you make. Merge in your dialog box ".LST" file that you 
     generated with DIOX, rename the 'Yourbox' in the listing on 
     one of the first few lines to your own boxes' name, then run 
     it. 
     
     
     
     (PART 2)
     EDITING :     
     ---------------------------------------------------------     
          You start out with DIOX by selecting 'Create'(Unless you 
     have a file to load off disk). The program wants a procedure 
     name for the button. Use up to 32 characters of the type that 
     would normally be allowed in a GFA BASIC PROCEDURE NAME. That 
     means only uppercase-alpha, lowercase-alpha, digits 0-9, and 
     the underscore " _ " character. If an ENTRY ERROR is made an 
     alert box will come up. If this happens, clicking 'OK' will 
     send you back to edit your response, and clicking 'Cancel' 
     will abort the creation. When finished entering the ITEMS 
     NAME, you may wish to jot it down if you think you can't 
     remember it. This will be important to you as you use it in 
     your program, as this is the name that will be passed back 
     to you if the button is clicked on during your programs' run.
          
          Next you may want to select STRING under the TEXT 
     heading. This allows you to type in the line of characters 
     that will be in the button . NOTE: DON'T USE THE DOUBLE QUOTE 
     CHARACTER (")! DIOX will check for this error. You may use 
     any of the non-keyboard characters by typing CTRL-A, the 
     ASCII code of the character you want (in your GFA manual), 
     and a cursor key. The special character you want should be 
     visible then. For instance, to get an UP ARROW symbol, type:
     
                    CTRL-A, 1, then any CURSOR KEY.
               
     You are allowed 70 characters for medium or high res, 35 for 
     low res. 
     
          To create a border simply press '+' and keep pressing 
     it until the border is as thick as you want. If you want to 
     reduce the border thickness, press '-' until the border is 
     as thin as you want it. You can keep doing this until the 
     border is gone. Your buttons don't HAVE to have borders. If 
     you are making an AUTORES box and are doing it from MONO, 
     you may wish to make a default buttons' thickness a little 
     thicker than normal, as auto res cuts thickness in half on 
     medium res from its' original MONO size. That's so it can 
     squeeze evrything onto a medium res screen. To increase the 
     size of the box area, press CURSOR UP for increased vertical 
     size and press cursor right for increased horizontal size. 
     CURSOR DOWN decreases vertical border size and CURSOR LEFT 
     reduces horizontal border size. 
     
          To actually move the button, place the arrow on top of 
     the button, click the RIGHT MOUSE BUTTON, and move the mouse. 
     Note that the arrow disappears. This picks up the button so 
     that it moves with your mouse movements. This also ACTIVATES 
     the button. ACTIVE means that the button is now the present 
     button being worked on, and so whatever text, border, or 
     attribute changes you make will be made to the ACTIVE button. 
     To lay down the button, click the LEFT MOUSE BUTTON. You may 
     need to click it twice, as GFA BASIC seems to miss a click 
     occasionaly, but usually once is enough. The +, - and cursor 
     keys will work either when the button your working on is 
     being moved or when the button is layed down. 
                                                                  
               Now you know how to CREATE your first button, 
     make its' TEXT, create its' BORDER, MOVE and PLACE it, and 
     ACTIVATE it for further editing at any time. You can also 
     change its' text SYTLE, SIZE (not in AUTORES), COLOR (not in 
     AUTORES or MONO), choose weather you want to have it drawn in 
     reverse or not by using the SELECTED option, (RADIO and 
     TOGGLE buttons will not be effected by this in the final, 
     generated code. You pre-set these by a PROCEDURE call, more 
     on that later), and choose what ATTRIBUTE it has. ATTRIBUTES 
     are what the buttons do when they are selected. Let's talk 
     about ATTRIBUTES.
     
          DIOX has SIX ATTRIBUTES in its' Attr menu strip. RADIO, 
     TOGGLE, EXIT, DEAD, ENTER, and CANCEL. 
     
     RADIO:
          RADIO is when you have a group of buttons, but only ONE 
     button can be selected at a time. A "set RS 232 port" dialog 
     box prbably uses a group of radio boxes to set the baud rate, 
     as you can only choose a single baud rate out of several 
     choices. DIOX allows FIVE distinct groups of radio boxes. 
     When you want a button to be a radio button, just select the 
     RADIO option. A dialog box will appear with five buttons 
     labeled "Group 1", "Group 2", "Group 3", "Group 4", and 
     "Group 5". It also has an OK and a cancel button. Select one 
     of those groups and then hit Return or click on OK. Cancel 
     simply aborts any changes. Now, when you see the Attr strip 
     scroll down again, you'll see RADIO's  been checked. The 
     buttons' attribute is now set. 
     
     TOGGLE:
          Or, maybe you'd rather have it as a TOGGLE button 
     instead. Simply select the TOGGLE option. It will be checked 
     when selected. A toggle button will simply reverse its' state 
     when it's been selected. So if the button is in a turned-off 
     state, it will turn on (reverse) when clicked on. If it is in 
     a turned-on state, it will be turned off when selected. 
     
          RADIO and TOGGLE are the only two button types that are 
     pre-selectable from your eventual program (via what variable 
     you pass to it in your procedure call- more on that later), 
     they are NOT presetable from DIOX even though you can reverse 
     them there.
     
     EXIT:
          EXIT buttons are also available. Again, just click on 
     that option to make your button an exit button. An exit 
     button will cause an exit from the dialog box when selected. 
     First, though, it will reverse for a moment, just to look 
     like it has been selected. 
     
     DEAD:
          DEAD is the default when DIOX first starts up. A dead 
     button does absolutly nothing when selected. It is for a 
     display only. Most of the text in the help screens of DIOX 
     are dead buttons. 
     
     ENTER:
          A button given the ENTER attribute is the only DEFAULT 
     button DIOX gives you. By DEAFULT I mean that it will be the 
     button selected when RETURN is pressed. It can also be 
     selected in the usual way with the mouse. When an enter 
     button in your dialog box is selected, the dialog box is 
     exited with the newly selected settings of the other buttons 
     passed back to the main program. Don't worry if you don't 
     understand 'passed back', I'll explain that shortly. 
     
     CANCEL:
          A CANCEL button, like ENTER and EXIT, will cause an exit 
     from the routine if it is selected in your programs' dialog 
     box. However, a CANCEL button will cause any of the new 
     button settings to be disregarded and will pass back the old 
     button settings you went in with. Another words, it will 
     cancel any changes made to the dialog boxes' settings. 
     
          Niether CANCEL or ENTER will ever pass back thier own 
     names. TOGGLE, RADIO, and EXIT buttons' names ARE passed back 
     if they were selected.
     
          In summary, The RADIO attribute will cause only one out 
     of a group to be selected. TOGGLE will always reverse the 
     button when selected. EXIT will cause an exit from the dialog 
     box with all new selections passed back. DEAD will do 
     nothing. ENTER will cause an exit if either the return key is 
     hit or it is selected by mouse, passing back all the new 
     selections. CANCEL will exit the dialog box BUT passing back 
     only the PRE-SET values you went in with, canceling all new 
     selections.
     
          A tip on ENTER buttons. Generaly, you'd want to make 
     thier borders thicker, as it is generally understood that 
     thicker borders constitute default. Another note: You should 
     use only ONE enter button per dialog box. DIOX will not 
     restrict you to this, but I don't know what would happen if 
     you put in two defaults.
                   
          Thus far, I have explained how to create a button, put 
     text into it, make its' border, select size, style, and color 
     of text, reverse a DEAD, CANCEL, or EXIT button from DIOX, 
     and assign a button one of six attributes and what those 
     attributes were. 
     
          Now you'd probably want more than one button in your 
     box. So, simply select CREATE and start up another button. 
     NEVER USE THE SAME NAME FOR DIFFERENT BUTTONS! DIOX will 
     check for this. Since there was a previously active button, 
     the name of the last button activated will be the default 
     text in your edit space. You may only wish to change one 
     character if you have a system of simular buttons, such names 
     as Color_a, Color_b, or you can totaly re-enter a whole new 
     name. If you enter the same name that was there before, NO 
     NEW BUTTON IS CREATED. The creation is just aborted. ALL of 
     the new buttons' properties default to the properties of the 
     LAST ACTIVE BUTTON. You have to change those properties if 
     you want a different looking and/or acting button. Changing 
     an activated buttons' properties is just a matter of 
     selecting the appropriate options, as before. Don't worry, 
     you won't lose the properties of the last button, it was 
     stored away when you made a new button and can be recalled by 
     activating that button again.

          When all buttons, except the first, are created, they 
     will already be picked up by your mouse. That is so they 
     won't suddenly pop into existance on some other button. 
     Simply take them to where you want to put them, and left-
     click the mouse to put it down. 
     
          With more than one button on your screen, you must have 
     a method of directing your text, style, attribute, etc 
     changes to just the one button you're working on. This means 
     you must ACTIVATE the button. You do this by placing the 
     mouse arrow over the button. Then you can either click the 
     right mouse button, which will always mean moving your 
     button at least a few pixels, or you just can press return 
     and not disturb its' position on the screen. Doing either one 
     of these things says to DIOX " I want to work on THIS button 
     now ". When you ACTIVATE a button all of that buttons' 
     characteristics are now displayed in all the menus. The 
     options of CREATE and RENAME( explained below ) will print 
     the buttons' name out when they are selected. The TEXT and 
     ATTR menu strip will display checks at all places which were 
     last selected for THAT button. String option will print the 
     buttons' text out as default when selected. The radios' 
     dialog box will display a radio buttons' group number. This 
     is how you go about getting a status report on a particular 
     button you want to check. Just activate it, and look at all 
     the menus and thier options. They all reflect the buttons' 
     status. I had to use seperate drop down menus to display and 
     set all the settings of a button ( except radio grouping ) 
     because, guess what, I had no efficient method of making 
     dialog boxes. DIOX 0.95 may be 'gutted' and re-fit with a 
     single dialog box for making most of those drop-down menu 
     options for version 1.0. I now have a dialog box editor to do 
     that with.  
     
          To DELETE a button, ACTIVATE the offending button and 
     press DELETE. The PRESENTLY ACTIVE BUTTON will be gone 
     forever. If you kept pressing DELETE after that, the 
     previously created button from the one just deleted will be, 
     you guessed it, deleted. It keeps going back to the first 
     button.
     
          RENAME is another option you may need. If you wanted to, 
     you could just change the name of a button without creating a 
     new one by selecting this option.  
     
          Also, two new additions to v0.95 are ROUNDED and SEE 
     THRU options. Rounded will cause the buttons' border to have 
     rounded edges. See thru will cause the buttons' background to 
     be transparent. When reversed, anything under it will be 
     reversed. This is usefull for puttings several lines of text 
     under a single button. I am planning on putting a clip-art 
     option onto DIOX, so pictures can be under this button as 
     well as text. 
     
          What have you learned? By now you should know ....
     
               How to CREATE your first button
               How to make TEXT for your button
               How to change the STYLE, SIZE, and COLOR of text
               How to edit the text in your button
               How to add a border line around your button
               How to make the border line THICKER or THINNER
               How to make the border AREA larger or smaller
               How to assign an ATTRIBUTE to a button
               How to MOVE your button and PLACE IT somewhere
               How to CREATE MORE buttons 
               How to ACTIVATE any particular button 
               How to change the SETTINGS of any button, any time
               How to RENAME a button
               How to DELETE a button
               How to make ROUNDED buttons
               How to make TRANSPARENT buttons
     
          You now know how to make, edit, and manipulate buttons, 
     I hope. If not, PLAY-PLAY-PLAY with DIOX! Look at the example 
     given in this text. READ the HELP screens in DIOX (press 
     HELP). 
     
          OKAY, let's move on to some artistic detailing. You've
     completed all your buttons and laid them down nicely right 
     next to each other in neat little rows (unless your into 
     'new-wave' dialog boxes). Now you may wish to enclose your 
     buttons in a box, to graphically seperate them from the rest 
     of the screen. Just select the BOX option. This is 
     different from the older v0.90 version of DIOX. Now you 
     select a fill pattern for the box first. It can be any one of 
     36 patterns, solid white, or transparent (a frame). Click on 
     this with the left mouse button. The box is now started by 
     placing the cross on a point where one corner of the square 
     is to go. Then click the RIGHT mouse button. Move the mouse 
     around until the frame is the desired shape. Click the LEFT 
     mouse button to lay down the square. To delete any shape, 
     press UNDO and the last shape drawn (not nessesarily the 
     last created because of the bottom option) will be deleted. 

          Let's again review what should now have been learned. 
     Do you know how to use DIOX to do all kinds of things to all 
     kinds of buttons, including making a button go away? I 
     explained how up there. How about making shapes to enhance 
     the appearance of your box? You know how to make shapes go 
     away too, right? GOOD! Now we move on to our final 
     destination. GENERATING THE CODE THAT WILL DO ALL THIS!
     
          The SAVE option starts all this 'program generating' 
     up. When all is well with what you've laid out, you'll want 
     to select SAVE. The first thing that pops up is a request to 
     enter the dialog boxes name. Again, same as the BUTTONS' 
     name, a procedure name. IT MUST BE DIFFERENT FROM ANY OTHER 
     NAME USED IN YOUR BOX. Same as the BUTTONS' NAME rules. It 
     will be checked for uniqueness by DIOX. This is the name you 
     will use to call your box from your procedure. Once you've 
     selected the name and pressed return, a SAVE OPTIONS menu 
     will come up. You can choose to save only the DIALOG BOX 
     DATA, or to just generate a LST file (your dialog box 
     routine), or BOTH. Another option is to make your dialog box 
     RESTORE THE SCREEN AFTER EXIT. A REPORT can be sent to the 
     printer. This will list the dialog boxes' procedure name, and 
     each individual buttons' name, text line, and attribute. I 
     havn't put in a printer check routine, so have everything 
     ready for this. You can get JUST a report without saving by 
     selecting this then selecting cancel at the forthcomming file 
     selector box. The last item is the BUTTON DELAY. This 
     controls how fast the dialog box reacts to your clicking of 
     the mouse button. It defaults to 4. 0 is fastest, 9 is 
     slowest. Select OKAY when done. Now a file selector box will 
     appear. It wants a name to save your .LST file which is the 
     code for your dialog box. Make sure you type in that .LST 
     extender, as DIOX will not add it. When you press return, 
     DIOX starts churning away. The new 0.95 version will now 
     write code to the screen as well as disk, so you see it as 
     it's being written. DIOX will also comment on every new 
     procedure as it creates it. It can be a show. It takes a few 
     seconds to a few minutes to generate a dialog box routine, 
     depending on its' complexity. When the thing stops, you'll 
     know it, as the picture redraws itself and the bee has turned 
     back into an arrow. WARNING! WARNING! I have NOT used traps 
     in DIOX. If you forget to place a disk into the drive or some 
     other catastrophe occours, THE PROGRAM WILL TERMINATE! And 
     your work along with it. Make sure all is well BEFORE using 
     DIOX. OH, before I forget, two other files are laid down 
     besides your .LST file. A .DAT file is the raw data on the 
     dialog box and each of the buttons. A .DSH file is the data 
     on the shapes in your box. THESE ARE WHAT IS LOADED BACK IN 
     FOR FURTHER EDITING. So, now that we have generated a routine 
     that is supposed to implement your design, let's not go right 
     into testing it. First let's cover our last feature, LOADING.
     
          To LOAD in a previously SAVEd dialog box, hit ESC. This 
     will CLEAR and RESTART the whole program. Now, select the 
     LOAD option. The file selector will come up with the name of 
     the .DAT files on your directory. It wants to load the .DAT 
     and .DSH files that were previously laid down from SAVE. It 
     doesn't care about the .LST file. Once loaded, your started 
     with the first, created button as your active button. Your 
     ready to continue editing using all the above described 
     features. NOTE! If you load in a file created with DIOX 
     0.90 into DIOX 0.95, and it had FILL patterns in it, they 
     will not show up. Erase all shapes and start them over again 
     with v0.95s superior method. Remeber, the old fills won't 
     show up, so when deleting, hit UNDO twice. You won't hurt 
     anything by UNDOing too many times. I have kept the BUTTON 
     compatibilty with 0.90 flawless, despite the two new button 
     features (rounded and see thru).

     
     (PART 3)
     INTERFACING
     -------------------------------------------------------
          So, I assume you have a generated .LST file you'd like 
     to quickly put into a program and test. The program called 
     TEST_BOX.BAS will to just that. It has instructions in its' 
     listing for merging it in and testing it. I'll explain it 
     here:
     
          Step 1) MERGE your dialog box program into TEST_BOX.BAS 
     either where the listing says you should or in the end of it. 
     Just be sure you don't merge it in the middle of the only 
     other procedure in there, the DRAW_TEXT_IN_BOX procedure. GFA 
     BASIC will not allow procedures within procedures. 
     
          Step 2) RENAME the Procedure call, @Your_box_name, to
     your boxes actual name. It is on the first few lines of 
     TEST_BOX.BAS.
     
          Step 3) RUN IT!
     
          Notice, everytime you select a box you made into an exit 
     box, an enter box, or a cancel box, your box disappears and 
     some names appear inside parentheses, along with other 
     parentheses which are empty. Do some of those names look 
     familiar? Those are the names you assigned to those buttons. 
     When ever a TOGGLE, RADIO, or EXIT box is selected, thier 
     names are passed back between parentheses in one string. Now 
     hit a key. Your dialog box will come back, with the 
     previously selected toggle and radio boxes now pre-selected. 
     Your previous choices were 'echoed' back so you could see 
     that all aspects of the dialog box work. To stop, just press 
     CTRL-SHIFT-ATL as usual. You have now tested your box. Don't 
     bother saving what you've got here. Your goal is to merge it 
     into YOUR program, not the test shell.
     
          Now that you've tested it successfully (I hope), let's 
     talk about INTERFACING it to your program. Figure 1
     illustrates a flow chart of how the box is linked to your 
     program and a little of how your box will work.
     
          The statement you must make to call your dialog box is
     a simple, one line affair. NOTE: YOU must clear the screen 
     before AND after the box is drawn. Maybe save a screen 
     temporarily using SGET and then doing a CLS. Call your box.
     When it's finished, use SPUT. I have elected NOT to do this 
     from within a DIOX procedure as it would cut down on the 
     ability of more advanced effects, like thumbwheels perhaps.
     DIOXS' DIALOG BOXES WILL NOT ERASE ANYTHING. THEY DRAW IT AND
     LEAVE IT! The before and after of the dailog box is up to 
     you. You make a GOSUB call (I prefer @) with only two strings 
     in the parameter list (parameter list is the part in the 
     parentheses next to the GOSUB statement. They are seperated 
     by a comma. See GFA MANUAL for more info.) 
     
          The first string is the PRESELECT. This string YOU 
     provide. It can be an empty string if you like, a "" can be 
     put there. If this is the case, none of the toggle or radio 
     buttons will be preselected. Or, if you choose to preselect, 
     simply take the name of the toggle or radio button you typed 
     in when you CREATED it from DIOX, surround it with 
     parentheses, (Like_this), and attatch it to the string. The 
     toggle and radio buttons you specified will then start out in 
     a selected state for default selections. You COULD specify 
     more than one radio button per group be preselected, but then 
     that radio group acts 'wierd', so you'd want to make sure 
     your specifying no more than one radio button per group. 
     Common sense.
     
          The second string, the POST-SELECT, must always be a 
     VARIABLE preceded by an asterisk (*) character. That makes 
     that variable a RETURN variable. A return variable is one 
     which is changed by the procedure. YOU provide the string 
     variables' NAME, and the DIALOG BOX will provide the string 
     varibables' CONTENTS. After you've called the dialog box and 
     it has returned (finished, been exited from), you can now 
     use that returned preselect variable as the method of seeing 
     what selections were made on the dialog box. It's format will 
     be exactly the same as the preselects' variable except that 
     it will have an EXIT button name if an EXIT button was 
     chosen. How do you test if a particular name is in your 
     postselect string? Use the INSTR function. The GFA manual 
     has more info on this function, but basically you'd do 
     something like : 
               IF INSTR(Postselect$, "(Buttons_name)")>0 
                 YUP! That button was selected
               ELSE 
                 NOPE! That button was not selected
               ENDIF
     
     
     
     CONCLUSION --------------------------------------------
                 Well, did I cover everything on DIOX? 
                    I probably forgot some things. 
      If you run into trouble, leave me EMAIL at GEnie where my 
     address is PHUNTINGTON or on MICHTRONS' Sig there. OR, some 
     local (San Diego, Ca.) BBSs I haunt are MIDI (619)452-7535 24 
     hours/7 days 1200/2400. SDACE (619)284-3821 24hr/7days 1200/ 
     hopefully 2400 soon. My address is also on the Intro screen 
     of DIOX. Good luck.
     
      -------- Paul Huntington
     
     
     
     
     
     
     
     
     
     
     
     
     
     
               |                  (FIGURE 1)
               |                   
           your program                               
               |
               |                  Passing
             \ | /                preset names for
              \ /                 radio & toggle. 
     Gosub Your_boxes_name -------------------------> Now your                  
               |<----------\                      dialog box is
               |           |                      in control.
       continue with your  |                            |
            program        |                          \ | /
               |           |              /----------> \ / 
             \ | /         |              |      If a button is
              \|/          |              |      selected, is it a
                           |              |      EXIT,ENTER,or 
                           |              |      cancel button?
                        Passing back      |             |
                     names of buttons     \------ NOPE, loop again
                     de-limited, or                     |
                     seperated by,                      |
                     parentheses.                       |
                           |                            |
                           ----Send back NEW----- YES, ENTER/EXIT
                          /|\  selected exit,           |
                           |   toggle & radio names     |
                           |                            |
                           \---Send back OLD----- YES, CANCEL
                               Preset radio, toggle
                               button names that
                               were sent IN. No changes.
     
     
     
     -----------------------------------------------------------
     
     
     Let's step through an example on how to construct a dialog 
     box. First load up the BOXTEST.BAS file. We're going to see 
     an example which I have previously done. We are going to see 
     how it works when in action. We want to this this first 
     because you are going to build up an identical box, and you 
     probably want to see what it SUPPOSED to do and look like. 
     Now that you are in the BOXTEST.BAS program, merge in the 
     EXAMPLE.LST file into an appropriate spot. A few lines from 
     the top of the program you'll notice a statement 
     
               @Yourbox (Preset$,*Postset$)
     
     rename that statement to

               @Exmple_box (Preselect$,*Postselect$)
     
     and now run the program and the dialog box should appear in 
     the upper half of the screen. This is a self-adjusting 
     AutoRes dialog box. It will appear the same in mono or medium 
     res color. Now twidle with everything and see what it does. 
     Note that when the EXIT buttons, Cancel button, and Okay 
     button is clicked on, the box exits as your choices are 
     printed out. Ok, now you know what you've got to make. So 
     let's do it.
     
          Load and run DIOX.PRG. Press return if you've already 
     read the title screen. In medium or High res, an alert box 
     will come up and ask if you want your box to automatically 
     adjust to medium and hi res. Select YES. Now, select the load 
     option and let's take a look at our initial example. Load in 
     the EXAMPLE.DAT file. If your operating with a color monitor 
     in medium resolution, look at what happens to this dialog 
     box! It is not the same thing as you saw on the demo! 
     Although everything fits onto the screen, it covers both 
     halves. That is because AutoRes only effects the LST file 
     which DIOX generates, NOT the actual data of the .DAT or .DSH 
     files, nor will its' draw routines adjust more than the SIZE 
     of the fonts. No matter. It still is editable. But we don't 
     want to edit this. We want to MAKE this. So we will start 
     over by pressing ESCAPE. Then press return. Then select YES 
     to AutoRes again.
     
          Now, let's CREATE our first button. Select the create 
     option from underneath the 'Item' drop down menu. It asks for 
     an ITEMS procedure name. That should actually be BUTTONS 
     procedure name, but DIOX is out already, so I'll correct that 
     next time. So now we enter "RADIO_A_1" and return. Nothing 
     should appear to happen on the screen. 
          
          We need to make the buttons' TEXT, so select the STRING 
     option from the 'Text' drop down. Now it wants a String of 
     characters for your button. Enter "Radio A 1" and return. Now 
     you should see a line of text on the screen as "Radio A 1". 
     You've just typed it in. 

          Pick up the button and move it twoards the right side of 
     the screen. You do that by placing the mouse arrow over the 
     button. Press the RIGHT mouse button for a moment. Now the 
     arrow will be gone and the button moves with the mouse. place 
     it where you previously saw the same "Radio A 1" button in 
     the example (on the right side of the screen, a little up). 
     When placed correctly, you can either press the LEFT mouse 
     button to set it down, or ALT-INSERT (you may need to do 
     either twice as I've noticed GFA can occaisionaly miss a 
     click).  
     
          Let's make a border (you could mess with its' border 
     while still in movement mode, if you wanted) by pressing the 
     '+' (plus) key once. Now let's increase the horizontal size 
     of the border by pressing the cursor right key twice.      

          So we have our buttons' physical appearance in order. 
     What else do we have to do? How about telling DIOX that this 
     is going to be a RADIO button. So go to the 'Attr' drop down 
     and select RADIO. A dialog box pops up and presents you with 
     a choice of five different 'groupings' of radio buttons. 
     Select group 1. Hit return. This button is now a radio button 
     in radio group 1. 

          Now let's create the next RADIO button, the one we saw 
     in the example as "Radio A 2". Go to CREATE and select it. 
     Now we have the previous text to edit, as DIOX now has a 
     default to present. ALL menu options will reflect the LAST 
     BUTTON YOU ACTIVATED. We don't have to do a complete re-
     typing in order to get "Radio_A_1" to "Radio_A_2". Press the 
     DOWN cursor button and you're cursor goes to the end of the 
     text line. Hit BACKSPACE once and then press '2'. Hit return.
     From now on, everytime you create a button, it will 
     automatically start off as being picked up.
     
          How about a tip on how to do some precision positioning 
     of buttons? We want a profesional look, yet v0.9 lacks 
     autosnap. No problem. What we want to do is precisley align 
     the new button under our previous one. So, position it 
     approximatley with the mouse just under the other button, the 
     upper edge of its' border should just touch the bottom of the 
     first buttons' border. Next, let go of the mouse and start 
     using the keyboard. Alternate- left cursor or alternate- 
     right cursor will move the button one charcter space left or 
     right. Shifted- alternate- left and right cursors will move 
     left and right one pixel. The same applies for up and down. 
     Now position the new button so its' left and right sides are 
     flush with the old buttons' left and right sides. Use the 
     SHFT-ALT-RIGHT/LEFT for that movement. Use the SHFT-ALT-
     UP/DOWN for precise alignment of the buttons' top edge to the 
     old buttons' bottom edge, so they just touch. Now, you've got 
     the left-right alignment correct, okay? And the two buttons 
     are just touching vertically? Good. NOW, press ALT-DOWN 
     cursor once. You now have the ability to uniformly space 
     buttons, because ALT-Cursor always spaces the same distance. 
     The next button under this one you put a single ALT-DOWN from 
     this button, and so on. It works like that for horizontal, 
     too.

          OK, so now your button is precisley in place. So as not 
     to disturb its' position, use the ALT-INSERT button as a 
     substitute for the LEFT mouse click. You may need to do it 
     twice in a row. I use the ALT-CRSR-INSERT keys constantly! 
     They're how I line things up! 
     
          Now we have to edit its' text. Select the STRING option 
     and simply edit "Radio A 1" into "Radio A 2" by the same 
     method as you did with editing by CREATE. Generaly, you may 
     sometimes wish to temporarily lay down a button, change its' 
     text, then pick it up to line it up. That is because your 
     text length may vary, and so will your buttons' border 
     dimensions. In our case, the text size was the same, so our 
     previous alignment was not futile.
     
          How about our most recent buttons' attribute? We 
     haven't messed with that yet. Look at the 'Attr' drop down 
     menu. As you can see, it is already checked-off in front of 
     RADIO. Let's see if our group is still the same. Select 
     RADIO, and there you see that Group 1 is selected already, 
     which is what we want. Press RETURN. You did not HAVE to 
     check the attribute like that, as it was defaulted to that 
     already. I just wanted you to see it for yourself.
     
          Now see if you can make a button whose name is 
     'Radio_a_3' and whose text is "Radio A 3". Position it under 
     the button whose text is "Radio A 2" by one ALT-DOWN length. 
     Remember that its' attribute defaults to radio group 1 if you 
     don't change it, which we don't want to do. Now create 
     another button called 'Radio_a_4' and give it a text line of 
     "Radio A 4". Position it under the button whose text is 
     "Radio A 3" by the length of one ALT-DOWN. All four buttons 
     should now have uniform, even spacing. 

          Let's change gears a little. We are now going to make 
     another 'grouping' of radio buttons. Let's only put in three 
     buttons this time. CREATE a button entitled 'Radio_b_1'.
     Give a line of text: "Radio B 1" and position it to the left 
     of the button "Radio A 1". Make it four ALT-RIGHT lengths 
     from the button. NOW, we DO want to make some modification to 
     the attribute, as we are dealing with a different radio 
     group. Can you guess how we will deal with this? Yup. Select 
     RADIO from the drop down, select, oh, Group 4 maybe, (that is 
     what the examples' is) and hit return. Now create a button 
     entitled 'Radio_b_2' and give it text of "Radio B 2" and 
     align it one ALT-DOWN length beneath the "Radio B 1" button. 
     Make one more button called 'Radio_b_3', give it text of 
     "Radio B 3" and put it beneath "Radio B 2" by one ALT-DOWN. 
     Remember, the attributes of the last two buttons default to 
     the previous buttons' if you make no changes. We want no 
     changes from "Radio B 1". 
     
          How about something different? Let's make a TOGGLE 
     button. First, create a button called 'Toggle_1'. Give it 
     text of "Toggle 1" and put it twoards the upper left of the 
     screen. Now, let's select the TOGGLE attribute by selecting 
     TOGGLE from the 'Attr' drop down. Poof! You've got a toggle 
     button. Make a second toggle called 'Toggle_2' and put it one 
     ALT-DOWN beneath 'Toggle_1'. The attribute is still toggle, 
     remember? 
     
          Make two EXIT buttons now. Call one 'Exit_1' and give it 
     text of "Exit 1" and place it several ALT-DOWNS under 
     "Toggle 2". Now select EXIT form the 'Attr' strip. Call the 
     other 'Exit_2' and give it text of "Exit 2" and place it one 
     ALT-DOWN beneath "Exit 1".

          How about making a CANCEL button? And we want an ENTER 
     button, too. Create a button called 'Okay' and make its' text 
     "Okay". Position it in the upper middle of the screen. Select 
     an attribute of ENTER. This is going to be a default button, 
     so let's graphically indicate that by pressing '+' a few 
     times, thickening the border. Create a button called 'Cancel' 
     and give it text of "Cancel". Position it below "Okay" a few 
     ALT-DOWNS. Select the attribute of CANCEL. Also, press '-' a 
     few times to get rid of the thicker border. Make it one 
     pixel thick, like the others. 
     
          DETAILS! Where's the titles? How about creating a button 
     called 'Radio_title' with text of "RADIO". Place and center 
     this button above the radio buttons. Remember the example? 
     Select the DEAD attribute. This is just for display. Create a 
     button named 'Toggle_title'. For a text line, let's use a 
     special Atari ST character not found on the keyboard. How? 
     Select STRING. Delete what's there now. Type CONTROL-A. Enter 
     the digit 4. Press a cursor key. There's the RIGHT ARROW 
     symbol, whose ST-ASCII code is 4. Continue to type in 
     "Toggle". Position the button to the right of the toggle 
     buttons. Create a button called 'Exit_title' and give its' 
     text line as in toggles', only type in "Exit" instead of 
     "Toggle". The attribute is still DEAD. 

          Shapes and fill patterns. No sweat. How about this. We 
     box in each radio group, then box in the two groups plus the 
     radio title. Select BOX to do that. Start a box corner with 
     mouse right, finish the other corner with mouse left. If you 
     don't like it, press UNDO and whatever the last shape is, it 
     will be deleted (fill pattern counts as a shape). Fill in a 
     pattern between the two small boxes and the big box. Select 
     fill. Then, select a pattern with the right mouse button, 
     start filling with the left mouse button at the appropriate 
     mouse coordinates. How about boxes around TOGGLE and EXIT. Do 
     you remember the example? You can do it. 
     
          That covers the editing. One more thing. To delete a 
     button, you must activate it by either right-mouse clicking 
     on it and laying it down, or by pressing return when the 
     mouse arrow is on top of the button. Then press delete. That 
     offensive button has now gone away. 
     
          Now we are going to save it. Do you want to check all 
     the attributes and stuff first? Did you make mistakes? Go to 
     each button with the mouse arrow on top of it, press return, 
     and look at the strip menu options. If you made a mistake, 
     simply change it. Wnat to check its' name? Select RENAME. 
     Just Return if correct, or edit if it's a mistake. OKAY! 
     Everything is good. SAVE it. Select SAVE. Enter the dialog 
     box name of 'Example_box_1'. Return. Save it as EXAMPLE1.LST 
     (always use .LST). 
     
     
     NOW TO TEST:
     
          Load BOXTEST.BAS from the GFA interpreter. MERGE your 
     EXAMPLE1.LST file. CHANGE the name of "Yourbox" to 
     "Example_box_1". Run it! It BETTER work, right? 
     
     
     GOOD! It works..... Now let's INTERFACE it!
     
          Let's write our own, short program that tests for the 
     various buttons. First, MERGE EXAMPLE.LST or EXAMPLE1.LST.
     Now, merge in DRAW_BTN.BAS. Next, we'll write a DO-LOOP. 
     Let's exit if we select the button called 'Exit_2'. Otherwise 
     we print the buttons chosen and loop around, feeding back 
     what our previous choice was. 
     
     Do
     Cls
       @Example_box (A$,*A$)      !Notice,going IN(A$) 
     Cls
     '                             automatically will be set to 
     '                             coming out(*A$).
       If Instr(A$,"(Radio_a_1)")>0  ! Is 'Radio_a_1' selected?
         Print "RADIO A 1"
       Endif
     '
       If Instr(A$,"(Radio_a_2)")>0  ! Is 'Radio_a_2' selected?
         Print "Radio A 2"
       Endif
     '
       If Instr(A$,"(Radio_a_3)")>0  ! Is 'Radio_a_3' selected?
         Print "RADIO A 3"
       Endif
     '
       If Instr(A$,"(Radio_a_4)")>0  ! Is 'Radio_a_4' selected?
         Print "RADIO A 4"
       Endif
     '
       If Instr(A$,"(Radio_b_1)")>0  ! Is 'Radio_b_1' selected?
         Print "RADIO B 1"
       Endif
     '
       If Instr(A$,"(Radio_b_2)")>0  ! Is 'Radio_b_2' selected?
         Print "RADIO B 2"
       Endif
     '
       If Instr(A$,"(Radio_b_3)")>0  ! Is 'Radio_b_3' selected?
         Print "RADIO B 3"
       Endif
     '
       If Instr(A$,"(Toggle_1)")>0  ! Is 'Toggle_1' selected?
         Print "TOGGLE 1"
       Endif
     '
       If Instr(A$,"(Toggle_2)")>0  ! Is 'Toggle_2' selected?
         Print "TOGGLE 2"
       Endif
     '
       If Instr(A$,"(Exit_1)")>0  ! Is 'Exit_1' selected?
         Print "Exit_1"
       Endif
     '
       Exit If Instr(A$,"(Exit_2)")>0  ! If 'Exit_2' selected,end! 
     Loop
     
     EXPERIMENT!
     
