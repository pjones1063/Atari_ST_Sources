screen ( sensitive ( "öbersicht" ),
         sensitive ( "SysGem"     ))
SysGem V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

  \#Registrierung\#       - Wie kriege ich die 'Please register' Meldung
                        weg?
  \#Autor\#               - Wer hat das Teil hier verbrochen?
  \#Objecttypen\#         - Was die Lib noch so drauf hat...
  \#Signale\#             - MiNT-Signale abfangen
  \#SysInfo\#             - Super-Tool fuer alle, die wissen wollen, was
                        im Rechner so ab geht...
  \#Wichtig\#             - Wichtig! Lesen!

  \#Konzept\#             - Wie arbeitet SysGem?

----------------------------------------------------------------------

SysGem bietet Funktion, die sich in folgende Kategorien einteilen
lassen:

 \#Abfrageroutinen\#
 \#Bildschirmfunktionen\#
 \#Eigener Desktop\#
 \#Dialogfunktionen\#
 \#Einstellungen\# / Verhalten von Funktionen
 \#Fensterfunktionen\#
 \#Kommunikation\#
 \#Manipulation\#
 \#MenÅzeile\#
 \#Popup's\#
 \#Resource\#
 \#Sliderboxen\#
 \#Textfenster\#
 \#Timer\#

\end

screen ( sensitive ( "Dialogfunktionen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#ChangeButton\#        - Text eines Buttons Ñndern
  \#ClearEditFields\#     - Editfelder eines Dialogs loeschen
  \#DelDialog\#           - Dialog aus der Verwaltung nehmen
  \#DoDialog\#            - Komplette Dialogdurchfuehrung
  \#GetEditFields\#       - Alle Editfelder auslesen
  \#GetText\#             - Einzelnes Text-Feld auslesen
  \#NewDialog\#           - Dialog in Verwaltung aufnehmen
  \#RedrawDialog\#        - Objektbaum neuzeichnen
  \#RedrawObj\#           - Einzelnes Objekt neuzeichnen
  \#SetEditField\#        - Cursor in ein Editfeld setzen
  \#SetFieldProc\#        - Proc. fuer Editfelder anmelden
  \#SetText\#             - Text eines Objektes setzen
  \#UseRightButton\#      - Rechte Maustaste benutzen?
  \#WindowDialog\#        - Fensterdialog anmelden

\end
screen ( sensitive ( "Fensterfunktionen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#CloseAllWindows\#     - Alle Fenster schliessen
  \#CloseWindow\#         - Ein Fenster (versuchen) zu schliessen
  \#DoDialog\#            - Komplette Dialogdurchfuehrung
  \#GetHandle\#           - Fensterhandle anhand der Id ermitteln
  \#GetTopWindow\#        - Oberstes Fenster ermitteln
  \#GetWindowId\#         - Fensterid anhand des Handles ermitteln
  \#IsVisible\#           - Fenster ganz sichtbar?
  \#LinkImage\#           - Icon zum Iconifizieren anmelden
  \#OpenLogWindow\#       - Textfenster îffnen
  \#OpenWindow\#          - Fenster oeffnen
  \#RectIntersect\#       - Ueberlappung von Rechtecken pruefen
  \#RedrawArea\#          - Bildschirmbereich neuzeichnen
  \#RedrawObj\#           - Einzelnes Objekt neuzeichnen
  \#RedrawWindow\#        - Komplettes Fenster neuzeichnen
  \#ScrollWindow\#        - Im Fenster den Inhalt scrollen lassen
  \#SetAlertTitle\#       - öberschrift der Alertbox setzen
  \#SetWinMaxSize\#       - Maximale Fenstergrîûe setzen
  \#SetWinMinSize\#       - Minimale Fenstergrîûe setzen
  \#SetWindowInfo\#       - Text der Info-Zeile setzen
  \#SetWindowName\#       - Fenstertitel setzen
  \#SetWindowParm\#       - Parameter eines Fensters setzen und abfragen
  \#TopWindow\#           - Fenster nach oben holen
  \#WindowDialog\#        - Fensterdialog anmelden

\end

screen ( sensitive ( "Abfrageroutinen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#CalcArea\#            - Ausmasse eines Objekts berechnen
  \#GetCookie\#           - Cookie suchen
  \#GetFlags\#            - Abfragen, ob ein Flag gesetzt ist
  \#GetHandle\#           - Fensterhandle anhand der Id ermitteln
  \#GetState\#            - Abfragen, ob ein Status gesetzt ist
  \#GetTopWindow\#        - Oberstes Fenster ermitteln
  \#GetWindowId\#         - Fensterid anhand des Handles ermitteln
  \#IsMenuKey\#           - MenÅshortcuts finden
  \#IsVisible\#           - Fenster ganz sichtbar?
  \#has_search\#          - appl_search vorhanden?
  \#magx_avail\#          - Versionsnummer von Mag!X holen
  \#mint_avail\#          - Versionsnummer von MiNT
  \#objc_frame\#          - Rand eines Objekts berechnen
  \#winx_avail\#          - Winx da?

\end
screen ( sensitive ( "Einstellungen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#DialPosXY\#           - Dialoge an Mausposition / zentriert?
  \#FrameTextColor\#      - FrameText Farbe setzen
  \#SetAccProc\#          - Acc-Behandlungsroutinen setzen
  \#SetButton\#           - Aussehen der Alert-Buttons setzen
  \#SetCookie\#           - Cookie oder Wert setzen
  \#SetIconColor\#        - Iconfarbe fuer Alertbox setzen
  \#SetMessageProc\#      - Empfangsroutine fuer Nachrichten anmelden
  \#SetProcTimer\#        - Timerfunktion anmelden
  \#SetReturn\#           - Verhalten der Return-Taste setzen
  \#SetTimer\#            - Timer setzen
  \#ShortCutColor\#       - Farbe der Shortcuts setzen
  \#TellKeyStrokes\#      - Tastendruecke weiterleiten?
  \#UseHighButtons\#      - Hohe Buttons in Alertboxen?

\end
screen ( sensitive ( "Manipulation" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#ChgInList\#           - Textzeile Ñndern/abfragen
  \#DelFlags\#            - Einzelne Objekt-Flags loeschen
  \#DelState\#            - Einzelne Objekt-Stati loeschen
  \#SetFlags\#            - Einzelne Objekt-Flags setzen
  \#SetGlobalFlags\#      - Mehrere Flags setzen
  \#SetGlobalState\#      - Mehrere Stati setzen
  \#SetSliderPos\#        - Position in Sliderbox setzen
  \#SetState\#            - Einzelne Objekt-Stati setzen

\end
screen ( sensitive ( "Resource" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#LoadResource\#        - Resource-Datei laden
  \#RscAdr\#              - Resource-Adressen ermitteln
  \#RscFree\#             - Resourcen-Speicher freigeben

\end
screen ( sensitive ( "Bildschirmfunktionen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#ClearArea\#           - Bereich freigeben
  \#CopyArea\#            - Bereich kopieren
  \#FreeArea\#            - Bereich und Variable freigeben
  \#MoveScreen\#          - Bereich kopieren
  \#NewArea\#             - Neue Variable anmelden
  \#RestoreArea\#         - Mit SaveArea gesicherter Bereich wieder zurueckschreiben
  \#SaveArea\#            - Bereich in Speicher kopieren

\end
screen ( sensitive ( "Textfenster" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#AddToList\#           - Zeile an Liste hinzufÅgen
  \#CountLines\#          - Zeilen im Textfenster zÑhlen
  \#DelInList\#           - Zeile in der Liste lîschen
  \#Display\#             - Textdatei laden und darstellen
  \#HideCursor\#          - Cursor ausschalten
  \#LinkList\#            - List an Fenster binden
  \#OpenLogWindow\#       - Textfenster îffnen
  \#ShowCursor\#          - Cursor einschalten
  \#do_qsort\#            - Zeilen sortieren
  \#wcls\#                - Fenster lîschen
  \#wgetchar\#            - Zeichen an Position abfragen
  \#wgetxy\#              - Cursor abfragen
  \#wposxy\#              - Cursor setzen
  \#wprintf\#             - Schreiben ins Fenster

\end
screen ( sensitive ( "Sliderboxen" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#AddSliderItem\#       - Element zur Sliderbox hinzunehmen
  \#LinkSlider\#          - Sliderbox anmelden
  \#RedrawSliderBox\#     - Sliderbox neuzeichnen
  \#ScrollSlider\#        - Elemente scollen lassen
  \#SetSliderPos\#        - Position in Sliderbox setzen
  \#UnLinkSlider\#        - Sliderbox aus der Verwaltung nehmen

\end
screen ( sensitive ( "Popup's" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#Cycle\#               - Circle-Buttons
  \#Listbox\#             - Listbox darstellen
  \#PopUp\#               - Pop-Up darstellen
  \#xPopUp\#              - Erweiterte PopUp's

\end
screen ( sensitive ( "MenÅzeile" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#IsMenuKey\#           - MenÅshortcuts finden
  \#RemDeskTopMenu\#      - Hauptmenue abmelden
  \#SelectMenu\#          - Menuetitel manuell selektieren
  \#SetDeskTopMenu\#      - Menuezeile setzen

\end
screen ( sensitive ( "Eigener Desktop" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#RemoveDeskTop\#       - Eigenen Desktop entfernen
  \#SetDeskTop\#          - Eigenen Desktop anmelden

\end
screen ( sensitive ( "Cookies" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#GetCookie\#           - Cookie suchen
  \#RemoveCookie\#        - Cookie entfernen
  \#SetCookie\#           - Cookie oder Wert setzen

\end
screen ( sensitive ( "Timer" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#SetTimer\#            - Timer setzen
  \#SetProcTimer\#        - Timerfunktion anmelden

\end
screen ( sensitive ( "Kommunikation" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#ProgramExist\#        - Schauen, ob SysGem-Programm existiert
  \#SendMsg\#             - Welche gibt es?
  \#SendSgMsg\#           - Nachricht an SysGem-Programm schicken
  \#SetMessageProc\#      - Empfangsroutine fuer Nachrichten anmelden

\end
screen ( sensitive ( "Sonstiges" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

  \#Alert\#               - Alertbox darstellen
  \#Exit_GEM\#            - Abmelden beim GEM
  \#HandleSysGem\#        - Kontrolle an SysGem abgeben
  \#Init_GEM\#            - Anmelden beim GEM (\#Initialisierung\#)
  \#TerminateSysGem\#     - SysGem verlassen

\end

screen ( sensitive ( "Gesamt-Index" ))
\#SysGem\# V1.20
----------------------------------------------------------------------

Strukturen:


  \#AREA\#                - Beschreiben von Bildschirm-Bereichen
  \#COOKIE\#              - Cookie-Struktur
  \#DIALOG_INFO\#         - Info's ueber einen Dialog
  \#DRAG_DROP\#           - Drag & Drop-Struktur
  \#PARAMETER\#           - System-Daten via \#Init_GEM\#
  \#RECT\#                - zur Beschreibung eines Rechtecks
  \#WINDOW_INFO\#         - Ereignis-Struktur von SysGem

Funktionen:


  \#AddSliderItem\#       - Element zur Sliderbox hinzunehmen
  \#AddToList\#           - Zeile an Liste hinzufÅgen
  \#Alert\#               - Alertbox darstellen
  \#CalcArea\#            - Ausmasse eines Objekts berechnen
  \#ChangeButton\#        - Text eines Buttons Ñndern
  \#ChgInList\#           - Textzeile Ñndern/abfragen
  \#ClearArea\#           - Bereich freigeben
  \#ClearEditFields\#     - Editfelder eines Dialogs loeschen
  \#CloseAllWindows\#     - Alle Fenster schliessen
  \#CloseWindow\#         - Ein Fenster (versuchen) zu schliessen
  \#CopyArea\#            - Bereich kopieren
  \#CountLines\#          - Zeilen im Textfenster zÑhlen
  \#Cycle\#               - Circle-Buttons
  \#DelDialog\#           - Dialog aus der Verwaltung nehmen
  \#DelFlags\#            - Einzelne Objekt-Flags loeschen
  \#DelInList\#           - Zeile in der Liste lîschen
  \#DelState\#            - Einzelne Objekt-Stati loeschen
  \#DialPosXY\#           - Dialoge an Mausposition / zentriert?
  \#Display\#             - Textdatei laden und darstellen
  \#DoDialog\#            - Komplette Dialogdurchfuehrung
  \#Exit_GEM\#            - Abmelden beim GEM
  \#FrameTextColor\#      - FrameText Farbe setzen
  \#FreeArea\#            - Bereich und Variable freigeben
  \#GetCookie\#           - Cookie suchen
  \#GetEditFields\#       - Alle Editfelder auslesen
  \#GetFlags\#            - Abfragen, ob ein Flag gesetzt ist
  \#GetHandle\#           - Fensterhandle anhand der Id ermitteln
  \#GetState\#            - Abfragen, ob ein Status gesetzt ist
  \#GetText\#             - Einzelnes Text-Feld auslesen
  \#GetTopWindow\#        - Oberstes Fenster ermitteln
  \#GetWindowId\#         - Fensterid anhand des Handles ermitteln
  \#HandleSysGem\#        - Kontrolle an SysGem abgeben
  \#HideCursor\#          - Cursor ausschalten
  \#Init_GEM\#            - Anmelden beim GEM (\#Initialisierung\#)
  \#IsMenuKey\#           - MenÅshortcuts finden
  \#IsVisible\#           - Fenster ganz sichtbar?
  \#LinkImage\#           - Icon zum Iconifizieren anmelden
  \#LinkList\#            - List an Fenster binden
  \#LinkSlider\#          - Sliderbox anmelden
  \#Listbox\#             - Listbox darstellen
  \#LoadResource\#        - Resource-Datei laden
  \#MoveScreen\#          - Bereich kopieren
  \#NewArea\#             - Neue Variable anmelden
  \#NewDialog\#           - Dialog in Verwaltung aufnehmen
  \#OpenLogWindow\#       - Textfenster îffnen
  \#OpenWindow\#          - Fenster oeffnen
  \#PopUp\#               - Pop-Up darstellen
  \#ProgramExist\#        - Schauen, ob SysGem-Programm existiert
  \#RectIntersect\#       - Ueberlappung von Rechtecken pruefen
  \#RedrawArea\#          - Bildschirmbereich neuzeichnen
  \#RedrawDialog\#        - Objektbaum neuzeichnen
  \#RedrawObj\#           - Einzelnes Objekt neuzeichnen
  \#RedrawSliderBox\#     - Sliderbox neuzeichnen
  \#RedrawWindow\#        - Komplettes Fenster neuzeichnen
  \#RemDeskTopMenu\#      - Hauptmenue abmelden
  \#RemoveCookie\#        - Cookie entfernen
  \#RemoveDeskTop\#       - Eigenen Desktop entfernen
  \#RestoreArea\#         - Mit SaveArea gesicherter Bereich wieder zurueckschreiben
  \#RscAdr\#              - Resource-Adressen ermitteln
  \#RscFree\#             - Resourcen-Speicher freigeben
  \#SaveArea\#            - Bereich in Speicher kopieren
  \#ScrollSlider\#        - Elemente scollen lassen
  \#ScrollWindow\#        - Im Fenster den Inhalt scrollen lassen
  \#SelectMenu\#          - Menuetitel manuell selektieren
  \#SendMsg\#             - Welche gibt es?
  \#SendSgMsg\#           - Nachricht an SysGem-Programm schicken
  \#SetAccProc\#          - Acc-Behandlungsroutinen setzen
  \#SetAlertTitle\#       - öberschrift der Alertbox setzen
  \#SetButton\#           - Aussehen der Alert-Buttons setzen
  \#SetCookie\#           - Cookie oder Wert setzen
  \#SetDeskTopMenu\#      - Menuezeile setzen
  \#SetDeskTop\#          - Eigenen Desktop anmelden
  \#SetEditField\#        - Cursor in ein Editfeld setzen
  \#SetFieldProc\#        - Proc. fuer Editfelder anmelden
  \#SetFlags\#            - Einzelne Objekt-Flags setzen
  \#SetGlobalFlags\#      - Mehrere Flags setzen
  \#SetGlobalState\#      - Mehrere Stati setzen
  \#SetIconColor\#        - Iconfarbe fuer Alertbox setzen
  \#SetMessageProc\#      - Empfangsroutine fuer Nachrichten anmelden
  \#SetProcTimer\#        - Timerfunktion anmelden
  \#SetReturn\#           - Verhalten der Return-Taste setzen
  \#SetSliderPos\#        - Position in Sliderbox setzen
  \#SetState\#            - Einzelne Objekt-Stati setzen
  \#SetText\#             - Text eines Objektes setzen
  \#SetTimer\#            - Timer setzen
  \#SetWinMaxSize\#       - Maximale Fenstergrîûe setzen
  \#SetWinMinSize\#       - Minimale Fenstergrîûe setzen
  \#SetWindowInfo\#       - Text der Info-Zeile setzen
  \#SetWindowName\#       - Fenstertitel setzen
  \#SetWindowParm\#       - Parameter eines Fensters setzen und abfragen
  \#ShortCutColor\#       - Farbe der Shortcuts setzen
  \#ShowCursor\#          - Cursor einschalten
  \#TellKeyStrokes\#      - Tastendruecke weiterleiten?
  \#TerminateSysGem\#     - SysGem verlassen
  \#TopWindow\#           - Fenster nach oben holen
  \#UnLinkSlider\#        - Sliderbox aus der Verwaltung nehmen
  \#UseHighButtons\#      - Hohe Buttons in Alertboxen?
  \#UseRightButton\#      - Rechte Maustaste benutzen?
  \#WindowDialog\#        - Fensterdialog anmelden
  \#do_qsort\#            - Zeilen sortieren
  \#has_search\#          - appl_search vorhanden?
  \#magx_avail\#          - Versionsnummer von Mag!X holen
  \#mint_avail\#          - Versionsnummer von MiNT
  \#objc_frame\#          - Rand eines Objekts berechnen
  \#wcls\#                - Fenster lîschen
  \#wgetchar\#            - Zeichen an Position abfragen
  \#wgetxy\#              - Cursor abfragen
  \#winx_avail\#          - Winx da?
  \#wposxy\#              - Cursor setzen
  \#wprintf\#             - Schreiben ins Fenster
  \#xPopUp\#              - Erweiterte PopUp's

\end
screen ( sensitive ( "Konzept" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Alle GEM-Programme haben eins gemeinsam: Sie rufen laufend evnt_multi
auf und warten darauf, daû fÅr sie eine Nachricht einfliegt, auf die
dann reagiert werden soll. Ebenso ist es mit viel Aufwand verbunden,
Dialoge in Fenster zu legen. Man muû sich um die Positionen kÅmmern,
Mausklicks und Tasten abfragen und immer schauen, ob der Benutzer
nicht irgendwas im Fenster gemacht hat...

SysGem verfolgt die Philosophie, daû weniger mehr ist. Sie sagen nur
noch, ein Fenster soll aufgehen, und Sie geben an, wie dies aussehen
soll. SysGem verwaltet dann die ganze Arbeit, verschiegen, vergrîûern,
fullen etc.

FÅr den/die Programmierer/in wÑre es nur wichtig zu wissen, wenn der
Benutzer etwas macht, auf das reagiert werden soll. Alle diese
Funktionen stecken in der Funktion \#HandleSysGem\#. Fast alle Ver-
waltungsaufgaben Åbernimmt diese Funktion. Warum soll man sich darum
kÅmmern, auf welche Position die Slider zu setzen sind? Es reicht doch,
wenn man weis, daû die Slider verschoben oder verÑndert wurden...

FÅr die Fenster und Dialoge geben Sie bei SysGem jeweils eine Funktion
an (oder auch nicht), an die alle BenutzeraktivitÑten gemeldet werden;
Sie entscheiden dann, wie darauf reagiert werden soll.

Ein kleines Beispiel:

     Sie: Hallo Lib! Mach ein Fenster auf, in dem der Dialog xy liegen
          soll und melde mit alle Aktionen an die Funktion z.
  SysGem: Klar Mann!
     Sie: Dann mach noch ein Fenster auf und lege den Text z7 da rein.
          KÅmmer dich um alles, bis der Benutzer das Fenster schlieût
          und lass mich in Ruhe!
  SysGem: Ja, Master. Ist gebongt!
Benutzer: Aha. Ein Fensterdialog! Nett. Was passiert wohl, wenn dich
          den Button "mach was" anklicke? [Benutzer klickt...]
  SysGem: Na endlich was zu tun! Ein Mausklick! Wohin eigentlich?
          Ach so, Dialog xy. Oh, Button "mach was". Mal sehen, "Sie"
          hat eine Funktion angegeben, also melden wir das mal.

          He, Funktion z! Der Benutzer hat "mach was" angeklickt!
 Funk. z: Is ja gut. Aha, bei "mach was" soll der Dialog verlassen
          werden. He, Lib! Mach das Fenster zu.
  SysGem: Jo, geschlossen.
Benutzer: Oh, ein Textfenster. Scrollen wir mal...
  SysGem: Aha, Textfenster. Keine Funktion angegeben, also Arbeit
          fÅr mich. Wir scrollen, updaten...
Benutzer: Is dat scheen!
     Sie: Warum kompliziert, wenn man SysGem nehmen kann...


Sie sehen, SysGem liefert nur Nachrichten an Handler. Sie kînnen sich
also auf das wesentliche des Programms konzentrieren, ohne auf die
Verwaltung des GEM RÅcksicht zu nehmen.


\end
screen ( sensitive ( "TRUE" ),
         sensitive ( "FALSE" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

FALSE  entspricht dem Wert 0
TRUE   entspricht dem Wert 1.

\end

screen ( sensitive ( "AREA" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef struct
  {
    BOOL        used;
    INT         x;
    INT         y;
    INT         w;
    INT         h;
    ULONG       size;
    MFDB        mf;
  } AREA;

Diese Struktur wird in SysGem dazu benutzt, um Bildschirmbereiche
zu beschreiben.

-->  Diese Struktur darf nur gelesen, aber unter keinen UmstÑnden
     von Ihnen geÑndert werden!

-->  Sollten Sie dennoch einmal Werte Ñndern, kann es gut passieren,
     dass Sie mit unerwarteten "Nebenwirkungen" rechnen mÅssen!

\end

screen ( sensitive ( "Wichtig" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Bei der Arbeit mit SysGem gibt es ein paar Dinge, die Sie unbedingt
beachten sollten, um unerwÅnschte Nebeneffekte zu vermeiden:

-  Benutzen Sie keine wind_... Funktionen; vor allem nicht wind_close
   oder wind_delete; das Fenster wÅrde zwar geschlossen, wÑre fÅr
   SysGem aber noch geîffnet, was zu (fatalen) Schwierigkeiten fÅhren
   kînnte.

   Das AES kann dann unter bestimmten UmstÑnden das Honk-Bit setzen
   und das Rembrandt-Flag negieren, was eine ungeordnete Terminierung
   des Programms zur Folge hat (is'n Insider-Witz :-)  ).

-  Erhalten Sie von SysGem Nachrichten, dass ein Fenster geschlossen
   werden soll, schliessen Sie es nicht eigenmÑchtig! SysGem schliesst
   das Fenster von selbst.

   Die Funktion \#CloseWindow\# ist zwar fÅr solche Zwecke da, aber
   sollte nur dann eingesetzt werden, wenn es nicht anders geht.

-  Wegen der Iconifizierung sollten Sie sich nicht darauf verlassen,
   dass ein bestimmtes Fenster auch ein bestimmtes Handle hat!

   Das Handle kann sich Ñndern! Deshalb greifen Sie immer mittels
   \#GetHandle\# auf das Fenster zu!

\end

screen ( sensitive ( "Signale" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Unter MiNT ist es kein Problem, einem Prozess eine Nachricht zu
schicken, dass es terminieren soll. Ziehen Sie z. B. aus 'U:\\PROC'
ein Programm auf den Papierkorb, so erhÑlt es die Nachricht, sich zu
verabschieden.

Dies kann unter GEM natÅrlich voll 'in die Hose' gehen, wenn sich ein
Programm unkontrolliert verabschiedet und z.B. Dateien, Fenster usw.
nicht geschlossen werden kînnen.

SysGem installiert deshalb Routinen, die diese Nachrichten abfangen
und leitet dann die geordnete Terminierung ein; soll heissen, die
Funktion \#HandleSysGem\# kehrt zurÅck. So ist also gewÑhrleistet,
dass Ihr Programm sich ordnungsgemÑss beenden kann.

Von SysGem werden folgende Signale abgefangen:

- SIGABRT --> Abort. Schwerer Fehler

- SIGQUIT
- SIGTERM --> Prozess soll beendet werden

- SIGUSR1
- SIGUSR2 --> Applikations-Signale. MÅssen abgefangen werden, da sonst
              der Prozess beendet wird. Wenn Sie die Signale selbst aus-
              werten wollen, kînnen Sie ja jederzeit eigene Routinen
              installieren.

- SIGPIPE --> Wegen Drag & Drop

\end

screen ( sensitive ( "Registrierung" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

SysGem ist Keyware. Das heisst, Sie kînnen SysGem ohne irgendwelche
EinschrÑnkungen nutzen. Jedoch erscheint sporadisch eine Meldung,
die Sie daran erinnern soll, den Obulus zu entrichten.

FÅr 40 DM, die Sie bitte an den \#Autor\# richten, erhalten Sie einen
SchlÅssel fÅr SysGem, der die Registriermeldung nicht mehr erscheinen
lÑsst.

Ausserdem wird SysInfo dann Ihre SysGem-Version als registriert
ausweisen.

Wenn Sie Åberweisen mîchten, hier meine Bankverbindung:

Andreas Pietsch

Kto: 100-060466    BLZ: 57650010    Kreissparkasse Mayen

Vergessen Sie aber bitte nicht Ihren Absender!

----------------------------------------------------------------------
Wohnen Sie ausserhalb der BRD, so beachten Sie bitte, dass es sich die
Banken gut bezahlen lassen, aus dem Ausland Geld einzuziehen.
Die GebÅhren kînnen (aus Erfahrung) teilweise bis zu 50 % des
Betrages erreichen!!

Im Zweifelsfalle senden Sie einfach Bargeld (in DM; als Wertbrief!)
oder rechnen Sie die GebÅhren dazu!
----------------------------------------------------------------------

Es lohnt sich ausserdem, sich auch fÅr \#SysInfo\# registrieren
zu lassen!

Leider kann ich es nicht verhindern, dass die Library als Keyware
vertrieben wird. Es hat sich herausgestellt, dass wesentlich mehr
Leute die Lib nutzen, Fragen stellen, anrufen, Updates haben wollen,
aber nie den (ohnehin sehr geringen) Obulus entrichtet haben. Dieses
finde ich nicht fair, also blieb uns nichts anderes Åbrig.

Ich helfe gerne weiter - natÅrlich auch, wenn Sie nicht registriert
sind! Wenn Sie aber ettliche Male angerufen haben, ob ich das und
jenes noch einbauen kann, dann mache ich das natÅrlich gerne; gehe aber
davon aus, dass Ihnen dann die Lib auch gefÑllt - und erwarte auch
irgendwie, dass Sie den Obulus entrichten.

Sollten Sie gequÑlt werden von der Erkenntnis, dass die Library
wesentlich mehr wert ist als 40 DM, kînnen Sie Ihr Gewissen
erleichtern: Schicken Sie einfach Zuwendungen in Form von Geschenken,
Lottogewinne, Schecks, PlÅschtiere (bitte keine echten Tiere),
Danksagungen, Atari-TT's, Festplatten usw. an mich....


\end

screen ( sensitive ( "Autor" ),
         sensitive ( "Andreas_Pietsch" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Sollten Sie eine Funktion vermissen, einen Wunsch, eine Anregung oder
vielleicht eine Fehlermeldung haben, so kînnen Sie sich direkt an mich
wenden. Fehler werden sofort beseitigt, sinnvolle WÅnsche oder
Anregungen kînnen allerdings schon mal ein paar Tage dauern.

Erreichen kînnen Sie mich auf folgenden elektronischen Wegen:

Telefon  +49-2651-48833
Telefax  +49-2651-43344

Maus     WI2
Internet Andreas_Pietsch@wi2.maus.de

oder aber per Snail-Mail:

Andreas Pietsch
Schillerstr. 24
56727 Mayen, FRG

Da ich die Library so umfangreich und komfortabel wie mîglich
gestalten mîchte, sollten Sie sich also nicht scheuen, mir Ihre
WÅnsche mitzuteilen.

Siehe auch: \#Registrierung\#

\end

screen ( sensitive ( "Thorsten_Bergner" ),
         sensitive ( "SysInfo" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Kurzinformationen zu SysInfo V2.00
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

SysInfo gibt einen Einblick in die Hard- und Softwarefunktionen
des Atari und bietet darÅber hinaus noch eine Menge Zusatzfunk-
tionen fÅr Programmierer und Interessierte an.

Die wichtigsten Werte werden Åber einen Programmtakt stÑndig
aktualisiert. Ansonsten reicht ein Klick auf 'Update' und das
Fenster wird aufgefrischt.

Ein kurzer öberblick...

- SysInfo ist Keyware und kostet 15 DM
- SysInfo lÑuft mit allen offiziellen ROM- und RAMTOS Versionen,
  auch mit KAOS, Mag!X und MiNT/MTOS
- UnterstÅtzt alle Grafikauflîsungen >= 640*200 (SW/Farbe)
- LÑsst sich als Programm oder Accessory benutzen

- Speicherinformationen Åber ST- und/oder TT-RAM
- Hardwareinformationen Åber Maschine, CPU und FPU
- Cache, Takt und Blitter-Funktionen
- Laufwerks- und Treiberinformationen
- Anzeige Bootlaufwerk
- System- bzw. Versionsinformationen
- NetzwerkÅbersicht
- Cookieinformationen mit Kommentar
- XBRA-Informationen
- Harddiskinformationen
- Grafikinformationen
- Anzeige der laufenden SysGem-Prozesse
- Eine Eckuhr ist vorhanden
- XSSI UnterstÅtzung
- Ausgabe aller Informationen in eine Datei


Die Funktionen...
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ-----

Info
----
- Anzeige der Version und des Autors

Ausgabe
-------
- Ausgabe aller Werte von SysInfo als Datei ins Klemmbrett. Falls
  das Klemmbrett nicht vorhanden sein sollte, wird eins angelegt.
  Die Ausgabe funktioniert nur mit einer registrierten Version.

System
------
- Maschine (ST, STE, BOOK, MSTE, TT, F030)
- CPU      (68000, 68010, 68020, 68030, 68040)
- FPU      (SFP004, 68881, 68882, 68040)
- VersionsÅbersicht
- Videomodus
- NetzwerkÅbersicht
- Speicherkontrolle

- Cache. Hiermit kann ein vorhandener Cachespeicher ein- oder
  ausgeschaltet werden

  68000 : - ST   Konfig Hypercache Turbo+ ( Soundchip Port A/Bit 6 )
          - STE  Konfig Hypercache II     ( Adr.0xFFBE01 )
          - MSTE Konfig SCU Chip          ( Adr.0xFF8E21 )
  68010 : - Kein Cache. Das Feld wird gesperrt
  68020 : - Instruction Cache ein/aus
  68030 : - Data+Instruction Cache ein/aus
  68040 : - Data+Instruction Cache ein/aus

- Takt. Hiermit kann der CPU Takt beim MegaSTE und Falcon030 zwischen
  16 und 8 MHz umgeschaltet werden

- Blitter. Ist ein Blitter eingebaut, kann er ein- oder ausgeschaltet
  werden

- Blittertakt. Hiermit kann der Blittertakt beim Falcon030 zwischen
  16 und 8 MHz umgeschaltet werden

- Laufwerke A-6. Ein selektierter Buchstabe zeigt, das das Laufwerk
  angemeldet ist. Zusatzinformationen erhÑlt man, wenn man mit der
  Maus, einen selektierten Laufwerksbutton anklickt

- Anzeige des Bootlaufwerkes

Memory
------
- Anzeige des gesamten und freien Speichers in Byte (ST- und TT-RAM)
- Anzeige der letzten Speicheranforderung

Vektor
------
- Anzeige von Systemvektoren, VBlankvektoren und Systemadressen

Cookie
------
- Ausgabe der Cookie Tabelle mit Kommentar. Cookies, die nicht
  kommentiert sind, geben ein '???' aus

- Zur Zeit sind folgende Cookies im Programm kommentiert:

  Atari  : _AKP, _CPU, _FDC, _FLK, _FPU, _FRB, _IDT, _INF, _MCH, _NET,
           _OOL, _SLM, _SND, _SWI, _VDO

  Andere : AFnt, AlHP, AHVR, AMCG, APGM, BIGS, BLOW, CFIX, CHAM, CHNG,
           CLCK, CM16, COOK, CRIT, CSMD, CTCH, cVDI, DATE, DATL, DAWN,
           DBFX, DEPI, DYNL, EdDI, ENVR, F117, FIX2, FLTP, FOse, FSEL,
           FSER, FSMC, FSmp, FxDR, FxOP, GDEV, GMNI, HDJR, HFIX, HSnd,
           IMNE, INSJ, INXR, JFTP, JMLS, KAOS, LAWC, M128, macc, MADD,
           MagC, MagX, MCWR, MDIA, MFNT, MGEM, MiNT, MkJr, MMAC, MOGR,
           MPRO, MSPO, MUPF, NCLN, NFnt, NLdr, NOVA, NVDI, OFLS, OPPM,
           OSTT, OVER, PBUG, PDOS, PMMU, PRTR, PTOS, PV__, RDCT, RFLX,
           RSpd, RSVE, RSVF, RWIN, SCRN, SCRW, SCSI, SF71, SFA^, SFMN,
           SMAL, SM00, SM01, SM02, SMTT, SPEX, Spol, SRYS, SSND, STRX,
           SYMB, SWAP, SwTm, TCRB, TIME, TFIX, TMon, THNX, TSWP, TTTF,
           Typ1, UFSL, UIS3, USHD, USRS, VFIX, VFNT, VGAS, VMEM, VRAM,
           VSCR, WDOG, WEGA, WFSL, WINX, WPRO, WrAp, XDsk, XFRB, XFS1,
           XHDI, xRmt, XSDD, XSSI, zDCF, _T30, 4PRN

XBRA
----
- Ausgabe der XBRA Vektor Tabelle. Die Funktion ist nur anwÑhlbar, wenn
  keine Memoryprotection aktiv ist

HDInfo
------
- Komplette öbersicht der Festplattenbelegung

Grafik
------
- Informationen Åber Farben, normalen und virtueÅllen Bildschirm

SysGem
------
- Anzeige der laufenden Prozesse die mit der SysGem Lib geschrieben
  wurden. Diese Anzeige erscheint nur, wenn entweder Mag!X, MultiTOS
  oder eine GEM Version >= 4.00 installiert ist.

Option
------
- Programm-Registrierung
- Einstellung des Programmtakt's (nur in registrierter Version)
- Eckuhr ein/aus
- Flag fÅr Fenster/Dialog an Mausposition oder zentriert


Schlussbemerkung...
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ-----
- Bei Schwierigkeiten oder Problemen mit SysInfo selber oder anderen
  Programmen und Accessoir's, bitte ich um genaue Informationen des
  Fehlers, der Systemkonfiguration und der Versionsnummer von SysInfo.

- Mein besonderer Dank geht an Andreas Pietsch, Frank Bartels,
  Dirk Haun, Werner Brandt, Axel Schermann und Dirk Johannwerner.

- Erstellt wurde das Programm mit dem Pure C EWS V1.20 (ASH) und die
  Resource mit Interface V2.20. FÅr die GEM Funktionen wurde die
  SysGem-Library von Andreas Pietsch (Es kann nur einen geben...)
  benutzt.

- Das Programm ist frei von rechten Dritter, darf aber nur zusammen mit
  diesem Copyrightvermerk weitergegeben werden. Die Benutzung des Prog-
  ramms ist auf eigene Gefahr. FÅr SchÑden an Hard- oder Software durch
  das Programm oder dessen Benutzung, Åbernehme ich keine Haftung.

- Ein Versand Åber PD-Vertriebe bedarf meiner schriflichen Genehmigung.

- öberweisung per Verrechnungsscheck, oder auf mein Konto bei der Berliner
  Bank (BLZ 10020000 / Konto-Nr 2656071200)


Anschrift und EMail...
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ-----
- Thorsten Bergner
  Mainzer Strasse 55
  D-12053 Berlin

- Tel   : 49-30-6249904
- EMail : MAUS     @ B
          FIDO     2:2410/409.1
          GERNET   21:100/9514.1
          INTERNET Thorsten_Bergner@schiele-ct.de


\end

screen ( sensitive ( "RECT" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Die Struktur RECT hat folgende Struktur:

typedef struct
  {
    INT  x;     /* x-Koordinate des Rechtecks */
    INT  y;     /* y-Koordinate des Rechtecks */
    INT  w;     /* Breite des Rechtecks       */
    INT  h;     /* Hîhe des Rechtecks         */
  } RECT;


\end

screen ( sensitive ( "PARAMETER" ),
         sensitive ( "vdi_handle" ),
         sensitive ( "charw" ),
         sensitive ( "charh" ),
         sensitive ( "boxw" ),
         sensitive ( "boxh" ),
         sensitive ( "appl_id" ),
         sensitive ( "xmax" ),
         sensitive ( "ymax" ),
         sensitive ( "desktop" ),
         sensitive ( "aes_version" ),
         sensitive ( "tos_version" ),
         sensitive ( "bitplanes" ),
         sensitive ( "max_colors" ),
         sensitive ( "act_colors" ),
         sensitive ( "color_avail" ),
         sensitive ( "acc_entry" ),
         sensitive ( "multitask" ),
         sensitive ( "magx" ),
         sensitive ( "magx_rel" ),
         sensitive ( "mint" ),
         sensitive ( "winx" ),
         sensitive ( "search" ),
         sensitive ( "agi" ),
         sensitive ( "AGI_0" ),
         sensitive ( "AGI_3" ),
         sensitive ( "AGI_4" ),
         sensitive ( "draw_3d" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------


Die Struktur PARAMETER hat folgende Struktur:

typedef struct
  {
    INT         vdi_handle;
    INT         charw;
    INT         charh;
    INT         boxw;
    INT         boxh;
    INT         appl_id;
    INT         xmax;
    INT         ymax;
    \#RECT\#        desktop;
    INT         bitplanes;
    INT         max_colors;
    INT         act_colors;
    BOOL        color_avail;
    INT         acc_entry;
    BOOL        multitask;
    INT         aes_version;
    UINT        tos_version;
    INT         magx;
    INT         magx_rel;
    INT         mint;
    BOOL        winx;
    BOOL        search;
    INT         agi;
    BOOL        draw_3d;
  } PARAMETER;


- vdi_handle    EnthÑlt das Handle der VDI-Workstation, die fÅr Ihr
                Programm erîffnet wurde. Wenn Sie in Ihrem Programm
                Ausgaben Åber das VDI machen wollen, sollten Sie
                'vdi_handle' Åbergeben.

- charw         EnthÑlt die Breite eines Zeichens in Pixeln.

- charh         EnthÑlt die Hîhe eines Zeichens in Pixeln.

- boxw          EnthÑlt die Breite einer Zeichenbox in Pixeln.

- boxh          EnthÑlt die Hîhe eines Zeichenbox in Pixeln.

- appl_id       EnthÑlt die Identifikationsnummer, welches das AES
                Ihrem Programm zugeordnet hat.

- xmax          EnthÑlt die Breite des Bildschirms in Pixeln.

- ymax          EnthÑlt die Hîhe des Bildschirms in Pixeln.

- desktop       ist eine \#RECT\#-Struktur und enthÑlt die Ausmasse
                des Desktops, auf dem Sie zeichnen dÅrfen, also z. B.
                abzÅglich der MenÅzeile.

- aes_version   enthÑlt die Versionsnummer des AES. Einige Funktionen
                des AES stehen z. B. erst ab einer bestimmten
                Versionsnummer zur VerfÅgung.

                Die Versionsnummer wird in Hex zurÅckgegeben. 0x0399
                wÅrde also eine Version 3.99 bedeuten.

- tos_version   enthÑlt die Versionsnummer des TOS.

                Die Versionsnummer wird in Hex zurÅckgegeben. 0x0205
                wÅrde also eine Version 2.05 bedeuten.

- bitplanes     gibt an, wieviel Bit pro Pixel zur Farbdarstellung
                benutzt werden.

- max_colors    gibt die Anzahl der verfÅgbaren Farben an. Eine 0
                besagt, dass True-Color verfÅgbar ist.

- act_colors    gibt die Anzahl der Farben an, die gleichzeitig aus
                einer Tabelle von 'max_colors' Farben darge- stellt
                werden kînnen.

- color_avail   ist \#TRUE\#, wenn mehr als 2 Farben verfÅgbar sind.

- acc_entry     hat den Wert -2 wenn Ihr Programm als Programm
                gestartet wurde. Sie hat einen Wert grîsser -1, wenn
                Ihr Programm als ACC gestartet wurde und den Wert -1,
                wenn wÑhrend der Initialisierung was schief ging, z.
                B. kein ACC-Slot mehr frei war.

- magx          EnthÑlt die Versionsnummer von Mag!X oder 0, wenn
                Mag!X nicht installiert ist.

- magx_rel      EnthÑlt die Releasenummer von Mag!X oder 0, wenn
                Mag!X nicht installiert ist.

- mint          EnthÑlt die Versionsnummer von MiNT oder 0, wenn
                MiNT nicht installiert ist.

- winx          Ist \#TRUE\#, wenn Winx >= 2.2 installiert ist.

- search        Ist \#TRUE\#, wenn appl_search vorhanden ist.

- agi           Hat folgende Werte:

                AGI_0   appl_getinfo ist nicht vorhanden
                AGI_3   appl_getinfo nur bis Par. 3.
                AGI_4   appl_getinfo kann voll genutzt werden.

- draw_3d       Ist \#TRUE\#, wenn die 3D-Buttons gezeichnet wird.

\end


screen ( sensitive ( "Init_GEM" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT Init_GEM ( \#PARAMETER\# *parm,
                         BYTE      *acc_name,
                         LONG      prg_id,
                         BYTE      *prg_name,
                         LONG      user_id,
                         BYTE      *name,
                         LONG      key );


Initialisiert die Library und meldet das Programm beim GEM an.

Die Parameter haben folgende Bedeutung:

- parm          In dieser Struktur erhalten Sie Daten zurueck,
                die fuer Ihr Programm wichtig sind.
                Es wird ein Zeiger auf die Struktur \#PARAMETER\#
                erwartet.

                -->  NULL ist __nicht__ zulaessig!

- acc_name      Uebergeben Sie hier den Namen Ihres Programm, der -
                falls Ihr Programm als ACC gestartet wurde - in der
                Acc-Leiste stehen soll.

                \#acc_entry\# enthaelt einen Wert != -2, wenn
                dem so ist.

                Wollen Sie verhindern, dass Ihr Programm als ACC
                gestartet wird, uebergeben Sie einfach einen leeren
                String ("").

- prg_id        Hier geben Sie einen 4-Zeichen-Code an, der Ihr
                Programm identifiziert. So hat SysInfo z. B. die
                Kennung 'SINF'.

                Da diese Kennung eindeutig sein muss, sollten Sie mir
                jede Kennung mitteilen, wenn Sie vorhaben, Ihr
                Programm freizugeben!

                Nur so kann gewaehrleistet werden, dass nicht zwei
                verschiedene Programme die gleiche Kennung besizten.
                Wenden Sie sich dazu einfach an den \#Autor\#.

- prg_name      Geben Sie hier den Namen des Programms an. Erlaubt
                sind bis zu 30 Zeichen. Der Programmname kann z. B.
                von \#SysInfo\# erfragt werden und ist logischerweise
                wesentlich aussagekraeftiger als der 4-Zeichen-Code.

- user_id       Ist ein 4-Zeichen-Code und repraesentiert den Autor.
                Die Kennung koennen Sie selbst vergeben (es sei denn,
                sie existiert schon...).

- name          Hier uebergeben Sie Ihren eigenen Namen (Vor- und
                Nachname) als String.

- key           Wenn Sie sich fuer SysGem haben registrieren lassen,
                erhalten Sie von mir einen Schluessel. In der
                registrierten Version erscheinen dann die Hinweise,
                dass Sie sich doch registrieren lassen sollen,
                natuerlich nicht mehr.

                Haben Sie noch keinen Schluessel, uebergeben Sie
                einfach eine 0, und lesen Sie mehr ueber die
                \#Registrierung\#.

----------------------------------------------------------------------

Rueckgabewerte: (siehe auch \#Initialisierung\#)

< 0     Init_GEM gibt -1 zurueck, falls das Programm sich schon im
        Speicher befindet; Das AES wird _nicht_ initialisiert und
        Ihr Programm wird _nicht_ beim GEM angemeldet.
        Ihr Programm _muss_ terminieren!

  0     Der Rueckgabewert ist 0, wenn das Programm nicht beim GEM
        angemeldet werden konnte.

> 0     Bei fehlerfreier Ausfuehrung wird ein Wert groesser 0 zurueck-
        gegeben. Nur dann duerfen Sie Funktionen aus SysGem nutzen!

----------------------------------------------------------------------

Ein Aufruf koennte zum Beispiel so aussehen:

PARAMETER par;

if ( Init_GEM ( &par, "  Demo Acc ", 'DEMO', "SysGem-Demo", 'ANPI',
     "Andreas Pietsch", 0L ) > 0 )
  {
    ...
  }

\end

screen ( sensitive ( "magx_avail" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: ULONG magx_avail ( VOID );


Liefert die Versionsnummer von Magix. Dabei befindet sich im oberen
Wort die Releasenummer und im unteren Wort die Versionsnummer. Die
Funktion liefert 0, wenn Magix nicht installiert ist.


\end


screen ( sensitive ( "mint_avail" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: UINT mint_avail ( VOID );


Liefert die Versionsnummer von MiNT oder 0, wenn MiNT nicht
installiert ist.

\end


screen ( sensitive ( "winx_avail" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL winx_avail ( VOID );


Liefert \#TRUE\#, wenn Winx >= 2.2 installiert ist.

\end


screen ( sensitive ( "has_search" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL has_search ( VOID );


Liefert \#TRUE\#, wenn appl_search zur Verfuegung steht.

\end


screen ( sensitive ( "FrameTextColor" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID FrameTextColor ( INT color );


Setzt die Farbe fÅr die Frame-Boxen, bzw. dessen Text. Diese Farbe
wird auch fuer den Text eines Iconifizierten Fensters gebraucht.

\end

screen ( sensitive ( "ShortCutColor" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ShortCutColor ( INT color );


Setzt die Farbe fÅr die Shortcuts. Steht am Anfang auf RED.

\end

screen ( sensitive ( "LinkImage" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID LinkImage ( LONG win_id, BITBLK *image, UBYTE *text );


Setzt fuer ein Fenster mit der Id 'win_id' ein Image, dass bei der
Iconifizierung verwendet wird.

'text' ist ein max. 8 Zeichen langer String, der dann unter dem Image
erscheint.

\end


screen ( sensitive ( "xPopUp" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT xPopUp ( OBJECT *tree, INT obj, OBJECT *tree2, INT start,
                                                             INT *first );


Baut auf \#PopUp\# auf. Stellt ein PopUp dar, und uebernimmt nach
Abschluss den Text des angeklickten Objekts und schreibt ihn dann
wieder in 'obj'. So kann man sich eine Menge Arbeit sparen.

Die Parameter:

- tree    Zeiger auf den dialog, in dem der Button liegt, der
          das Popup ausloest.

- obj     Die Objektnummer dieses Buttons.

- tree2   Zeiger auf den Baum fuer das Popup.

- start   Nummer des Objekte, das die gesamten Texte umschliesst.

- first   Nummer des Objektes, das unter der Maus erscheinen
          soll.

\end


screen ( sensitive ( "Listbox" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT Listbox ( UBYTE *strings, INT count, INT len, OBJECT *tree,
                                                            INT    box );


Stellt eine Listbox dar. Dabei gibt es zwei Mîglichkeiten. Einerseits
kann man einen Speicherbereich wie bei \#LinkSlider\# angeben, der
dann in der Listbox dargestellt wird. Andererseits kann man, wenn
'count' und 'len' auf 0 gesetzt sind, einen String uebergeben, wobei
die einzelnen EintrÑge mit '|' getrennt sind.

Die Funktion schreibt in 'box' automatisch den Text, den der Benutzer
ausgewaehlt hat und liefert die Nummer des angeklickten Textes
zurueck.

Parameter:

- strings    Zeiger auf den Speicherbereich oder auf den String.

- count      Anzahl der Eintraege oder 0.

- len        LÑnge eines Eintrags oder 0.

- tree       Zeiger auf den Baum, in dem sich der Button befindet,
             der die Listbox ausloest.

- box        Die Objektnummer dieses Buttons.


\end

screen ( sensitive ( "Exit_GEM" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID Exit_GEM ( VOID );


Diese Funktion meldet alle noch offenen Fenster ab, gibt den von Lib
benutzen Speicher wieder frei, entfernt evtl. noch vorhandene
Resourcen aus dem Speicher und meldet das Programm beim GEM ab.

Diese Funktion muss am Ende Ihres Programms aufgerufen werden.
Allerdings nur dann, wenn \#Init_GEM\# einen Wert grîsser 0 geliefert
hat.

\end

screen ( sensitive ( "LoadResource" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: UINT LoadResource ( BYTE *rsc_name );


LÑdt die angegebene Resourcedatei ein und liefert die LÑnge der
Resource in Bytes zurÅck, wenn das Einlesen geklappt hat, 0 sonst.

\end

screen ( sensitive ( "RscAdr" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: OBJECT *RscAdr ( INT tree_type, INT index );


Nachdem mit \#LoadResource\# eine Resourcedatei geladen wurde, kînnen
mit dieser Funktion die Adressen der verschiedenen BÑume und Objekte
bestimmt werden.

Wollen Sie z. B. die Adresse eines Dialogs ermitteln, Åbergeben Sie
fÅr 'tree_type' einfach R_TREE. Die anderen Parameter stimmen mit
denen Åberein, wie sie in AES.H definiert sind.

\end

screen ( sensitive ( "RscFree" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RscFree ( VOID );


Diese Funktion gibt den Speicherplatz, in den die Resource-Datei
geladen wurde, wieder frei. Diese Funktion wird auch automatisch
von SysGem bei \#Exit_GEM\# aufgerufen.

\end

screen (  sensitive ( "Objecttypen"    ),
         sensitive ( "SPECIAL_BUTTON" ),
         sensitive ( "SPECIAL_TEXT"   ),
         sensitive ( "SPECIAL_FRAME"  ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

- SPECIAL_BUTTON - Erweiterte Nummer 18

  Nur einsetzbar bei Button-Objekten (GEM-Objektnummer 26)!

  Der Button wird in AbhÑngigkeit der Objekt-Flags und des Objekt-
  Status gezeichnet. Dabei kommt folgenden Flags bzw. Kombinationen
  eine besondere Bedeutung zu:

  - SELECTABLE

    Zeichnet eine ankreuzbare Box. Das Kreuz wird in AbhÑngigkeit des
    SELECTED-Statusflags gezeichnet. Der Buttontext wird rechts neben
    der Box angeordnet. Planen Sie ca. 3 Zeichen mehr Platz ein fÅr
    den Button.

  - SELECTABLE und EXIT

    Es wird ein 'normaler' Button dargestellt, ggf. mit Tastatur-
    Shortcut.

  - SELECTABLE und RADIOBUTTON

    Es wird ein runder Knopf gezeichnet, und gefÅllt, wenn SELECTED
    als Status gegeben ist. Der Buttontext wird rechts neben dem
    Knopf angeordnet. Planen Sie ca. 3 Zeichen mehr Platz ein fÅr
    dieses Objekt.

- SPECIAL_TEXT - Erweiterte Nummer 19

  Nur mit String-Objekt (GEM-Objektnummer 28)!

  Der String wird in AbhÑngigkeit des Objektstatus ausgegeben:

  - SELECTED

    Der String wird Schwarz hinterlegt.

  - DISABLED

    Der String wird in 'heller' Schrift gezeichnet und ist auch
    nicht anwÑhlbar!

  - OUTLINED

    Der Text wird zweifach unterstrichen.

  - SHADOWED

    Der String wird einfach unterstrichen.

  - WHITEBAK

    Es wird Fettschrift verwendet.

  - CHECKED

    Es wird die Iconschrift verwendet.


- SPECIAL_FRAME - Erweiterte Nummer 20

  Macht aus einem Button-Objekt (GEM-Objektnummer 26) einen Rahmen.
  Dabei wird der Buttontext auf die obere Linie der Box geschrieben:

  +-Titelbox--------+
  |                 |
  |                 |
  |                 |
  |                 |
  +ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ+

  Kann dazu verwendet werden, um Felder von Radiobuttons voneinander
  zu trennen, oder sonstige Gliederungen in der Dialogbox zu machen.

  Das Objekt sollte _nicht_ den SELECTABLE Status haben. Der Text
  wird mit den Effekten wie bei SPECIAL_TEXT gezeichnet, allerdings
  wird WHITEBAK nicht unterstÅtzt.

  ZusÑtzlich kann durch Angabe von  CROSSED  der String zentriert
  werden.

  \#Tastatur\#

\end

screen ( sensitive ( "Tastatur" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

GrundsÑtzlich gilt fÅr alle erweiterten Typen ausser Mover und Frame:

Ist im Text des Objekts ein [ eingetragen, wird der folgende Buchstabe
als Tastatur-Shortcut benutzt, d.h. der Buchstabe zusammen mit der
Shortkey-Taste lîsen das Objekt aus. Beispiel:


Aus dem Buttontext  [Selectable  wird  Selectable  also mit
unterstrichenem S.                     


Durch DrÅcken von [ALTERNATE]-[S] wird das Objekt selektiert und
- wenn das Objekt den EXIT-Status hat - der Dialog auch verlassen.

Es werden ausschliesslich folgende Zeichen als Shortcuts akzep-
tiert:

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                  1 2 3 4 5 6 7 8 9 0

wobei Gross- und Kleinbuchstaben als gleichwertig betrachtet werden.

\end

screen ( sensitive ( "NewDialog" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL NewDialog ( OBJECT *tree );


Beim Aufruf dieser Funktion legt SysGem intern Strukturen an, in denen
wichtige Parameter Åber den Dialog gespeichert werden, z. B. der Hin-
tergrund des Dialogs. Die Funktion gibt \#TRUE\# zurÅck, wenn die Struktur
angelegt werden konnte. Sollte es einmal passieren, dass die Funktion
\#FALSE\# zurÅckgibt und Sie dennoch den Dialog darstellen lassen wollen,
so passiert gar nichts.

Siehe auch: \#Besonderheiten\#

\end

screen ( sensitive ( "DoDialog" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT DoDialog ( OBJECT *tree, INT first_edit, BYTE *title );


ôffnet ein Fenster, der den optionalen Title 'title' besitzt und
stellt dann den Dialog dar.

In 'tree' Åbergeben Sie die Adresse, die Sie mittels \#RscAdr\# bestimmt
haben. 'first_edit' gibt das erste editierbare Feld innerhalb des
Dialogs an. Sollten in Ihrer Dialogbox keine Edit-Felder vorkommen,
so Åbergeben Sie einfach eine 0.

Die Funktion kÅmmert sich dann um alles. Um das Verschieben, um
Eingaben, einfach um alles. Nachdem der Benutzer ein EXIT oder
TOUCHEXIT Feld angeklickt hat und damit den Dialog verlassen will,
wird der Hintergrund automatisch restauriert. Die Funktion gibt die
Nummer des Objektes zurÅck, Åber den der Benutzer den Dialog verlassen
hat.


Siehe auch: \#Besonderheiten\#

\end

screen ( sensitive ( "Besonderheiten" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Kommen in Ihren Dialogen Edit-Felder vor, so hat SysGem in diesem
Zusammenhang noch eine Besonderheit zu bieten:

Ist ein Feld DEFAULT gesetzt, wird es nicht - wie sonst Åblich - nur
mit RETURN angewÑhlt, der Benutzer muss SHIFT-RETURN betÑtigen, um das
DEFAULT-Feld anzuwÑhlen.

Innerhalb von Edit-Feldern kann der Benutzer nun mittels RETURN zum
nÑchsten Edit-Feld springen. Auf TAB oder die Cursortasten kann nun
weitgehend verzichtet werden - Return ist viel einfacher. Befindet
sich der Cursor im letzten Edit-Feld und betÑtigt der Benutzer RETURN,
wird der Cursor in das erste Edit-Feld gesetzt (und umgekehrt). Ein
bisschen komfortabler als GEM sollte es halt schon sein...

Nichtsdestotrotz kînnen sie natÅrlich auch die Vorgehensweise ein-
stellen, die Sie von GEM her gewohnt sind! Alles weitere finden Sie
bei der Funktion \#SetReturn\#.

\end

screen ( sensitive ( "SetReturn" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetReturn ( BOOL like_sysgem );


Wie bei den Dialogen und den Editfeldern besprochen, kînnen Sie mit
dieser Funktion das Verhalten der Return-Taste einstellen.

- 1        Die Editfelder lassen sich mit der Taste <Return> weiter
           anwÑhlen, d.h., drÅckt man Return, wird der Cursor
           auf das nÑchste Editfeld gesetzt und ein evtl. gesetzter
           Exit-Button kann mit [Shift][Return] ausgewÑhlt werden.

           Dies ist die Voreinstellung.

- 0        Die [Return] Taste wÑhlt den Default-Button an. Es findet
           keine Positionierung in den Editfeldern statt. Der Benutzer
           muss also immer die [TAB] Taste oder die Cursor-Tasten
           benutzen, um ein Editfeld weiterzukommen.

Siehe auch: \#Besonderheiten\#

\end

screen ( sensitive ( "DialPosXY" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID DialPosXY ( BOOL center );


Normalerweise erscheinen Dialoge in der Bildschirmmitte. Bei Grossbild-
schirmen ist es allerdings fÅr die Masse der Anwender bequemer, wenn
die Dialoge an der Position erscheinen, wo sich zur Zeit die Maus
befindet.

öbergeben Sie \#TRUE\#, werden die Dialoge in der Bildschirmmitte darge-
stellt. Dies ist die Voreinstellung.

öbergeben Sie \#FALSE\#, erscheinen die Dialoge an der Mausposition.

\end

screen ( sensitive ( "SetFieldProc" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetFieldProc (INT (*proc)(OBJECT *tree, INT ed, LONG id));


Mit  Hilfe  dieser  Funktion kînnen Sie eine Funktion anmelden,  die
angesprungen wird, wenn Sie in einem Dialog ein Editfeld weitergehen.

'ed' > 0        Als Argument wird der Index des Editfeldes
                Åbergeben, den der Cursor gerade verlassen hat
                und der Zeiger auf den aktuellen Baum also
                ein Zeiger auf den Dialog), damit Sie auch
                eine Routine fÅr mehrere Dialoge nutzen kînnen.

'ed' < 0        Manchmal kann es aber sinnvoll sein, zu wissen,
                was in einem Editfeld steht, _bevor_ der Cursor
                in das Feld gesetzt wird.

                Um zu erkennen, was denn nun passiert ist, wird
                Index das entsprechenden Editfeld _negativ_
                angegeben, was natÅrlich von Ihnen abgefragt werden
                _muss_.

- tree          Zeiger auf den Dialog, in dem sich das Editfeld
                befindet.

- id            Die Id, die bei \#WindowDialog\# angegeben wurde.


Die Funktion muû zurÅckliefern:

-1       Der Cursor bleibt in diesem Editfeld

 0       Weitermachen, aber Cursor bleibt im alten Feld

 1       Cursor wird in's neue Feld gesetzt


\end

screen ( sensitive ( "Alert" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT Alert ( INT priority, INT def, BYTE *alert_string );


Beispiel: button = Alert ( ALERT_NORM, 2, "[3][Hallo, Ihr da!][ [Tag | [Nacht]" );
            ^                 ^        ^    ^        ^                 ^
 Ergebnis --|                 |        |    |        |                 |
 PrioritÑt -------------------|        |    |        |                 |
 Defaultbutton ------------------------|    |        |                 |
                                            |        |                 |
 Icon --------------------------------------|        |                 |
                                                     |                 |
 Text der Alertbox (durch '|' getrennt) -------------|                 |
                                                                       |
 Die einzelnen Buttons, die Benutzer wÑhlen kann ----------------------|

Die Funktion stellt eine AlertBox im Fenster dar; wobei man das Verhalten
der Alertbox noch beeinflussen kann. Parameter fÅr priority:

ALERT_NORM      Normales Fenster. Die Hintergrundprozesse kînnen bedient
                werden. Ausblenden des Programms geht allerdings nicht.

ALERT_STOP      Nur die Alertbox kann bedient werden.


Drei Icons stehen zur Auswahl:

0 = kein Icon
1 = Ausrufezeichen
2 = Fragezeichen
3 = Stop-Schild

Der Text darf aus maximal 16 Zeilen mit maximal 55 Zeichen pro
Zeile bestehen. Das Zeichen '|' trennt die Zeilen voneinander.

Die Zahl der Quittierungsknîpfe muss zwischen 1 und 5 liegen. Der
Text auf jedem Knopf darf dabei maximal 20 Zeichen lang sein.

'def' gibt die Nummer des Buttons an, der beim Alert als Default
erscheinen soll, also mit RETURN anwÑhlbar ist. Wird eine 0 Åber-
geben, so ist kein Button mit RETURN anwÑhlbar; der Benutzer muss
mit der Maus den Alert bedienen.

Die Funktion gibt die Nummer des Buttons zurÅck, den der Benutzer
gewÑhlt hat. Klickte der Benutzer z. B. in obigem Beispiel auf 'Tag',
so ist das Ergebnis 1. Klickt er auf 'Nacht', gibt Alert eine 2
zurÅck.


Siehe auch: \#SetIconColor\#  \#SetButton\#

\end

screen ( sensitive ( "SetIconColor" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT SetIconColor ( INT color );


Diese Funktion setzt die Farbe des Icons des Alerts.

öbergeben Sie fÅr 'color' -1, wird die aktuell eingestellte Farbe
zurÅckgeliefert.

\end

screen ( sensitive ( "SetButton" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetButton ( INT just );


Mit dieser Funktion kînnen Sie die Ausrichtung der Buttons in Alerts
bestimmen. Es gibt drei Mîglichkeiten:

- ButtonLeft     Die Buttons werden linksbÅndig angeordnet.
- ButtonCenter   Die Buttons werden zentriert. Voreinstellung.
- ButtonRight    Die Buttons werden rechtsbÅndig angeordnet.

\end

screen ( sensitive ( "GetText" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BYTE *GetText ( OBJECT *tree, INT index, BYTE *text );


Erfragt den Text des Objectes 'index' im Baum 'tree'.
Die Funktion kÅmmert sich selbst darum, ob Sie einen String, einen
Edittext oder z.B. Icontext abfragen wollen.

Die Funktion liefert den Zeiger auf 'text' zurÅck.

\end

screen ( sensitive ( "SetText" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetText ( OBJECT *tree, INT index, BYTE *text );


Setzt den Text 'text' des Objektes 'index' im Baum 'tree'.
Die Funktion kÅmmert sich selbst darum, ob Sie einen String, einen
Edit-Text oder z.B. einen Icontext setzen wollen.

\end

screen ( sensitive ( "RedrawObj" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RedrawObj (OBJECT *tree, INT obj, INT depth, INT state, INT flag);


Zeichnet das Objekt 'obj' mit der Tiefe 'depth' des Baumes 'tree' neu.

'state' gibt an, ob ein neuer Status genutzt werden soll.

'flag' gibt an, was getan werden soll:

  - FLIP_STATE  Ist der Status schon gesetzt, wird er entfernt,
                ist er nicht vorhanden, wird er gesetzt.

  - DEL_STATE   Der angegebene Status wird entfernt.
                War er beim Aufruf nicht gesetzt, wird das Objekt
                auch nicht gezeichnet!

  - SET_STATE   Der angegebene Status wird gesetzt.
                War er beim Aufruf schon gesetzt, wird das Objekt
                auch nicht gezeichnet!

  - UPD_STATE   Das Objekt wird lediglich neu gezeichnet.

----------------------------------------------------------------------
Beispiel:

RedrawObj ( demo_dialog, OK_BUTTON, 0, SELECTED, DEL_STATE );


Zeichnet das Objekt OK_BUTTON im Baum demo_dialog __nach__ dem
Entfernen des SELECTED-Status neu --- allerdings nur dann, wenn
SELECTED im Status vorhanden ist. Wenn es nichts zu Ñndern gibt,
zeichnet die Funktion auch nichts neu.

Eine Ausnahme ist UPD_STATE. Dieses Flag erzwingt das neuzeichnen,
allerdings ohne énderung des Status. FÅr 'state' sollte also
'NONE' Åbergeben werden, andere Werte werden ignoriert.

Die Funktion beachtet teilweise verdeckte Bereiche automatisch, so
dass Sie hiermit auch in teilweise oder ganz verdeckten Fensterdialogen
zeichnen kînnen.

\end

screen ( sensitive ( "NewArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL NewArea ( \#AREA\# *area );


Legt eine neue Area-Struktur an. Die Funktion liefert \#TRUE\#, wenn alles
glatt ging.

\end

screen ( sensitive ( "ClearArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ClearArea ( \#AREA\# *area );


Gibt einen eventuell noch allozierten Speicher frei. Die Area-Variable
bleibt intern aber noch bekannt.

\end

screen ( sensitive ( "FreeArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID FreeArea ( \#AREA\# *area );


Gibt die Area-Variable frei und eventuell noch benutzen Speicher frei.

\end

screen ( sensitive ( "SaveArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL SaveArea ( INT handle, \#AREA\# *area, \#RECT\# *r );


Sichert einen Bildschirmbereich ins RAM. Die Funktion liefert \#FALSE\#,
wenn der Bildschirmbereich, der durch 'r' beschrieben wird, nicht
kopiert werden konnte.

Ist bereits ein Bildspeicher alloziiert und dieser fÅr das zu
sichernde TeilstÅck zu klein, wird er freigegeben und ein neuer
Speicherbereich angefordert.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise \#vdi_handle\# aus \#PARAMETER\#).

\end

screen ( sensitive ( "RestoreArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RestoreArea ( INT handle, \#AREA\# *area );


Kopiert einen mit \#SaveArea\# gespeicherten Bereich wieder auf
seine Originalposition zurÅck.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise \#vdi_handle\# aus \#PARAMETER\#).

\end

screen ( sensitive ( "CopyArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID CopyArea ( INT handle, \#AREA\# *area, INT x, INT y );


Kopiert einen mit \#SaveArea\# gespeicherten Bereich an die
Position x und y. Der gesicherte Bereich wird dabei nicht
verÑndert.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise \#vdi_handle\# aus \#PARAMETER\#).

\end

screen ( sensitive ( "MoveScreen" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID MoveScreen ( INT handle, \#RECT\# *r, INT x, INT y );


Diese Funktion kopiert einen Bildschirmbereich, dessen Koordinaten
in 'r' beschrieben sind, an die Position x, y.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise \#vdi_handle\# aus \#PARAMETER\#).

\end

screen ( sensitive ( "ClearEditFields" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ClearEditFields ( OBJECT *tree );


Lîscht alle Editfelder im Dialog 'tree'. Editfelder, die mit dem
DISABLED-Flag versehen sind, oder denen das EDITABLE-Flag fehlt,
werden nicht berÅcksichtigt.

\end

screen ( sensitive ( "GetEditFields" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID GetEditFields ( OBJECT *tree,
                               VOID   (*callback)(INT obj, BYTE *s ));


Um das auslesen von Editfeldern zu rationalisieren, gibt es diese
Funktion.

Die callback-Funktion wird mit der Objektnummer des Editfeldes und dem
Inhalt des Editfeldes aufgerufen. Editfelder, die mit dem DISABLED-Flag
versehen sind, oder denen das EDITABLE-Flag fehlt, werden nicht berÅck-
sichtigt.

\end

screen ( sensitive ( "SetState" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetState ( OBJECT *tree, INT obj, INT state );


Verodert den Status 'state' mit den eventuell bereits vorhandenen
Objektstati des Objekts 'obj' im Baum 'tree'.

\end

screen ( sensitive ( "DelState" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID DelState ( OBJECT *tree, INT obj, INT state );


Lîscht den Status 'state' beim Objekt 'obj' im Baum 'tree'.

\end

screen ( sensitive ( "GetState" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL GetState ( OBJECT *tree, INT obj, INT state );


Liefert \#TRUE\#, wenn 'state' beim Objekt gesetzt ist, \#FALSE\# sonst.

\end

screen ( sensitive ( "SetGlobalState" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetGlobalState ( OBJECT *tree, INT obj, INT state );


Setzt den Status 'state' beim Objekt 'obj' global. WÑhrend bei
\#SetState\# verodert wird, wird das hier nicht gemacht.

\end

screen ( sensitive ( "SetFlags" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetFlags ( OBJECT *tree, INT obj, INT flags );


Verodert das Flag 'flags' mit den eventuell bereits vorhandenen
Objektflags des Objekts 'obj' im Baum 'tree'.

\end

screen ( sensitive ( "DelFlags" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID DelFlags ( OBJECT *tree, INT obj, INT flags );


Lîscht das Flag 'flags' beim Objekt 'obj' im Baum 'tree'.

\end

screen ( sensitive ( "GetFlags" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL GetFlags ( OBJECT *tree, INT obj, INT flags );


Liefert \#TRUE\#, wenn 'flag' beim Objekt gesetzt ist, \#FALSE\# sonst.

\end

screen ( sensitive ( "SetGlobalFlags" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetGlobalFlags ( OBJECT *tree, INT obj, INT flags );


Setzt das/die Flags 'flags' beim Objekt 'obj' global. WÑhrend bei
\#SetFlags\# verodert wird, wird das hier nicht gemacht.

\end

screen ( sensitive ( "objc_frame" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT objc_frame ( OBJECT *tree, INT obj );


Berechnet den Rahmen des Objektes 'obj' im Baum 'tree'.
Eine 2 wÅrde bedeuten, dass der Rahmen 2 Pixel aus dem Dialog
herausragt.

\end

screen ( sensitive ( "CalcArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID CalcArea ( OBJECT *tree, INT obj, \#RECT\# *r );
                                 var r : \#RECT\# );


Berechnet die Ausmasse des Objektes 'obj' im Baum 'tree' und liefert
die Koordinaten in 'r' zurÅck. Eventuelle Rahmen, Schattierungen
usw. werden berÅcksichtigt. Die Funktion liefert die absoluten Bild-
schirmkoordinaten zurÅck.


\end

screen ( sensitive ( "WindowDialog" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

INT  WindowDialog ( LONG        id,
                    INT         xpos,
                    INT         ypos,
                    UBYTE       *name,
                    UBYTE       *info,
                    BOOL        shut,
                    BOOL        force,
                    OBJECT      *tree,
                    OBJECT      *menu,
                    INT         edit,
                    VOID        *user,
                    \#DPROC\#       proc );


Diese  Funktion  stellt einen Dialog in einem Fenster dar und kÅmmert
sich  um  die  gesamte  Verwaltung  desselben.  Dies  ist die "grosse"
Variante,  bei der Sie auf sehr viele Dinge, die den Dialog betreffen,
Einfluss  ausÅben  kînnen.  Wollen  Sie nur schnell einen Dialog auf
den  Bildschirm  zaubern,  kînnen  Sie  statt  dieser  Funktion  auch
\#DoDialog\# benutzen.

Die Parameter:

- id            Die Id dient dazu, um z. B. von anderen Prozessen
                Fensterdaten abzufragen. Ausserdem kînnen Sie so
                Ihren Dialog komfortabel verwalten. Erwartet wird ein
                4-Zeichen-Code, z.b. 'DEMO', oder 'INFO' oder
                Ñhnliches.

                Die Funktion prÅft, ob die Id schon vorhanden ist,
                d.h., zwei Fenster mit der gleichen Id sind nicht
                mîglich.

- xpos          Gibt die X-Position an, an der der Dialog erscheinen
                soll. Soll nach dem mit \#DialPosXY\# eingestellen
                Parameter verfahren werden, Åbergeben Sie einfach
                -1.

- ypos          Gibt die Y-Position an, an der der Dialog erscheinen
                soll. Soll nach dem mit \#DialPosXY\# eingestellen
                Parameter verfahren werden, Åbergeben Sie einfach
                -1.

- title         Mit diesem String legen Sie die DialogÅberschrift
                fest. In einer Multitask-Umgebung setzt SysGem
                automatisch die Programm-Id als "[xxxx]" vor den
                Fensternamen. Wenn das von Ihnen nicht gewÅnscht
                wird, Åbergeben Sie als erstes Zeichen ein '|'.
                Die Id wird dann nicht angezeigt.

- info          Hiermit kann eine Info-Zeile Åbergeben werden, die
                im Dialog dargestellt wird.

                Es ist entweder nur eine Info-Zeile oder eine
                MenÅzeile mîglich. Haben Sie noch eine MenÅ-Zeile
                mit angegeben, ist die Info-Zeile ohne Bedeutung.

                Wollen Sie keine Info-Zeile, so Åbergeben Sie
                einfach einen leeren String (also "").

- shut          öbergeben Sie \#TRUE\#, wird der Dialog mit einem
                Schliessfeld ausgestattet.

- force         öbergeben Sie \#TRUE\#, kann nur dieser Dialog vom
                Benutzer bearbeitet werden. Der Benutzer kann keine
                anderen Fenster in den Vordergrund holen, solange
                dieser Dialog nicht beendet wurde. Um dies auch
                optisch zu verdeutlichen, wird die MenÅzeile
                gesperrt.

- tree          Zeiger auf den Dialog, der im Fenster dargestellt
                werden soll. Muû vorher mit \#NewDialog\# angemeldet
                worden sein.

- menu_line     Im Fenster kann eine MenÅzeile dargestellt werden.
                Wollen Sie keine, so Åbergeben Sie einfach NULL.

- first_edit    Gibt das Editfeld an, in das der Cursor gesetzt
                werden soll. EnthÑlt Ihr Dialog keine Edit-Felder,
                oder wollen Sie das Editieren verhindern, so
                Åbergeben Sie eine 0. öbergeben Sie -2, sucht sich
                SysGem das erste Editfeld selbststÑndig heraus und
                positioniert den Cursor in diesem Feld. Es mÅssen
                aber Editfelder vorhanden sein!

- user          Hier kînnen Sie einen Zeiger unterbringen, der fÅr
                Sie zur VerfÅgung steht. Wenn Sie keinen brauchen
                oder nicht wissen, wozu das gut sein soll, Åbergeben
                Sie einfach NULL.

- dfunc         öber diese Funktion wird der Dialog von Ihnen
                gesteuert. SysGem ruft diese Funktion auf, wenn der
                Benutzer etwas getan hat, was die Mitarbeit Ihres
                Programmes erfordert.

                Mehr unter \#dfunc\#

\end

screen ( sensitive ( "redraw" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID window_redraw ( \#WINDOW_INFO\# *inf );

Diese  Funktion  wird  aufgerufen,  wenn  ein  Teil  des  Fensters neu
gezeichnet werden muss.

\#WINDOW_INFO\# ist dabei wie folgt belegt:

handle          Das Handle des Fensters, das neu gezeichnet werden
                soll.

id              enthÑlt die Id des Fensters, welches Sie beim
                ôffnen angegeben haben.

                Ist das Handle des Fensters 0 (Desktop), enthÑlt die
                Id immer 'DESK'.

doc_x
doc_y           enthalten die Grîsse des Documents.

pos_x
pos_y           enthalten die Position der linken oberen Ecke des
                Dokuments, das im Fenster sichtbar ist.

scroll          EnthÑlt -1 bei normalem Redraw und den Wert von
                WA_..., wenn gescrollt wurde.

work_area       enthÑlt die Position und Ausmasse des Arbeitsbereiches
                des Fensters 'handle'.

draw_area       enthÑlt die Position und Ausmasse des Arbeitsbereiches
                ohne die eventuell eingelinkten BÑume (\#LinkTree\#).

clip            enthÑlt die Koordinaten des gesetzten Clip-Rechtecks.
                Das Clipping ist dabei auf die VDI-Workstation
                \#vdi_handle\# eingestellt, welches ja schon fÅr Ihr
                Programm reserviert wurde.

                Arbeiten Sie mit einer anderen Workstation, so
                mÅssen Sie das Clipping selbst Åbernehmen!!!

                Desweiteren wurde schon wind_update fÅr Sie gesetzt.
                Sie sollten es also nicht noch mal aufrufen.

                Soweit SysGem dazu in der Lage ist, Åbernimmt es
                Redraw's von allein. Die Redraw-Funktion wird also
                nur aufgerufen, wenn es wirklich sein muss. Sie
                sollten also nur den Bereich neu zeichnen, der mit
                'clip' beschrieben ist.

                SysGem versteckt beim Aufruf der Redraw-Funktion
                __nicht__ den Mauszeiger, da das bei AES-Ausgaben
                sowieso nicht notwendig ist. TÑtigen Sie aber
                VDI-Ausgaben, mÅssen Sie selbst dafÅr sorgen, dass
                die Maus nicht 'Åbermalt' wird.

user            enthÑlt den Zeiger, den Sie beim ôffnen angegeben
                haben.

\end

screen ( sensitive ( "action" ),
         sensitive ( "SG_DRAW" ),
         sensitive ( "SG_SIZED" ),
         sensitive ( "SG_MOVED" ),
         sensitive ( "SG_LCLICK1" ),
         sensitive ( "SG_LCLICK2" ),
         sensitive ( "SG_RCLICK1" ),
         sensitive ( "SG_RCLICK2" ),
         sensitive ( "SG_BUTTON" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT action ( INT msg, \#WINDOW_INFO\# *inf );


öber  diese Funktion werden Ereignisse, die ein Fenster betreffen, an
Sie   weitergeleitet.   Viele   Ereignisse  (z.  B.  Sliderverwaltung)
Åbernimmt  SysGem  allein,  aber bei z. B. Mausklicks ins Fenster ist
SysGem mit seinem Latein auch am Ende und braucht Ihre Hilfe.


msg  kann folgende Werte annehmen:

- SG_LCLICK1    Ein Einfachklick mit der linken Maustaste trat auf.
- SG_LCLICK2    Ein Doppelklick mit der linken Maustaste trat auf.
- SG_RCLICK1    Ein Einfachklick mit der rechten Maustaste trat auf.
- SG_RCLICK2    Ein Doppelklick mit der rechten Maustaste trat auf.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                mx
                my
                work_area
                draw_area
                user
                line        - Die Zeile, in die geklickt wurde oder
                              -1L, wenn sich an dieser Stelle keine
                              Textzeile befindet
                column      - Die Spalte, in die geklickt wurde oder
                              -1L, wenn sich an dieser Stelle kein
                              Zeichen befindet (z.b. wenn die Zeile
                              zu kurz ist)

                line_ptr    - Zeiger auf das [0]-Element des Strings.

                Diese 3 Variablen sind nur belegt, wenn sich ein Text
                im Fenster befindet, der mit \#LinkList\# eingetragen
                wurde oder mit \#Display\# geladen wurde.

- SG_DRAW       Das Fenster _wurde_ neu gezeichnet.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                clip       - EnthÑlt die gezeichneten Koordinaten
                user

- SG_KEY        Ein Tastendruck trat auf. Gibt die Funktion SG_KEYCONT
                zurÅck, wird der Tastendruck noch weitergeleitet.

                Wird SG_KEYUSED zurÅckgegeben, so heisst dies, dass
                der Tastendruck 'verbraucht' wurde und nicht mehr
                weitergeleitet werden soll.

                Bei einem RÅckgabewert von SG_CLOSE wird das Fenster
                geschlossen, allerdings wird diese Funktion nochmal
                mit dem 'msg'-Wert SG_QUIT aufgerufen.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                key        - Scancode der gedrÅckten Taste
                state      - Status der Sondertasten
                work_area
                draw_area
                user

- SG_MENU       Das FenstermenÅ wurde angewÑhlt.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                mItem
                work_area
                draw_area
                user

- SG_MOVED      Das Fenster wurde verschoben; oder
- SG_SIZED      Das Fenster wurde mittels Sizer in der Grîsse verÑndert.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user

- SG_END        Der Benutzer mîchte, dass das Fenster geschlossen
                wird. Geben Sie SG_CLOSE zurÅck, wird das Fenster
                geschlossen. Geben Sie SG_CONT zurÅck, bleibt das
                Fenster offen, so, als hÑtten Sie die Meldung nie
                erhalten.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user

- SG_QUIT       Das Fenster wird auf jeden Fall geschlossen, sobald
                die Routine zurÅckkehrt. Sie kînnen also
                irgendwelche Strukturen oder Speicherbereiche
                freigeben. Das Schliessen des Fensters kann nicht
                verhindert werden.

                Die Info-Struktur ist wie bei SG_END belegt.

- SG_UNTOP      Das Fenster wurde in den Hintergrund gelegt. Diese
                Nachricht wird gesendet, damit Sie darauf reagieren
                kînnen, wenn Sie z. B. einen Cursor in einem Fenster
                darstellen.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user

- SG_TOP        Das Fenster wurde zum obersten aktuellen ernannt.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user

- SG_INVISIBLE  Der Prozess, zu dem das Fenster gehîrt, wurde
                ausgeblendet (z.Z. nur Mag!X). Das Fenster ist
                unsichtbar, bzw. es befindet sich nicht mehr im
                sichtbaren Bereich des Bildschirms.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user

                Die neuen Koordinaten werden durch einen weiteren
                Aufruf mit SG_SIZED mitgeteilt.

           -->  Eventuelle Redraws sind einzustellen. Diese Nachricht
                wird auch gesendet, wenn das Fenster Iconifiziert
                wurde.

- SG_VISIBLE    Das GegenstÅck. Der Prozess, bzw. das Fenster wurde
                wieder eingeblendet.

                WINDOW_INFO-Belegung wie bei SG_INVISIBLE.

                Die neuen Koordinaten werden durch einen weiteren
                Aufruf mit SG_SIZED mitgeteilt.

- SG_BUTTON     Haben Sie mit \#LinkTree\# BÑume im Fenster
                plaziert, so wurde auf eines dieser Objekte
                geklickt.

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                mx
                my
                work_area
                draw_area
                user
                item    - Objektnummer
                obj_id  - Id des Baumes

- SG_DRAGDROP   Objekte wurden via Drag & Drop auf das Fenster
                gezogen. NÑheres siehe unter \#DRAG_DROP\#.

                Folgende Elemente aus WINDOW_INFO sind belegt:

                handle
                id
                doc_x
                doc_y
                pos_x
                pos_y
                work_area
                draw_area
                user
                dd


Als RÅckgabewerte stehen Ihnen folgende zur VerfÅgung:


- SG_CLOSE      Das Fenster soll geschlossen werden. Es erfolgt noch
                ein Aufruf mit SG_QUIT.

- SG_REDRAW     Das Fenster wird redrawed.

- SG_TERM       Das Programm wird beendet. Ist identisch mit einem
                Aufruf von \#TerminateSysGem\#.

- SG_CONT       Weitermachen!

- SG_KEYUSED    Tastendruck wurde von der Funktion ausgewertet. Er
                braucht nicht mehr weitergeleitet werden.

- SG_KEYCONT    Tastendruck an nÑchste Ebene weiterleiten.

\end


screen ( sensitive ( "OpenWindow" ),
         sensitive ( "scroll_x" ),
         sensitive ( "scroll_y" ),
         sensitive ( "doc_x" ),
         sensitive ( "APROC" ),
         sensitive ( "RPROC" ),
         sensitive ( "doc_y" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef INT     (*APROC)(INT msg, \#WINDOW_INFO\# *inf );
typedef VOID    (*RPROC)(\#WINDOW_INFO\# *inf );

INT OpenWindow ( LONG   id,
                 UBYTE  *name,
                 UBYTE  *info,
                 INT    flags,
                 OBJECT *menu,
                 INT    align,
                 BOOL   part_redraw,
                 INT    scroll_x,
                 INT    scroll_y,
                 LONG   doc_x,
                 LONG   doc_y,
                 INT    x,
                 INT    y,
                 INT    w,
                 INT    h,
                 VOID   *user,
                 RPROC  \#redraw\#,
                 APROC  \#action\# );


Erschrecken   Sie  nicht,  es  sieht  komplizierter  aus,  als  es  in
Wirklichkeit ist.

- id            Die Id dient dazu, um z. B. von anderen Prozessen
                Fensterdaten abzufragen. Ausserdem kînnen Sie so
                Ihren Dialog komfortabel verwalten. Erwartet wird ein
                4-Zeichen-Code, z.b. 'DEMO', oder 'INFO' oder
                Ñhnliches.

                Die Funktion prÅft, ob die Id schon vorhanden ist,
                d.h., zwei Fenster mit der gleichen Id sind nicht
                mîglich.

- name          Der Name des Fensters als String.

                In einer Multitask-Umgebung setzt SysGem automatisch
                die Programm-Id als "[xxxx]" vor den Fensternamen.
                Wenn das von Ihnen nicht gewÅnscht wird, Åbergeben Sie
                als erstes Zeichen ein '|'. Die Id wird dann nicht
                angezeigt.

- info          Die Text, der in der Infozeile dargestellt wird.
                Haben Sie eine MenÅzeile angegeben, ist eine
                Infozeile nicht mîglich. Wollen Sie keine Infozeile,
                Åbergeben Sie einfach einen Leerstring.

- flags         bestimmt das Aussehen der Fenster. Die einzelnen
                Fensterattribute sind in AES.H ausfÅhrlich
                beschrieben.

                Wenn Sie ein Fenster mit allen Attributen haben
                wollen, aber ohne Infozeile, kînnen Sie auch einfach
                den Wert 0xfef (4079) Åbergeben. Ist vielleicht
                einfacher. Wollen Sie die Infozeile noch dazuhaben,
                schreiben Sie einfach 0xfef | INFO.

- menu_line     Zeiger auf die MenÅleiste, oder NULL, wenn Sie keine
                MenÅleiste benutzen/haben wollen.

- align         Bestimmt den horizontalen Ausrichtungsfaktor des
                Fensters. Die Fensterpostion kann nur solche x-Werte
                annehmen, bei denen der Arbeitsbereich des Fensters
                auf einem Vielfachen des align-Wertes beginnt. Ist z.
                B. ein align- Faktor von 8 angegeben, so kann das
                Fenster nur auf x-Positionen mit den Werten 7, 15, 23
                usw. liegen, da der Arbeitsbereich des Fensters an
                einer um einen Pixel hîheren x-Position als der
                Fenster-Rahmen beginnt.

                Ein align Wert von 8 ist besonders bei Textausgaben
                im Fenster sinnvoll, da Text an durch 8 teilbaren
                x-Koordinaten vom VDI in einer wesentlich hîheren
                Geschwindig- keit ausgegeben wird, wobei natÅrlich
                Voraussetzung ist, dass die Textausgabe linksbÅndig
                im Fenster beginnt.

                Siehe auch: \#charw\#

- part_redraw   öbergeben Sie hier \#TRUE\#, so wird das Fenster bei
                einem Neuzeichnen schon mal mit weiss Åbermalt. Dies
                ist bei Textausgaben z. B. sinnvoll, da die Texte ja
                immer schwarz auf weiss ausgegeben werden. So kann
                sich Ihr Programm das Zeichnen des weissen
                Hintergrundes sparen.

- scroll_x
- scroll_y      geben die horizontale bzw. vertikale Schrittweite des
                Fensters in Pixeln an. Bei BetÑtigung eines
                Scrollpfeils scrollt SysGem den Fensterinhalt um den
                angegebenen Wert.

                Siehe auch: \#charw\#, \#charh\#

- doc_x
- doc_y         geben die Grîsse des Documents in Pixeln an. Da ein
                Fenster ja meistens nur einen kleinen Ausschnitt aus
                dem Document zeigt, benîtigt SysGem die Angabe, wie
                gross das Document wirklich ist, um z. B. die
                Position und Grîsse von evtl. vorhandenen Slidern
                richtig berechnen zu kînnen.


- x, y, w, h    gibt die Grîsse an, die der *** Arbeitsbereich ***
                des Fensters beim ôffnen haben soll.

- user          ist ein Zeiger auf irgendeinen Speicherbereich oder
                auf eine Struktur. Die Anwendungsgebiete hÑngen
                dabei ganz allein von Ihnen ab.

                Wenn Sie nicht wissen, was Sie damit machen sollen,
                oder wenn Sie keinen Zeiger angeben wollen,
                Åbergeben Sie einfach NULL.

- redraw        ist eine Function, die bei Bedarf den Fensterinhalt
                neu zeichnet. Diese Funktion wird von SysGem
                automatisch aufgerufen, falls etwas neu zu zeichnen
                ist.

                Es kann auch NULL Åbergeben werden.

- action        an diese Funktion werden Ereignisse gemeldet, die der
                Benutzer 'verbrochen' hat und auf die Sie reagieren
                wollen/kînnen.

                Es kann auch NULL Åbergeben werden.


Die Funktion liefert einen Wert > 0, wenn das Fenster geîffnet werden
konnte. Dieser Wert entspricht dann dem Handle. Bei Werten <= 0 ist
was schiefgegangen.

\end


screen ( sensitive ( "DIALOG_INFO" ),
         sensitive ( "SG_RIGHTCLICK" ),
         sensitive ( "SG_DOUBLECLICK" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef struct
  {
    LONG        id;
    VOID        *user;
    UINT        special;
    \#DRAG_DROP\#   *dd;
  } DIALOG_INFO;


EnthÑlt   mehrere   Parameter,   die   das   Verwalten  von  Dialogen
vereinfachen:

- id        EnthÑlt die Id, die bei WindowDialog angegeben wurde.

- user      EnthÑlt den User-Zeiger aus \#WindowDialog\#.

- special   EnthÑlt bei SG_KEY den Status der Sondertasten, bei
            SG_END kann abgefragt werden, ob ein Doppelklick oder
            die rechte Maustaste benutzt wurde.

            rechte Maustaste = special & SG_RIGHTCLICK;
            Doppelclick      = special & SG_DOUBLECLICK;

- dd        ist nur belegt, wenn SG_DRAGDROP auftrat. NÑheres
            unter \#DRAG_DROP\#.

\end


screen ( sensitive ( "dfunc" ),
         sensitive ( "DPROC" ),
         sensitive ( "SG_START" ),
         sensitive ( "SG_END" ),
         sensitive ( "SG_QUIT" ),
         sensitive ( "SG_POSX" ),
         sensitive ( "SG_POSY" ),
         sensitive ( "SG_VISIBLE" ),
         sensitive ( "SG_INVISIBLE" ),
         sensitive ( "SG_TOP" ),
         sensitive ( "SG_UNTOP" ),
         sensitive ( "SG_KEY" ),
         sensitive ( "SG_MENU" ),
         sensitive ( "SG_NOWIN" ),
         sensitive ( "SG_DRAGDROP" ),
         sensitive ( "SG_CLOSE" ),
         sensitive ( "SG_REDRAW" ),
         sensitive ( "SG_TERM" ),
         sensitive ( "SG_CONT" ),
         sensitive ( "SG_ABORT" ),
         sensitive ( "SG_KEYUSED" ),
         sensitive ( "SG_SLID_UP" ),
         sensitive ( "SG_SLID_DN" ),
         sensitive ( "SG_SLID_MV" ),
         sensitive ( "SG_SLID_PGUP" ),
         sensitive ( "SG_SLID_PGDN" ),
         sensitive ( "SG_KEYCONT" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Die Funktion ist wie folgt definiert:

typedef INT     (*DPROC)(INT msg, INT button, \#DIALOG_INFO\# *inf );


öber diese Funktion steuern Sie verschiede Dinge des \#WindowDialog\#s.

SysGem ruft diese Funktion automatisch auf, wenn es selbst nicht
weiterweis, oder wenn es etwas nachfragen muss.

msg   kann folgende Werte annehmen:

- SG_START             Diese Nachricht besagt, dass nach RÅckkehr
                       der Routine der Dialog gezeichnet wird. Es ist
                       hier also die Zeit und der Platz, eventuelle
                       Voreinstellungen zu tÑtigen, z. B. Editfelder
                       vorzubelegen, Buttons zu selektieren oder
                       Ñhnliches. Redraws dÅrfen noch nicht gemacht
                       werden, da der Dialog noch _nicht_ auf dem
                       Bildschirm ist!

- SG_NOWIN             Diese Meldung besagt, dass kein Fenster mehr
                       zur VerfÅgung steht, um den Dialog
                       darzustellen. Jetzt kommt es auf Sie an: Geben
                       Sie SG_ABORT zurÅck, wird der Fensterdialog
                       abgebrochen. Alle anderen Werte fÅhren dazu,
                       dass der Dialog als ganz 'ordinÑrer' Dialog
                       dargestellt wird; es kann ja schliesslich
                       sein, dass Sie sehr wichtige Dinge vom
                       Benutzer in Erfahrung bringen wollen.

- SG_END               Im Dialog wurde ein Objekt angewÑhlt, welches
                       den EXIT oder TOUCHEXIT Status hat. 'button'
                       enthÑlt dabei die Objektnummer oder -1, wenn
                       der Schliessknopf des Dialogs angeklickt
                       wurde.

                       Die Funktion wird automatisch noch einmal mit
                       SG_QUIT aufgerufen, damit eventueller Speicher
                       von Ihnen wieder freigegeben werden kann.

                       Siehe auch \#action\#

- SG_POSX              Wurde das Fenster geschlossen, enthÑlt
                       'button' die X-Koordinate der letzten Position
                       des Dialogs. Kann beim nÑchsten
                       \#WindowDialog\# als xpos wieder eingesetzt
                       werden.

- SG_POSY              Wurde das Fenster geschlossen, enthÑlt
                       'button' die Y-Koordinate der letzten Position
                       des Dialogs. Kann beim nÑchsten
                       \#WindowDialog\# als ypos wieder eingesetzt
                       werden.

- SG_QUIT              Im Prinzip wie SG_END, allerdings enthÑlt
                       'button' keinen definierten Wert. Das Fenster
                       muss - egal aus welchem Grund - geschlossen
                       werden. Diese Nachricht erhalten Sie z. B.,
                       wenn Ihr Programm terminiert, aber Ihr Dialog
                       noch offen ist. Da Sie in diesem Fall keine
                       Wahl haben, ob Ihr Dialog offen bleiben soll,
                       mÅssen Sie also evtl. vorhanden Speicher, den
                       Sie fÅr den Dialog reserviert haben,
                       freigeben.

                       Vor dieser Meldung wird SG_POSX und ...Y noch
                       aufgerufen.

                       Siehe auch \#action\#

- SG_KEY               öber die Funktion \#TellKeyStrokes\# kînnen
                       Sie festlegen, ob Sie TastendrÅcke erhalten
                       wollen, um z.b. die Cursortasten abzufragen.
                       Der Tastendruck wird Ihnen erst gemeldet, wenn
                       SysGem ihn schon fÅr den Dialog ausgewertet
                       hat.

                       'button' enthÑlt den Scancode der gedrÅckten
                       Taste, special aus \#DIALOG_INFO\# den Status
                       der Sondertasten.

                       Bei einem RÅckgabewert von SG_KEYCONT wird
                       der Tastendruck weitergeleitet.

                       Siehe auch \#action\#

- SG_MENU              Ein Eintrag im FenstermenÅ wurde angewÑhlt.
                       'button' enthÑlt den Index des Eintrages.

                       Siehe auch \#action\#

- SG_UNTOP             Der Fensterdialog wurde in den Hintergrund
                       gelegt.

                       Siehe auch \#action\#

- SG_TOP               Der Fensterdialog wurde zum obersten Fenster
                       ernannt.

                       Siehe auch \#action\#

- SG_INVISIBLE         Der Prozess, zu dem das Fenster gehîrt, wurde
                       ausgeblendet (z.Z. nur Mag!X). Das Fenster ist
                       unsichtbar, bzw. es befindet sich nicht mehr
                       im sichtbaren Bereich des Bildschirms. Diese
                       Meldung wird auch verschickt, wenn das Fenster
                       Iconifiziert wurde.

                       Geben Sie SG_ABORT zurÅck, kînnen Sie das aus-
                       blenden des Fensters verhindern.

                   --> Alle Timer- und Redraw-Aktionen, die dieses
                       Fenster betreffen, sind _sofort_ einzustellen.

                       Siehe auch \#action\#

- SG_VISIBLE           Das GegenstÅck. Der Prozess, bzw. das Fenster
                       wurde wieder eingeblendet.

                       Siehe auch \#action\#

- SG_DRAGDROP          Objekte wurden via Drag & Drop auf das Fenster
                       gezogen. NÑheres siehe unter \#DRAG_DROP\#.

                       Siehe auch \#action\#

- SG_SLID_...          Wird aufgerufen, wenn der Benutzer in einer
                       Sliderbox scrollt. 'msg' enthÑlt dann ja
                       nach Aktion folgende Werte:

                       SG_SLID_UP    - Eine Zeile nach oben
                       SG_SLID_DN    - Eine Zeile nach unten
                       SG_SLID_MV    - Via Slider verschoben
                       SG_SLID_PGUP  - Seite nach oben
                       SG_SLID_PGDN  - Seite nach unten

                       'button' enthÑlt jeweils die Nummer der ersten
                       Zeile, die dann (nach der RÅckkehr) in der
                       Sliderbox zu sehen ist.

                       dialog_info.special enthÑlt die Boxnummer der
                       Sliderbox, so daû - wenn sich mehrere in einem
                       Dialog befinden sollten - bekannt ist, welche
                       denn nun gemeint ist.

Als RÅckgabewerte stehen Ihnen folgende zur VerfÅgung:


- SG_CLOSE             Das Fenster soll geschlossen werden.

- SG_REDRAW            Das Fenster wird neu gezeichnet.

- SG_TERM              Das Programm wird beendet. Ist identisch mit
                       einem Aufruf von \#TerminateSysGem\#.

- SG_CONT              Weitermachen!

- SG_ABORT             Bei Fenstermangel soll die Darstellung des
                       Dialogs abgebrochen werden.

- SG_KEYUSED           Tastendruck wurde von der Funktion
                       ausgewertet. Er braucht nicht mehr
                       weitergeleitet werden.

- SG_KEYCONT           Tastendruck an nÑchste Ebene weiterleiten.

\end



screen ( sensitive ( "DRAG_DROP" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef struct
  {
    BOOL        gemini;
    LONG        data_type;
    UBYTE       *data;
    LONG        data_len;
    UBYTE       data_id  [128];
    UBYTE       filename [128];
    INT         x;
    INT         y;
    INT         state;
    INT         obj;
    LONG        id;
  } DRAG_DROP;


gemini          \#TRUE\#, wenn die Nachricht von Gemini kam, \#FALSE\#, wenn
                von MiNT.

data_type       Typ-Id von MiNT.

data            Zeiger auf die Daten, die Åbertragen wurden.

data_len        LÑnge von data. Nur belegt, wenn die Nachricht von
                MiNT kam, bei Gemini entspricht die LÑnge = strlen (
                data );

data_id         Klassifizierung der Daten von MiNT.

filename        Filename von Irgendwas. Kommt von MiNT.

x, y            Koordinaten der Maus.

state           Status der Sondertasten.

obj             Ist != -1, wenn die Maus Åber einem Objekt im
                Fenster losgelassen wurde.

id              enthÑlt die Id des Baumes, wenn obj != -1.

\end


screen ( sensitive ( "WINDOW_INFO" ),
         sensitive ( "pos_x" ),
         sensitive ( "pos_y" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef struct
  {
    LONG        id;
    LONG        pos_x;
    LONG        pos_y;
    LONG        doc_x;
    LONG        doc_y;
    INT         scroll;
    INT         handle;
    INT         key;
    INT         state;
    INT         mTitle;
    INT         mItem;
    INT         mx, my;
    LONG        line;
    LONG        column;
    BYTE        *line_ptr;
    \#RECT\#        work_area;
    RECT        draw_area;
    RECT        clip;
    VOID        *user;
    LONG        obj_id;
    INT         item;
    \#DRAG_DROP\#   *dd;
  } WINDOW_INFO;


Mittels der Struktur WINDOW_INFO erhalten Sie alle notwendigen
Informationen, um einen Fensterbereich neu zu zeichnen oder auf
Ereignisse von SysGem zu reagieren. Die Parameter haben dabei
folgende Bedeutung:

- handle        ist das handle des Fensters, auf das sich das
                Ereignis bezieht, oder es gibt das Fenster an,
                welches neu zu zeichnen ist.

- id            enthÑlt die Id des Fensters, welches Sie beim
                ôffnen angegeben haben.

                Ist das Handle des Fensters 0 (Desktop), enthÑlt
                die Id immer 'DESK'.

- doc_x
- doc_y         enthalten die Grîsse des Documents.

- pos_x
- pos_y         enthalten die Position der linken oberen Ecke des
                Dokuments, das im Fenster sichtbar ist.

- key           enthÑlt den Scancode der Taste.

- state         enthÑlt den Status der Sondertasten.

- mTitle        enthÑlt den Index des MenÅtitels.

- mItem         enthÑlt den Index des angewÑhlten MenÅeintrags.

- mx
- my            enthÑlt die Position der Maus auf dem Bildschirm.

- line          Die Zeile, in die geklickt wurde oder -1L, wenn sich
                an dieser Stelle keine Textzeile befindet

                Siehe auch: \#SG_LCLICK1\#

- column        Die Spalte, in die geklickt wurde oder -1L, wenn sich
                an dieser Stelle kein Zeichen befindet (z.b. wenn die
                Zeile zu kurz ist)

                Siehe auch: \#SG_LCLICK1\#

- line_ptr      Zeiger auf das [0]-Element des Strings oder NULL.

                Siehe auch: \#SG_LCLICK1\#

- scroll        siehe bei \#redraw\#. Nur dort belegt.

- work_area     enthÑlt die Position und Ausmasse des ***
                Arbeitsbereiches *** des Fensters 'handle'.

- draw_area     enthÑlt die Position und Ausmasse des Arbeitsbereiches
                ohne die eventuell eingelinkten BÑume.

- clip          enthÑlt die Koordinaten eines evtl. gesetzten
                Clip-Rechtecks.

- user          enthÑlt den Zeiger, den Sie beim ôffnen angegeben
                haben.

- obj_id        Bei einem Klick auf einen mit \#LinkTree\#
                gebundenen Baum steht hier die Id des Baumes.

- item          Das Objekt, dass bei 'obj_id' angeklickt wurde.

- dd            Daten fÅr Drag & Drop. Siehe \#DRAG_DROP\#.


\end

screen ( sensitive ( "TellKeyStrokes" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID TellKeyStrokes ( BOOL tell );


öbergeben Sie \#TRUE\#, werden die TastendrÅcke an Ihre Dialogroutinen
(\#dfunc\#) weitergeleitet.

Bei \#FALSE\# unterbleiben sie. Da es eine Menge Rechenzeit kostet, jede
Taste zu melden, sollten Sie sich Åberlegen, ob Sie die Tasten auch
wirklich brauchen.

\end


screen ( sensitive ( "HandleSysGem" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID HandleSysGem ( VOID );


Diese Funktion ist das 'Gehirn' von SysGem und muss wenigstens
einmal aufgerufen werden. Alle Funktionen Ihres Programms werden
von dieser Funktion gesteuert.

Soll Ihr Programm terminieren, so kînnen Sie SysGem mit einem
Aufruf von \#TerminateSysGem\# dazu bewegen.

ErhÑlt SysGem aus irgendeinem Anlass die Meldung, zu terminieren
(MiNT kann ja so eine Meldung verschicken), so kehrt SysGem von
sich aus zurÅck.

Beispiel:

INT main ( VOID )

{
  if ( \#Init_GEM\# ( ... ) > 0 )
    {
      ...
      HandleSysGem ();
      ...
      \#Exit_GEM\# ();
    }
  return ( 0 );
}

\end

screen ( sensitive ( "TerminateSysGem" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID TerminateSysGem ( VOID );


Veranlasst SysGem, die Kontrolle wieder an das Programm abzugeben.

Wurde Ihr Programm als ACC geladen, wird der Aufruf von dieser
Funktion ignoriert, da sich ein ACC ja niemals terminieren kann.

ErhÑlt SysGem als ACC eine SIGQUIT oder SIGTERM Nachricht (siehe
auch \#Signale\#), so ruft SysGem die unter 'acc_close' (\#SetAccProc\#)
angegebene Funktion auf.


\end

screen ( sensitive ( "RedrawArea" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RedrawArea ( INT handle, \#RECT\# *rect );


Setzt eine Nachricht ab, den Bereich 'rect' des Fensters mit der
Kennung 'handle' neuzuzeichnen.

\end

screen ( sensitive ( "SetWindowName" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetWindowName ( INT handle, BYTE *name );


Setzt den Namen des Fensters 'handle'.

\end

screen ( sensitive ( "SetWindowInfo" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetWindowInfo ( INT handle, BYTE *info );


Setzt die Infozeile des Fensters 'handle'.

\end

screen ( sensitive ( "GetHandle" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT GetHandle ( LONG id );


Liefert das handle des Fensters, dass unter der Id 'id' bekannt ist.
Die Funktion liefert -1, wenn es kein Fenster mit dieser Id gibt.

\end

screen ( sensitive ( "GetWindowId" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: LONG GetWindowId ( INT handle );


Liefert die Id des Fensters mit der Kennung 'handle'. Gibt es das
handle nicht, liefert die Funktion 0.

\end

screen ( sensitive ( "TopWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL TopWindow ( INT handle );


Macht das Fenster mit der Kennung 'handle' zum obersten, aktiven
Fenster. Dies geschieht allerdings nur, wenn das Fenster, dass vor
dem Aufruf aktuell war, nicht den 'force'-Status hatte. Hat(te) es
diesen, wird der Aufruf dieser Funktion ignoriert.

\end

screen ( sensitive ( "GetTopWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT GetTopWindow ( VOID );


Liefert das handle des obersten, aktiven Fensters.

\end

screen ( sensitive ( "CloseWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL CloseWindow ( INT handle );


Schickt dem Fenster mit der Kennung 'handle' die Aufforderung, das
Fenster zu schliessen (SG_END, -1), was aber noch lange nicht
bedeutet, dass das Fenster dieser Aufforderung nachkommen muss!

Die Funktion liefert \#TRUE\#, wenn das Fenster wirklich geschlossen wurde,
\#FALSE\# sonst.

\end

screen ( sensitive ( "CloseAllWindows" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID CloseAllWindows ( VOID );


Alle dem Prozess gehîrenden Fenster werden geschlossen. Ohne Wenn und
Aber. Es werden SG_QUIT Nachrichten verschickt.

Diese Funktion wird auch von \#Exit_GEM\# aufgerufen.

\end

screen ( sensitive ( "RectIntersect" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RectIntersect ( \#RECT\# *r1, \#RECT\# *r2 );


PrÅft, ob sich zwei Rechtecke Åberlappen und liefert in 'r2' die
Ausmasse dieses Bereichs.

\end

screen ( sensitive ( "SetDeskTopMenu" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef INT (*APROC)(INT msg, WINDOW_INFO *inf );

Prototyp: BOOL SetDeskTopMenu ( OBJECT *tree, APROC action );


Setzt die MenÅzeile, auf die 'tree' zeigt. Die action-Routine
wird mit \#SG_MENU\# aufgerufen, wenn der Benutzer einen Eintrag ausge-
wÑhlt hat.

\end

screen ( sensitive ( "RemDeskTopMenu" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RemDeskTopMenu ( VOID );


Entfernt die mit \#SetDeskTopMenu\# gesetzte MenÅzeile wieder.
Diese Funktion wird auch von \#Exit_GEM\# aufgerufen.

\end

screen ( sensitive ( "COOKIE" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Die Cookie-Struktur ist wie folgt definiert:

typedef struct
  {
    LONG        id;     /* Identifikation des Cookies  */
    LONG        value;  /* Der Wert des Cookies        */
  } COOKIE;


\end

screen ( sensitive ( "SetCookie" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL SetCookie ( LONG id, LONG value );


Setzt einen Eintrag mit der Id 'id' und dem Wert 'value' in den
Cookie-Jar ein. Existiert die Id bereits, wird nur 'value' geÑndert.

Die Funktion liefert \#TRUE\#, wenn der Cookie eingetragen oder der
Wert geÑndert wurde, \#FALSE\# sonst.

Cookie-Struktur: \#COOKIE\#

\end

screen ( sensitive ( "GetCookie" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL GetCookie ( LONG id, LONG *value );


Sucht, ob der Cookie 'id' vorhanden ist. Wenn ja, liefert die Funktion
\#TRUE\# und in 'value' befindet sich der Wert des Cookies.

--> Bei dieser Funktion ist es auch mîglich, fÅr 'value' NULL zu
    Åbergeben. In diesem Fall wird natÅrlich kein Wert geliefert,
    man kann aber einfach das Vorhandensein eines Cookies abfragen.

    Beispiel:

    if ( GetCookie ( 'MagX', NULL ))
      {
        ...
      }

Cookie-Struktur: \#COOKIE\#

\end

screen ( sensitive ( "RemoveCookie" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RemoveCookie ( LONG id );


Diese Funktion entfernt den Cookie 'id' aus der Liste.


Cookie-Struktur: \#COOKIE\#

\end

screen ( sensitive ( "SetTimer" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetTimer ( INT ms_low, INT ms_high );


Setzt die Zeitspanne, nach der ein Timer-Event ausgelîst werden soll.
Es wird dabei die Routine aufgerufen, die Sie mit \#SetProcTimer\#
angemeldet haben.

\end

screen ( sensitive ( "SetProcTimer" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetProcTimer ( VOID (*proc)(VOID) );


Meldet eine Funktion an, die aufgerufen wird, wenn ein Timerevent
eingetreten ist. Die Zeitspanne kînnen Sie mit \#SetTimer\#
festlegen.

\end

screen ( sensitive ( "SetDeskTop" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef INT (*APROC)(INT msg, \#WINDOW_INFO\# *inf );

Prototyp: BOOL SetDeskTop ( OBJECT *tree, INT first, APROC \#action\# );
                                           \#action\# : APROC ) : integer;


Meldet einen eigenen Desktop an. Dabei zeigt 'tree' auf den Baum, der
als neuer Desktop angemeldet werden soll, 'first' ist das erste
Objekt, ab dem gezeichnet werden soll und action die Funktion,
der BenutzeraktivitÑten gemeldet werden.

Konnte der neue Desktop angemeldet werden, liefert die Funktion \#TRUE\#,
ansonsten \#FALSE\#.

\end

screen ( sensitive ( "RemoveDeskTop" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RemoveDeskTop ( VOID );


Meldet den mittels \#SetDeskTop\# angemeldeten Desktop wieder ab.
Wird automatisch von \#Exit_GEM\# aufgerufen.

\end

screen ( sensitive ( "PopUp" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT PopUp (OBJECT *tree, INT x, INT y, INT start, INT first);


Stellt ein Pop-Up-MenÅ dar. Ein PopUp besteht normalerweise aus einer
Box (Gem: G_BOX) in der sich mehrere andere Objekte (norm. STRING oder
TEXT) befinden.

Diese Box befindet sich im Baum 'tree' und hat die Objektnummer 'start'.

'x' und 'y' geben die Koordinaten an, an der der Popup erscheinen
soll. öbergeben Sie -1, erscheint es an der aktuellen Mausposition.

'first' ist die Objektnummer des Elements, dass beim Erscheinen auf
dem Bildschirm unter der Maus liegen soll. Ist kein solches Element
von Ihnen gewÅnscht, Åbergeben Sie einfach -1.

Die Funktion liefert als Ergebnis die Objektnummer des Elements, dass
vom Benutzer angeklickt wurde oder -1, wenn er kein Element gewÑhlt
hat (also ausserhalb des PopUps geklickt hat).

Es kînnen nur solche Objekte angeklickt werden, die mit dem SELECTABLE
Flag versehen sind.

\end

screen ( sensitive ( "SetAccProc" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef VOID (*TPROC)(VOID);

Prototyp: VOID SetAccProc ( TPROC acc_open, TPROC acc_close );

Wurde Ihr Programm als Accessory gestartet und klickt der Benutzer
den Acc-Eintrag an, wird die unter 'acc_open' angegebene Routine
aufgerufen.

Die Funktion 'acc_close' wird nur dann angesprungen, wenn GEM dazu
den Befehl gibt. In diesem Fall schliesst SysGem alle Fenster des ACC,
bevor die unter 'acc_close' angegebene Funktion aufgerufen wird.

FÅr nicht benîtigte Funktionen kann auch NULL Åbergeben werden.

\end

screen ( sensitive ( "LinkSlider" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL LinkSlider ( OBJECT *tree, INT up, INT dn, INT show,
                            INT hide, INT max, INT box, VOID *buffer,
                            INT len, INT format );


Diese Funktion meldet fÅr die Dialogbox, auf die 'tree' zeigt, eine
Sliderbox an. Die Verwaltung wird komplett von SysGem Åbernommen.

Die einzelnen TexteintrÑge sollen in aufsteigender Reihenfolge vor-
liegen. In Interface z. B. mittels 'Sortieren' machbar.

Die Parameter:

- tree          Zeiger auf die Dialogbox, in der die Sliderbox liegt

- up            Objektnummer des Objektes fÅr Pfeil-hoch. Sollte mit
                TOUCHEXIT versehen werden.

- dn            Objektnummer des Objektes fÅr Pfeil-runter. Sollte
                mit TOUCHEXIT versehen werden.

- show          Objektnummer des Objektes, das den beweglichen
                Slider reprÑsentiert. Sollte mit TOUCHEXIT versehen
                werden.

- hide          Objektnummer des Objektes, in dem der bewegliche
                Slider liegt. Sollte ebenfalls mit TOUCHEXIT
                versehen werden.

- max           Die aktuelle Anzahl der TexteintrÑge der Box. Diese
                Angabe ist _unabhÑngig_ von der Anzahl der wirklich
                sichtbaren EintrÑge. Kînnen in der Sliderbox 10 Zeilen
                Text dargestellt werden, es sind aber nur 2 derzeit
                belegt, so Åbergeben Sie bei 'max' eine 2.

- box           Die Objektnummer der Box, die alle sichtbaren
                TexteintrÑge umgibt.

- buffer        Zeiger auf einen Speicherbereich oder Array, dass die
                darzustellenden EintrÑge enthÑlt.

- len           Die LÑnge einer Bufferzeile in Bytes. Sollte mit
                'sizeof' ermittelt werden!

- format        FÅllt die Zeilen bis 'format' Zeichen mit Leerzeichen
                auf. Wenn Sie dies nicht wÅnschen, Åbergeben Sie
                einfach eine 0.


    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫                       Dialogbox                           ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫                                                           ∫
    ∫    ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒø        ∫
    ∫    ≥ Testzeile 1, die hier ein wenig lÑnger ist≥≥<- 'up' ∫
    ∫    ≥ Testzeile 2, die hier ein wenig lÑnger ist√ƒ¥        ∫
    ∫    ≥ Testzeile 3, die hier ein wenig lÑnger ist≥ ≥        ∫
    ∫    ≥ ^                                        ^≥ ≥<-'hide'∫
    ∫    ≥ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ≥ ≥        ∫
    ∫    ≥                   'len'                   ≥±≥        ∫
    ∫    ≥                                           ≥±≥<-'show'∫
    ∫    ≥                                           ≥±≥        ∫
    ∫    ≥                                           √ƒ¥        ∫
    ∫    ≥                                           ≥≥<-'dn'  ∫
    ∫    ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒŸ        ∫
    ∫       ^                                                   ∫
    ∫ 'box'ƒŸ                                                   ∫
    ∫                                                           ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

\end

screen ( sensitive ( "UnLinkSlider" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL UnLinkSlider ( OBJECT *tree, INT box );


"Entfernt" die Sliderbox, deren 'Box' im Baum 'tree' liegt, aus der
Verwaltung.

\end

screen ( sensitive ( "AddSliderItem" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL AddSliderItem ( OBJECT *tree, INT box, INT anz_items );


VerÑndert die Anzahl der Elemente der Sliderbox 'box' im Baum
'tree'. Zu den maximalen Elementen werden 'anz_items' EintrÑge
addiert. Wollen Sie EintrÑge lîschen, Åbergeben Sie die Anzahl
einfach negativ.

\end

screen ( sensitive ( "RedrawSliderBox" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RedrawSliderBox ( OBJECT *tree, INT box );


Zeichnet die TexteintrÑge in der Sliderbox neu, ohne die Anzahl der
EintrÑge zu verÑndern.

\end

screen ( sensitive ( "SetSliderPos" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT SetSliderPos ( OBJECT *tree, INT box, INT pos, BOOL draw );


Diese Funktion setzt die erste Zeile innerhalb einer Sliderbox.
öbergeben Sie z. B. fÅr 'pos' eine 5, so wÅrde die 5. Zeile des
Buffers als erste Zeile in der Sliderbox erscheinen.

Die Funktion kÅmmert sich automatisch um das Neuzeichnen des Inhaltes,
sofern 'draw' \#TRUE\# ist.

öbergeben Sie fÅr 'pos' einen negativen Wert (-1), dann erhalten Sie
die aktuelle Position zurÅck; ansonsten wird die alte Position zurÅck-
geliefert.

\end

screen ( sensitive ( "Initialisierung" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Die Programminitialisierung von SysGem gestaltet sich sehr einfach.
Verfahren Sie einfach nach folgendem Schema:

…ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
∫ \#Init_GEM\# liefert Wert > 0 ?                                        ∫
«ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫ Ja   ≥ Initialisierung beim GEM war erfolgreich!                   ∫
∫      ≥ \#acc_entry\# ist -2 ?                                          ∫
∫      √ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥ Ja   ≥ Als Programm gestartet!                              ∫
∫      ≥      ≥ Resource laden (\#LoadResource\#) fehlgeschlagen?        ∫
∫      ≥      √ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥      ≥ Ja   ≥ \#Exit_GEM\# aufrufen                             ∫
∫      ≥      ≥      ≥ Programm terminieren                          ∫
∫      ≥      ≥      √ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥      ≥ Nein ≥ Resource-Adressen ermitteln (\#RscAdr\#)          ∫
∫      ≥      ≥      ≥ Dialoge mit \#NewDialog\# anmelden                ∫
∫      ≥      ≥      ≥ Hauptfunktion aufrufen, bzw. Hauptfenster     ∫
∫      ≥      ≥      ≥     îffnen (\#WindowDialog\#)                     ∫
∫      ≥      ≥      ≥ \#HandleSysGem\# aufrufen                         ∫
∫      ≥      ≥      ≥ \#Exit_GEM\# aufrufen                             ∫
∫      ≥      ≥      ≥ Programm terminieren                          ∫
∫      ≥      ∆ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
∫      ≥ Nein ≥ Als Desk-Acc gestartet!                              ∫
∫      ≥      ≥ Resource laden (\#LoadResource\#) fehlgeschlagen?        ∫
∫      ≥      √ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥      ≥ Ja   ≥ In einer Endlosschleife evnt_timer aufrufen   ∫
∫      ≥      ≥      √ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥      ≥ Nein ≥ Resource-Adressen ermitteln                   ∫
∫      ≥      ≥      ≥ Dialoge mit \#NewDialog\# anmelden                ∫
∫      ≥      ≥      ≥ \#SetAccProc\# mit Werten versorgen               ∫
∫      ≥      ≥      ≥ \#HandleSysGem\# aufrufen                         ∫
∫      ∆ÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
∫ Nein ≥ \#Init_GEM\# lieferte -1 ?                                      ∫
∫      √ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
∫      ≥ Ja   ≥ Programm ist schon im Speicher vorhanden             ∫
∫      ≥      ≥ Programm terminieren                                 ∫
∫      ≥      ∆ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
∫      ≥ Nein ≥ Initialisierung fehlgeschlagen                       ∫
∫      ≥      ≥ Programm terminieren                                 ∫
»ÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

\end

screen ( sensitive ( "ScrollWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ScrollWindow ( INT handle, INT what );


Mit dieser Funktion ist es mîglich, das Scrollen von Fensterinhalten
vom Programm aus zu steuern.

Es wird in die durch 'what' beschriebene Richtung jeweils um die Anzahl
von Pixel gescrollt, die als Scrollgrîsse \#scroll_x\#, \#scroll_y\# bei
\#OpenWindow\# angegeben wurde.


- handle        enthÑlt das Handle des Fensters, auf das sich die
                Scroll-Operation beziehen soll

- what          SCROLL_UP       Scrollt um \#scroll_y\# Pixel nach oben
                SCROLL_DOWN     Scrollt um \#scroll_y\# Pixel nach unten
                SCROLL_LEFT     Scrollt um \#scroll_x\# Pixel nach links
                SCROLL_RIGHT    Scrollt um \#scroll_x\# Pixel nach rechts
                SCROLL_PG_LEFT  Eine Seite nach links
                SCROLL_PG_RIGHT Eine Seite nach rechts
                SCROLL_PG_UP    Eine Seite nach oben
                SCROLL_PG_DOWN  Eine Seite nach unten

\end

screen ( sensitive ( "SetWindowParm" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: LONG SetWindowParm ( INT handle, INT what, LONG value );


öber diese Funktion kînnen Dokumentgrîsse und Position des Ausschnitts
von einem Fenster abgefragt sowie gesetzt werden.

- handle        Das Handle des Fensters

- what          SET_X   Setzt die x-Position (\#pos_x\#) des sichtbaren
                        Dokumentsausschnitt. 'value' enthÑlt den
                        neuen Wert.

                        Wird fÅr 'value' -1L Åbergeben, liefert die
                        Funktion die aktuelle x-Position zurÅck.

                SET_Y   Setzt die y-Position (\#pos_y\#) des sichtbaren
                        Dokumentsausschnitt. 'value' enthÑlt den
                        neuen Wert.

                        Wird fÅr 'value' -1L Åbergeben, liefert die
                        Funktion die aktuelle y-Position zurÅck.

                SET_W   Setzt die Documentbreite (\#doc_x\#) des
                        Dokuments. 'value' enthÑlt den neuen Wert.

                        Wird fÅr 'value' -1L Åbergeben, liefert die
                        Funktion die aktuelle Dokumentbreite zurÅck.

                SET_H   Setzt die Documenthîhe (\#doc_y\#) des
                        Dokuments. 'value' enthÑlt den neuen Wert.

                        Wird fÅr 'value' -1L Åbergeben, liefert die
                        Funktion die aktuelle Dokumenthîhe zurÅck.

\end

screen ( sensitive ( "SetEditField" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetEditField ( OBJECT *tree, INT field );


Diese Funktion setzt den Text-Cursor in das Editfeld mit der Objekt-
nummer 'field' im Baum 'tree'.

\end

screen ( sensitive ( "ScrollSlider" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ScrollSlider ( OBJECT *tree, INT box, INT what );


Mit dieser Funktion ist es mîglich, in den Sliderboxen Programm-
gesteuert zu scrollen.

Die Sliderbox befindet sich im Baum 'tree' und die Textbox hat die
Objektnummer 'box'.

FÅr 'what' sind folgende Kommandos mîglich:

- SCROLL_UP     Die EintrÑge der Sliderbox scrollen um einen Eintrag
                nach oben.

- SCROLL_DOWN   Die EintrÑge der Sliderbox scrollen um einen Eintrag
                nach unten.


\end
screen ( sensitive ( "SetMessageProc" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

typedef   LONG (*MPROC)(UBYTE msg, UBYTE sub, LONG from, LONG parm );

Prototyp: VOID SetMessageProc ( MPROC proc );


Setzt die Funktion, die bei einem Eintreffen einer SysGem Nachricht
aufgerufen wird.

\end
screen ( sensitive ( "SendSgMsg" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SendSgMsg ( INT msg, INT sub, LONG dest, LONG parm );


Diese Funktion schickt eine Nachricht an ein anderes Programm.

dest    Id des Programms, an das die Nachricht gerichtet ist

parm    Parameter; abhÑngig von der Nachricht

msg     kann folgende Werte annehmen:

        MSG_TERM        Programm soll terminieren

        MSG_OPEN        Fenster îffnen. Die Id des Fensters steht
                        in 'parm'.

        MSG_CLOSE       Fenster schliessen. Die Id des Fensters
                        steht in 'parm'.

        MSG_USER        Frei verfÅgbar.

        MSG_SYSTEM      Kommunikation mit SysInfo. 'sub' kann dabei
                        folgende Werte annehmen:

                4       Ausgabe auf das Clipboard.

                5       Laufwerk îffnen. Das Laufwerk steht dabei
                        im unteren Byte von 'parm'. (A=0, B=1,...)

                SysInfo schickt daraufhin als Ergebnis die Msg wieder
                zurÅck; sub = 0 --> Fehler
                        sub = 1 --> Alles klar.

        MSG_NEW         Ein neues Programm hat sich angemeldet.
                        Die Id des Programms steht in 'from'.

        MSG_QUIT        Ein Programm hat sich verabschiedet.
                        Die Id des Programms steht in 'from'.

----------------------------------------------------------------------
SysInfo benutzt dabei die Msg 0x7777. Dabei steht die Nachricht im
unteren Wort von msg [3], die 'sub' meldung im oberen Wort. Die Ab-
sender-Id in 4 und 5, der Parameter in 6 und 7 jeweils high-low Wort.


\end
screen ( sensitive ( "SendMsg" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT SendMsg ( LONG dest, INT msg, INT sub, LONG parm,
                        INT timeout, LONG *result );


Exakt wie \#SendSgMsg\#, nur mit dem Unterschied, daû bis zu 'timeout'
Sekunden auf eine Antwort gewartet wird. Ein evtl. RÅckgabeparameter
wird dann in 'result' zurÅckgeliefert. result kann auch NULL sein.

Die Funktion liefert folgende RÅckgaben:

-2    Timeout
-1    Programm, an das die Nachricht ist, existiert nicht
 0    Fehler
 1    Alles klar

\end

screen ( sensitive ( "ProgramExist" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT ProgramExist ( LONG prg_id );


PrÅft, ob sich das Programm mit der Kennung 'prg_id' im Speicher
befindet. Die Funktion liefert die AES-Id, wenn das Programm gefunden
wurde, -1 sonst.

\end

screen ( sensitive ( "SelectMenu" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SelectMenu ( INT item, BOOL invert );


Diese Funktion sucht den MenÅtitel, in dem das Item 'item' sich be-
findet. Ist 'invert' \#TRUE\#, wird der entsprechende MenÅtitel invers
dargestellt, ansonsten deselektiert.

\end

screen ( sensitive ( "UseRightButton" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID UseRightButton ( BOOL use );


FÅr manche Anwendungen kann es sinnvoll sein, bestimmte Dinge auch
mit der rechten Maustaste anwÑhlen zu kînnen. So sind z. B. zwei
verschiedene Funktionen fÅr einen Button mîglich.

Normalerweise wird die Benutzung der rechten Maustaste in Dialogen
von SysGem unterbunden (Voreinstellung).

öbergeben Sie der Funktion \#TRUE\#, reagiert SysGem auch auf die rechte
Maustaste in Dialogen. Buttons usw. lassen sich dann also mit beiden
Tasten steuern.

\end

screen ( sensitive ( "DelDialog" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL DelDialog ( OBJECT *tree );


Diese Funktion entfernt den vorher mit \#NewDialog\# angemeldeten
Dialog wieder aus der Verwaltung und liefert \#TRUE\#, wenn es geklappt
hat, \#FALSE\# sonst.

\end

screen ( sensitive ( "UseHighButtons" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID UseHighButtons ( BOOL use_high );


Auf mehrfachen Wunsch wurde diese Funktion implementiert. Sie erhîht
die Hîhe der Alertbuttons um ein halbes Zeichen.

StandardmÑssig sind die Buttons ein Zeichen hoch.

\end

screen ( sensitive ( "LinkTree" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL LinkTree ( LONG win_id, OBJECT *tree, LONG id, INT pos );


Bindet einen Baum an ein mit \#OpenWindow\# geoeffnetes Fenster.

win_id          Id des Fensters, an das der Baum gebunden werden
                soll.

tree            Zeiger auf den Baum.

id              Id, die der Baum erhalten soll. Wird bei \#SG_BUTTON\#
                wieder geliefert.

pos             Legt fest, wo der Baum im Fenster erscheinen soll:

                - LINK_LEFT
                - LINK_RIGHT
                - LINK_TOP
                - LINK_BOTTOM

                SysGem kÅmmert sich automatisch um das Neuzeichnen
                und die Grîûenanpassung an das Fenster. Die minimale
                Grîûe des Fensters sollte mit \#SetWinMinSize\#
                festgelegt werden.

\end

screen ( sensitive ( "IsMenuKey" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT IsMenuKey ( OBJECT *tree, INT scan, INT state );


Diese Funktion prueft, ob der Tastendruck auf einen Menue-Shortcut
passt. Es werden nur die Control- und Alternate Tasten unterstuetzt.

Als Zeichen fuer Control wird '^' (dez: 94), fuer
Alternate '' (dez: 7) erwartet.

- tree     Zeiger auf die Menuezeile, die 'untersucht' werden soll
- scan     Der Scancode der Taste
- state    Der Status der Sondertasten

Die Funktion liefert den Index des Menueeintrags, wenn ein solcher
gefunden wurde oder -1, wenn kein Menueeintrag passt.

\end

screen ( sensitive ( "RedrawDialog" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RedrawDialog ( OBJECT *tree );


Diese Funktion zeichnet den Dialog 'tree' neu. Dieser muss sich
allerdings schon auf dem Bildschirm befinden.

Diese Funktion muss aufgerufen werden, wenn ein Dialog neu gezeichnet
werden soll. ShowDialog sichert beim Aufruf z. B. den Dialog-
hintergrund, weshalb die Funktion nur einmal aufgerufen werden sollte.

RedrawDialog kann beliebig oft aufgerufen werden.

\end

screen ( sensitive ( "RedrawWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID RedrawWindow ( INT handle );


Diese Funktion zeichnet den Inhalt des Fensters mit dem Handle 'handle'
neu.

\end

screen ( sensitive ( "SetAlertTitle" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetAlertTitle ( BYTE *string );


Setzt den Fenstertitel des Alerts. Hier kann ein max. 20-Zeichen langer
String Åbergeben werden, der anstatt von "Alert" erscheint. Soll die
Programm-Id nicht erscheinen, setzen Sie einfach als erstes Zeichen
ein '|' vor den Namen.

\end

screen ( sensitive ( "LinkList" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BYTE *LinkList ( LONG win_id, BYTE *text );


"HÑngt" eine Textliste in ein Fenster ein. Die Lib kÅmmert sich dann
selbststÑndig um die Anpassung des Dokumentbereichs und um das Scrollen
an sich.

Dabei wird 'text' in eine interne Liste kopiert. Die Funktion liefert
einen Zeiger auf das [0] Element des Textes zurÅck. Der Text selbst
beginnt allerdings erst bei [1]. [0] ist fÅr die Angabe von Stati
reserviert. Ist das Byte >= 0, interpretiert SysGem den Wert als An-
gabe fÅr vst_effects und stellt die Zeile auch wie angegeben dar. Ist
der Wert < 0, ignoriert SysGem den Wert und nimmt als Effekt 0 an.

Auf diese Weise kînnen Sie ganz einfach auch eigene Stati verwalten.

Die Funktion liefert NULL, wenn die Liste nicht angelegt oder der
Text nicht Åbernommen werden konnte.


Siehe auch: \#AddToList\# \#ChgInList\# \#DelInList\# \#do_qsort\#

\end

screen ( sensitive ( "AddToList" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BYTE *AddToList ( LONG win_id, BYTE *text );


HÑngt 'text' als neue Zeile an die Liste an. RÅckgabe ist wie bei
\#LinkList\# beschrieben.

Die Funktion passt den Dokumentbereich des Fensters automatisch an.
Hat die lÑngste Zeile im Text eine LÑnge von 60 Zeichen und linken
Sie eine Zeile mit 200 Zeichen dazu, werden die Scrollbalken automatisch
angepasst.


Siehe auch: \#LinkList\# \#ChgInList\# \#DelInList\# \#do_qsort\#

\end

screen ( sensitive ( "ChgInList" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BYTE *ChgInList ( LONG win_id, UINT line, BYTE *text );


Ersetzt den Text in Zeile 'line' durch 'text' im Fenster 'win_id'.

Ist 'text' == NULL, liefert die Funktion den Zeiger auf das
[0] Element des bereits bestehenden Textes oder NULL, wenn es die
Zeile nicht gibt.

Wurde der Text Åbernommen, liefert die Funktion die neue Adresse
des Strings.


Siehe auch: \#LinkList\# \#AddToList\# \#DelInList\# \#do_qsort\#

\end

screen ( sensitive ( "OpenLogWindow" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL OpenLogWindow ( LONG win_id, BYTE *title, BYTE *info,
                  INT columns, INT rows, INT x, INT y, APROC \#action\# );


ôffnet ein Fenster, in das mit \#wprintf\# geschrieben werden kann.

Parameter:

- win_id     Id des Fensters. Siehe auch \#OpenWindow\#.

- title      Der Fenstertitel. Siehe auch \#OpenWindow\#.

- info       Der Text fÅr die Infozeile. Ist keine gewÅnscht, Åber-
             geben Sie einfach einen Leerstring ("").

- columns    Anzahl der Spalten, die dargestellt werden sollen.
             Der Wert muû >= 3 sein.

- rows       Anzahl der Zeilen, die dargestellt werden sollen.
             Der Wert muû >= 3 sein.

- x, y       Koordinaten der linken oberen Ecke, an der das Fenster
             erscheinen soll.

- action     Die \#action\# Funktion.


Die Funktion liefert \#TRUE\#, wenn das Fenster geîffnet wurde.

\end

screen ( sensitive ( "wprintf" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID wprintf ( LONG win_id, BYTE *format, ... );


Schreibt in das (mit \#OpenLogWindow\# geîffnete) Fenster mit der
id 'Id' den angegeben String. Der Format-String ist identisch
mit dem bei printf. Es gibt aber noch folgende ESC-Sequenzen, die
wprintf interpretiert:

 ESC p  - Fett ein
 ESC q  - Fett aus
 ESC +  - Unterstreichen ein
 ESC -  - Unterstreichen aus
 ESC (  - Kursiv ein
 ESC )  - Kursiv aus
 ESC e  - Cursor an
 ESC f  - Cursor aus
 ESC E  - ClearScreen; Cursor auf Ursprung (x = 0, y = 0)


\end

screen ( sensitive ( "wcls" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID wcls ( LONG win_id );


Lîscht das Fenster und setzt den Cursor auf 0, 0.

\end

screen ( sensitive ( "wposxy" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID wposxy ( LONG win_id, INT x, INT y );


Setzt den Cursor auf die Position x, y.

\end

screen ( sensitive ( "wgetxy" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID wgetxy ( LONG win_id, INT *x, INT *y );


Liefert die Position des Cursors (Ursprung: 0, 0)

\end

screen ( sensitive ( "wgetchar" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BYTE wgetchar ( LONG win_id, INT x, INT y, INT *effect );
                       var effect : integer ) : char;

Liefert das Zeichen, daû sich an Position x, y befindet. Ist 'effect'
!= NULL, wird hier der Wert der Stati zurÅckgegeben. Dieser Wert ist
bitcodiert und identisch wie bei vst_effects.


\end

screen ( sensitive ( "HideCursor" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID HideCursor ( LONG win_id );


Schaltet den Textcursor in diesem Fenster aus.


Siehe auch: \#OpenLogWindow\# \#wprintf\#

\end

screen ( sensitive ( "ShowCursor" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ShowCursor ( LONG win_id );


Schaltet den Textcursor in diesem Fenster ein.


Siehe auch: \#OpenLogWindow\# \#wprintf\#

\end

screen ( sensitive ( "IsVisible" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL IsVisible ( INT handle );


Liefert \#TRUE\#, wenn der Arbeitsbereich des angegebenen Fensters voll-
stÑndig sichtbar ist. \#FALSE\# sonst.

\end

screen ( sensitive ( "SetWinMinSize" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetWinMinSize ( LONG win_id, INT w, INT h );


setzt die Minimale Grîûe des Fensters. Hilfreich, wenn BÑume drin sind.


Siehe auch: \#LinkTree\#

\end
screen ( sensitive ( "SetWinMaxSize" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID SetWinMaxSize ( LONG win_id, INT w, INT h );


setzt die Maximale Grîûe des Fensters. Hilfreich, wenn BÑume drin sind.


Siehe auch: \#LinkTree\#

\end

screen ( sensitive ( "ChangeButton" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: VOID ChangeButton ( OBJECT *tree, INT obj, BYTE *text, BOOL draw );


éndert einen Buttontext nach 'text' und zeichnet diesen - falls 'draw'
\#TRUE\# ist - gleichzeitig neu.

Beispiel:
=========

ChangeButton ( rsc_dialog, OK, "[Suchen", \#TRUE\# );

Ñndert den Text des Buttons OK in "Suchen" und zeichnet diesen
gleichzeitig wieder neu.

\end

screen ( sensitive ( "Display" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: UINT Display ( BYTE *fname, BYTE *wname, BYTE *winfo,
                         INT len, LONG win_id, INT x, INT y, INT w,
                         INT h, APROC \#action\# );


LÑdt eine Datei und stellt diese in einem Fenster dar. Die Lib kÅmmert
sich selbststÑndig um das Scrollen und um eventuelle Redraws.

Parameter:

- fname     Name und Pfad der TEXT-Datei, die geladen werden soll.

- wname     Der Name des Fensters

- winfo     Die Infozeile. Wenn nicht gewÅnscht, einfach einen Leer-
            string ("") Åbergeben.

- len       gibt an, wie lang eine Zeile maximal sein darf

- win_id    Die Id des Fensters

- x, y,
  w, h      Die Koordinate, wo und wie das Fenster erscheinen soll

- action    Die \#action\# Funktion.


Die Funktion liefert die Anzahl der eingelesenen Zeilen oder 0 im
Fehlerfall.

Siehe auch: \#LinkList\# \#AddToList\#

\end

screen ( sensitive ( "DelInList" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: BOOL DelInList ( LONG win_id, UINT line );


Lîscht die Zeile 'line' aus der Textliste und liefert \#TRUE\#, wenn
sie entfernt wurde.

Die Funktion passt den Dokumentbereich des Fensters automatisch an.
Hat die lÑngste Zeile im Text eine LÑnge von 200 Zeichen und lîschen
Sie diese Zeile und ist dann die lÑngste Zeile 60 Zeichen lang, werden
die Scrollbalken automatisch angepasst und das Fenster redrawed.

Siehe auch: \#LinkList\# \#AddToList\# \#do_qsort\#

\end

screen ( sensitive ( "CountLines" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: UINT CountLines ( LONG win_id );


Liefert die Anzahl der Textzeilen im Fenster 'win_id'.


Siehe auch: \#LinkList\# \#AddToList\# \#DelInList\# \#do_qsort\#

\end
screen ( sensitive ( "do_qsort" ),
         sensitive ( "cmp_strings_up" ),
         sensitive ( "cmp_strings_dn" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: typedef INT  (*CPROC)(BYTE *str1, BYTE *str2 );

          VOID do_qsort ( LONG win_id, CPROC compare );


Sortiert die Zeilen im Fenster 'win_id'. SysGem bietet fÅr 'compare'
schon zwei vordefinierte Funktionen:

cmp_strings_up   - Sortiert die Zeilen in Aufsteigender Reihenfolge
cmp_strings_dn   - Sortiert die Zeilen in Absteigender Reihenfolge

Eigene Funktionen kînnen leicht angegeben werden. Die Funktion erhÑlt
2 Zeiger auf die Strings - auf Element [1].

Wird fÅr 'compare' NULL Åbergeben, nimmt SysGem die Funktion
cmp_strings_up.

Die Funktion muû die Werte wie bei   qsort   beschrieben zurÅckliefern.



Siehe auch: \#LinkList\# \#AddToList\# \#DelInList\#

\end
screen ( sensitive ( "Cycle" ))
\#SysGem\# V1.20                                              \#Gesamt-Index\#
----------------------------------------------------------------------

Prototyp: INT Cycle ( OBJECT *tree, INT obj, OBJECT *pop_tree, INT first,
                    INT last, INT *ret );


Diese Funktion realisiert Circle-Buttons, d.h., die Funktion "scrollt"
alle EintrÑge durch. Baut auf \#PopUp\# auf. "Scrollt" die EintrÑge
eines PopUp's durch, und uebernimmt nach Abschluss den Text des neuen
Objekts und schreibt ihn dann wieder in 'obj'. So kann man sich eine
Menge Arbeit sparen.

Die Parameter:

- tree       Zeiger auf den dialog, in dem der Button liegt, der
             das Popup ausloest, bzw. in dem der Text des Circle-Buttons
             liegt.

- obj        Die Objektnummer dieses Textes.

- pop_tree   Zeiger auf den Baum fuer das Popup.

- first      Objektnummer des ersten Textes

- last       Objektnummer des letzten Textes

- ret        EnthÑlt die Position (Objektnummer) des Textes, der danach
             im Textfeld stehen soll. Beim Aufruf wird 'ret' incrementiert
             und der Text ausgelesen; anschlieûend in tree [obj] wieder
             geschrieben und redrawed. ret enthÑlt dann die Objektnummer
             des Textes, der gerade dargestellt wird.

Die Funktion liefert 'ret' zurÅck.


Siehe auch: \#xPopUp\#

\end

