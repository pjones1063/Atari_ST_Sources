diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/all_widg.c /h/xaaes/all_widg.c
--- /i/newitems/XaAES.beta2/src/all_widg.c	Sun Feb 18 14:41:50 1996
+++ /h/xaaes/all_widg.c	Wed Feb 21 13:43:56 1996
@@ -14,7 +14,7 @@
 
 #if MONO_WIDGETS
 
-// Mario Becroft's mono widget set
+/* Mario Becroft's mono widget set */
 
 unsigned short widget_bitmap_close[DATASIZE] =
 { 0xFFFF, 0x8001, 0x8003, 0x8003, 
@@ -214,7 +214,7 @@
 
 #else
 
-// Close widget (normal)
+/* Close widget (normal)*/
 unsigned short widget_bitmap_close[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5FFA, 
   0x500A, 0x57EA, 0x57EA, 0x57EA, 
@@ -235,7 +235,7 @@
 };
 
 
-// Close widget (selected)
+/* Close widget (selected)*/
 unsigned short widget_bitmap_close_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5FFA, 
   0x5FFA, 0x5FFA, 0x5FFA, 0x5FFA, 
@@ -255,7 +255,7 @@
   0x2001, 0x0001, 0x0001, 0xFFFF
 };
 
-// Sizer widget (normal)
+/* Sizer widget (normal)*/
 unsigned short widget_bitmap_size[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x4002, 
   0x4FF2, 0x4872, 0x48F2, 0x4852, 
@@ -275,7 +275,7 @@
   0x3FF9, 0x0001, 0x0001, 0xFFFF
 };
 
-// Sizer widget (selected)
+/* Sizer widget (selected)*/
 unsigned short widget_bitmap_size_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5FFA, 
   0x581A, 0x500A, 0x500A, 0x500A, 
@@ -295,7 +295,7 @@
   0x2001, 0x2001, 0x0001, 0xFFFF
 };
 
-// Fuller widget (normal)
+/* Fuller widget (normal)*/
 unsigned short widget_bitmap_full[DATASIZE] =
 { 0x0000, 0x0000, 0x03C0, 0x1BD8, 
   0x1DB8, 0x0E70, 0x37EC, 0x3BDC, 
@@ -315,7 +315,7 @@
   0x4405, 0x7C3D, 0x0001, 0xFFFF
 };
 
-// Fuller widget (selected)
+/* Fuller widget (selected)*/
 unsigned short widget_bitmap_full_s[DATASIZE] =
 { 0x0000, 0x0000, 0x03C0, 0x1BD8, 
   0x1DB8, 0x0E70, 0x37EC, 0x3BDC, 
@@ -335,7 +335,7 @@
   0x6001, 0x4001, 0x0001, 0xFFFF
 };
 
-// Left Scroll widget (normal)
+/* Left Scroll widget (normal)*/
 unsigned short widget_bitmap_left[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5D7A, 0x5B02, 0x57F2, 0x4FF2, 
@@ -355,7 +355,7 @@
   0x2181, 0x0001, 0x0001, 0xFFFF
 };
 
-// Left Scroll widget (selected)
+/* Left Scroll widget (selected)*/
 unsigned short widget_bitmap_left_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5C7A, 0x5802, 0x5002, 0x4002, 
@@ -375,7 +375,7 @@
   0x2101, 0x0001, 0x0001, 0xFFFF
 };
 
-// Right Scroll widget (normal)
+/* Right Scroll widget (normal)*/
 unsigned short widget_bitmap_right[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5EBA, 0x40DA, 0x4FEA, 0x4FF2, 
@@ -395,7 +395,7 @@
   0x2081, 0x0001, 0x0001, 0xFFFF
 };
 
-// Right Scroll widget (selected)
+/* Right Scroll widget (selected)*/
 unsigned short widget_bitmap_right_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5E3A, 0x401A, 0x400A, 0x4002, 
@@ -415,7 +415,7 @@
   0x2101, 0x0001, 0x0001, 0xFFFF
 };
 
-// Scroll Up widget (normal)
+/* Scroll Up widget (normal)*/
 unsigned short widget_bitmap_up[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5DBA, 0x5BDA, 0x57EA, 0x4FF2, 
@@ -435,7 +435,7 @@
   0x27E1, 0x0001, 0x0001, 0xFFFF
 };
 
-// Scroll Up widget (selected)
+/* Scroll Up widget (selected)*/
 unsigned short widget_bitmap_up_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x5E7A, 
   0x5C3A, 0x581A, 0x500A, 0x4002, 
@@ -455,7 +455,7 @@
   0x2401, 0x0001, 0x0001, 0xFFFF
 };
 
-// Scroll Down widget (normal)
+/* Scroll Down widget (normal)*/
 unsigned short widget_bitmap_down[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x581A, 
   0x5BDA, 0x5BDA, 0x5BDA, 0x43C2, 
@@ -475,7 +475,7 @@
   0x2181, 0x0001, 0x0001, 0xFFFF
 };
 
-// Scroll Down widget (selected)
+/* Scroll Down widget (selected)*/
 unsigned short widget_bitmap_down_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x581A, 
   0x581A, 0x581A, 0x581A, 0x4002, 
@@ -495,7 +495,7 @@
   0x2001, 0x0001, 0x0001, 0xFFFF
 };
 
-// Iconify widget (normal)
+/* Iconify widget (normal)*/
 unsigned short widget_bitmap_iconify[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x400A, 
   0x4FEA, 0x4FEA, 0x4FEA, 0x4FEA, 
@@ -515,7 +515,7 @@
   0x20F9, 0x0001, 0x0001, 0xFFFF
 };
 
-// Iconify widget (selected)
+/* Iconify widget (selected)*/
 unsigned short widget_bitmap_iconify_s[DATASIZE] =
 { 0x0000, 0x7FFE, 0x4002, 0x400A, 
   0x4FEA, 0x4FEA, 0x4FEA, 0x4FEA, 
@@ -535,7 +535,7 @@
   0x2001, 0x0001, 0x0001, 0xFFFF
 };
 
-// Horizontal slider (normal)
+/* Horizontal slider (normal)*/
 unsigned short widget_bitmap_hslide[DATASIZE] =
 { 0x0000, 0xEFF7, 0xD81B, 0xB7ED, 
   0x6C36, 0x5BDA, 0x57EA, 0x57EA, 
@@ -555,7 +555,7 @@
   0x4002, 0x2004, 0x1008, 0xFFFF
 };
 
-// Horizontal slider left edge (normal)
+/* Horizontal slider left edge (normal)*/
 unsigned short widget_bitmap_hslide_left[DATASIZE] =
 { 0xF000, 0xEFFF, 0xD81F, 0xB7EF, 
   0x6C37, 0x5BDB, 0x57EB, 0x57EB, 
@@ -575,7 +575,7 @@
   0x4000, 0x2000, 0x1000, 0x0FFF
 };
 
-// Horizontal slider right edge (normal)
+/* Horizontal slider right edge (normal)*/
 unsigned short widget_bitmap_hslide_right[DATASIZE] =
 { 0x000F, 0xFFF7, 0xF81B, 0xF7ED, 
   0xEC36, 0xDBDA, 0xD7EA, 0xD7EA, 
@@ -595,7 +595,7 @@
   0x0002, 0x0004, 0x0008, 0xFFF0
 };
 
-// Horizontal Slider widget (selected)
+/* Horizontal Slider widget (selected)*/
 unsigned short widget_bitmap_hslide_s[DATASIZE] =
 { 0x0000, 0xEFF7, 0xD81B, 0xB7ED, 
   0x6FF6, 0x599A, 0x53CA, 0x4002, 
@@ -615,7 +615,7 @@
   0x4002, 0x2004, 0x1008, 0xFFFF
 };
 
-// Horizontal slider left edge (selected)
+/* Horizontal slider left edge (selected)*/
 unsigned short widget_bitmap_hslide_left_s[DATASIZE] =
 { 0xF000, 0xEFFF, 0xD81F, 0xB7EF, 
   0x6FF7, 0x5CFB, 0x59FB, 0x500B, 
@@ -635,7 +635,7 @@
   0x4000, 0x2000, 0x1000, 0x0FFF
 };
 
-// Horizontal slider right edge (selected)
+/* Horizontal slider right edge (selected)*/
 unsigned short widget_bitmap_hslide_right_s[DATASIZE] =
 { 0x000F, 0xFFF7, 0xF81B, 0xF7ED, 
   0xEFF6, 0xDF3A, 0xDF9A, 0xD00A, 
@@ -655,7 +655,7 @@
   0x0002, 0x0004, 0x0008, 0xFFF0
 };
 
-// Vertical slider (normal)
+/* Vertical slider (normal)*/
 unsigned short widget_bitmap_vslide[DATASIZE] =
 { 0x700E, 0x6FF6, 0x581A, 0x37EC, 
   0x6C36, 0x5BDA, 0x57EA, 0x57EA, 
@@ -675,7 +675,7 @@
   0x4003, 0x2005, 0x1009, 0x0FF1
 };
 
-// Vertical Slider bottom edge (normal)
+/* Vertical Slider bottom edge (normal)*/
 unsigned short widget_bitmap_vslide_down[DATASIZE] =
 { 0x7FFE, 0x7FFE, 0x781E, 0x77EE, 
   0x6C36, 0x5BDA, 0x57EA, 0x57EA, 
@@ -695,7 +695,7 @@
   0x4002, 0x2004, 0x1008, 0x0FF0
 };
 
-// Vertical Slider top edge (normal)
+/* Vertical Slider top edge (normal)*/
 unsigned short widget_bitmap_vslide_up[DATASIZE] =
 { 0xF00F, 0xEFF7, 0xD81B, 0xB7ED, 
   0x6C36, 0x5BDA, 0x57EA, 0x57EA, 
@@ -715,7 +715,7 @@
   0x0001, 0x0001, 0x0001, 0x0001
 };
 
-// Vertical Slider widget (selected)
+/* Vertical Slider widget (selected)*/
 unsigned short widget_bitmap_vslide_s[DATASIZE] =
 { 0x700E, 0x6FF6, 0x581A, 0x366C, 
   0x6C36, 0x581A, 0x5A5A, 0x5E7A, 
@@ -735,7 +735,7 @@
   0x4003, 0x2005, 0x1009, 0x0FF1
 };
 
-// Vertical Slider bottom edge (selected)
+/* Vertical Slider bottom edge (selected)*/
 unsigned short widget_bitmap_vslide_down_s[DATASIZE] =
 { 0x7FFE, 0x7FFE, 0x781E, 0x77EE, 
   0x6E76, 0x5E7A, 0x5E7A, 0x5E7A, 
@@ -755,7 +755,7 @@
   0x4002, 0x2004, 0x1008, 0x0FF0
 };
 
-// Vertical Slider top edge (selected)
+/* Vertical Slider top edge (selected)*/
 unsigned short widget_bitmap_vslide_up_s[DATASIZE] =
 { 0xF00F, 0xEFF7, 0xD81B, 0xB7ED, 
   0x6E76, 0x5C3A, 0x581A, 0x5A5A, 
@@ -775,8 +775,8 @@
   0x0001, 0x0001, 0x0001, 0x0001
 };
 
-//======================================
-// XaAES Logo (16*16, Normal)
+/*======================================*/
+/* XaAES Logo (16*16, Normal)*/
 unsigned short bitmap_xaaes16[DATASIZE] =
 { 0xFFFF, 0xFFFF, 0xCFFB, 0xC7F3, 
   0xC3E3, 0xE1C3, 0xF087, 0xFAAF, 
@@ -796,7 +796,7 @@
   0x2142, 0x4222, 0x7C1E, 0x0000
 };
 
-// XaAES Logo (16*16, Selected)
+/* XaAES Logo (16*16, Selected)*/
 unsigned short bitmap_xaaes16_s[DATASIZE] =
 { 0xFFFF, 0xFFFF, 0xCFFB, 0xC7F3, 
   0xC3E3, 0xE1C3, 0xF1C7, 0xF96F, 
@@ -815,4 +815,4 @@
   0x0010, 0x0400, 0x0E7C, 0x1F7E, 
   0x3F3E, 0x7E3E, 0x7C1E, 0x0000
 };
-#endif
\ No newline at end of file
+#endif
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/app_man.c /h/xaaes/app_man.c
--- /i/newitems/XaAES.beta2/src/app_man.c	Mon Feb 19 14:02:12 1996
+++ /h/xaaes/app_man.c	Wed Feb 21 21:31:52 1996
@@ -9,12 +9,13 @@
 #include <FILESYS.H>
 #include <MINTBIND.H>
 #include <SIGNAL.H>
-#include "XA_DEFS.H"
 #include "XA_TYPES.H"
+#include "XA_DEFS.H"
 #include "XA_GLOBL.H"
 #include "K_DEFS.H"
 #include "XA_CODES.H"
 #include "NEW_CLNT.H"
+#include "c_window.h"
 
 /*
 	Application Manager
@@ -36,9 +37,9 @@
 	
 	for(app=0; app<MAX_PID; app++)
 	{
-		if ((app!=AESpid)&&(clients[app].clnt_pipe_rd))		// Is this a valid application?
+		if ((app!=AESpid)&&(clients[app].clnt_pipe_rd))		/* Is this a valid application?*/
 		{
-			r=Pkill(app,SIGNULL);	// poll to see if the client has died since we last looked....
+			r=Pkill(app,SIGNULL);	/* poll to see if the client has died since we last looked....*/
 
 			if (r)
 			{
@@ -46,18 +47,18 @@
 
 				DIAGS(("Dead client [%s:pid=%d] - cleaning up\n",clients[app].name,app));
 				
-				dead_client_pb.contrl=dead_exit_contrl;	// If client is dead, send ourselves a message to clean up....
-				dead_client_packet.pid=app;				// client pid
-				dead_client_packet.cmd=AESCMD_NOREPLY;	// no reply
-				dead_client_packet.pb=&dead_client_pb;	// pointer to AES parameter block
+				dead_client_pb.contrl=dead_exit_contrl;	/* If client is dead, send ourselves a message to clean up....*/
+				dead_client_packet.pid=app;				/* client pid*/
+				dead_client_packet.cmd=AESCMD_NOREPLY;	/* no reply*/
+				dead_client_packet.pb=&dead_client_pb;	/* pointer to AES parameter block*/
 
-				XA_client_exit(app,&dead_client_pb);	// Run the application exit cleanup
+				XA_client_exit(app,&dead_client_pb);	/* Run the application exit cleanup*/
 				
-				clients[app].clnt_pipe_rd=0;			// This is normally done by appl_exit(),
-														// but beings as the client is dead, the pipe will be
-														// closed already
+				clients[app].clnt_pipe_rd=0;			/* This is normally done by appl_exit(),*/
+														/* but beings as the client is dead, the pipe will be*/
+														/* closed already*/
 
-				if (update_lock==app)					// unlock mouse & screen
+				if (update_lock==app)					/* unlock mouse & screen*/
 					update_lock=0;
 				if (mouse_lock==app)
 					mouse_lock=0;
@@ -81,16 +82,16 @@
 		DIAGS(("Killing owner of update lock\n"));
 		r=Pkill(update_lock,SIGKILL);
 
-		dead_client_pb.contrl=dead_exit_contrl;	// If client is dead, send ourselves a message to clean up....
-		dead_client_packet.pid=update_lock;				// client pid
-		dead_client_packet.cmd=AESCMD_NOREPLY;	// no reply
-		dead_client_packet.pb=&dead_client_pb;	// pointer to AES parameter block
+		dead_client_pb.contrl=dead_exit_contrl;	/* If client is dead, send ourselves a message to clean up....*/
+		dead_client_packet.pid=update_lock;				/* client pid*/
+		dead_client_packet.cmd=AESCMD_NOREPLY;	/* no reply*/
+		dead_client_packet.pb=&dead_client_pb;	/* pointer to AES parameter block*/
 
-		XA_client_exit(update_lock,&dead_client_pb);	// Run the application exit cleanup
+		XA_client_exit(update_lock,&dead_client_pb);	/* Run the application exit cleanup*/
 				
-		clients[update_lock].clnt_pipe_rd=0;	// This is normally done by appl_exit(),
-												// but beings as the client is dead, the pipe will be
-												// closed already
+		clients[update_lock].clnt_pipe_rd=0;	/* This is normally done by appl_exit(),*/
+												/* but beings as the client is dead, the pipe will be*/
+												/* closed already*/
 	}
 	
 	if ((mouse_lock)&&((mouse_lock!=update_lock)&&(mouse_lock!=AESpid)))
@@ -98,16 +99,16 @@
 		DIAGS(("Killing owner of mouse lock\n"));
 		r=Pkill(mouse_lock,SIGKILL);
 
-		dead_client_pb.contrl=dead_exit_contrl;	// If client is dead, send ourselves a message to clean up....
-		dead_client_packet.pid=mouse_lock;				// client pid
-		dead_client_packet.cmd=AESCMD_NOREPLY;	// no reply
-		dead_client_packet.pb=&dead_client_pb;	// pointer to AES parameter block
+		dead_client_pb.contrl=dead_exit_contrl;	/* If client is dead, send ourselves a message to clean up....*/
+		dead_client_packet.pid=mouse_lock;				/* client pid*/
+		dead_client_packet.cmd=AESCMD_NOREPLY;	/* no reply*/
+		dead_client_packet.pb=&dead_client_pb;	/* pointer to AES parameter block*/
 
-		XA_client_exit(mouse_lock,&dead_client_pb);	// Run the application exit cleanup
+		XA_client_exit(mouse_lock,&dead_client_pb);	/* Run the application exit cleanup*/
 				
-		clients[mouse_lock].clnt_pipe_rd=0;		// This is normally done by appl_exit(),
-												// but beings as the client is dead, the pipe will be
-												// closed already
+		clients[mouse_lock].clnt_pipe_rd=0;		/* This is normally done by appl_exit(),*/
+												/* but beings as the client is dead, the pipe will be*/
+												/* closed already*/
 	}
 	v_show_c(V_handle, 0);
 	mouse_lock=update_lock=0;
@@ -134,7 +135,7 @@
 		if (next_app>=MAX_PID)
 			next_app=0;
 			
-		if (clients[next_app].clnt_pipe_rd)	// Is this a valid application?
+		if (clients[next_app].clnt_pipe_rd)	/* Is this a valid application?*/
 		{
 			if (clients[next_app].std_menu!=menu_bar->tree)
 			{
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/appl_ini.c /h/xaaes/appl_ini.c
--- /i/newitems/XaAES.beta2/src/appl_ini.c	Thu Feb 15 22:59:22 1996
+++ /h/xaaes/appl_ini.c	Wed Feb 21 21:26:56 1996
@@ -6,6 +6,7 @@
  */
 
 #include <UNISTD.H>
+#include <stdio.h>
 #include <FILESYS.H>
 #include <OSBIND.H>
 #include <MINTBIND.H>
@@ -16,11 +17,11 @@
 #include "K_DEFS.H"
 #include "KERNAL.H"
 
-// These are all far globals, as this is the only major module outside of the trap
-// vector handler which executes wholely in supervisor mode, and under the CLIENT pid, 
-// not the AES pid. A bit kludgey - but it's only one little module eh? If these aren't
-// defined as far global, the compiler generates refferances to them relative to the
-// offset register which aren't valid when executing as the client process.
+/* These are all far globals, as this is the only major module outside of the trap*/
+/* vector handler which executes wholely in supervisor mode, and under the CLIENT pid, */
+/* not the AES pid. A bit kludgey - but it's only one little module eh? If these aren't*/
+/* defined as far global, the compiler generates refferances to them relative to the*/
+/* offset register which aren't valid when executing as the client process.*/
 
 /* Note: since XA_handler now properly loads the global base register,
 	`far' data is no longer needed! <mk> */
@@ -44,27 +45,27 @@
 {
 	Psemaphore(2,APPL_INIT_SEMAPHORE,-1L);
 	
-// In XaAES, AESid==MiNT process id : this makes error tracking easier
+/* In XaAES, AESid==MiNT process id : this makes error tracking easier*/
 	Cpid=Pgetpid();
 
 	pb->intout[0]=Cpid;
 
-	pb->globl[0]=0x0410;		// Try to emulate AES4.1
-	pb->globl[1]=-1;			// Unlimited applicatios (well, not really)
-	pb->globl[2]=Cpid;			// appid==pid
+	pb->globl[0]=0x0410;		/* Try to emulate AES4.1*/
+	pb->globl[1]=-1;			/* Unlimited applicatios (well, not really)*/
+	pb->globl[2]=Cpid;			/* appid==pid*/
 	pb->globl[5]=0;
 	pb->globl[6]=0;
 	pb->globl[7]=0;
 	pb->globl[8]=0;
 	pb->globl[9]=0;
-	pb->globl[10]=0;
+	pb->globl[10]=display.planes;
 	pb->globl[11]=0;
 	pb->globl[12]=0;
-	pb->globl[13]=display.c_max_h;		// AES4.0 extensions
+	pb->globl[13]=display.c_max_h;		/* AES4.0 extensions*/
 	pb->globl[14]=4;
 
-	clients[Cpid].globl_ptr=pb->globl;		// Preserve the pointer to the global array
-											// so we can fill in the resource address later
+	clients[Cpid].globl_ptr=pb->globl;		/* Preserve the pointer to the global array*/
+											/* so we can fill in the resource address later*/
 	
 	if (clients[Cpid].clnt_pipe_rd)
 	{
@@ -72,42 +73,42 @@
 		return TRUE;
 	}
 
-// Allocate a private stack just for use in XaAES calls
+/* Allocate a private stack just for use in XaAES calls*/
 	clients[Cpid].private_stack=Mxalloc(PRIVATE_STACK_SIZE,3|(1<<3)|(2<<4));
 
-// Create a new client reply pipe
+/* Create a new client reply pipe*/
 	sprintf(r_pipe_name,r_fmt,Cpid);
-	clients[Cpid].clnt_pipe_rd=Fopen(r_pipe_name,O_CREAT|O_RDONLY);	// Clients end of pipe
+	clients[Cpid].clnt_pipe_rd=(int)Fopen(r_pipe_name,O_CREAT|O_RDONLY);	/* Clients end of pipe*/
 
-//	pb->globl[12]=clients[Cpid].clnt_pipe_rd;	// XaAES extension
+/*	pb->globl[12]=clients[Cpid].clnt_pipe_rd;	// XaAES extension*/
 
-// Get the client's home directory (where it was started) - we use this later to load
-//  resource files, etc
+/* Get the client's home directory (where it was started) - we use this later to load*/
+/*  resource files, etc*/
 	XAappin_temp=Dgetdrv();
 	clients[Cpid].home_path[0]=(char)XAappin_temp+'a';
 	clients[Cpid].home_path[1]=':';
 	clients[Cpid].home_path[2]='\\';
 	Dgetcwd(clients[Cpid].home_path+3,XAappin_temp+1,196);
 
-// Reset the AES messages pending list for our new application
+/* Reset the AES messages pending list for our new application*/
 	clients[Cpid].msg=NULL;
-// No widgets have action pending on a new app
+/* No widgets have action pending on a new app*/
 	clients[Cpid].widget_active=NULL;
-// Initially, client isn't waiting on any event types
+/* Initially, client isn't waiting on any event types*/
 	clients[Cpid].waiting_for=0;
 	clients[Cpid].waiting_pb=NULL;
-// Initial settings for the clients mouse cursor
-	clients[Cpid].client_mouse=ARROW;		// Default client mouse cursor is an arrow
+/* Initial settings for the clients mouse cursor*/
+	clients[Cpid].client_mouse=ARROW;		/* Default client mouse cursor is an arrow*/
 	clients[Cpid].client_mouse_form=NULL;
 
-// Build a 'register new client' packet and send it to the kernal
-// - the kernal will respond by opening it's end of the reply pipe ready for use
+/* Build a 'register new client' packet and send it to the kernal*/
+/* - the kernal will respond by opening it's end of the reply pipe ready for use*/
 	new_client_pb.contrl=new_client_contrl;
-	new_client_packet.pid=Cpid;					// client pid
-	new_client_packet.cmd=AESCMD_NOREPLY;		// no reply
-	new_client_packet.pb=&new_client_pb;		// pointer to AES parameter block
+	new_client_packet.pid=Cpid;					/* client pid*/
+	new_client_packet.cmd=AESCMD_NOREPLY;		/* no reply*/
+	new_client_packet.pb=&new_client_pb;		/* pointer to AES parameter block*/
 
-	Fwrite(AES_in_pipe_clnt, sizeof(K_CMD_PACKET), &new_client_packet);	// Send packet
+	Fwrite(AES_in_pipe_clnt, sizeof(K_CMD_PACKET), &new_client_packet);	/* Send packet*/
 
 	Psemaphore(3,APPL_INIT_SEMAPHORE,0);
 
@@ -124,19 +125,19 @@
 */
 far __regargs short XA_appl_exit(short *intout)
 {
-	intout[0]=Pgetpid();						// Which process are we? It'll be a client pid
+	intout[0]=Pgetpid();						/* Which process are we? It'll be a client pid*/
 	DIAGS(("XaAES:pid=%d :appl_exit()\n",intout[0]));
 
-// Build a 'client is exiting' packet and send it to the kernal
-// - the kernal will respond by closing it's end of the clients reply pipe.
+/* Build a 'client is exiting' packet and send it to the kernal*/
+/* - the kernal will respond by closing it's end of the clients reply pipe.*/
 	new_client_pb.contrl=client_exit_contrl;
-	new_client_packet.pid=intout[0];			// client pid
-	new_client_packet.cmd=AESCMD_NOREPLY;		// no reply
-	new_client_packet.pb=&new_client_pb;		// pointer to AES parameter block
+	new_client_packet.pid=intout[0];			/* client pid*/
+	new_client_packet.cmd=AESCMD_NOREPLY;		/* no reply*/
+	new_client_packet.pb=&new_client_pb;		/* pointer to AES parameter block*/
 
-	Fwrite(AES_in_pipe_clnt, sizeof(K_CMD_PACKET), &new_client_packet);	// Send packet
+	Fwrite(AES_in_pipe_clnt, sizeof(K_CMD_PACKET), &new_client_packet);	/* Send packet*/
 
-	Fclose(clients[intout[0]].clnt_pipe_rd);	// Close the client end of client reply pipe
+	Fclose(clients[intout[0]].clnt_pipe_rd);	/* Close the client end of client reply pipe*/
 
 	clients[intout[0]].clnt_pipe_rd=0;
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/appl_msg.c /h/xaaes/appl_msg.c
--- /i/newitems/XaAES.beta2/src/appl_msg.c	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/appl_msg.c	Thu Feb 22 21:04:00 1996
@@ -0,0 +1,30 @@
+/*
+ * XaAES - XaAES Ain't the AES
+ *
+ * A multitasking AES replacement for MiNT
+ *
+ */
+
+#include "XA_DEFS.H"
+#include "XA_TYPES.H"
+#include "XA_GLOBL.H"
+#include "messages.h"
+
+/* Should of course be able to send more than 16 bytes, but send_app_message
+ * currently doesn't allow this.
+ */
+short XA_appl_write(short clnt_pid, AESPB *pb)
+{
+	short *mbuf;
+
+	if (pb->intin[1] != 16)
+	{
+		pb->intout[0] = 0;
+		return FALSE;
+	}
+	mbuf = (short *)pb->addrin[0];
+	send_app_message(pb->intin[0], mbuf[0], clnt_pid, mbuf[3], mbuf[4],
+		mbuf[5], mbuf[6], mbuf[7]);
+	pb->intout[0] = 1;
+	return TRUE;
+}
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/appl_msg.h /h/xaaes/appl_msg.h
--- /i/newitems/XaAES.beta2/src/appl_msg.h	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/appl_msg.h	Thu Feb 22 20:05:52 1996
@@ -0,0 +1,6 @@
+#ifndef _APPL_MSG_H
+#define _APPL_MSG_H
+
+short XA_appl_write(short clnt_pid, AESPB *pb);
+
+#endif
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/bootup.c /h/xaaes/bootup.c
--- /i/newitems/XaAES.beta2/src/bootup.c	Mon Feb 19 13:45:20 1996
+++ /h/xaaes/bootup.c	Thu Feb 22 19:52:46 1996
@@ -12,6 +12,8 @@
 #include <FILESYS.H>
 #include <SIGNAL.H>
 #include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
 #include <IOCTL.H>
 #include "xa_defs.h"
 #include "k_defs.h"
@@ -35,7 +37,7 @@
 extern short _AESglobal[15];
 #define global _AESglobal
 int __regargs _AESif(unsigned int);
-#define appl_init() _AESif(0)
+#define appl_init()			_AESif(0)
 #elif defined(__PUREC__)	/* ----- Pure C 1.1 ----- */
 typedef struct
 {
@@ -49,6 +51,9 @@
 extern  GEMPARBLK _GemParBlk;
 #define global _GemParBlk.global
 extern int appl_init(void);
+extern int appl_exit(void);
+extern int graf_handle(int *gr_hwchar, int *gr_hhchar,
+	int *gr_hwbox, int *gr_hhbox );
 #else						/* ----- others ----- */
 extern short global[] ;
 extern int appl_init(void) ;
@@ -76,35 +81,35 @@
 	printf("(w)1995,Craig Graham\n");
 }
 
-short P_handle=0,V_handle=0;		// Workstation handles used by the AES
-XA_SCREEN display;				// The display descriptor
+short P_handle=0,V_handle=0;		/* Workstation handles used by the AES*/
+XA_SCREEN display;				/* The display descriptor*/
 const XA_COLOUR_SCHEME default_colours={LWHITE,BLACK,LBLACK,WHITE,BLACK,CYAN};
 const XA_COLOUR_SCHEME bw_default_colours={WHITE,BLACK,BLACK,BLACK,BLACK,BLACK};
-int AES_in_pipe;				// The AES instruction input pipe handle
-int AES_in_pipe_clnt;			// The AES instruction input pipe handle (client end)
+int AES_in_pipe;				/* The AES instruction input pipe handle*/
+int AES_in_pipe_clnt;			/* The AES instruction input pipe handle (client end)*/
 
-int MOUSE_in_pipe;				// The MOUSE data packet input pipe handle
+int MOUSE_in_pipe;				/* The MOUSE data packet input pipe handle*/
 
-long KBD_device;					// The MiNT keyboard device's file handle
+long KBD_device;					/* The MiNT keyboard device's file handle*/
 
 unsigned long kernal_a4;
 unsigned long kernal_a6;
 
-short AESpid;						// The AES's MiNT process ID
+short AESpid;						/* The AES's MiNT process ID*/
 
-XA_WINDOW *root_window;				// The desktop window
+XA_WINDOW *root_window;				/* The desktop window*/
 
 #if GENERATE_DIAGS
-char debug_path[100];				// Path to dump debug info to
-short debug_file;					// File handle to dump debug stuff to
+char debug_path[100];				/* Path to dump debug info to*/
+short debug_file;					/* File handle to dump debug stuff to*/
 #endif
 
-char XaAES_home[200];				// XaAES's home location
+char XaAES_home[200];				/* XaAES's home location*/
 short XaAES_home_drv;
 
-char scrap_path[128];				// Path to the scrap directory
+char scrap_path[128];				/* Path to the scrap directory*/
 
-void *system_resources;				// Pointer to the XaAES resources
+void *system_resources;				/* Pointer to the XaAES resources*/
 
 /*
 	Read & parse the 'xaaes.cnf' file.
@@ -140,21 +145,21 @@
 	{
 		fgets(lb,199,cnf);
 		
-		if (lb[0]!='#')							// '#' is a comment line
+		if (lb[0]!='#')							/* '#' is a comment line*/
 		{
-			tl=strlen(lb);
+			tl=(short)strlen(lb);
 			
 			for(t=0; (t<tl)&&(lb[t]!=' '); t++) 
-				if ((lb[t]>96)&&(lb[t]<123))	// Capitalise the command
+				if ((lb[t]>96)&&(lb[t]<123))	/* Capitalise the command*/
 					lb[t]-=32;
 
 			for(t++; t<tl; t++)
 			{
-				if (lb[t]<14)					// Strip out unwanted carriage returns, etc
+				if (lb[t]<14)					/* Strip out unwanted carriage returns, etc*/
 					lb[t]='\0';
 			}
 			
-			if (!strncmp(lb,"RUN ",4))			// Run command launches a program
+			if (!strncmp(lb,"RUN ",4))			/* Run command launches a program*/
 			{
 				for(p=lb+4; (*p!=' ')&&(*p!='\0'); p++);
 				if (*p)
@@ -168,13 +173,13 @@
 				shell_write(0,0,0,lb+4,parms);
 			}
 			
-			if (!strncmp(lb,"CLIPBOARD ",10))	// Set the location of the default clipboard
+			if (!strncmp(lb,"CLIPBOARD ",10))	/* Set the location of the default clipboard*/
 			{
 				sprintf(scrap_path,"%s",lb+10);
 			}
 
 #if GENERATE_DIAGS
-			if (!strncmp(lb,"DEBUG ",6))		// Redirect console output
+			if (!strncmp(lb,"DEBUG ",6))		/* Redirect console output*/
 			{
 				sprintf(debug_path,"%s",lb+6);
 			}
@@ -208,13 +213,17 @@
 	- Run the xaaes.cnf startup script.
 */
 
-const XA_WIDGET_LOCATION sys_menu_loc={LT,2,2};
+XA_WIDGET_LOCATION sys_menu_loc={LT,2,2};
 
 short main(void)
 {
 	short work_in[12];
 	short work_out[58];
 	char a1[10];
+	char proc_path[32];
+	short proc_handle;
+	long protection;
+	_DTA my_dta,*old_dta;
 	short f,junk;
 	long dummy;
 	XA_WIDGET_TREE *menu;
@@ -223,25 +232,52 @@
 	for(f=1;f<10; work_in[f++]=1);
 	work_in[10]=2;
 
-// Print a text boot message (you probably won't see this as it goes by real quick)
+/* Print a text boot message (you probably won't see this as it goes by real quick)*/
 	BootMessage();
 
-// Check that MiNT is actually installed
+/* Check that MiNT is actually installed*/
 	if(!GetCookie((long)'MiNT',&dummy))
 	{
-		do_form_alert(1,"[3][ Sorry, XaAES requires MiNT to run. ][ Exit ]",0);
+/* Use puts here, as everything is not yet initialised */
+		puts("Sorry, XaAES requires MiNT to run.");
 		exit(1);
 	}
 
-// Let's get our MiNT process id being's as MiNT is loaded...
+/* Let's get our MiNT process id being's as MiNT is loaded...*/
 	AESpid=Pgetpid();
 	clients[AESpid].cmd_name="XaAES";
 
-// Where were we started?
+/* Change the protection mode to OS_SPECIAL to allow operation with
+ * memory protection (doesn't work yet, what's wrong?)
+ */
+	sprintf(proc_path, "u:\\proc\\*.%03d", AESpid);
+	old_dta = Fgetdta();
+	Fsetdta(&my_dta);
+	if (!Fsfirst(proc_path, 0x27))
+	{
+#ifndef F_PROT_S
+#define F_PROT_S		0x20
+#endif
+#ifndef F_OS_SPECIAL
+#define F_OS_SPECIAL	0x8000
+#endif
+		sprintf(proc_path, "u:\\proc\\%s", my_dta.dta_name);
+		if ((dummy = Fopen(proc_path, O_RDONLY)) >= 0)
+		{
+			proc_handle = (short)dummy;
+			Fcntl(proc_handle, &protection, PGETFLAGS);
+			protection &= ~0xf0;
+			protection |= F_OS_SPECIAL | F_PROT_S;
+			Fcntl(proc_handle, &protection, PSETFLAGS);
+			Fclose(proc_handle);
+		}
+	}
+
+/* Where were we started?*/
 	XaAES_home_drv=Dgetdrv();
 	Dgetcwd(XaAES_home,XaAES_home_drv+1,196);
 
-// Are we an auto/mint.cnf launched program?
+/* Are we an auto/mint.cnf launched program?*/
 	/* Note: global[0] (AES version number) is initially zero. */
 	appl_init();
 	auto_program=(global[0]==0);	/* global[0] still zero? */
@@ -249,23 +285,25 @@
 	
 	if (auto_program)
 	{
-		v_opnwk(work_in,&P_handle,work_out);			// If we are an auto program we must open a physical workstation to the screen
+		v_opnwk(work_in,&P_handle,work_out);			/* If we are an auto program we must open a physical workstation to the screen*/
 	}else{
-		P_handle=graf_handle(&junk,&junk,&junk,&junk);	// The GEM AES has already been started, 
-														//  so get the physical workstation handle from it
+		P_handle=graf_handle(&junk,&junk,&junk,&junk);	/* The GEM AES has already been started, */
+														/*  so get the physical workstation handle from it*/
 	}
 
-// Grab the Lattice C data pointers - we'll need them to get at our own
-// data when kernal routines are executed as threads of other applications (grin)
+/* Grab the Lattice C data pointers - we'll need them to get at our own*/
+/* data when kernal routines are executed as threads of other applications (grin)*/
+#ifdef LATTICE
 	kernal_a4=get_a4();
 	kernal_a6=get_a6();
+#endif
 
-// Setup the kernal OS call jump table
+/* Setup the kernal OS call jump table*/
 	setup_k_function_table();
 
-// Create a whole wodge of semphores for everything from remembering your mothers birthday
-// to avoiding an IRA bomb up your arse at work......(yes folks, I work in London and
-// don't like getting blown up).
+/* Create a whole wodge of semphores for everything from remembering your mothers birthday*/
+/* to avoiding an IRA bomb up your arse at work......(yes folks, I work in London and*/
+/* don't like getting blown up).*/
 	Psemaphore(0,APPL_INIT_SEMAPHORE,0);
 	Psemaphore(0,TRAP_HANDLER_SEMAPHORE,0);
 	Psemaphore(0,WIN_LIST_SEMAPHORE,0);
@@ -274,16 +312,16 @@
 	Psemaphore(0,UPDATE_LOCK,0);
 	Psemaphore(0,MOUSE_LOCK,0);
 
-// Patch the AES trap vector to use our OS.
+/* Patch the AES trap vector to use our OS.*/
 	hook_into_vector();
 
-// Create our AES instruction pipe (create once as a global file handle)
-	AES_in_pipe=Fopen("u:\\pipe\\XaAES.cmd", O_CREAT|O_RDONLY);	// kernals end of pipe
-	AES_in_pipe_clnt=Fopen("u:\\pipe\\XaAES.cmd",O_WRONLY|O_GLOBAL);	// clients shared handle to other end of pipe
-																		// - all clients use the same file handle to write
-																		//   to the command pipe.
+/* Create our AES instruction pipe (create once as a global file handle)*/
+	AES_in_pipe=(int)Fopen("u:\\pipe\\XaAES.cmd", O_CREAT|O_RDONLY);		/* kernals end of pipe*/
+	AES_in_pipe_clnt=(int)Fopen("u:\\pipe\\XaAES.cmd",O_WRONLY|O_GLOBAL);	/* clients shared handle to other end of pipe*/
+																			/* - all clients use the same file handle to write*/
+																			/*   to the command pipe.*/
 
-// Open the u:/dev/console device to get keyboard input
+/* Open the u:/dev/console device to get keyboard input*/
 	KBD_device=Fopen("u:\\dev\\console",O_RDONLY);
 	if (KBD_device<0)
 	{
@@ -291,7 +329,7 @@
 		exit(0);
 	}
 
-// Initialise the client descriptors
+/* Initialise the client descriptors*/
 	for(f=0; f<MAX_PID; f++)
 	{
 		clients[f].clnt_pipe_rd=clients[f].clnt_pipe_wr=0;
@@ -302,13 +340,13 @@
 		clients[f].zen=NULL;
 	}
 	
-// Open us a virtual workstation for XaAES to play with
+/* Open us a virtual workstation for XaAES to play with*/
 	V_handle=P_handle;
 	v_opnvwk(work_in,&V_handle,work_out);
-	vswr_mode(V_handle,MD_TRANS);	// We run in TRANSPARENT mode for all AES ops (unless requested otherwise)
+	vswr_mode(V_handle,MD_TRANS);	/* We run in TRANSPARENT mode for all AES ops (unless requested otherwise)*/
 	vst_alignment(V_handle,0,5,&f,&f);
 
-// Setup the display parameters
+/* Setup the display parameters*/
 	display.x=display.y=0;
 	display.w=work_out[0];
 	display.h=work_out[1];
@@ -320,18 +358,18 @@
 	display.dial_colours=
 		(display.colours<16) ?	bw_default_colours : default_colours;
 	
-	vq_extnd(V_handle,1,work_out);	// Get extended information
-	display.planes=work_out[4];		// number of planes in the display
+	vq_extnd(V_handle,1,work_out);	/* Get extended information*/
+	display.planes=work_out[4];		/* number of planes in the display*/
 
-//If we are using anything apart from the system font for windows, better check 
-// for GDOS and load the fonts.
+/*If we are using anything apart from the system font for windows, better check */
+/* for GDOS and load the fonts.*/
 	if (STANDARD_AES_FONTID!=1)		
 	{
-		if (vq_gdos())		// Yeah, I know, this is assuming the old-style vq_gdos() binding
+		if (vq_gdos())		/* Yeah, I know, this is assuming the old-style vq_gdos() binding*/
 			vst_load_fonts(V_handle,0);
 	}
 
-// Set standard AES font
+/* Set standard AES font*/
 	vst_font(V_handle,STANDARD_AES_FONTID);	
 
 /* Get font information for use by the resource loader */
@@ -345,51 +383,57 @@
 #endif
 
 
-// Select standard font
+/* Select standard font*/
 	vst_point(V_handle,STANDARD_FONT_POINT,&f,&f,&f,&f);
 
-// Get standard character extents for use by the resource loader
+/* Get standard character extents for use by the resource loader*/
 	vqt_extent(V_handle,"M",work_out);	
 	display.c_max_w=abs(work_out[2]-work_out[0]);
 	display.c_max_h=abs(work_out[1]-work_out[7]);
 	
-// Fix up the window widget bitmaps and any others we might be using
-//  (calls vr_trnfm() for all the bitmaps)
+/* Fix up the window widget bitmaps and any others we might be using*/
+/*  (calls vr_trnfm() for all the bitmaps)*/
 	fix_bitmaps();
 
-// Load the system resource file (we can probably embed this later)
+/* Load the system resource file (we can probably embed this later)*/
 	system_resources=LoadResources("system.rsc",DU_RSX_CONV, DU_RSY_CONV);
+	if (system_resources == NULL)
+	{
+		puts("FATAL: system.rsc not found!");
+/* Any better ideas? ;) */
+		for(;;);
+	}
 
-// Set the default clipboard
-	sprintf(scrap_path,"c:\\clipbrd\\");
+/* Set the default clipboard*/
+	strcpy(scrap_path,"c:\\clipbrd\\");
 
-// Spawn the mouse server
-	MOUSE_in_pipe=Fopen("u:\\pipe\\mouse.XA", O_CREAT|O_RDONLY);	// kernals end of pipe mouse packet pipe
+/* Spawn the mouse server*/
+	MOUSE_in_pipe=(int)Fopen("u:\\pipe\\mouse.XA", O_CREAT|O_RDONLY);	/* kernals end of pipe mouse packet pipe*/
 	sprintf(a1,"%d",V_handle);
 	if (!Pvfork())
-	{				// In child here
+	{				/* In child here*/
 		execl("mousesrv.tos","mousesrv",a1,NULL);
 	}
 
 #if SHOW_LOGO_AT_STARTUP
-// Display the XaAES logo
+/* Display the XaAES logo*/
 	if (!Pvfork())
-	{				// In child here
+	{				/* In child here*/
 		execl("logo.prg","XaAES_LOGO",NULL);
 	}
 #endif
 
-// Parse the standard startup file xaaes.cnf
-// This can run programs & re-direct the debugging output to another file/device
+/* Parse the standard startup file xaaes.cnf*/
+/* This can run programs & re-direct the debugging output to another file/device*/
 #if GENERATE_DIAGS
-	sprintf(debug_path,"debug.list");	// By default debugging output goes to the file "./debug.list"
+	strcpy(debug_path,"debug.list");	/* By default debugging output goes to the file "./debug.list"*/
 #endif
 	parse_cnf();
 
 #if GENERATE_DIAGS
-// Open a diagnostics file? All console output can be considered diagnostics, so
-// I just redirect the console to the required file/device
-	debug_file=Fopen(debug_path,O_CREAT|O_WRONLY);
+/* Open a diagnostics file? All console output can be considered diagnostics, so*/
+/* I just redirect the console to the required file/device*/
+	debug_file=(int)Fopen(debug_path,O_CREAT|O_WRONLY);
 	Fforce(1,debug_file);
 
 	DIAGS(("\n\n\nDebug to %s\n",debug_path));
@@ -399,39 +443,39 @@
 	DIAGS((" size=[%d,%d], colours=%d, bitplanes=%d\n",display.w,display.h,display.colours,display.planes));
 	DIAGS(("system_resources=%lx\n",system_resources));
 
-// Create the root (desktop) window
+/* Create the root (desktop) window*/
 	root_window=create_window(AESpid, 0, 0, 0, display.w, display.h);
 	root_window->handle=0;
-	root_window->is_open=TRUE;				// Flag window as open	
+	root_window->is_open=TRUE;				/* Flag window as open	*/
 
-// Tack a menu onto the root widget
+/* Tack a menu onto the root widget*/
 	clients[AESpid].std_menu=ResourceTree(system_resources,SYSTEM_MENU);
 	fix_menu(clients[AESpid].std_menu);
 	set_menu_widget(root_window, sys_menu_loc, clients[AESpid].std_menu);
 	menu=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 	menu->owner=AESpid;
 
-// Display the root window
+/* Display the root window*/
 	v_hide_c(V_handle);
 	display_non_topped_window(root_window);
 
-// Turn on the mouse cursor
+/* Turn on the mouse cursor*/
 	v_show_c(V_handle,0);
 
-// Set our process priority - a high negative value here improves performance a lot, 
-//  so I set it to -20 in XA_DEFS.H. This doesn't hurt the rest of the systems performance,
-//  as there are no busy wait loops in the server, and it spends most of it's time blocked
-//  waiting for commands.
+/* Set our process priority - a high negative value here improves performance a lot, */
+/*  so I set it to -20 in XA_DEFS.H. This doesn't hurt the rest of the systems performance,*/
+/*  as there are no busy wait loops in the server, and it spends most of it's time blocked*/
+/*  waiting for commands.*/
 	Pnice(AES_PRIORITY);
 
-// Catch SIGCHLD to spot dead children
+/* Catch SIGCHLD to spot dead children*/
 /*	Psignal(SIGCHLD, (long)HandleSIGCHLD);*/
 
-// Call the main command interpreter kernal
+/* Call the main command interpreter kernal*/
 	kernal();
 
-// Closedown & exit - we should never get here....especially as I've not done all the closedown
-// handling yet.
+/* Closedown & exit - we should never get here....especially as I've not done all the closedown*/
+/* handling yet.*/
 	Cleanup() ;
 
 	return 0;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/box3d.c /h/xaaes/box3d.c
--- /i/newitems/XaAES.beta2/src/box3d.c	Wed Jan 31 01:00:24 1996
+++ /h/xaaes/box3d.c	Wed Feb 21 13:44:06 1996
@@ -14,7 +14,7 @@
 	short pnt[10];
 	
 	vsf_color(V_handle,display.dial_colours.bg_col);
-	vsf_interior(V_handle,FIS_SOLID);		// Select solid fills - maybe make this an option?
+	vsf_interior(V_handle,FIS_SOLID);		/* Select solid fills - maybe make this an option?*/
 	pnt[0]=x; pnt[1]=y; pnt[2]=x+w; pnt[3]=y+h;
 	v_bar(V_handle,pnt);
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/c_window.c /h/xaaes/c_window.c
--- /i/newitems/XaAES.beta2/src/c_window.c	Thu Feb 15 22:53:04 1996
+++ /h/xaaes/c_window.c	Thu Feb 22 22:45:00 1996
@@ -15,17 +15,18 @@
 #include "BOX3D.H"
 #include "C_WINDOW.H"
 #include "RECTLIST.H"
+#include "messages.h"
 
 /*
 	Low-level Window Stack Management Functions
 */
 
-XA_WINDOW *window_list=NULL;		// The global system window stack
-short wind_handle=0;				// Window handle counter (used to generate unique window handles)
-									// As this loops round, there may be a problem if a user opens
-									// more than 32767 windows in one session :)
+XA_WINDOW *window_list=NULL;		/* The global system window stack*/
+short wind_handle=0;				/* Window handle counter (used to generate unique window handles)*/
+									/* As this loops round, there may be a problem if a user opens*/
+									/* more than 32767 windows in one session :)*/
 
-// Create a window
+/* Create a window*/
 XA_WINDOW *create_window(short pid, long tp, short rx, short ry, short rw, short rh)
 {
 	XA_WINDOW *nw=(XA_WINDOW *)malloc(sizeof(XA_WINDOW));
@@ -50,13 +51,13 @@
 	if (window_list) window_list->prev=nw;
 	window_list=nw;
 
-	send_wind_to_bottom(nw);	// As the window isn't open yet, send it to the bottom to get it out of the way
+	send_wind_to_bottom(nw);	/* As the window isn't open yet, send it to the bottom to get it out of the way*/
 	
 	Psemaphore(3,WIN_LIST_SEMAPHORE,0);
 	
-	standard_widgets(nw,tp);	// Attatch the appropriate widgets to the window
+	standard_widgets(nw,tp);	/* Attatch the appropriate widgets to the window*/
 
-	if (tp&STORE_BACK)			// If STORE_BACK extended attribute is used, window preserves it's own background
+	if (tp&STORE_BACK)			/* If STORE_BACK extended attribute is used, window preserves it's own background*/
 	{
 		nw->background=(void*)malloc(display.planes*((rw+35)>>2)*(rh+20));
 		nw->bgx=-1;
@@ -64,18 +65,18 @@
 		nw->background=NULL;
 	}
 	
-	calc_work_area(nw);			// Calculate an initial work area
+	calc_work_area(nw);			/* Calculate an initial work area*/
 
 	return nw;
 }
 
-// Display a window
+/* Display a window*/
 void display_window(XA_WINDOW *wind)
 {
 	short f,pnt[8],x,y,w,h;
 	WidgetCallback wc;
 
-	if (wind->active_widgets&STORE_BACK)	// Is this a 'preserve own background' window?
+	if (wind->active_widgets&STORE_BACK)	/* Is this a 'preserve own background' window?*/
 	{
 		MFDB Mscreen;
 		MFDB Mpreserve;
@@ -104,7 +105,7 @@
 	w=wind->ww;
 	h=wind->wh;
 	
-// Display the window backdrop (borders only, GEM style)
+/* Display the window backdrop (borders only, GEM style)*/
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 	pnt[0]=wind->x; pnt[1]=wind->y; pnt[2]=wind->x+wind->w; pnt[3]=y;
@@ -116,7 +117,7 @@
 	pnt[0]=x+w; pnt[2]=wind->x+wind->w;
 	v_bar(V_handle,pnt);
 
-// Display the work area	
+/* Display the work area	*/
 	vsl_color(V_handle,display.dial_colours.b_r_col);
 
 	pnt[0]=x; pnt[1]=y+h;
@@ -141,7 +142,7 @@
 	pnt[4]=x+w-1; pnt[5]=y+1;
 	v_pline(V_handle,3,pnt);
 
-// Go through and display the window widgets using their display behaviour
+/* Go through and display the window widgets using their display behaviour*/
 	for(f=0; f<XA_MAX_WIDGETS; f++)
 	{
 		wc=wind->widgets[f].behaviour[XACB_DISPLAY];
@@ -193,13 +194,13 @@
 	return NULL;
 }
 
-// Pull this window to the head of the window list
+/* Pull this window to the head of the window list*/
 void pull_wind_to_top(XA_WINDOW *w)
 {
 	Psemaphore(2,WIN_LIST_SEMAPHORE,-1L);
 
-	if (window_list->owner!=w->owner)	// If we're getting a new top window, we may need
-	{									// to swap menu bars.....
+	if (window_list->owner!=w->owner)	/* If we're getting a new top window, we may need*/
+	{									/* to swap menu bars.....*/
 		XA_WIDGET_TREE *menu_bar;
 
 		Psemaphore(2,ROOT_SEMAPHORE,-1L);
@@ -235,9 +236,9 @@
 {
 	XA_WINDOW *wl,*wlst_orig;
 	
-	if (w->next==NULL) return;			// Can't send to the bottom a window that's already there
+	if (w->next==NULL) return;			/* Can't send to the bottom a window that's already there*/
 	
-	if (window_list->next->next)		// Bottom window is always the desktop
+	if (window_list->next->next)		/* Bottom window is always the desktop*/
 	{
 		Psemaphore(2,WIN_LIST_SEMAPHORE,-1L);
 		
@@ -252,17 +253,17 @@
 		if (w->next)
 			w->next->prev=w->prev;
 
-		for(wl=window_list; wl->next->next; wl=wl->next);	// Find end of window list (excluding the desktop)
+		for(wl=window_list; wl->next->next; wl=wl->next);	/* Find end of window list (excluding the desktop)*/
 		
-		w->prev=wl;				// Insert the window above the desktop, but below everything else
+		w->prev=wl;				/* Insert the window above the desktop, but below everything else*/
 		w->next=wl->next;
 		wl->next->prev=w;
 		wl->next=w;
 	
 		Psemaphore(3,WIN_LIST_SEMAPHORE,0L);
 
-		if (wlst_orig->owner!=window_list->owner)	// If we're getting a new top window, we may need
-		{											// to swap menu bars.....
+		if (wlst_orig->owner!=window_list->owner)	/* If we're getting a new top window, we may need*/
+		{											/* to swap menu bars.....*/
 			XA_WIDGET_TREE *menu_bar=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 	
 			Psemaphore(2,ROOT_SEMAPHORE,-1L);
@@ -298,14 +299,14 @@
 	free(wind);
 }
 
-// Display a window that isn't on top, respecting clipping
+/* Display a window that isn't on top, respecting clipping*/
 void display_non_topped_window(XA_WINDOW *w)
 {
 	short clip[4];
 	XA_RECT_LIST *drl;
 	XA_RECT_LIST *rl=generate_rect_list(w);
 
-	if (w->is_open)		// Redraw the moved window
+	if (w->is_open)		/* Redraw the moved window*/
 	{
 		while(rl)
 		{
@@ -313,7 +314,7 @@
 			clip[0]=rl->x; clip[1]=rl->y;
 			clip[2]=rl->x+rl->w; clip[3]=rl->y+rl->h;
 			vs_clip(V_handle,1,clip);
-			display_window(w);				// Display the window
+			display_window(w);				/* Display the window*/
 			rl=rl->next;
 			free(drl);
 		}
@@ -321,7 +322,7 @@
 	vs_clip(V_handle,0,clip);
 }
 
-// Erase a window that isn't on top, respecting clipping
+/* Erase a window that isn't on top, respecting clipping*/
 void erase_non_topped_window(XA_WINDOW *w)
 {
 	short clip[4];
@@ -356,7 +357,7 @@
 	XA_RECT_LIST *rl;
 	short clip[4];
 
-	if (w->active_widgets&STORE_BACK)	// Is this a 'preserve own background' window?
+	if (w->active_widgets&STORE_BACK)	/* Is this a 'preserve own background' window?*/
 	{
 		MFDB Mscreen;
 		MFDB Mpreserve;
@@ -387,27 +388,27 @@
 			old_r.g_w=rl->w;
 			old_r.g_h=rl->h;
 	
-			if (w->next)	// We only need to do this bit if there are any windows lower than window
+			if (w->next)	/* We only need to do this bit if there are any windows lower than window*/
 			{	
-				for(wl=w; wl->next; wl=wl->next);	// Find bottom window
-				for(; wl!=w; wl=wl->prev)			// Check for redraws of windows starting at the
-				{									// bottom and working up to our window, and redraw using
-													// intersections with the rectangle list for our window.
+				for(wl=w; wl->next; wl=wl->next);	/* Find bottom window*/
+				for(; wl!=w; wl=wl->prev)			/* Check for redraws of windows starting at the*/
+				{									/* bottom and working up to our window, and redraw using*/
+													/* intersections with the rectangle list for our window.*/
 					if (wl->is_open)
 					{
 						win_r.g_x=wl->x;
 						win_r.g_y=wl->y;
 						win_r.g_w=wl->w;
 						win_r.g_h=wl->h;
-						if (rc_intersect(&old_r, &win_r))	// Part of a window needs re-drawing
+						if (rc_intersect(&old_r, &win_r))	/* Part of a window needs re-drawing*/
 						{
 							clip[0]=win_r.g_x; clip[1]=win_r.g_y;
 							clip[2]=win_r.g_x+win_r.g_w; clip[3]=win_r.g_y+win_r.g_h;
 							vs_clip(V_handle,1,clip);
 	
-							display_window(wl);				// Display the window
+							display_window(wl);				/* Display the window*/
 							
-											// send a redraw message to the owner of the window for this rectangle
+											/* send a redraw message to the owner of the window for this rectangle*/
 							if (!(wl->active_widgets&NO_REDRAWS))
 								send_app_message(wl->owner, WM_REDRAW, 0, wl->handle, win_r.g_x, win_r.g_y, win_r.g_w, win_r.g_h);
 						}
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/closwidg.c /h/xaaes/closwidg.c
--- /i/newitems/XaAES.beta2/src/closwidg.c	Tue Nov 28 00:38:48 1995
+++ /h/xaaes/closwidg.c	Wed Feb 21 13:44:08 1996
@@ -22,12 +22,12 @@
 /*======================================================
 	CLOSE WIDGET BEHAVIOUR
 ========================================================*/
-// Display the closer widget
+/* Display the closer widget*/
 short display_close_widget(XA_WINDOW *wind, XA_WIDGET *widg)
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_close);
@@ -37,8 +37,8 @@
 	return TRUE;
 }
 
-// Default close widget behaviour - just send a WM_CLOSED message to the client that
-// owns the window.
+/* Default close widget behaviour - just send a WM_CLOSED message to the client that*/
+/* owns the window.*/
 short click_close(XA_WINDOW *wind, XA_WIDGET *widg)
 {
 	send_app_message(wind->owner, WM_CLOSED, 0, wind->handle, 0, 0, 0, 0);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/cookies.c /h/xaaes/cookies.c
--- /i/newitems/XaAES.beta2/src/cookies.c	Wed Nov  1 01:36:38 1995
+++ /h/xaaes/cookies.c	Wed Feb 21 21:29:34 1996
@@ -8,7 +8,7 @@
 #include <OSBIND.H>
 #include "XA_TYPES.H"
 
-// This module is taken from Stephen Sowerby's AGiLE Library
+/* This module is taken from Stephen Sowerby's AGiLE Library*/
 
 /*
 	GetCookie : Get a cookie with a given code
@@ -21,7 +21,7 @@
 	long *cookie;
 	void *ssp;
 
-	ssp = Super(0L);
+	ssp = (void *)Super(0L);
 	cookie = *((long **) 0x5a0);
 	Super(ssp);
 	while (*cookie)
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/drag_box.c /h/xaaes/drag_box.c
--- /i/newitems/XaAES.beta2/src/drag_box.c	Wed Jan 31 22:40:32 1996
+++ /h/xaaes/drag_box.c	Wed Feb 21 13:44:14 1996
@@ -32,7 +32,7 @@
 		vq_mouse(V_handle, &mb, &x, &y);
 		dx=x-idx; dy=y-idy;
 		
-		if (dx<bx)		// Ensure we are inside the bounding rectangle
+		if (dx<bx)		/* Ensure we are inside the bounding rectangle*/
 		{
 			dx=bx;
 		}else{
@@ -50,7 +50,7 @@
 			v_hide_c(V_handle);
 			if (odx!=-1)
 #if SOLID_BOXES
-				v_bar(V_handle,pnt);		// This is a real man's GUI - dragged boxs can be done as solid
+				v_bar(V_handle,pnt);		/* This is a real man's GUI - dragged boxs can be done as solid*/
 
 			pnt[0]=dx; pnt[1]=dy; pnt[2]=dx+w; pnt[3]=dy+h;
 			v_bar(V_handle,pnt);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/event_q.c /h/xaaes/event_q.c
--- /i/newitems/XaAES.beta2/src/event_q.c	Wed Nov  1 01:36:38 1995
+++ /h/xaaes/event_q.c	Wed Feb 21 18:18:12 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include "EVENT_Q.H"
 #include "XA_DEFS.H"
 #include "K_DEFS.H"
@@ -17,20 +18,20 @@
 {
 	EVNT_Q *n,*c;
 	
-	c=(EVNT_Q*)malloc(sizeof(EVNT_Q));	// Create new event queue entry
+	c=(EVNT_Q*)malloc(sizeof(EVNT_Q));	/* Create new event queue entry*/
 	c->next=NULL;
 	c->pid=id;
 	c->pb=pb;
 	
-	if (*q==NULL)	// new list?
+	if (*q==NULL)	/* new list?*/
 	{
 		*q=c;
 		return;
 	}
 	
-	for(n=*q; n->next!=NULL; n=n->next);	// Find end of list
+	for(n=*q; n->next!=NULL; n=n->next);	/* Find end of list*/
 	
-	n->next=c;		// append entry
+	n->next=c;		/* append entry*/
 }
 
 EVNT_Q *EQ_pull_head(EVNT_Q **q)
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/event_q.h /h/xaaes/event_q.h
--- /i/newitems/XaAES.beta2/src/event_q.h	Wed Oct 11 13:02:46 1995
+++ /h/xaaes/event_q.h	Wed Feb 21 13:45:40 1996
@@ -13,11 +13,11 @@
 #define _EVENT_Q_H_
 #include "K_DEFS.H"
 
-// A queue of client processes that are waiting for an event
+/* A queue of client processes that are waiting for an event*/
 typedef struct evnt_q {
 	struct evnt_q *next;
-	short pid;		// Id of client that is waiting for an event
-	AESPB *pb;		// pointer to the parameter block for the client
+	short pid;		/* Id of client that is waiting for an event*/
+	AESPB *pb;		/* pointer to the parameter block for the client*/
 } EVNT_Q;
 
 void EQ_append(EVNT_Q **q, short id, AESPB *pb);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/evnt_btn.c /h/xaaes/evnt_btn.c
--- /i/newitems/XaAES.beta2/src/evnt_btn.c	Tue Feb  6 13:29:04 1996
+++ /h/xaaes/evnt_btn.c	Wed Feb 21 13:44:18 1996
@@ -14,8 +14,8 @@
 */
 short XA_evnt_button(short clnt_pid,AESPB *pb)
 {
-	clients[clnt_pid].waiting_for=XAWAIT_BUTTON;	// Flag the app as waiting for messages
-	clients[clnt_pid].waiting_pb=pb;				// Store a pointer to the AESPB to fill when the event
-												//  finally arrives.
-	return FALSE;	// Returning FALSE blocks the client app to wait for the event
+	clients[clnt_pid].waiting_for=XAWAIT_BUTTON;	/* Flag the app as waiting for messages*/
+	clients[clnt_pid].waiting_pb=pb;				/* Store a pointer to the AESPB to fill when the event*/
+												/*  finally arrives.*/
+	return FALSE;	/* Returning FALSE blocks the client app to wait for the event*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/evnt_kbd.c /h/xaaes/evnt_kbd.c
--- /i/newitems/XaAES.beta2/src/evnt_kbd.c	Tue Feb  6 13:29:14 1996
+++ /h/xaaes/evnt_kbd.c	Wed Feb 21 13:44:18 1996
@@ -14,8 +14,8 @@
 */
 short XA_evnt_keybd(short clnt_pid,AESPB *pb)
 {
-	clients[clnt_pid].waiting_for=XAWAIT_KEY;	// Flag the app as waiting for messages
-	clients[clnt_pid].waiting_pb=pb;			// Store a pointer to the AESPB to fill when the event
-												// finally arrives.
-	return FALSE;	// Returning FALSE blocks the client app to wait for the event
+	clients[clnt_pid].waiting_for=XAWAIT_KEY;	/* Flag the app as waiting for messages*/
+	clients[clnt_pid].waiting_pb=pb;			/* Store a pointer to the AESPB to fill when the event*/
+												/* finally arrives.*/
+	return FALSE;	/* Returning FALSE blocks the client app to wait for the event*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/evnt_mes.c /h/xaaes/evnt_mes.c
--- /i/newitems/XaAES.beta2/src/evnt_mes.c	Tue Feb  6 13:29:38 1996
+++ /h/xaaes/evnt_mes.c	Wed Feb 21 18:18:30 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include "XA_DEFS.H"
 #include "XA_TYPES.H"
 #include "XA_GLOBL.H"
@@ -24,8 +25,8 @@
 	XA_WIDGET *widg;
 	XA_WINDOW *wind;
 
-// Is there a widget still active (like a scroll arrow)? If so, check with the action first
-// as it may result in some messages (just in case we've not got any already)
+/* Is there a widget still active (like a scroll arrow)? If so, check with the action first*/
+/* as it may result in some messages (just in case we've not got any already)*/
 	if (!clients[clnt_pid].msg)
 	{
 		if (clients[clnt_pid].widget_active)
@@ -34,19 +35,19 @@
 			wc=pending->action;
 			widg=pending->widg;
 			wind=pending->wind;
-			rtn=(*wc)(pending->wind, pending->widg);	// Call the pending action
+			rtn=(*wc)(pending->wind, pending->widg);	/* Call the pending action*/
 
-			if (rtn)	// If the widget click/drag function returned TRUE we reset the state of the widget
+			if (rtn)	/* If the widget click/drag function returned TRUE we reset the state of the widget*/
 			{
 				XA_RECT_LIST *rl=generate_rect_list(wind);
 				XA_RECT_LIST *drl;
 				short clip[4];
 
-				widg->stat=XAW_PLAIN;					// Flag the widget as de-selected
-				disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
+				widg->stat=XAW_PLAIN;					/* Flag the widget as de-selected*/
+				disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
 
 				v_hide_c(V_handle);
-				for(drl=rl; drl; drl=drl->next)	// Walk the rectangle list
+				for(drl=rl; drl; drl=drl->next)	/* Walk the rectangle list*/
 				{
 					clip[0]=drl->x; clip[1]=drl->y;
 					clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -54,7 +55,7 @@
 					(*disp)(wind, widg);
 				}
 				v_show_c(V_handle, 1);
-				while(rl)	// Dispose of rectangle list
+				while(rl)	/* Dispose of rectangle list*/
 				{
 					drl=rl;
 					rl=rl->next;
@@ -65,20 +66,20 @@
 		}
 	}
 
-	if (clients[clnt_pid].msg)	// Are there any messages pending?
+	if (clients[clnt_pid].msg)	/* Are there any messages pending?*/
 	{
 		msg=clients[clnt_pid].msg;
 		clients[clnt_pid].msg=msg->next;
 		
-		for(f=0; f<8; f++)		// Copy the message into the clients buffer
+		for(f=0; f<8; f++)		/* Copy the message into the clients buffer*/
 			clnt_buf[f]=msg->message[f];
 
 		pb->intout[0]=1;
-		return TRUE;			// Return TRUE to unblock the client
+		return TRUE;			/* Return TRUE to unblock the client*/
 	}
 	
-	clients[clnt_pid].waiting_for=XAWAIT_MESSAGE;	// Mark the client as waiting for messages
+	clients[clnt_pid].waiting_for=XAWAIT_MESSAGE;	/* Mark the client as waiting for messages*/
 	clients[clnt_pid].waiting_pb=pb;
 	
-	return FALSE;				// Return false to block client waiting for a message
+	return FALSE;				/* Return false to block client waiting for a message*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/evnt_mul.c /h/xaaes/evnt_mul.c
--- /i/newitems/XaAES.beta2/src/evnt_mul.c	Mon Feb 19 14:14:42 1996
+++ /h/xaaes/evnt_mul.c	Wed Feb 21 18:18:46 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include "EVENT_Q.H"
 #include "XA_DEFS.H"
 #include "XA_GLOBL.H"
@@ -26,18 +27,18 @@
 	XA_WIDGET *widg;
 	XA_WINDOW *wind;
 
-	clients[clnt_pid].waiting_pb=pb;	// Store a pointer to the AESPB to fill when the event(s)
-										//  finally arrive.
+	clients[clnt_pid].waiting_pb=pb;	/* Store a pointer to the AESPB to fill when the event(s)*/
+										/*  finally arrive.*/
 	
 	if (events&MU_BUTTON)
 	{
-		new_waiting_for|=XAWAIT_BUTTON;	// Flag the app as waiting for messages
+		new_waiting_for|=XAWAIT_BUTTON;	/* Flag the app as waiting for messages*/
 		ret=XAC_BLOCK;
 	}
 	
 	if (events&MU_KEYBD)
 	{
-		new_waiting_for|=XAWAIT_KEY;	// Flag the app as waiting for messages
+		new_waiting_for|=XAWAIT_KEY;	/* Flag the app as waiting for messages*/
 		ret=XAC_BLOCK;
 	}
 	
@@ -52,15 +53,15 @@
 		if (dl<0x10)					/* Minimum timer is 0x10 */
 			dl=0x10;
 		
-		new_waiting_for|=XAWAIT_TIMER;	// Flag the app as waiting for a timer
+		new_waiting_for|=XAWAIT_TIMER;	/* Flag the app as waiting for a timer*/
 
 		ret=dl|XAC_M_TIMEOUT;
 	}
 	
 	if (events&MU_MESAG)
 	{
-// Is there a widget still active (like a scroll arrow)? If so, check with the action first
-// as it may result in some messages (just in case we've not got any already)
+/* Is there a widget still active (like a scroll arrow)? If so, check with the action first*/
+/* as it may result in some messages (just in case we've not got any already)*/
 		if (!clients[clnt_pid].msg)
 		{
 			if (clients[clnt_pid].widget_active)
@@ -69,19 +70,19 @@
 				wc=pending->action;
 				widg=pending->widg;
 				wind=pending->wind;
-				rtn=(*wc)(pending->wind, pending->widg);	// Call the pending action
+				rtn=(*wc)(pending->wind, pending->widg);	/* Call the pending action*/
 
-				if (rtn)	// If the widget click/drag function returned TRUE we reset the state of the widget
+				if (rtn)	/* If the widget click/drag function returned TRUE we reset the state of the widget*/
 				{
 					XA_RECT_LIST *rl=generate_rect_list(wind);
 					XA_RECT_LIST *drl;
 					short clip[4];
 
-					widg->stat=XAW_PLAIN;					// Flag the widget as de-selected
-					disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
+					widg->stat=XAW_PLAIN;					/* Flag the widget as de-selected*/
+					disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
 
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)	// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)	/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -89,7 +90,7 @@
 						(*disp)(wind, widg);
 					}
 					v_show_c(V_handle, 1);
-					while(rl)	// Dispose of rectangle list
+					while(rl)	/* Dispose of rectangle list*/
 					{
 						drl=rl;
 						rl=rl->next;
@@ -99,12 +100,12 @@
 			}
 		}
 
-		if (clients[clnt_pid].msg)	// Are there any messages pending?
+		if (clients[clnt_pid].msg)	/* Are there any messages pending?*/
 		{
 			msg=clients[clnt_pid].msg;
 			clients[clnt_pid].msg=msg->next;
 		
-			for(f=0; f<8; f++)		// Copy the message into the clients buffer
+			for(f=0; f<8; f++)		/* Copy the message into the clients buffer*/
 				clnt_buf[f]=msg->message[f];
 
 			pb->intout[0]=MU_MESAG;
@@ -112,16 +113,16 @@
 			return XAC_DONE;		/* Return XAC_DONE to unblock the client */
 		}
 	
-		new_waiting_for|=XAWAIT_MESSAGE;			// Mark the client as waiting for messages
+		new_waiting_for|=XAWAIT_MESSAGE;			/* Mark the client as waiting for messages*/
 	
 		if (ret==XAC_DONE)
 			ret=XAC_BLOCK;
 	}
 	
-	if (new_waiting_for)		// If we actually recognised any of the codes, then set the multi flag
+	if (new_waiting_for)		/* If we actually recognised any of the codes, then set the multi flag*/
 		new_waiting_for|=XAWAIT_MULTI;
 	
-	clients[clnt_pid].waiting_for=new_waiting_for;	// Flag the app as waiting for messages
+	clients[clnt_pid].waiting_for=new_waiting_for;	/* Flag the app as waiting for messages*/
 
 	return ret;
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/evnt_tmr.c /h/xaaes/evnt_tmr.c
--- /i/newitems/XaAES.beta2/src/evnt_tmr.c	Mon Feb 19 14:17:02 1996
+++ /h/xaaes/evnt_tmr.c	Wed Feb 21 13:44:22 1996
@@ -28,9 +28,9 @@
 	if (dl<0x10)					/* Minimum timer is 0x10 */
 		dl=0x10;
 
-	clients[clnt_pid].waiting_pb=pb;			// Store a pointer to the AESPB to fill when the event
-												//  finally arrives.
-	clients[clnt_pid].waiting_for=XAWAIT_TIMER;	// Flag the app as waiting for a timer
+	clients[clnt_pid].waiting_pb=pb;			/* Store a pointer to the AESPB to fill when the event*/
+												/*  finally arrives.*/
+	clients[clnt_pid].waiting_for=XAWAIT_TIMER;	/* Flag the app as waiting for a timer*/
 
 	return dl|XAC_T_TIMEOUT;
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/form_do.c /h/xaaes/form_do.c
--- /i/newitems/XaAES.beta2/src/form_do.c	Thu Feb 15 12:58:22 1996
+++ /h/xaaes/form_do.c	Thu Feb 22 13:02:36 1996
@@ -72,24 +72,24 @@
 */
 short click_object_widget(XA_WINDOW *wind, XA_WIDGET *widg)
 {
-	short x,y,f,b;
+	short x,y,f,b, xy[4];
 	short retv=XA_OK;
 	XA_WIDGET_TREE *wt=(XA_WIDGET_TREE*)widg->stuff;
 	OBJECT *form;
 
-	if (window_list!=wind)			// You can only work alerts when they are on top
+	if (window_list!=wind)			/* You can only work alerts when they are on top*/
 		return FALSE;
 
 	form=wt->tree;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	f=find_object(form, 0, 10, x+widg->click_x, y+widg->click_y);
 
-	if ((!(form[f].ob_flags&HIDETREE))		// Was click on a valid selectable object?
+	if ((!(form[f].ob_flags&HIDETREE))		/* Was click on a valid selectable object?*/
 		&&(!(form[f].ob_state&DISABLED)))
 	{
-		vs_clip(V_handle, 0, NULL);
+		vs_clip(V_handle, 0, xy);
 	
 		if (form[f].ob_flags&SELECTABLE)
 		{
@@ -103,20 +103,20 @@
 			}
 		}
 	
-		if (f>-1)	// Do we still have a click after the watch_object?
+		if (f>-1)	/* Do we still have a click after the watch_object?*/
 		{
-			if (form[f].ob_flags&RBUTTON)	// Was click on a radio button?
+			if (form[f].ob_flags&RBUTTON)	/* Was click on a radio button?*/
 			{
 				Radio_b(form,f);
 			}
 			
-			if (form[f].ob_flags&(EXIT|TOUCHEXIT))	// Exit button?
+			if (form[f].ob_flags&(EXIT|TOUCHEXIT))	/* Exit button?*/
 			{
 				clients[wt->owner].waiting_pb->intout[0]=f;
-				Fwrite(clients[wt->owner].clnt_pipe_wr, (long)sizeof(short),&retv);	// Write success to clients reply pipe to unblock the process
+				Fwrite(clients[wt->owner].clnt_pipe_wr, (long)sizeof(short),&retv);	/* Write success to clients reply pipe to unblock the process*/
 
-				if (!(wind->created_by_FMD_START))	// If FMD_START didn't create this window, destroy it now
-				{									// - if it did, then we expect the app to call FMD_FINISH to delete the window
+				if (!(wind->created_by_FMD_START))	/* If FMD_START didn't create this window, destroy it now*/
+				{									/* - if it did, then we expect the app to call FMD_FINISH to delete the window*/
 					clients[wt->owner].zen=NULL;
 					v_hide_c(V_handle);
 					display_windows_below(wind);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/forms.c /h/xaaes/forms.c
--- /i/newitems/XaAES.beta2/src/forms.c	Sun Feb 18 22:44:10 1996
+++ /h/xaaes/forms.c	Thu Feb 22 13:05:26 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdio.h>
 #include "XA_DEFS.H"
 #include "XA_TYPES.H"
 #include "XA_GLOBL.H"
@@ -13,6 +14,7 @@
 #include "FRM_ALRT.H"
 #include "STD_WIDG.H"
 #include "C_WINDOW.H"
+#include "watchbox.h"
 
 /*
 	FORM HANDLERS INTERFACE
@@ -57,7 +59,7 @@
 	
 	switch(pb->intin[0])
 	{
-		case FMD_START: 			// Create a window to put the dialog in
+		case FMD_START: 			/* Create a window to put the dialog in*/
 			dialog_window=create_window(clnt_pid, NAME, pb->intin[5], pb->intin[6], 
 							pb->intin[7], pb->intin[8]);
 
@@ -66,14 +68,14 @@
 			w=2*dialog_window->w - dialog_window->ww +1;
 			h=2*dialog_window->h - dialog_window->wh +1;
 
-			delete_window(dialog_window);		// Dispose of the temporary window we created
-												// And create the real one. It stay's fixed until form_do is called
-												// when it gets a MOVE property.
-// We create a window owned by the client so it will get button clicks for this area (in case it's gonna handle things it's own way)
+			delete_window(dialog_window);		/* Dispose of the temporary window we created*/
+												/* And create the real one. It stay's fixed until form_do is called*/
+												/* when it gets a MOVE property.*/
+/* We create a window owned by the client so it will get button clicks for this area (in case it's gonna handle things it's own way)*/
 			clients[clnt_pid].zen=dialog_window=create_window(clnt_pid, NAME|STORE_BACK|NO_MESSAGES, x, y, w, h);
 			dialog_window->is_open=TRUE;
 			dialog_window->created_by_FMD_START=TRUE;
-// Set the window title to be the clients name to avoid confusion
+/* Set the window title to be the clients name to avoid confusion*/
 			dialog_window->widgets[XAW_TITLE].stuff=(void*)clients[clnt_pid].name;
 
 			v_hide_c(V_handle);
@@ -86,7 +88,7 @@
 			break;
 		case FMD_SHRINK:
 			break;
-		case FMD_FINISH:		// If the client's dialog window is still hanging around, dispose of it....
+		case FMD_FINISH:		/* If the client's dialog window is still hanging around, dispose of it....*/
 			dialog_window=clients[clnt_pid].zen;
 			if (dialog_window)
 			{
@@ -111,11 +113,11 @@
 {
 	OBJECT *tree=(OBJECT*)pb->addrin[0];
 	short ob=pb->intin[0];
-	short is,os;
+	short is,os,xy[4];
 
-	pb->intout[1]=0;	// We cann't handle text fields yet in the forms...
+	pb->intout[1]=0;	/* We cann't handle text fields yet in the forms...*/
 
-	if (!(tree[ob].ob_flags&SELECTABLE))		// Exit immediately for static objects
+	if (!(tree[ob].ob_flags&SELECTABLE))		/* Exit immediately for static objects*/
 	{
 		pb->intout[0]=1;
 		return TRUE;
@@ -127,9 +129,9 @@
 	else
 		is=tree[ob].ob_state|SELECTED;
 
-	vs_clip(V_handle,0,NULL);
+	vs_clip(V_handle,0,xy);
 	
-	if (tree[ob].ob_flags&TOUCHEXIT)		// Change state & exit for TOUCHEXIT objects
+	if (tree[ob].ob_flags&TOUCHEXIT)		/* Change state & exit for TOUCHEXIT objects*/
 	{
 		tree[ob].ob_state=is;
 		v_hide_c(V_handle);
@@ -140,7 +142,7 @@
 		return TRUE;
 	}
 
-	if (watch_object(tree, ob, is, os))		// Do a watch to see if object is really selected
+	if (watch_object(tree, ob, is, os))		/* Do a watch to see if object is really selected*/
 	{
 		if (tree[ob].ob_flags&EXIT)
 		{
@@ -239,7 +241,7 @@
 
 	clients[clnt_pid].waiting_pb=pb;
 	
-	if (!clients[clnt_pid].zen)			// If the client hasn't called FMD_START (naughty), create a window for the dialog
+	if (!clients[clnt_pid].zen)			/* If the client hasn't called FMD_START (naughty), create a window for the dialog*/
 	{
 		dialog_window=create_window(clnt_pid, NAME|MOVE, form->ob_x, form->ob_y, form->ob_width, form->ob_height);
 
@@ -248,12 +250,12 @@
 		w=2*dialog_window->w - dialog_window->ww +1;
 		h=2*dialog_window->h - dialog_window->wh +1;
 
-		delete_window(dialog_window);		// Dispose of the temporary window we created
+		delete_window(dialog_window);		/* Dispose of the temporary window we created*/
 
 		clients[clnt_pid].zen=dialog_window=create_window(AESpid, NAME|MOVE|STORE_BACK|NO_MESSAGES, x, y, w, h);
 
 		dialog_window->created_by_FMD_START=FALSE;
-	// Set the window title to be the clients name to avoid confusion
+	/* Set the window title to be the clients name to avoid confusion*/
 		dialog_window->widgets[XAW_TITLE].stuff=(void*)clients[clnt_pid].name;
 	}else{
 		dialog_window=clients[clnt_pid].zen;
@@ -269,8 +271,8 @@
 	
 	((XA_WIDGET_TREE*)dialog_window->widgets[XAW_TOOLBAR].stuff)->owner=clnt_pid;
 	
-	dialog_window->active_widgets|=(NO_MESSAGES|MOVE);	// We don't want any redraw messages 
-											// - the widget handler will take care of it
+	dialog_window->active_widgets|=(NO_MESSAGES|MOVE);	/* We don't want any redraw messages */
+											/* - the widget handler will take care of it*/
 	dialog_window->is_open=TRUE;
 	
 	v_hide_c(V_handle);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/frm_alrt.c /h/xaaes/frm_alrt.c
--- /i/newitems/XaAES.beta2/src/frm_alrt.c	Fri Feb 16 00:42:12 1996
+++ /h/xaaes/frm_alrt.c	Thu Feb 22 13:05:44 1996
@@ -5,6 +5,8 @@
  *
  */
 
+#include <stdio.h>
+#include <stdlib.h>
 #include <VDI.H>
 #include <OSBIND.H>
 #include "XA_TYPES.H"
@@ -32,8 +34,8 @@
 	short x,y,w,h=0,n_lines=0,n_buttons=0,icon,max_w=0,m_butt_w=0;
 	short ty,th,b;
 	short f,pnt[10];
-	char alert_text[5][100];	// texts to display in the alert
-	char button_text[3][20];	// text for buttons
+	char alert_text[5][100];	/* texts to display in the alert*/
+	char button_text[3][20];	/* text for buttons*/
 	short button_w[3];
 	char *t;
 	OBJECT *alert_form;
@@ -43,17 +45,17 @@
 	
 	if (alert[0]!='[') return 0;
 	t=alert+1;
-	for(f=1; (t[f]!=']')&&(t[f]!='\0'); f++);	// Search for closing bracket on first field
+	for(f=1; (t[f]!=']')&&(t[f]!='\0'); f++);	/* Search for closing bracket on first field*/
 	if (t[f]!=']') return 0;
 
 	t[f]='\0';
-	icon=atoi(t);				// calculate the icon
+	icon=atoi(t);				/* calculate the icon*/
 	
 	t+=f+1;
 	if (t[0]!='[') return 0;
 	
 	t++;
-	for(f=0; (t[f]!=']')&&(t[f]!='\0');f++)		// Strip out the text lines
+	for(f=0; (t[f]!=']')&&(t[f]!='\0');f++)		/* Strip out the text lines*/
 	{
 		if (t[f]=='|')
 		{
@@ -82,7 +84,7 @@
 	if (t[0]!='[') return 0;
 	t++;
 
-	for(f=0; (t[f]!=']')&&(t[f]!='\0');f++)		// Strip out the text lines
+	for(f=0; (t[f]!=']')&&(t[f]!='\0');f++)		/* Strip out the text lines*/
 	{
 		if (t[f]=='|')
 		{
@@ -123,7 +125,7 @@
 		((ICONBLK*)(alert_icons+f)->ob_spec)->ib_yicon=((ICONBLK*)(alert_form+ALERT_D_ICON)->ob_spec)->ib_yicon;
 	}
 	
-	switch(icon)	// Setup the correct icon for this alert
+	switch(icon)	/* Setup the correct icon for this alert*/
 	{
 		case 1:
 			(ICONBLK*)(alert_form+ALERT_D_ICON)->ob_spec=(ICONBLK*)(alert_icons+ALR_IC_WARNING)->ob_spec;
@@ -149,14 +151,14 @@
 			break;
 	}
 	
-	for(f=0; f<5; f++)				// Fill in texts
+	for(f=0; f<5; f++)				/* Fill in texts*/
 		sprintf(((TEDINFO*)alert_form[ALERT_T1+f].ob_spec)->te_ptext,"%s",alert_text[f]);
 	
-	x=w-m_butt_w; 					// space the buttons evenly
+	x=w-m_butt_w; 					/* space the buttons evenly*/
 	b=x/(n_buttons+1);	
 	x=b;
 	
-	for(f=0; f<n_buttons; f++)		// Fill in & show buttons
+	for(f=0; f<n_buttons; f++)		/* Fill in & show buttons*/
 	{
 		sprintf((char*)alert_form[ALERT_BUT1+f].ob_spec,"%s",button_text[f]);
 		alert_form[ALERT_BUT1+f].ob_width=button_w[f];
@@ -166,27 +168,27 @@
 		x+=button_w[f]+b;
 	}
 	
-	for(f=n_buttons; f<3; f++)		// Hide unused buttons
+	for(f=n_buttons; f<3; f++)		/* Hide unused buttons*/
 		alert_form[ALERT_BUT1+f].ob_flags|=HIDETREE;
 
-// Create a window and attach the alert object tree to it
+/* Create a window and attach the alert object tree to it*/
 	alert_window=create_window(AESpid, NAME|MOVE|STORE_BACK, alert_form->ob_x, alert_form->ob_y, 
 									alert_form->ob_width+10, display.c_max_h+16+alert_form->ob_height);
 
 	dialog_toolbar_loc.y=display.c_max_h+10;
 	set_toolbar_widget(alert_window, dialog_toolbar_loc, alert_form);
 	
-// Change the click & drag behaviours for the alert box widget, because alerts return a number
-// 1 to 3, not an object index.
-	alert_window->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=&click_alert_widget;
-	alert_window->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=&click_alert_widget;
+/* Change the click & drag behaviours for the alert box widget, because alerts return a number*/
+/* 1 to 3, not an object index.*/
+	alert_window->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=click_alert_widget;
+	alert_window->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=click_alert_widget;
 	((XA_WIDGET_TREE*)alert_window->widgets[XAW_TOOLBAR].stuff)->owner=owner;
 	
-	alert_window->active_widgets|=NO_REDRAWS;	// We don't want any redraw messages 
-											// - the widget handler will take care of it
+	alert_window->active_widgets|=NO_REDRAWS;	/* We don't want any redraw messages */
+											/* - the widget handler will take care of it*/
 	alert_window->is_open=TRUE;
 
-// Set the window title to be the clients name to avoid confusion
+/* Set the window title to be the clients name to avoid confusion*/
 	alert_window->widgets[XAW_TITLE].stuff=(void*)clients[owner].name;
 	
 	v_hide_c(V_handle);
@@ -202,35 +204,35 @@
 */
 short click_alert_widget(XA_WINDOW *wind, XA_WIDGET *widg)
 {
-	short x,y,sel_b=-1,f,b;
+	short x,y,xy[4],sel_b=-1,f,b;
 	short retv=XA_OK;
 	XA_WIDGET_TREE *wt=(XA_WIDGET_TREE*)widg->stuff;
 	OBJECT *alert_form;
 
-	if (window_list!=wind)			// You can only work alerts when they are on top
+	if (window_list!=wind)			/* You can only work alerts when they are on top*/
 		return FALSE;
 
 	alert_form=wt->tree;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	f=find_object(alert_form, 0, 10, x+widg->click_x, y+widg->click_y);
 
-	if (((f>=ALERT_BUT1)			// Did we click on a valid button?
+	if (((f>=ALERT_BUT1)			/* Did we click on a valid button?*/
 		&&(f<ALERT_BUT1+3))
 		&&(!(alert_form[f].ob_flags&HIDETREE)))
 	{
-		vs_clip(V_handle, 0, NULL);
+		vs_clip(V_handle, 0, xy);
 	
 		b=watch_object(alert_form, f, SELECTED, 0);
 	
 		if (b)
 			sel_b=f+1-ALERT_BUT1;
 	
-		if (sel_b>-1)					// If the click was definite, we return the button & close the window
+		if (sel_b>-1)					/* If the click was definite, we return the button & close the window*/
 		{
 			clients[wt->owner].waiting_pb->intout[0]=sel_b;
-			Fwrite(clients[wt->owner].clnt_pipe_wr, (long)sizeof(short),&retv);	// Write success to clients reply pipe to unblock the process
+			Fwrite(clients[wt->owner].clnt_pipe_wr, (long)sizeof(short),&retv);	/* Write success to clients reply pipe to unblock the process*/
 
 			v_hide_c(V_handle);
 			erase_non_topped_window(wind);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/fullwidg.c /h/xaaes/fullwidg.c
--- /i/newitems/XaAES.beta2/src/fullwidg.c	Tue Nov 28 00:38:58 1995
+++ /h/xaaes/fullwidg.c	Wed Feb 21 13:44:32 1996
@@ -22,8 +22,8 @@
 /*======================================================
 	FULL WIDGET BEHAVIOUR
 ========================================================*/
-// Default full widget behaviour - just send a WM_FULLED message to the client that
-// owns the window.
+/* Default full widget behaviour - just send a WM_FULLED message to the client that*/
+/* owns the window.*/
 short click_full(XA_WINDOW *wind, XA_WIDGET *widg)
 {
 	send_app_message(wind->owner, WM_FULLED, 0, wind->handle, 0, 0, 0, 0);
@@ -34,7 +34,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_full);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/getinfo.c /h/xaaes/getinfo.c
--- /i/newitems/XaAES.beta2/src/getinfo.c	Thu Feb  1 03:30:56 1996
+++ /h/xaaes/getinfo.c	Wed Feb 21 21:32:30 1996
@@ -58,13 +58,13 @@
 
 	if ((ex==0xffff)||(ex==0xfffe))
 	{
-		pb->intout[0]=(((unsigned long)pb->addrin[0]))&0xffff;	// In XaAES AES id == MiNT pid
+		pb->intout[0]=(short)(((unsigned long)pb->addrin[0]))&0xffff;	/* In XaAES AES id == MiNT pid*/
 		return TRUE;
 	}
 	
 	if (!ex)
 	{
-		pb->intout[0]=menu_bar->owner;		// Return the pid of the app owning the menu?
+		pb->intout[0]=menu_bar->owner;		/* Return the pid of the app owning the menu?*/
 		return TRUE;
 	}
 	
@@ -72,7 +72,7 @@
 	{
 		for(f=0; f<MAX_PID; f++)
 		{
-			if (clients[f].clnt_pipe_rd)	// Client active?
+			if (clients[f].clnt_pipe_rd)	/* Client active?*/
 			{
 				t=clients[f].proc_name;
 				for(n=0; (n<8)&&(name[n]==t[n]); n++);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/graf_box.c /h/xaaes/graf_box.c
--- /i/newitems/XaAES.beta2/src/graf_box.c	Wed Jan 31 22:45:16 1996
+++ /h/xaaes/graf_box.c	Wed Feb 21 21:32:44 1996
@@ -11,6 +11,7 @@
 #include "K_DEFS.H"
 #include "XA_GLOBL.H"
 #include "DRAG_BOX.H"
+#include "watchbox.h"
 
 /*
 	INTERFACE TO INTERACTIVE BOX ROUTINES
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/graf_mou.c /h/xaaes/graf_mou.c
--- /i/newitems/XaAES.beta2/src/graf_mou.c	Sun Feb 18 21:35:26 1996
+++ /h/xaaes/graf_mou.c	Wed Feb 21 21:39:10 1996
@@ -12,6 +12,13 @@
 #include "XA_GLOBL.H"
 #include "GRAF_MOU.H"
 
+/* Lattice's binding of vsc_form is incompatible to the DRI prototype,
+ * so for other compilers we this #define
+ */
+#ifndef LATTICE
+#define vsc_form(h, p)	vsc_form(h, (short *)(p))
+#endif
+
 /* Mouse definition block - standard GEM arrow */
 
 MFORM M_ARROW_MOUSE =
@@ -232,42 +239,42 @@
 		case USER_DEF:
 			vsc_form(V_handle, mf);
 			return;
-		case XACRS_BUBBLE_DISC:		// The Data Uncertain logo
+		case XACRS_BUBBLE_DISC:		/* The Data Uncertain logo*/
 			vsc_form(V_handle, &M_BUBD_MOUSE);
 			return;
-		case XACRS_RESIZER:			// The 'resize window' cursor
+		case XACRS_RESIZER:			/* The 'resize window' cursor*/
 			vsc_form(V_handle, &M_SIZER_MOUSE);
 			return;
-		case XACRS_MOVER:			// The 'move window' cursor
+		case XACRS_MOVER:			/* The 'move window' cursor*/
 			vsc_form(V_handle, &M_MOVER_MOUSE);
 			return;
 	}
 	DIAGS(("WARNING: graf_mouse() - unknown mouseshape '%d'\n",m_shape));
 }
 
-// Slight differance from GEM here - each application can have a different mouse form,
-// and the one that is used is for the client with the top window.
-// A non-top application can still hide & show the mouse though, to ensure that redraws
-// are done correctly
+/* Slight differance from GEM here - each application can have a different mouse form,*/
+/* and the one that is used is for the client with the top window.*/
+/* A non-top application can still hide & show the mouse though, to ensure that redraws*/
+/* are done correctly*/
 short XA_graf_mouse(short clnt_pid, AESPB *pb)
 {
 	short m=pb->intin[0];
 
-// Store the mouse shape requested if this isn't a turn on/off request.
+/* Store the mouse shape requested if this isn't a turn on/off request.*/
 	if ((m!=M_OFF)&&(m!=M_ON))
 	{
 		clients[clnt_pid].client_mouse=m;
 		clients[clnt_pid].client_mouse_form=(MFORM*)(pb->addrin[0]);	
-// Only actually set the cursor shape if the top window is our client's 
-// or there are no windows open at all
+/* Only actually set the cursor shape if the top window is our client's */
+/* or there are no windows open at all*/
 		if ((window_list==NULL)||(window_list->owner==clnt_pid))
 			graf_mouse(m, (MFORM*)(pb->addrin[0]));
 	}else{
-		graf_mouse(m, NULL);	// Any client can hide the mouse (required for redraws by clients
-								// that aren't top)
+		graf_mouse(m, NULL);	/* Any client can hide the mouse (required for redraws by clients*/
+								/* that aren't top)*/
 	}
 
-// Always return no error
+/* Always return no error*/
 	pb->intout[0]=1;
 
 	return TRUE;
@@ -275,7 +282,7 @@
 
 short XA_graf_handle(short clnt_pid, AESPB *pb)
 {
-	pb->intout[0]=P_handle;		// graf_handle returns the physical workstation handle
+	pb->intout[0]=P_handle;		/* graf_handle returns the physical workstation handle*/
 	pb->intout[1]=0;
 	pb->intout[2]=0;
 	pb->intout[3]=display.c_max_w;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/graf_mou.h /h/xaaes/graf_mou.h
--- /i/newitems/XaAES.beta2/src/graf_mou.h	Fri Oct 27 02:21:38 1995
+++ /h/xaaes/graf_mou.h	Wed Feb 21 14:40:12 1996
@@ -4,8 +4,8 @@
 #include <VDI.H>
 #include "K_DEFS.H"
 
-extern short user_mouse;		// User set mouse (whatever was last set with graf_mouse)
-extern MFORM *user_mouse_form;	// - used to restore cursor after window drags, etc
+extern short user_mouse;		/* User set mouse (whatever was last set with graf_mouse)*/
+extern MFORM *user_mouse_form;	/* - used to restore cursor after window drags, etc*/
 
 void graf_mouse(short m_shape, MFORM *mf);
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/grafgrow.c /h/xaaes/grafgrow.c
--- /i/newitems/XaAES.beta2/src/grafgrow.c	Wed Jan 31 23:34:38 1996
+++ /h/xaaes/grafgrow.c	Wed Feb 21 13:44:40 1996
@@ -34,7 +34,7 @@
 
 	v_hide_c(V_handle);
 
-	for(f=0; f<GRAF_STEPS; f++)			// Draw initial growing outline
+	for(f=0; f<GRAF_STEPS; f++)			/* Draw initial growing outline*/
 	{
 		draw_2d_box(x, y, w, h, 1, BLACK);
 		x+=dx; y+=dy;
@@ -42,12 +42,12 @@
 		if (f%2) Vsync();
 	}
 	
-	x=pb->intin[0];						// reset to initial area
+	x=pb->intin[0];						/* reset to initial area*/
 	y=pb->intin[1];
 	w=pb->intin[2];
 	h=pb->intin[3];
 
-	for(f=0; f<GRAF_STEPS; f++)			// Erase growing outline
+	for(f=0; f<GRAF_STEPS; f++)			/* Erase growing outline*/
 	{
 		draw_2d_box(x, y, w, h, 1, BLACK);
 		x+=dx; y+=dy;
@@ -82,17 +82,17 @@
 
 	v_hide_c(V_handle);
 
-	for(f=0; f<GRAF_STEPS; f++)		// Draw initial images
+	for(f=0; f<GRAF_STEPS; f++)		/* Draw initial images*/
 	{
 		draw_2d_box(x, y, w, h, 1, BLACK);
 		x+=dx; y+=dy;
 		if (f%2) Vsync();
 	}
 	
-	x=pb->intin[2];					// Reset to go back over same area
+	x=pb->intin[2];					/* Reset to go back over same area*/
 	y=pb->intin[3];
 
-	for(f=0; f<GRAF_STEPS; f++)		// Erase them again
+	for(f=0; f<GRAF_STEPS; f++)		/* Erase them again*/
 	{
 		draw_2d_box(x, y, w, h, 1, BLACK);
 		x+=dx; y+=dy;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/handler.c /h/xaaes/handler.c
--- /i/newitems/XaAES.beta2/src/handler.c	Mon Feb 19 13:36:56 1996
+++ /h/xaaes/handler.c	Thu Feb 22 16:00:00 1996
@@ -45,6 +45,7 @@
 */
 
 
+#include <stdio.h>
 #include <OSBIND.H>
 #include <MINTBIND.H>
 #include <FILESYS.H>
@@ -75,18 +76,18 @@
 	switch(pb->contrl[0])
 	{
 		case XA_APPL_INIT:
-			XA_appl_init(pb);					// Call appl_init directly
+			XA_appl_init(pb);					/* Call appl_init directly*/
 			return AES_MAGIC;
 			break;
 		case XA_APPL_EXIT:
-			XA_appl_exit(pb->intout);			// Call appl_exit directly
+			XA_appl_exit(pb->intout);			/* Call appl_exit directly*/
 			return AES_MAGIC;
 			break;
 		default:
 			break;
 	}
 	
-	if (Kcall_direct[pb->contrl[0]])	// Call direct?
+	if (Kcall_direct[pb->contrl[0]])	/* Call direct?*/
 	{
 		short rtn_mode,cmd_rtn,clnt_pid=Pgetpid();
 		unsigned long reply_s;
@@ -96,7 +97,7 @@
 		{
 			AESroutine cmd_routine=Ktable[pb->contrl[0]];
 
-			if (cmd_routine)		// If opcode was implemented, call it
+			if (cmd_routine)		/* If opcode was implemented, call it*/
 			{
 				cmd_rtn=(*cmd_routine)(clnt_pid,pb);
 				rtn_mode=cmd_rtn&0xf;
@@ -111,7 +112,7 @@
 						reply_s=1L<<clients[clnt_pid].clnt_pipe_rd;
 						timeout=cmd_rtn&XAC_TVAL;
 						
-						cmd_rtn=Fselect(timeout,&reply_s,NULL,NULL);
+						cmd_rtn=Fselect(timeout,(long *)&reply_s,NULL,NULL);
 
 						Psemaphore(2,CLIENTS_SEMAPHORE,-1L);
 						
@@ -137,7 +138,7 @@
 			}
 		}
 
-	}else{		// Nope, go through the pipes messaging system instead...
+	}else{		/* Nope, go through the pipes messaging system instead...*/
 
 
 		short rtn_mode,cmd_rtn,clnt_pid=Pgetpid();
@@ -146,19 +147,19 @@
 
 		Psemaphore(2,TRAP_HANDLER_SEMAPHORE,-1L);
 
-		client_request.pid=clnt_pid;	// Build command packet
+		client_request.pid=clnt_pid;	/* Build command packet*/
 		client_request.cmd=c;
 		client_request.pb=pb;
 
-		Fwrite(AES_in_pipe_clnt, (long)sizeof(K_CMD_PACKET), &client_request);	// Send command packet
+		Fwrite(AES_in_pipe_clnt, (long)sizeof(K_CMD_PACKET), &client_request);	/* Send command packet*/
 
 		Psemaphore(3,TRAP_HANDLER_SEMAPHORE,0);
 
-		if (c!=AESCMD_STD) 				// Unless we are doing standard GEM style AES calls, return 
-			return AES_in_pipe_clnt;	// here.
+		if (c!=AESCMD_STD) 				/* Unless we are doing standard GEM style AES calls, return */
+			return AES_in_pipe_clnt;	/* here.*/
 
-// OK, here we are in blocking AES call mode (standard GEM) - so we handle the reply pipe
-// on behalf of the client.
+/* OK, here we are in blocking AES call mode (standard GEM) - so we handle the reply pipe*/
+/* on behalf of the client.*/
 
 		Fread(clients[clnt_pid].clnt_pipe_rd,sizeof(short),&dummy);
 		
@@ -177,7 +178,7 @@
 
 					reply_s=1L<<clients[clnt_pid].clnt_pipe_rd;
 					
-					cmd_rtn=Fselect(timeout,&reply_s,NULL,NULL);
+					cmd_rtn=Fselect(timeout,(long *)&reply_s,NULL,NULL);
 					
 					Psemaphore(2,CLIENTS_SEMAPHORE,-1L);
 
@@ -218,18 +219,18 @@
 	printf("- XaAES hooking into trap vector %d at location %lx\n",
 			AES_TRAP, (0x20+AES_TRAP)*4L);
 
-	old_ssp=Super((void*)NULL);		// Enter Supervisor mode
+	old_ssp=(void *)Super((void*)NULL);		/* Enter Supervisor mode*/
 	/* We want to do this with task switching disabled in order
 		to prevent a possible race condition... */
 	old_trap2_vector = Setexc(0x20+AES_TRAP, (void*)handler) ;
-	Super(old_ssp);					// Back to User Mode
+	Super(old_ssp);					/* Back to User Mode*/
 }
 
 void unhook_from_vector(void)
 {
 	void *old_ssp;
  
-	old_ssp=Super((void*)NULL);
+	old_ssp=(void *)Super((void*)NULL);
 	Setexc(0x20+AES_TRAP, old_trap2_vector) ;
 	Super(old_ssp);
 	/* Note: the above code unhooks all TSRs started after XaAES, too -
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/infowidg.c /h/xaaes/infowidg.c
--- /i/newitems/XaAES.beta2/src/infowidg.c	Wed Dec 13 00:52:00 1995
+++ /h/xaaes/infowidg.c	Wed Feb 21 13:44:42 1996
@@ -26,7 +26,7 @@
 {
 	short x,y,pnt[6];
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	vsl_color(V_handle,display.dial_colours.b_r_col);
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/k_defs.h /h/xaaes/k_defs.h
--- /i/newitems/XaAES.beta2/src/k_defs.h	Tue Feb 13 01:55:48 1996
+++ /h/xaaes/k_defs.h	Wed Feb 21 18:30:44 1996
@@ -13,6 +13,21 @@
 #ifndef _K_DEFS_H_
 #define _K_DEFS_H_
 
+#ifdef __PUREC__
+#define far
+#define __regargs
+#define __saveds
+#define short	int
+
+/* Switch off some of PC's warning messages */
+#pragma warn -aus	/* 'foo' is assigned a value which is never used */
+#pragma warn -rch	/* Unreachable code */
+#pragma warn -stv	/* Structure passed by value */
+#pragma warn -use	/* 'foo' declared but never used */
+#pragma warn -cln	/* Constant is long */
+#pragma warn -par	/* Parameter 'foo' is never used */
+#endif /* __PUREC__ */
+
 #include "XA_DEFS.H"
 
 /* Event library definitions */
@@ -30,9 +45,9 @@
 
 #define MN_SELECTED	10
 
-#define SCR_MGR     0x0001	// process id of the screen manager - this is redundant
-							// and will probably require a kludge to redirect it to the
-							// 'real' desktop (check the AVSERVER variable?)
+#define SCR_MGR     0x0001	/* process id of the screen manager - this is redundant*/
+							/* and will probably require a kludge to redirect it to the*/
+							/* 'real' desktop (check the AVSERVER variable?)*/
 #define AP_MSG           0
 
 #define WM_REDRAW	20
@@ -48,7 +63,7 @@
 #define WM_UNTOPPED	30
 #define WM_ONTOP	31
 #define WM_OFFTOP	32
-#define PR_FINISH	33		// What is PR_FINISH? It has the same number as WM_BOTTOMED...
+#define PR_FINISH	33		/* What is PR_FINISH? It has the same number as WM_BOTTOMED...*/
 #define WM_BOTTOMED	33
 
 #define WM_ICONIFY			34
@@ -71,7 +86,7 @@
 #define CT_NEWTOP	52
 #define CT_KEY		53
 
-// Drag'n'Drop
+/* Drag'n'Drop*/
 #define AP_DRAGDROP			63
 #define	DD_OK				0
 #define DD_NAK				1
@@ -215,21 +230,21 @@
 	char *te_ptmplt;
 	char *te_pvalid;
 	short te_font;
-	short te_fontid;		// AES 4.1 extension
+	short te_fontid;		/* AES 4.1 extension*/
 	short te_just;
 	short te_color;
-	short te_fontsize;		// AES 4.1 extension
+	short te_fontsize;		/* AES 4.1 extension*/
 	short te_thickness;
 	short te_txtlen;
 	short te_tmplen;
 } TEDINFO;
 
-// AES 4.1 extended te_font types
-#define TE_GDOS_PROP	0	// Use a proportional SPEEDOGDOS font
-#define TE_GDOS_MONO	1	// Use a monospaced SPEEDOGDOS font
-#define TE_GDOS_BITM	2	// Use a GDOS bitmap font
-#define TE_STANDARD		3	// Use the standard system font (10 point)
-#define TE_SMALL		5	// Use the small syatem font (8 point)
+/* AES 4.1 extended te_font types*/
+#define TE_GDOS_PROP	0	/* Use a proportional SPEEDOGDOS font*/
+#define TE_GDOS_MONO	1	/* Use a monospaced SPEEDOGDOS font*/
+#define TE_GDOS_BITM	2	/* Use a GDOS bitmap font*/
+#define TE_STANDARD		3	/* Use the standard system font (10 point)*/
+#define TE_SMALL		5	/* Use the small syatem font (8 point)*/
 
 typedef struct icon_block
 {
@@ -383,11 +398,11 @@
 #define SMALLER		0x4000
 
 /* Extended XaAES Attributes */
-#define STORE_BACK	0x80000000L	// Store the background of a window & don't generate redraw 
-								// messages to windows below
-#define NO_WORK		0x40000000L	// A window with no work area
-#define NO_REDRAWS	0x20000000L	// Don't generate WM_REDRAW messages to the owner app
-#define NO_MESSAGES	0x30000000L	// Don't generate any messages at all to the owner app
+#define STORE_BACK	0x80000000L	/* Store the background of a window & don't generate redraw */
+								/* messages to windows below*/
+#define NO_WORK		0x40000000L	/* A window with no work area*/
+#define NO_REDRAWS	0x20000000L	/* Don't generate WM_REDRAW messages to the owner app*/
+#define NO_MESSAGES	0x30000000L	/* Don't generate any messages at all to the owner app*/
 
 
 
@@ -429,7 +444,7 @@
 #define FOCUS_MOUSE				1
 #define FOCUS_FIELD				2
 
-// XaAES extensions
+/* XaAES extensions*/
 #define WF_XAWIDGET	100
 
 #define	END_UPDATE	0
@@ -505,7 +520,7 @@
 	unsigned short rsh_rssize;	/* total bytes in resource */
 } RSHDR;
 
-// AES parameter block
+/* AES parameter block*/
 typedef struct {
 	short *contrl;
 	short *globl;
@@ -515,7 +530,7 @@
 	void  **addrout;
 } AESPB;
 
-// Extended Shell Write structure
+/* Extended Shell Write structure*/
 typedef struct _shelw {
 	char *newcmd;
 	long psetlimit;
@@ -536,29 +551,29 @@
 #pragma inline d0=call_aes(d0,d1) {"4E42";}
 #endif
 
-// Menu bar install/remove codes
+/* Menu bar install/remove codes*/
 #define MENU_REMOVE		0
 #define MENU_INSTALL	1
 #define MENU_INQUIRE	-1
 
-//------------------------------------------------------------
-// SPECIAL XaAES stuff
+/*------------------------------------------------------------*/
+/* SPECIAL XaAES stuff*/
 
-// AES Command types
-#define AESCMD_STD		0xc8		// Standard blocking AES call (process blocks for reply)
-#define AESCMD_TEST		0xc9		// The 'secret' test for installed AES call
-#define AESCMD_NOREPLY	0xca		// Process isn't interested in reply so don't give one
-#define AESCMD_NOBLOCK	0xcb		// Don't block for reply, but place in process reply pipe
-									// -process is handling it's own reply pipe
-#define VDICMD_STD		79			// The trap was a VDI trap, so call the old vector instead
-
-// Mouse Handler Fake Process
-#define XAPID_MOUSE		0			// As MiNT is always pid 0 and won't send XaAES any
-									// commands, I use id 0 to fake up a mouse server process
-
-// Extra mouse forms
-#define XACRS_BUBBLE_DISC	258		// The Data Uncertain logo
-#define XACRS_RESIZER		259		// The 'resize window' cursor
-#define XACRS_MOVER			260		// The 'move window' cursor
+/* AES Command types*/
+#define AESCMD_STD		0xc8		/* Standard blocking AES call (process blocks for reply)*/
+#define AESCMD_TEST		0xc9		/* The 'secret' test for installed AES call*/
+#define AESCMD_NOREPLY	0xca		/* Process isn't interested in reply so don't give one*/
+#define AESCMD_NOBLOCK	0xcb		/* Don't block for reply, but place in process reply pipe*/
+									/* -process is handling it's own reply pipe*/
+#define VDICMD_STD		79			/* The trap was a VDI trap, so call the old vector instead*/
+
+/* Mouse Handler Fake Process*/
+#define XAPID_MOUSE		0			/* As MiNT is always pid 0 and won't send XaAES any*/
+									/* commands, I use id 0 to fake up a mouse server process*/
+
+/* Extra mouse forms*/
+#define XACRS_BUBBLE_DISC	258		/* The Data Uncertain logo*/
+#define XACRS_RESIZER		259		/* The 'resize window' cursor*/
+#define XACRS_MOVER			260		/* The 'move window' cursor*/
 
 #endif
\ No newline at end of file
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/kernal.c /h/xaaes/kernal.c
--- /i/newitems/XaAES.beta2/src/kernal.c	Mon Feb 19 14:14:52 1996
+++ /h/xaaes/kernal.c	Thu Feb 22 21:04:54 1996
@@ -8,7 +8,11 @@
 #include <OSBIND.H>
 #include <FILESYS.H>
 #include <MINTBIND.H>
+#ifdef __PUREC__
+#include <sys\types.h>
+#else
 #include <sys/types.h>
+#endif
 #include "K_DEFS.H"
 #include "KERNAL.H"
 #include "XA_GLOBL.H"
@@ -38,6 +42,7 @@
 #include "SCRAP.H"
 #include "op_names.h"
 #include "APP_MAN.H"
+#include "appl_msg.h"
 
 far AESroutine Ktable[300];		/* The main AES kernal command jump table */
 far short Kcall_direct[300];	/* array of flags to indicate that routines should be direct called */
@@ -80,10 +85,10 @@
 		input_channels|=1L<<AES_in_pipe;
 		input_channels|=1L<<MOUSE_in_pipe;
 
-		fs_rtn=Fselect(2000,&input_channels,NULL,NULL);	/* Block via select() on the console & the */
+		fs_rtn=Fselect(2000,(long *)&input_channels,NULL,NULL);	/* Block via select() on the console & the */
 														/* AES command pipe. */
 		
-		if (!fs_rtn)	// Timeout - do some housekeeping
+		if (!fs_rtn)	/* Timeout - do some housekeeping*/
 		{
 		
 			find_dead_clients();
@@ -103,7 +108,7 @@
 		
 			if (input_channels&(1L<<AES_in_pipe))		/* Did we get a command message? */
 			{
-				r=Fread(AES_in_pipe, (long)sizeof(short), &clnt_pid);	/* pid of the client sending the command */
+				r=(short)Fread(AES_in_pipe, (long)sizeof(short), &clnt_pid);	/* pid of the client sending the command */
 
 /* Quick check here to get round a bug in MiNT's Fselect when used with pipes (sometimes a pipe may be reported
    as having data ready for reading, when in-fact it hasn't). */
@@ -180,105 +185,107 @@
 /* appl_ class functions */
 	Ktable[XA_APPL_INIT]=NULL;
 	Ktable[XA_APPL_EXIT]=NULL;
-	Ktable[XA_APPL_GETINFO]=&XA_appl_getinfo;
-	Ktable[XA_APPL_FIND]=&XA_appl_find;
+	Ktable[XA_APPL_READ]=NULL;
+	Ktable[XA_APPL_WRITE]=XA_appl_write;
+	Ktable[XA_APPL_GETINFO]=XA_appl_getinfo;
+	Ktable[XA_APPL_FIND]=XA_appl_find;
 
 /* Form handlers (form_ xxxx) */
-	Ktable[XA_FORM_ALERT]=&XA_form_alert;
-	Ktable[XA_FORM_ERROR]=&XA_form_error;
-	Ktable[XA_FORM_CENTER]=&XA_form_center;
-	Ktable[XA_FORM_DIAL]=&XA_form_dial;
-	Ktable[XA_FORM_BUTTON]=&XA_form_button;
-	Ktable[XA_FORM_DO]=&XA_form_do;
+	Ktable[XA_FORM_ALERT]=XA_form_alert;
+	Ktable[XA_FORM_ERROR]=XA_form_error;
+	Ktable[XA_FORM_CENTER]=XA_form_center;
+	Ktable[XA_FORM_DIAL]=XA_form_dial;
+	Ktable[XA_FORM_BUTTON]=XA_form_button;
+	Ktable[XA_FORM_DO]=XA_form_do;
 	CALL_DIRECT(XA_FORM_CENTER);
 
 /* Event handlers (evnt_ xxx) */
-	Ktable[XA_EVNT_BUTTON]=&XA_evnt_button;
-	Ktable[XA_EVNT_KEYBD]=&XA_evnt_keybd;
-	Ktable[XA_EVNT_MESAG]=&XA_evnt_mesag;
-	Ktable[XA_EVNT_MULTI]=&XA_evnt_multi;
-	Ktable[XA_EVNT_TIMER]=&XA_evnt_timer;
+	Ktable[XA_EVNT_BUTTON]=XA_evnt_button;
+	Ktable[XA_EVNT_KEYBD]=XA_evnt_keybd;
+	Ktable[XA_EVNT_MESAG]=XA_evnt_mesag;
+	Ktable[XA_EVNT_MULTI]=XA_evnt_multi;
+	Ktable[XA_EVNT_TIMER]=XA_evnt_timer;
 	CALL_DIRECT(XA_EVNT_BUTTON);
 	CALL_DIRECT(XA_EVNT_KEYBD);
 /*	CALL_DIRECT(XA_EVNT_MESAG);*/
 
 /* graf_ class functions */
-	Ktable[XA_GRAF_RUBBERBOX]=&XA_graf_rubberbox;
-	Ktable[XA_GRAF_DRAGBOX]=&XA_graf_dragbox;
-	Ktable[XA_GRAF_HANDLE]=&XA_graf_handle;
-	Ktable[XA_GRAF_MOUSE]=&XA_graf_mouse;
-	Ktable[XA_GRAF_MKSTATE]=&XA_graf_mkstate;
-	Ktable[XA_GRAF_GROWBOX]=&XA_graf_growbox;
-	Ktable[XA_GRAF_SHRINKBOX]=&XA_graf_growbox;
-	Ktable[XA_GRAF_MOVEBOX]=&XA_graf_movebox;
-	Ktable[XA_GRAF_WATCHBOX]=&XA_graf_watchbox;
+	Ktable[XA_GRAF_RUBBERBOX]=XA_graf_rubberbox;
+	Ktable[XA_GRAF_DRAGBOX]=XA_graf_dragbox;
+	Ktable[XA_GRAF_HANDLE]=XA_graf_handle;
+	Ktable[XA_GRAF_MOUSE]=XA_graf_mouse;
+	Ktable[XA_GRAF_MKSTATE]=XA_graf_mkstate;
+	Ktable[XA_GRAF_GROWBOX]=XA_graf_growbox;
+	Ktable[XA_GRAF_SHRINKBOX]=XA_graf_growbox;
+	Ktable[XA_GRAF_MOVEBOX]=XA_graf_movebox;
+	Ktable[XA_GRAF_WATCHBOX]=XA_graf_watchbox;
 	CALL_DIRECT(XA_GRAF_HANDLE);
 	CALL_DIRECT(XA_GRAF_MOUSE);
 	CALL_DIRECT(XA_GRAF_MKSTATE);
 
 /* Window Handling (wind_ xxxx) */
-	Ktable[XA_WIND_CREATE]=&XA_wind_create;
-	Ktable[XA_WIND_OPEN]=&XA_wind_open;
-	Ktable[XA_WIND_CLOSE]=&XA_wind_close;
-	Ktable[XA_WIND_SET]=&XA_wind_set;
-	Ktable[XA_WIND_GET]=&XA_wind_get;
-	Ktable[XA_WIND_FIND]=&XA_wind_find;
-	Ktable[XA_WIND_UPDATE]=&XA_wind_update;
-	Ktable[XA_WIND_DELETE]=&XA_wind_delete;
-	Ktable[XA_WIND_NEW]=&XA_wind_new;
-	Ktable[XA_WIND_CALC]=&XA_wind_calc;
+	Ktable[XA_WIND_CREATE]=XA_wind_create;
+	Ktable[XA_WIND_OPEN]=XA_wind_open;
+	Ktable[XA_WIND_CLOSE]=XA_wind_close;
+	Ktable[XA_WIND_SET]=XA_wind_set;
+	Ktable[XA_WIND_GET]=XA_wind_get;
+	Ktable[XA_WIND_FIND]=XA_wind_find;
+	Ktable[XA_WIND_UPDATE]=XA_wind_update;
+	Ktable[XA_WIND_DELETE]=XA_wind_delete;
+	Ktable[XA_WIND_NEW]=XA_wind_new;
+	Ktable[XA_WIND_CALC]=XA_wind_calc;
 	CALL_DIRECT(XA_WIND_FIND);
 /*	CALL_DIRECT(XA_WIND_GET);*/
 	Kcall_direct[XA_WIND_UPDATE]=TRUE;	/* wind_update must ALWAYS be call direct
 											as it uses semaphore locking */
 
 /* Object Tree Handling (objc_ xxxx) */
-	Ktable[XA_OBJC_DRAW]=&XA_objc_draw;
-	Ktable[XA_OBJC_FIND]=&XA_objc_find;
-	Ktable[XA_OBJC_OFFSET]=&XA_objc_offset;
-	Ktable[XA_OBJC_CHANGE]=&XA_objc_change;
+	Ktable[XA_OBJC_DRAW]=XA_objc_draw;
+	Ktable[XA_OBJC_FIND]=XA_objc_find;
+	Ktable[XA_OBJC_OFFSET]=XA_objc_offset;
+	Ktable[XA_OBJC_CHANGE]=XA_objc_change;
 	CALL_DIRECT(XA_OBJC_DRAW);
 	CALL_DIRECT(XA_OBJC_FIND);
 	CALL_DIRECT(XA_OBJC_OFFSET);
 	CALL_DIRECT(XA_OBJC_CHANGE);
 	
 /* Resource Handling */
-	Ktable[XA_RSRC_LOAD]=&XA_rsrc_load;
-	Ktable[XA_RSRC_FREE]=&XA_rsrc_free;
-	Ktable[XA_RSRC_GADDR]=&XA_rsrc_gaddr;
-	Ktable[XA_RSRC_OBFIX]=&XA_rsrc_obfix;
+	Ktable[XA_RSRC_LOAD]=XA_rsrc_load;
+	Ktable[XA_RSRC_FREE]=XA_rsrc_free;
+	Ktable[XA_RSRC_GADDR]=XA_rsrc_gaddr;
+	Ktable[XA_RSRC_OBFIX]=XA_rsrc_obfix;
 	CALL_DIRECT(XA_RSRC_GADDR);
 	CALL_DIRECT(XA_RSRC_OBFIX);
 
 /* Menu Bar Handling */
-	Ktable[XA_MENU_BAR]=&XA_menu_bar;
-	Ktable[XA_MENU_TNORMAL]=&XA_menu_tnormal;
-	Ktable[XA_MENU_ICHECK]=&XA_menu_icheck;
-	Ktable[XA_MENU_IENABLE]=&XA_menu_ienable;
-	Ktable[XA_MENU_TEXT]=&XA_menu_text;
-	Ktable[XA_MENU_REGISTER]=&XA_menu_register;
+	Ktable[XA_MENU_BAR]=XA_menu_bar;
+	Ktable[XA_MENU_TNORMAL]=XA_menu_tnormal;
+	Ktable[XA_MENU_ICHECK]=XA_menu_icheck;
+	Ktable[XA_MENU_IENABLE]=XA_menu_ienable;
+	Ktable[XA_MENU_TEXT]=XA_menu_text;
+	Ktable[XA_MENU_REGISTER]=XA_menu_register;
 	CALL_DIRECT(XA_MENU_TNORMAL);
 	CALL_DIRECT(XA_MENU_ICHECK);
 	CALL_DIRECT(XA_MENU_IENABLE);
 
 /* Shell  */
-	Ktable[XA_SHELL_WRITE]=&XA_shell_write;
-	Ktable[XA_SHELL_READ]=&XA_shell_read;
-	Ktable[XA_SHELL_FIND]=&XA_shell_find;
-	Ktable[XA_SHELL_ENVRN]=&XA_shell_envrn;
+	Ktable[XA_SHELL_WRITE]=XA_shell_write;
+	Ktable[XA_SHELL_READ]=XA_shell_read;
+	Ktable[XA_SHELL_FIND]=XA_shell_find;
+	Ktable[XA_SHELL_ENVRN]=XA_shell_envrn;
 
 /* Scrap / Clipboard */
-	Ktable[XA_SCRAP_READ]=&XA_scrap_read;
-	Ktable[XA_SCRAP_WRITE]=&XA_scrap_write;
+	Ktable[XA_SCRAP_READ]=XA_scrap_read;
+	Ktable[XA_SCRAP_WRITE]=XA_scrap_write;
 
 /* XaAES specific AES calls */
-	Ktable[XA_APPL_PIPE]=&XA_appl_pipe;
+	Ktable[XA_APPL_PIPE]=XA_appl_pipe;
 
 /*
   XaAES kernal internal messages - applications should NEVER send these to the kernal,
    they are used internally to pass crucial info from the client pid trap handler to 
    the kernal.
 */
-	Ktable[XA_NEW_CLIENT]=&XA_new_client;
-	Ktable[XA_CLIENT_EXIT]=&XA_client_exit;
+	Ktable[XA_NEW_CLIENT]=XA_new_client;
+	Ktable[XA_CLIENT_EXIT]=XA_client_exit;
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/kernal.h /h/xaaes/kernal.h
--- /i/newitems/XaAES.beta2/src/kernal.h	Thu Feb  1 02:57:52 1996
+++ /h/xaaes/kernal.h	Wed Feb 21 13:46:08 1996
@@ -17,12 +17,12 @@
 void kernal(void);
 void setup_k_function_table(void);
 
-typedef short (*AESroutine)(short clnt_pid,AESPB*);		// All AES command handers are of this type
+typedef short (*AESroutine)(short clnt_pid,AESPB*);		/* All AES command handers are of this type*/
 
-typedef struct {		// Kernal command packet structure
-	short pid;			// client pid
-	unsigned short cmd;	// command code
-	AESPB *pb;			// pointer to AES parameter block
+typedef struct {		/* Kernal command packet structure*/
+	short pid;			/* client pid*/
+	unsigned short cmd;	/* command code*/
+	AESPB *pb;			/* pointer to AES parameter block*/
 } K_CMD_PACKET;
 
 typedef struct {
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/keyboard.c /h/xaaes/keyboard.c
--- /i/newitems/XaAES.beta2/src/keyboard.c	Mon Feb 19 14:08:54 1996
+++ /h/xaaes/keyboard.c	Wed Feb 21 23:22:52 1996
@@ -34,32 +34,32 @@
 	kstate=shift_state;
 	
 #if ALT_CTRL_APP_OPS
-// Check for control+alt+tab, and do an app swap if valid....
+/* Check for control+alt+tab, and do an app swap if valid....*/
 	shift_state&=12;
 	if (shift_state==12)
 	{
 		key=Crawcin();
-		AESkey=(key&0xff)|((key>>8)&0xff00);	// translate the GEMDOS raw data into AES format
+		AESkey=(short)((key&0xff)|((key>>8)&0xff00));	/* translate the GEMDOS raw data into AES format*/
 
 		switch(AESkey)
 		{
-			case 0xf09:			// CTRL+ALT+TAB switches menu bars
+			case 0xf09:			/* CTRL+ALT+TAB switches menu bars*/
 				next_app_menu();
 				return;
 				break;
-			case 0x1312:		// Attempt to recover a hung system
+			case 0x1312:		/* Attempt to recover a hung system*/
 				recover();
 				return;
 				break;
-			case 0x260c:		// Output a list of current clients via DIAGS
+			case 0x260c:		/* Output a list of current clients via DIAGS*/
 				list_apps();
 				return;
 				break;
-			case 0x250b:		// Tidy up after any clients that have died without calling appl_exit()
+			case 0x250b:		/* Tidy up after any clients that have died without calling appl_exit()*/
 				find_dead_clients();
 				return;
 				break;
-			case 0x2004:		// Dump the current system status
+			case 0x2004:		/* Dump the current system status*/
 				status_dump();
 				return;
 				break;
@@ -68,33 +68,33 @@
 #endif
 
 #if POINT_TO_TYPE
-// Keyboard input goes to the application whose window is under the mouse
+/* Keyboard input goes to the application whose window is under the mouse*/
 	w=wind_find(mx,my); 
 
-// If there is no window under the mouse, send to the top window instead
+/* If there is no window under the mouse, send to the top window instead*/
 	if (!w)
 		w=window_list;
 #else
 
-// Keyboard input always goes to the application whose window is on top
+/* Keyboard input always goes to the application whose window is on top*/
 	w=window_list;
 
 #endif
 
 	if (w)
 	{
-		if (!(clients[w->owner].waiting_for&XAWAIT_KEY))	// If window under mouse isn't waiting for keys, maybe the top window is?
+		if (!(clients[w->owner].waiting_for&XAWAIT_KEY))	/* If window under mouse isn't waiting for keys, maybe the top window is?*/
 			w=window_list;
 		
 		Psemaphore(2,CLIENTS_SEMAPHORE,-1L);
 
-		if (clients[w->owner].waiting_for&XAWAIT_KEY)	// If the client owning the window was waiting for a keyboard event, send it
+		if (clients[w->owner].waiting_for&XAWAIT_KEY)	/* If the client owning the window was waiting for a keyboard event, send it*/
 		{
 			key=Crawcin();
-			AESkey=(key&0xff)|((key>>8)&0xff00);	// translate the GEMDOS raw data into AES format
+			AESkey=(short)((key&0xff)|((key>>8)&0xff00));	/* translate the GEMDOS raw data into AES format*/
 
-			if (clients[w->owner].waiting_for&XAWAIT_MULTI)	// If the client is waiting on a multi, the response is 
-			{												// slightly different to the evnt_keybd() response.
+			if (clients[w->owner].waiting_for&XAWAIT_MULTI)	/* If the client is waiting on a multi, the response is */
+			{												/* slightly different to the evnt_keybd() response.*/
 				clients[w->owner].waiting_pb->intout[0]=MU_KEYBD;
 				clients[w->owner].waiting_pb->intout[1]=mx;
 				clients[w->owner].waiting_pb->intout[2]=my;
@@ -105,10 +105,10 @@
 				cancel_evnt_multi(w->owner);
 			}else{
 				clients[w->owner].waiting_pb->intout[0]=AESkey;
-				clients[w->owner].waiting_for=0;	// Now client isn't waiting for anything
+				clients[w->owner].waiting_for=0;	/* Now client isn't waiting for anything*/
 			}
 			
-			Fwrite(clients[w->owner].clnt_pipe_wr,sizeof(short),&retv);	// Write success to clients reply pipe to unblock the process
+			Fwrite(clients[w->owner].clnt_pipe_wr,sizeof(short),&retv);	/* Write success to clients reply pipe to unblock the process*/
 		
 		}
 		
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/menubar.c /h/xaaes/menubar.c
--- /i/newitems/XaAES.beta2/src/menubar.c	Tue Feb 13 01:10:50 1996
+++ /h/xaaes/menubar.c	Wed Feb 21 13:44:46 1996
@@ -35,7 +35,7 @@
 	switch(pb->intin[0])
 	{
 		case MENU_INSTALL:
-			fix_menu((OBJECT*)pb->addrin[0]);	// do a special fix on menu the menu 
+			fix_menu((OBJECT*)pb->addrin[0]);	/* do a special fix on menu the menu */
 			clients[clnt_pid].std_menu=(OBJECT*)pb->addrin[0];
 			menu_bar->tree=(OBJECT*)(pb->addrin[0]);
 			menu_bar->owner=clnt_pid;
@@ -68,12 +68,12 @@
 	XA_WIDGET_TREE *menu_bar=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 	OBJECT *tree=(OBJECT*)pb->addrin[0];
 	
-	if (pb->intin[1])			// Change the highlight / normal status of a menu title
+	if (pb->intin[1])			/* Change the highlight / normal status of a menu title*/
 		tree[pb->intin[0]].ob_state&=~SELECTED;
 	else
 		tree[pb->intin[0]].ob_state|=SELECTED;
 	
-// If we just changed the main root window's menu, better redraw it
+/* If we just changed the main root window's menu, better redraw it*/
 	if ((tree==menu_bar->tree)&&(tree[pb->intin[0]].ob_type==G_TITLE))
 	{
 		v_hide_c(V_handle);
@@ -94,12 +94,12 @@
 	XA_WIDGET_TREE *menu_bar=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 	OBJECT *tree=(OBJECT*)pb->addrin[0];
 	
-	if (pb->intin[1])			// Change the disabled status of a menu item
+	if (pb->intin[1])			/* Change the disabled status of a menu item*/
 		tree[pb->intin[0]].ob_state&=~DISABLED;
 	else
 		tree[pb->intin[0]].ob_state|=DISABLED;
 	
-// If we just changed the main root window's menu, better redraw it
+/* If we just changed the main root window's menu, better redraw it*/
 	if ((tree==menu_bar->tree)&&(tree[pb->intin[0]].ob_type==G_TITLE))
 	{
 		v_hide_c(V_handle);
@@ -119,12 +119,12 @@
 	XA_WIDGET_TREE *menu_bar=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 	OBJECT *tree=(OBJECT*)pb->addrin[0];
 	
-	if (pb->intin[1])			// Change the disabled status of a menu item
+	if (pb->intin[1])			/* Change the disabled status of a menu item*/
 		tree[pb->intin[0]].ob_state|=CHECKED;
 	else
 		tree[pb->intin[0]].ob_state&=~CHECKED;
 	
-// If we just changed the main root window's menu, better redraw it
+/* If we just changed the main root window's menu, better redraw it*/
 	if ((tree==menu_bar->tree)&&(tree[pb->intin[0]].ob_type==G_TITLE))
 	{
 		v_hide_c(V_handle);
@@ -148,7 +148,7 @@
 	
 	tree[pb->intin[0]].ob_spec=(void*)text;
 	
-// If we just changed the main root window's menu, better redraw it
+/* If we just changed the main root window's menu, better redraw it*/
 	if ((tree==menu_bar->tree)&&(tree[pb->intin[0]].ob_type==G_TITLE))
 	{
 		v_hide_c(V_handle);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/messages.c /h/xaaes/messages.c
--- /i/newitems/XaAES.beta2/src/messages.c	Mon Feb 19 13:20:02 1996
+++ /h/xaaes/messages.c	Wed Feb 21 16:56:12 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <MINTBIND.H>
 #include <OSBIND.H>
 #include "XA_DEFS.H"
@@ -24,25 +25,25 @@
 	
 	DIAGS(("XaAES - send AES message :"));
 	
-	if (dest_id==AESpid) 	// Just a precaution - we don't want to send messages to ourselves.....
+	if (dest_id==AESpid) 	/* Just a precaution - we don't want to send messages to ourselves.....*/
 		return;
 
 	Psemaphore(2,CLIENTS_SEMAPHORE,-1L);
 	
-	if (clients[dest_id].waiting_for&XAWAIT_MESSAGE)	// Is the dest client waiting for a message at the moment?
+	if (clients[dest_id].waiting_for&XAWAIT_MESSAGE)	/* Is the dest client waiting for a message at the moment?*/
 	{
 		DIAGS(("immediate send\n"));
-		if (clients[dest_id].waiting_for&XAWAIT_MULTI)	// If the client is waiting on a multi, the response is 
-		{												// slightly different to the evnt_mesag() response.
+		if (clients[dest_id].waiting_for&XAWAIT_MULTI)	/* If the client is waiting on a multi, the response is */
+		{												/* slightly different to the evnt_mesag() response.*/
 			clients[dest_id].waiting_pb->intout[0]=MU_MESAG;
 			cancel_evnt_multi(dest_id);
 		}else{
 			clients[dest_id].waiting_pb->intout[0]=1;
-			clients[dest_id].waiting_for=0;	// flag client as not waiting for anything
+			clients[dest_id].waiting_for=0;	/* flag client as not waiting for anything*/
 		}
 		
 		clnt_buf=(short*)(clients[dest_id].waiting_pb->addrin[0]);
-		clnt_buf[0]=mesg;			// Fill in the clients message buffer
+		clnt_buf[0]=mesg;			/* Fill in the clients message buffer*/
 		clnt_buf[1]=source_id;
 		clnt_buf[2]=0;
 		clnt_buf[3]=a;
@@ -51,13 +52,13 @@
 		clnt_buf[6]=d;
 		clnt_buf[7]=e;
 		
-		Fwrite(clients[dest_id].clnt_pipe_wr, (long)sizeof(short),&retv);	// Write success to clients reply pipe to unblock the process
-	}else{	// Create a new entry in the destination client's pending messages list
+		Fwrite(clients[dest_id].clnt_pipe_wr, (long)sizeof(short),&retv);	/* Write success to clients reply pipe to unblock the process*/
+	}else{	/* Create a new entry in the destination client's pending messages list*/
 		new_msg=(XA_AESMSG_LIST*)malloc(sizeof(XA_AESMSG_LIST));
 		
 		DIAGS(("queueing message["));
 		
-		new_msg->message[0]=mesg;			// Fill in the new pending list entry with the message
+		new_msg->message[0]=mesg;			/* Fill in the new pending list entry with the message*/
 		new_msg->message[1]=source_id;
 		new_msg->message[2]=0;
 		new_msg->message[3]=a;
@@ -67,12 +68,12 @@
 		new_msg->message[7]=e;
 		new_msg->next=NULL;
 
-		if (clients[dest_id].msg)	// There are already some pending messages
+		if (clients[dest_id].msg)	/* There are already some pending messages*/
 		{
 			DIAGS(("append]\n"));
 			for(ml=clients[dest_id].msg; ml->next; ml=ml->next);
-			ml->next=new_msg;	// Append the new message to the list
-		}else{	// First entry in the clients pending message list
+			ml->next=new_msg;	/* Append the new message to the list*/
+		}else{	/* First entry in the clients pending message list*/
 			DIAGS(("new queue]\n"));
 			clients[dest_id].msg=new_msg;
 		}
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/mouse_cl.c /h/xaaes/mouse_cl.c
--- /i/newitems/XaAES.beta2/src/mouse_cl.c	Mon Feb 19 13:20:20 1996
+++ /h/xaaes/mouse_cl.c	Wed Feb 21 23:25:16 1996
@@ -16,13 +16,14 @@
 #include "EVNT_BTN.H"
 #include "C_WINDOW.H"
 #include "EVNT_MUL.H"
+#include "std_widg.h"
 
 /*
 	Mouse button click handler 
 	- MOUSESRV sever process passes us click events
 */
 
-// The real button click handler is here :)
+/* The real button click handler is here :)*/
 short XA_button_event(MOUSE_DATA *md)
 {
 	XA_WINDOW *w;
@@ -32,18 +33,18 @@
 	
 	DIAGS(("MOUSE_CLICK EVENT: \n   loc=(%d,%d), state=%d, count=%d\n",md->mx,md->my,md->state, md->clicks));
 	
-	if (mouse_lock)	// Mouse is locked - clicks go to owner
+	if (mouse_lock)	/* Mouse is locked - clicks go to owner*/
 	{
 		target_app=mouse_lock;
 	}else{
-		w=wind_find(md->mx, md->my);	// Mouse is free - try for a window
+		w=wind_find(md->mx, md->my);	/* Mouse is free - try for a window*/
 		if (w)
 		{
 			target_app=w->owner;
 			DIAGS((" click on window (handle=%d, owner=%d)\n",w->handle,w->owner));
 
 			if (do_widgets(w,md))
-				 return FALSE;	// Process window widgets
+				 return FALSE;	/* Process window widgets*/
 		}else{
 			return FALSE;
 		}
@@ -51,12 +52,12 @@
 
 	Psemaphore(2,CLIENTS_SEMAPHORE,-1L);
 
-	if (clients[target_app].waiting_for&XAWAIT_BUTTON)	// If the client owning was waiting for a button event, send it
-	{													// - otherwise forget it, 'coz we don't want delayed clicks (they are confusing to the user [ie. me] )
-		vq_key_s(V_handle, &kstate);	// get the current keyboard state
+	if (clients[target_app].waiting_for&XAWAIT_BUTTON)	/* If the client owning was waiting for a button event, send it*/
+	{													/* - otherwise forget it, 'coz we don't want delayed clicks (they are confusing to the user [ie. me] )*/
+		vq_key_s(V_handle, &kstate);	/* get the current keyboard state*/
 
-		if (clients[target_app].waiting_for&XAWAIT_MULTI)	// If the client is waiting on a multi, the response is 
-		{												// slightly different to the evnt_button() response.
+		if (clients[target_app].waiting_for&XAWAIT_MULTI)	/* If the client is waiting on a multi, the response is */
+		{												/* slightly different to the evnt_button() response.*/
 			clients[target_app].waiting_pb->intout[0]=MU_BUTTON;
 			clients[target_app].waiting_pb->intout[1]=md->mx;
 			clients[target_app].waiting_pb->intout[2]=md->my;
@@ -70,9 +71,9 @@
 			clients[target_app].waiting_pb->intout[2]=md->my;
 			clients[target_app].waiting_pb->intout[3]=md->clicks;
 			clients[target_app].waiting_pb->intout[4]=kstate;
-			clients[target_app].waiting_for=0;	// Now client isn't waiting for anything
+			clients[target_app].waiting_for=0;	/* Now client isn't waiting for anything*/
 		}
-		Fwrite(clients[target_app].clnt_pipe_wr,sizeof(short),&retv);	// Write success to clients reply pipe to unblock the process
+		Fwrite(clients[target_app].clnt_pipe_wr,sizeof(short),&retv);	/* Write success to clients reply pipe to unblock the process*/
 	}
 
 	Psemaphore(3,CLIENTS_SEMAPHORE,0L);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/new_clnt.c /h/xaaes/new_clnt.c
--- /i/newitems/XaAES.beta2/src/new_clnt.c	Mon Feb 19 01:08:40 1996
+++ /h/xaaes/new_clnt.c	Wed Feb 21 23:26:40 1996
@@ -5,6 +5,8 @@
  *
  */
 
+#include <stdio.h>
+#include <stdlib.h>
 #include <FILESYS.H>
 #include <OSBIND.H>
 #include <MINTBIND.H>
@@ -14,6 +16,7 @@
 #include "C_WINDOW.H"
 #include "SYSTEM.H"
 #include "RESOURCE.H"
+#include "events.h"
 
 /*
 	Open the clients reply pipe in response to an XA_NEW_CLIENT message
@@ -23,26 +26,26 @@
 	char pipe_name[50];
 	char fmt[]="u:\\pipe\\XaClnt.%d\0";
 
-	if (clients[clnt_pid].clnt_pipe_wr)		// Multiple appl_inits? what's going on here then.....
+	if (clients[clnt_pid].clnt_pipe_wr)		/* Multiple appl_inits? what's going on here then.....*/
 	{
 		DIAGS(("New Client - Error: already opened server end?\n"));
 		return FALSE;
 	}
 
-	if (!clients[clnt_pid].clnt_pipe_rd)	// If this occurs, then we've got a problem - fix it with
+	if (!clients[clnt_pid].clnt_pipe_rd)	/* If this occurs, then we've got a problem - fix it with*/
 	{
 		DIAGS(("New Client - Error: client pipe does not exist yet?\n"));
-		clients[clnt_pid].clnt_pipe_rd=Fopen(pipe_name,O_RDONLY|O_GLOBAL);
+		clients[clnt_pid].clnt_pipe_rd=(int)Fopen(pipe_name,O_RDONLY|O_GLOBAL);
 	}
 
-	sprintf(pipe_name,fmt,clnt_pid);							// Open the clients reply pipe for writing to
-	clients[clnt_pid].clnt_pipe_wr=Fopen(pipe_name,O_WRONLY);	// Kernals end of pipe
+	sprintf(pipe_name,fmt,clnt_pid);								/* Open the clients reply pipe for writing to*/
+	clients[clnt_pid].clnt_pipe_wr=(int)Fopen(pipe_name,O_WRONLY);	/* Kernals end of pipe*/
 	clients[clnt_pid].std_menu=ResourceTree(system_resources,SYSTEM_MENU);
 
 	sprintf(clients[clnt_pid].name,"Foreign client ?");
 	sprintf(clients[clnt_pid].proc_name,"XACLIENT");
 
-	return FALSE;	// No reply from this, as the client has already moved on
+	return FALSE;	/* No reply from this, as the client has already moved on*/
 }
 
 /*
@@ -57,11 +60,11 @@
 	XA_AESMSG_LIST *nm,*dnm;
 	XA_WIDGET_TREE *menu_bar=(XA_WIDGET_TREE*)(root_window->widgets[XAW_MENU].stuff);
 
-	Fclose(clients[clnt_pid].clnt_pipe_wr);	// Close the kernal end of client reply pipe
+	Fclose(clients[clnt_pid].clnt_pipe_wr);	/* Close the kernal end of client reply pipe*/
 	clients[clnt_pid].clnt_pipe_wr=0;
 
-// Go through and check that all windows belonging to this client are
-// closed and deleted (in case of sloppy programming).
+/* Go through and check that all windows belonging to this client are*/
+/* closed and deleted (in case of sloppy programming).*/
 	for(wl=window_list; wl;)
 	{
 		if (wl->owner==clnt_pid)
@@ -69,14 +72,14 @@
 			dwl=wl;
 
 			v_hide_c(V_handle);
-			erase_non_topped_window(wl);			// Erase the window
-			redraw_area(wl->x,wl->y,wl->w,wl->h);	// The redraw should really get done here
-			display_windows_below(wl);				// Redisplay any windows below the one we are closing
+			erase_non_topped_window(wl);			/* Erase the window*/
+			redraw_area(wl->x,wl->y,wl->w,wl->h);	/* The redraw should really get done here*/
+			display_windows_below(wl);				/* Redisplay any windows below the one we are closing*/
 			v_show_c(V_handle, 1);
 
 			wl=wl->next;
 			
-			if (window_list==dwl)					// Actually delete the window
+			if (window_list==dwl)					/* Actually delete the window*/
 				window_list=dwl->next;
 
 			if (dwl->prev) dwl->prev->next=dwl->next;
@@ -88,7 +91,7 @@
 		}
 	}
 
-// Dispose of any pending messages for the client
+/* Dispose of any pending messages for the client*/
 	for(nm=clients[clnt_pid].msg; nm;)
 	{
 		dnm=nm;
@@ -97,7 +100,7 @@
 	}
 	clients[clnt_pid].msg=NULL;
 	
-// If the client forgot to remove it's menu bar, better do it now
+/* If the client forgot to remove it's menu bar, better do it now*/
 	if (menu_bar->tree==clients[clnt_pid].std_menu)
 	{
 		menu_bar->tree=ResourceTree(system_resources,SYSTEM_MENU);
@@ -107,7 +110,7 @@
 		v_show_c(V_handle,1);
 	}
 
-// If the client forgot to free it's resources, we do it for them.
+/* If the client forgot to free it's resources, we do it for them.*/
 	if (clients[clnt_pid].std_resource)
 	{
 		FreeResources(clients[clnt_pid].std_resource);
@@ -116,5 +119,5 @@
 	
 	Pwait3(1,NULL);
 	
-	return FALSE;	// No reply from this (good thing, beings as we just closed the reply pipe)
+	return FALSE;	/* No reply from this (good thing, beings as we just closed the reply pipe)*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/objc_drw.c /h/xaaes/objc_drw.c
--- /i/newitems/XaAES.beta2/src/objc_drw.c	Sat Feb 17 19:26:10 1996
+++ /h/xaaes/objc_drw.c	Thu Feb 22 13:06:06 1996
@@ -27,7 +27,7 @@
 	
 	vs_clip(V_handle,1,clip);
 	pb->intout[0]=draw_object_tree(pb->addrin[0],pb->intin[0],pb->intin[1]+1);
-	vs_clip(V_handle,0,NULL);
+	vs_clip(V_handle,0,clip);
 	
 	return TRUE;
 }
@@ -60,7 +60,7 @@
 		clip[3]=clip[1]+pb->intin[5];
 		vs_clip(V_handle,1,clip);
 		draw_object_tree(root,pb->intin[0],pb->intin[1]+1);
-		vs_clip(V_handle,0,NULL);
+		vs_clip(V_handle,0,clip);
 	}
 	
 	pb->intout[0]=1;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/objcwidg.c /h/xaaes/objcwidg.c
--- /i/newitems/XaAES.beta2/src/objcwidg.c	Sat Feb 17 19:25:58 1996
+++ /h/xaaes/objcwidg.c	Thu Feb 22 19:19:06 1996
@@ -5,20 +5,30 @@
  *
  */
 
+#include <stdlib.h>
 #include <OSBIND.H>
 #include <VDI.H>
+#ifndef THICKENED
+/* Lattice C should better use the TF_xxx-constants anyway... */
+#define THICKENED	0x01
+#define SHADED		0x02
+#define SKEWED		0x04
+#define UNDERLINED	0x08
+#define OUTLINE		0x10
+#define SHADOW		0x20
+#endif
 #include "XA_TYPES.H"
 #include "XA_DEFS.H"
 #include "XA_GLOBL.H"
 #include "KERNAL.H"
 #include "K_DEFS.H"
-#include "KERNAL.H"
 #include "GRAF_MOU.H"
 #include "C_WINDOW.H"
 #include "RECTLIST.H"
 #include "BOX3D.H"
 #include "OBJECTS.H"
 #include "MESSAGES.H"
+#include "std_widg.h"
 
 /*
 	Menu Widget display
@@ -34,7 +44,7 @@
 	short menu_text,mty;
 	short mx,my,mb;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	
 	root=w_otree->tree;
 
@@ -49,7 +59,7 @@
 
 	vq_mouse(V_handle, &mb, &mx, &my);
 	
-	while(title!=root[root[0].ob_head].ob_head)		// Display titles
+	while(title!=root[root[0].ob_head].ob_head)		/* Display titles*/
 	{
 		this_t++;
 		if (root[title].ob_state&SELECTED)
@@ -64,7 +74,7 @@
 		title=root[title].ob_next;
 	}
 	
-	if (sel_t!=-1)	// If a menu is selected, display the actual menu
+	if (sel_t!=-1)	/* If a menu is selected, display the actual menu*/
 	{
 		sel_t_menu=root[root[0].ob_tail].ob_head;
 		for(title=0; (title!=sel_t); title++)
@@ -79,11 +89,11 @@
 		
 		for(menu_text=root[sel_t_menu].ob_head; menu_text!=sel_t_menu; menu_text=root[menu_text].ob_next)
 		{
-			if (root[menu_text].ob_state&DISABLED)			// Disabled item?
+			if (root[menu_text].ob_state&DISABLED)			/* Disabled item?*/
 			{
 				vst_effects(V_handle, SHADED);
 			}else{
-				if (root[menu_text].ob_state&SELECTED)		// Selected menu item?
+				if (root[menu_text].ob_state&SELECTED)		/* Selected menu item?*/
 				{
 					XA_3D_rect(menu_x+3,mty-2,root[sel_t_menu].ob_width+4,root[menu_text].ob_height+4,1,0);
 				
@@ -94,7 +104,7 @@
 				}
 			}
 				v_gtext(V_handle, menu_x+5, mty, (char*)root[menu_text].ob_spec);
-				if (root[menu_text].ob_state&CHECKED)	// Display a check mark if needed
+				if (root[menu_text].ob_state&CHECKED)	/* Display a check mark if needed*/
 				v_gtext(V_handle, menu_x+5, mty, "");
 				
 				vst_effects(V_handle, 0);
@@ -114,7 +124,7 @@
 	XA_WIDGET_TREE *w_otree=(XA_WIDGET_TREE*)widg->stuff;
 	OBJECT *root;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	
 	root=w_otree->tree;
 
@@ -151,7 +161,7 @@
 	MFDB Mscreen;
 	MFDB Mpreserve;
 	
-	rp_2_ap(menu_wind, menu_widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(menu_wind, menu_widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	
 	root=w_otree->tree;
 	
@@ -182,20 +192,29 @@
 		Mpreserve.fd_wdwidth=(Mpreserve.fd_w+15)>>4;
 		Mpreserve.fd_nplanes=display.planes;
 		Mpreserve.fd_stand=0;
+#if 0
 		Mpreserve.fd_addr=(void*)malloc(((display.planes*(Mpreserve.fd_w+8))/4)*(Mpreserve.fd_h+8));
+#else
+/* Always remember that the MFDB-members are short, and short * short = short,
+ * which will be converted into a long for the malloc call. Usually, it will
+ * be converted preserving the sign, so that 0x8000 becomes 0xffff8000!
+ * Also consider that short * short may easily no longer fit into a short.
+ */
+		Mpreserve.fd_addr=(void*)malloc((long)Mpreserve.fd_h * (long)Mpreserve.fd_wdwidth * 2L * (long)display.planes);
+#endif
 
 		Mscreen.fd_addr=NULL;
 
 		if (!Mpreserve.fd_addr)
 		{
-			root[clicked_title].ob_state&=~SELECTED;	// Deselect the title
+			root[clicked_title].ob_state&=~SELECTED;	/* Deselect the title*/
 			DIAGS(("ERROR: Cann't allocate memory for menu background\n"));
 			return TRUE;
 		}
 
-		vs_clip(V_handle,0,NULL);			// Menu's are always on top...so don't clip
+		vs_clip(V_handle,0,pxy);			/* Menu's are always on top...so don't clip*/
 
-		pxy[0]=menu_x; pxy[1]=menu_y;					// Preserve background
+		pxy[0]=menu_x; pxy[1]=menu_y;					/* Preserve background*/
 		pxy[2]=menu_x+Mpreserve.fd_w-1; pxy[3]=menu_y+Mpreserve.fd_h-4;
 		pxy[4]=0; pxy[5]=0;
 		pxy[6]=Mpreserve.fd_w-1; pxy[7]=Mpreserve.fd_h-4;
@@ -206,7 +225,7 @@
 		display_menu_widget(menu_wind, menu_widg);
 		v_show_c(V_handle, 1);
 		
-// Do a point-at-and-click menu selection
+/* Do a point-at-and-click menu selection*/
 		do{
 			vq_mouse(V_handle,&mb,&mx,&my);
 			
@@ -217,7 +236,7 @@
 				
 				t=-1;
 
-				if ((mx>menu_x)&&(mx<menu_x+root[selected_menu].ob_width))	// Find pointed at menu entry
+				if ((mx>menu_x)&&(mx<menu_x+root[selected_menu].ob_width))	/* Find pointed at menu entry*/
 				{
 					for(f=root[selected_menu].ob_head; f!=selected_menu; f=root[f].ob_next)
 					{
@@ -228,17 +247,17 @@
 					}
 				}
 
-				if (point_at_menu!=-1)		// De-select current selection (if any)
+				if (point_at_menu!=-1)		/* De-select current selection (if any)*/
 				{
 					root[point_at_menu].ob_state&=~SELECTED;
 				}
 				
-				if (t!=-1)				// Something selected at the moment?
-				{						// Highlight current selection
+				if (t!=-1)				/* Something selected at the moment?*/
+				{						/* Highlight current selection*/
 					root[t].ob_state|=SELECTED;
 				}
 				
-				if (t!=point_at_menu)	// Has the status of the menu changed? if so, redisplay
+				if (t!=point_at_menu)	/* Has the status of the menu changed? if so, redisplay*/
 				{
 					point_at_menu=t;
 					v_hide_c(V_handle);
@@ -248,9 +267,9 @@
 			}
 		}while(!mb);
 
-		root[clicked_title].ob_state&=~SELECTED;	// Deselect the title
+		root[clicked_title].ob_state&=~SELECTED;	/* Deselect the title*/
 
-		pxy[4]=pxy[0]; pxy[5]=pxy[1];				// Restore background
+		pxy[4]=pxy[0]; pxy[5]=pxy[1];				/* Restore background*/
 		pxy[6]=pxy[2]; pxy[7]=pxy[3];
 		pxy[0]=0; pxy[1]=0;
 		pxy[2]=Mpreserve.fd_w-1; pxy[3]=Mpreserve.fd_h-4;
@@ -260,17 +279,17 @@
 		
 		free(Mpreserve.fd_addr);
 		
-		if (point_at_menu!=-1)	// Exitting with a selection - send it
+		if (point_at_menu!=-1)	/* Exitting with a selection - send it*/
 		{
-			root[point_at_menu].ob_state&=~SELECTED;	// Deselect the menu entry
-			if (w_otree->owner!=AESpid)					// If it's a client program menu, send it a little message to say hi....
+			root[point_at_menu].ob_state&=~SELECTED;	/* Deselect the menu entry*/
+			if (w_otree->owner!=AESpid)					/* If it's a client program menu, send it a little message to say hi....*/
 			{
 				send_app_message(w_otree->owner, MN_SELECTED, AESpid, clicked_title, point_at_menu, (short)((long)root>>16), (short)((long)root&0xffff), selected_menu);
-			}		// In the above, note the AES4.0 extended message format......
+			}		/* In the above, note the AES4.0 extended message format......*/
 		}
 	}
 
-	return FALSE;		// Return false so we don't re-display the widget
+	return FALSE;		/* Return false so we don't re-display the widget*/
 }
 
 #ifdef _THREADS_H_
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/objects.c /h/xaaes/objects.c
--- /i/newitems/XaAES.beta2/src/objects.c	Sat Feb 17 19:26:24 1996
+++ /h/xaaes/objects.c	Thu Feb 22 15:34:56 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include "XA_DEFS.H"
 #include "XA_TYPES.H"
 #include "XA_GLOBL.H"
@@ -65,7 +66,7 @@
 	{
 		switch(*template)
 		{
-			case '_':				// Found text field
+			case '_':				/* Found text field*/
 				if (*text_in)
 				{
 					*text_out=*text_in;
@@ -76,7 +77,7 @@
 				text_out++;
 				template++;
 				break;
-			default:				// Formatting characters
+			default:				/* Formatting characters*/
 				*text_out=*template;
 				text_out++;
 				template++;
@@ -110,7 +111,7 @@
 
 	colourword=(OBJC_COLORWORD*)&zap;
 
-	if (ob->ob_state&SHADOWED)				// Are we shadowing this object?
+	if (ob->ob_state&SHADOWED)				/* Are we shadowing this object?*/
 	{
 		vsf_color(V_handle,BLACK);
 		vsf_interior(V_handle, FIS_SOLID);
@@ -121,7 +122,7 @@
 		v_bar(V_handle, coords);
 	}
 
-	if (ob->ob_flags&DEFAULT)				// Default exit object
+	if (ob->ob_flags&DEFAULT)				/* Default exit object*/
 	{
 		vsf_color(V_handle,BLACK);
 		vsf_interior(V_handle, FIS_SOLID);
@@ -132,13 +133,13 @@
 		v_bar(V_handle, coords);
 	}
 
-	switch(t)	// Sort out the colourword
+	switch(t)	/* Sort out the colourword*/
 	{
 		case G_BOXCHAR:
 			temp_text[0]=(ob_spec&0xff000000)>>24;
 			temp_text[1]='\0';
 			zap=(unsigned short)ob->ob_spec&0xffff;
-			border_thick=(ob_spec&0xff0000)>>16;
+			border_thick=(short)((ob_spec&0xff0000)>>16);
 			if (border_thick&128)
 				border_thick=-(1+(border_thick^0xff));
 			colourword->opaque=0;
@@ -147,7 +148,7 @@
 		case G_BOX:
 		case G_IBOX:
 			zap=(unsigned short)ob->ob_spec&0xffff;
-			border_thick=(ob_spec&0xff0000)>>16;
+			border_thick=(short)((ob_spec&0xff0000)>>16);
 			if (border_thick&128)
 				border_thick=-(1+(border_thick^0xff));
 			colourword->opaque=1;
@@ -161,9 +162,9 @@
 			zap=(unsigned short)textblk->te_color;
 			border_thick=textblk->te_thickness;
 			
-			switch(textblk->te_just)			//Set text alignment - why on earth did
-			{									// atari use a different horizontal alignment
-				case 0:							// code for GEM to the one the VDI uses?
+			switch(textblk->te_just)			/*Set text alignment - why on earth did*/
+			{									/* atari use a different horizontal alignment*/
+				case 0:							/* code for GEM to the one the VDI uses?*/
 					vst_alignment(V_handle,0,5,&temp,&temp);
 					break;
 				case 1:
@@ -174,21 +175,21 @@
 					break;
 			}
 			
-			switch(textblk->te_font)	// Set the correct text size & font
+			switch(textblk->te_font)	/* Set the correct text size & font*/
 			{
-				case TE_GDOS_PROP:		// Use a proportional SPEEDOGDOS font (AES4.1 style)
-				case TE_GDOS_MONO:		// Use a monospaced SPEEDOGDOS font (AES4.1 style)
-				case TE_GDOS_BITM:		// Use a GDOS bitmap font (AES4.1 style)
+				case TE_GDOS_PROP:		/* Use a proportional SPEEDOGDOS font (AES4.1 style)*/
+				case TE_GDOS_MONO:		/* Use a monospaced SPEEDOGDOS font (AES4.1 style)*/
+				case TE_GDOS_BITM:		/* Use a GDOS bitmap font (AES4.1 style)*/
 					vst_font(V_handle,textblk->te_fontid);
 					vst_point(V_handle,textblk->te_fontsize,&temp,&temp,&temp,&temp);
 					ty=parent_y + ob->ob_y + ((ob->ob_height-display.c_max_h)/2);
 					break;
-				case TE_STANDARD:		// Use the standard system font (probably 10 point)
+				case TE_STANDARD:		/* Use the standard system font (probably 10 point)*/
 					vst_font(V_handle,STANDARD_AES_FONTID);
 					vst_point(V_handle,STANDARD_FONT_POINT,&temp,&temp,&temp,&temp);
 					ty=parent_y + ob->ob_y + ((ob->ob_height-display.c_max_h)/2);
 					break;
-				case TE_SMALL:			// Use the small syatem font (probably 8 point)
+				case TE_SMALL:			/* Use the small syatem font (probably 8 point)*/
 					vst_font(V_handle,STANDARD_AES_FONTID);
 					vst_point(V_handle,SMALL_FONT_POINT,&temp,&temp,&temp,&temp);
 					ty=parent_y + ob->ob_y + ((ob->ob_height-display.c_min_h)/2);
@@ -212,11 +213,11 @@
 		case G_CICON:
 			ciconblk=(CICONBLK*)ob->ob_spec;
 
-			for(this_cicon=ciconblk->mainlist; 			// Search for a colour icon for this res.
+			for(this_cicon=ciconblk->mainlist; 			/* Search for a colour icon for this res.*/
 				(this_cicon)&&(this_cicon->num_planes!=display.planes); 
 				this_cicon=this_cicon->next_res);
 				
-			if (!this_cicon)							// No matching icon, so use the mono one instead
+			if (!this_cicon)							/* No matching icon, so use the mono one instead*/
 				t=G_ICON;
 			iconblk=(ICONBLK*)ob->ob_spec;
 			break;
@@ -246,7 +247,7 @@
 		if (colourword->pattern==0)
 		{
 			vsf_style(V_handle, 8);
-			if ((colourword->fillc==0)&&(ob->ob_flags&FLD3DANY))	// Object inherits default dialog background colour?
+			if ((colourword->fillc==0)&&(ob->ob_flags&FLD3DANY))	/* Object inherits default dialog background colour?*/
 			{
 				colourword->fillc=display.dial_colours.bg_col;
 			}else{
@@ -259,7 +260,7 @@
 
 	if (selected)
 	{
-		if (ob->ob_flags&FLD3DANY)		// Allow a different colour set for 3d push 
+		if (ob->ob_flags&FLD3DANY)		/* Allow a different colour set for 3d push */
 			vsf_color(V_handle, selected3D_colour[colourword->fillc]);
 		else
 			vsf_color(V_handle, selected_colour[colourword->fillc]);
@@ -281,7 +282,7 @@
 				coords[2]=coords[0]+ob->ob_width;
 				coords[3]=coords[1]+ob->ob_height;
 				v_bar(V_handle, coords);
-				if (border_thick)			// Display a border?
+				if (border_thick)			/* Display a border?*/
 				{
 					draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 								ob->ob_width, ob->ob_height, 
@@ -289,8 +290,8 @@
 				}
 			}
 			break;
-		case G_IBOX:					// G_IBOX is like a box but doesn't get filled.
-			if (border_thick)			// Display a border?
+		case G_IBOX:					/* G_IBOX is like a box but doesn't get filled.*/
+			if (border_thick)			/* Display a border?*/
 			{
 				draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 							ob->ob_width, ob->ob_height, 
@@ -298,7 +299,7 @@
 			}
 			break;
 		case G_BOXCHAR:
-			tx=parent_x + ob->ob_x + ((ob->ob_width-display.c_max_w)/2);	// Centre the text in the box
+			tx=parent_x + ob->ob_x + ((ob->ob_width-display.c_max_w)/2);	/* Centre the text in the box*/
 			ty=parent_y + ob->ob_y + ((ob->ob_height-display.c_max_h)/2);
 
 			if (ob->ob_flags&FLD3DANY)
@@ -317,7 +318,7 @@
 					coords[3]=coords[1]+ob->ob_height;
 					v_bar(V_handle, coords);
 				}
-				if (border_thick)			// Display a border?
+				if (border_thick)			/* Display a border?*/
 				{
 					draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 								ob->ob_width, ob->ob_height,
@@ -361,7 +362,7 @@
 					coords[3]=coords[1]+ob->ob_height;
 					v_bar(V_handle, coords);
 				}
-				if (border_thick)	// Display a border?
+				if (border_thick)	/* Display a border?*/
 				{
 					draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 								ob->ob_width, ob->ob_height, 
@@ -400,7 +401,7 @@
 					coords[3]=coords[1]+ob->ob_height;
 					v_bar(V_handle, coords);
 				}
-				if (border_thick)	// Display a border?
+				if (border_thick)	/* Display a border?*/
 				{
 					draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 								ob->ob_width, ob->ob_height, 
@@ -419,7 +420,7 @@
 					tx+=PUSH3D_DISTANCE; ty+=PUSH3D_DISTANCE;
 				}
 			}else{
-				if (border_thick)	// Display a border?
+				if (border_thick)	/* Display a border?*/
 				{
 					draw_2d_box(parent_x+ob->ob_x, parent_y+ob->ob_y, 
 								ob->ob_width, ob->ob_height, 
@@ -470,7 +471,7 @@
 					break;
 			}
 			break;
-		case G_CICON:		// If t==G_CICON by we get here, we've definitely got a valid CICON for this res....
+		case G_CICON:		/* If t==G_CICON by we get here, we've definitely got a valid CICON for this res....*/
 			icx=parent_x+ob->ob_x+iconblk->ib_xicon;
 			icy=parent_y+ob->ob_y+iconblk->ib_yicon;
 			
@@ -588,11 +589,11 @@
 		if ((start_drawing)&&(!(tree[current].ob_flags&HIDETREE)))
 		{
 			this=tree+current;
-			display_object(x,y,this);	// Display this object
+			display_object(x,y,this);	/* Display this object*/
 		}
 
 		head=tree[current].ob_head;
-										// Any non-hidden children?
+										/* Any non-hidden children?*/
 		if (((head!=-1)&&(!(tree[current].ob_flags&HIDETREE)))
 			&&((!start_drawing)||((start_drawing)&&(rel_depth<depth))))
 		{
@@ -603,9 +604,9 @@
 		
 		}else{
 
-			next=tree[current].ob_next;		// Try for a sibling
+			next=tree[current].ob_next;		/* Try for a sibling*/
 	
-			while((next!=-1)				// Trace back up tree if no more siblings
+			while((next!=-1)				/* Trace back up tree if no more siblings*/
 					&&(tree[next].ob_tail==current))
 			{
 				current=next;
@@ -638,21 +639,21 @@
 	short x=0,y=0;
 	
 	do {
-		if (current==object)	// Found the object in the tree? cool, return the coords
+		if (current==object)	/* Found the object in the tree? cool, return the coords*/
 		{
 			*obx=x+tree[current].ob_x;
 			*oby=y+tree[current].ob_y;
 			return 1;
 		}
 		
-		if (tree[current].ob_head!=-1)		// Any children?
+		if (tree[current].ob_head!=-1)		/* Any children?*/
 		{
 			x+=tree[current].ob_x; y+=tree[current].ob_y;
 			current=tree[current].ob_head;
 		}else{
-			next=tree[current].ob_next;							// Try for a sibling
+			next=tree[current].ob_next;							/* Try for a sibling*/
 
-			while((next!=-1)&&(tree[next].ob_tail==current))	// Trace back up tree if no more siblings
+			while((next!=-1)&&(tree[next].ob_tail==current))	/* Trace back up tree if no more siblings*/
 			{
 				current=next;
 				x-=tree[current].ob_x;
@@ -661,9 +662,9 @@
 			}
 			current=next;
 		}
-	} while(current!=-1);		// If 'current' is -1 then we have finished
+	} while(current!=-1);		/* If 'current' is -1 then we have finished*/
 
-	return 0;	// Bummer - didn't find the object, so return error
+	return 0;	/* Bummer - didn't find the object, so return error*/
 }
 
 /*
@@ -677,7 +678,7 @@
 	short pos_object=-1;
 	
 	do {
-		if (current==object)	// We can start considering objects at this point
+		if (current==object)	/* We can start considering objects at this point*/
 		{
 			start_checking=TRUE;
 			rel_depth=0;
@@ -690,19 +691,19 @@
 				&&((tree[current].ob_x+x+tree[current].ob_width>=obx)
 				&&(tree[current].ob_y+y+tree[current].ob_height>=oby))))
 			{
-				pos_object=current;	// This is only a possible object, as it may have children on top of it.
+				pos_object=current;	/* This is only a possible object, as it may have children on top of it.*/
 			}
 		}
 
-		if (((!start_checking)||(rel_depth<depth))&&(tree[current].ob_head!=-1))		// Any children?
+		if (((!start_checking)||(rel_depth<depth))&&(tree[current].ob_head!=-1))		/* Any children?*/
 		{
 			x+=tree[current].ob_x; y+=tree[current].ob_y;
 			rel_depth++;
 			current=tree[current].ob_head;
 		}else{
-			next=tree[current].ob_next;							// Try for a sibling
+			next=tree[current].ob_next;							/* Try for a sibling*/
 
-			while((next!=-1)&&(tree[next].ob_tail==current))	// Trace back up tree if no more siblings
+			while((next!=-1)&&(tree[next].ob_tail==current))	/* Trace back up tree if no more siblings*/
 			{
 				current=next;
 				x-=tree[current].ob_x;
@@ -731,7 +732,7 @@
 	title=root[root[root[0].ob_head].ob_head].ob_head;
 	surround=root[root[0].ob_tail].ob_head;
 	
-	while(title!=root[root[0].ob_head].ob_head)		// Fix title spacings (some resource editors don't set them up right)
+	while(title!=root[root[0].ob_head].ob_head)		/* Fix title spacings (some resource editors don't set them up right)*/
 	{
 		root[title].ob_x=mnx;
 		root[surround].ob_x=mnx;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/purec/ahndlrpc.s /h/xaaes/purec/ahndlrpc.s
--- /i/newitems/XaAES.beta2/src/purec/ahndlrpc.s	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/purec/ahndlrpc.s	Wed Feb 21 17:42:02 1996
@@ -0,0 +1,69 @@
+	super
+	mc68000
+
+	xdef	handler
+
+;-------------------------------------------------------------------------------------
+; AES/VDI (Trap 2)  Handler
+; Version for Pure Assembler by Thomas Binder
+; Better solution would of course be to use something like the .spp-
+; files for the MiNT-kernel.
+;-------------------------------------------------------------------------------------
+; This mini handler just calls the main handler (written in C) or fields VDI
+; commands out to the old vector (which was saved when we hooked trap 2 in the first
+; place).
+; Perhaps the whole trap handler should be in assembler, but really, it's fast enough
+; for me just written in C with this small kludge routine to handle the actual
+; exception itself. If anyone wants to recode it totally in assembler, the main Trap
+; to pipe interface in in HANDLER.C - I'll happily put the mods into a new release.
+; - Self modifying code removed [13/2/96] by Martin koeling.
+; - Made XBRA compliant [13/2/96] by Martin koeling.
+;-------------------------------------------------------------------------------------
+
+	xref	XA_handler
+	xdef	old_trap2_vector
+
+; XBRA structure immediately before the new vector address:
+	dc.b	'XBRA'
+	dc.b	'XaAE'		; XBRA id (just a proposal)
+old_trap2_vector:
+	dc.l	0
+
+	
+;Exception vector goes to here....
+handler:
+
+	btst	#7,d0			; Is this a VDI call? AES calls all have bit 7 of d0 set.
+	beq.s	_is_vdi_call	; - if so, we should call the old vector as we haven't replaced
+							;   the VDI and have to rely on the existing one.
+
+	cmp.w	#$fffe,d0		; Bloody inconvenient vq_gdos() call - what's wrong with the normal VDI magic?
+	beq.s	_is_vdi_call
+	
+	cmp.w	#$c9,d0			; Special case : implement the test for installed AES
+	beq.s	_end_handler
+	
+	movem.l	d0-d7/a0-a6,-(a7)
+
+	move.l	d1,a0			; Place d1 arg in a0 as Lattice __regargs expects pointer to be
+							; in a0 not d1 (same for Pure C)
+
+	jsr		XA_handler		; Call the real handler written in C
+
+	movem.l	(a7)+,d0-d7/a0-a6
+
+	clr.w	d0				; Ordinary GEM does this - so we do it as well.....
+
+_end_handler:
+	rte
+
+
+; New version of the call to the original VDI/AES vector
+; [13/2/96] - Martin Koehling
+; This is a jump to the old VDI/AES vector. No self-modifieng code
+; here - _old_trap_vector is data, not code... :-)
+_is_vdi_call:
+	move.l	old_trap2_vector(pc),-(sp)
+	rts
+	
+	END
\ No newline at end of file
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/purec/pvfork/pvfork.prj /h/xaaes/purec/pvfork/pvfork.prj
--- /i/newitems/XaAES.beta2/src/purec/pvfork/pvfork.prj	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/purec/pvfork/pvfork.prj	Thu Feb 22 22:25:18 1996
@@ -0,0 +1,5 @@
+..\..\pvfork.o
+.S [ -Y ]
+.L [ -J -Y ]
+=
+pvfork.s
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/purec/pvfork/pvfork.s /h/xaaes/purec/pvfork/pvfork.s
--- /i/newitems/XaAES.beta2/src/purec/pvfork/pvfork.s	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/purec/pvfork/pvfork.s	Thu Feb 22 22:08:54 1996
@@ -0,0 +1,56 @@
+; pvfork.s dated 02/22/96
+;
+; Author:
+; Thomas Binder
+; (binder@rbg.informatik.th-darmstadt.de)
+;
+; Purpose:
+; Frontend for the MiNT-call Pvfork, which can't be called with a
+; simple subroutine. Just put it _in front_ of mintlib.lib in your
+; project files.
+;
+; History:
+; 02/21-
+; 02/22/96: Creation
+
+	export	Pvfork
+
+module Pvfork
+; First, save register a2
+	pea		(a2)
+	move.w	#$113,-(sp)		; Pvfork
+	trap	#1
+	addq.l	#2,sp
+	tst.w	d0
+	beq.s	child
+; In the parent, we just restore a2 and return
+	move.l	(sp)+,a2
+	rts
+child:
+; In the child, we have a problem: Since Pvfork is called as a
+; subroutine, a2 and the return address have to popped from the stack
+; to return to the calling routine. This routine now calls at least
+; Pterm or Pexec, which pushes new values on the stack, thus
+; destroying the value of a2 and the return address of the parent's
+; Pvfork-call. So, we must set up a temporary stack to avoid this.
+; Of course, we also have to copy some bytes of the original stack,
+; because Pure C keeps many local variables there (other compilers
+; sure do the same...)
+
+; 256 bytes of temporary stack should be enough in most cases; but if
+; the calling function has many local arrays, it might as well be too
+; little...
+	equ		tmp_stksiz,$100
+
+	move.l	sp,a0
+	lea		-tmp_stksiz(a0),sp	; Bug: No stack checking here
+	moveq	#4,d1
+	moveq	#0,d2
+loop:
+	move.l	(a0,d1.w),(sp,d2.w)
+	addq.w	#4,d1
+	addq.w	#4,d2
+	cmpi.w	#tmp_stksiz,d2
+	bne.s	loop
+	move.l	(a0),a2
+	rts
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/purec/readmepc.txt /h/xaaes/purec/readmepc.txt
--- /i/newitems/XaAES.beta2/src/purec/readmepc.txt	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/purec/readmepc.txt	Thu Feb 22 22:28:56 1996
@@ -0,0 +1,10 @@
+The Pure C-port is not finished now. To compile, copy the files
+ahndlrpc.s, pvfork.o (after making pvfork/pvfork.prj) and xa_aespc.prj
+to the parent directory. Start Pure C, select xa_aespc.prj and make all.
+
+Of course, you need the MiNTLibs!
+
+More to come...
+
+
+Thomas Binder / binder@rbg.informatik.th-darmstadt.de
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/purec/xa_aespc.prj /h/xaaes/purec/xa_aespc.prj
--- /i/newitems/XaAES.beta2/src/purec/xa_aespc.prj	Thu Jan  1 01:00:00 1970
+++ /h/xaaes/purec/xa_aespc.prj	Thu Feb 22 22:10:02 1996
@@ -0,0 +1,88 @@
+XAAES.TOS
+.C [ -Y -P -M ]
+.S [ -Y ]
+.L [ -Y -F -G -S=32768 ]
+;.C	[-gx -b4 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=0]
+;.S	[-l -d -m0]
+;.L	[WIDTH 100 SWIDTH 20 PWIDTH 10 INDENT 0 HWIDTH 15 FWIDTH 20 MAP,F,H,S,X]
+=
+crt0.o
+APPL_INI.C (xa_globl.h,xa_types.h,xa_defs.h,xa_codes.h,k_defs.h,kernal.h)
+APP_MAN.C (xa_types.h,xa_defs.h,xa_globl.h,k_defs.h,xa_codes.h,new_clnt.h,c_window.h)
+	[ -DGENERATE_DIAGS=1 ]
+APPL_MSG.C (xa_defs.h,xa_types.h,xa_globl.h,messages.h)
+ALL_WIDG.C (all_widg.h)
+BOOTUP.C (xa_defs.h,k_defs.h,xa_types.h,frm_alrt.h,handler.h,cookies.h,kernal.h,
+	mouse_cl.h,c_window.h,std_widg.h,xa_globl.h,system.h,signals.h,shellwrt.h,resource.h,
+	objects.h) [ -DGENERATE_DIAGS=1 ]
+BOX3D.C (xa_types.h,xa_globl.h)
+C_WINDOW.C (xa_types.h,xa_defs.h,xa_globl.h,std_widg.h,box3d.h,c_window.h,rectlist.h,
+	messages.h)
+CLOSWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,messages.h,
+	c_window.h,rectlist.h,all_widg.h,std_widg.h)
+COOKIES.C (xa_types.h)
+DRAG_BOX.C (xa_defs.h,xa_types.h,k_defs.h,xa_globl.h)
+EVENTS.C (xa_types.h,xa_defs.h,xa_globl.h,std_widg.h,box3d.h,c_window.h)
+EVENT_Q.C (event_q.h,xa_defs.h,k_defs.h)
+EVNT_BTN.C (event_q.h,xa_defs.h,xa_globl.h)
+EVNT_KBD.C (event_q.h,xa_defs.h,xa_globl.h)
+EVNT_MES.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,rectlist.h)
+EVNT_MUL.C (event_q.h,xa_defs.h,xa_globl.h,xa_types.h,k_defs.h,rectlist.h) [ -DGENERATE_DIAGS=1 ]
+EVNT_TMR.C (k_defs.h,xa_types.h,xa_globl.h)
+EXTEND.C (xa_defs.h,xa_types.h,xa_globl.h)
+FORM_DO.C (xa_types.h,xa_globl.h,xa_defs.h,box3d.h,frm_alrt.h,k_defs.h,resource.h,
+	objects.h,watchbox.h,c_window.h,std_widg.h)
+FORMS.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,objects.h,frm_alrt.h,std_widg.h,
+	c_window.h,watchbox.h)
+FRM_ALRT.C (xa_types.h,xa_globl.h,xa_defs.h,box3d.h,frm_alrt.h,k_defs.h,resource.h,
+	objects.h,watchbox.h,c_window.h,std_widg.h,system.h) [ -DGENERATE_DIAGS=1 ]
+FULLWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,messages.h,
+	c_window.h,rectlist.h,all_widg.h,std_widg.h)
+GETINFO.C  (xa_defs.h,xa_types.h,xa_globl.h) [ -DGENERATE_DIAGS=1 ]
+GRAF_BOX.C (xa_defs.h,xa_types.h,k_defs.h,xa_globl.h,drag_box.h,watchbox.h)
+GRAF_MOU.C (xa_defs.h,xa_types.h,k_defs.h,xa_globl.h,graf_mou.h)
+GRAFGROW.C (xa_defs.h,xa_types.h,xa_globl.h,objects.h)
+HANDLER.C (k_defs.h,handler.h,xa_defs.h,xa_globl.h,frm_alrt.h,xa_codes.h,appl_ini.h,
+	kernal.h) [ -DGENERATE_DIAGS=1 ]
+INFOWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,messages.h,
+	c_window.h,rectlist.h,all_widg.h,std_widg.h)
+KERNAL.C (k_defs.h,kernal.h,xa_globl.h,xa_codes.h,xa_defs.h,appl_ini.h,new_clnt.h,
+	getinfo.h,evnt_btn.h,evnt_kbd.h,evnt_mes.h,evnt_mul.h,evnt_tmr.h,mouse_cl.h,
+	wind_fns.h,graf_mou.h,graf_box.h,grafgrow.h,keyboard.h,resource.h,objc_drw.h,forms.h,
+	frm_alrt.h,menubar.h,shell.h,extend.h,scrap.h,op_names.h,app_man.h,appl_msg.h)
+	[ -DGENERATE_DIAGS=1 ]
+KEYBOARD.C (xa_defs.h,xa_types.h,xa_globl.h,app_man.h,c_window.h,evnt_mul.h) [ -DGENERATE_DIAGS=1 ]
+MENUBAR.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,rectlist.h,objects.h,system.h,
+	c_window.h,resource.h)
+MESSAGES.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,evnt_mul.h)
+MOUSE_CL.C (k_defs.h,kernal.h,xa_defs.h,xa_types.h,xa_globl.h,mouse_cl.h,evnt_btn.h,
+	c_window.h,evnt_mul.h,std_widg.h) [ -DGENERATE_DIAGS=1 ]
+NEW_CLNT.C (xa_defs.h,xa_types.h,xa_globl.h,c_window.h,system.h,resource.h,events.h)
+	[ -DGENERATE_DIAGS=1 ]
+OBJCWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,c_window.h,
+	rectlist.h,box3d.h,objects.h,messages.h,std_widg.h) [ -DGENERATE_DIAGS=1 ]
+OBJC_DRW.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,rectlist.h,objects.h) [ -DGENERATE_DIAGS=1 ]
+OBJECTS.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,rectlist.h,box3d.h) [ -DGENERATE_DIAGS=1 ]
+RECTLIST.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,c_window.h,events.h)
+RESOURCE.C (k_defs.h,resource.h,xa_globl.h,xa_defs.h,xa_types.h)
+RESZWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,messages.h,
+	c_window.h,rectlist.h,all_widg.h,std_widg.h,drag_box.h)
+SCRAP.C (xa_types.h,xa_defs.h,xa_globl.h,k_defs.h)
+SCRLWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,box3d.h,drag_box.h,
+	graf_mou.h,messages.h,c_window.h,rectlist.h,all_widg.h,std_widg.h)
+SIGNALS.C (c_window.h,k_defs.h,xa_types.h,xa_globl.h,xa_defs.h,xa_codes.h,new_clnt.h)
+SHELL.C (k_defs.h,xa_globl.h,shellwrt.h,xa_defs.h) [ -DGENERATE_DIAGS=1 ]
+SHELLWRT.C (k_defs.h,xa_defs.h,xa_types.h,xa_globl.h) [ -DGENERATE_DIAGS=1 ]
+STD_WIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,c_window.h,
+	rectlist.h,all_widg.h,scrlwidg.h,closwidg.h,reszwidg.h,titlwidg.h,fullwidg.h,
+	infowidg.h,objcwidg.h,form_do.h) [ -DGENERATE_DIAGS=1 ]
+TITLWIDG.C (xa_types.h,xa_defs.h,xa_globl.h,kernal.h,k_defs.h,graf_mou.h,messages.h,
+	c_window.h,rectlist.h,all_widg.h,std_widg.h,drag_box.h)
+WATCHBOX.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,objects.h)
+WIND_FNS.C (xa_defs.h,xa_types.h,xa_globl.h,k_defs.h,c_window.h,events.h,rectlist.h,
+	scrlwidg.h,infowidg.h,titlwidg.h,std_widg.h,graf_mou.h,messages.h)
+AHNDLRPC.S
+
+pvfork.o
+mintlib.lib
+pcgemlib.lib
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/rectlist.c /h/xaaes/rectlist.c
--- /i/newitems/XaAES.beta2/src/rectlist.c	Sun Feb 18 23:43:32 1996
+++ /h/xaaes/rectlist.c	Wed Feb 21 17:07:02 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <VDI.H>
 #include <MINTBIND.H>
 #include "XA_DEFS.H"
@@ -162,7 +163,7 @@
 							nrl=cnrl;
 						}
 					}
-				}else{	// Keep the current rectangle, it hasn't been changed
+				}else{	/* Keep the current rectangle, it hasn't been changed*/
 					cnrl=(XA_RECT_LIST*)malloc(sizeof(XA_RECT_LIST));
 					cnrl->x=rl->x;
 					cnrl->y=rl->y;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/resource.c /h/xaaes/resource.c
--- /i/newitems/XaAES.beta2/src/resource.c	Mon Feb 19 10:51:04 1996
+++ /h/xaaes/resource.c	Wed Feb 21 23:28:20 1996
@@ -35,12 +35,12 @@
 	void **glob_entry;
 	short f;
 
-// If the client is overwriting it's existing resource then better free it
-// (it shouldn't, but just in case)
+/* If the client is overwriting it's existing resource then better free it*/
+/* (it shouldn't, but just in case)*/
 	if (clients[clnt_pid].std_resource)
 		FreeResources(clients[clnt_pid].std_resource);
 
-// What sort of path is it?
+/* What sort of path is it?*/
 	for(f=0; (n[f])&&(n[f]!='\\'); f++);
 	if (n[f])
 		sprintf(full_path,"%s",n);
@@ -53,7 +53,7 @@
 	else
 		pb->intout[0]=0;
 
-// Fill in the application's global array with a pointer to the resource
+/* Fill in the application's global array with a pointer to the resource*/
 	glob_entry=(void**)(clients[clnt_pid].globl_ptr+5);
 	*glob_entry=clients[clnt_pid].std_resource;
 
@@ -255,7 +255,7 @@
 				cibh[i] = cib;
 				ib = &cib->monoblk;
 				size = 2UL*(unsigned long)(ib->ib_wicon/16)*(unsigned long)ib->ib_hicon;
-				addr = (long*)((long)cib+sizeof(ICONBLK));
+				addr = (unsigned long*)((long)cib+sizeof(ICONBLK));
 				numRez = (short)*addr;
 				pdata = (short*)&addr[1];
 				ib->ib_pdata = pdata;
@@ -341,7 +341,7 @@
 		{ /* Standard AES menu */
 			j = 0;
 			do { /* Use conventional AES routine */
-//				rsrc_obfix(tree,j);		// GEMAES
+/*				rsrc_obfix(tree,j);		// GEMAES*/
 			} while (!(tree[j++].ob_flags&LASTOB));
 		}
 	}
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/reszwidg.c /h/xaaes/reszwidg.c
--- /i/newitems/XaAES.beta2/src/reszwidg.c	Tue Nov 28 00:39:10 1995
+++ /h/xaaes/reszwidg.c	Thu Feb 22 13:06:56 1996
@@ -18,21 +18,22 @@
 #include "RECTLIST.H"
 #include "ALL_WIDG.H"
 #include "STD_WIDG.H"
+#include "drag_box.h"
 
 /*======================================================
 	RESIZE WIDGET BEHAVIOUR
 ========================================================*/
 short drag_resize(XA_WINDOW *wind, XA_WIDGET *widg)
 {
-	short w,h;
+	short w,h,xy[4];
 	
-	vs_clip(V_handle, 0, NULL);
+	vs_clip(V_handle, 0, xy);
 
-	graf_mouse(XACRS_RESIZER, NULL);		// Always have a nice consistent SIZER when resizing a window
+	graf_mouse(XACRS_RESIZER, NULL);		/* Always have a nice consistent SIZER when resizing a window*/
 	rubber_box(wind->x, wind->y, WIDGET_SIZE+20, WIDGET_SIZE+20, &w, &h);
-	graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	// Restore the mouse now we've done the drag
+	graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	/* Restore the mouse now we've done the drag*/
 
-// Send a message to the client to say that the AES would like the window re-sizing
+/* Send a message to the client to say that the AES would like the window re-sizing*/
 	if ((w!=wind->w)||(h!=wind->h))
 		send_app_message(wind->owner, WM_SIZED, 0, wind->handle, wind->x, wind->y, w, h);
 
@@ -43,7 +44,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_size);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/scrap.c /h/xaaes/scrap.c
--- /i/newitems/XaAES.beta2/src/scrap.c	Sun Feb 11 19:57:44 1996
+++ /h/xaaes/scrap.c	Wed Feb 21 17:07:36 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <string.h>
 #include "XA_TYPES.H"
 #include "XA_DEFS.H"
 #include "XA_GLOBL.H"
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/scrlwidg.c /h/xaaes/scrlwidg.c
--- /i/newitems/XaAES.beta2/src/scrlwidg.c	Wed Dec 13 02:20:04 1995
+++ /h/xaaes/scrlwidg.c	Thu Feb 22 19:03:36 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <OSBIND.H>
 #include <VDI.H>
 #include "XA_TYPES.H"
@@ -13,7 +14,6 @@
 #include "KERNAL.H"
 #include "K_DEFS.H"
 #include "BOX3D.H"
-#include "KERNAL.H"
 #include "DRAG_BOX.H"
 #include "GRAF_MOU.H"
 #include "MESSAGES.H"
@@ -33,7 +33,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_left);
@@ -50,10 +50,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_LFLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_lscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_lscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -66,7 +66,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_right);
@@ -83,10 +83,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_RTLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_rscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_rscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -99,7 +99,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_up);
@@ -116,10 +116,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_UPLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_uscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_uscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -132,7 +132,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_down);
@@ -149,10 +149,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_DNLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_dscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_dscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -169,10 +169,10 @@
 	short x,y,pnt[4],offs,len,wcy;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
-	len=(widg->h*sl->length)/1000;
-	offs=((widg->h - len)*sl->position)/1000;
+	len=(short)(((long)widg->h * (long)sl->length)/1000);
+	offs=(short)(((long)(widg->h - len) * (long)sl->position)/1000);
 	wcy=widg->click_y-offs;
 
 	if (len>=ICON_H*3)
@@ -231,34 +231,34 @@
 	XA_RECT_LIST *drl;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 
-	len=(widg->h*sl->length)/1000;
+	len=(short)(((long)widg->h * (long)sl->length)/1000);
 	orig_offs=offs=sl->position;
-	wcy=widg->click_y-((widg->h - len)*sl->position)/1000;
+	wcy=widg->click_y - (short)(((long)(widg->h - len) * (long)sl->position)/1000);
 
 	vq_mouse(V_handle, &mb, &imx, &imy);
 	pmx=imx; pmy=imy;
 
-	if ((len<ICON_H*3)||((wcy>ICON_H)&&(wcy<len-ICON_H)))	// Drag slider
+	if ((len<ICON_H*3)||((wcy>ICON_H)&&(wcy<len-ICON_H)))	/* Drag slider*/
 	{
 		do {
 			vq_mouse(V_handle, &mb, &mx, &my);
-			if (my!=pmy)			// Has mouse moved?
+			if (my!=pmy)			/* Has mouse moved?*/
 			{
-				dy=(1000*(my-pmy))/(widg->h-len);
+				dy=(short)((1000L * (long)(my-pmy))/(widg->h-len));
 				noffs=offs+dy;
 				if (noffs<0) noffs=0;
 				if (noffs>1000) noffs=1000;
 
-				if (noffs!=offs)	// Has the slider moved?
+				if (noffs!=offs)	/* Has the slider moved?*/
 				{
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -267,7 +267,7 @@
 					}
 					offs=noffs;
 					sl->position=offs;
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -284,18 +284,22 @@
 		send_app_message(wind->owner, WM_VSLID, 0, wind->handle, offs, 0, 0, 0);
 	}else{
 		vsf_color(V_handle,display.dial_colours.highlight_col);
-		if (wcy<ICON_H)			// Page left
+		if (wcy<ICON_H)			/* Page left*/
 		{
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_UPPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y;
-			pnt[2]=x+widg->w; pnt[3]=y+(widg->h - len)*sl->position/1000;
-		}else{					// Page right
+			pnt[0]=x;
+			pnt[1]=y;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+(short)((long)(widg->h - len) * (long)sl->position / 1000);
+		}else{					/* Page right*/
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_DNPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y+(widg->h - len)*sl->position/1000+len;
-			pnt[2]=x+widg->w; pnt[3]=y+widg->h;
+			pnt[0]=x;
+			pnt[1]=y+(short)((long)(widg->h - len) * (long)sl->position / 1000) + len;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+widg->h;
 		}
 		v_hide_c(V_handle);
-		for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+		for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 		{
 			clip[0]=drl->x; clip[1]=drl->y;
 			clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -305,16 +309,16 @@
 		}
 		v_show_c(V_handle, 1);
 		vsf_color(V_handle,display.dial_colours.bg_col);
-		if (mb)	// If the button has been held down, set a pending/active widget for the client
+		if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 		{
-			set_widget_active(wind, widg, &drag_vslide);
-			return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+			set_widget_active(wind, widg, drag_vslide);
+			return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 		}
 		cancel_widget_active(wind);
 	}
 	
 	v_hide_c(V_handle);
-	while(rl)		// Dispose of the rectangle list & erase the dragged slider
+	while(rl)		/* Dispose of the rectangle list & erase the dragged slider*/
 	{
 		drl=rl;
 		clip[0]=drl->x; clip[1]=drl->y;
@@ -323,8 +327,8 @@
 		v_bar(V_handle,pnt);
 		rl=rl->next;
 		free(drl);
-	}				// We don't need to re-draw the slider as it get's redrawn by the 
-					// standard widget handler anyway.
+	}				/* We don't need to re-draw the slider as it get's redrawn by the */
+					/* standard widget handler anyway.*/
 	v_show_c(V_handle, 1);
 
 	return TRUE;
@@ -342,10 +346,10 @@
 	short x,y,pnt[4],offs,len,wcx;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
-	len=(widg->w*sl->length)/1000;
-	offs=((widg->w - len)*sl->position)/1000;
+	len=(short)(((long)widg->w * (long)sl->length)/1000);
+	offs=(short)(((long)(widg->w - len) * (long)sl->position)/1000);
 
 	wcx=widg->click_x-offs;
 
@@ -405,34 +409,34 @@
 	XA_RECT_LIST *drl;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 
-	len=(widg->w*sl->length)/1000;
+	len=(short)(((long)widg->w * (long)sl->length)/1000);
 	orig_offs=offs=sl->position;
-	wcx=widg->click_x-((widg->w - len)*sl->position)/1000;
+	wcx=widg->click_x-(short)(((long)(widg->w - len) * (long)sl->position)/1000);
 
 	vq_mouse(V_handle, &mb, &imx, &imy);
 	pmx=imx; pmy=imy;
 
-	if ((len<ICON_W*3)||((wcx>ICON_W)&&(wcx<len-ICON_W)))	// Drag slider
+	if ((len<ICON_W*3)||((wcx>ICON_W)&&(wcx<len-ICON_W)))	/* Drag slider*/
 	{
 		do {
 			vq_mouse(V_handle, &mb, &mx, &my);
-			if (mx!=pmx)			// Has mouse moved?
+			if (mx!=pmx)			/* Has mouse moved?*/
 			{
-				dx=(1000*(mx-pmx))/(widg->w-len);
+				dx=(short)((1000L * (long)(mx-pmx))/(widg->w-len));
 				noffs=offs+dx;
 				if (noffs<0) noffs=0;
 				if (noffs>1000) noffs=1000;
 
-				if (noffs!=offs)	// Has the slider moved?
+				if (noffs!=offs)	/* Has the slider moved?*/
 				{
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -441,7 +445,7 @@
 					}
 					offs=noffs;
 					sl->position=offs;
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -458,18 +462,22 @@
 		send_app_message(wind->owner, WM_HSLID, 0, wind->handle, offs, 0, 0, 0);
 	}else{
 		vsf_color(V_handle,display.dial_colours.highlight_col);
-		if (wcx<ICON_W)			// Page left
+		if (wcx<ICON_W)			/* Page left*/
 		{
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_LFPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y;
-			pnt[2]=x+(widg->w - len)*sl->position/1000; pnt[3]=y+widg->h;
-		}else{					// Page right
+			pnt[0]=x;
+			pnt[1]=y;
+			pnt[2]=x+(short)((long)(widg->w - len) * (long)sl->position / 1000);
+			pnt[3]=y+widg->h;
+		}else{					/* Page right*/
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_RTPAGE, 0, 0, 0);
-			pnt[0]=x+(widg->w - len)*sl->position/1000+len; pnt[1]=y;
-			pnt[2]=x+widg->w; pnt[3]=y+widg->h;
+			pnt[0]=x+(short)((long)(widg->w - len) * (long)sl->position / 1000) + len;
+			pnt[1]=y;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+widg->h;
 		}
 		v_hide_c(V_handle);
-		for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+		for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 		{
 			clip[0]=drl->x; clip[1]=drl->y;
 			clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -479,16 +487,16 @@
 		}
 		v_show_c(V_handle, 1);
 		vsf_color(V_handle,display.dial_colours.bg_col);
-		if (mb)	// If the button has been held down, set a pending/active widget for the client
+		if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 		{
-			set_widget_active(wind, widg, &drag_hslide);
-			return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+			set_widget_active(wind, widg, drag_hslide);
+			return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 		}
 		cancel_widget_active(wind);
 	}
 	
 	v_hide_c(V_handle);
-	while(rl)		// Dispose of the rectangle list & erase the dragged slider
+	while(rl)		/* Dispose of the rectangle list & erase the dragged slider*/
 	{
 		drl=rl;
 		clip[0]=drl->x; clip[1]=drl->y;
@@ -497,8 +505,8 @@
 		v_bar(V_handle,pnt);
 		rl=rl->next;
 		free(drl);
-	}				// We don't need to re-draw the slider as it get's redrawn by the 
-					// standard widget handler anyway.
+	}				/* We don't need to re-draw the slider as it get's redrawn by the */
+					/* standard widget handler anyway.*/
 	v_show_c(V_handle, 1);
 
 	return TRUE;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/shell.c /h/xaaes/shell.c
--- /i/newitems/XaAES.beta2/src/shell.c	Sun Feb 18 23:01:58 1996
+++ /h/xaaes/shell.c	Wed Feb 21 23:30:54 1996
@@ -6,7 +6,9 @@
  */
 
 #include <OSBIND.H>
+#include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include "k_defs.h"
 #include "xa_globl.h"
 #include "shellwrt.h"
@@ -56,7 +58,7 @@
 	handle=Fopen(path,0);
 	if (handle>0)
 	{
-		Fclose(handle);
+		Fclose((short)handle);
 		sprintf(fn,"%s",path);
 		pb->intout[0]=1;
 		
@@ -66,7 +68,7 @@
 	}
 	
 /* check our PATH enviroment variable */
-	l=strlen(cwd);
+	l=(short)strlen(cwd);
 	sprintf(cwd,"%s",kp);
 	
 	while(f<l)
@@ -80,7 +82,7 @@
 		handle=Fopen(path,0);
 		if (handle>0)
 		{
-			Fclose(handle);
+			Fclose((short)handle);
 			sprintf(fn,"%s",path);
 			pb->intout[0]=1;
 
@@ -95,7 +97,7 @@
 	handle=Fopen(fn,0);
 	if (handle>0)
 	{
-		Fclose(handle);
+		Fclose((short)handle);
 		pb->intout[0]=1;
 		
 		DIAGS(("found as file spec on it's own\n"));
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/shellwrt.c /h/xaaes/shellwrt.c
--- /i/newitems/XaAES.beta2/src/shellwrt.c	Sun Feb 18 23:21:44 1996
+++ /h/xaaes/shellwrt.c	Thu Feb 22 17:35:20 1996
@@ -9,6 +9,7 @@
 #include <MINTBIND.H>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include "k_defs.h"
 #include "xa_defs.h"
 #include "xa_types.h"
@@ -31,13 +32,13 @@
 	switch(real_mode)
 	{
 		case 0:
-			save_cmd=(char*)malloc(strlen(cmd)+1);		// Preserve the details
+			save_cmd=(char*)malloc(strlen(cmd)+1);		/* Preserve the details*/
 			strcpy(save_cmd,cmd);
 			save_tail=(char*)malloc(strlen(tail+1)+1);
 			strncpy(save_tail,tail, tail[0]+1);
 			save_tail[tail[0]+1]='\0';
 			
-			for(t=strlen(cmd); (t>-1)&&(cmd[t]!='\\'); t--);	// Seperate path & name
+			for(t=(short)strlen(cmd); (t>-1)&&(cmd[t]!='\\'); t--);	/* Seperate path & name*/
 			if (cmd[t]=='\\')
 			{
 				cmd[t]='\0';
@@ -45,28 +46,28 @@
 				run_name=cmd+t+1;
 				if (run_path[1]==':')
 				{
-					Dsetdrv(run_path[0]-'a');
+					Dsetdrv((run_path[0] & ~32) - 'A');
 					run_path+=2;
 				}
-				Dsetpath(run_path);	// Ensure that client is run from it's correct directory
-									// - this allows it to find it's resources,etc
+				Dsetpath(run_path);	/* Ensure that client is run from it's correct directory*/
+									/* - this allows it to find it's resources,etc*/
 			}else{
 				run_name=cmd;
 			}
 			
-			child=Pvfork();			// Fork off a new process
+			child=(short)Pvfork();	/* Fork off a new process*/
 			if (!child)
-			{						// In child here
-				if (x_mode&SW_PSETLIMIT)		// Limit child's memory?
+			{						/* In child here*/
+				if (x_mode&SW_PSETLIMIT)		/* Limit child's memory?*/
 					Psetlimit(2,x_shell->psetlimit);
 	
-				Pexec(200,run_name,tail,NULL);	// Run the new client
+				Pexec(200,run_name,tail,NULL);	/* Run the new client*/
 				
-				Pterm0();			// If we reach here, we've failled to execute, so exit
+				Pterm0();			/* If we reach here, we've failled to execute, so exit*/
 			}
 			
-			if (x_mode&SW_PRENICE)				// Was the child spawned as 'nice'?
-				Prenice(child, x_shell->prenice);
+			if (x_mode&SW_PRENICE)				/* Was the child spawned as 'nice'?*/
+				Prenice(child, (short)x_shell->prenice);
 			
 			Dsetdrv(XaAES_home_drv);
 			Dsetpath(XaAES_home);
@@ -81,13 +82,13 @@
 			return child;
 			break;
 		case 1:
-			save_cmd=(char*)malloc(strlen(cmd)+1);		// Preserve the details
+			save_cmd=(char*)malloc(strlen(cmd)+1);		/* Preserve the details*/
 			strcpy(save_cmd,cmd);
 			save_tail=(char*)malloc(strlen(tail+1)+1);
 			strncpy(save_tail,tail, tail[0]+1);
 			save_tail[tail[0]+1]='\0';
 			
-			for(t=strlen(cmd); (t>-1)&&(cmd[t]!='\\'); t--);	// Seperate path & name
+			for(t=(short)strlen(cmd); (t>-1)&&(cmd[t]!='\\'); t--);	/* Seperate path & name*/
 			if (cmd[t]=='\\')
 			{
 				cmd[t]='\0';
@@ -95,44 +96,44 @@
 				run_name=cmd+t+1;
 				if (run_path[1]==':')
 				{
-					Dsetdrv(run_path[0]-'a');
+					Dsetdrv((run_path[0] & ~32) - 'A');
 					run_path+=2;
 				}
-				Dsetpath(run_path);	// Ensure that client is run from it's correct directory
-									// - this allows it to find it's resources,etc
+				Dsetpath(run_path);	/* Ensure that client is run from it's correct directory*/
+									/* - this allows it to find it's resources,etc*/
 			}else{
 				run_name=cmd;
 			}
 			
-			child=Pvfork();			// Fork off a new process
+			child=(short)Pvfork();	/* Fork off a new process*/
 			if (!child)
-			{						// In child here
+			{						/* In child here*/
 				if (wisgr==0)		/* TOS Launch? */
 				{
 					int fd;
 					char new_cmd[300];
 					
 					sprintf(new_cmd,"%s %s",run_name,tail+1);
-					fd = Fopen("U:\\PIPE\\TOSRUN", 2);
-					t = strlen(new_cmd) + 1;
+					fd = (int)Fopen("U:\\PIPE\\TOSRUN", 2);
+					t = (short)strlen(new_cmd) + 1;
 
 					Fwrite(fd, t, new_cmd);
 					
 					Fclose(fd);
 					
 				}else{				/* GEM Launch */
-					if (x_mode&SW_PSETLIMIT)		// Limit child's memory?
+					if (x_mode&SW_PSETLIMIT)		/* Limit child's memory?*/
 						Psetlimit(2,x_shell->psetlimit);
 	
-					Pexec(200,run_name,tail,NULL);	// Run the new client
+					Pexec(200,run_name,tail,NULL);	/* Run the new client*/
 
 				}
 				
-				Pterm0();			// If we reach here, we've failled to execute, so exit
+				Pterm0();			/* If we reach here, we've failled to execute, so exit*/
 			}
 			
-			if (x_mode&SW_PRENICE)				// Was the child spawned as 'nice'?
-				Prenice(child, x_shell->prenice);
+			if (x_mode&SW_PRENICE)				/* Was the child spawned as 'nice'?*/
+				Prenice(child, (short)x_shell->prenice);
 			
 			Dsetdrv(XaAES_home_drv);
 			Dsetpath(XaAES_home);
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/signals.c /h/xaaes/signals.c
--- /i/newitems/XaAES.beta2/src/signals.c	Mon Feb 19 13:46:24 1996
+++ /h/xaaes/signals.c	Wed Feb 21 23:55:24 1996
@@ -14,6 +14,7 @@
 #include "xa_globl.h"
 #include "xa_defs.h"
 #include "xa_codes.h"
+#include "new_clnt.h"
 
 /*
 	SIGNAL HANDLERS
@@ -42,16 +43,17 @@
 		if (r==mouse_lock)
 			mouse_lock=0;
 
-		dead_client_pb.contrl=dead_exit_contrl;	// If client is dead, send ourselves a message to clean up....
-		dead_client_packet.pid=r;				// client pid
-		dead_client_packet.cmd=AESCMD_NOREPLY;	// no reply
-		dead_client_packet.pb=&dead_client_pb;	// pointer to AES parameter block
-
-		XA_client_exit(r,&dead_client_pb);		// Run the application exit cleanup
-
-		clients[r].clnt_pipe_rd=0;				// This is normally done by appl_exit(),
-												// but beings as the client is dead, the pipe will be
-												// closed already
+		dead_client_pb.contrl=dead_exit_contrl;	/* If client is dead, send ourselves a message to clean up....*/
+		dead_client_packet.pid=(short)r;		/* client pid*/
+		dead_client_packet.cmd=AESCMD_NOREPLY;	/* no reply*/
+		dead_client_packet.pb=&dead_client_pb;	/* pointer to AES parameter block*/
+
+		XA_client_exit((short)r,&dead_client_pb);
+												/* Run the application exit cleanup*/
+
+		clients[r].clnt_pipe_rd=0;				/* This is normally done by appl_exit(),*/
+												/* but beings as the client is dead, the pipe will be*/
+												/* closed already*/
 		r=Pwait3(1,NULL);
 	}
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/std_widg.c /h/xaaes/std_widg.c
--- /i/newitems/XaAES.beta2/src/std_widg.c	Sun Feb 18 14:42:36 1996
+++ /h/xaaes/std_widg.c	Thu Feb 22 15:39:50 1996
@@ -13,7 +13,6 @@
 #include "XA_GLOBL.H"
 #include "KERNAL.H"
 #include "K_DEFS.H"
-#include "KERNAL.H"
 #include "GRAF_MOU.H"
 #include "C_WINDOW.H"
 #include "RECTLIST.H"
@@ -34,10 +33,10 @@
 
 MFDB widget_bm;
 
-// Convert widget bitmaps (16*16*4bit device independant format) to device specific format
-// for the current screen device.
-// Asides from looking pretty, this should make the default widget set work with any
-// colour screen mode and any graphics card (right up to 24 bits/pixel).
+/* Convert widget bitmaps (16*16*4bit device independant format) to device specific format*/
+/* for the current screen device.*/
+/* Asides from looking pretty, this should make the default widget set work with any*/
+/* colour screen mode and any graphics card (right up to 24 bits/pixel).*/
 void fix_bitmaps(void)
 {
 	MFDB dest;
@@ -54,7 +53,7 @@
 	dest=widget_bm;
 	dest.fd_stand=0;
 
-// Transform the XaAES logo
+/* Transform the XaAES logo*/
 	widget_bm.fd_addr=(void*)bitmap_xaaes16_s;
 	dest.fd_addr=(void*)bitmap_xaaes16_s;
 	vr_trnfm(V_handle,&widget_bm,&dest);
@@ -62,7 +61,7 @@
 	dest.fd_addr=(void*)bitmap_xaaes16;
 	vr_trnfm(V_handle,&widget_bm,&dest);
 	
-// Transform the actual window widgets
+/* Transform the actual window widgets*/
 	widget_bm.fd_addr=(void*)widget_bitmap_close;
 	dest.fd_addr=(void*)widget_bitmap_close;
 	vr_trnfm(V_handle,&widget_bm,&dest);
@@ -155,7 +154,7 @@
 	widget_bm=dest;
 }
 
-// Set the active/pending widget behaviour for a client
+/* Set the active/pending widget behaviour for a client*/
 void set_widget_active(XA_WINDOW *wind, XA_WIDGET *widg, WidgetCallback wc)
 {
 	XA_PENDING_WIDGET *pw;
@@ -171,7 +170,7 @@
 	clients[clnt_pid].widget_active=pw;
 }
 
-// Cancel the active/pending widget for a client
+/* Cancel the active/pending widget for a client*/
 void cancel_widget_active(XA_WINDOW *wind)
 {
 	XA_PENDING_WIDGET *pw;
@@ -182,7 +181,7 @@
 	if (pw) free(pw);
 }
 
-// Convert window relative widget coords to absolute screen coords
+/* Convert window relative widget coords to absolute screen coords*/
 void rp_2_ap(XA_WINDOW *wind, XA_WIDGET *widg, short *x, short *y)
 {
 	XA_WIDGET_LOCATION rp=widg->loc;
@@ -250,11 +249,11 @@
 #endif
 }
 
-// Calculate the size of the work area for a window and store it
-// - this is needed because the locations of widgets are relative and
-//   can be modified.
-// Actually, this updates all the dynamic sized elements from the standard widget set...
-// (namely: work area, sliders and title bar)
+/* Calculate the size of the work area for a window and store it*/
+/* - this is needed because the locations of widgets are relative and*/
+/*   can be modified.*/
+/* Actually, this updates all the dynamic sized elements from the standard widget set...*/
+/* (namely: work area, sliders and title bar)*/
 void calc_work_area(XA_WINDOW *wind)
 {
 	XA_WIDGET *widg;
@@ -277,8 +276,8 @@
 	for (f=0; f<XA_MAX_WIDGETS; f++)
 	{
 		widg=wind->widgets+f;
-		disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
-		if (disp)	// If the widget is displayed, include it in the calculation
+		disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
+		if (disp)	/* If the widget is displayed, include it in the calculation*/
 		{
 			rp_2_ap(wind, widg, &wx, &wy);
 			rt=widg->loc.relative_type;
@@ -332,23 +331,23 @@
 			}
 		}
 	}
-	wind->wx=x0;							// Update work area
+	wind->wx=x0;							/* Update work area*/
 	wind->wy=y0;
 	wind->ww=x1-x0;
 	wind->wh=y1-y0;
-	wind->widgets[XAW_TITLE].w=tx1-tx0;		// Update title bar length
+	wind->widgets[XAW_TITLE].w=tx1-tx0;		/* Update title bar length*/
 	wind->widgets[XAW_TITLE].loc.x=tx0-wind->x;
-	if (wind->active_widgets&HSLIDE)		// Update horizontal slider
+	if (wind->active_widgets&HSLIDE)		/* Update horizontal slider*/
 	{
 		wind->widgets[XAW_HSLIDE].w=slx1-slx0;
 	}
-	if (wind->active_widgets&VSLIDE)		// Update vertical slider
+	if (wind->active_widgets&VSLIDE)		/* Update vertical slider*/
 	{
 		wind->widgets[XAW_VSLIDE].h=sly1-sly0;
 	}
 }
 
-// Define the widget locations using window relative coordinates.
+/* Define the widget locations using window relative coordinates.*/
 const XA_WIDGET_LOCATION stdl_close={LT,1,1};
 const XA_WIDGET_LOCATION stdl_full={RT,1,1};
 const XA_WIDGET_LOCATION stdl_title={LT,23,3};
@@ -362,18 +361,18 @@
 const XA_WIDGET_LOCATION stdl_info={LT,1,1};
 const XA_WIDGET_LOCATION stdl_menu={LT,1,WIDGET_SIZE+5};
 
-// Setup the required 'standard' widgets for a window. These are the ordinary GEM
-// behaviours. These can be changed for any given window if you want special behaviours.
+/* Setup the required 'standard' widgets for a window. These are the ordinary GEM*/
+/* behaviours. These can be changed for any given window if you want special behaviours.*/
 void standard_widgets(XA_WINDOW *wind, long tp)
 {
 	short wd,bh,top_w=wind->w;
 	long bit_mask;
 	
-	wind->active_widgets=tp;				// Fill in the active widgets summary
+	wind->active_widgets=tp;				/* Fill in the active widgets summary*/
 	wind->widgets_on_top=0;
 	
-	for (wd=0; wd<XA_MAX_WIDGETS; wd++)		// Initially tag all behaviours as NULL so we can tell
-	{										// which ones we have actually attatched.
+	for (wd=0; wd<XA_MAX_WIDGETS; wd++)		/* Initially tag all behaviours as NULL so we can tell*/
+	{										/* which ones we have actually attatched.*/
 		for(bh=0; bh<COUNT_XACB; bh++)
 		{
 			wind->widgets[wd].behaviour[bh]=NULL;
@@ -383,8 +382,8 @@
 
 	if (tp&CLOSE)
 	{
-		wind->widgets[XAW_CLOSE].behaviour[XACB_DISPLAY]=&display_close_widget;
-		wind->widgets[XAW_CLOSE].behaviour[XACB_CLICK]=&click_close;
+		wind->widgets[XAW_CLOSE].behaviour[XACB_DISPLAY]=display_close_widget;
+		wind->widgets[XAW_CLOSE].behaviour[XACB_CLICK]=click_close;
 		wind->widgets[XAW_CLOSE].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_CLOSE].behaviour[XACB_DRAG]=NULL;
 		wind->widgets[XAW_CLOSE].loc=stdl_close;
@@ -397,8 +396,8 @@
 
 	if (tp&FULLER)
 	{
-		wind->widgets[XAW_FULL].behaviour[XACB_DISPLAY]=&display_full;
-		wind->widgets[XAW_FULL].behaviour[XACB_CLICK]=&click_full;
+		wind->widgets[XAW_FULL].behaviour[XACB_DISPLAY]=display_full;
+		wind->widgets[XAW_FULL].behaviour[XACB_CLICK]=click_full;
 		wind->widgets[XAW_FULL].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_FULL].behaviour[XACB_DRAG]=NULL;
 		wind->widgets[XAW_FULL].loc=stdl_full;
@@ -411,10 +410,10 @@
 
 	if (tp&SIZER)
 	{
-		wind->widgets[XAW_RESIZE].behaviour[XACB_DISPLAY]=&display_resize;
+		wind->widgets[XAW_RESIZE].behaviour[XACB_DISPLAY]=display_resize;
 		wind->widgets[XAW_RESIZE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_RESIZE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_RESIZE].behaviour[XACB_DRAG]=&drag_resize;
+		wind->widgets[XAW_RESIZE].behaviour[XACB_DRAG]=drag_resize;
 		wind->widgets[XAW_RESIZE].loc=stdl_resize;
 		wind->widgets[XAW_RESIZE].stat=XAW_PLAIN;
 		wind->widgets[XAW_RESIZE].w=ICON_W;
@@ -423,10 +422,10 @@
 	
 	if (tp&UPARROW)
 	{
-		wind->widgets[XAW_UP].behaviour[XACB_DISPLAY]=&display_uscroll;
-		wind->widgets[XAW_UP].behaviour[XACB_CLICK]=&click_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_DISPLAY]=display_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_CLICK]=click_uscroll;
 		wind->widgets[XAW_UP].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_UP].behaviour[XACB_DRAG]=&click_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_DRAG]=click_uscroll;
 		wind->widgets[XAW_UP].loc=stdl_uscroll;
 		wind->widgets[XAW_UP].stat=XAW_PLAIN;
 		wind->widgets[XAW_UP].w=ICON_W;
@@ -434,10 +433,10 @@
 	}
 	if (tp&DNARROW)
 	{
-		wind->widgets[XAW_DOWN].behaviour[XACB_DISPLAY]=&display_dscroll;
-		wind->widgets[XAW_DOWN].behaviour[XACB_CLICK]=&click_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_DISPLAY]=display_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_CLICK]=click_dscroll;
 		wind->widgets[XAW_DOWN].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_DOWN].behaviour[XACB_DRAG]=&click_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_DRAG]=click_dscroll;
 		wind->widgets[XAW_DOWN].loc=stdl_dscroll;
 		wind->widgets[XAW_DOWN].stat=XAW_PLAIN;
 		wind->widgets[XAW_DOWN].w=ICON_W;
@@ -445,10 +444,10 @@
 	}
 	if (tp&LFARROW)
 	{
-		wind->widgets[XAW_LEFT].behaviour[XACB_DISPLAY]=&display_lscroll;
-		wind->widgets[XAW_LEFT].behaviour[XACB_CLICK]=&click_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_DISPLAY]=display_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_CLICK]=click_lscroll;
 		wind->widgets[XAW_LEFT].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_LEFT].behaviour[XACB_DRAG]=&click_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_DRAG]=click_lscroll;
 		wind->widgets[XAW_LEFT].loc=stdl_lscroll;
 		wind->widgets[XAW_LEFT].stat=XAW_PLAIN;
 		wind->widgets[XAW_LEFT].w=ICON_W;
@@ -456,10 +455,10 @@
 	}
 	if (tp&RTARROW)
 	{
-		wind->widgets[XAW_RIGHT].behaviour[XACB_DISPLAY]=&display_rscroll;
-		wind->widgets[XAW_RIGHT].behaviour[XACB_CLICK]=&click_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_DISPLAY]=display_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_CLICK]=click_rscroll;
 		wind->widgets[XAW_RIGHT].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_RIGHT].behaviour[XACB_DRAG]=&click_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_DRAG]=click_rscroll;
 		wind->widgets[XAW_RIGHT].loc=stdl_rscroll;
 		wind->widgets[XAW_RIGHT].stat=XAW_PLAIN;
 		wind->widgets[XAW_RIGHT].w=ICON_W;
@@ -468,10 +467,10 @@
 
 	if (tp&VSLIDE)
 	{
-		wind->widgets[XAW_VSLIDE].behaviour[XACB_DISPLAY]=&display_vslide;
+		wind->widgets[XAW_VSLIDE].behaviour[XACB_DISPLAY]=display_vslide;
 		wind->widgets[XAW_VSLIDE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_VSLIDE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_VSLIDE].behaviour[XACB_DRAG]=&drag_vslide;
+		wind->widgets[XAW_VSLIDE].behaviour[XACB_DRAG]=drag_vslide;
 		wind->widgets[XAW_VSLIDE].loc=stdl_vslide;
 		wind->widgets[XAW_VSLIDE].stat=XAW_PLAIN;
 		wind->widgets[XAW_VSLIDE].w=ICON_W;
@@ -483,10 +482,10 @@
 	
 	if (tp&HSLIDE)
 	{
-		wind->widgets[XAW_HSLIDE].behaviour[XACB_DISPLAY]=&display_hslide;
+		wind->widgets[XAW_HSLIDE].behaviour[XACB_DISPLAY]=display_hslide;
 		wind->widgets[XAW_HSLIDE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_HSLIDE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_HSLIDE].behaviour[XACB_DRAG]=&drag_hslide;
+		wind->widgets[XAW_HSLIDE].behaviour[XACB_DRAG]=drag_hslide;
 		wind->widgets[XAW_HSLIDE].loc=stdl_hslide;
 		wind->widgets[XAW_HSLIDE].stat=XAW_PLAIN;
 		wind->widgets[XAW_HSLIDE].w=ICON_W;
@@ -498,7 +497,7 @@
 
 	if (tp&INFO)
 	{
-		wind->widgets[XAW_INFO].behaviour[XACB_DISPLAY]=&display_info;
+		wind->widgets[XAW_INFO].behaviour[XACB_DISPLAY]=display_info;
 		wind->widgets[XAW_INFO].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_INFO].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_INFO].behaviour[XACB_DRAG]=NULL;
@@ -506,7 +505,7 @@
 		wind->widgets[XAW_INFO].stat=XAW_PLAIN;
 		wind->widgets[XAW_INFO].w=top_w;
 		wind->widgets[XAW_INFO].h=display.c_max_h+4;
-		wind->widgets[XAW_INFO].stuff=(void*)"Info Bar";		// Give the window a default info line until the client changes it
+		wind->widgets[XAW_INFO].stuff=(void*)"Info Bar";		/* Give the window a default info line until the client changes it*/
 		
 		if (tp&(NAME|CLOSE|FULLER))
 		{
@@ -517,7 +516,7 @@
 		}
 		
 		bit_mask=tp&(~(INFO|NAME|CLOSE|FULLER));
-		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	// Shift any widgets we might interfere with
+		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	/* Shift any widgets we might interfere with*/
 		{
 			if (bit_mask&1L)
 			{
@@ -532,21 +531,21 @@
 		}
 	}
 
-// do this last as it's a variable size depending on which widgets are on the top bar
+/* do this last as it's a variable size depending on which widgets are on the top bar*/
 	if (tp&NAME)
 	{
-		wind->widgets[XAW_TITLE].behaviour[XACB_DISPLAY]=&display_title;
-		wind->widgets[XAW_TITLE].behaviour[XACB_CLICK]=&click_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_DISPLAY]=display_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_CLICK]=click_title;
 		wind->widgets[XAW_TITLE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_TITLE].behaviour[XACB_DRAG]=&drag_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_DRAG]=drag_title;
 		wind->widgets[XAW_TITLE].loc=stdl_title;
 		wind->widgets[XAW_TITLE].stat=XAW_PLAIN;
-		wind->widgets[XAW_TITLE].w=top_w;						// Actually, this is re-calculated anyway...
+		wind->widgets[XAW_TITLE].w=top_w;						/* Actually, this is re-calculated anyway...*/
 		wind->widgets[XAW_TITLE].h=display.c_max_h+2;
-		wind->widgets[XAW_TITLE].stuff=(void*)"XaAES Window";	// Give the window a default title until the client changes it
+		wind->widgets[XAW_TITLE].stuff=(void*)"XaAES Window";	/* Give the window a default title until the client changes it*/
 		
 		bit_mask=tp&(~(INFO|NAME|CLOSE|FULLER));
-		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	// Shift any widgets we might interfere with
+		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	/* Shift any widgets we might interfere with*/
 		{
 			if (bit_mask&1L)
 			{
@@ -582,17 +581,17 @@
 	nt->tree=obj;
 	nt->is_menu=TRUE;
 	
-	wind->widgets[XAW_MENU].behaviour[XACB_DISPLAY]=&display_menu_widget;
-	wind->widgets[XAW_MENU].behaviour[XACB_CLICK]=&click_menu_widget;
+	wind->widgets[XAW_MENU].behaviour[XACB_DISPLAY]=display_menu_widget;
+	wind->widgets[XAW_MENU].behaviour[XACB_CLICK]=click_menu_widget;
 	wind->widgets[XAW_MENU].behaviour[XACB_DCLICK]=NULL;
 	wind->widgets[XAW_MENU].behaviour[XACB_DRAG]=NULL;
 	wind->widgets[XAW_MENU].loc=loc;
-	wind->widgets[XAW_MENU].stat=XAW_MENUSTATE;	// Special status value for menu's
+	wind->widgets[XAW_MENU].stat=XAW_MENUSTATE;	/* Special status value for menu's*/
 	wind->widgets[XAW_MENU].w=wind->w-4;
 	wind->widgets[XAW_MENU].h=display.c_max_h;
 	wind->widgets[XAW_MENU].stuff=(void*)nt;
 
-	calc_work_area(wind);			// Recalculate the work area to include the new menu widget
+	calc_work_area(wind);			/* Recalculate the work area to include the new menu widget*/
 }
 
 /*
@@ -614,28 +613,28 @@
 	nt->tree=obj;
 	nt->is_menu=FALSE;
 	
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DISPLAY]=&display_object_widget;
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=&click_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DISPLAY]=display_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=click_object_widget;
 	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DCLICK]=NULL;
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=&click_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=click_object_widget;
 	wind->widgets[XAW_TOOLBAR].loc=loc;
-	wind->widgets[XAW_TOOLBAR].stat=XAW_TOOLBARSTATE;	// Special status value for toolbars
+	wind->widgets[XAW_TOOLBAR].stat=XAW_TOOLBARSTATE;	/* Special status value for toolbars*/
 	wind->widgets[XAW_TOOLBAR].w=obj->ob_width;
 	wind->widgets[XAW_TOOLBAR].h=obj->ob_height;
 	wind->widgets[XAW_TOOLBAR].stuff=(void*)nt;
 
-	calc_work_area(wind);			// Recalculate the work area to include the new menu widget
+	calc_work_area(wind);			/* Recalculate the work area to include the new menu widget*/
 }
 
-// Process widget clicks, and call the appropriate handler routines
-// This is the main routine for handling window interaction from a users perspective.
-// Each widget has a set of behaviours (display, drag, click, etc) for each of it's widgets.
-// - these can be changed on an individual basis, so the close widget of one window might
-//   call a that sends a 'go back up a directory' message to the desktop, where-as on another
-//   it may just take the GEM default and send a WM_CLOSED message to the application.
-// NOTE: If a widget has no XACB_DISPLAY behaviour, it will not recieve clicks (this is
-// deliberate as it's not a good idea to have invisible widgets that still get clicked
-// on.
+/* Process widget clicks, and call the appropriate handler routines*/
+/* This is the main routine for handling window interaction from a users perspective.*/
+/* Each widget has a set of behaviours (display, drag, click, etc) for each of it's widgets.*/
+/* - these can be changed on an individual basis, so the close widget of one window might*/
+/*   call a that sends a 'go back up a directory' message to the desktop, where-as on another*/
+/*   it may just take the GEM default and send a WM_CLOSED message to the application.*/
+/* NOTE: If a widget has no XACB_DISPLAY behaviour, it will not recieve clicks (this is*/
+/* deliberate as it's not a good idea to have invisible widgets that still get clicked*/
+/* on.*/
 short do_widgets(XA_WINDOW *w, MOUSE_DATA *md)
 {
 	XA_RECT_LIST *rl=generate_rect_list(w);
@@ -649,69 +648,69 @@
 	clicks=md->clicks;
 	if (clicks>2) clicks=2;
 
-	for(f=0; (f<XA_MAX_WIDGETS)&&(this_widget==NULL); f++)		// Scan through widgets to find the one we clicked on
+	for(f=0; (f<XA_MAX_WIDGETS)&&(this_widget==NULL); f++)		/* Scan through widgets to find the one we clicked on*/
 	{
 		widg=w->widgets+f;
-		disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
+		disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
 		if (disp)
 		{
-			rp_2_ap(w, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+			rp_2_ap(w, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 			if ((((md->mx>x)&&(md->my>y))&&(md->mx<x+widg->w))&&(md->my<y+widg->h))
 			{
-				this_widget=widg;			// Found a widget - this_widget acts as a flag that says to absorb the click
+				this_widget=widg;			/* Found a widget - this_widget acts as a flag that says to absorb the click*/
 
-				widg->click_x=md->mx-x; 	// Mark where the click occurred (relative to the widget)
+				widg->click_x=md->mx-x; 	/* Mark where the click occurred (relative to the widget)*/
 				widg->click_y=md->my-y;	
 
-											// We don't auto select & pre-display for a menu or toolbar widget
+											/* We don't auto select & pre-display for a menu or toolbar widget*/
 				if ((f!=XAW_MENU)&&(f!=XAW_TOOLBAR))
 				{
-					widg->stat=XAW_SELECTED;	// Flag the widget as selected
+					widg->stat=XAW_SELECTED;	/* Flag the widget as selected*/
 				
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
 						vs_clip(V_handle,1, clip);
-						(*disp)(w, this_widget);	// display the selected widget
+						(*disp)(w, this_widget);	/* display the selected widget*/
 					}
 					v_show_c(V_handle, 1);
 				}
 
-				wdrag=this_widget->behaviour[XACB_DRAG];	// get the click-drag function for this widget
+				wdrag=this_widget->behaviour[XACB_DRAG];	/* get the click-drag function for this widget*/
 
 				vq_mouse(V_handle, &b,&rx,&ry);
-				if ((b)&&(wdrag))	// If the mouse button is still down do a drag (if the widget has a drag behaviour)
+				if ((b)&&(wdrag))	/* If the mouse button is still down do a drag (if the widget has a drag behaviour)*/
 				{
 					rtn=(*wdrag)(w, this_widget);
-				}else{							// otherwise, process as a mouse click(s)
+				}else{							/* otherwise, process as a mouse click(s)*/
 	
-					while (b)					// wait for the mouse to be released
+					while (b)					/* wait for the mouse to be released*/
 						vq_mouse(V_handle, &b,&rx,&ry);
 				
 					if ((((rx>x)&&(ry>y))&&(rx<x+widg->w))&&(ry<y+widg->h))
 					{
 						wc=this_widget->behaviour[clicks];
-						if (wc)							// If the widget has a click behaviour, call it
+						if (wc)							/* If the widget has a click behaviour, call it*/
 						{
 							rtn=(*wc)(w, this_widget);
 						}
 					}
 				}
 				
-				if (rtn)	// If the widget click/drag function returned TRUE we reset the state of the widget
+				if (rtn)	/* If the widget click/drag function returned TRUE we reset the state of the widget*/
 				{
-					widg->stat=XAW_PLAIN;			// Flag the widget as de-selected
+					widg->stat=XAW_PLAIN;			/* Flag the widget as de-selected*/
 			
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)	// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)	/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
 						vs_clip(V_handle,1, clip);
-						(*disp)(w, this_widget);	// display the selected widget
+						(*disp)(w, this_widget);	/* display the selected widget*/
 					}
 					v_show_c(V_handle, 1);
 				}
@@ -719,14 +718,14 @@
 		}
 	}
 
-	while(rl)	// Dispose of rectangle list
+	while(rl)	/* Dispose of rectangle list*/
 	{
 		drl=rl;
 		rl=rl->next;
 		free(drl);
 	}
 	
-	if (this_widget) return TRUE;	// Button click was used up by the GUI
+	if (this_widget) return TRUE;	/* Button click was used up by the GUI*/
 	
-	return FALSE;					// Button click can be passed on to applications as we didn't use it for a widget
+	return FALSE;					/* Button click can be passed on to applications as we didn't use it for a widget*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/titlwidg.c /h/xaaes/titlwidg.c
--- /i/newitems/XaAES.beta2/src/titlwidg.c	Thu Feb  8 02:32:28 1996
+++ /h/xaaes/titlwidg.c	Thu Feb 22 13:07:12 1996
@@ -18,6 +18,7 @@
 #include "RECTLIST.H"
 #include "ALL_WIDG.H"
 #include "STD_WIDG.H"
+#include "drag_box.h"
 
 /*======================================================
 	TITLE WIDGET BEHAVIOUR
@@ -26,10 +27,10 @@
 {
 	short x,y,pnt[4];
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 #if DISPLAY_LOGO_IN_TITLE_BAR
-	if (widg->stat==XAW_PLAIN)	// display the XaAES logo on the title bar of each window
+	if (widg->stat==XAW_PLAIN)	/* display the XaAES logo on the title bar of each window*/
 		display_widget_bitmap(x, y, bitmap_xaaes16);
 	else
 		display_widget_bitmap(x, y, bitmap_xaaes16_s);
@@ -40,7 +41,7 @@
 	pnt[0]=x; pnt[1]=y; pnt[2]=x+widg->w-3; pnt[3]=y+widg->h;
 #endif
 
-	if (window_list==wind)	// Highlight the title bar of the top window
+	if (window_list==wind)	/* Highlight the title bar of the top window*/
 	{
 		vsf_color(V_handle,LBLUE);
 		vsf_interior(V_handle,FIS_SOLID);
@@ -55,32 +56,32 @@
 	return TRUE;
 }
 
-// Click & drag on the title bar - does a move window
+/* Click & drag on the title bar - does a move window*/
 short drag_title(XA_WINDOW *wind, XA_WIDGET *widg)
 {
-	short x,y;
+	short x,y,xy[4];
 
-	if (wind->active_widgets&MOVER)			// You can only move a window if it's MOVER attribute is set
+	if (wind->active_widgets&MOVER)			/* You can only move a window if it's MOVER attribute is set*/
 	{
-		vs_clip(V_handle, 0, NULL);
+		vs_clip(V_handle, 0, xy);
 
-		graf_mouse(XACRS_MOVER, NULL);		// Always have a nice consistent MOVER when dragging a box
+		graf_mouse(XACRS_MOVER, NULL);		/* Always have a nice consistent MOVER when dragging a box*/
 		drag_box(wind->w, wind->h, wind->x, wind->y, display.x, display.y, display.w, display.h, &x, &y);
 		
-		graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	// Restore the mouse now we've done the drag
+		graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	/* Restore the mouse now we've done the drag*/
 
 		if ((x!=wind->x)||(y!=wind->y))
 		{
-			if (wind->owner==AESpid)			// Just move AES owned windows, they can handle it....
+			if (wind->owner==AESpid)			/* Just move AES owned windows, they can handle it....*/
 			{
 				v_hide_c(V_handle);
 				
 				erase_non_topped_window(wind);
 				display_windows_below(wind);
 
-				wind->prev_x=wind->x;			// Save windows previous coords
+				wind->prev_x=wind->x;			/* Save windows previous coords*/
 				wind->prev_y=wind->y;
-				wind->x=x;						// Change the window coords
+				wind->x=x;						/* Change the window coords*/
 				wind->y=y;
 
 				calc_work_area(wind);
@@ -89,7 +90,7 @@
 			
 				v_show_c(V_handle,1);
 
-			}else{	// Send a message to a client to say that the AES would like the window moving (if the window has moved)
+			}else{	/* Send a message to a client to say that the AES would like the window moving (if the window has moved)*/
 				send_app_message(wind->owner, WM_MOVED, 0, wind->handle, x, y, wind->w, wind->h);
 			}
 		}
@@ -102,19 +103,19 @@
 {
 	short clip[4];
 
-	if (window_list!=wind)	// If window isn't top then top it
+	if (window_list!=wind)	/* If window isn't top then top it*/
 	{
 	
 		if (wind->owner==AESpid)
 		{
-			pull_wind_to_top(wind);	// Top the window
+			pull_wind_to_top(wind);	/* Top the window*/
 
 			clip[0]=wind->x; clip[1]=wind->y;
 			clip[2]=wind->x+wind->w; clip[3]=wind->y+wind->h;
 			vs_clip(V_handle,1,clip);
 			
 			v_hide_c(V_handle);
-			display_window(wind);	// Display the window (clip to it's size)
+			display_window(wind);	/* Display the window (clip to it's size)*/
 			v_show_c(V_handle,1);
 			
 			vs_clip(V_handle,0,clip);
@@ -125,16 +126,16 @@
 	
 		}
 	
-	}else{		// If window is already top, then send it to the back
+	}else{		/* If window is already top, then send it to the back*/
 
 		if (wind->owner==AESpid)
 		{
 			v_hide_c(V_handle);
 
-			display_windows_below(wind);	// Redisplay any windows below the one we are bottoming
-											// (if they require it)
-			send_wind_to_bottom(wind);		// Send it to the back
-			display_non_topped_window(wind);// Re-display the window
+			display_windows_below(wind);	/* Redisplay any windows below the one we are bottoming*/
+											/* (if they require it)*/
+			send_wind_to_bottom(wind);		/* Send it to the back*/
+			display_non_topped_window(wind);/* Re-display the window*/
 
 			v_show_c(V_handle,1);
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/watchbox.c /h/xaaes/watchbox.c
--- /i/newitems/XaAES.beta2/src/watchbox.c	Sun Feb 11 19:16:26 1996
+++ /h/xaaes/watchbox.c	Wed Feb 21 13:45:24 1996
@@ -31,12 +31,12 @@
 	
 	vq_mouse(V_handle,&mb,&omx,&omy);
 	
-	object_abs_coords(dial, ob, &x, &y);	// call XaAES's internal objc_offset()
+	object_abs_coords(dial, ob, &x, &y);	/* call XaAES's internal objc_offset()*/
 	w=the_object->ob_width+2;
 	h=the_object->ob_height+2;
 	x--; y--;
 
-	if (!mb)		// If mouse button is already released, assume that was just a click, so select
+	if (!mb)		/* If mouse button is already released, assume that was just a click, so select*/
 	{
 		(dial+ob)->ob_state=in_state;
 		v_hide_c(V_handle);
@@ -45,8 +45,8 @@
 		obf=ob;
 	}else{
 	
-		while (mb)		// This loop contains a pretty busy wait, but I don't think it's to
-		{				// much of a problem as the user is interacting with it continuously.
+		while (mb)		/* This loop contains a pretty busy wait, but I don't think it's to*/
+		{				/* much of a problem as the user is interacting with it continuously.*/
 			vq_mouse(V_handle,&mb,&mx,&my);
 		
 			if ((mx!=omx)||(my!=omy))
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/wind_fns.c /h/xaaes/wind_fns.c
--- /i/newitems/XaAES.beta2/src/wind_fns.c	Thu Feb 15 00:12:58 1996
+++ /h/xaaes/wind_fns.c	Thu Feb 22 18:53:18 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <VDI.H>
 #include <MINTBIND.H>
 #include <OSBIND.H>
@@ -19,6 +20,8 @@
 #include "INFOWIDG.H"
 #include "TITLWIDG.H"
 #include "STD_WIDG.H"
+#include "graf_mou.h"
+#include "messages.h"
 
 /*
 	AES window handling functions
@@ -38,9 +41,9 @@
 
 	DIAGS(("  - window created (handle=%d)\n",new_window->handle));
 
-	pb->intout[0]=new_window->handle;	// Return the window handle in intout[0]
+	pb->intout[0]=new_window->handle;	/* Return the window handle in intout[0]*/
 
-	return TRUE;	// Allow the kernal to wake up the client - we've done our bit
+	return TRUE;	/* Allow the kernal to wake up the client - we've done our bit*/
 }
 
 short XA_wind_open(short clnt_pid,AESPB *pb)
@@ -49,18 +52,18 @@
 
 	DIAGS(("wind_open() - "));
 
-	w=get_wind_by_handle(pb->intin[0]);	// Get the window
+	w=get_wind_by_handle(pb->intin[0]);	/* Get the window*/
 
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 	
-	pb->intout[0]=1;				// return ok in intout[0]
+	pb->intout[0]=1;				/* return ok in intout[0]*/
 	
-	if (w->is_open==TRUE)			// the window is already open, no need to do anything
+	if (w->is_open==TRUE)			/* the window is already open, no need to do anything*/
 	{
 		DIAGS(("WARNING: Attempt to open window when it was already open\n"));
 		return TRUE;
@@ -68,29 +71,29 @@
 
 	DIAGS(("\n"));
 
-	// New top window - change the cursor to this clients choice
+	/* New top window - change the cursor to this clients choice*/
 	graf_mouse(clients[clnt_pid].client_mouse, clients[clnt_pid].client_mouse_form);
 	
-	pull_wind_to_top(w);			// Newly opened windows begin on top
+	pull_wind_to_top(w);			/* Newly opened windows begin on top*/
 
 	wl=w->next;
-	if (wl)		// Refresh the previous top window as being 'non-topped'
+	if (wl)		/* Refresh the previous top window as being 'non-topped'*/
 	{
 		display_non_topped_window(wl);
 		send_app_message(wl->owner, WM_REDRAW, 0, wl->handle, wl->x, wl->y, wl->w, wl->h);
 	}
 	
-	w->x=pb->intin[1];				// Change the window coords
+	w->x=pb->intin[1];				/* Change the window coords*/
 	w->y=pb->intin[2];
 	w->w=pb->intin[3];
 	w->h=pb->intin[4];
 
-	w->is_open=TRUE;				// Flag window as open
+	w->is_open=TRUE;				/* Flag window as open*/
 
 	calc_work_area(w);
 
 	v_hide_c(V_handle);
-	display_non_topped_window(w);	// Display the window (use the non-topped method as it sets clipping rectangles)
+	display_non_topped_window(w);	/* Display the window (use the non-topped method as it sets clipping rectangles)*/
 	send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 	v_show_c(V_handle,1);
 
@@ -103,35 +106,35 @@
 	
 	DIAGS(("wind_close() - "));
 
-	w=get_wind_by_handle(pb->intin[0]);	// Get the window
+	w=get_wind_by_handle(pb->intin[0]);	/* Get the window*/
 
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
-	if (w->owner!=clnt_pid)		// Clients can only close their own windows
+	if (w->owner!=clnt_pid)		/* Clients can only close their own windows*/
 	{
 		DIAGS(("WARNING: clnt %d cannot close window %d (not owner)\n",clnt_pid,w->handle));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
 	v_hide_c(V_handle);
 
-	erase_non_topped_window(w);			// Erase the window
-	redraw_area(w->x,w->y,w->w,w->h);	// The redraw should really get done here
-	display_windows_below(w);			// Redisplay any windows below the one we are closing
+	erase_non_topped_window(w);			/* Erase the window*/
+	redraw_area(w->x,w->y,w->w,w->h);	/* The redraw should really get done here*/
+	display_windows_below(w);			/* Redisplay any windows below the one we are closing*/
 
 	v_show_c(V_handle,1);
 
 	send_wind_to_bottom(w);
 
-	w->is_open=FALSE;		// tag window as closed
+	w->is_open=FALSE;		/* tag window as closed*/
 
-	// New top window - change the cursor to this clients choice
+	/* New top window - change the cursor to this clients choice*/
 	graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);
 	
 	pb->intout[0]=1;
@@ -146,7 +149,7 @@
 	
 	DIAGS(("wind_find() - "));
 
-	w=wind_find(pb->intin[0], pb->intin[1]);	// Is there a window under the mouse?
+	w=wind_find(pb->intin[0], pb->intin[1]);	/* Is there a window under the mouse?*/
 
 	if (w==NULL)
 	{
@@ -155,7 +158,7 @@
 		return TRUE;
 	}
 
-	pb->intout[0]=w->handle;	// Found a window, return the handle
+	pb->intout[0]=w->handle;	/* Found a window, return the handle*/
 
 	DIAGS(("\n"));
 	
@@ -169,14 +172,14 @@
 	XA_WIDGET *widg=wind->widgets;
 	widg+=XAW_VSLIDE;
 	
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 	
 	v_hide_c(V_handle);
-	for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+	for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 	{
 		clip[0]=drl->x; clip[1]=drl->y;
 		clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -194,7 +197,7 @@
 	XA_WIDGET *widg=wind->widgets;
 	widg+=XAW_HSLIDE;
 	
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
@@ -203,7 +206,7 @@
 	vsf_interior(V_handle,FIS_SOLID);
 	
 	v_hide_c(V_handle);
-	for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+	for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 	{
 		clip[0]=drl->x; clip[1]=drl->y;
 		clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -229,14 +232,14 @@
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
-	if (w->owner!=clnt_pid)		// Clients can only change their own windows
+	if (w->owner!=clnt_pid)		/* Clients can only change their own windows*/
 	{
 		DIAGS(("WARNING: clnt %d cannot change window %d (not owner)\n",clnt_pid,w->handle));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 	
@@ -297,7 +300,7 @@
 			break;
 		case WF_NAME:
 			l=(unsigned short*)(pb->intin);
-			t=(char*)(l[2]<<16);
+			t=(char*)((long)l[2]<<16L);
 			t+=l[3];
 			w->widgets[XAW_TITLE].stuff=(void*)t;
 
@@ -314,14 +317,14 @@
 					rl=rl->next;
 					free(drl);
 				}
-//				display_non_topped_window(w);
-//				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
+/*				display_non_topped_window(w);*/
+/*				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);*/
 			}
 			v_show_c(V_handle,1);
 			break;
 		case WF_INFO:
 			l=(unsigned short*)(pb->intin);
-			t=(char*)(l[2]<<16);
+			t=(char*)((long)l[2]<<16L);
 			t+=l[3];
 			w->widgets[XAW_INFO].stuff=(void*)t;
 
@@ -338,49 +341,49 @@
 					rl=rl->next;
 					free(drl);
 				}
-//				display_non_topped_window(w);
-//				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
+/*				display_non_topped_window(w);*/
+/*				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);*/
 			}
 			v_show_c(V_handle,1);
 			break;
-		case WF_CURRXYWH:			// Move a window
+		case WF_CURRXYWH:			/* Move a window*/
 			v_hide_c(V_handle);
 			erase_non_topped_window(w);
-			display_windows_below(w);	// Redisplay any windows below the one we are moving
-										// (if they require it)
+			display_windows_below(w);	/* Redisplay any windows below the one we are moving*/
+										/* (if they require it)*/
 
-			w->prev_x=w->x;				// Save windows previous coords
+			w->prev_x=w->x;				/* Save windows previous coords*/
 			w->prev_y=w->y;
 			w->prev_w=w->w;
 			w->prev_h=w->h;
 			
-			w->x=pb->intin[2];			// Change the window coords
+			w->x=pb->intin[2];			/* Change the window coords*/
 			w->y=pb->intin[3];
 			w->w=pb->intin[4];
 			w->h=pb->intin[5];
 
-			calc_work_area(w);			// Recalculate the work area (as well as moving,
-										// it might have changed size).
+			calc_work_area(w);			/* Recalculate the work area (as well as moving,*/
+										/* it might have changed size).*/
 			
-			display_non_topped_window(w);	// Re-display the window
+			display_non_topped_window(w);	/* Re-display the window*/
 			
 			send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 			v_show_c(V_handle,1);
 
 			break;
-		case WF_BOTTOM:				// Extension, send window to the bottom
+		case WF_BOTTOM:				/* Extension, send window to the bottom*/
 			v_hide_c(V_handle);
-			display_windows_below(w);		// Redisplay any windows below the one we are bottoming
-											// (if they require it)
-			send_wind_to_bottom(w);			// Send it to the back
-			display_non_topped_window(w);	// Re-display the window
+			display_windows_below(w);		/* Redisplay any windows below the one we are bottoming*/
+											/* (if they require it)*/
+			send_wind_to_bottom(w);			/* Send it to the back*/
+			display_non_topped_window(w);	/* Re-display the window*/
 			v_show_c(V_handle,1);
 			break;
-		case WF_TOP:				// Top the window
+		case WF_TOP:				/* Top the window*/
 			pull_wind_to_top(w);
-							// New top window - change the cursor to this clients choice
+							/* New top window - change the cursor to this clients choice*/
 			graf_mouse(clients[clnt_pid].client_mouse, clients[clnt_pid].client_mouse_form);
-							// Display the previous top window as un-topped
+							/* Display the previous top window as un-topped*/
 			
 			v_hide_c(V_handle);
 			if ((window_list->next)&&(window_list->next->is_open))
@@ -388,7 +391,7 @@
 			
 			if (w->is_open)
 			{
-				display_non_topped_window(w);	// Display the window
+				display_non_topped_window(w);	/* Display the window*/
 				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 			}			
 			v_show_c(V_handle,1);
@@ -402,10 +405,10 @@
 	return TRUE;
 }
 
-// AES wind_get() function.
-// This includes support for most of the AES4 / AES4.1 extensions,
-// with the exception of WF_BEVENT (all XaAES windows get button events in the
-// background at the moment).
+/* AES wind_get() function.*/
+/* This includes support for most of the AES4 / AES4.1 extensions,*/
+/* with the exception of WF_BEVENT (all XaAES windows get button events in the*/
+/* background at the moment).*/
 short XA_wind_get(short clnt_pid, AESPB *pb)
 {
 	XA_WINDOW *w;
@@ -421,14 +424,14 @@
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
 	switch(cmd)
 	{
-		case WF_FIRSTXYWH:			// Generate a rectangle list and return the first entry
-			for(rl=w->rect_list; rl; )	// Dispose of any existing rectangle list
+		case WF_FIRSTXYWH:			/* Generate a rectangle list and return the first entry*/
+			for(rl=w->rect_list; rl; )	/* Dispose of any existing rectangle list*/
 			{
 				drl=rl;
 				rl=rl->next;
@@ -436,9 +439,9 @@
 			}
 			w->rect_list=NULL;
 			
-			rl=generate_rect_list(w);	// Call the internal rectangle list generator.
+			rl=generate_rect_list(w);	/* Call the internal rectangle list generator.*/
 			
-			for(drl=rl; rl; drl=rl)		// Fix the rectangle list to clip to the work area only
+			for(drl=rl; rl; drl=rl)		/* Fix the rectangle list to clip to the work area only*/
 			{
 				s.g_x=rl->x;
 				s.g_y=rl->y;
@@ -449,8 +452,8 @@
 				d.g_w=w->ww;
 				d.g_h=w->wh;
 				rl=rl->next;
-				if (rc_intersect(&s, &d))	// Optimise the rectangle list to only do bit's 
-				{							// that intersect the work area
+				if (rc_intersect(&s, &d))	/* Optimise the rectangle list to only do bit's */
+				{							/* that intersect the work area*/
 					drl->x=d.g_x;
 					drl->y=d.g_y;
 					drl->w=d.g_w+1;
@@ -462,100 +465,100 @@
 				}
 			}
 
-			if (w->rect_list)			// Did we get any rectangles?
+			if (w->rect_list)			/* Did we get any rectangles?*/
 			{
 				rl=w->rect_list;
 				w->rect_list=rl->next;
-				pb->intout[1]=rl->x;	// Return the first rectangle coords
+				pb->intout[1]=rl->x;	/* Return the first rectangle coords*/
 				pb->intout[2]=rl->y;
 				pb->intout[3]=rl->w;
 				pb->intout[4]=rl->h;
-				free(rl);				// Dispose the first entry in the rectangle list
+				free(rl);				/* Dispose the first entry in the rectangle list*/
 			}else{
-				pb->intout[1]=w->wx;	// Totally obscured window, return w & h as 0
+				pb->intout[1]=w->wx;	/* Totally obscured window, return w & h as 0*/
 				pb->intout[2]=w->wy;
 				pb->intout[3]=0;
 				pb->intout[4]=0;
-				w->rect_list=NULL;		// Window has no rectangle list
+				w->rect_list=NULL;		/* Window has no rectangle list*/
 			}
 			break;
-		case WF_NEXTXYWH:			// Get next entry from a rectangle list
-			if (w->rect_list!=NULL)		// Are there any rectangles left in the list ?
+		case WF_NEXTXYWH:			/* Get next entry from a rectangle list*/
+			if (w->rect_list!=NULL)		/* Are there any rectangles left in the list ?*/
 			{
 				rl=w->rect_list;
 				w->rect_list=rl->next;
-				pb->intout[1]=rl->x;	// Return the next rectangle coords
+				pb->intout[1]=rl->x;	/* Return the next rectangle coords*/
 				pb->intout[2]=rl->y;
 				pb->intout[3]=rl->w;
 				pb->intout[4]=rl->h;
-				free(rl);				// Dispose the entry in the rectangle list
+				free(rl);				/* Dispose the entry in the rectangle list*/
 			}else{
-				pb->intout[1]=0;		// No rectangles left - return all zero
+				pb->intout[1]=0;		/* No rectangles left - return all zero*/
 				pb->intout[2]=0;
 				pb->intout[3]=0;
 				pb->intout[4]=0;
 			}
 			break;
-		case WF_CURRXYWH:			// Get the current coords of the window
-			pb->intout[1]=w->x;		// Return the window coords
+		case WF_CURRXYWH:			/* Get the current coords of the window*/
+			pb->intout[1]=w->x;		/* Return the window coords*/
 			pb->intout[2]=w->y;
 			pb->intout[3]=w->w;
 			pb->intout[4]=w->h;
 			break;
-		case WF_WORKXYWH:			// Get the current coords of the window's user work area
+		case WF_WORKXYWH:			/* Get the current coords of the window's user work area*/
 			pb->intout[1]=w->wx+2;	
 			pb->intout[2]=w->wy+2;
 			pb->intout[3]=w->ww-4;
 			pb->intout[4]=w->wh-4;
 			break;
-		case WF_PREVXYWH:			// Get previous window position
+		case WF_PREVXYWH:			/* Get previous window position*/
 			pb->intout[1]=w->prev_x;
 			pb->intout[2]=w->prev_y;
 			pb->intout[3]=w->prev_w;
 			pb->intout[4]=w->prev_h;
 			break;			
-		case WF_FULLXYWH:			// Get maximum window dimensions
+		case WF_FULLXYWH:			/* Get maximum window dimensions*/
 			pb->intout[1]=root_window->x; 
-			pb->intout[2]=root_window->wy;	// ensure the windows don't overlay the menu bar
+			pb->intout[2]=root_window->wy;	/* ensure the windows don't overlay the menu bar*/
 			pb->intout[3]=root_window->w;
 			pb->intout[4]=root_window->h-root_window->wy;
 			break;
-		case WF_BOTTOM:				// Extension, gets the bottom window
+		case WF_BOTTOM:				/* Extension, gets the bottom window*/
 			for(w=window_list; w->next; w=w->next);
-			pb->intout[1]=w->handle;	// Return the window handle of the bottom window
-			pb->intout[2]=w->owner;		// Return the owner of the bottom window
+			pb->intout[1]=w->handle;	/* Return the window handle of the bottom window*/
+			pb->intout[2]=w->owner;		/* Return the owner of the bottom window*/
 			break;
 		case WF_TOP:
 			for(w=window_list; (w)&&(w->is_open==FALSE); w=w->next);
 			if (w)
 			{
-				pb->intout[1]=w->handle;	// Return the window handle
-				pb->intout[2]=w->owner;		// AES4 specifies that you return the AESid of the owner here as well
-				if (w->next)				// Is there a window below? 
-				{							// if there is, then AES4 says return it's handle here
+				pb->intout[1]=w->handle;	/* Return the window handle*/
+				pb->intout[2]=w->owner;		/* AES4 specifies that you return the AESid of the owner here as well*/
+				if (w->next)				/* Is there a window below? */
+				{							/* if there is, then AES4 says return it's handle here*/
 					pb->intout[3]=w->next->handle;
-					pb->intout[4]=w->next->owner;	// XaAES extentin - return the AESid of the app that owns the window below
+					pb->intout[4]=w->next->owner;	/* XaAES extentin - return the AESid of the app that owns the window below*/
 				}else{
 					pb->intout[3]=0;
 					pb->intout[4]=0;
 				}
 			}else{
-				pb->intout[1]=0;	// No windows open - return an error
+				pb->intout[1]=0;	/* No windows open - return an error*/
 				pb->intout[0]=0;
 				return TRUE;
 			}
 			break;
-		case WF_OWNER:				// AES4 compatible stuff
-			pb->intout[1]=w->owner;		// The window owners AESid (==app_id)
-			pb->intout[2]=w->is_open;	// Is the window open?
-			if (w->prev)				// If there is a window above, return it's handle
+		case WF_OWNER:				/* AES4 compatible stuff*/
+			pb->intout[1]=w->owner;		/* The window owners AESid (==app_id)*/
+			pb->intout[2]=w->is_open;	/* Is the window open?*/
+			if (w->prev)				/* If there is a window above, return it's handle*/
 			{
 				pb->intout[3]=w->prev->handle;
 			}else{
 				pb->intout[3]=0;
 			}
 			
-			if (w->next)				// If there is a window below, return it's handle
+			if (w->next)				/* If there is a window below, return it's handle*/
 			{
 				pb->intout[4]=w->next->handle;
 			}else{
@@ -610,34 +613,56 @@
 	return TRUE;
 }
 
-short update_lock=FALSE;			// These are now only here for debugging...
+short update_lock=FALSE;			/* These are now only here for debugging...*/
 short mouse_lock=FALSE;
+short update_cnt=0;
+short mouse_cnt=0;
 
-// Wind_update handling
-// This handles locking for the update and mctrl flags.
-// !!!!New version - uses semphores to locking...
+/* Wind_update handling*/
+/* This handles locking for the update and mctrl flags.*/
+/* !!!!New version - uses semphores to locking...*/
 short XA_wind_update(short clnt_pid, AESPB *pb)
 {
 	pb->intout[0]=1;
 	
 	switch(pb->intin[0])
 	{
-		case BEG_UPDATE:	// Grab the update lock
+		case BEG_UPDATE:	/* Grab the update lock*/
 			Psemaphore(2,UPDATE_LOCK,-1L);
+			if (update_lock == clnt_pid)
+				update_cnt++;
+			else
+				update_cnt = 0;
 			update_lock=clnt_pid;
 			break;
 		case END_UPDATE:
+			if (update_lock != clnt_pid)
+				return FALSE;	/* Should usually never happen */
+/* Only free the semaphore if this is really releasing the lock */
+			if (--update_cnt > 0)
+				break;
 			update_lock=FALSE;
 			Psemaphore(3,UPDATE_LOCK,0);
 			break;
-		case BEG_MCTRL:		// Grab the mouse lock
+		case BEG_MCTRL:		/* Grab the mouse lock*/
 			Psemaphore(2,MOUSE_LOCK,-1L);
+			if (mouse_lock == clnt_pid)
+				mouse_cnt++;
+			else
+				mouse_cnt = 0;
 			mouse_lock=clnt_pid;
 			break;
 		case END_MCTRL:
+			if (mouse_lock != clnt_pid)
+				return FALSE;
+			if (--mouse_cnt > 0)
+				break;
 			mouse_lock=FALSE;
 			Psemaphore(3,MOUSE_LOCK,0);
 			break;
+		default:
+			pb->intout[0] = 0;
+			return FALSE;
 	}
 	return TRUE;
 }
@@ -659,8 +684,8 @@
 	return TRUE;
 }
 
-// Go through and check that all windows belonging to this client are
-// closed and deleted 
+/* Go through and check that all windows belonging to this client are*/
+/* closed and deleted. Also release any locks of this client. */
 short XA_wind_new(short clnt_pid, AESPB *pb)
 {
 	XA_WINDOW *wl,*dwl;
@@ -672,14 +697,14 @@
 			dwl=wl;
 
 			v_hide_c(V_handle);
-			erase_non_topped_window(wl);			// Erase the window
-			redraw_area(wl->x,wl->y,wl->w,wl->h);	// The redraw should really get done here
-			display_windows_below(wl);				// Redisplay any windows below the one we are closing
+			erase_non_topped_window(wl);			/* Erase the window*/
+			redraw_area(wl->x,wl->y,wl->w,wl->h);	/* The redraw should really get done here*/
+			display_windows_below(wl);				/* Redisplay any windows below the one we are closing*/
 			v_show_c(V_handle, 1);
 
 			wl=wl->next;
 			
-			if (window_list==dwl)					// Actually delete the window
+			if (window_list==dwl)					/* Actually delete the window*/
 				window_list=dwl->next;
 
 			if (dwl->prev) dwl->prev->next=dwl->next;
@@ -690,6 +715,19 @@
 			wl=wl->next;
 		}
 	}
+
+	if (update_lock == clnt_pid)
+	{
+		update_lock = FALSE;
+		update_cnt = 0;
+		Psemaphore(3, UPDATE_LOCK, 0);
+	}
+	if (mouse_lock == clnt_pid)
+	{
+		mouse_lock = FALSE;
+		mouse_cnt = 0;
+		Psemaphore(3, MOUSE_LOCK, 0);
+	}
 	
 	return TRUE;
 }
@@ -702,18 +740,18 @@
 	XA_WINDOW *w_temp;
 	short request=pb->intin[0];
 	
-// Create a temporary window with the required widgets
+/* Create a temporary window with the required widgets*/
 	w_temp=create_window(clnt_pid, pb->intin[1], pb->intin[2], pb->intin[3], pb->intin[4], pb->intin[5]);
 
 	switch(request)
 	{
-		case WC_BORDER:					// We have to work out the border size ourselves here
-			pb->intout[1]=2*w_temp->x - w_temp->wx;	//if you want to prove the maths here, draw two boxes one inside
-			pb->intout[2]=2*w_temp->y - w_temp->wy;	// the other, then sit and think about it for a while....
+		case WC_BORDER:					/* We have to work out the border size ourselves here*/
+			pb->intout[1]=2*w_temp->x - w_temp->wx;	/*if you want to prove the maths here, draw two boxes one inside*/
+			pb->intout[2]=2*w_temp->y - w_temp->wy;	/* the other, then sit and think about it for a while....*/
 			pb->intout[3]=2*w_temp->w - w_temp->ww +1;
 			pb->intout[4]=2*w_temp->h - w_temp->wh +1;
 			break;
-		case WC_WORK:					// Work area was calculated when the window was created
+		case WC_WORK:					/* Work area was calculated when the window was created*/
 			pb->intout[1]=w_temp->wx;
 			pb->intout[2]=w_temp->wy;
 			pb->intout[3]=w_temp->ww+1;
@@ -721,7 +759,7 @@
 			break;
 	}
 
-	delete_window(w_temp);		// Dispose of the temporary window we created
+	delete_window(w_temp);		/* Dispose of the temporary window we created*/
 
 	pb->intout[0]=1;
 	
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_aes.prj /h/xaaes/xa_aes.prj
--- /i/newitems/XaAES.beta2/src/xa_aes.prj	Mon Feb 19 13:57:56 1996
+++ /h/xaaes/xa_aes.prj	Thu Feb 22 20:06:22 1996
@@ -6,6 +6,7 @@
 C.O
 APPL_INI.C	[-gs -gx -b4 -r0 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=0]
 APP_MAN.C	[-gx -b4 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=1]
+APPL_MSG.C
 ALL_WIDG.C
 BOOTUP.C	[-gx -b4 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=1]	(XA_DEFS.H,FRM_ALRT.H,XA_TYPES.H,COOKIES.H)
 BOX3D.C
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_codes.h /h/xaaes/xa_codes.h
--- /i/newitems/XaAES.beta2/src/xa_codes.h	Sun Feb 18 22:25:18 1996
+++ /h/xaaes/xa_codes.h	Thu Feb 22 19:55:24 1996
@@ -12,9 +12,11 @@
 #ifndef _XA_CODES_H_
 #define _XA_CODES_H_
 
-// Standard GEM AES op-codes
+/* Standard GEM AES op-codes*/
 
 #define XA_APPL_INIT	10
+#define XA_APPL_READ	11
+#define XA_APPL_WRITE	12
 #define XA_APPL_FIND	13
 #define XA_APPL_EXIT	19
 #define XA_APPL_GETINFO	130
@@ -78,8 +80,8 @@
 #define XA_SHELL_FIND	124
 #define XA_SHELL_ENVRN	125
 
-// XaAES specific extended op-codes
-// (these all start at 250, well out of the way of standard AES calls)
+/* XaAES specific extended op-codes*/
+/* (these all start at 250, well out of the way of standard AES calls)*/
 #define XA_BUTTON_CLICK	250
 #define XA_NEW_CLIENT	251
 #define XA_CLIENT_EXIT	252
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_defs.h /h/xaaes/xa_defs.h
--- /i/newitems/XaAES.beta2/src/xa_defs.h	Mon Feb 19 14:15:02 1996
+++ /h/xaaes/xa_defs.h	Thu Feb 22 15:44:32 1996
@@ -8,63 +8,65 @@
 #ifndef _XA_DEFS_H_
 #define _XA_DEFS_H_
 
-//-----------------------------------------------------------------
-// COMPILE TIME SWITCHES
-// - define as 1 to turn on, 0 to turn off
-//-----------------------------------------------------------------
-//#define GENERATE_DIAGS		0		// Make the DIAGS macro print out diagnostics
+/*-----------------------------------------------------------------*/
+/* COMPILE TIME SWITCHES*/
+/* - define as 1 to turn on, 0 to turn off*/
+/*-----------------------------------------------------------------*/
+#ifndef GENERATE_DIAGS
+#define GENERATE_DIAGS		0			/* Make the DIAGS macro print out diagnostics*/
+#endif
 
-#define USE_DEBUG_VECTOR		0		// Hook trap3 instead of trap2 to allow debugging under GEM
+#define USE_DEBUG_VECTOR		0		/* Hook trap3 instead of trap2 to allow debugging under GEM*/
 
-#define FORCE_WINDOWS			0		// Force windows to do what the user says instead of just
-										// sending a WM_ message to the client (eg. if a window is topped
-										// do it straight away, and then send the client a message about it)
+#define FORCE_WINDOWS			0		/* Force windows to do what the user says instead of just*/
+										/* sending a WM_ message to the client (eg. if a window is topped*/
+										/* do it straight away, and then send the client a message about it)*/
 
-#define SOLID_BOXES				0		// Do graf_dragbox, graf_rubberbox, etc using a solid box instead of
-										// an outline
+#define SOLID_BOXES				0		/* Do graf_dragbox, graf_rubberbox, etc using a solid box instead of*/
+										/* an outline*/
 
-#define MONO_WIDGETS			0		// Compile with black & white widgets instead of colour ones
+#define MONO_WIDGETS			0		/* Compile with black & white widgets instead of colour ones*/
 
-#define DISPLAY_LOGO_IN_TITLE_BAR	1	// Display the XaAES logo in the title bar of each window
+#define DISPLAY_LOGO_IN_TITLE_BAR	1	/* Display the XaAES logo in the title bar of each window*/
 
-#define POINT_TO_TYPE			1		// 0=Keyboard input goes to topped application
-										// 1=Keyboard input goes to application whose window is pointed at
+#define POINT_TO_TYPE			0		/* 0=Keyboard input goes to topped application*/
+										/* 1=Keyboard input goes to application whose window is pointed at*/
 
-#define ALT_CTRL_APP_OPS		1		// Some ALT+CTRL+key combo's will perform functions relating to
-                       					// the XaAES system
+#define ALT_CTRL_APP_OPS		1		/* Some ALT+CTRL+key combo's will perform functions relating to*/
+                       					/* the XaAES system*/
 
-#define USE_TMALARM				1		// Use the 'un-official' Tmalarm() call to get better timing
+#define USE_TMALARM				1		/* Use the 'un-official' Tmalarm() call to get better timing*/
 
-#define USE_CALL_DIRECT			1		// Bypass the command pipe for certain op-codes
+#define USE_CALL_DIRECT			1		/* Bypass the command pipe for certain op-codes*/
 
-//-----------------------------------------------------------------
-// CONFIGURABLE PARAMETERS
-#define WIDGET_SIZE			20			// Default size of window widgets in pixels (for drawn widgets)
-#define MAX_PID				500			// Max number of client process'
-#define SHOW_LOGO_AT_STARTUP	1		// Run the XaAES logo program at startup
-#define AES_PRIORITY		-20			// The process priority for the XaAES server (-20 is high priority)
+/*-----------------------------------------------------------------*/
+/* CONFIGURABLE PARAMETERS*/
+#define WIDGET_SIZE			20			/* Default size of window widgets in pixels (for drawn widgets)*/
+#define MAX_PID				500			/* Max number of client process'*/
+#define SHOW_LOGO_AT_STARTUP	1		/* Run the XaAES logo program at startup*/
+#define AES_PRIORITY		-20			/* The process priority for the XaAES server (-20 is high priority)*/
 
-#define DU_RSX_CONV 		8			// Resource char to pixel coord conversion constants.
-#define DU_RSY_CONV 		16			// If you are designing your resources in ST-Low res, 
-										//  change DU_RSY_CONV to 8
-#define STANDARD_FONT_POINT	10			// Size of the 'standard' AES font (for window titles, etc)
-#define SMALL_FONT_POINT	8			// Size of the 'small' AES font.
-#define STANDARD_AES_FONTID	1			// Standard GDOS fontid for windows & stuff (set to 1 for no GDOS)
+#define DU_RSX_CONV 		8			/* Resource char to pixel coord conversion constants.*/
+#define DU_RSY_CONV 		16			/* If you are designing your resources in ST-Low res, */
+										/*  change DU_RSY_CONV to 8*/
+#define STANDARD_FONT_POINT	10			/* Size of the 'standard' AES font (for window titles, etc)*/
+#define SMALL_FONT_POINT	8			/* Size of the 'small' AES font.*/
+#define STANDARD_AES_FONTID	1			/* Standard GDOS fontid for windows & stuff (set to 1 for no GDOS)*/
 
-#define GRAF_STEPS			10			// Number of intermediate steps in a graf_growbox(), etc
+#define GRAF_STEPS			10			/* Number of intermediate steps in a graf_growbox(), etc*/
 
-#define PUSH3D_DISTANCE		1			// Distance text on selected (pushed in) 3D objects will move
-#define SHADOW_OFFSET		3			// Offset used for shadowing objects
+#define PUSH3D_DISTANCE		1			/* Distance text on selected (pushed in) 3D objects will move*/
+#define SHADOW_OFFSET		3			/* Offset used for shadowing objects*/
 
-#define PRIVATE_STACK_SIZE	1024		// Size of the private stack allocated for each client
+#define PRIVATE_STACK_SIZE	1024		/* Size of the private stack allocated for each client*/
 
-//-----------------------------------------------------------------
-// VERSION NUMBER
-#define XA_VERSION	"v0.1"				// Version number
-#define XA_AES_VERSION	0x0500			// AES version number we are going to use
+/*-----------------------------------------------------------------*/
+/* VERSION NUMBER*/
+#define XA_VERSION	"v0.1"				/* Version number*/
+#define XA_AES_VERSION	0x0500			/* AES version number we are going to use*/
 
-//-----------------------------------------------------------------
-// General Definitions 
+/*-----------------------------------------------------------------*/
+/* General Definitions */
 #define TRUE	1
 #define FALSE	0
 
@@ -72,8 +74,8 @@
 #define NULL	((void *)0)
 #endif
 
-//-----------------------------------------------------------------
-// Return codes in the clients reply pipe
+/*-----------------------------------------------------------------*/
+/* Return codes in the clients reply pipe*/
 #define XA_OK				0	/* Ok, op-code done */
 #define XA_UNIMPLEMENTED	1	/* Unimpemented but valid op-code */
 #define XA_ILLEGAL			2	/* Illegal op-code */
@@ -81,17 +83,18 @@
 #define XA_M_WAIT			4	/* Re-select for a evnt_multi format timeout */
 #define XA_TVAL			0xfff0	/* Mask to get the timeout value */
 
-//-----------------------------------------------------------------
-// Return codes from op-code service functions
+/*-----------------------------------------------------------------*/
+/* Return codes from op-code service functions*/
 #define XAC_BLOCK			0	/* Block the client indefinitely */
 #define XAC_DONE			1	/* Function completed - release client immediately */
 #define XAC_T_TIMEOUT		2	/* Block client, but timeout (evnt_timer format) */
 #define XAC_M_TIMEOUT		3	/* Block client, but timeout (evnt_multi format) */
 #define XAC_TVAL		0xfff0	/* Mask to get the timeout value */
 
+#ifdef LATTICE
 #if 1
-//-----------------------------------------------------------------
-// Inline functions to store / set Lattice C data pointers
+/*-----------------------------------------------------------------*/
+/* Inline functions to store / set Lattice C data pointers*/
 unsigned long get_a4(void);
 unsigned long get_a6(void);
 unsigned long get_a7(void);
@@ -116,37 +119,39 @@
 #define set_a7(x)
 
 #endif
+#endif /* LATTICE */
 
-//-----------------------------------------------------------------
-// Define the semaphores used in various places....
+/*-----------------------------------------------------------------*/
+/* Define the semaphores used in various places....*/
 
-#define APPL_INIT_SEMAPHORE	'XA:I'		// Semaphore id for appl_init() routine access
-#define TRAP_HANDLER_SEMAPHORE	'XA:H'	// Semaphore for access to part of the trap handler routine
-#define WIN_LIST_SEMAPHORE	'XA:W'		// Semaphore for order modify / entry delete access to the window list
-#define ROOT_SEMAPHORE		'XA:R'		// Semaphore for access to the root window
-#define CLIENTS_SEMAPHORE	'XA:C'		// Semaphore for access to the clients structure
+#define APPL_INIT_SEMAPHORE	'XA:I'		/* Semaphore id for appl_init() routine access*/
+#define TRAP_HANDLER_SEMAPHORE	'XA:H'	/* Semaphore for access to part of the trap handler routine*/
+#define WIN_LIST_SEMAPHORE	'XA:W'		/* Semaphore for order modify / entry delete access to the window list*/
+#define ROOT_SEMAPHORE		'XA:R'		/* Semaphore for access to the root window*/
+#define CLIENTS_SEMAPHORE	'XA:C'		/* Semaphore for access to the clients structure*/
 
-#define UPDATE_LOCK			'XA:U'		// Semaphore id for BEG_UPDATE
-#define MOUSE_LOCK			'XA:M'		// Semaphore id for BEG_MCTRL
+#define UPDATE_LOCK			'XA:U'		/* Semaphore id for BEG_UPDATE*/
+#define MOUSE_LOCK			'XA:M'		/* Semaphore id for BEG_MCTRL*/
 
-//-----------------------------------------------------------------
-// Diagnostics
+/*-----------------------------------------------------------------*/
+/* Diagnostics*/
 #if GENERATE_DIAGS
+#include <stdio.h>
 #define DIAGS(x) printf x
 #else
 #define DIAGS(x)
 #endif
 
-//-----------------------------------------------------------------
-// For debugging, I use trap 3 for XaAES so I can run it in tandem with multiTOS.
+/*-----------------------------------------------------------------*/
+/* For debugging, I use trap 3 for XaAES so I can run it in tandem with multiTOS.*/
 #if USE_DEBUG_VECTOR
 #define AES_TRAP		3
 #else
 #define AES_TRAP		2
 #endif
 
-//-----------------------------------------------------------------
-// Direct call interface enable
+/*-----------------------------------------------------------------*/
+/* Direct call interface enable*/
 #if USE_CALL_DIRECT
 #define CALL_DIRECT(x) Kcall_direct[(x)]=TRUE
 #else
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_globl.h /h/xaaes/xa_globl.h
--- /i/newitems/XaAES.beta2/src/xa_globl.h	Mon Feb 19 13:47:56 1996
+++ /h/xaaes/xa_globl.h	Thu Feb 22 14:41:00 1996
@@ -18,49 +18,51 @@
 	GLOBAL VARIABLES AND DATA STRUCTURES
 */
 
-#define MAX_PID 500						// maximum number of processes we can handle
+#define MAX_PID 500						/* maximum number of processes we can handle*/
 
-extern short AESpid;					// XaAES's MiNT process id.
+extern short AESpid;					/* XaAES's MiNT process id.*/
 
-extern short P_handle,V_handle;			// Workstation handles used by the AES
-extern XA_SCREEN display;			// The display descriptor
+extern short P_handle,V_handle;			/* Workstation handles used by the AES*/
+extern XA_SCREEN display;			/* The display descriptor*/
 
-extern void *super_stack;				// Supervisor mode stack
+extern void *super_stack;				/* Supervisor mode stack*/
 
-extern int AES_in_pipe;				// The AES instruction pipe handle
-extern int AES_in_pipe_clnt;		// The AES instruction pipe handle (client end)
+extern int AES_in_pipe;				/* The AES instruction pipe handle*/
+extern int AES_in_pipe_clnt;		/* The AES instruction pipe handle (client end)*/
 
-extern int MOUSE_in_pipe;			// The MOUSE pipe handle
+extern int MOUSE_in_pipe;			/* The MOUSE pipe handle*/
 
-extern long KBD_device;					// The MiNT keyboard device's file handle
+extern long KBD_device;					/* The MiNT keyboard device's file handle*/
 
-extern short debug_file;				// File handle to dump debug stuff to
+extern short debug_file;				/* File handle to dump debug stuff to*/
 
 extern unsigned long kernal_a4;
 extern unsigned long kernal_a6;
 
-extern XA_WINDOW *window_list;			// The global windows list
-extern XA_WINDOW *root_window;			// The desktop window
+extern XA_WINDOW *window_list;			/* The global windows list*/
+extern XA_WINDOW *root_window;			/* The desktop window*/
 
-extern EVNT_Q *button_event_q;			// Queue of clients waiting on a button event (not used any more)
+extern EVNT_Q *button_event_q;			/* Queue of clients waiting on a button event (not used any more)*/
 
-extern short update_lock;				// wind_update() locks
+extern short update_lock;				/* wind_update() locks...*/
 extern short mouse_lock;
+extern short update_cnt;				/* ...and counters*/
+extern short mouse_cnt;
 
 extern AESPB new_client_pb;
 extern K_CMD_PACKET new_client_packet;
 extern short client_exit_contrl[];
 
-extern char XaAES_home[200];			// XaAES's home location
+extern char XaAES_home[200];			/* XaAES's home location*/
 extern short XaAES_home_drv;
 
-extern char scrap_path[128];			// Clipboard directory path
+extern char scrap_path[128];			/* Clipboard directory path*/
 
-extern void *system_resources;			// Pointer to the XaAES resources
+extern void *system_resources;			/* Pointer to the XaAES resources*/
 
-extern far AESroutine Ktable[300];		// The main AES kernal command jump table
-extern far short Kcall_direct[300];		// array of flags to indicate that routines should be direct called
-extern far XA_CLIENT clients[MAX_PID];	// The main data structure is the clients database
+extern far AESroutine Ktable[300];		/* The main AES kernal command jump table*/
+extern far short Kcall_direct[300];		/* array of flags to indicate that routines should be direct called*/
+extern far XA_CLIENT clients[MAX_PID];	/* The main data structure is the clients database*/
 
 
 #endif
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_types.h /h/xaaes/xa_types.h
--- /i/newitems/XaAES.beta2/src/xa_types.h	Thu Feb 15 00:27:38 1996
+++ /h/xaaes/xa_types.h	Wed Feb 21 14:19:28 1996
@@ -8,47 +8,59 @@
 #ifndef _XA_TYPES_H_
 #define _XA_TYPES_H_
 #include <VDI.H>
+#ifdef __PUREC__
+typedef struct mfstr
+{
+    int  mf_xhot;
+    int  mf_yhot;
+    int  mf_nplanes;
+    int  mf_fg;
+    int  mf_bg;
+    int  mf_mask[16];
+    int  mf_data[16];
+} MFORM;
+#endif
 #include "K_DEFS.H"
 
-//-----------------------------------------------------------------
-// Display descriptions
+/*-----------------------------------------------------------------*/
+/* Display descriptions*/
 
 typedef enum { D_LOCAL=0, D_TCP=1 } XA_DISPLAY;
 
 typedef struct {
-	short bg_col;			// Colour used for backgrounds
-	short fg_col;			// COlour used for foregrounds
-	short b_r_col;			// Colour used for bottom right 3d edge
-	short t_l_col;			// Colour used for top left 3d edge
-	short border_col;		// Colour used for edging
-	short highlight_col;	// Colour used for highlighting
+	short bg_col;			/* Colour used for backgrounds*/
+	short fg_col;			/* COlour used for foregrounds*/
+	short b_r_col;			/* Colour used for bottom right 3d edge*/
+	short t_l_col;			/* Colour used for top left 3d edge*/
+	short border_col;		/* Colour used for edging*/
+	short highlight_col;	/* Colour used for highlighting*/
 } XA_COLOUR_SCHEME;
 
 typedef struct {
-	short x,y,w,h;				// Screen dimensions
-	short colours;				// number of colours available
-	short planes;				// number of planes in screen
-	XA_DISPLAY display_type;	// The type of display we are using
-	short P_handle;				// VDI physical workstation handle (for D_LOCAL screens)
-	short V_handle;				// VDI virtual workstation handle (for all screens)
-	short c_max_w,c_max_h;		// Maximum character dimensions in pixels
-	short c_min_w,c_min_h;		// Minimum (small font) character dimensions in pixels
-	XA_COLOUR_SCHEME dial_colours;	// Colour scheme used for dialogs
+	short x,y,w,h;				/* Screen dimensions*/
+	short colours;				/* number of colours available*/
+	short planes;				/* number of planes in screen*/
+	XA_DISPLAY display_type;	/* The type of display we are using*/
+	short P_handle;				/* VDI physical workstation handle (for D_LOCAL screens)*/
+	short V_handle;				/* VDI virtual workstation handle (for all screens)*/
+	short c_max_w,c_max_h;		/* Maximum character dimensions in pixels*/
+	short c_min_w,c_min_h;		/* Minimum (small font) character dimensions in pixels*/
+	XA_COLOUR_SCHEME dial_colours;	/* Colour scheme used for dialogs*/
 } XA_SCREEN;
 
-//-----------------------------------------------------------------
-// Client application data structures
+/*-----------------------------------------------------------------*/
+/* Client application data structures*/
 
-// List of Pending AES messages
+/* List of Pending AES messages*/
 typedef struct xa_aesmsg_list {
 	struct xa_aesmsg_list *next;
 	short message[8];
 } XA_AESMSG_LIST;
 
-// Codes for what types of event an app is currently waiting for
-// - I've used the same bit allocation as evnt_multi() here, but there is
-//   the extra XAWAIT_MULTI bit to indicate we are waiting from evnt_multi()
-//   as opposed to one of the individual routines (as return values are different).
+/* Codes for what types of event an app is currently waiting for*/
+/* - I've used the same bit allocation as evnt_multi() here, but there is*/
+/*   the extra XAWAIT_MULTI bit to indicate we are waiting from evnt_multi()*/
+/*   as opposed to one of the individual routines (as return values are different).*/
 #define XAWAIT_KEY		0x01
 #define XAWAIT_BUTTON	0x02
 #define XAWAIT_MOUSE1	0x04
@@ -57,81 +69,81 @@
 #define XAWAIT_TIMER	0x20
 #define XAWAIT_MULTI	128
 
-// Main client application descriptor
+/* Main client application descriptor*/
 typedef struct {
-	int clnt_pipe_rd;		// File handle of the clients internal reply pipe (client end)
-	int clnt_pipe_wr;		// File handle of the clients internal reply pipe (server end)
-	int reply_pipe;			// File handle of the clients external reply pipe
-	XA_AESMSG_LIST *msg;	// Pending AES messages
-	struct xa_pending_widget *widget_active;	// Pending active widget (if any)
-	short waiting_for;		// What types of event(s) the client is waiting for
-	AESPB *waiting_pb;		// Parameter block for whatever the client is waiting for
-	short client_mouse;		// The cursor to use when this is top application
+	int clnt_pipe_rd;		/* File handle of the clients internal reply pipe (client end)*/
+	int clnt_pipe_wr;		/* File handle of the clients internal reply pipe (server end)*/
+	int reply_pipe;			/* File handle of the clients external reply pipe*/
+	XA_AESMSG_LIST *msg;	/* Pending AES messages*/
+	struct xa_pending_widget *widget_active;	/* Pending active widget (if any)*/
+	short waiting_for;		/* What types of event(s) the client is waiting for*/
+	AESPB *waiting_pb;		/* Parameter block for whatever the client is waiting for*/
+	short client_mouse;		/* The cursor to use when this is top application*/
 	MFORM *client_mouse_form;
-	short *globl_ptr;		// Pointer to the client's globl array (so we can fill in the resource
-							//  address field later).
-	void *std_resource;		// Pointer to the client's standard GEM-style single resource file
-	OBJECT *std_menu;		// Pointer to the client's standard GEM-style menu-bar
-	char home_path[150];	// The directory that the client was started in
-	char *cmd_tail;			// The command tail of the process (if launched by shell_write)
-	char *cmd_name;			// The full filename used when launching the process (if launched by shell_write)
-	char name[20];			// The clients 'pretty' name (possibly set by menu_register)
-	char proc_name[9];		// The clients 'official' (ie. used by appl_find) name.
-	short parent;			// Process id of the client's "parent" process (if launched with shell_write)
-	struct xa_window *zen;	// Pointer to a window that could be about to become a dialog
-	void *private_stack;	// Private stack used for call-direct operations
-	void *temp;				// temporary storage
+	short *globl_ptr;		/* Pointer to the client's globl array (so we can fill in the resource*/
+							/*  address field later).*/
+	void *std_resource;		/* Pointer to the client's standard GEM-style single resource file*/
+	OBJECT *std_menu;		/* Pointer to the client's standard GEM-style menu-bar*/
+	char home_path[150];	/* The directory that the client was started in*/
+	char *cmd_tail;			/* The command tail of the process (if launched by shell_write)*/
+	char *cmd_name;			/* The full filename used when launching the process (if launched by shell_write)*/
+	char name[20];			/* The clients 'pretty' name (possibly set by menu_register)*/
+	char proc_name[9];		/* The clients 'official' (ie. used by appl_find) name.*/
+	short parent;			/* Process id of the client's "parent" process (if launched with shell_write)*/
+	struct xa_window *zen;	/* Pointer to a window that could be about to become a dialog*/
+	void *private_stack;	/* Private stack used for call-direct operations*/
+	void *temp;				/* temporary storage*/
 } XA_CLIENT;
 
-//-----------------------------------------------------------------
-// Windows & Widgets
+/*-----------------------------------------------------------------*/
+/* Windows & Widgets*/
 
-// A pointer to a function of the type used for widget behaviours is a 
-//  'WidgetCallback'.
-typedef short (*WidgetCallback)(struct window *wind, struct xa_widget *widg);
-
-// Relative coordinate types
-typedef enum {	RT=0,	// Top right
-				RB=1,	// Bottom right
-				LT=2,	// Top left
-				LB=3,	// Bottom left
-				CT=4,	// Top centred
-				CB=5	// Bottom centred
+/* A pointer to a function of the type used for widget behaviours is a */
+/*  'WidgetCallback'.*/
+typedef short (*WidgetCallback)(struct xa_window *wind, struct xa_widget *widg);
+
+/* Relative coordinate types*/
+typedef enum {	RT=0,	/* Top right*/
+				RB=1,	/* Bottom right*/
+				LT=2,	/* Top left*/
+				LB=3,	/* Bottom left*/
+				CT=4,	/* Top centred*/
+				CB=5	/* Bottom centred*/
 			} XA_RELATIVE;
 
-// Widget positions are defined as relative locations
+/* Widget positions are defined as relative locations*/
 typedef struct {
-	XA_RELATIVE relative_type;	// Where is the position relative to?
-	short x,y;					// position
+	XA_RELATIVE relative_type;	/* Where is the position relative to?*/
+	short x,y;					/* position*/
 } XA_WIDGET_LOCATION;
 
-// Object Tree based widget descriptor
+/* Object Tree based widget descriptor*/
 typedef struct {
-	OBJECT *tree;				// The object tree
-	short is_menu;				// TRUE if this widget is a menu
-	short owner;				// The tree widget would be owned by a different app to
-								// the actual window (like the menu bar on the root window)
+	OBJECT *tree;				/* The object tree*/
+	short is_menu;				/* TRUE if this widget is a menu*/
+	short owner;				/* The tree widget would be owned by a different app to*/
+								/* the actual window (like the menu bar on the root window)*/
 } XA_WIDGET_TREE;
 
-// Widget Callback/Behaviour Identifiers
+/* Widget Callback/Behaviour Identifiers*/
 #define COUNT_XACB		4
 #define XACB_DISPLAY	0
 #define XACB_CLICK		1
 #define XACB_DCLICK		2
 #define XACB_DRAG		3
 
-// Widget Status
+/* Widget Status*/
 typedef enum { XAW_PLAIN=0, XAW_SELECTED=1, XAW_MENUSTATE=2, XAW_TOOLBARSTATE=3 } XA_WIDGET_STATUS;
 
-// Window Widget
+/* Window Widget*/
 typedef struct xa_widget {
-	XA_WIDGET_LOCATION loc;		// Location of widget relative to window extents
-	WidgetCallback behaviour[COUNT_XACB];	// Callback function pointers to the behaviours of the widget
-	XA_WIDGET_STATUS stat;		// Current status (selected, etc)
-	short w,h;					// dimensions
-	short click_x,click_y;		// If we are displaying because we've been clicked on, this is the location 
-								// of the click (this is only used by the slider widget really)
-	void *stuff;				// Pointer to widget dependant context data, if any
+	XA_WIDGET_LOCATION loc;		/* Location of widget relative to window extents*/
+	WidgetCallback behaviour[COUNT_XACB];	/* Callback function pointers to the behaviours of the widget*/
+	XA_WIDGET_STATUS stat;		/* Current status (selected, etc)*/
+	short w,h;					/* dimensions*/
+	short click_x,click_y;		/* If we are displaying because we've been clicked on, this is the location */
+								/* of the click (this is only used by the slider widget really)*/
+	void *stuff;				/* Pointer to widget dependant context data, if any*/
 } XA_WIDGET;
 
 typedef struct xa_widget_list {
@@ -139,17 +151,17 @@
 	struct xa_widget_list *next;
 } XA_WIDGET_LIST;
 
-// Pending action from a widget
+/* Pending action from a widget*/
 typedef struct xa_pending_widget {
 	XA_WIDGET *widg;
 	struct xa_window *wind;
 	WidgetCallback action;
 } XA_PENDING_WIDGET;
 
-// Extra details for a slider widget
+/* Extra details for a slider widget*/
 typedef struct {
-	short position;		// Actual position of the slider (0-1000)
-	short length;		// Length (0-1000)
+	short position;		/* Actual position of the slider (0-1000)*/
+	short length;		/* Length (0-1000)*/
 } XA_SLIDER_WIDGET;
 
 #define ZT_A	1
@@ -157,20 +169,20 @@
 #define ZT_C	3
 #define ZT_D	4
 
-// Rectangle List entry
+/* Rectangle List entry*/
 typedef struct xa_rect_list {
 	struct xa_rect_list *next;
-	short x,y,w,h;			// dimensions of segment
+	short x,y,w,h;			/* dimensions of segment*/
 } XA_RECT_LIST;
 
-// Number of available XA_WIDGET slots in a the window for default/standard widgets
+/* Number of available XA_WIDGET slots in a the window for default/standard widgets*/
 #define XA_MAX_WIDGETS	15
 
-// Widget Index's
+/* Widget Index's*/
 #define XAW_TITLE		0
 #define XAW_CLOSE		1
 #define XAW_FULL		2
-#define XAW_MOVER		3		// Not actually used like the others
+#define XAW_MOVER		3		/* Not actually used like the others*/
 #define XAW_INFO		4
 #define XAW_RESIZE		5
 #define XAW_UP			6
@@ -180,31 +192,31 @@
 #define XAW_RIGHT		10
 #define XAW_HSLIDE		11
 #define XAW_ICONIFY		12
-#define XAW_MENU		13		// Extended XaAES widget
-#define XAW_TOOLBAR		14		// Extended XaAES widget
+#define XAW_MENU		13		/* Extended XaAES widget*/
+#define XAW_TOOLBAR		14		/* Extended XaAES widget*/
 
-// Window Descriptor
+/* Window Descriptor*/
 typedef struct xa_window {
-	struct xa_window *next;	// Window list stuff	- next is the window below
-	struct xa_window *prev;	//						- prev is the window above (both NULL terminated)
-	long active_widgets;	// Summary of the current standard widgets for the window
-	XA_WIDGET widgets[XA_MAX_WIDGETS];	// The windows standard widget set (array for speed)
-	XA_WIDGET_LIST *user_widgets;		// Pointer to a list of user added widgets
-	short x,y,w,h;			// current dimensions
-	short handle;			// Window handle
-	short owner;			// client pid of the window's owner
-	short is_open;			// flag - is the window actually open?
-	short widgets_on_top;	// Number of widgets on the top bar, not including the title
-	XA_RECT_LIST *rect_list;	// The rectangle list for redraws in this window
-	short wx,wy,ww,wh;		// current user work area dimensions
-	short prev_x,prev_y,prev_w,prev_h;	// Previous window coords
-	void *background;		// pointer to a buffer containing the saved background
-	short bgx,bgy;			// location the saved background came from
-	short created_by_FMD_START;	// flag - 1=this window was created by form_dial,
-								// so don't destroy it until the form_dial(FMD_FINISH)
+	struct xa_window *next;	/* Window list stuff	- next is the window below*/
+	struct xa_window *prev;	/*						- prev is the window above (both NULL terminated)*/
+	long active_widgets;	/* Summary of the current standard widgets for the window*/
+	XA_WIDGET widgets[XA_MAX_WIDGETS];	/* The windows standard widget set (array for speed)*/
+	XA_WIDGET_LIST *user_widgets;		/* Pointer to a list of user added widgets*/
+	short x,y,w,h;			/* current dimensions*/
+	short handle;			/* Window handle*/
+	short owner;			/* client pid of the window's owner*/
+	short is_open;			/* flag - is the window actually open?*/
+	short widgets_on_top;	/* Number of widgets on the top bar, not including the title*/
+	XA_RECT_LIST *rect_list;	/* The rectangle list for redraws in this window*/
+	short wx,wy,ww,wh;		/* current user work area dimensions*/
+	short prev_x,prev_y,prev_w,prev_h;	/* Previous window coords*/
+	void *background;		/* pointer to a buffer containing the saved background*/
+	short bgx,bgy;			/* location the saved background came from*/
+	short created_by_FMD_START;	/* flag - 1=this window was created by form_dial,*/
+								/* so don't destroy it until the form_dial(FMD_FINISH)*/
 } XA_WINDOW;
 
-//------------------------------------------------------------------
+/*------------------------------------------------------------------*/
 
 #define TRUE	1
 #define FALSE	0
