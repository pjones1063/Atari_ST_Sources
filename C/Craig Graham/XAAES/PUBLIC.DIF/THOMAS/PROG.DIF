diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/scrlwidg.c /h/xaaes/scrlwidg.c
--- /i/newitems/XaAES.beta2/src/scrlwidg.c	Wed Dec 13 02:20:04 1995
+++ /h/xaaes/scrlwidg.c	Thu Feb 22 19:03:36 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <OSBIND.H>
 #include <VDI.H>
 #include "XA_TYPES.H"
@@ -13,7 +14,6 @@
 #include "KERNAL.H"
 #include "K_DEFS.H"
 #include "BOX3D.H"
-#include "KERNAL.H"
 #include "DRAG_BOX.H"
 #include "GRAF_MOU.H"
 #include "MESSAGES.H"
@@ -33,7 +33,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_left);
@@ -50,10 +50,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_LFLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_lscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_lscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -66,7 +66,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_right);
@@ -83,10 +83,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_RTLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_rscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_rscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -99,7 +99,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_up);
@@ -116,10 +116,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_UPLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_uscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_uscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -132,7 +132,7 @@
 {
 	short x,y;
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 	if (widg->stat==XAW_PLAIN)
 		display_widget_bitmap(x, y, widget_bitmap_down);
@@ -149,10 +149,10 @@
 	send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_DNLINE, 0, 0, 0);
 	vq_mouse(V_handle, &mb, &mx, &my);
 
-	if (mb)	// If the button has been held down, set a pending/active widget for the client
+	if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 	{
-		set_widget_active(wind, widg, &click_dscroll);
-		return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+		set_widget_active(wind, widg, click_dscroll);
+		return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 	}
 	cancel_widget_active(wind);
 	return TRUE;
@@ -169,10 +169,10 @@
 	short x,y,pnt[4],offs,len,wcy;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
-	len=(widg->h*sl->length)/1000;
-	offs=((widg->h - len)*sl->position)/1000;
+	len=(short)(((long)widg->h * (long)sl->length)/1000);
+	offs=(short)(((long)(widg->h - len) * (long)sl->position)/1000);
 	wcy=widg->click_y-offs;
 
 	if (len>=ICON_H*3)
@@ -231,34 +231,34 @@
 	XA_RECT_LIST *drl;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 
-	len=(widg->h*sl->length)/1000;
+	len=(short)(((long)widg->h * (long)sl->length)/1000);
 	orig_offs=offs=sl->position;
-	wcy=widg->click_y-((widg->h - len)*sl->position)/1000;
+	wcy=widg->click_y - (short)(((long)(widg->h - len) * (long)sl->position)/1000);
 
 	vq_mouse(V_handle, &mb, &imx, &imy);
 	pmx=imx; pmy=imy;
 
-	if ((len<ICON_H*3)||((wcy>ICON_H)&&(wcy<len-ICON_H)))	// Drag slider
+	if ((len<ICON_H*3)||((wcy>ICON_H)&&(wcy<len-ICON_H)))	/* Drag slider*/
 	{
 		do {
 			vq_mouse(V_handle, &mb, &mx, &my);
-			if (my!=pmy)			// Has mouse moved?
+			if (my!=pmy)			/* Has mouse moved?*/
 			{
-				dy=(1000*(my-pmy))/(widg->h-len);
+				dy=(short)((1000L * (long)(my-pmy))/(widg->h-len));
 				noffs=offs+dy;
 				if (noffs<0) noffs=0;
 				if (noffs>1000) noffs=1000;
 
-				if (noffs!=offs)	// Has the slider moved?
+				if (noffs!=offs)	/* Has the slider moved?*/
 				{
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -267,7 +267,7 @@
 					}
 					offs=noffs;
 					sl->position=offs;
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -284,18 +284,22 @@
 		send_app_message(wind->owner, WM_VSLID, 0, wind->handle, offs, 0, 0, 0);
 	}else{
 		vsf_color(V_handle,display.dial_colours.highlight_col);
-		if (wcy<ICON_H)			// Page left
+		if (wcy<ICON_H)			/* Page left*/
 		{
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_UPPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y;
-			pnt[2]=x+widg->w; pnt[3]=y+(widg->h - len)*sl->position/1000;
-		}else{					// Page right
+			pnt[0]=x;
+			pnt[1]=y;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+(short)((long)(widg->h - len) * (long)sl->position / 1000);
+		}else{					/* Page right*/
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_DNPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y+(widg->h - len)*sl->position/1000+len;
-			pnt[2]=x+widg->w; pnt[3]=y+widg->h;
+			pnt[0]=x;
+			pnt[1]=y+(short)((long)(widg->h - len) * (long)sl->position / 1000) + len;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+widg->h;
 		}
 		v_hide_c(V_handle);
-		for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+		for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 		{
 			clip[0]=drl->x; clip[1]=drl->y;
 			clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -305,16 +309,16 @@
 		}
 		v_show_c(V_handle, 1);
 		vsf_color(V_handle,display.dial_colours.bg_col);
-		if (mb)	// If the button has been held down, set a pending/active widget for the client
+		if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 		{
-			set_widget_active(wind, widg, &drag_vslide);
-			return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+			set_widget_active(wind, widg, drag_vslide);
+			return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 		}
 		cancel_widget_active(wind);
 	}
 	
 	v_hide_c(V_handle);
-	while(rl)		// Dispose of the rectangle list & erase the dragged slider
+	while(rl)		/* Dispose of the rectangle list & erase the dragged slider*/
 	{
 		drl=rl;
 		clip[0]=drl->x; clip[1]=drl->y;
@@ -323,8 +327,8 @@
 		v_bar(V_handle,pnt);
 		rl=rl->next;
 		free(drl);
-	}				// We don't need to re-draw the slider as it get's redrawn by the 
-					// standard widget handler anyway.
+	}				/* We don't need to re-draw the slider as it get's redrawn by the */
+					/* standard widget handler anyway.*/
 	v_show_c(V_handle, 1);
 
 	return TRUE;
@@ -342,10 +346,10 @@
 	short x,y,pnt[4],offs,len,wcx;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
-	len=(widg->w*sl->length)/1000;
-	offs=((widg->w - len)*sl->position)/1000;
+	len=(short)(((long)widg->w * (long)sl->length)/1000);
+	offs=(short)(((long)(widg->w - len) * (long)sl->position)/1000);
 
 	wcx=widg->click_x-offs;
 
@@ -405,34 +409,34 @@
 	XA_RECT_LIST *drl;
 	XA_SLIDER_WIDGET *sl=(XA_SLIDER_WIDGET*)(widg->stuff);
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 
-	len=(widg->w*sl->length)/1000;
+	len=(short)(((long)widg->w * (long)sl->length)/1000);
 	orig_offs=offs=sl->position;
-	wcx=widg->click_x-((widg->w - len)*sl->position)/1000;
+	wcx=widg->click_x-(short)(((long)(widg->w - len) * (long)sl->position)/1000);
 
 	vq_mouse(V_handle, &mb, &imx, &imy);
 	pmx=imx; pmy=imy;
 
-	if ((len<ICON_W*3)||((wcx>ICON_W)&&(wcx<len-ICON_W)))	// Drag slider
+	if ((len<ICON_W*3)||((wcx>ICON_W)&&(wcx<len-ICON_W)))	/* Drag slider*/
 	{
 		do {
 			vq_mouse(V_handle, &mb, &mx, &my);
-			if (mx!=pmx)			// Has mouse moved?
+			if (mx!=pmx)			/* Has mouse moved?*/
 			{
-				dx=(1000*(mx-pmx))/(widg->w-len);
+				dx=(short)((1000L * (long)(mx-pmx))/(widg->w-len));
 				noffs=offs+dx;
 				if (noffs<0) noffs=0;
 				if (noffs>1000) noffs=1000;
 
-				if (noffs!=offs)	// Has the slider moved?
+				if (noffs!=offs)	/* Has the slider moved?*/
 				{
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -441,7 +445,7 @@
 					}
 					offs=noffs;
 					sl->position=offs;
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -458,18 +462,22 @@
 		send_app_message(wind->owner, WM_HSLID, 0, wind->handle, offs, 0, 0, 0);
 	}else{
 		vsf_color(V_handle,display.dial_colours.highlight_col);
-		if (wcx<ICON_W)			// Page left
+		if (wcx<ICON_W)			/* Page left*/
 		{
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_LFPAGE, 0, 0, 0);
-			pnt[0]=x; pnt[1]=y;
-			pnt[2]=x+(widg->w - len)*sl->position/1000; pnt[3]=y+widg->h;
-		}else{					// Page right
+			pnt[0]=x;
+			pnt[1]=y;
+			pnt[2]=x+(short)((long)(widg->w - len) * (long)sl->position / 1000);
+			pnt[3]=y+widg->h;
+		}else{					/* Page right*/
 			send_app_message(wind->owner, WM_ARROWED, 0, wind->handle, WA_RTPAGE, 0, 0, 0);
-			pnt[0]=x+(widg->w - len)*sl->position/1000+len; pnt[1]=y;
-			pnt[2]=x+widg->w; pnt[3]=y+widg->h;
+			pnt[0]=x+(short)((long)(widg->w - len) * (long)sl->position / 1000) + len;
+			pnt[1]=y;
+			pnt[2]=x+widg->w;
+			pnt[3]=y+widg->h;
 		}
 		v_hide_c(V_handle);
-		for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+		for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 		{
 			clip[0]=drl->x; clip[1]=drl->y;
 			clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -479,16 +487,16 @@
 		}
 		v_show_c(V_handle, 1);
 		vsf_color(V_handle,display.dial_colours.bg_col);
-		if (mb)	// If the button has been held down, set a pending/active widget for the client
+		if (mb)	/* If the button has been held down, set a pending/active widget for the client*/
 		{
-			set_widget_active(wind, widg, &drag_hslide);
-			return FALSE;	// We return false here so the widget display status stays selected whilst it repeats
+			set_widget_active(wind, widg, drag_hslide);
+			return FALSE;	/* We return false here so the widget display status stays selected whilst it repeats*/
 		}
 		cancel_widget_active(wind);
 	}
 	
 	v_hide_c(V_handle);
-	while(rl)		// Dispose of the rectangle list & erase the dragged slider
+	while(rl)		/* Dispose of the rectangle list & erase the dragged slider*/
 	{
 		drl=rl;
 		clip[0]=drl->x; clip[1]=drl->y;
@@ -497,8 +505,8 @@
 		v_bar(V_handle,pnt);
 		rl=rl->next;
 		free(drl);
-	}				// We don't need to re-draw the slider as it get's redrawn by the 
-					// standard widget handler anyway.
+	}				/* We don't need to re-draw the slider as it get's redrawn by the */
+					/* standard widget handler anyway.*/
 	v_show_c(V_handle, 1);
 
 	return TRUE;
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/shell.c /h/xaaes/shell.c
--- /i/newitems/XaAES.beta2/src/shell.c	Sun Feb 18 23:01:58 1996
+++ /h/xaaes/shell.c	Wed Feb 21 23:30:54 1996
@@ -6,7 +6,9 @@
  */
 
 #include <OSBIND.H>
+#include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include "k_defs.h"
 #include "xa_globl.h"
 #include "shellwrt.h"
@@ -56,7 +58,7 @@
 	handle=Fopen(path,0);
 	if (handle>0)
 	{
-		Fclose(handle);
+		Fclose((short)handle);
 		sprintf(fn,"%s",path);
 		pb->intout[0]=1;
 		
@@ -66,7 +68,7 @@
 	}
 	
 /* check our PATH enviroment variable */
-	l=strlen(cwd);
+	l=(short)strlen(cwd);
 	sprintf(cwd,"%s",kp);
 	
 	while(f<l)
@@ -80,7 +82,7 @@
 		handle=Fopen(path,0);
 		if (handle>0)
 		{
-			Fclose(handle);
+			Fclose((short)handle);
 			sprintf(fn,"%s",path);
 			pb->intout[0]=1;
 
@@ -95,7 +97,7 @@
 	handle=Fopen(fn,0);
 	if (handle>0)
 	{
-		Fclose(handle);
+		Fclose((short)handle);
 		pb->intout[0]=1;
 		
 		DIAGS(("found as file spec on it's own\n"));
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/signals.c /h/xaaes/signals.c
--- /i/newitems/XaAES.beta2/src/signals.c	Mon Feb 19 13:46:24 1996
+++ /h/xaaes/signals.c	Wed Feb 21 23:55:24 1996
@@ -14,6 +14,7 @@
 #include "xa_globl.h"
 #include "xa_defs.h"
 #include "xa_codes.h"
+#include "new_clnt.h"
 
 /*
 	SIGNAL HANDLERS
@@ -42,16 +43,17 @@
 		if (r==mouse_lock)
 			mouse_lock=0;
 
-		dead_client_pb.contrl=dead_exit_contrl;	// If client is dead, send ourselves a message to clean up....
-		dead_client_packet.pid=r;				// client pid
-		dead_client_packet.cmd=AESCMD_NOREPLY;	// no reply
-		dead_client_packet.pb=&dead_client_pb;	// pointer to AES parameter block
-
-		XA_client_exit(r,&dead_client_pb);		// Run the application exit cleanup
-
-		clients[r].clnt_pipe_rd=0;				// This is normally done by appl_exit(),
-												// but beings as the client is dead, the pipe will be
-												// closed already
+		dead_client_pb.contrl=dead_exit_contrl;	/* If client is dead, send ourselves a message to clean up....*/
+		dead_client_packet.pid=(short)r;		/* client pid*/
+		dead_client_packet.cmd=AESCMD_NOREPLY;	/* no reply*/
+		dead_client_packet.pb=&dead_client_pb;	/* pointer to AES parameter block*/
+
+		XA_client_exit((short)r,&dead_client_pb);
+												/* Run the application exit cleanup*/
+
+		clients[r].clnt_pipe_rd=0;				/* This is normally done by appl_exit(),*/
+												/* but beings as the client is dead, the pipe will be*/
+												/* closed already*/
 		r=Pwait3(1,NULL);
 	}
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/std_widg.c /h/xaaes/std_widg.c
--- /i/newitems/XaAES.beta2/src/std_widg.c	Sun Feb 18 14:42:36 1996
+++ /h/xaaes/std_widg.c	Thu Feb 22 15:39:50 1996
@@ -13,7 +13,6 @@
 #include "XA_GLOBL.H"
 #include "KERNAL.H"
 #include "K_DEFS.H"
-#include "KERNAL.H"
 #include "GRAF_MOU.H"
 #include "C_WINDOW.H"
 #include "RECTLIST.H"
@@ -34,10 +33,10 @@
 
 MFDB widget_bm;
 
-// Convert widget bitmaps (16*16*4bit device independant format) to device specific format
-// for the current screen device.
-// Asides from looking pretty, this should make the default widget set work with any
-// colour screen mode and any graphics card (right up to 24 bits/pixel).
+/* Convert widget bitmaps (16*16*4bit device independant format) to device specific format*/
+/* for the current screen device.*/
+/* Asides from looking pretty, this should make the default widget set work with any*/
+/* colour screen mode and any graphics card (right up to 24 bits/pixel).*/
 void fix_bitmaps(void)
 {
 	MFDB dest;
@@ -54,7 +53,7 @@
 	dest=widget_bm;
 	dest.fd_stand=0;
 
-// Transform the XaAES logo
+/* Transform the XaAES logo*/
 	widget_bm.fd_addr=(void*)bitmap_xaaes16_s;
 	dest.fd_addr=(void*)bitmap_xaaes16_s;
 	vr_trnfm(V_handle,&widget_bm,&dest);
@@ -62,7 +61,7 @@
 	dest.fd_addr=(void*)bitmap_xaaes16;
 	vr_trnfm(V_handle,&widget_bm,&dest);
 	
-// Transform the actual window widgets
+/* Transform the actual window widgets*/
 	widget_bm.fd_addr=(void*)widget_bitmap_close;
 	dest.fd_addr=(void*)widget_bitmap_close;
 	vr_trnfm(V_handle,&widget_bm,&dest);
@@ -155,7 +154,7 @@
 	widget_bm=dest;
 }
 
-// Set the active/pending widget behaviour for a client
+/* Set the active/pending widget behaviour for a client*/
 void set_widget_active(XA_WINDOW *wind, XA_WIDGET *widg, WidgetCallback wc)
 {
 	XA_PENDING_WIDGET *pw;
@@ -171,7 +170,7 @@
 	clients[clnt_pid].widget_active=pw;
 }
 
-// Cancel the active/pending widget for a client
+/* Cancel the active/pending widget for a client*/
 void cancel_widget_active(XA_WINDOW *wind)
 {
 	XA_PENDING_WIDGET *pw;
@@ -182,7 +181,7 @@
 	if (pw) free(pw);
 }
 
-// Convert window relative widget coords to absolute screen coords
+/* Convert window relative widget coords to absolute screen coords*/
 void rp_2_ap(XA_WINDOW *wind, XA_WIDGET *widg, short *x, short *y)
 {
 	XA_WIDGET_LOCATION rp=widg->loc;
@@ -250,11 +249,11 @@
 #endif
 }
 
-// Calculate the size of the work area for a window and store it
-// - this is needed because the locations of widgets are relative and
-//   can be modified.
-// Actually, this updates all the dynamic sized elements from the standard widget set...
-// (namely: work area, sliders and title bar)
+/* Calculate the size of the work area for a window and store it*/
+/* - this is needed because the locations of widgets are relative and*/
+/*   can be modified.*/
+/* Actually, this updates all the dynamic sized elements from the standard widget set...*/
+/* (namely: work area, sliders and title bar)*/
 void calc_work_area(XA_WINDOW *wind)
 {
 	XA_WIDGET *widg;
@@ -277,8 +276,8 @@
 	for (f=0; f<XA_MAX_WIDGETS; f++)
 	{
 		widg=wind->widgets+f;
-		disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
-		if (disp)	// If the widget is displayed, include it in the calculation
+		disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
+		if (disp)	/* If the widget is displayed, include it in the calculation*/
 		{
 			rp_2_ap(wind, widg, &wx, &wy);
 			rt=widg->loc.relative_type;
@@ -332,23 +331,23 @@
 			}
 		}
 	}
-	wind->wx=x0;							// Update work area
+	wind->wx=x0;							/* Update work area*/
 	wind->wy=y0;
 	wind->ww=x1-x0;
 	wind->wh=y1-y0;
-	wind->widgets[XAW_TITLE].w=tx1-tx0;		// Update title bar length
+	wind->widgets[XAW_TITLE].w=tx1-tx0;		/* Update title bar length*/
 	wind->widgets[XAW_TITLE].loc.x=tx0-wind->x;
-	if (wind->active_widgets&HSLIDE)		// Update horizontal slider
+	if (wind->active_widgets&HSLIDE)		/* Update horizontal slider*/
 	{
 		wind->widgets[XAW_HSLIDE].w=slx1-slx0;
 	}
-	if (wind->active_widgets&VSLIDE)		// Update vertical slider
+	if (wind->active_widgets&VSLIDE)		/* Update vertical slider*/
 	{
 		wind->widgets[XAW_VSLIDE].h=sly1-sly0;
 	}
 }
 
-// Define the widget locations using window relative coordinates.
+/* Define the widget locations using window relative coordinates.*/
 const XA_WIDGET_LOCATION stdl_close={LT,1,1};
 const XA_WIDGET_LOCATION stdl_full={RT,1,1};
 const XA_WIDGET_LOCATION stdl_title={LT,23,3};
@@ -362,18 +361,18 @@
 const XA_WIDGET_LOCATION stdl_info={LT,1,1};
 const XA_WIDGET_LOCATION stdl_menu={LT,1,WIDGET_SIZE+5};
 
-// Setup the required 'standard' widgets for a window. These are the ordinary GEM
-// behaviours. These can be changed for any given window if you want special behaviours.
+/* Setup the required 'standard' widgets for a window. These are the ordinary GEM*/
+/* behaviours. These can be changed for any given window if you want special behaviours.*/
 void standard_widgets(XA_WINDOW *wind, long tp)
 {
 	short wd,bh,top_w=wind->w;
 	long bit_mask;
 	
-	wind->active_widgets=tp;				// Fill in the active widgets summary
+	wind->active_widgets=tp;				/* Fill in the active widgets summary*/
 	wind->widgets_on_top=0;
 	
-	for (wd=0; wd<XA_MAX_WIDGETS; wd++)		// Initially tag all behaviours as NULL so we can tell
-	{										// which ones we have actually attatched.
+	for (wd=0; wd<XA_MAX_WIDGETS; wd++)		/* Initially tag all behaviours as NULL so we can tell*/
+	{										/* which ones we have actually attatched.*/
 		for(bh=0; bh<COUNT_XACB; bh++)
 		{
 			wind->widgets[wd].behaviour[bh]=NULL;
@@ -383,8 +382,8 @@
 
 	if (tp&CLOSE)
 	{
-		wind->widgets[XAW_CLOSE].behaviour[XACB_DISPLAY]=&display_close_widget;
-		wind->widgets[XAW_CLOSE].behaviour[XACB_CLICK]=&click_close;
+		wind->widgets[XAW_CLOSE].behaviour[XACB_DISPLAY]=display_close_widget;
+		wind->widgets[XAW_CLOSE].behaviour[XACB_CLICK]=click_close;
 		wind->widgets[XAW_CLOSE].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_CLOSE].behaviour[XACB_DRAG]=NULL;
 		wind->widgets[XAW_CLOSE].loc=stdl_close;
@@ -397,8 +396,8 @@
 
 	if (tp&FULLER)
 	{
-		wind->widgets[XAW_FULL].behaviour[XACB_DISPLAY]=&display_full;
-		wind->widgets[XAW_FULL].behaviour[XACB_CLICK]=&click_full;
+		wind->widgets[XAW_FULL].behaviour[XACB_DISPLAY]=display_full;
+		wind->widgets[XAW_FULL].behaviour[XACB_CLICK]=click_full;
 		wind->widgets[XAW_FULL].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_FULL].behaviour[XACB_DRAG]=NULL;
 		wind->widgets[XAW_FULL].loc=stdl_full;
@@ -411,10 +410,10 @@
 
 	if (tp&SIZER)
 	{
-		wind->widgets[XAW_RESIZE].behaviour[XACB_DISPLAY]=&display_resize;
+		wind->widgets[XAW_RESIZE].behaviour[XACB_DISPLAY]=display_resize;
 		wind->widgets[XAW_RESIZE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_RESIZE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_RESIZE].behaviour[XACB_DRAG]=&drag_resize;
+		wind->widgets[XAW_RESIZE].behaviour[XACB_DRAG]=drag_resize;
 		wind->widgets[XAW_RESIZE].loc=stdl_resize;
 		wind->widgets[XAW_RESIZE].stat=XAW_PLAIN;
 		wind->widgets[XAW_RESIZE].w=ICON_W;
@@ -423,10 +422,10 @@
 	
 	if (tp&UPARROW)
 	{
-		wind->widgets[XAW_UP].behaviour[XACB_DISPLAY]=&display_uscroll;
-		wind->widgets[XAW_UP].behaviour[XACB_CLICK]=&click_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_DISPLAY]=display_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_CLICK]=click_uscroll;
 		wind->widgets[XAW_UP].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_UP].behaviour[XACB_DRAG]=&click_uscroll;
+		wind->widgets[XAW_UP].behaviour[XACB_DRAG]=click_uscroll;
 		wind->widgets[XAW_UP].loc=stdl_uscroll;
 		wind->widgets[XAW_UP].stat=XAW_PLAIN;
 		wind->widgets[XAW_UP].w=ICON_W;
@@ -434,10 +433,10 @@
 	}
 	if (tp&DNARROW)
 	{
-		wind->widgets[XAW_DOWN].behaviour[XACB_DISPLAY]=&display_dscroll;
-		wind->widgets[XAW_DOWN].behaviour[XACB_CLICK]=&click_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_DISPLAY]=display_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_CLICK]=click_dscroll;
 		wind->widgets[XAW_DOWN].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_DOWN].behaviour[XACB_DRAG]=&click_dscroll;
+		wind->widgets[XAW_DOWN].behaviour[XACB_DRAG]=click_dscroll;
 		wind->widgets[XAW_DOWN].loc=stdl_dscroll;
 		wind->widgets[XAW_DOWN].stat=XAW_PLAIN;
 		wind->widgets[XAW_DOWN].w=ICON_W;
@@ -445,10 +444,10 @@
 	}
 	if (tp&LFARROW)
 	{
-		wind->widgets[XAW_LEFT].behaviour[XACB_DISPLAY]=&display_lscroll;
-		wind->widgets[XAW_LEFT].behaviour[XACB_CLICK]=&click_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_DISPLAY]=display_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_CLICK]=click_lscroll;
 		wind->widgets[XAW_LEFT].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_LEFT].behaviour[XACB_DRAG]=&click_lscroll;
+		wind->widgets[XAW_LEFT].behaviour[XACB_DRAG]=click_lscroll;
 		wind->widgets[XAW_LEFT].loc=stdl_lscroll;
 		wind->widgets[XAW_LEFT].stat=XAW_PLAIN;
 		wind->widgets[XAW_LEFT].w=ICON_W;
@@ -456,10 +455,10 @@
 	}
 	if (tp&RTARROW)
 	{
-		wind->widgets[XAW_RIGHT].behaviour[XACB_DISPLAY]=&display_rscroll;
-		wind->widgets[XAW_RIGHT].behaviour[XACB_CLICK]=&click_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_DISPLAY]=display_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_CLICK]=click_rscroll;
 		wind->widgets[XAW_RIGHT].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_RIGHT].behaviour[XACB_DRAG]=&click_rscroll;
+		wind->widgets[XAW_RIGHT].behaviour[XACB_DRAG]=click_rscroll;
 		wind->widgets[XAW_RIGHT].loc=stdl_rscroll;
 		wind->widgets[XAW_RIGHT].stat=XAW_PLAIN;
 		wind->widgets[XAW_RIGHT].w=ICON_W;
@@ -468,10 +467,10 @@
 
 	if (tp&VSLIDE)
 	{
-		wind->widgets[XAW_VSLIDE].behaviour[XACB_DISPLAY]=&display_vslide;
+		wind->widgets[XAW_VSLIDE].behaviour[XACB_DISPLAY]=display_vslide;
 		wind->widgets[XAW_VSLIDE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_VSLIDE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_VSLIDE].behaviour[XACB_DRAG]=&drag_vslide;
+		wind->widgets[XAW_VSLIDE].behaviour[XACB_DRAG]=drag_vslide;
 		wind->widgets[XAW_VSLIDE].loc=stdl_vslide;
 		wind->widgets[XAW_VSLIDE].stat=XAW_PLAIN;
 		wind->widgets[XAW_VSLIDE].w=ICON_W;
@@ -483,10 +482,10 @@
 	
 	if (tp&HSLIDE)
 	{
-		wind->widgets[XAW_HSLIDE].behaviour[XACB_DISPLAY]=&display_hslide;
+		wind->widgets[XAW_HSLIDE].behaviour[XACB_DISPLAY]=display_hslide;
 		wind->widgets[XAW_HSLIDE].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_HSLIDE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_HSLIDE].behaviour[XACB_DRAG]=&drag_hslide;
+		wind->widgets[XAW_HSLIDE].behaviour[XACB_DRAG]=drag_hslide;
 		wind->widgets[XAW_HSLIDE].loc=stdl_hslide;
 		wind->widgets[XAW_HSLIDE].stat=XAW_PLAIN;
 		wind->widgets[XAW_HSLIDE].w=ICON_W;
@@ -498,7 +497,7 @@
 
 	if (tp&INFO)
 	{
-		wind->widgets[XAW_INFO].behaviour[XACB_DISPLAY]=&display_info;
+		wind->widgets[XAW_INFO].behaviour[XACB_DISPLAY]=display_info;
 		wind->widgets[XAW_INFO].behaviour[XACB_CLICK]=NULL;
 		wind->widgets[XAW_INFO].behaviour[XACB_DCLICK]=NULL;
 		wind->widgets[XAW_INFO].behaviour[XACB_DRAG]=NULL;
@@ -506,7 +505,7 @@
 		wind->widgets[XAW_INFO].stat=XAW_PLAIN;
 		wind->widgets[XAW_INFO].w=top_w;
 		wind->widgets[XAW_INFO].h=display.c_max_h+4;
-		wind->widgets[XAW_INFO].stuff=(void*)"Info Bar";		// Give the window a default info line until the client changes it
+		wind->widgets[XAW_INFO].stuff=(void*)"Info Bar";		/* Give the window a default info line until the client changes it*/
 		
 		if (tp&(NAME|CLOSE|FULLER))
 		{
@@ -517,7 +516,7 @@
 		}
 		
 		bit_mask=tp&(~(INFO|NAME|CLOSE|FULLER));
-		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	// Shift any widgets we might interfere with
+		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	/* Shift any widgets we might interfere with*/
 		{
 			if (bit_mask&1L)
 			{
@@ -532,21 +531,21 @@
 		}
 	}
 
-// do this last as it's a variable size depending on which widgets are on the top bar
+/* do this last as it's a variable size depending on which widgets are on the top bar*/
 	if (tp&NAME)
 	{
-		wind->widgets[XAW_TITLE].behaviour[XACB_DISPLAY]=&display_title;
-		wind->widgets[XAW_TITLE].behaviour[XACB_CLICK]=&click_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_DISPLAY]=display_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_CLICK]=click_title;
 		wind->widgets[XAW_TITLE].behaviour[XACB_DCLICK]=NULL;
-		wind->widgets[XAW_TITLE].behaviour[XACB_DRAG]=&drag_title;
+		wind->widgets[XAW_TITLE].behaviour[XACB_DRAG]=drag_title;
 		wind->widgets[XAW_TITLE].loc=stdl_title;
 		wind->widgets[XAW_TITLE].stat=XAW_PLAIN;
-		wind->widgets[XAW_TITLE].w=top_w;						// Actually, this is re-calculated anyway...
+		wind->widgets[XAW_TITLE].w=top_w;						/* Actually, this is re-calculated anyway...*/
 		wind->widgets[XAW_TITLE].h=display.c_max_h+2;
-		wind->widgets[XAW_TITLE].stuff=(void*)"XaAES Window";	// Give the window a default title until the client changes it
+		wind->widgets[XAW_TITLE].stuff=(void*)"XaAES Window";	/* Give the window a default title until the client changes it*/
 		
 		bit_mask=tp&(~(INFO|NAME|CLOSE|FULLER));
-		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	// Shift any widgets we might interfere with
+		for (wd=0; wd<XA_MAX_WIDGETS; wd++)	/* Shift any widgets we might interfere with*/
 		{
 			if (bit_mask&1L)
 			{
@@ -582,17 +581,17 @@
 	nt->tree=obj;
 	nt->is_menu=TRUE;
 	
-	wind->widgets[XAW_MENU].behaviour[XACB_DISPLAY]=&display_menu_widget;
-	wind->widgets[XAW_MENU].behaviour[XACB_CLICK]=&click_menu_widget;
+	wind->widgets[XAW_MENU].behaviour[XACB_DISPLAY]=display_menu_widget;
+	wind->widgets[XAW_MENU].behaviour[XACB_CLICK]=click_menu_widget;
 	wind->widgets[XAW_MENU].behaviour[XACB_DCLICK]=NULL;
 	wind->widgets[XAW_MENU].behaviour[XACB_DRAG]=NULL;
 	wind->widgets[XAW_MENU].loc=loc;
-	wind->widgets[XAW_MENU].stat=XAW_MENUSTATE;	// Special status value for menu's
+	wind->widgets[XAW_MENU].stat=XAW_MENUSTATE;	/* Special status value for menu's*/
 	wind->widgets[XAW_MENU].w=wind->w-4;
 	wind->widgets[XAW_MENU].h=display.c_max_h;
 	wind->widgets[XAW_MENU].stuff=(void*)nt;
 
-	calc_work_area(wind);			// Recalculate the work area to include the new menu widget
+	calc_work_area(wind);			/* Recalculate the work area to include the new menu widget*/
 }
 
 /*
@@ -614,28 +613,28 @@
 	nt->tree=obj;
 	nt->is_menu=FALSE;
 	
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DISPLAY]=&display_object_widget;
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=&click_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DISPLAY]=display_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_CLICK]=click_object_widget;
 	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DCLICK]=NULL;
-	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=&click_object_widget;
+	wind->widgets[XAW_TOOLBAR].behaviour[XACB_DRAG]=click_object_widget;
 	wind->widgets[XAW_TOOLBAR].loc=loc;
-	wind->widgets[XAW_TOOLBAR].stat=XAW_TOOLBARSTATE;	// Special status value for toolbars
+	wind->widgets[XAW_TOOLBAR].stat=XAW_TOOLBARSTATE;	/* Special status value for toolbars*/
 	wind->widgets[XAW_TOOLBAR].w=obj->ob_width;
 	wind->widgets[XAW_TOOLBAR].h=obj->ob_height;
 	wind->widgets[XAW_TOOLBAR].stuff=(void*)nt;
 
-	calc_work_area(wind);			// Recalculate the work area to include the new menu widget
+	calc_work_area(wind);			/* Recalculate the work area to include the new menu widget*/
 }
 
-// Process widget clicks, and call the appropriate handler routines
-// This is the main routine for handling window interaction from a users perspective.
-// Each widget has a set of behaviours (display, drag, click, etc) for each of it's widgets.
-// - these can be changed on an individual basis, so the close widget of one window might
-//   call a that sends a 'go back up a directory' message to the desktop, where-as on another
-//   it may just take the GEM default and send a WM_CLOSED message to the application.
-// NOTE: If a widget has no XACB_DISPLAY behaviour, it will not recieve clicks (this is
-// deliberate as it's not a good idea to have invisible widgets that still get clicked
-// on.
+/* Process widget clicks, and call the appropriate handler routines*/
+/* This is the main routine for handling window interaction from a users perspective.*/
+/* Each widget has a set of behaviours (display, drag, click, etc) for each of it's widgets.*/
+/* - these can be changed on an individual basis, so the close widget of one window might*/
+/*   call a that sends a 'go back up a directory' message to the desktop, where-as on another*/
+/*   it may just take the GEM default and send a WM_CLOSED message to the application.*/
+/* NOTE: If a widget has no XACB_DISPLAY behaviour, it will not recieve clicks (this is*/
+/* deliberate as it's not a good idea to have invisible widgets that still get clicked*/
+/* on.*/
 short do_widgets(XA_WINDOW *w, MOUSE_DATA *md)
 {
 	XA_RECT_LIST *rl=generate_rect_list(w);
@@ -649,69 +648,69 @@
 	clicks=md->clicks;
 	if (clicks>2) clicks=2;
 
-	for(f=0; (f<XA_MAX_WIDGETS)&&(this_widget==NULL); f++)		// Scan through widgets to find the one we clicked on
+	for(f=0; (f<XA_MAX_WIDGETS)&&(this_widget==NULL); f++)		/* Scan through widgets to find the one we clicked on*/
 	{
 		widg=w->widgets+f;
-		disp=widg->behaviour[XACB_DISPLAY];		// get the redraw function for this widget
+		disp=widg->behaviour[XACB_DISPLAY];		/* get the redraw function for this widget*/
 		if (disp)
 		{
-			rp_2_ap(w, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+			rp_2_ap(w, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 			if ((((md->mx>x)&&(md->my>y))&&(md->mx<x+widg->w))&&(md->my<y+widg->h))
 			{
-				this_widget=widg;			// Found a widget - this_widget acts as a flag that says to absorb the click
+				this_widget=widg;			/* Found a widget - this_widget acts as a flag that says to absorb the click*/
 
-				widg->click_x=md->mx-x; 	// Mark where the click occurred (relative to the widget)
+				widg->click_x=md->mx-x; 	/* Mark where the click occurred (relative to the widget)*/
 				widg->click_y=md->my-y;	
 
-											// We don't auto select & pre-display for a menu or toolbar widget
+											/* We don't auto select & pre-display for a menu or toolbar widget*/
 				if ((f!=XAW_MENU)&&(f!=XAW_TOOLBAR))
 				{
-					widg->stat=XAW_SELECTED;	// Flag the widget as selected
+					widg->stat=XAW_SELECTED;	/* Flag the widget as selected*/
 				
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
 						vs_clip(V_handle,1, clip);
-						(*disp)(w, this_widget);	// display the selected widget
+						(*disp)(w, this_widget);	/* display the selected widget*/
 					}
 					v_show_c(V_handle, 1);
 				}
 
-				wdrag=this_widget->behaviour[XACB_DRAG];	// get the click-drag function for this widget
+				wdrag=this_widget->behaviour[XACB_DRAG];	/* get the click-drag function for this widget*/
 
 				vq_mouse(V_handle, &b,&rx,&ry);
-				if ((b)&&(wdrag))	// If the mouse button is still down do a drag (if the widget has a drag behaviour)
+				if ((b)&&(wdrag))	/* If the mouse button is still down do a drag (if the widget has a drag behaviour)*/
 				{
 					rtn=(*wdrag)(w, this_widget);
-				}else{							// otherwise, process as a mouse click(s)
+				}else{							/* otherwise, process as a mouse click(s)*/
 	
-					while (b)					// wait for the mouse to be released
+					while (b)					/* wait for the mouse to be released*/
 						vq_mouse(V_handle, &b,&rx,&ry);
 				
 					if ((((rx>x)&&(ry>y))&&(rx<x+widg->w))&&(ry<y+widg->h))
 					{
 						wc=this_widget->behaviour[clicks];
-						if (wc)							// If the widget has a click behaviour, call it
+						if (wc)							/* If the widget has a click behaviour, call it*/
 						{
 							rtn=(*wc)(w, this_widget);
 						}
 					}
 				}
 				
-				if (rtn)	// If the widget click/drag function returned TRUE we reset the state of the widget
+				if (rtn)	/* If the widget click/drag function returned TRUE we reset the state of the widget*/
 				{
-					widg->stat=XAW_PLAIN;			// Flag the widget as de-selected
+					widg->stat=XAW_PLAIN;			/* Flag the widget as de-selected*/
 			
 					v_hide_c(V_handle);
-					for(drl=rl; drl; drl=drl->next)	// Walk the rectangle list
+					for(drl=rl; drl; drl=drl->next)	/* Walk the rectangle list*/
 					{
 						clip[0]=drl->x; clip[1]=drl->y;
 						clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
 						vs_clip(V_handle,1, clip);
-						(*disp)(w, this_widget);	// display the selected widget
+						(*disp)(w, this_widget);	/* display the selected widget*/
 					}
 					v_show_c(V_handle, 1);
 				}
@@ -719,14 +718,14 @@
 		}
 	}
 
-	while(rl)	// Dispose of rectangle list
+	while(rl)	/* Dispose of rectangle list*/
 	{
 		drl=rl;
 		rl=rl->next;
 		free(drl);
 	}
 	
-	if (this_widget) return TRUE;	// Button click was used up by the GUI
+	if (this_widget) return TRUE;	/* Button click was used up by the GUI*/
 	
-	return FALSE;					// Button click can be passed on to applications as we didn't use it for a widget
+	return FALSE;					/* Button click can be passed on to applications as we didn't use it for a widget*/
 }
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/titlwidg.c /h/xaaes/titlwidg.c
--- /i/newitems/XaAES.beta2/src/titlwidg.c	Thu Feb  8 02:32:28 1996
+++ /h/xaaes/titlwidg.c	Thu Feb 22 13:07:12 1996
@@ -18,6 +18,7 @@
 #include "RECTLIST.H"
 #include "ALL_WIDG.H"
 #include "STD_WIDG.H"
+#include "drag_box.h"
 
 /*======================================================
 	TITLE WIDGET BEHAVIOUR
@@ -26,10 +27,10 @@
 {
 	short x,y,pnt[4];
 
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 
 #if DISPLAY_LOGO_IN_TITLE_BAR
-	if (widg->stat==XAW_PLAIN)	// display the XaAES logo on the title bar of each window
+	if (widg->stat==XAW_PLAIN)	/* display the XaAES logo on the title bar of each window*/
 		display_widget_bitmap(x, y, bitmap_xaaes16);
 	else
 		display_widget_bitmap(x, y, bitmap_xaaes16_s);
@@ -40,7 +41,7 @@
 	pnt[0]=x; pnt[1]=y; pnt[2]=x+widg->w-3; pnt[3]=y+widg->h;
 #endif
 
-	if (window_list==wind)	// Highlight the title bar of the top window
+	if (window_list==wind)	/* Highlight the title bar of the top window*/
 	{
 		vsf_color(V_handle,LBLUE);
 		vsf_interior(V_handle,FIS_SOLID);
@@ -55,32 +56,32 @@
 	return TRUE;
 }
 
-// Click & drag on the title bar - does a move window
+/* Click & drag on the title bar - does a move window*/
 short drag_title(XA_WINDOW *wind, XA_WIDGET *widg)
 {
-	short x,y;
+	short x,y,xy[4];
 
-	if (wind->active_widgets&MOVER)			// You can only move a window if it's MOVER attribute is set
+	if (wind->active_widgets&MOVER)			/* You can only move a window if it's MOVER attribute is set*/
 	{
-		vs_clip(V_handle, 0, NULL);
+		vs_clip(V_handle, 0, xy);
 
-		graf_mouse(XACRS_MOVER, NULL);		// Always have a nice consistent MOVER when dragging a box
+		graf_mouse(XACRS_MOVER, NULL);		/* Always have a nice consistent MOVER when dragging a box*/
 		drag_box(wind->w, wind->h, wind->x, wind->y, display.x, display.y, display.w, display.h, &x, &y);
 		
-		graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	// Restore the mouse now we've done the drag
+		graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);	/* Restore the mouse now we've done the drag*/
 
 		if ((x!=wind->x)||(y!=wind->y))
 		{
-			if (wind->owner==AESpid)			// Just move AES owned windows, they can handle it....
+			if (wind->owner==AESpid)			/* Just move AES owned windows, they can handle it....*/
 			{
 				v_hide_c(V_handle);
 				
 				erase_non_topped_window(wind);
 				display_windows_below(wind);
 
-				wind->prev_x=wind->x;			// Save windows previous coords
+				wind->prev_x=wind->x;			/* Save windows previous coords*/
 				wind->prev_y=wind->y;
-				wind->x=x;						// Change the window coords
+				wind->x=x;						/* Change the window coords*/
 				wind->y=y;
 
 				calc_work_area(wind);
@@ -89,7 +90,7 @@
 			
 				v_show_c(V_handle,1);
 
-			}else{	// Send a message to a client to say that the AES would like the window moving (if the window has moved)
+			}else{	/* Send a message to a client to say that the AES would like the window moving (if the window has moved)*/
 				send_app_message(wind->owner, WM_MOVED, 0, wind->handle, x, y, wind->w, wind->h);
 			}
 		}
@@ -102,19 +103,19 @@
 {
 	short clip[4];
 
-	if (window_list!=wind)	// If window isn't top then top it
+	if (window_list!=wind)	/* If window isn't top then top it*/
 	{
 	
 		if (wind->owner==AESpid)
 		{
-			pull_wind_to_top(wind);	// Top the window
+			pull_wind_to_top(wind);	/* Top the window*/
 
 			clip[0]=wind->x; clip[1]=wind->y;
 			clip[2]=wind->x+wind->w; clip[3]=wind->y+wind->h;
 			vs_clip(V_handle,1,clip);
 			
 			v_hide_c(V_handle);
-			display_window(wind);	// Display the window (clip to it's size)
+			display_window(wind);	/* Display the window (clip to it's size)*/
 			v_show_c(V_handle,1);
 			
 			vs_clip(V_handle,0,clip);
@@ -125,16 +126,16 @@
 	
 		}
 	
-	}else{		// If window is already top, then send it to the back
+	}else{		/* If window is already top, then send it to the back*/
 
 		if (wind->owner==AESpid)
 		{
 			v_hide_c(V_handle);
 
-			display_windows_below(wind);	// Redisplay any windows below the one we are bottoming
-											// (if they require it)
-			send_wind_to_bottom(wind);		// Send it to the back
-			display_non_topped_window(wind);// Re-display the window
+			display_windows_below(wind);	/* Redisplay any windows below the one we are bottoming*/
+											/* (if they require it)*/
+			send_wind_to_bottom(wind);		/* Send it to the back*/
+			display_non_topped_window(wind);/* Re-display the window*/
 
 			v_show_c(V_handle,1);
 
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/watchbox.c /h/xaaes/watchbox.c
--- /i/newitems/XaAES.beta2/src/watchbox.c	Sun Feb 11 19:16:26 1996
+++ /h/xaaes/watchbox.c	Wed Feb 21 13:45:24 1996
@@ -31,12 +31,12 @@
 	
 	vq_mouse(V_handle,&mb,&omx,&omy);
 	
-	object_abs_coords(dial, ob, &x, &y);	// call XaAES's internal objc_offset()
+	object_abs_coords(dial, ob, &x, &y);	/* call XaAES's internal objc_offset()*/
 	w=the_object->ob_width+2;
 	h=the_object->ob_height+2;
 	x--; y--;
 
-	if (!mb)		// If mouse button is already released, assume that was just a click, so select
+	if (!mb)		/* If mouse button is already released, assume that was just a click, so select*/
 	{
 		(dial+ob)->ob_state=in_state;
 		v_hide_c(V_handle);
@@ -45,8 +45,8 @@
 		obf=ob;
 	}else{
 	
-		while (mb)		// This loop contains a pretty busy wait, but I don't think it's to
-		{				// much of a problem as the user is interacting with it continuously.
+		while (mb)		/* This loop contains a pretty busy wait, but I don't think it's to*/
+		{				/* much of a problem as the user is interacting with it continuously.*/
 			vq_mouse(V_handle,&mb,&mx,&my);
 		
 			if ((mx!=omx)||(my!=omy))
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/wind_fns.c /h/xaaes/wind_fns.c
--- /i/newitems/XaAES.beta2/src/wind_fns.c	Thu Feb 15 00:12:58 1996
+++ /h/xaaes/wind_fns.c	Thu Feb 22 18:53:18 1996
@@ -5,6 +5,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <VDI.H>
 #include <MINTBIND.H>
 #include <OSBIND.H>
@@ -19,6 +20,8 @@
 #include "INFOWIDG.H"
 #include "TITLWIDG.H"
 #include "STD_WIDG.H"
+#include "graf_mou.h"
+#include "messages.h"
 
 /*
 	AES window handling functions
@@ -38,9 +41,9 @@
 
 	DIAGS(("  - window created (handle=%d)\n",new_window->handle));
 
-	pb->intout[0]=new_window->handle;	// Return the window handle in intout[0]
+	pb->intout[0]=new_window->handle;	/* Return the window handle in intout[0]*/
 
-	return TRUE;	// Allow the kernal to wake up the client - we've done our bit
+	return TRUE;	/* Allow the kernal to wake up the client - we've done our bit*/
 }
 
 short XA_wind_open(short clnt_pid,AESPB *pb)
@@ -49,18 +52,18 @@
 
 	DIAGS(("wind_open() - "));
 
-	w=get_wind_by_handle(pb->intin[0]);	// Get the window
+	w=get_wind_by_handle(pb->intin[0]);	/* Get the window*/
 
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 	
-	pb->intout[0]=1;				// return ok in intout[0]
+	pb->intout[0]=1;				/* return ok in intout[0]*/
 	
-	if (w->is_open==TRUE)			// the window is already open, no need to do anything
+	if (w->is_open==TRUE)			/* the window is already open, no need to do anything*/
 	{
 		DIAGS(("WARNING: Attempt to open window when it was already open\n"));
 		return TRUE;
@@ -68,29 +71,29 @@
 
 	DIAGS(("\n"));
 
-	// New top window - change the cursor to this clients choice
+	/* New top window - change the cursor to this clients choice*/
 	graf_mouse(clients[clnt_pid].client_mouse, clients[clnt_pid].client_mouse_form);
 	
-	pull_wind_to_top(w);			// Newly opened windows begin on top
+	pull_wind_to_top(w);			/* Newly opened windows begin on top*/
 
 	wl=w->next;
-	if (wl)		// Refresh the previous top window as being 'non-topped'
+	if (wl)		/* Refresh the previous top window as being 'non-topped'*/
 	{
 		display_non_topped_window(wl);
 		send_app_message(wl->owner, WM_REDRAW, 0, wl->handle, wl->x, wl->y, wl->w, wl->h);
 	}
 	
-	w->x=pb->intin[1];				// Change the window coords
+	w->x=pb->intin[1];				/* Change the window coords*/
 	w->y=pb->intin[2];
 	w->w=pb->intin[3];
 	w->h=pb->intin[4];
 
-	w->is_open=TRUE;				// Flag window as open
+	w->is_open=TRUE;				/* Flag window as open*/
 
 	calc_work_area(w);
 
 	v_hide_c(V_handle);
-	display_non_topped_window(w);	// Display the window (use the non-topped method as it sets clipping rectangles)
+	display_non_topped_window(w);	/* Display the window (use the non-topped method as it sets clipping rectangles)*/
 	send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 	v_show_c(V_handle,1);
 
@@ -103,35 +106,35 @@
 	
 	DIAGS(("wind_close() - "));
 
-	w=get_wind_by_handle(pb->intin[0]);	// Get the window
+	w=get_wind_by_handle(pb->intin[0]);	/* Get the window*/
 
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
-	if (w->owner!=clnt_pid)		// Clients can only close their own windows
+	if (w->owner!=clnt_pid)		/* Clients can only close their own windows*/
 	{
 		DIAGS(("WARNING: clnt %d cannot close window %d (not owner)\n",clnt_pid,w->handle));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
 	v_hide_c(V_handle);
 
-	erase_non_topped_window(w);			// Erase the window
-	redraw_area(w->x,w->y,w->w,w->h);	// The redraw should really get done here
-	display_windows_below(w);			// Redisplay any windows below the one we are closing
+	erase_non_topped_window(w);			/* Erase the window*/
+	redraw_area(w->x,w->y,w->w,w->h);	/* The redraw should really get done here*/
+	display_windows_below(w);			/* Redisplay any windows below the one we are closing*/
 
 	v_show_c(V_handle,1);
 
 	send_wind_to_bottom(w);
 
-	w->is_open=FALSE;		// tag window as closed
+	w->is_open=FALSE;		/* tag window as closed*/
 
-	// New top window - change the cursor to this clients choice
+	/* New top window - change the cursor to this clients choice*/
 	graf_mouse(clients[window_list->owner].client_mouse, clients[window_list->owner].client_mouse_form);
 	
 	pb->intout[0]=1;
@@ -146,7 +149,7 @@
 	
 	DIAGS(("wind_find() - "));
 
-	w=wind_find(pb->intin[0], pb->intin[1]);	// Is there a window under the mouse?
+	w=wind_find(pb->intin[0], pb->intin[1]);	/* Is there a window under the mouse?*/
 
 	if (w==NULL)
 	{
@@ -155,7 +158,7 @@
 		return TRUE;
 	}
 
-	pb->intout[0]=w->handle;	// Found a window, return the handle
+	pb->intout[0]=w->handle;	/* Found a window, return the handle*/
 
 	DIAGS(("\n"));
 	
@@ -169,14 +172,14 @@
 	XA_WIDGET *widg=wind->widgets;
 	widg+=XAW_VSLIDE;
 	
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
 	vsf_interior(V_handle,FIS_SOLID);
 	
 	v_hide_c(V_handle);
-	for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+	for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 	{
 		clip[0]=drl->x; clip[1]=drl->y;
 		clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -194,7 +197,7 @@
 	XA_WIDGET *widg=wind->widgets;
 	widg+=XAW_HSLIDE;
 	
-	rp_2_ap(wind, widg, &x, &y);	// Convert relative coords and window location to absolute screen location
+	rp_2_ap(wind, widg, &x, &y);	/* Convert relative coords and window location to absolute screen location*/
 	pnt[0]=x; pnt[1]=y;
 	pnt[2]=x+widg->w; pnt[3]=y+widg->h;
 	vsf_color(V_handle,display.dial_colours.bg_col);
@@ -203,7 +206,7 @@
 	vsf_interior(V_handle,FIS_SOLID);
 	
 	v_hide_c(V_handle);
-	for(drl=rl; drl; drl=drl->next)				// Walk the rectangle list
+	for(drl=rl; drl; drl=drl->next)				/* Walk the rectangle list*/
 	{
 		clip[0]=drl->x; clip[1]=drl->y;
 		clip[2]=drl->x+drl->w; clip[3]=drl->y+drl->h;
@@ -229,14 +232,14 @@
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
-	if (w->owner!=clnt_pid)		// Clients can only change their own windows
+	if (w->owner!=clnt_pid)		/* Clients can only change their own windows*/
 	{
 		DIAGS(("WARNING: clnt %d cannot change window %d (not owner)\n",clnt_pid,w->handle));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 	
@@ -297,7 +300,7 @@
 			break;
 		case WF_NAME:
 			l=(unsigned short*)(pb->intin);
-			t=(char*)(l[2]<<16);
+			t=(char*)((long)l[2]<<16L);
 			t+=l[3];
 			w->widgets[XAW_TITLE].stuff=(void*)t;
 
@@ -314,14 +317,14 @@
 					rl=rl->next;
 					free(drl);
 				}
-//				display_non_topped_window(w);
-//				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
+/*				display_non_topped_window(w);*/
+/*				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);*/
 			}
 			v_show_c(V_handle,1);
 			break;
 		case WF_INFO:
 			l=(unsigned short*)(pb->intin);
-			t=(char*)(l[2]<<16);
+			t=(char*)((long)l[2]<<16L);
 			t+=l[3];
 			w->widgets[XAW_INFO].stuff=(void*)t;
 
@@ -338,49 +341,49 @@
 					rl=rl->next;
 					free(drl);
 				}
-//				display_non_topped_window(w);
-//				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
+/*				display_non_topped_window(w);*/
+/*				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);*/
 			}
 			v_show_c(V_handle,1);
 			break;
-		case WF_CURRXYWH:			// Move a window
+		case WF_CURRXYWH:			/* Move a window*/
 			v_hide_c(V_handle);
 			erase_non_topped_window(w);
-			display_windows_below(w);	// Redisplay any windows below the one we are moving
-										// (if they require it)
+			display_windows_below(w);	/* Redisplay any windows below the one we are moving*/
+										/* (if they require it)*/
 
-			w->prev_x=w->x;				// Save windows previous coords
+			w->prev_x=w->x;				/* Save windows previous coords*/
 			w->prev_y=w->y;
 			w->prev_w=w->w;
 			w->prev_h=w->h;
 			
-			w->x=pb->intin[2];			// Change the window coords
+			w->x=pb->intin[2];			/* Change the window coords*/
 			w->y=pb->intin[3];
 			w->w=pb->intin[4];
 			w->h=pb->intin[5];
 
-			calc_work_area(w);			// Recalculate the work area (as well as moving,
-										// it might have changed size).
+			calc_work_area(w);			/* Recalculate the work area (as well as moving,*/
+										/* it might have changed size).*/
 			
-			display_non_topped_window(w);	// Re-display the window
+			display_non_topped_window(w);	/* Re-display the window*/
 			
 			send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 			v_show_c(V_handle,1);
 
 			break;
-		case WF_BOTTOM:				// Extension, send window to the bottom
+		case WF_BOTTOM:				/* Extension, send window to the bottom*/
 			v_hide_c(V_handle);
-			display_windows_below(w);		// Redisplay any windows below the one we are bottoming
-											// (if they require it)
-			send_wind_to_bottom(w);			// Send it to the back
-			display_non_topped_window(w);	// Re-display the window
+			display_windows_below(w);		/* Redisplay any windows below the one we are bottoming*/
+											/* (if they require it)*/
+			send_wind_to_bottom(w);			/* Send it to the back*/
+			display_non_topped_window(w);	/* Re-display the window*/
 			v_show_c(V_handle,1);
 			break;
-		case WF_TOP:				// Top the window
+		case WF_TOP:				/* Top the window*/
 			pull_wind_to_top(w);
-							// New top window - change the cursor to this clients choice
+							/* New top window - change the cursor to this clients choice*/
 			graf_mouse(clients[clnt_pid].client_mouse, clients[clnt_pid].client_mouse_form);
-							// Display the previous top window as un-topped
+							/* Display the previous top window as un-topped*/
 			
 			v_hide_c(V_handle);
 			if ((window_list->next)&&(window_list->next->is_open))
@@ -388,7 +391,7 @@
 			
 			if (w->is_open)
 			{
-				display_non_topped_window(w);	// Display the window
+				display_non_topped_window(w);	/* Display the window*/
 				send_app_message(clnt_pid, WM_REDRAW, 0, w->handle, w->x, w->y, w->w, w->h);
 			}			
 			v_show_c(V_handle,1);
@@ -402,10 +405,10 @@
 	return TRUE;
 }
 
-// AES wind_get() function.
-// This includes support for most of the AES4 / AES4.1 extensions,
-// with the exception of WF_BEVENT (all XaAES windows get button events in the
-// background at the moment).
+/* AES wind_get() function.*/
+/* This includes support for most of the AES4 / AES4.1 extensions,*/
+/* with the exception of WF_BEVENT (all XaAES windows get button events in the*/
+/* background at the moment).*/
 short XA_wind_get(short clnt_pid, AESPB *pb)
 {
 	XA_WINDOW *w;
@@ -421,14 +424,14 @@
 	if (w==NULL)
 	{
 		DIAGS(("WARNING:Invalid window handle\n"));
-		pb->intout[0]=0;			// Invalid window handle, return error
+		pb->intout[0]=0;			/* Invalid window handle, return error*/
 		return TRUE;
 	}
 
 	switch(cmd)
 	{
-		case WF_FIRSTXYWH:			// Generate a rectangle list and return the first entry
-			for(rl=w->rect_list; rl; )	// Dispose of any existing rectangle list
+		case WF_FIRSTXYWH:			/* Generate a rectangle list and return the first entry*/
+			for(rl=w->rect_list; rl; )	/* Dispose of any existing rectangle list*/
 			{
 				drl=rl;
 				rl=rl->next;
@@ -436,9 +439,9 @@
 			}
 			w->rect_list=NULL;
 			
-			rl=generate_rect_list(w);	// Call the internal rectangle list generator.
+			rl=generate_rect_list(w);	/* Call the internal rectangle list generator.*/
 			
-			for(drl=rl; rl; drl=rl)		// Fix the rectangle list to clip to the work area only
+			for(drl=rl; rl; drl=rl)		/* Fix the rectangle list to clip to the work area only*/
 			{
 				s.g_x=rl->x;
 				s.g_y=rl->y;
@@ -449,8 +452,8 @@
 				d.g_w=w->ww;
 				d.g_h=w->wh;
 				rl=rl->next;
-				if (rc_intersect(&s, &d))	// Optimise the rectangle list to only do bit's 
-				{							// that intersect the work area
+				if (rc_intersect(&s, &d))	/* Optimise the rectangle list to only do bit's */
+				{							/* that intersect the work area*/
 					drl->x=d.g_x;
 					drl->y=d.g_y;
 					drl->w=d.g_w+1;
@@ -462,100 +465,100 @@
 				}
 			}
 
-			if (w->rect_list)			// Did we get any rectangles?
+			if (w->rect_list)			/* Did we get any rectangles?*/
 			{
 				rl=w->rect_list;
 				w->rect_list=rl->next;
-				pb->intout[1]=rl->x;	// Return the first rectangle coords
+				pb->intout[1]=rl->x;	/* Return the first rectangle coords*/
 				pb->intout[2]=rl->y;
 				pb->intout[3]=rl->w;
 				pb->intout[4]=rl->h;
-				free(rl);				// Dispose the first entry in the rectangle list
+				free(rl);				/* Dispose the first entry in the rectangle list*/
 			}else{
-				pb->intout[1]=w->wx;	// Totally obscured window, return w & h as 0
+				pb->intout[1]=w->wx;	/* Totally obscured window, return w & h as 0*/
 				pb->intout[2]=w->wy;
 				pb->intout[3]=0;
 				pb->intout[4]=0;
-				w->rect_list=NULL;		// Window has no rectangle list
+				w->rect_list=NULL;		/* Window has no rectangle list*/
 			}
 			break;
-		case WF_NEXTXYWH:			// Get next entry from a rectangle list
-			if (w->rect_list!=NULL)		// Are there any rectangles left in the list ?
+		case WF_NEXTXYWH:			/* Get next entry from a rectangle list*/
+			if (w->rect_list!=NULL)		/* Are there any rectangles left in the list ?*/
 			{
 				rl=w->rect_list;
 				w->rect_list=rl->next;
-				pb->intout[1]=rl->x;	// Return the next rectangle coords
+				pb->intout[1]=rl->x;	/* Return the next rectangle coords*/
 				pb->intout[2]=rl->y;
 				pb->intout[3]=rl->w;
 				pb->intout[4]=rl->h;
-				free(rl);				// Dispose the entry in the rectangle list
+				free(rl);				/* Dispose the entry in the rectangle list*/
 			}else{
-				pb->intout[1]=0;		// No rectangles left - return all zero
+				pb->intout[1]=0;		/* No rectangles left - return all zero*/
 				pb->intout[2]=0;
 				pb->intout[3]=0;
 				pb->intout[4]=0;
 			}
 			break;
-		case WF_CURRXYWH:			// Get the current coords of the window
-			pb->intout[1]=w->x;		// Return the window coords
+		case WF_CURRXYWH:			/* Get the current coords of the window*/
+			pb->intout[1]=w->x;		/* Return the window coords*/
 			pb->intout[2]=w->y;
 			pb->intout[3]=w->w;
 			pb->intout[4]=w->h;
 			break;
-		case WF_WORKXYWH:			// Get the current coords of the window's user work area
+		case WF_WORKXYWH:			/* Get the current coords of the window's user work area*/
 			pb->intout[1]=w->wx+2;	
 			pb->intout[2]=w->wy+2;
 			pb->intout[3]=w->ww-4;
 			pb->intout[4]=w->wh-4;
 			break;
-		case WF_PREVXYWH:			// Get previous window position
+		case WF_PREVXYWH:			/* Get previous window position*/
 			pb->intout[1]=w->prev_x;
 			pb->intout[2]=w->prev_y;
 			pb->intout[3]=w->prev_w;
 			pb->intout[4]=w->prev_h;
 			break;			
-		case WF_FULLXYWH:			// Get maximum window dimensions
+		case WF_FULLXYWH:			/* Get maximum window dimensions*/
 			pb->intout[1]=root_window->x; 
-			pb->intout[2]=root_window->wy;	// ensure the windows don't overlay the menu bar
+			pb->intout[2]=root_window->wy;	/* ensure the windows don't overlay the menu bar*/
 			pb->intout[3]=root_window->w;
 			pb->intout[4]=root_window->h-root_window->wy;
 			break;
-		case WF_BOTTOM:				// Extension, gets the bottom window
+		case WF_BOTTOM:				/* Extension, gets the bottom window*/
 			for(w=window_list; w->next; w=w->next);
-			pb->intout[1]=w->handle;	// Return the window handle of the bottom window
-			pb->intout[2]=w->owner;		// Return the owner of the bottom window
+			pb->intout[1]=w->handle;	/* Return the window handle of the bottom window*/
+			pb->intout[2]=w->owner;		/* Return the owner of the bottom window*/
 			break;
 		case WF_TOP:
 			for(w=window_list; (w)&&(w->is_open==FALSE); w=w->next);
 			if (w)
 			{
-				pb->intout[1]=w->handle;	// Return the window handle
-				pb->intout[2]=w->owner;		// AES4 specifies that you return the AESid of the owner here as well
-				if (w->next)				// Is there a window below? 
-				{							// if there is, then AES4 says return it's handle here
+				pb->intout[1]=w->handle;	/* Return the window handle*/
+				pb->intout[2]=w->owner;		/* AES4 specifies that you return the AESid of the owner here as well*/
+				if (w->next)				/* Is there a window below? */
+				{							/* if there is, then AES4 says return it's handle here*/
 					pb->intout[3]=w->next->handle;
-					pb->intout[4]=w->next->owner;	// XaAES extentin - return the AESid of the app that owns the window below
+					pb->intout[4]=w->next->owner;	/* XaAES extentin - return the AESid of the app that owns the window below*/
 				}else{
 					pb->intout[3]=0;
 					pb->intout[4]=0;
 				}
 			}else{
-				pb->intout[1]=0;	// No windows open - return an error
+				pb->intout[1]=0;	/* No windows open - return an error*/
 				pb->intout[0]=0;
 				return TRUE;
 			}
 			break;
-		case WF_OWNER:				// AES4 compatible stuff
-			pb->intout[1]=w->owner;		// The window owners AESid (==app_id)
-			pb->intout[2]=w->is_open;	// Is the window open?
-			if (w->prev)				// If there is a window above, return it's handle
+		case WF_OWNER:				/* AES4 compatible stuff*/
+			pb->intout[1]=w->owner;		/* The window owners AESid (==app_id)*/
+			pb->intout[2]=w->is_open;	/* Is the window open?*/
+			if (w->prev)				/* If there is a window above, return it's handle*/
 			{
 				pb->intout[3]=w->prev->handle;
 			}else{
 				pb->intout[3]=0;
 			}
 			
-			if (w->next)				// If there is a window below, return it's handle
+			if (w->next)				/* If there is a window below, return it's handle*/
 			{
 				pb->intout[4]=w->next->handle;
 			}else{
@@ -610,34 +613,56 @@
 	return TRUE;
 }
 
-short update_lock=FALSE;			// These are now only here for debugging...
+short update_lock=FALSE;			/* These are now only here for debugging...*/
 short mouse_lock=FALSE;
+short update_cnt=0;
+short mouse_cnt=0;
 
-// Wind_update handling
-// This handles locking for the update and mctrl flags.
-// !!!!New version - uses semphores to locking...
+/* Wind_update handling*/
+/* This handles locking for the update and mctrl flags.*/
+/* !!!!New version - uses semphores to locking...*/
 short XA_wind_update(short clnt_pid, AESPB *pb)
 {
 	pb->intout[0]=1;
 	
 	switch(pb->intin[0])
 	{
-		case BEG_UPDATE:	// Grab the update lock
+		case BEG_UPDATE:	/* Grab the update lock*/
 			Psemaphore(2,UPDATE_LOCK,-1L);
+			if (update_lock == clnt_pid)
+				update_cnt++;
+			else
+				update_cnt = 0;
 			update_lock=clnt_pid;
 			break;
 		case END_UPDATE:
+			if (update_lock != clnt_pid)
+				return FALSE;	/* Should usually never happen */
+/* Only free the semaphore if this is really releasing the lock */
+			if (--update_cnt > 0)
+				break;
 			update_lock=FALSE;
 			Psemaphore(3,UPDATE_LOCK,0);
 			break;
-		case BEG_MCTRL:		// Grab the mouse lock
+		case BEG_MCTRL:		/* Grab the mouse lock*/
 			Psemaphore(2,MOUSE_LOCK,-1L);
+			if (mouse_lock == clnt_pid)
+				mouse_cnt++;
+			else
+				mouse_cnt = 0;
 			mouse_lock=clnt_pid;
 			break;
 		case END_MCTRL:
+			if (mouse_lock != clnt_pid)
+				return FALSE;
+			if (--mouse_cnt > 0)
+				break;
 			mouse_lock=FALSE;
 			Psemaphore(3,MOUSE_LOCK,0);
 			break;
+		default:
+			pb->intout[0] = 0;
+			return FALSE;
 	}
 	return TRUE;
 }
@@ -659,8 +684,8 @@
 	return TRUE;
 }
 
-// Go through and check that all windows belonging to this client are
-// closed and deleted 
+/* Go through and check that all windows belonging to this client are*/
+/* closed and deleted. Also release any locks of this client. */
 short XA_wind_new(short clnt_pid, AESPB *pb)
 {
 	XA_WINDOW *wl,*dwl;
@@ -672,14 +697,14 @@
 			dwl=wl;
 
 			v_hide_c(V_handle);
-			erase_non_topped_window(wl);			// Erase the window
-			redraw_area(wl->x,wl->y,wl->w,wl->h);	// The redraw should really get done here
-			display_windows_below(wl);				// Redisplay any windows below the one we are closing
+			erase_non_topped_window(wl);			/* Erase the window*/
+			redraw_area(wl->x,wl->y,wl->w,wl->h);	/* The redraw should really get done here*/
+			display_windows_below(wl);				/* Redisplay any windows below the one we are closing*/
 			v_show_c(V_handle, 1);
 
 			wl=wl->next;
 			
-			if (window_list==dwl)					// Actually delete the window
+			if (window_list==dwl)					/* Actually delete the window*/
 				window_list=dwl->next;
 
 			if (dwl->prev) dwl->prev->next=dwl->next;
@@ -690,6 +715,19 @@
 			wl=wl->next;
 		}
 	}
+
+	if (update_lock == clnt_pid)
+	{
+		update_lock = FALSE;
+		update_cnt = 0;
+		Psemaphore(3, UPDATE_LOCK, 0);
+	}
+	if (mouse_lock == clnt_pid)
+	{
+		mouse_lock = FALSE;
+		mouse_cnt = 0;
+		Psemaphore(3, MOUSE_LOCK, 0);
+	}
 	
 	return TRUE;
 }
@@ -702,18 +740,18 @@
 	XA_WINDOW *w_temp;
 	short request=pb->intin[0];
 	
-// Create a temporary window with the required widgets
+/* Create a temporary window with the required widgets*/
 	w_temp=create_window(clnt_pid, pb->intin[1], pb->intin[2], pb->intin[3], pb->intin[4], pb->intin[5]);
 
 	switch(request)
 	{
-		case WC_BORDER:					// We have to work out the border size ourselves here
-			pb->intout[1]=2*w_temp->x - w_temp->wx;	//if you want to prove the maths here, draw two boxes one inside
-			pb->intout[2]=2*w_temp->y - w_temp->wy;	// the other, then sit and think about it for a while....
+		case WC_BORDER:					/* We have to work out the border size ourselves here*/
+			pb->intout[1]=2*w_temp->x - w_temp->wx;	/*if you want to prove the maths here, draw two boxes one inside*/
+			pb->intout[2]=2*w_temp->y - w_temp->wy;	/* the other, then sit and think about it for a while....*/
 			pb->intout[3]=2*w_temp->w - w_temp->ww +1;
 			pb->intout[4]=2*w_temp->h - w_temp->wh +1;
 			break;
-		case WC_WORK:					// Work area was calculated when the window was created
+		case WC_WORK:					/* Work area was calculated when the window was created*/
 			pb->intout[1]=w_temp->wx;
 			pb->intout[2]=w_temp->wy;
 			pb->intout[3]=w_temp->ww+1;
@@ -721,7 +759,7 @@
 			break;
 	}
 
-	delete_window(w_temp);		// Dispose of the temporary window we created
+	delete_window(w_temp);		/* Dispose of the temporary window we created*/
 
 	pb->intout[0]=1;
 	
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_aes.prj /h/xaaes/xa_aes.prj
--- /i/newitems/XaAES.beta2/src/xa_aes.prj	Mon Feb 19 13:57:56 1996
+++ /h/xaaes/xa_aes.prj	Thu Feb 22 20:06:22 1996
@@ -6,6 +6,7 @@
 C.O
 APPL_INI.C	[-gs -gx -b4 -r0 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=0]
 APP_MAN.C	[-gx -b4 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=1]
+APPL_MSG.C
 ALL_WIDG.C
 BOOTUP.C	[-gx -b4 -r6 -v -cm -d0 -m0 -rs -cb -cg -ck -cq -cr -fm -dGENERATE_DIAGS=1]	(XA_DEFS.H,FRM_ALRT.H,XA_TYPES.H,COOKIES.H)
 BOX3D.C
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_codes.h /h/xaaes/xa_codes.h
--- /i/newitems/XaAES.beta2/src/xa_codes.h	Sun Feb 18 22:25:18 1996
+++ /h/xaaes/xa_codes.h	Thu Feb 22 19:55:24 1996
@@ -12,9 +12,11 @@
 #ifndef _XA_CODES_H_
 #define _XA_CODES_H_
 
-// Standard GEM AES op-codes
+/* Standard GEM AES op-codes*/
 
 #define XA_APPL_INIT	10
+#define XA_APPL_READ	11
+#define XA_APPL_WRITE	12
 #define XA_APPL_FIND	13
 #define XA_APPL_EXIT	19
 #define XA_APPL_GETINFO	130
@@ -78,8 +80,8 @@
 #define XA_SHELL_FIND	124
 #define XA_SHELL_ENVRN	125
 
-// XaAES specific extended op-codes
-// (these all start at 250, well out of the way of standard AES calls)
+/* XaAES specific extended op-codes*/
+/* (these all start at 250, well out of the way of standard AES calls)*/
 #define XA_BUTTON_CLICK	250
 #define XA_NEW_CLIENT	251
 #define XA_CLIENT_EXIT	252
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_defs.h /h/xaaes/xa_defs.h
--- /i/newitems/XaAES.beta2/src/xa_defs.h	Mon Feb 19 14:15:02 1996
+++ /h/xaaes/xa_defs.h	Thu Feb 22 15:44:32 1996
@@ -8,63 +8,65 @@
 #ifndef _XA_DEFS_H_
 #define _XA_DEFS_H_
 
-//-----------------------------------------------------------------
-// COMPILE TIME SWITCHES
-// - define as 1 to turn on, 0 to turn off
-//-----------------------------------------------------------------
-//#define GENERATE_DIAGS		0		// Make the DIAGS macro print out diagnostics
+/*-----------------------------------------------------------------*/
+/* COMPILE TIME SWITCHES*/
+/* - define as 1 to turn on, 0 to turn off*/
+/*-----------------------------------------------------------------*/
+#ifndef GENERATE_DIAGS
+#define GENERATE_DIAGS		0			/* Make the DIAGS macro print out diagnostics*/
+#endif
 
-#define USE_DEBUG_VECTOR		0		// Hook trap3 instead of trap2 to allow debugging under GEM
+#define USE_DEBUG_VECTOR		0		/* Hook trap3 instead of trap2 to allow debugging under GEM*/
 
-#define FORCE_WINDOWS			0		// Force windows to do what the user says instead of just
-										// sending a WM_ message to the client (eg. if a window is topped
-										// do it straight away, and then send the client a message about it)
+#define FORCE_WINDOWS			0		/* Force windows to do what the user says instead of just*/
+										/* sending a WM_ message to the client (eg. if a window is topped*/
+										/* do it straight away, and then send the client a message about it)*/
 
-#define SOLID_BOXES				0		// Do graf_dragbox, graf_rubberbox, etc using a solid box instead of
-										// an outline
+#define SOLID_BOXES				0		/* Do graf_dragbox, graf_rubberbox, etc using a solid box instead of*/
+										/* an outline*/
 
-#define MONO_WIDGETS			0		// Compile with black & white widgets instead of colour ones
+#define MONO_WIDGETS			0		/* Compile with black & white widgets instead of colour ones*/
 
-#define DISPLAY_LOGO_IN_TITLE_BAR	1	// Display the XaAES logo in the title bar of each window
+#define DISPLAY_LOGO_IN_TITLE_BAR	1	/* Display the XaAES logo in the title bar of each window*/
 
-#define POINT_TO_TYPE			1		// 0=Keyboard input goes to topped application
-										// 1=Keyboard input goes to application whose window is pointed at
+#define POINT_TO_TYPE			0		/* 0=Keyboard input goes to topped application*/
+										/* 1=Keyboard input goes to application whose window is pointed at*/
 
-#define ALT_CTRL_APP_OPS		1		// Some ALT+CTRL+key combo's will perform functions relating to
-                       					// the XaAES system
+#define ALT_CTRL_APP_OPS		1		/* Some ALT+CTRL+key combo's will perform functions relating to*/
+                       					/* the XaAES system*/
 
-#define USE_TMALARM				1		// Use the 'un-official' Tmalarm() call to get better timing
+#define USE_TMALARM				1		/* Use the 'un-official' Tmalarm() call to get better timing*/
 
-#define USE_CALL_DIRECT			1		// Bypass the command pipe for certain op-codes
+#define USE_CALL_DIRECT			1		/* Bypass the command pipe for certain op-codes*/
 
-//-----------------------------------------------------------------
-// CONFIGURABLE PARAMETERS
-#define WIDGET_SIZE			20			// Default size of window widgets in pixels (for drawn widgets)
-#define MAX_PID				500			// Max number of client process'
-#define SHOW_LOGO_AT_STARTUP	1		// Run the XaAES logo program at startup
-#define AES_PRIORITY		-20			// The process priority for the XaAES server (-20 is high priority)
+/*-----------------------------------------------------------------*/
+/* CONFIGURABLE PARAMETERS*/
+#define WIDGET_SIZE			20			/* Default size of window widgets in pixels (for drawn widgets)*/
+#define MAX_PID				500			/* Max number of client process'*/
+#define SHOW_LOGO_AT_STARTUP	1		/* Run the XaAES logo program at startup*/
+#define AES_PRIORITY		-20			/* The process priority for the XaAES server (-20 is high priority)*/
 
-#define DU_RSX_CONV 		8			// Resource char to pixel coord conversion constants.
-#define DU_RSY_CONV 		16			// If you are designing your resources in ST-Low res, 
-										//  change DU_RSY_CONV to 8
-#define STANDARD_FONT_POINT	10			// Size of the 'standard' AES font (for window titles, etc)
-#define SMALL_FONT_POINT	8			// Size of the 'small' AES font.
-#define STANDARD_AES_FONTID	1			// Standard GDOS fontid for windows & stuff (set to 1 for no GDOS)
+#define DU_RSX_CONV 		8			/* Resource char to pixel coord conversion constants.*/
+#define DU_RSY_CONV 		16			/* If you are designing your resources in ST-Low res, */
+										/*  change DU_RSY_CONV to 8*/
+#define STANDARD_FONT_POINT	10			/* Size of the 'standard' AES font (for window titles, etc)*/
+#define SMALL_FONT_POINT	8			/* Size of the 'small' AES font.*/
+#define STANDARD_AES_FONTID	1			/* Standard GDOS fontid for windows & stuff (set to 1 for no GDOS)*/
 
-#define GRAF_STEPS			10			// Number of intermediate steps in a graf_growbox(), etc
+#define GRAF_STEPS			10			/* Number of intermediate steps in a graf_growbox(), etc*/
 
-#define PUSH3D_DISTANCE		1			// Distance text on selected (pushed in) 3D objects will move
-#define SHADOW_OFFSET		3			// Offset used for shadowing objects
+#define PUSH3D_DISTANCE		1			/* Distance text on selected (pushed in) 3D objects will move*/
+#define SHADOW_OFFSET		3			/* Offset used for shadowing objects*/
 
-#define PRIVATE_STACK_SIZE	1024		// Size of the private stack allocated for each client
+#define PRIVATE_STACK_SIZE	1024		/* Size of the private stack allocated for each client*/
 
-//-----------------------------------------------------------------
-// VERSION NUMBER
-#define XA_VERSION	"v0.1"				// Version number
-#define XA_AES_VERSION	0x0500			// AES version number we are going to use
+/*-----------------------------------------------------------------*/
+/* VERSION NUMBER*/
+#define XA_VERSION	"v0.1"				/* Version number*/
+#define XA_AES_VERSION	0x0500			/* AES version number we are going to use*/
 
-//-----------------------------------------------------------------
-// General Definitions 
+/*-----------------------------------------------------------------*/
+/* General Definitions */
 #define TRUE	1
 #define FALSE	0
 
@@ -72,8 +74,8 @@
 #define NULL	((void *)0)
 #endif
 
-//-----------------------------------------------------------------
-// Return codes in the clients reply pipe
+/*-----------------------------------------------------------------*/
+/* Return codes in the clients reply pipe*/
 #define XA_OK				0	/* Ok, op-code done */
 #define XA_UNIMPLEMENTED	1	/* Unimpemented but valid op-code */
 #define XA_ILLEGAL			2	/* Illegal op-code */
@@ -81,17 +83,18 @@
 #define XA_M_WAIT			4	/* Re-select for a evnt_multi format timeout */
 #define XA_TVAL			0xfff0	/* Mask to get the timeout value */
 
-//-----------------------------------------------------------------
-// Return codes from op-code service functions
+/*-----------------------------------------------------------------*/
+/* Return codes from op-code service functions*/
 #define XAC_BLOCK			0	/* Block the client indefinitely */
 #define XAC_DONE			1	/* Function completed - release client immediately */
 #define XAC_T_TIMEOUT		2	/* Block client, but timeout (evnt_timer format) */
 #define XAC_M_TIMEOUT		3	/* Block client, but timeout (evnt_multi format) */
 #define XAC_TVAL		0xfff0	/* Mask to get the timeout value */
 
+#ifdef LATTICE
 #if 1
-//-----------------------------------------------------------------
-// Inline functions to store / set Lattice C data pointers
+/*-----------------------------------------------------------------*/
+/* Inline functions to store / set Lattice C data pointers*/
 unsigned long get_a4(void);
 unsigned long get_a6(void);
 unsigned long get_a7(void);
@@ -116,37 +119,39 @@
 #define set_a7(x)
 
 #endif
+#endif /* LATTICE */
 
-//-----------------------------------------------------------------
-// Define the semaphores used in various places....
+/*-----------------------------------------------------------------*/
+/* Define the semaphores used in various places....*/
 
-#define APPL_INIT_SEMAPHORE	'XA:I'		// Semaphore id for appl_init() routine access
-#define TRAP_HANDLER_SEMAPHORE	'XA:H'	// Semaphore for access to part of the trap handler routine
-#define WIN_LIST_SEMAPHORE	'XA:W'		// Semaphore for order modify / entry delete access to the window list
-#define ROOT_SEMAPHORE		'XA:R'		// Semaphore for access to the root window
-#define CLIENTS_SEMAPHORE	'XA:C'		// Semaphore for access to the clients structure
+#define APPL_INIT_SEMAPHORE	'XA:I'		/* Semaphore id for appl_init() routine access*/
+#define TRAP_HANDLER_SEMAPHORE	'XA:H'	/* Semaphore for access to part of the trap handler routine*/
+#define WIN_LIST_SEMAPHORE	'XA:W'		/* Semaphore for order modify / entry delete access to the window list*/
+#define ROOT_SEMAPHORE		'XA:R'		/* Semaphore for access to the root window*/
+#define CLIENTS_SEMAPHORE	'XA:C'		/* Semaphore for access to the clients structure*/
 
-#define UPDATE_LOCK			'XA:U'		// Semaphore id for BEG_UPDATE
-#define MOUSE_LOCK			'XA:M'		// Semaphore id for BEG_MCTRL
+#define UPDATE_LOCK			'XA:U'		/* Semaphore id for BEG_UPDATE*/
+#define MOUSE_LOCK			'XA:M'		/* Semaphore id for BEG_MCTRL*/
 
-//-----------------------------------------------------------------
-// Diagnostics
+/*-----------------------------------------------------------------*/
+/* Diagnostics*/
 #if GENERATE_DIAGS
+#include <stdio.h>
 #define DIAGS(x) printf x
 #else
 #define DIAGS(x)
 #endif
 
-//-----------------------------------------------------------------
-// For debugging, I use trap 3 for XaAES so I can run it in tandem with multiTOS.
+/*-----------------------------------------------------------------*/
+/* For debugging, I use trap 3 for XaAES so I can run it in tandem with multiTOS.*/
 #if USE_DEBUG_VECTOR
 #define AES_TRAP		3
 #else
 #define AES_TRAP		2
 #endif
 
-//-----------------------------------------------------------------
-// Direct call interface enable
+/*-----------------------------------------------------------------*/
+/* Direct call interface enable*/
 #if USE_CALL_DIRECT
 #define CALL_DIRECT(x) Kcall_direct[(x)]=TRUE
 #else
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_globl.h /h/xaaes/xa_globl.h
--- /i/newitems/XaAES.beta2/src/xa_globl.h	Mon Feb 19 13:47:56 1996
+++ /h/xaaes/xa_globl.h	Thu Feb 22 14:41:00 1996
@@ -18,49 +18,51 @@
 	GLOBAL VARIABLES AND DATA STRUCTURES
 */
 
-#define MAX_PID 500						// maximum number of processes we can handle
+#define MAX_PID 500						/* maximum number of processes we can handle*/
 
-extern short AESpid;					// XaAES's MiNT process id.
+extern short AESpid;					/* XaAES's MiNT process id.*/
 
-extern short P_handle,V_handle;			// Workstation handles used by the AES
-extern XA_SCREEN display;			// The display descriptor
+extern short P_handle,V_handle;			/* Workstation handles used by the AES*/
+extern XA_SCREEN display;			/* The display descriptor*/
 
-extern void *super_stack;				// Supervisor mode stack
+extern void *super_stack;				/* Supervisor mode stack*/
 
-extern int AES_in_pipe;				// The AES instruction pipe handle
-extern int AES_in_pipe_clnt;		// The AES instruction pipe handle (client end)
+extern int AES_in_pipe;				/* The AES instruction pipe handle*/
+extern int AES_in_pipe_clnt;		/* The AES instruction pipe handle (client end)*/
 
-extern int MOUSE_in_pipe;			// The MOUSE pipe handle
+extern int MOUSE_in_pipe;			/* The MOUSE pipe handle*/
 
-extern long KBD_device;					// The MiNT keyboard device's file handle
+extern long KBD_device;					/* The MiNT keyboard device's file handle*/
 
-extern short debug_file;				// File handle to dump debug stuff to
+extern short debug_file;				/* File handle to dump debug stuff to*/
 
 extern unsigned long kernal_a4;
 extern unsigned long kernal_a6;
 
-extern XA_WINDOW *window_list;			// The global windows list
-extern XA_WINDOW *root_window;			// The desktop window
+extern XA_WINDOW *window_list;			/* The global windows list*/
+extern XA_WINDOW *root_window;			/* The desktop window*/
 
-extern EVNT_Q *button_event_q;			// Queue of clients waiting on a button event (not used any more)
+extern EVNT_Q *button_event_q;			/* Queue of clients waiting on a button event (not used any more)*/
 
-extern short update_lock;				// wind_update() locks
+extern short update_lock;				/* wind_update() locks...*/
 extern short mouse_lock;
+extern short update_cnt;				/* ...and counters*/
+extern short mouse_cnt;
 
 extern AESPB new_client_pb;
 extern K_CMD_PACKET new_client_packet;
 extern short client_exit_contrl[];
 
-extern char XaAES_home[200];			// XaAES's home location
+extern char XaAES_home[200];			/* XaAES's home location*/
 extern short XaAES_home_drv;
 
-extern char scrap_path[128];			// Clipboard directory path
+extern char scrap_path[128];			/* Clipboard directory path*/
 
-extern void *system_resources;			// Pointer to the XaAES resources
+extern void *system_resources;			/* Pointer to the XaAES resources*/
 
-extern far AESroutine Ktable[300];		// The main AES kernal command jump table
-extern far short Kcall_direct[300];		// array of flags to indicate that routines should be direct called
-extern far XA_CLIENT clients[MAX_PID];	// The main data structure is the clients database
+extern far AESroutine Ktable[300];		/* The main AES kernal command jump table*/
+extern far short Kcall_direct[300];		/* array of flags to indicate that routines should be direct called*/
+extern far XA_CLIENT clients[MAX_PID];	/* The main data structure is the clients database*/
 
 
 #endif
diff -u --recursive --new-file /i/newitems/XaAES.beta2/src/xa_types.h /h/xaaes/xa_types.h
--- /i/newitems/XaAES.beta2/src/xa_types.h	Thu Feb 15 00:27:38 1996
+++ /h/xaaes/xa_types.h	Wed Feb 21 14:19:28 1996
@@ -8,47 +8,59 @@
 #ifndef _XA_TYPES_H_
 #define _XA_TYPES_H_
 #include <VDI.H>
+#ifdef __PUREC__
+typedef struct mfstr
+{
+    int  mf_xhot;
+    int  mf_yhot;
+    int  mf_nplanes;
+    int  mf_fg;
+    int  mf_bg;
+    int  mf_mask[16];
+    int  mf_data[16];
+} MFORM;
+#endif
 #include "K_DEFS.H"
 
-//-----------------------------------------------------------------
-// Display descriptions
+/*-----------------------------------------------------------------*/
+/* Display descriptions*/
 
 typedef enum { D_LOCAL=0, D_TCP=1 } XA_DISPLAY;
 
 typedef struct {
-	short bg_col;			// Colour used for backgrounds
-	short fg_col;			// COlour used for foregrounds
-	short b_r_col;			// Colour used for bottom right 3d edge
-	short t_l_col;			// Colour used for top left 3d edge
-	short border_col;		// Colour used for edging
-	short highlight_col;	// Colour used for highlighting
+	short bg_col;			/* Colour used for backgrounds*/
+	short fg_col;			/* COlour used for foregrounds*/
+	short b_r_col;			/* Colour used for bottom right 3d edge*/
+	short t_l_col;			/* Colour used for top left 3d edge*/
+	short border_col;		/* Colour used for edging*/
+	short highlight_col;	/* Colour used for highlighting*/
 } XA_COLOUR_SCHEME;
 
 typedef struct {
-	short x,y,w,h;				// Screen dimensions
-	short colours;				// number of colours available
-	short planes;				// number of planes in screen
-	XA_DISPLAY display_type;	// The type of display we are using
-	short P_handle;				// VDI physical workstation handle (for D_LOCAL screens)
-	short V_handle;				// VDI virtual workstation handle (for all screens)
-	short c_max_w,c_max_h;		// Maximum character dimensions in pixels
-	short c_min_w,c_min_h;		// Minimum (small font) character dimensions in pixels
-	XA_COLOUR_SCHEME dial_colours;	// Colour scheme used for dialogs
+	short x,y,w,h;				/* Screen dimensions*/
+	short colours;				/* number of colours available*/
+	short planes;				/* number of planes in screen*/
+	XA_DISPLAY display_type;	/* The type of display we are using*/
+	short P_handle;				/* VDI physical workstation handle (for D_LOCAL screens)*/
+	short V_handle;				/* VDI virtual workstation handle (for all screens)*/
+	short c_max_w,c_max_h;		/* Maximum character dimensions in pixels*/
+	short c_min_w,c_min_h;		/* Minimum (small font) character dimensions in pixels*/
+	XA_COLOUR_SCHEME dial_colours;	/* Colour scheme used for dialogs*/
 } XA_SCREEN;
 
-//-----------------------------------------------------------------
-// Client application data structures
+/*-----------------------------------------------------------------*/
+/* Client application data structures*/
 
-// List of Pending AES messages
+/* List of Pending AES messages*/
 typedef struct xa_aesmsg_list {
 	struct xa_aesmsg_list *next;
 	short message[8];
 } XA_AESMSG_LIST;
 
-// Codes for what types of event an app is currently waiting for
-// - I've used the same bit allocation as evnt_multi() here, but there is
-//   the extra XAWAIT_MULTI bit to indicate we are waiting from evnt_multi()
-//   as opposed to one of the individual routines (as return values are different).
+/* Codes for what types of event an app is currently waiting for*/
+/* - I've used the same bit allocation as evnt_multi() here, but there is*/
+/*   the extra XAWAIT_MULTI bit to indicate we are waiting from evnt_multi()*/
+/*   as opposed to one of the individual routines (as return values are different).*/
 #define XAWAIT_KEY		0x01
 #define XAWAIT_BUTTON	0x02
 #define XAWAIT_MOUSE1	0x04
@@ -57,81 +69,81 @@
 #define XAWAIT_TIMER	0x20
 #define XAWAIT_MULTI	128
 
-// Main client application descriptor
+/* Main client application descriptor*/
 typedef struct {
-	int clnt_pipe_rd;		// File handle of the clients internal reply pipe (client end)
-	int clnt_pipe_wr;		// File handle of the clients internal reply pipe (server end)
-	int reply_pipe;			// File handle of the clients external reply pipe
-	XA_AESMSG_LIST *msg;	// Pending AES messages
-	struct xa_pending_widget *widget_active;	// Pending active widget (if any)
-	short waiting_for;		// What types of event(s) the client is waiting for
-	AESPB *waiting_pb;		// Parameter block for whatever the client is waiting for
-	short client_mouse;		// The cursor to use when this is top application
+	int clnt_pipe_rd;		/* File handle of the clients internal reply pipe (client end)*/
+	int clnt_pipe_wr;		/* File handle of the clients internal reply pipe (server end)*/
+	int reply_pipe;			/* File handle of the clients external reply pipe*/
+	XA_AESMSG_LIST *msg;	/* Pending AES messages*/
+	struct xa_pending_widget *widget_active;	/* Pending active widget (if any)*/
+	short waiting_for;		/* What types of event(s) the client is waiting for*/
+	AESPB *waiting_pb;		/* Parameter block for whatever the client is waiting for*/
+	short client_mouse;		/* The cursor to use when this is top application*/
 	MFORM *client_mouse_form;
-	short *globl_ptr;		// Pointer to the client's globl array (so we can fill in the resource
-							//  address field later).
-	void *std_resource;		// Pointer to the client's standard GEM-style single resource file
-	OBJECT *std_menu;		// Pointer to the client's standard GEM-style menu-bar
-	char home_path[150];	// The directory that the client was started in
-	char *cmd_tail;			// The command tail of the process (if launched by shell_write)
-	char *cmd_name;			// The full filename used when launching the process (if launched by shell_write)
-	char name[20];			// The clients 'pretty' name (possibly set by menu_register)
-	char proc_name[9];		// The clients 'official' (ie. used by appl_find) name.
-	short parent;			// Process id of the client's "parent" process (if launched with shell_write)
-	struct xa_window *zen;	// Pointer to a window that could be about to become a dialog
-	void *private_stack;	// Private stack used for call-direct operations
-	void *temp;				// temporary storage
+	short *globl_ptr;		/* Pointer to the client's globl array (so we can fill in the resource*/
+							/*  address field later).*/
+	void *std_resource;		/* Pointer to the client's standard GEM-style single resource file*/
+	OBJECT *std_menu;		/* Pointer to the client's standard GEM-style menu-bar*/
+	char home_path[150];	/* The directory that the client was started in*/
+	char *cmd_tail;			/* The command tail of the process (if launched by shell_write)*/
+	char *cmd_name;			/* The full filename used when launching the process (if launched by shell_write)*/
+	char name[20];			/* The clients 'pretty' name (possibly set by menu_register)*/
+	char proc_name[9];		/* The clients 'official' (ie. used by appl_find) name.*/
+	short parent;			/* Process id of the client's "parent" process (if launched with shell_write)*/
+	struct xa_window *zen;	/* Pointer to a window that could be about to become a dialog*/
+	void *private_stack;	/* Private stack used for call-direct operations*/
+	void *temp;				/* temporary storage*/
 } XA_CLIENT;
 
-//-----------------------------------------------------------------
-// Windows & Widgets
+/*-----------------------------------------------------------------*/
+/* Windows & Widgets*/
 
-// A pointer to a function of the type used for widget behaviours is a 
-//  'WidgetCallback'.
-typedef short (*WidgetCallback)(struct window *wind, struct xa_widget *widg);
-
-// Relative coordinate types
-typedef enum {	RT=0,	// Top right
-				RB=1,	// Bottom right
-				LT=2,	// Top left
-				LB=3,	// Bottom left
-				CT=4,	// Top centred
-				CB=5	// Bottom centred
+/* A pointer to a function of the type used for widget behaviours is a */
+/*  'WidgetCallback'.*/
+typedef short (*WidgetCallback)(struct xa_window *wind, struct xa_widget *widg);
+
+/* Relative coordinate types*/
+typedef enum {	RT=0,	/* Top right*/
+				RB=1,	/* Bottom right*/
+				LT=2,	/* Top left*/
+				LB=3,	/* Bottom left*/
+				CT=4,	/* Top centred*/
+				CB=5	/* Bottom centred*/
 			} XA_RELATIVE;
 
-// Widget positions are defined as relative locations
+/* Widget positions are defined as relative locations*/
 typedef struct {
-	XA_RELATIVE relative_type;	// Where is the position relative to?
-	short x,y;					// position
+	XA_RELATIVE relative_type;	/* Where is the position relative to?*/
+	short x,y;					/* position*/
 } XA_WIDGET_LOCATION;
 
-// Object Tree based widget descriptor
+/* Object Tree based widget descriptor*/
 typedef struct {
-	OBJECT *tree;				// The object tree
-	short is_menu;				// TRUE if this widget is a menu
-	short owner;				// The tree widget would be owned by a different app to
-								// the actual window (like the menu bar on the root window)
+	OBJECT *tree;				/* The object tree*/
+	short is_menu;				/* TRUE if this widget is a menu*/
+	short owner;				/* The tree widget would be owned by a different app to*/
+								/* the actual window (like the menu bar on the root window)*/
 } XA_WIDGET_TREE;
 
-// Widget Callback/Behaviour Identifiers
+/* Widget Callback/Behaviour Identifiers*/
 #define COUNT_XACB		4
 #define XACB_DISPLAY	0
 #define XACB_CLICK		1
 #define XACB_DCLICK		2
 #define XACB_DRAG		3
 
-// Widget Status
+/* Widget Status*/
 typedef enum { XAW_PLAIN=0, XAW_SELECTED=1, XAW_MENUSTATE=2, XAW_TOOLBARSTATE=3 } XA_WIDGET_STATUS;
 
-// Window Widget
+/* Window Widget*/
 typedef struct xa_widget {
-	XA_WIDGET_LOCATION loc;		// Location of widget relative to window extents
-	WidgetCallback behaviour[COUNT_XACB];	// Callback function pointers to the behaviours of the widget
-	XA_WIDGET_STATUS stat;		// Current status (selected, etc)
-	short w,h;					// dimensions
-	short click_x,click_y;		// If we are displaying because we've been clicked on, this is the location 
-								// of the click (this is only used by the slider widget really)
-	void *stuff;				// Pointer to widget dependant context data, if any
+	XA_WIDGET_LOCATION loc;		/* Location of widget relative to window extents*/
+	WidgetCallback behaviour[COUNT_XACB];	/* Callback function pointers to the behaviours of the widget*/
+	XA_WIDGET_STATUS stat;		/* Current status (selected, etc)*/
+	short w,h;					/* dimensions*/
+	short click_x,click_y;		/* If we are displaying because we've been clicked on, this is the location */
+								/* of the click (this is only used by the slider widget really)*/
+	void *stuff;				/* Pointer to widget dependant context data, if any*/
 } XA_WIDGET;
 
 typedef struct xa_widget_list {
@@ -139,17 +151,17 @@
 	struct xa_widget_list *next;
 } XA_WIDGET_LIST;
 
-// Pending action from a widget
+/* Pending action from a widget*/
 typedef struct xa_pending_widget {
 	XA_WIDGET *widg;
 	struct xa_window *wind;
 	WidgetCallback action;
 } XA_PENDING_WIDGET;
 
-// Extra details for a slider widget
+/* Extra details for a slider widget*/
 typedef struct {
-	short position;		// Actual position of the slider (0-1000)
-	short length;		// Length (0-1000)
+	short position;		/* Actual position of the slider (0-1000)*/
+	short length;		/* Length (0-1000)*/
 } XA_SLIDER_WIDGET;
 
 #define ZT_A	1
@@ -157,20 +169,20 @@
 #define ZT_C	3
 #define ZT_D	4
 
-// Rectangle List entry
+/* Rectangle List entry*/
 typedef struct xa_rect_list {
 	struct xa_rect_list *next;
-	short x,y,w,h;			// dimensions of segment
+	short x,y,w,h;			/* dimensions of segment*/
 } XA_RECT_LIST;
 
-// Number of available XA_WIDGET slots in a the window for default/standard widgets
+/* Number of available XA_WIDGET slots in a the window for default/standard widgets*/
 #define XA_MAX_WIDGETS	15
 
-// Widget Index's
+/* Widget Index's*/
 #define XAW_TITLE		0
 #define XAW_CLOSE		1
 #define XAW_FULL		2
-#define XAW_MOVER		3		// Not actually used like the others
+#define XAW_MOVER		3		/* Not actually used like the others*/
 #define XAW_INFO		4
 #define XAW_RESIZE		5
 #define XAW_UP			6
@@ -180,31 +192,31 @@
 #define XAW_RIGHT		10
 #define XAW_HSLIDE		11
 #define XAW_ICONIFY		12
-#define XAW_MENU		13		// Extended XaAES widget
-#define XAW_TOOLBAR		14		// Extended XaAES widget
+#define XAW_MENU		13		/* Extended XaAES widget*/
+#define XAW_TOOLBAR		14		/* Extended XaAES widget*/
 
-// Window Descriptor
+/* Window Descriptor*/
 typedef struct xa_window {
-	struct xa_window *next;	// Window list stuff	- next is the window below
-	struct xa_window *prev;	//						- prev is the window above (both NULL terminated)
-	long active_widgets;	// Summary of the current standard widgets for the window
-	XA_WIDGET widgets[XA_MAX_WIDGETS];	// The windows standard widget set (array for speed)
-	XA_WIDGET_LIST *user_widgets;		// Pointer to a list of user added widgets
-	short x,y,w,h;			// current dimensions
-	short handle;			// Window handle
-	short owner;			// client pid of the window's owner
-	short is_open;			// flag - is the window actually open?
-	short widgets_on_top;	// Number of widgets on the top bar, not including the title
-	XA_RECT_LIST *rect_list;	// The rectangle list for redraws in this window
-	short wx,wy,ww,wh;		// current user work area dimensions
-	short prev_x,prev_y,prev_w,prev_h;	// Previous window coords
-	void *background;		// pointer to a buffer containing the saved background
-	short bgx,bgy;			// location the saved background came from
-	short created_by_FMD_START;	// flag - 1=this window was created by form_dial,
-								// so don't destroy it until the form_dial(FMD_FINISH)
+	struct xa_window *next;	/* Window list stuff	- next is the window below*/
+	struct xa_window *prev;	/*						- prev is the window above (both NULL terminated)*/
+	long active_widgets;	/* Summary of the current standard widgets for the window*/
+	XA_WIDGET widgets[XA_MAX_WIDGETS];	/* The windows standard widget set (array for speed)*/
+	XA_WIDGET_LIST *user_widgets;		/* Pointer to a list of user added widgets*/
+	short x,y,w,h;			/* current dimensions*/
+	short handle;			/* Window handle*/
+	short owner;			/* client pid of the window's owner*/
+	short is_open;			/* flag - is the window actually open?*/
+	short widgets_on_top;	/* Number of widgets on the top bar, not including the title*/
+	XA_RECT_LIST *rect_list;	/* The rectangle list for redraws in this window*/
+	short wx,wy,ww,wh;		/* current user work area dimensions*/
+	short prev_x,prev_y,prev_w,prev_h;	/* Previous window coords*/
+	void *background;		/* pointer to a buffer containing the saved background*/
+	short bgx,bgy;			/* location the saved background came from*/
+	short created_by_FMD_START;	/* flag - 1=this window was created by form_dial,*/
+								/* so don't destroy it until the form_dial(FMD_FINISH)*/
 } XA_WINDOW;
 
-//------------------------------------------------------------------
+/*------------------------------------------------------------------*/
 
 #define TRUE	1
 #define FALSE	0
