!raw [stg] @subject "Programmieren/C"

!code_source [tos]
!language german

!docinfo [title] Die Anleitung zu
!docinfo [program]    SysGem
!docinfo [version]    Version 2.51
!docinfo [date]    (!today)
!docinfo [author] Andreas Pietsch
!docinfo [stgdatabase] SysGem V2.51

########################################
# Schalter setzen
########################################
!use_compressed_tocs		[stg,win,html,pch]
!use_auto_subtocs		    [stg,win,html,pch]
!use_auto_subsubtocs	  [stg,win,html,pch]
!use_auto_subsubsubtocs	[stg,win,html,pch]
!use_nodes_inside_index [win, stg]
!use_label_inside_index [win, stg]
!no_effects				      [asc]
!image_alignment        [center]

!begin_document

!maketitle
!tableofcontents

!ifndest [pch]

!node SysGem 2.02

Willkommen zu SysGem V2.02. Es hat zwar fast schon ewig gedauert,
aber endlich ist sie da. Wenn man bedenkt, daû ich sie eigentlich
schon Weihnachten '94 fertig haben wollte... Aber wie es halt so ist,
erstens kommt es anders und zweitens als man denkt.

!endif

!node Einleitung

SysGem ist eine einfach zu bedienende und vor allem einfach zu handha-
bende GEM-Library. SysGem wurde entwickelt, um Programme schnell und
vor allem einfach GEM-konform entwickeln zu kînnen, ohne sich mit der
GEM-Programmierung auskennen zu mÅssen.

Diesem Gedanken trÑgt auch das Konzept von SysGem Rechnung: Es arbei-
tet fast ausschlieûlich mit Call-Back-Routinen, die es ermîglichen,
wirklich nur das Programmieren zu mÅssen, was auch wirklich fÅr das
Programm notwendig ist. öberflÅssige Arbeit und auch Ballast bleiben
dabei auûen vor.

Bei einem neuen Programm mÅssen Sie immer alles im Programm selbst
abfragen, z. B. ob die Maus gedrÅckt wurde, ob der Benutzer eine
Taste gedrÅckt hat, ob ein Drag&Drop ausgefÅhrt wurde usw.

SysGem arbeitet dabei vîllig ereignisorientiert: Wenn Sie einen Fen-
sterdialog geîffnet haben, und der Benutzer wÑhlt einen Button aus,
so teilt SysGem dieses Ihrem Programm mit. Sie reagieren dann nur
noch auf dieses Ereignis; wie, das legen Sie in Ihrem Programm fest.
Um so triviale Dinge wie Fenster verschieben, scrollen, Shortcut-Aus-
wertung usw. brauchen Sie sich in Ihrem Programm nicht mehr zu
kÅmmern.


!ifndest [pch]

!node énderungen

!subnode énderungen in der 2.02

!begin_enumerate
  !item Radio- und Selectable-Buttons werden nun bei 'verstellten' 3D-
     Farben nicht mehr in Grau, sondern in der jeweiligen Hintergrund-
     farbe gezeichnet (Thorsten Bergner)

  !item Die Sliderboxen kînnen nun Åber beliebig viele selektierbare Ein-
     trÑge verfÅgen. Siehe dazu auch bei xLinkSlider und/oder/auch
     xListbox (Dirk Hagedorn / Reiner Rosin)

  !item Ein Fenster kann jetzt mit ReSizeWindow auch vom Programm aus in
     seiner Grîûe und Position verÑndert werden

  !item FÅr besondere FÑlle kînnen die Slider bei Sliderboxen mit
     RedrawTheSlider neugezeichnet werden (Dirk Hagedorn)

  !item öberflÅssige Redraws bei Sliderboxen werden nun abgefangen

  !item SetText schneidet nun bei der MaximallÑnge des Textes ab. Bei
     CTRL-V konnte sonst der Dialog Åberschrieben werden -> Bumm!

  !item Parameter-énderung bei crc_16 und crc_32

  !item Fenster kînnen nun auch im iconifizierten Zustand geîffnet wer-
     den. Siehe dazu unter SG_OPENICONIFIED und SG_ICONIFY (Reiner
     Rosin) Dank auch an Dirk Haun!

  !item Redrawproblem bei Log-Fenstern ist behoben (Rayko Balun)

 !item Routinen zum Laden, Speichern und Verwaltung einer Config-Datei
     eingebaut. Siehe dazu unter "Das Config". (Rayko Balun)

 !item MenÅzeilen in Fenstern werden nun auch in 3D gezeichnet

 !item Bei den Circlebuttons gibt es nun die Nachricht SG_LCIRCLE
     (Linksklick) und SG_RCIRCLE (Rechtsklick), mit der zwischen
     Popup und BlÑttern unterschieden werden kann

 !item Der Cursor in Editfeldern kann jetzt mit der Maus zeichengenau
     positioniert werden. Ebenso wird jetzt Shift-Cursor-Left und
     Shift-Cursor-Right unterstÅtzt (Dirk Hagedorn)

 !item DispatchEvents ist wieder drin (Dirk Hagedorn)

 !item Neue Nachricht bei den Sliderboxen: SG_EMPTYSLDLINE

 !item Neue Nachricht bei den Editfeldern: SG_LASTEDIT

 !item Neue Nachricht bei den Dialogen: SG_TOUCH

 !item SG_RCLICK1 und SG_RCLICK2 sind wieder vorhanden

 !item Das Problem beim Versenden von SG_TOP und SG_UNTOP sollte nun
     behoben sein

 !item Kam ein Event dazwischen, lieferte SG_NEXTSTART nur MÅll (im
     oberen Wort) (Dirk Hagedorn)

 !item Bei Popups und Listboxen wurde immer der gewÑhlte Eintrag fett
     gezeichnet (Harald Blees)

 !item Das Problem mit dem Ermitteln des Systemzeichensatzes sollte
     behoben sein (hoffe ich zumindest...) (Rayko Balun)

 !item Stand in einem Editfeld der Cursor irgendwo vorne und war das
     Editfeld voll, so wurde ein Buchstabe immer nur an das Ende ange-
     hÑngt. Behoben.

 !item Man kann SysGem jetzt auch Events "unterjubeln". Siehe dazu
     unter TakeEvent.

 !item Unter Winx wurde immer der kleine System-Font eingestellt, was
     Ñuûerst eichelwÅrzig aussah...

 !item Die Modulschnittstelle von SysGem ist drin.

 !item Berechnung der Spalten und Zeilen funktionieren jetzt bei Text-
     fenstern und Tabulatoren und Proportionalfonts...

 !item Die Funktionen UseWindowSlider, UseWindowMenu und InitMenuLine
     sind ersatzlos entfallen. Die Lib Åbernimmt nun die notwendigen
     Initialisierungen von selbst.

 !item Eine Listbox kann jetzt auch frei auf dem Bildschirm plaziert
     werden.

 !item Die Echtzeitslider sind drin. Viel Spaû...

 !item Neue Funktionen:

     SysGemVerStr, SetReturn, SetUnknownEvent, SetLanguage,
     SetLinkIconColor, SetLinkTextColor, xSetLineIcon, GetLineHeight,
     xLinkSlider, RedrawTheSlider, GetSliderItems, ReSizeWindow,
     xListbox, TakeEvent, DispatchEvents, CountKeywords, SetConfig,
     GetConfigPtr, GetConfig, DelConfig, SaveConfig, LoadConfig,
     SetTextColor, AskModule, ModulAvail, SetModulePath,
     StartSysGemModul, LoadSysGemModul, TermSysGemModul,
     GetModuleInfo, GetFontName, UpdListTab, UpdSliderTab, BeginHelp,
     EndHelp, EnableHelp, DisableHelp, SetHelpTime, SetHelpColor,
     xdo_qsort, GetTabPosition, ShowStatus, EndStatus, xWindowDialog,
     UnLinkTree, CalcArea, CalcWinTrees, CheckWindow, CountWindows,
     FastDrawSldBox, OpenTextWindow, GetWindowFont

 !item Neue Nachrichten:

     SG_OPENICONIFIED, SG_LCIRCLE, SG_RCIRCLE, SG_TOUCH, SG_RCLICK1,
     SG_RCLICK2, SG_EMPTYSLDLINE, SG_LASTEDIT, SG_EDITABLE,
     SG_BEGINHELP, SG_ENDHELP

 !item Neue Nachrichten fÅr die Module:

     Der Aufbau eines Moduls. Der Aufbau eines Moduls, Der Aufbau eines Moduls, Der Aufbau eines Moduls, Der Aufbau eines Moduls
!end_enumerate

!subnode énderungen in der 2.03 [beta]
!begin_enumerate

  !item Bei den "Balken" mit Erw. Typ 51 (siehe ShowStatus) wird jetzt
     die Prozentzahl in Farbe immer in Schwarz ausgegeben, es sei
     denn, die Balkenfarbe wÑre schwarz, dann wird wie Åblich
     invertiert. (Thorsten Bergner)
  
  !item MenÅeintrÑge mit CHECKED-Status haben ihren Haken wieder...
     (Dirk Hagedorn)
     
  !item Log-Fenster Ñndern jetzt simultan mit der Gemini-Console ihren
     Font. Dieses Feature ist Åber CheckLogFont konfigurierbar.

  !item CycleWindow schickt jetzt an Gemini (sofern vorhanden) die 
     Nachricht zum Fensterwechsel. So kann durch alle vorhandenen
     Applikationen gescrollt werden. (Christoph Spengler)
     
 !item Die Speicherverwaltung puffert nun in der Spezialversion die
     LÑnge der einzelnen Blîcke und stellt sie dem Debug-Modul zur
     VerfÅgung.

  !item Da es wohl mit irgendeinem Server Probleme gab, meldet SysGem
     sich bei Gemini jetzt mit AV_EXIT korrekt wieder ab.
     (Christoph Spengler / Holger Weets)
     
 !item Debug-Funktion fÅr die Module eingebaut (ENTER/LEAVE)

 !item Z-Modem-Routinen an den neuen Redraw-Dispatcher angepasst.
     
  !item In der Struktur FUNCTIONS wurden die Funktionen GetTabPosition
     und GetWindowFont falsch initialisiert. (Jens Fellmuth)
     
 !item Durch einen netten kleinen Bug erhielt das zu îffnende Fenster
     die Nachricht SG_UNTOP, und nicht das Fenster, welches in den
     Hintergrund gelegt wurde...
     (Rudi Sigl)

!end_enumerate

!subnode énderungen in der 2.50 [beta]
!begin_enumerate

	!item CloseAllWindows hat einen neue Parameter bekommen.
	
	!item Auch bei MultipleDialog kann man jetzt eine MenÅzeile
				anmelden.
				
	!item Nach dem Laden von Modulen werden die CPU Caches gelîscht.
				Wichtig bei 68040 und hîher.
				
	!item Im Dialog von ShowStatus kann man zusÑtzlich eine
				Textzeile ("Abbruch mit ESC") einblenden.
				
	!item Bei den Nachrichten SG_LCLICK1, SG_LCLICK2
				SG_RCLICK1, SG_RCLICK2 und SG_TOUCH wird nun der
				Status der Sondertasten zurÅckgeliefert.
				
	!item MPROC so erweitert, daû ein Zeiger auf die Message
				geliefert wird (SetDeskTopMenu).
			
	!item ScrollWindow um die Funktionen SCROLL_HOME und
				SCROLL_SHIFT_HOME erweitert.

	!item FileSelect benutzt wenn mîgliche eine externe Dateiauswahl.
				Steht keine zur VerfÅgung wird versucht die von MagiC
				zu benutzen. Erst dann wir die vom TOS benutzt.

	!item SetLineFlags: neuer öbergabewert von Flags (-2).

	!item Falls die MenÅzeile (Titel) komplett disable wird, ist
				wird spÑter wieder der ursprungszustand hergestellt.

	!item RedrawWindow bei der öbergabe von -1 werden alle
				Fenster neugezeichnet.

	!item Dateifunktionen: FileExists, PathExists, GetPath, SetPath,
	       SplitFilename, SplitExtension, SetExtension, MakeNormalPath,
	       MakeShortPath

	!item Neue Funktionen:
	
				DebugConfigInt, SetObjTextColor, GetObjTextColor, GetObjColor,
				GetSelectSldItem, ChangeDialog, SetInt, SetLong, SetULong, 
				GetInt, GetLong, SetBoxChar, GetBoxChar, RedrawWindowById
				
	!item Neue Nachrichten:
	
				SG_SILDERMOVE
				
!end_enumerate

!subnode énderungen in der 2.51 [beta]
!begin_enumerate

!item In CalcArea wird bei der Breite berÅcksichtigt das
		  das bei einem Radio- und Select-Button etwas vor dem
			Text steht.

!item get_mch erkennt nun auch den Milan und ARAnyM.

!item Neue Funktionen SetFirstLine

!item SysGemVerStr liefert auf Anforderung auch das Erstellungsdatum

!item xLinkList, xAddToList und xInsInList mit zusÑtzlichen Parameter
      versehen, daû man sofort den Effekt einstellen kann.

!item Erkennung des AV-Server verbessert. RÅckgabe der ID des AV-Server
      in der PARAMETER-Struktur.

!end_enumerate


!endif


!node An- und Abmelden vom System

Bevor Sie irgendwelche Funktionen von SysGem benutzen kînnen, mÅssen
Sie die Lib erstmal initialisieren, also erst einmal den "Start-
Knopf" drÅcken. Dies geschieht mit einem Aufruf der Funktion InitGem.

Die Funktion ExitGem muû beim Beenden des Programms aufgerufen wer-
den, nÑmlich dann, wenn (!B)keine(!b) Funktionen von SysGem mehr benîtigt wer-
den.

Hier mal eine kleine FunktionsÅbersicht:


!subnode InitGem

INT InitGem ( BYTE *acc, LONG prg_id, BYTE *prg_name );


Initialisiert SysGem und meldet das Programm beim AES an. Dabei
ermittelt die Funktion noch die Umgebung. Die Einzelheiten der Umge-
bung, in der Ihr Programm lÑuft, kînnen dann von Ihnen mit den Routi-
nen GetParStruct oder GetParam abgefragt werden.

Parameter:
!begin_xlist [xxxxxxxxxxxx]
 !item [acc]         ist ein Zeiger auf einen String, der den Programmnamen
             fÅr ein Acc enthÑlt, also der Name, der unter dem DESK-
             Eintrag in der MenÅzeile zu lesen ist, wenn das Programm
             als Acc gestartet wurde.

             Wollen Sie von vornherein eine Nutzung via Acc (!U)unterbin!-den(!u),
						 Åbergeben Sie einfach einen Leerstring.

 !item [prg_id]      ist eine 4Byte Konstante, die fÅr mehrere Dinge benutzt
             wird. Einerseits dient sie zur Identifizierung von
             Prozessen unter Bruno96, andererseits wird sie zur
             Kennung in Fenstern unter Multitasking-Systemen benutzt.
             Weitere Informationen entnehmen Sie bitte der Funktion
             SetWindowName.

             Hinweis: Die Id darf nicht 0L sein!

 !item [prg_name]    Siehe auch unter prg_id. Der Name dient nur einer nach-
            trÑglichen Klassifizierung des Programms und wird von
            einigen Funktionen benutzt. Es darf (!B)kein(!b) Leerstring
			an!-ge!-geben werden. (!nl)
			Der Name wird beim Anmelden des Programm beim AV Server genutzt.
!end_xlist
RÅckgabe:

Die Funktion liefert einen Wert > 0, wenn alles glatt ging. Bei allen
anderen RÅckgabewerten (!B)muû(!b) das Programm terminieren. Sollten Sie es
doch weiterlaufen lassen, geschieht dies auf Ihre eigene Gefahr!


!subnode GetParStruct

VOID GetParStruct ( PARAMETER *par );


Diese Funktion liefert Informationen Åber die System-Umgebung in
einer Struktur zurÅck. FÅr den Fall, daû Sie nur einzelne Werte zur
Laufzeit brauchen, gibt es noch die Funktion GetParam.

Dies PARAMETER-Struktur hat folgenden Aufbau:
!begin_verbatim
typedef struct
  {
    INT         vdi_handle;
    INT         charw;
    INT         charh;
    INT         boxw;
    INT         boxh;
    INT         appl_id;
    INT         xmax;
    INT         ymax;
    RECT        desktop;
    INT         bitplanes;
    INT         max_colors;
    INT         act_colors;
    BOOL        color_avail;
    INT         acc_entry;
    BOOL        multitask;
    INT         aes_version;
    UINT        tos_version;
    INT         magx;
    INT         magx_rel;
    INT         mint;
    BOOL        winx;
    BOOL        search;
    INT         agi;
    INT         AVServer;
    INT         icfs;
    INT         backcol;
    INT         acticol;
    INT         syspt;
  } PARAMETER;
!end_verbatim
Die einzelnen Elemente:
!begin_xlist [xxxxxxxxxxxx]
!item [vdi_handle]     EnthÑlt das Handle der VDI-Workstation, die fÅr Ihr
                Programm erîffnet wurde. Wenn Sie in Ihrem Programm
                Ausgaben Åber das VDI machen wollen, sollten Sie
                'vdi_handle' Åbergeben. Dieser Wert lÑût sich auch
                Åber GetParam mit PAR_HANDLE erfragen.

 !item [charw]          EnthÑlt die Breite eines Zeichens in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_CHARW
                erfragen.

 !item [charh]          EnthÑlt die Hîhe eines Zeichens in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_CHARH
                erfragen.

 !item [boxw]           EnthÑlt die Breite einer Zeichenbox in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_BOXW
                erfragen.

 !item [boxh]           EnthÑlt die Hîhe eines Zeichenbox in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_BOXH
                erfragen.

 !item [appl_id]        EnthÑlt die Identifikationsnummer, welches das AES
                Ihrem Programm zugeordnet hat. Dieser Wert lÑût sich
                auch Åber GetParam mit PAR_APPLID erfragen.

 !item [xmax]           EnthÑlt die Breite des Bildschirms in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_XMAX
                erfragen.

 !item [ymax]           EnthÑlt die Hîhe des Bildschirms in Pixeln. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_YMAX
                erfragen.

 !item [desktop]        ist eine RECT-Struktur und enthÑlt die Ausmaûe des
                Desktops, auf dem Sie zeichnen dÅrfen, also abzÅglich
                der MenÅzeile. Die vier einzelnen Werte lassen sich
                auch Åber GetParam mit PAR_DESKX, PAR_DESKY,
                PAR_DESKW und PAR_DESKH erfragen.

 !item [aes_version]    enthÑlt die Versionsnummer des AES. Einige Funktionen
                des AES stehen z. B. erst ab einer bestimmten Ver-
                sionsnummer zur VerfÅgung. Die Versionsnummer wird
                dabei in Hex zurÅckgegeben. 0x0399 wÅrde also eine
                Version 3.99 bedeuten. Dieser Wert lÑût sich auch
                Åber GetParam mit PAR_VAES erfragen.

 !item [tos_version]    enthÑlt die Versionsnummer des TOS. Die Versionsnum-
                mer wird in Hex zurÅckgegeben. 0x0205 wÅrde also eine
                Version 2.05 bedeuten. Dieser Wert lÑût sich auch
                Åber GetParam mit PAR_VTOS erfragen.

 !item [bitplanes]      gibt an, wieviel Bit pro Pixel zur Farbdarstellung
                benutzt werden. Dieser Wert lÑût sich auch Åber
                GetParam mit PAR_BITPLANES erfragen.

 !item [max_colors]     gibt die Anzahl der verfÅgbaren Farben an. Eine 0
                besagt, dass True-Color verfÅgbar ist. Dieser Wert
                lÑût sich auch Åber GetParam mit PAR_MAXCOLOR
                erfragen.

 !item [act_colors]     gibt die Anzahl der Farben an, die gleichzeitig aus
                einer Tabelle von 'max_colors' Farben dargestellt wer-
                den kînnen. Dieser Wert lÑût sich auch Åber GetParam
                mit PAR_ACTCOLOR erfragen.

 !item [color_avail]    ist TRUE, wenn mehr als 2 Farben verfÅgbar sind.
                Dieser Wert lÑût sich auch Åber GetParam mit
                PAR_COLOR erfragen.

 !item [acc_entry]      hat den Wert -2 wenn Ihr Programm als Programm gestar-
                tet wurde. Sie hat einen Wert grîsser -1, wenn Ihr
                Programm als ACC gestartet wurde und den Wert -1,
                wenn wÑhrend der Initialisierung was schief ging, z.
                B. kein ACC-Slot mehr frei war. Dieser Wert lÑût sich
                auch Åber GetParam mit PAR_ACCENTRY erfragen.

                Beachten Sie, daû Sie im Falle eines ACC's die Funk-
                tion SetAccProc benutzen mÅssen!

 !item [multitask]      Ist TRUE, wenn das System in einer Multitasking- Umge-
                bung lÑuft, FALSE sonst. Dieser Wert lÑût sich auch
                Åber GetParam mit PAR_MULTI erfragen.

 !item [magx]           EnthÑlt die Versionsnummer von Mag!C oder 0, wenn
                Mag!C nicht installiert ist. Dieser Wert lÑût sich
                auch Åber GetParam mit PAR_VMAGX erfragen.

 !item [magx_rel]       EnthÑlt die Releasenummer von Mag!C oder 0, wenn
                Mag!C nicht installiert ist. Dieser Wert lÑût sich
                auch Åber GetParam mit PAR_RMAGX erfragen.

 !item [mint]           EnthÑlt die Versionsnummer von MiNT oder 0, wenn MiNT
                nicht installiert ist. Dieser Wert lÑût sich auch
                Åber GetParam mit PAR_MINT erfragen.

 !item [winx]           Ist TRUE, wenn Winx >= 2.2 installiert ist. Dieser
                Wert lÑût sich auch Åber GetParam mit PAR_WINX
                erfragen.

 !item [search]         Ist TRUE, wenn appl_search vorhanden ist. Dieser Wert
                lÑût sich auch Åber GetParam mit PAR_SEARCH erfragen.

 !item [agi]            Hat folgende Werte:

                AGI_0 appl_getinfo ist nicht vorhanden

                AGI_3 appl_getinfo nur bis Par. 3.

                AGI_4 appl_getinfo kann voll genutzt werden.

                Dieser Wert lÑût sich auch Åber GetParam mit PAR_AGI
                erfragen.

 !item [AVServer]   EnthÑlt die AES ID des AV Server oder -1.

 !item [icfs]           Liefert die Versionsnummer von (!xlink [ICFS] [ICFS.HYP/Titel]),
                ansonsten den  Wert 0. Dieser Wert lÑût sich auch Åber GetParam mit
                PAR_ICFS erfragen.

 !item [backcol]        Farbe des 3D Hintergrund

 !item [acticol]        Farbe nicht-selektierter Aktivatoren
 
 !item [syspt]          Fronthîhe des normalen AES-Zeichensatz
!end_xlist

!subnode GetParam

INT GetParam ( INT param );


WÑhrend die Funktion GetParStruct immer eine ganze Struktur Åber die
Systemumgebung zurÅckliefert, kann es an manchen Stellen wÅnschens-
wert sein, lediglich einen Wert abzufragen. Diesen Wunsch erfÅllt
Ihnen die obige Funktion.

'param' ist dabei die Konstante, die bei GetParStruct und dem ent-
sprechenden Element beschrieben ist.


!subnode SysGemVersion

UINT SysGemVersion ( VOID );


Liefert die Versionsnummer von SysGem in Hex zurÅck. Ein Wert von
0x0202 wÅrde also der Version 2.02 entsprechen.


!subnode SysGemVerStr

BYTE *SysGemVerStr ( INT i );

!begin_xlist [xx]
 !item [i]  = 0  Zeiger auf den Versions(!U)string(!u) von
SysGem. Der String ist incl. Nullbyte 12 Zeichen lang. (!nl)
            = 1  Erstellungsdatum von SysGem.
!end_xlist

Diese Funktion liefert einen Zeiger auf den Versions(!U)string(!u) von
SysGem. Der String ist incl. Nullbyte 12 Zeichen lang.

Siehe auch: SysGemVersion


!subnode SetKey

VOID SetKey ( LONG l1, LONG l2 );


SysGem ist KeyWare! Das heisst, Sie kînnen SysGem ohne irgendwelche
EinschrÑnkungen nutzen. Jedoch erscheint sporadisch eine Meldung, die
Sie daran erinnern soll, den Obulus zu entrichten.

FÅr 40 DM, die Sie bitte an den Autor richten, erhalten Sie einen
SchlÅssel fÅr SysGem, der die Registriermeldung nicht mehr erscheinen
lÑsst.

Wenn Sie schon fÅr die 1.x registriert sind, kînnen Sie fÅr 20 DM auf
die 2.0x updaten.

Dieser SchlÅssel besteht aus 2 Zahlen, die Sie dann jeweils bei 'l1'
und 'l2' angeben.


!subnode SetAccProc

typedef VOID    ( *TPROC )( VOID );

VOID SetAccProc ( TPROC acc_open, TPROC acc_close );


Wurde Ihr Programm als Accessory gestartet und klickt der Benutzer
den Acc-Eintrag an, wird die unter 'acc_open' angegebene Routine auf-
gerufen.

Die Funktion 'acc_close' wird nur dann angesprungen, wenn GEM dazu
den Befehl gibt. In diesem Fall schliesst SysGem (!B)alle(!b) Fenster des
ACC's, bevor die unter 'acc_close' angegebene Funktion aufgerufen
wird.

FÅr nicht benîtigte Funktionen kann auch NULL Åbergeben werden.

Eine Initialisierung fÅr ein Programm, das sowohl als ACC als auch
als Programm laufen soll, wÅrde also etwa folgendermaûen aussehen:

!begin_verbatim
VOID PrgOpen ( VOID )

{
  /* Hauptfenster îffnen */
}

/* main */
...
if ( InitGem ( "Acc-Name", "Programmname", 'PRID' ) > 0 )
  {
    SetKey ( ..., ... );
    if ( GetParam ( PAR_ACCENTRY ) != -2 )
      {
        /* Programm ist ein ACC */
        SetAccProc ( PrgOpen, PrgCose );
      }
    else
      {
        /* Ein normales Programm */
        PrgOpen ();
      }
    HandleSysGem ();
    ExitGem ();
  }
...
!end_verbatim


!subnode ExitGem

VOID ExitGem ( VOID );


Die Funktion ExitGem muû beim Beenden des Programms aufgerufen wer-
den, nÑmlich dann, wenn (!B)keine(!b) Funktionen von SysGem mehr benîtigt wer-
den. Die Funktion gibt den fÅr die Lib reservierten Speicher wieder
frei und meldet das Programm beim AES wieder ab.

Es dÅrfen dann keine Routinen von SysGem mehr aufgerufen werden!


!subnode TakeEvent

!begin_verbatim
VOID TakeEvent ( INT event, INT x, INT y, INT state, INT kstate,
                 INT key, INT clicks, INT *msg );
!end_verbatim

Durch TakeEvent ist es mîglich, SysGem irgendwelche Events
"unterzujubeln". Dies kann ein Tastendruck, ein Redraw, oder sonst
irgendwas sein. Die Mîglichkeiten sind dabei nicht begrenzt...

!begin_xlist [xxxxxxxxxxxx]
 !item [event]     ist das Bit, das angibt, um welchen Event (MU_BUTTON o.Ñ.)
           es sich handelt, der simuliert werden soll.

 !item [x, y]      sumulierte Mauskoordinaten

 !item [state]     der simulierte Mausstatus

 !item [kstate]    der Status der Sondertasten

 !item [key]       der Scancode der Taste (im GEM-Format, nicht NKCC!)

 !item [clicks]    die Anzahl der Mausklicks

 !item [msg]       Zeiger auf ein INT-Array mit 8 Elementen, dem
           Messagebuffer, der ausgewertet werden soll.
!end_xlist

FÅr nicht benîtigte Werte kînnen Phantomwerte Åbergeben werden; sie
werden dann eh ignoriert.


!subnode DispatchEvents

VOID DispatchEvents ( VOID );


Diese Funktion springt kurz in die Message-Verwaltung von SysGem und
schaut nach, ob irgendwelche Events zur Verarbeitung anliegen. Diese
Funktion eignet sich hervorragend dazu, um in langen Berechnungen ab
und zu aufgerufen zu werden, um das Programm bedienbar zu halten.

!subnode SetProcEvent

typedef VOID ( *TPROC )( VOID );

VOID SetProcEvent ( TPROC proc );


Diese Funktion meldet eine eigen Funtkion an. Dies wird aufgrufen,
nachdem die Message-Verwaltung von SysGem durchlaufen wurde.

!node Die Programmkontrolle

SysGem bietet noch ein paar Funktionen, mit denen sich der Pro-
grammfluû gezielt beeinfluûen lÑût, als da wÑren:


!subnode HandleSysGem

VOID HandleSysGem ( VOID );


HandleSysGem ist die wichtigste Funktion Åberhaupt in der Lib. Bei
ihrem Aufruf Åbernimmt die Funktion die gesamte Programmkontrolle.

HandleSysGem empfÑngt alle Nachrichten vom AES, verwaltet diese
zusammen mit den Timern, Mausklicks, TastendrÅcken und Benutzer-
aktivitÑten und steuert das Zusammenspiel der einzelnen Handlerfunk-
tionen.

Sie kînnen sich HandleSysGem auch als eine Endlosschleife vorstellen,
die erst dann verlassen wird, wenn das Programm sich beenden soll.

HandleSysGem muû (und darf nur) einmal aufgerufen werden.

Beispiel (aus dem Demo):

!begin_verbatim
INT main ( VOID )

{
  if ( InitGem ( "", 'demo', "Demo" ) > 0 )
    {
      UseOwnEditFields ();
      SetKey ( 0L, 0L );

      if ( LoadResource ( ..., FALSE ) >= 0 )
        {
          rsc_button    = RscAdr ( R_TREE, ... );

          NewDialog ( rsc_button  );

          if ( WindowDialog ( 'main', -1, -1, "|SysGem-Demo", "", TRUE,
               FALSE, rsc_main, NULL, -2, NULL, HandleMain ))
            {
              /* -----------------------------------------------------
               * Die Kontrolle an SysGem abgeben...
               * ----------------------------------------------------- */

              HandleSysGem ();
            }
        }
      else
        {
          Alert ( ALERT_NORM, 1, "[3][ Resource-Datei nicht gefunden! ][
                  [Abbruch ]" );
        }

      /* -------------------------------------------------------------
       * ...und wieder abmelden
       * ------------------------------------------------------------- */

      ExitGem ();
    }
  return ( 0 );
}
!end_verbatim
HandleSysGem wird erst dann beendet, wenn eine Handlerfunktion
SG_TERM zurÅckliefert, oder Sie selbst TerminateSysGem aufrufen.

Schematisch kann man sich den Programmfluû so vorstellen:

!begin_verbatim
INT main ( VOID )
  {
    InitGem ( ... );

    <Alles, was fÅr die Initialisierung des Programms notwendig ist>

    <Hauptfenster îffnen>

    HandleSysGem ();

    <Alles, was am Programmende gemacht wird>

    ExitGem ();
  }
!end_verbatim

!subnode TerminateSysGem

INT TerminateSysGem ( VOID );


Diese Funktion bewirkt, daû sich die Funktion HandleSysGem beenden
soll. TerminateSysGem wird immer dann aufgerufen, wenn sich das Pro!-gramm
selbst beenden will, z. B. wenn der Benutzer in der MenÅzeile
"Quit" anklickt.


!subnode SearchProgram

INT SearchProgram ( BYTE *name );


Diese Funktion sucht das Programm mit dem Namen 'name' und liefert
die Applikation-Id des Programms zurÅck, wenn es gefunden wurde, -1
sonst.


!subnode Alert

INT Alert ( INT priority, INT default, BYTE *text );


Diese Funktion stellt eine normale Alertbox dar, allerdings im Fen-
ster, wie hier:


!image IMG414.IMG Eine einfache Alertbox

Das Beispiel auf dem Bild oben wurde so erzeugt:
!begin_verbatim
button = Alert ( ALERT_NORM, 1, "[2][ Wirklich beenden?][ [Ja | [Nein]" );
  |                  |       |    |  ------------------  ------------
  |                  |       |    |          |                |
  +------ Ergebnis   |       |    |          |                |
                     |       |    |          |                |
  'PrioritÑt' -------+       |    |          |                |
                             |    |          |                |
  Default-Button ------------+    |          |                |
                                  |          |                |
  Das zu verwendende Icon --------+          |                |
                                             |                |
  Der eigentliche Text der Alertbox ---------+                |
                                                              |
  Der Text der einzelnen Buttons -----------------------------+
!end_verbatim

FÅr das Icon gilt:

1 = Ausrufezeichen (!nl)
2 = Fragezeichen (!nl)
3 = Stop-Schild

Die Parameter:
!begin_xlist [priority   ]
 !item [priority]   ist ein Flag, das angibt, wie sich die Alertbox zu den
            anderen Fenstern verhalten soll:

            (!B)ALERT_NORM(!b)

            Normales Fenster. Die Hintergrundprozesse kînnen bedient
            werden.

            (!B)ALERT_STOP(!b)

            Nur die Alertbox kann bedient werden, nichts anderes!

 !item [default]    ist die Nummer des Buttons, der als Default gelten soll
            (mit der RETURN-Taste anwÑhlbar / dicker umrandet). Dabei
            beginnt die ZÑhlung von links nach rechts mit 1.

            öbergeben Sie eine 0, ist keiner der Buttons Default.

 !item [text]       ist der Text, der in der Alertbox dargestellt werden
            soll. Die einzelnen Zeilen sind dabei mit '|' getrennt
            und der gesamte Text muû mit '[' und ']' geklammert sein.
!end_xlist
Der Text darf aus maximal 16 Zeilen mit maximal 55 Zeichen pro Zeile
bestehen.

Die Zahl der Quittierungsknîpfe muss zwischen 1 und 6 liegen. Der
Text auf jedem Knopf darf dabei maximal 20 Zeichen lang sein.

Die Funktion gibt die Nummer des Buttons zurÅck, den der Benutzer
gewÑhlt hat. Klickte der Benutzer z. B. in obigem Beispiel auf 'Ja',
so ist das Ergebnis 1. Klickt er auf 'Nein', gibt Alert eine 2
zurÅck.

Zur weiteren LektÅre siehe auch unter @{"form_alert" LINK "TOS.HYP/form_alert"}.

Siehe auch: SetButton, SetAlertColor, Set3DAlertColor, Enable3D,
Disable3D


!node Die Resourcen

Ein Programm ohne eine Rsc-Datei ist (fast) nicht vorstellbar. Des-
halb bietet SysGem auch einige Routinen fÅr den Umgang mit diesen
Dateien, als da wÑren:


!subnode LoadResource

INT LoadResource ( BYTE *rsc_name, BOOL long_rsc );


Die Funktion lÑdt eine Resourcedatei nach.

Parameter:
!begin_xlist [xxxxxxxxxxx]
 !item [rsc_name]     Name und Pfad der zu ladenden Resource-Datei.

 !item [long_rsc]     Ist dieser Wert ungleich 0, so soll eine Resource-Datei
              mit Farbicons oder eine allgemein lange (> 64k) Res-
              ource-Datei geladen werden. (!B)Dies ist allerdings nur
              mîglich, wenn sich das Programm CICON (Freeware) von
              Roger Jordan (MAUS WI2) im Auto-Ordner befindet.(!b)
!end_xlist
RÅckgabe:
!begin_xlist [xxxxxxxxxxx]
 !item [Wert >= 0]    Alles in Ordnung. Die Rsc-Datei konnte geladen werden.

 !item [RSC_NOCICON]  Es sollte eine lange Resource-Datei geladen werden,
              jedoch ist das Auto-Ordner Programm CICON nicht
              vorhanden.

 !item [RSC_LOADERR]  Ein Fehler ist beim Einlesen aufgetreten. Entweder ist
              die Datei defekt oder sie wurde nicht gefunden.
!end_xlist

!subnode RscAdr

OBJECT *RscAdr ( INT tree_type, INT index );


Ermittelt die Adresse eines Objektes aus der (!B)zuletzt geladenen(!b) Res-
ource-Datei.

Parameter:
!begin_xlist [xxxxxxxxxxx]
 !item [tree_type] Ist identisch mit der Definition aus AES.H

 !item [index]     Die Nummer des Objektes.
!end_xlist
Die Adresse eines Dialoges (nehmen wir an, sie ist der erste Baum in
der Rsc-Datei) wird dann so ermittelt:

adr = RscAdr ( R_TREE, 0 );

RÅckgabe:

Die Funktion liefert die Adresse des Objektes zurÅck, oder NULL, wenn
etwas schief lief.


!subnode RscFree

VOID RscFree ( VOID );


Gibt den Speicherplatz fÅr alle geladenen Resource-Dateien wieder
frei. Nach Aufruf dieses Befehls darf nicht mehr auf die Resourcen
zugegriffen werden!


!subnode InitResource

!begin_verbatim
BOOL InitResource ( OBJECT *rsc_tree, UINT num_obs, UINT num_trees,
                    VOID *rgb_table, BOOL long_rsc );
!end_verbatim

Initialisiert eine Resource, die im Programmcode eingebunden ist.

Parameter:
!begin_xlist [xxxxxxxxxxx]
 !item [rsc_tree]   Zeiger auf das allererste Element des gesamten Baumes.

 !item [num_obs]    Die Anzahl der Objekte in der Resource

 !item [num_trees]  Die Anzahl der BÑume in der Resource

 !item [rgb_table]  Zeiger auf eine RGB-Tabelle, wenn es sich bei der Resouce-
            Datei um eine lange (oder mit Farbicons) handelt. Zu den
            Farbicons bitte auch LoadResource beachten!

 !item [long_rsc]   muû auf TRUE gesetzt sein, wenn es sich um eine lange Res-
            ource-Datei handelt.
!end_xlist
RÅckgabe:

Die Routine liefert eine Wert != 0, wenn alles in Ordnung war, eine
0, wenn ein Fehler auftrat.


!node Bildschirmroutinen

SysGem nutzt die im folgenden aufgelisteten Funktionen hauptsÑchlich
fÅr interne Zwecke. Da sich mit ihnen allerdings nette Sachen machen
lassen, und sie teilweise den Programmieraufwand erheblich reduzie-
ren, sollen sie hier ruhig erwÑhnt werden...


!subnode NewArea

BOOL NewArea ( AREA *area );


Legt eine neue Area-Struktur an. Die Funktion liefert TRUE, wenn
alles glatt ging.

Liefert die Funktion FALSE, so dÅrfen die anderen Bildschirmroutinen
mit dieser Area-Struktur nicht benutzt werden!


!subnode ClearArea

VOID ClearArea ( AREA *area );


Gibt einen eventuell noch allozierten Speicher frei. Die Area-Variab-
le bleibt intern aber noch bekannt.


!subnode FreeArea

VOID FreeArea ( AREA *area );


Gibt die Area-Variable frei und eventuell noch benutzen Speicher
frei.


!subnode SaveArea

BOOL SaveArea ( INT handle, AREA *area, RECT *r );


Sichert einen Bildschirmbereich ins RAM. Die Funktion liefert FALSE,
wenn der Bildschirmbereich, der durch 'r' beschrieben wird, nicht
kopiert werden konnte.

Ist bereits ein Bildspeicher alloziiert und dieser fÅr das zu sichern-
de TeilstÅck zu klein, wird er freigegeben und ein neuer Speicherbe-
reich angefordert.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise vdi_handle aus
(!link [PARAMETER] [GetParStruct])).


!subnode RestoreArea

VOID RestoreArea ( INT handle, AREA *area );


Kopiert einen mit SaveArea gespeicherten Bereich wieder auf seine
Originalposition zurÅck.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise vdi_handle aus (!link [PARAMETER] [GetParStruct])).


!subnode CopyArea

VOID CopyArea ( INT handle, AREA *area, INT x, INT y );


Kopiert einen mit SaveArea gespeicherten Bereich an die Position x
und y. Der gesicherte Bereich wird dabei nicht verÑndert.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise vdi_handle aus (!link [PARAMETER] [GetParStruct])).


!subnode MoveScreen

VOID MoveScreen ( INT handle, RECT *r, INT x, INT y );


Diese Funktion kopiert einen Bildschirmbereich, dessen Koordinaten in
'r' beschrieben sind, an die Position x, y.

'handle' ist die Kennung der VDI-Workstation, auf der die Kopier-
aktion ablaufen soll. (Normalerweise vdi_handle aus (!link [PARAMETER] [GetParStruct])).


!node Konfiguration von SysGem

In SysGem lÑût sich fast alles konfigurieren; sei es eine Farbe oder
ein bestimmtes Verhalten. Hier mal eine öbersicht Åber die Funktion-
en:


!subnode Enable3D

VOID Enable3D ( VOID );


Schaltet die 3D-Darstellung ein. Dies ist die Voreinstellung, voraus-
gesetzt, es stehen 16 Farben oder mehr zur VerfÅgung. Bei weniger als
16 Farben wird der Aufruf dieser Funktion ignoriert.

Bei einem erfolgreichen Umschalten wird an jedes Fenster die Nach-
richt SG_3DSTATE verschickt. (!B)Danach(!b) wird das jeweilige Fenster neu ge-
zeichnet.

Sollten Sie also irgendwelche Einstellungen oder sonstwas im Fenster
darstellen, welches von der 3D-Darstellung abhÑngig ist, haben Sie
beim Eintreffen von SG_3DSTATE die Mîglichkeit, auf die geÑnderte Dar-
stellung zu reagieren.

(!B)Das Umschalten der Darstellung kann von einzelnen Fenstern nicht
verhindert werden.(!b)

Siehe auch: Disable3D, SysGem3D


!subnode Disable3D

VOID Disable3D ( VOID );


Schaltet die 3D-Darstellung aus. Der Aufruf wird ignoriert, wenn die
3D-Darstellung schon inaktiv war.

Bei einem erfolgreichen Umschalten wird an jedes Fenster die Nach-
richt SG_3DSTATE verschickt. (!B)Danach(!b) wird das jeweilige Fenster neu ge-
zeichnet.

Sollten Sie also irgendwelche Einstellungen oder sonstwas im Fenster
darstellen, welches von der 3D-Darstellung abhÑngig ist, haben Sie
beim Eintreffen von SG_3DSTATE die Mîglichkeit, auf die geÑnderte Dar-
stellung zu reagieren.

(!B)Das Umschalten der Darstellung kann von einzelnen Fenstern nicht mehr
verhindert werden.(!b)

Siehe auch: Enable3D, SysGem3D


!subnode SysGem3D

BOOL SysGem3D ( VOID );


Die Funktion liefert TRUE, wenn SysGem die Objekte im 3D-Look dar-
stellt, FALSE sonst.

Siehe auch: Enable3D, Disable3D


!subnode ChangeButton

VOID ChangeButton ( OBJECT *tree, INT obj, BYTE *text );


ChangeButton Ñndert den Text eines Buttons. Da alle Objekte von
SysGem geÑnderte ob_spec-Zeiger besitzen, dÅrfen Sie nicht mehr
selbst direkt auf diese Texte zugreifen. Sie mÅssen also Åber diese
Funktion gehen.

Die Parameter:
!begin_xlist [xxxxxxx]
 !item [tree]    Die Adresse des Baumes, in dem der Button liegt, dessen Text
         Sie Ñndern wollen. Der Baum muû vorher mit NewDialog angemeldet
         worden sein!

 !item [obj]     ist die Objektnummer des Buttons, dessen Text Sie Ñndern
         wollen.

 !item [text]    ist ein Zeiger auf den neuen Text. Der alte Text wird dabei
         gelîscht und durch den neuen ersetzt. Das Shortcut-Zeichen
         selbst wird dabei gefiltert und ein eventueller neuer Short-
         cut Åbernommen.

         (!B)Achtung:(!b) Der neue Text darf nicht lÑnger sein, als der alte!
!end_xlist
Das geÑnderte Objekt wird nicht direkt neugezeichnet, da Sie ja den
Text eines Buttons Ñndern kînnten, der noch nicht dargestellt wird
(z. B. beim Eintreffen der Nachricht SG_START). Ein gewÅnschtes Neu-
zeichnen mÅssen Sie mit einem Aufruf von RedrawObj selbst
herbeifÅhren.


!subnode SetAlertTitle

VOID SetAlertTitle ( BYTE *name );


Wenn eine Alertbox erscheint, so setzt SysGem als Standard die Pro-
gramm-Id in eckigen Klammern vor den Text "Hinweis". Da dieser Text
aber nicht allen gefÑllt, ist er konfigurierbar.

Bei dem Namen bzw. Text, den Sie der Funktion Åbergeben, setzt SysGem
selbststÑndig vor und hinter den Namen jeweils ein Leerzeichen.

Vor den ganzen Text setzt SysGem - wenn das Programm in einer Multi-
tasking-Umgebung lÑuft - immer den Programmnamen, der automatisch von
InitGem Åbernommen wird (Sie haben ihn ja dort angegeben), um dem
Benutzer zu zeigen, zu welchem Prozeû das Fesnter gehîrt.

Sollte als erstes Zeichen ein Balken ('|') stehen, so Åbernimmt
SysGem den gesamten String ohne irgendwelche énderungen.

Der Text ist solange gÅltig, bis ein neuer gesetzt wird, oder die
Funktion SetProgramName aufgerufen wird. Wenn Sie also die Titelzeile
einer Alertbox anders haben wollen, aber den Programmnamen noch
Ñndern wollen, so mÅssen Sie zuerst SetProgramName und dann
SetAlertTitle aufrufen, da SetProgramName auch den Namen fÅr die
Alertbox Åbernimmt.

Der Text kann bis zu 30 Zeichen lang sein, was wohl als Fenstertitel
ausreichen dÅrfte.


!subnode SetProgramName

VOID SetProgramName ( BYTE *name );


Diese Funktion Ñndert den Programmnamen um. Bei InitGem haben Sie ja
bereits einen Namen fÅr das Programm angegeben, und diesen benutzt
SysGem fÅr verschiedene Dinge, z. B. fÅr die Alertbox oder fÅr das
Iconify.

Wenn Sie den Programmnamen trotzdem nochmal Ñndern wollen, so kînnen
Sie der Funktionen einen bis zu 30 Zeichen langen String Åbergeben,
der dann als neuer Programmname Åbernommen wird.

Dabei wird der Name Åberschrieben, der bereits fÅr die Alertbox galt.
Eine vom Programmnamen abweichende Titelzeile fÅr die Alertbox mÅssen
Sie nach Aufruf dieser Funktion mit SetAlertTitle erneut setzen.


!subnode SetReturn

VOID SetReturn ( BOOL like_sysgem );


Diese Funktion stellt das Verhalten ein, wie SysGem auf die Return-
Taste reagieren soll.

Werte fÅr 'like_sysgem':
!begin_xlist [xxxxxxxxxxx]
 !item [TRUE]        Der Benutzer kann mit der Return-Taste die Editfelder
             wechseln, gelangt also in das jeweils nÑchste. Erreicht
             er das letzte, wird zuerst die Nachricht SG_LASTEDIT
             versandt, der RÅckgabewert ausgewertet, und anschlieûend
             dann der Cursor in die erste Zeile gesetzt.

             Ein Default-Button kann dann mit Shift-Return angewÑhlt
             werden.

 !item [FALSE]       Die Return-Taste wÑhlt einen Default-Button direkt an.
             Es kann nur mit den Cursor-Tasten und der TAB-Taste
             durch die Editfelder gesprungen werden (wie unter GEM
             halt...)
!end_xlist

!subnode SetUnknownEvent

typedef VOID ( *UPROC )( INT *msg );

VOID SetUnknownEvent ( UPROC proc );


Hiermit kann eine Funktion angemeldet werden, die immer dann aufge-
rufen wird, wenn SysGem auf einen unbekannten Event trifft. Dabei
wird der Funktion ein Zeiger auf den Message-Buffer (16 Byte) Åbergeben.


!subnode SetLanguage

VOID SetLanguage ( BOOL english );


Da es ja auch Leute gibt, die Programme in englischer Sprache schrei-
ben, kann mit dieser Funktion die Sprache eingestellt werden, in der
SysGem z. B. den Fontselektor darstellt (bzw. die
Buttonbeschriftung).

öbergeben Sie der Funktion TRUE, so ist Englisch aktiv, bei FALSE
Deutsch. Deutsch ist die Voreinstellung.


!subnode TellKeyStrokes

VOID TellKeyStrokes ( BOOL tell );


Mit dieser Funktion kînnen Sie einstellen, ob TastendrÅcke vor dem
Auswerten durch SysGem erst an die Handlerfunktion gesendet werden
(tell == TRUE) oder nicht (tell == FALSE).

Die Standardeinstellung ist FALSE.

Der Tastendruck wird mittels der Nachricht SG_KEY an die jeweilige
Handlerfunktion geschickt. Dabei geht SysGem wie folgt vor:
!begin_enumerate
  !item Der Benutzer betÑtigt eine Taste.

  !item Hat das Programm eine MenÅzeile, prÅft SysGem, ob der Shortcut
     auf einen Eintrag passt. Ist dies der Fall, bricht SysGem die
     Verarbeitung ab und teilt der Handlerfunktion der MenÅzeile den
     passenden MenÅeintrag mit.

  !item Hat das aktuelle Fenster eine MenÅzeile, prÅft SysGem, ob der
     Shortcut auf einen dieser EintrÑge passt. Ist dies der Fall,
     bricht SysGem die Verarbeitung ab und teilt der Handlerfunktion
     mittels der Nachricht SG_MENU die Anwahl der MenÅzeile mit.

  !item SysGem prÅft, ob der Tastendruck auf einen Shortcut eines But-
     tons passt. Ist dies der Fall, wird mittels SG_END oder
     SG_BUTTON dies der Handlerfunktion mitgeteilt.

  !item Ist die Taste die Help-Taste, wird die Nachricht SG_HELP
     verschickt.

  !item Ist die Taste die Undo-Taste, wird die Nachricht SG_UNDO
     verschickt.

  !item Wurde mittels TellKeyStrokes festgelegt (und nur dann), daû
     TastendrÅcke vorab zu senden sind, bevor SysGem diese weiter
     auswertet (z. B. Clipboard-Kopierfunktionen), wird nun SG_KEY
     verschickt. Darf und soll der Tastendruck nicht weiter verarbei-
     tet werden, muû die Handlerfunktion SG_KEYUSED zurÅckliefern.

  !item Handelt es sich bei dem Fenster um einen Fensterdialog, wird
     SG_EDKEY verschickt, sofern sich im Dialog Editfelder befinden.
     FÅr weitere Informationen siehe dort.

  !item Handelt es sich bei dem Fenster um ein normales Fenster, wird
     jetzt erst die Nachricht SG_KEY verschickt.
!end_enumerate

!subnode DialPosXY

VOID DialPosXY ( BOOL non_center );


Mit dieser Funktion kînnen Sie einstellen, ob Fensterdialoge zen-
triert (Voreinstellung) oder an der Mausposition (no_center == FALSE)
erscheinen sollen.


!subnode WaitAfterClose

VOID WaitAfterClose ( BOOL wait );


Mit dieser Funktion kînnen Sie einstellen, ob nach dem Schlieûen
eines Fensters etwas gewartet werden soll.

Diese Funktion hat nur Sinn, wenn Sie (!B)alle(!b) Fenster mittels
CloseAllWindows oder CloseWindow (!B)auf einmal(!b) schlieûen wollen und das
Programm auf einem Falcon unter TOS <= 4.04 lÑuft. Dort gibt es ein
Problem, wobei bei mehr als 16 Nachrichten in der Message-Queue der
Falcon abschmiert.

WaitAfterClose sorgt dafÅr, daû nach dem Schlieûen eines Fensters
erstmal die danach eintreffenden Nachrichten abgearbeitet werden um
zu verhindern, daû die Queue ÅberlÑuft.

In der Voreinstellung ist die Funktion inaktiv.


!subnode FrameTextColor

VOID FrameTextColor ( INT color );


Mit dieser Funktion kînnen Sie einstellen, in welcher Farbe die Texte
in den Frameboxen gezeichnet werden sollen. Die Voreinstellung ist
dabei die Farbe: Rot.


!subnode ShortCutColor

VOID ShortCutColor ( INT color );


Mit dieser Funktion kînnen Sie einstellen, in welcher Farbe die Short-
cuts gezeichnet werden sollen. Die Voreinstellung ist Rot.


!subnode UseRoundButtons

VOID UseRoundButtons ( BOOL use );


SysGem kann die Buttons in zweierlei Arten zeichnen: eckig und einmal
ganz leicht abgerundet, was vor allem in 3D sehr schîn aussieht.

öbergeben Sie TRUE, werden die Buttons mit abgerundeten Ecken gezeich-
net (Voreinstellung), bei FALSE halt eckig.


!subnode UseOwnEditFields

VOID UseOwnEditFields ( VOID );


SysGem kennt zwei Arten von Editfeldern:
!begin_enumerate
  !item die normalen, vom AES bekannten Editfelder, und

  !item die eigenen, die es auch ermîglichen, Eingaben mit Proportional-
     fonts zu handhaben. Desweiteren bieten die eigenen Editfelder
     einen blinkenden Cursor und einen Rahmen (wie bei Windows auch).
!end_enumerate
Um dieses Feature zu nutzen, muû die Funktion nach InitGem, aber noch
(!B)vor dem ersten(!b) NewDialog aufgerufen werden!

Siehe auch: Erweiterter Typ: Editfeld


!subnode SetMonoEditFrame

VOID SetMonoEditFrame ( BOOL paint );


Wird diese Funktion mit paint == TRUE aufgerufen, werden um die
Editfelder Rahmen gezeichnet.

Das Ganze sieht dann so aus:


!image IMG413.IMG
Dieses Beispiel wurde aus (!xlink [SysInfo] [SYSINFO.HYP/Inhalt]) entnommen.

In der Voreinstellung ist dieses Feature inaktiv.


!subnode SetSelColor

INT SetSelColor ( INT color );


Arbeiten Sie unter Farbe, so hat SysGem noch ein Feature zu bieten.
Wird beim Textfenster oder bei den Sliderboxen ein Eintrag selek-
tiert, so zeichnet SysGem diesen Eintrag in Monochrom invertiert,
also weiûe Schrift auf schwarzem Grund.

In Farbe kînnen Sie dies konfigurieren. In der Voreinstellung (unter
Farbe) zeichnet SysGem den Text in schwarz auf rotem Grund.

Die Farbe des Texthintergrundes (Voreinstellung: Rot) kînnen Sie mit
dieser Funktion einstellen.

Dazu Åbergeben Sie der Funktion bei 'color' einfach die neue Farbe,
in der ab dann der neue Hintergrund gezeichnet wird. Die Funktion
liefert die tatsÑchlich eingestellte Farbe zurÅck.

Siehe auch: SetSelTextColor


!subnode SetSelTextColor

INT SetSelTextColor ( INT color );


Arbeiten Sie unter Farbe, so hat SysGem noch ein Feature zu bieten.
Wird beim Textfenster oder bei den Sliderboxen ein Eintrag selek-
tiert, so zeichnet SysGem diesen Eintrag in Monochrom invertiert,
also weiûe Schrift auf schwarzem Grund.

In Farbe kînnen Sie dies konfigurieren. In der Voreinstellung (unter
Farbe) zeichnet SysGem den Text in schwarz auf rotem Grund.

Die Farbe des Textes (Voreinstellung: Schwarz) kînnen Sie mit dieser
Funktion einstellen.

Dazu Åbergeben Sie der Funktion bei 'color' einfach die neue Farbe,
in der ab dann der Text gezeichnet wird. Die Funktion liefert die
tatsÑchlich eingestellte Farbe zurÅck.

Siehe auch: SetSelColor


!subnode SetButton

VOID SetButton ( INT just );


Mit dieser Funktion kînnen Sie einstellen, wie die Buttons der Alert-
box angeordnet sein sollen. FÅr 'just' gilt:
!begin_xlist [xxxxxxxxxxxxxx]
!item [ButtonLeft]      Die Buttons sind linksbÅndig angeordnet

!item [ButtonCenter]    Die Buttons sind zentriert (Voreinstellung)

!item [ButtonRight]     Die Buttons werden rechtsbÅndig ausgegeben.
!end_xlist
Siehe auch: Alert


!subnode Set3DAlertColor

VOID Set3DAlertColor ( INT icn1, INT icn2, INT icn3 );


Damit die Alertbox (und vor allem das verwendete Icon) richtig zur
Geltung kommt, kann dessen Farbe eingestellt werden.
!begin_xlist [xxxxxxx]
!item [icn1]    die Farbe des Ausrufezeichens. Voreinstellung ist GrÅn.

 !item [icn2]    die Farbe des Fragezeichens. Voreinstellung ist Gelb.

 !item [icn3]    die Farbe des Stop-Schildes. Voreinstellung ist Rot.
!end_xlist
Diese Farbeinstellungen gelten nur, wenn die 3D-Darstellung aktiv
ist.

Wird fÅr einen Wert -1 Åbergeben, Ñndert sich die Einstellung nicht.

Siehe auch: SetAlertColor, Enable3D


!subnode SetAlertColor

VOID SetAlertColor ( INT icn1, INT icn2, INT icn3 );


Damit die Alertbox (und vor allem das verwendete Icon) richtig zur
Geltung kommt, kann dessen Farbe eingestellt werden.
!begin_xlist [xxxxxxx]
 !item [icn1]    die Farbe des Ausrufezeichens. Voreinstellung ist GrÅn.

 !item [icn2]    die Farbe des Fragezeichens. Voreinstellung ist Gelb.

 !item [icn3]    die Farbe des Stop-Schildes. Voreinstellung ist Rot.
!end_xlist
Diese Farbeinstellungen gelten nur, wenn die 3D-Darstellung (!B)inaktiv(!b)
ist.

Wird fÅr einen Wert -1 Åbergeben, Ñndert sich die Einstellung nicht.

Siehe auch: Set3DAlertColor, Enable3D, Disable3D


!subnode ClipboardChanged

VOID ClipboardChanged ( VOID );


Diese Funktion teilt allen Handlerfunktionen und auch parallel laufen-
den Prozessen mit, daû sich der Inhalt des Clipboards geÑndert hat.

Sie sollten diese Funktion aufrufen, wenn Sie selbst am Clipboard
manipuliert haben.


!subnode SetTextColor

VOID SetTextColor ( OBJECT *tree, INT obj, INT color );


Diese Funktion setzt die Farbe eines Textes (normales TEXTfeld oder
Editfeld) mit der Objektnummer 'obj' im Baum 'tree' auf die Farbe
'color'.

Das Objekt wird nicht direkt neugezeichnet; ein Neuzeichnen mÅssen
Sie selbst durch einen Aufruf von RedrawObj auslîsen.

!subnode SetObjTextColor

!begin_verbatim
VOID SetObjTextColor ( OBJECT *tree, INT obj, INT framecol, INT textcol,
                       INT textmode, INT fillpattern, INT interiorcol)
!end_verbatim

Diese Funktion setzt die Farben eines Textobjektes (normales TEXTfeld oder
Editfeld).
!begin_xlist [xxxxxxxxxxx]
!item [tree]         Adresse des Objektbaumes

!item [obj]          Objektnummer

!item [framecol]     Rahmenfarbe

!item [textcol]      Textfarbe

!item [textmode]     Zeichenmodus (0 = transparent, 1 = deckend)

!item [fillpattern]  ZeichenintensitÑt

             0    = hohl (!nl)
             1..6 = ansteigende IntensitÑt (!nl)
             7    = solide FlÑche  (!nl)

!item [interiorcol]  Innenfarbe
!end_xlist
Durch die Angabe von -1 bei einem Wert wird die Einstllung nicht verÑndert.

Das Objekt wird nicht direkt neugezeichnet; ein Neuzeichnen mÅssen
Sie selbst durch einen Aufruf von RedrawObj auslîsen.

!subnode GetObjTextColor

!begin_verbatim
INT GetObjTextColor ( OBJECT *tree, INT obj, INT *framecol, INT *textcol,
                       INT *textmode, INT *fillpattern, INT *interiorcol)
!end_verbatim

Diese Funktion ernmittelt die Farben eines Textobjektes (normales TEXTfeld oder
Editfeld).
!begin_xlist [xxxxxxxxxxx]
!item [tree]         Adresse des Objektbaumes

!item [obj]          Objektnummer

!item [framecol]     Rahmenfarbe

!item [textcol]      Textfarbe

!item [textmode]     Zeichenmodus (0 = transparent, 1 = deckend)

!item [fillpattern]  ZeichenintensitÑt

             0    = hohl (!nl)
             1..6 = ansteigende IntensitÑt (!nl)
             7    = solide FlÑche (!nl)

!item [interiorcol]  Innenfarbe
!end_xlist
Ist ein Wert nicht erwÅnscht so kann man auch NULL Åbergeben.

Die Funktion liefert TRUE, wenn alles funktioniert hat.


!subnode SetUserKeyProc

typedef INT (*USR_PROC)( INT );

VOID SetUserKeyProc ( USR_PROC key_hook );

Jeder Tastendruck wird zuerst an die Funktion "key_hook" gesendet 
(AES Tastencode) (sofern die Funktion angemeldet wurde). Liefert die 
Funktion key_hook != 0 zurÅck, wird die weitere Bearbeitung abgebrochen, 
also von SysGem verworfen. Ein Wert == 0 sagt SysGem, das mit der 
Taste nichts anfangen konntet, die Taste also ganz normal zu untersuchen 
und zu verarbeiten ist.

(!B)Achtung:(!b) Das funktioniert IMMER! Egal, ob nur die MenÅzeile oder aber 
200 Dialoge offen sind! key_hook erhÑlt dann immer den Tastendruck zuerst! 
Zum Abmelden einfach SetUserKeyP mit NULL aufrufen.

!subnode CheckLogFont

VOID CheckLogFont ( BOOL check )

Ist check TRUE werden fÅr alle Fenster die Funktion SetWindowFont
aufgerufen, wenn die Nachricht VA_FONTCHANGED kommt.


!node Die Fenster

In SysGem spielen die Fenster eine groûe Rolle, gibt es doch die
"normalen" Dialoge seit der 1.28 nicht mehr. Dementsprechend bietet
SysGem fÅr so ziemlich alle FÑlle etwas passendes an.

In SysGem werden Fenster normalerweise nicht durch ihr vom AES bekann-
ten Handle angesprochen, sondern Åber eine eigene Fenster-Id.

Der Grund dazu ist, daû man bei Handles immer eine Variable mitfÅhren
muû, bei der ID kann sie aber als Konstante abgelegt werden und ist
auch viel leichter zu handhaben - und vor allem: zu merken.

Die Fenster in SysGem arbeiten wie alle Funktionen mit sogenannten
Handlerfunktionen oder CallBack-Funktionen. Das heiût, fÅr jedes Fen-
ster wird eine Funktion festgelegt, die dann von SysGem aufgerufen
wird, wenn ein bestimmtes Ereignis aufgetreten ist. Der Vorteil davon
ist die klare Trennung in Aufgaben und die sehr leichte, einfache und
schnelle Erweiterbarkeit der Mîglichkeiten, bzw. der Programme.

FÅr jedes Fenster kînnen zwei Funktionen festgelegt werden. Eine Funk-
tion vom Typ RPROC kÅmmert sich nur um das Neuzeichnen von Fen-
sterbereichen, eine Funktion vom Typ APROC erhÑlt alle wichtigen Nach-
richten von SysGem und natÅrlich die BenutzeraktivitÑten. Die weitere
Verfahrensweise auf diese Nachricht wird dann Åber den RÅckgabewert
der Handlerfunktion abgewickelt.

Die einzelnen Fenster sind also bei SysGem fast schon kleine Pro-
gramme an sich.

Hier mal die öbersicht Åber alle weiteren Fensterfunktionen:

!subnode InitXWindow

VOID InitXWindow ( (!link [XWIN] [XWindow]) *xwin );


Diese Funktion initialisiert die fÅr die Funktion XWindow benîtigte
Struktur (!link [XWIN] [XWindow]), bzw. sie wird mit Standardwerten gefÅllt.

(!B)Eine weitere FunktionalitÑt dieser Funktion ist fÅr zukÅnftige
Erwei!-terungen reserviert!(!b)


!subnode XWindow

VOID *XWindow ( XWIN *xwin );


XWindow îffnet zwar auch nur ein Fenster, jedoch lÑût sich dieses Fen-
ster bis ins Detail schon vor dem ôffnen konfigurieren, im Gegensatz
zu OpenWindow, wo an einige Details erst nach dem ôffnen ranzukommen
ist.

Ebenso lassen sich bei XWindow bereits BÑume angeben, die im Fenster
gezeichnet werden sollen. Das besondere dabei bei dieser Funktion
ist, daû sich alle BÑume um den reinen Arbeitsbreich herumlegen. Der
Arbeitsbereich, der von Ihnen hier angegeben wird, bleibt also
er!-halten.

Um das Fenster zu beschreiben, wird eine Struktur vom Typ XWIN
benutzt:
!begin_verbatim
typedef struct
  {
    LONG        id;
    LONG        owner;
    INT         flags;
    UINT        cfg;
    RECT        work;
    BYTE        *name;
    BYTE        *info;
    VOID        *user;
    INT         align_x;
    INT         align_y;
    INT         scr_x;
    INT         scr_y;
    INT         font_id;
    INT         font_pt;
    INT         min_w;
    INT         min_h;
    INT         max_w;
    INT         max_h;
    INT         back;
    INT         anz_trees;
    XTREE       *trees;
    OBJECT      *menu;
    LONG        doc_w;
    LONG        doc_h;
    RPROC       redraw;
    APROC       waction;
    DPROC       daction;
  } XWIN;
!end_verbatim
(!B)Wichtig: Vor der Belegung der Struktur durch Sie, mÅssen Sie die Funk!-tion
 InitXWindow mit dieser Struktur aufrufen!(!b)

Hier die Beschreibung der einzelnen Werte:
!begin_xlist [xxxxxxxxxxxxxx]
 !item [id]              Die Fenster-Id. Sie darf nie 0L und muû immer ein-
                 deutig sein. Sie dient dazu, das Fenster nicht mit
                 einem Handle (welches sich in SysGem Ñndern kann),
                 sondern mit einem Klartextnamen (4 Zeichen)
                 anzusprechen.

 !item [owner]           Wird von InitXWindow mit der Programm-ID vorbelegt.
                 Reserviert fÅr zukÅnftige Erweiterungen!

 !item [flags]           Die normalen Flags, die das AES zur VerfÅgung
                 stellt, also das Aussehen des Fensters definieren.

 !item [cfg]             Bestimmte Einstellungen fÅr das Fenster:

                 (!B)WIN_PAINT(!b) Der Inhalt des Fensters wird immer gezeich-
                 net (normalerweise weiû, einstellbar mit
                 SetWinBackground). Der Bereich mittels XTREE oder
                 mit LinkTree eingehÑngte BÑume wird dabei ausge-
                 spart, da die BÑume ja ebenfalls noch gezeichnet wer-
                 den.

                 (!B)WIN_FORCE@(!b) Dieses Fenster ist immer oben, d.h., nur
                 dieses Fenster lÑût sich im Programm bedienen.
                 Dieser Status bleibt solange erhalten, bis das
                 Fesnter entweder geschlossen, oder ein neues eben-
                 falls mit WIN_FORCE geîffnet wird.

 !item [work]            legt die Koordinaten sowie die Hîhe und Breite des
                 Fensters (!B)des Arbeitsbereiches(!b) fest, mit dem das Fen-
                 ster geîffnet wird. EingehÑngte BÑume werden dann
                 (!B)auûerhalb(!b) dieses Bereiches platziert. 'work' gibt
                 also immer den reinen Netto-Arbeitsbereich des Fen-
                 sters an.

 !item [name]            ist ein Zeiger auf den Namen des Fensters, der als
                 Fenstertitel verwendet wird. Dabei setzt SysGem
                 selbststÑndig vor und hinter den Namen jeweils ein
                 Leerzeichen, so daû Sie es im Programm nicht immer
                 machen mÅssen (spart immer 2 Byte :-))

                 Vor den ganzen Text setzt SysGem - wenn das Programm
                 in einer Multitasking-Umgebung lÑuft - immer den Pro-
                 grammnamen, der automatisch von InitGem Åbernommen
                 wird (Sie haben ihn ja dort angegeben), um dem
                 Benutzer zu zeigen, zu welchem Prozeû das Fesnter
                 gehîrt.

                 Sollte als erstes Zeichen ein Balken ('|') stehen,
                 so Åbernimmt SysGem den gesamten String ohne
                 irgendwelche énderungen.

                 Der Name braucht nicht statisch gehalten zu werden,
                 nach Aufruf von XWindow wird der Name in einen
                 eigenen Speicherbereich kopiert.

 !item [info]            Ein Zeiger auf die Infozeile des Fensters (sofern
                 bei 'flags' INFO (0x10) angegeben wurde.

                 Die Infozeile wird 1:1 Åbernommen und nach dem
                 Aufruf von XWindow in einen eigenen Bereich kopiert,
                 so daû der Text in ihrem Programm nicht statisch ge-
                 halten werden muû.

 !item [user]            Ein Zeiger auf irgendwas. Dieser Zeiger ist fÅr Ihre
                 Routinen reserviert; er wird jeweils in der
                 WINDOW_INFO-Struktur an die Handlerroutine Åberge-
                 ben. Dieser Zeiger eignet sich vorzÅglich dazu,
                 Zeiger auf eigene Strukturen dem Fenster mitzugeben,
                 ohne das Sie sich diese in Ihrem Programm merken
                 mÅssen.

 !item [align_x]         gibt an, in welchen Pixelschritten das Fenster
                 horizontal verschoben werden kann. Normalerweise ist
                 dieser Wert 8, (Voreinstellung bei InitXWindow) so
                 daû der Arbeitsbereich immer auf Byte-Position
                 beginnt. Texte kînnen so sehr viel schneller ausgege-
                 ben werden.

 !item [align_y]         Das gleiche wie bei 'align_x', nur fÅr die vertikale
                 Verschiebung. Der Standardwert ist 1.

 !item [scr_x, scr_y]    Wenn Sie in einem Fenster die Scrollpfeile angemeld-
                 et haben, und klickt der Benutzer auf einen von
                 diesen, dann scrollt SysGem selbststÑndig den Fen-
                 sterinhalt, wie es sich auch um die korrekte Grîûe
                 und Position der Slider kÅmmert. Allerdings muû
                 SysGem dann wissen, um wieviel Pixel es scrollen
                 soll. Diese beiden Variablen geben also die Anzahl
                 der Pixel an, in die in jede Richtung gescrollt wer-
                 den soll. Bei einem Textfenster wÑren das die Zei-
                 chenbreite und -hîhe.

 !item [font_id]         ist die Id des Fonts, der fÅr die Darstellung im Fen-
                 ster genutzt werden soll. Voreinstellung ist der
                 aktuelle Zeichensatz.

 !item [font_pt]         ist die Grîûe des Fonts in Punkten. Voreinstellung
                 ist die Grîûe des aktuellen Zeichensatzes.

 !item [min_w, min_h]    gibt die minimalste Grîûe des Arbeitsbereiches in
                 Pixeln an. Der Benutzer kann das Fenster dann nicht
                 kleiner machen. Wird fÅr beide (oder fÅr einen)
                 Wert(e) eine 0 angegeben, so wird diese Grîûe nicht
                 beachtet.

 !item [max_w, max_h]    das gleiche wie bei min. Das Fenster kann dann nicht
                 grîûer werden als die angegebenen Grîûen. Wird fÅr
                 beide (oder fÅr einen) Wert(e) eine 0 angegeben, so
                 wird diese Grîûe nicht beachtet.

 !item [back]            gibt die Farbe an, mit der der Hintergrund des Fen-
                 sters gezeichnet wird. In 3D bietet sich so die Mîg-
                 lichkeit, den Fensterhintergrund in Grau statt in
                 Weiû (Voreinstellung) zeichnen zu lassen.

 !item [anz_trees]       gibt die Anzahl der BÑume an, die ins Fenster 
                 gehÑngt werden sollen. Der Wert ist 0, wenn keine
                 BÑume eingehÑngt werden sollen.

 !item [trees]           ist ein Zeiger auf ein Array von XTREE, oder NULL,
                 wenn keine BÑume ins Fenster gehÑngt werden sollen
                 und somit 'anz_trees' == 0 ist.

 !item [menu]            ist ein Zeiger auf einen Baum, der als MenÅzeile im
                 Fenster erscheinen soll. Auch hier sind beliebig
                 viele MenÅzeilen mîglich.

                 Neu in der 2.0: Bei einer MenÅzeile ist die Info-
                 zeile weiterhin nutzbar!

 !item [doc_w, doc_h]    Gibt den Dokumentbereich in Pixeln an. In einem Fen-
                 ster mit Slidern sieht man ja nur einen Ausschnitt
                 aus dem gesamten Dokument. Stellen Sie sich Ihre
                 Schreibtischplatte vor (haben Sie keinen Schreib-
                 tisch, kînnen Sie auch den Fuûboden nehmen, der
                 sollte auf jeden Fall vorhanden sein...). Nehmen Sie
                 ein Blatt Papier und legen Sie es auf die Platte
                 (Schreibtischplatte, nicht Festplatte!) Das Blatt
                 symbolisiert nun den Bereich, den Sie im Fenster
                 selbst sehen kînnen, die Schreibtischplatte den
                 Dokumentbereich. Mit den Slidern im Fenster kînnen
                 Sie nun (symbolisch) das Blatt auf dem Schreibtisch
                 verschieben.

                 Der Dokumentbereich kann immer nur ein Vielfaches
                 von scroll_x, scroll_y sein! Sollte dies von Ihnen
                 nicht beachtet werden, korrigiert SysGem diese Werte
                 selbststÑndig.

 !item [redraw]          Diese Funktion wird aufgerufen, wenn an oder im den
                 Fenster irgendwas neu zu zeichnen ist. FÅr weitere
                 Informationen siehe unter RPROC.

 !item [waction]         Diese Funktion erhÑlt alle Nachrichten Åber Benutzer-
                 aktivitÑten, wenn es sich bei dem Fenster um ein
                 normales Fenster handelt.

                 (!B)Geben Sie hier eine Routine an, so muû 'daction'
                 immer NULL sein!(!b)

                 FÅr weitere Informationen siehe unter APROC.

 !item [daction]         Soll sich das Fenster wie ein Fensterdialog verhalten,
                  so ist hier die Handlerfunktion dazu anzugeben.
                 'waction' muû dazu NULL sein!

                 FÅr weitere Informationen siehe unter DPROC.
!end_xlist
Ist das Fenster geîffnet worden, wird es durch die Nachricht SG_START
initialisiert.

Die Funktion liefert einen Wert != NULL, wenn das Fenster geîffnet
wurde, NULL sonst.


!subnode RPROC

typedef VOID ( *RPROC )( WINDOW_INFO *inf );


Eine Funktion vom Typ RPROC ist zustÑndig fÅr das Neuzeichnen von Fen-
sterbereichen. Die Funktion erhÑlt dabei alle notwendigen Daten, die
fÅr das Neuzeichnen von einem Fensterbereich benîtigt werden.

Die einzelnen Elemente von WINDOW_INFO sind dabei bei einem Redraw
wie folgt belegt:
!begin_xlist [xxxxxxxxxxxx]
 !item [id]            enthÑlt die Fenster-Id. Mit Hilfe der ID ist es auch
               mîglich, eine einzige Redraw-Funktion fÅr mehrere Fen-
               ster anzumelden, da eine genaue Entscheidung Åber das
               "gemeinte" Fenster mîglich ist.

 !item [handle]        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern kann
               (natÅrlich nicht, solange die Redraw-Funktion durchlau-
               fen wird...)

 !item [pos_x, pos_y]  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 !item [doc_x, doc_y]  mÅssten eigentlich 'doc_w' und 'doc_h' heiûen, aller-
               dings habe ich sie aus KompatibilitÑtsgrÅnden zur 1.x
               nicht umbenannt. Die Variablen enthalten die Grîûe des
               Dokument-Bereiches in Pixeln.

 !item [user]          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 !item [work_area]     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 !item [draw_area]     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 !item [clip]          enthÑlt die Ausmaûe des Rechtecks, welches neu zu
               zeichnen ist.
!end_xlist
Beachten Sie aber bitte folgende Dinge:
!begin_enumerate
  !item Die Zeichenfunktion wird fÅr jedes einzelne Rechteck separat auf-
     gerufen! Ein "abklappern" einer Rechteckliste ist nicht notwen-
     dig, das erledigt SysGem schon fÅr Sie!

  !item Der Bildschirm ist fÅr die Zeit, die in der Zeichenfunktion
     zugebracht wird, gesperrt (wind_update ist gesetzt). Sie sollten
     es also nicht noch einmal setzen.

  !item Die Maus wird bei Aufruf der Funktion nicht versteckt. Wenn Sie
     also VDI-Ausgaben machen, mÅssen Sie die Maus selbst verstecken!

  !item Der Fensterhintergrund (normalerweise weiû), wird, wenn Sie es
     der Lib nicht explizit verboten haben, von SysGem gezeichnet.
     Sie brauchen es also nicht noch einmal zu machen!

  !item Eventuell eingehÑngte BÑume werden von SysGem schon selbst ge-
     zeichnet. Sie brauchen sich also nur noch um das Redraw des ei-
     gentlichen Arbeitsbereiches zu kÅmmern!
!end_enumerate

!subnode APROC

typedef INT ( *APROC )( INT msg, WINDOW_INFO *inf );


Eine Handlerfunktion fÅr ein "normales" Fenster muû immer von obigem
Typ sein.

Bei einem Aufruf werden an 'msg' die Nachrichten von SysGem und in
'inf' ein Zeiger auf die WINDOW_INFO Struktur Åbergeben.

Als RÅckgabewert wird immer ein INT erwartet; siehe dazu bei "Nach-
richten an SysGem".


!subnode OpenWindow
!begin_verbatim
INT OpenWindow ( LONG   id,
                 BYTE   *name,
                 BYTE   *info,
                 INT    flags,
                 OBJECT *menu,
                 INT    align,
                 BOOL   part,
                 INT    scr_x,
                 INT    scr_y,
                 LONG   doc_x,
                 LONG   doc_y,
                 INT    x,
                 INT    y,
                 INT    w,
                 INT    h,
                 VOID   *user,
                 RPROC  redraw,
                 APROC  action );
!end_verbatim

Ich weiû, es sieht viel aus, ist aber ganz einfach. Das Erstellen
eines Fensters ist aufweniger als die Verwaltung...

Diese Funktion îffnet ein normales Fenster und liefert das Handle des
Fensters zurÅck; im Fehlerfall -1 (kein Fenster mehr frei) und an die
Handlerfunktion (sofern angemeldet) die Nachricht SG_NOWIN.

Parameter:
!begin_xlist [xxxxxxxxxx]
 !item [id]         Die Fenster-Id, unter der Fenster spÑter angesprochen
            wird.

 !item [name]       ist ein Zeiger auf den Namen des Fensters, der als Fen-
            stertitel verwendet wird. Dabei setzt SysGem selbst-
            stÑndig vor und hinter den Namen jeweils ein Leerzeichen,
            so daû Sie es im Programm nicht immer machen mÅssen
            (spart immer 2 Byte :-))

            Vor den ganzen Text setzt SysGem - wenn das Programm in
            einer Multitasking-Umgebung lÑuft - immer den Pro-
            grammnamen, der automatisch von InitGem Åbernommen wird
            (Sie haben ihn ja dort angegeben), um dem Benutzer zu
            zeigen, zu welchem Prozeû das Fesnter gehîrt.

            Sollte als erstes Zeichen ein Balken ('|') stehen, so
            Åbernimmt SysGem den gesamten String ohne irgendwelche
            énderungen.

            Der Name braucht nicht statisch gehalten zu werden, nach
            Aufruf wird der Name in einen eigenen Speicherbereich
            kopiert.

 !item [info]       Ein String, der als Infozeile im Fenster erscheinen soll.
            Ist keine Infozeile erwÅnscht, Åbergeben Sie einfach
            einen Leerstring, (!B)nicht(!b) NULL.

 !item [flags]      Die Flags, die das Aussehen des Fensters bestimmen. Sie
            sind in der jeweiligen GEM-Unit definiert.

 !item [menu]       Zeiger auf den Baum einer MenÅleiste, die im Fenster
            erscheinen soll oder NULL.

 !item [align]      Auf diesen Wert wird der linke Arbeitsbereich des Fen-
            sters ausgerichtet, d.h., das Fenster kann nur an X-
            Koordinaten liegen, die durch "align" restlos teilbar
            sind. Bei Textfenstern sollte daher immer charw von
            @{"PARAMETER" LINK "GetParStruct" 3} angegeben werden; dieses setzt dann das Fenster
            immer auf durch 8 (wenn parameter.charw == 8) teilbare
            Koordinaten. Dies hat den (unschlagbaren) Vorteil, daû
            dann die Ausgabe via "v_xtext" um einiges schneller
            verlÑuft.

            Der Normalwert - falls nicht benîtigt oder gewÅnscht -
            sollte 8 sein.

 !item [part]       öbergeben Sie hier eine 1, wird bei jedem Redraw der Fen-
            sterhintergrund mit weiû "vorgemalt". Sie brauchen sich
            dann nicht um das Zeichnen des Hintergrundes zu kÅmmern,
            SysGem macht dies dann fÅr Sie.

            öbergeben Sie eine 0, so unterbleibt das Zeichnen des
            Hintergrundes.

 !item [scroll_x,y] Wenn Sie in einem Fenster die Scrollpfeile angemeldet
            haben, und klickt der Benutzer auf einen von diesen, dann
            scrollt SysGem selbststÑndig den Fensterinhalt, wie es
            sich auch um die korrekte Grîûe und Position der Slider
            kÅmmert. Allerdings muû SysGem dann wissen, um wieviel
            Pixel es scrollen soll. Diese beiden Variablen geben also
            die Anzahl der Pixel an, in die in jede Richtung
            gescrollt werden soll. Bei einem Textfenster wÑren das
            die Zeichenbreite und -hîhe.

 !item [doc_x,y]    Gibt den Dokumentbereich in Pixeln an. In einem Fenster
            mit Slidern sieht man ja nur einen Ausschnitt aus dem
            gesamten Dokument. Stellen Sie sich Ihre Schreib-
            tischplatte vor (haben Sie keinen Schreibtisch, kînnen
            Sie auch den Fuûboden nehmen, der sollte auf jeden Fall
            vorhanden sein...). Nehmen Sie ein Blatt Papier und legen
            Sie es auf die Platte (Schreibtischplatte, nicht
            Festplatte!) Das Blatt symbolisiert nun den Bereich, den
            Sie im Fenster selbst sehen kînnen, die Schreib-
            tischplatte den Dokumentbereich. Mit den Slidern im Fen-
            ster kînnen Sie nun (symbolisch) das Blatt auf dem
            Schreibtisch verschieben.

            Der Dokumentbereich kann immer nur ein Vielfaches von
            scroll_x, scroll_y sein! Sollte dies von Ihnen nicht
            beachtet werden, korrigiert SysGem diese Werte selbst-
            stÑndig.

 !item [x,y,w,h]    Geben die Koordinaten, die Breite und Hîhe des Arbeitsbe-
            reiches an, die das Fenster beim ôffnen haben soll. Die
            Breite und Hîhe mÅssen ein Vielfaches von scroll_x,
            scroll_y sein; SysGem korrigiert diese Werte jedoch, soll-
            ten sie nicht stimmen.

            Beachten Sie, daû hier vom Arbeitsbereich des Fensters
            die Rede ist!

 !item [user]       Zeiger auf irgendwas. Zur freien VerfÅgung.

 !item [redraw]     Hier geben Sie eine Funktion an, die das Neuzeichnen des
            Fensters Åbernimmt. Siehe auch unter RPROC.

 !item [action]     Diese Funktion erhÑlt alle BenutzeraktivitÑten. Siehe auf
            unter APROC.
!end_xlist
Wurde das Fenster geîffnet, erhÑlt die Handlerfunktion als erstes die
Nachricht SG_START.


!subnode SetWindowName

VOID SetWindowName ( INT handle, BYTE *name );


Setzt den Titel des Fensters neu.
!begin_xlist [xxxxxxxx]
 !item [handle]    ist das AES Handle des Fenster. Siehe auch bei GetHandle.

 !item [name]      ist ein Zeiger auf den Namen des Fensters, der als Fen-
           stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
           vor und hinter den Namen jeweils ein Leerzeichen, so daû
           Sie es im Programm nicht immer machen mÅssen (spart immer
           2 Byte :-))

           Vor den ganzen Text setzt SysGem - wenn das Programm in
           einer Multitasking-Umgebung lÑuft - immer den Pro-
           grammnamen, der automatisch von InitGem Åbernommen wird
           (Sie haben ihn ja dort angegeben), um dem Benutzer zu
           zeigen, zu welchem Prozeû das Fesnter gehîrt.

           Sollte als erstes Zeichen ein Balken ('|') stehen, so
           Åbernimmt SysGem den gesamten String ohne irgendwelche
           énderungen.

           Der Name braucht nicht statisch gehalten zu werden, nach
           Aufruf von XWindow wird der Name in einen eigenen Speicher-
           bereich kopiert.
!end_xlist

!subnode SetWindowInfo

VOID SetWindowInfo ( INT handle, BYTE *info );


Setzt einen neuen Text fÅr die Infozeile.
!begin_xlist [xxxxxxxx]
 !item [handle]    ist das AES Handle des Fenster. Siehe auch bei GetHandle.

 !item [info]      ist ein Zeiger auf die neue Infozeile. Der neue Text wird
           ohne énderungen Åbernommen.

           Der Name braucht nicht statisch gehalten zu werden, nach
           Aufruf wird der Name in einen eigenen Speicherbereich
           kopiert.
!end_xlist

!subnode CloseAllWindows

BOOL CloseAllWindows ( WORD mode );

/* mode: TRUE = Fenster bekommen nur eine SG_QUIT Message							 */
/*       FALSE = Bekommt erst die Message SG_END											 */
/* RÅckgabe: TRUE alle Fenster konnten geschlossen werden, sonst FALSE */
/* [GS]																																 */


Schlieût alle Fenster. Dazu werden die Fenster ohne vorhergehende
Nachricht direkt mittels SG_QUIT geschlossen.



!subnode WindowVisible

BOOL WindowVisible ( INT handle );


WindowVisible liefert TRUE, wenn der Arbeitsbereich des Fensters
sichtbar ist, FALSE sonst.

Siehe auch: GetHandle


!subnode GetTopWindow

INT GetTopWindow ( VOID );


Liefert das AES-Handle des obersten Fensters oder -1, wenn das
oberste Fenster nicht dem Programm gehîrt.


!subnode GetTopWindowId

LONG GetTopWindowId ( VOID );


Liefert die Fenster-Id des obersten Fensters oder 0L, wenn das
oberste Fenster nicht dem Programm gehîrt.


!subnode TopWindow

BOOL TopWindow ( INT handle );


Diese Funktion toppt das durch das AES Handle 'handle' angegebene Fen-
ster.

Die Funktion liefert TRUE, wenn das Fenster dann als oberstes liegt,
FALSE, wenn nicht. FALSE kann auftreten, wenn Sie versuchen ein Fen-
ster zu toppen, aber noch ein Fenster mit 'force'-Status (siehe auch:
WindowDialog) in Bearbeitung ist.

Das Fenster, welches dann seinen Status als aktuelles Fenster
verliert, erhÑlt eine SG_UNTOP-Nachricht; danach wird das neue Fen-
ster getoppt und erhÑlt von SysGem eine SG_TOP-Nachricht.


!subnode CloseWindow

BOOL CloseWindow ( INT handle );


Diese Funktion versucht, daû durch das AES Handle 'handle' angegebene
Fenster zu schlieûen. Dazu wird dem Fenster eine SG_END Nachricht
verschickt mit dem Parameter, daû der Closer angeklickt worden wÑre.

Schlieût sich das Fenster, liefert die Funktion TRUE, FALSE sonst.


!subnode CloseWindowById

BOOL CloseWindowById ( LONG win_id );


Diese Funktion versucht, daû durch die Fenster-Id 'win_id' angegebene
Fenster zu schlieûen. Dazu wird dem Fenster eine SG_END Nachricht
verschickt mit dem Parameter, daû der Closer angeklickt worden wÑre.

Schlieût sich das Fenster, liefert die Funktion TRUE, FALSE sonst.


!subnode GetHandle

INT GetHandle ( LONG win_id );


Liefert das AES-Handle des Fensters, daû unter der Fenster-Id
'win_id' bekannt ist.

Die Funktion liefert -1, wenn das Fenster nicht existiert.


!subnode GetWindowId

LONG GetWindowId ( INT handle );


Liefert die Fenster-Id des Fensters, welches dem AES unter dem Handle
'handle' bekannt ist.

Die Funktion liefert 0L, wenn das Fenster nicht existiert.


!subnode SetWinMinSize

VOID SetWinMinSize ( LONG win_id, INT w, INT h );


Mit Hilfe dieser Funktion kînnen Sie einem Fenster eine Minimalgrîûe
vorgeben, die nicht unterschritten werden kann. Die Angaben der Grîûe
beziehen sich auf den reinen Netto-Arbeitsbereich!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Fensters, fÅr das die Grîûe gelten soll.

 !item [w]         ist die neue minimale Breite in Pixeln. öbergeben Sie -1,
           erfolgt bei diesem Parameter keine énderung.

 !item [h]         ist die neue minimale Hîhe in Pixeln. öbergeben Sie -1,
           erfolgt bei diesem Parameter keine énderung.
!end_xlist

!subnode SetWinMaxSize

VOID SetWinMaxSize ( LONG win_id, INT w, INT h );


Mit Hilfe dieser Funktion kînnen Sie einem Fenster eine Maximalgrîûe
vorgeben, die nicht Åberschritten werden kann. Die Angaben der Grîûe
beziehen sich auf den reinen Netto-Arbeitsbereich!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Fensters, fÅr das die Grîûe gelten soll.

 !item [w]         ist die neue maximale Breite in Pixeln. öbergeben Sie -1,
           erfolgt bei diesem Parameter keine énderung.

 !item [h]         ist die neue maximale Hîhe in Pixeln. öbergeben Sie -1,
           erfolgt bei diesem Parameter keine énderung.
!end_xlist

!subnode ScrollWindow

VOID ScrollWindow ( INT handle, INT what );


Mit Hilfe dieser Funktion kînnen Sie programmgesteuert einen Fen-
sterinhalt in alle Richtungen scrollen, und zwar so, wie der Benutzer
es mit der Maus auch kann.

Parameter fÅr 'what':
!begin_xlist [xxxxxxxxxxxxxxxx]
 !item [SCROLL_UP]          Scrollt um eine Zeile nach oben.

 !item [SCROLL_DOWN]        Scrollt um eine Zeile nach unten.

 !item [SCROLL_RIGHT]       Scrollt um eine Zeile nach rechts.

 !item [SCROLL_LEFT]        Scrollt um eine Zeile nach links.

 !item [SCROLL_PG_UP]       Scrollt um eine Seite nach oben.

 !item [SCROLL_PG_DOWN]     Scrollt um eine Seite nach unten.

 !item [SCROLL_PG_RIGHT]    Scrollt um eine Seite nach rechts.

 !item [SCROLL_PG_LEFT]     Scrollt um eine Seite nach links.

 !item [SCROLL_HOME]        Scrollt zur Ecke links oben.

 !item [SCROLL_SHIFT_HOME]  Scrollt zur Ecke links unten.
!end_xlist

!subnode SetWindowParm

LONG SetWindowParm ( INT handle, INT what, LONG value, BOOL Redraw  );


öber diese Funktion kînnen Dokumentgrîsse und Position des Aus-
schnitts von einem Fenster abgefragt sowie gesetzt werden.
!begin_xlist [xxxxxx]
 !item [handle]  ist das AES Handle des Fensters

 !item [what]    gibt an, was geÑndert werden soll.
!begin_xlist [xxxxxx]
         !item [SET_X]   Setzt die x-Position (pos_x) des sichtbaren
                 Dokumentsausschnitt. 'value' enthÑlt den
                 neuen Wert.

                 Wird fÅr 'value' -1L Åbergeben, liefert die
                 Funktion die aktuelle x-Position zurÅck.

         !item [SET_Y]   Setzt die y-Position (pos_y) des sichtbaren
                 Dokumentsausschnitt. 'value' enthÑlt den
                 neuen Wert.

                 Wird fÅr 'value' -1L Åbergeben, liefert die
                 Funktion die aktuelle y-Position zurÅck.

         !item [SET_W]   Setzt die Documentbreite (doc_x) des
                 Dokuments. 'value' enthÑlt den neuen Wert.

                 Wird fÅr 'value' -1L Åbergeben, liefert die
                 Funktion die aktuelle Dokumentbreite zurÅck.

         !item [SET_H]  Setzt die Documenthîhe (doc_y) des
                 Dokuments. 'value' enthÑlt den neuen Wert.

                 Wird fÅr 'value' -1L Åbergeben, liefert die
                 Funktion die aktuelle Dokumenthîhe zurÅck.
!end_xlist
	!item [Redraw]	TRUE, dann wird automatisch das Fenster neugezeichnet.
	        Bei FALSE erfolgt dies nicht.
!end_xlist

!subnode SetWinUser

VOID SetWinUser ( LONG win_id, VOID *user );


Ab und zu kann es nîtig sein, den Userzeiger, den Sie ja beim ôffnen
des Fensters angegeben haben, zu Ñndern oder vielleicht erst nachtrÑg-
lich zu setzen. Dabei hilft Ihnen diese Funktion.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Fensters, bei dem der User-Zeiger geÑndert
           werden soll.

 !item [user]      ist der neue Wert, der Åbernommen werden soll.
!end_xlist

!subnode GetWinUser

VOID *GetWinUser ( LONG win_id );


Diese Funktion liefert den User-Zeiger des Fensters, welches unter
der Id 'win_id' bekannt ist.


!subnode SetWinBackground

VOID SetWinBackground ( LONG win_id, INT color );


Normalerweise wird der Fensterhintergrund, bzw. die FlÑche des
Arbeitsbereiches von SysGem in der Farbe Weiû gezeichnet. Gerade aber
in der 3D-Darstellung sieht es sehr schîn aus, wenn der Hintergrund
in Grau gezeichnet wird.

Mit dieser Funktion kînnen Sie die Farbe des Hintergrundes fÅr das
Fenster mit der Id 'win_id' auf die Farbe 'color' setzen.


!subnode SetFulledX

VOID SetFulledX ( INT x );


Beim Eintreffen der Nachricht SG_MOVED, SG_SIZED und SG_FULLED werden
der Handlerfunktion die neuen Koordinaten, die die neue Fenstergrîûe
betreffen, zur Information mitgelteilt. Sollten Sie diese Koordinaten
nicht akzeptieren wollen, kînnen Sie die X-Koordinate innerhalb der
Handlerfunktion auf den Wert setzten, den Sie wÅnschen.

Diese Funktion wird nur beachtet, wenn Sie bei den drei oben genann-
ten Nachrichten verwendet wird.


!subnode SetFulledY

VOID SetFulledY ( INT y );


Beim Eintreffen der Nachricht SG_MOVED, SG_SIZED und SG_FULLED werden
der Handlerfunktion die neuen Koordinaten, die die neue Fenstergrîûe
betreffen, zur Information mitgelteilt. Sollten Sie diese Koordinaten
nicht akzeptieren wollen, kînnen Sie die Y-Koordinate innerhalb der
Handlerfunktion auf den Wert setzten, den Sie wÅnschen.

Diese Funktion wird nur beachtet, wenn Sie bei den drei oben genann-
ten Nachrichten verwendet wird.


!subnode SetFulledW

VOID SetFulledW ( INT w );


Beim Eintreffen der Nachricht SG_MOVED, SG_SIZED und SG_FULLED werden
der Handlerfunktion die neuen Koordinaten, die die neue Fenstergrîûe
betreffen, zur Information mitgelteilt. Sollten Sie diese Koordinaten
nicht akzeptieren wollen, kînnen Sie die Breite innerhalb der Handler-
funktion auf den Wert setzten, den Sie wÅnschen.

Diese Funktion wird nur beachtet, wenn Sie bei den drei oben genann-
ten Nachrichten verwendet wird.


!subnode SetFulledH

VOID SetFulledH ( INT h );


Beim Eintreffen der Nachricht SG_MOVED, SG_SIZED und SG_FULLED werden
der Handlerfunktion die neuen Koordinaten, die die neue Fenstergrîûe
betreffen, zur Information mitgelteilt. Sollten Sie diese Koordinaten
nicht akzeptieren wollen, kînnen Sie die Hîhe innerhalb der Handler-
funktion auf den Wert setzten, den Sie wÅnschen.

Diese Funktion wird nur beachtet, wenn Sie bei den drei oben genann-
ten Nachrichten verwendet wird.


!subnode LinkTree

BOOL LinkTree ( LONG win_id, OBJECT *tree, LONG id, INT pos );


Bindet einen Baum an ein mit OpenWindow geoeffnetes Fenster. (Das
Verfahren bei XWindow gestaltet sich etwas anders, deshalb siehe dort
unter XTREE).
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Fensters, an das der Baum gebunden werden
           soll.

 !item [tree]      ist ein Zeiger auf den Objektbaum, der in das Fenster
           gelegt werden soll. Dieser Baum muû vorher mit NewDialog
           angemeldet worden sein.

 !item [id]        ist die Id, die der Baum erhalten soll. Wird bei SG_BUTTON
           wieder geliefert.

 !item [pos]       ist die Positionsangabe, wo der Baum gezeichnet werden
           soll.

           LINK_TOP zeichnet den Baum unterhalb der (vielleicht)
           vorhandenen MenÅzeile. Die Breite des Baumes wird dabei
           automatisch an die Breite des Fensters angepasst.

           LINK_LEFT zeichnet den Baum an die linke Seite des Fen-
           sters. Die Hîhe des Baumes wird dabei automatisch an die
           Hîhe des Fensters angepasst.

           LINK_RIGHT wie bei LINK_LEFT, nur auf der rechten Seite
           des Fensters.

           LINK_BOTTOM wie bei LINK_TOP, nur am unteren Rand des Fen-
           sters.
!end_xlist
Bitte beachten:
!begin_enumerate
  !item Bei GrîûenÑnderungen des Fensters werden die Positionen und
     Ausmaûe (Breite und auch Hîhe (LINK_TOP/BOTTOM)) automatisch
     angepasst und neu gezeichnet.

  !item Es kînnen beliebig viele BÑume an der gleichen Stelle stehen!

     Somit ist es also ohne Probleme mîglich, z. B. 6 BÑume mit
     LINK_TOP anzumelden. Diese BÑume werden dann in der Reihenfolge
     ihrer Definition gezeichnet und untereinander plaziert.

     Das gleiche gilt natÅrlich auch fÅr die anderen LINK_... Komman-
     dos.
!end_enumerate

!subnode CycleWindow

VOID CycleWindow ( BOOL show_window );


Mit CycleWindow ist es mîglich, die Fenster einzeln durchzugehen,
bzw. nacheinander zu toppen.

Wird fÅr 'show_window' TRUE Åbergeben, erhÑlt der Benutzer einen
Auswahldialog, in dem er das Fenster, welches er gerne toppen will,
auswÑhlen kann.

öbergeben Sie fÅr 'show_window' FALSE, wird das nÑchste Fenster
getoppt, in der Reihenfolge, in der die Fenster auch geîffnet wurden.


!subnode ReSizeWindow

VOID ReSizeWindow ( LONG win_id, RECT *size );


Mit ReSizeWindow ist es mîglich, die Grîûe und/oder Position eines
Fensters mit der Id 'win_id' vom Programm aus zu Ñndern. Dabei werden
der Funktion die (!B)gesamten(!b) Ausmaûe des neuen Bereiches in 'size' Åber-
geben.


!subnode CountWindows

INT CountWindows ( VOID );


Diese Funktion liefert die Anzahl der offenen Fenster des Programms
zurÅck.


!subnode CalcWinTrees

VOID CalcWinTrees ( LONG win_id );


Ab und zu kann es notwendig oder gewÅnscht sein, einen mit LinkTree
an ein Fenster gebundenen Baum entweder in seiner Hîhe oder in seiner
Breite zu verÑndern.

Beim Aufruf dieser Funktion liest SysGem die Breite und Hîhe der
eingelinkten BÑume neu ein und berechnet deren Ausmaûe neu. Das Fen-
ster wird dabei in seiner Grîûe nicht verÑndert, es findet auch kein
automatischer Redraw im Anschluû statt.


!subnode UnLinkTree

BOOL UnLinkTree ( LONG win_id, OBJECT *tree );


Diese Funktion entfernt aus dem Fenster mit der Id 'win_id' den
vorher mit LinkTree Åbernommenen Baum 'tree' und berechnet das Fen-
ster anschlieûend neu.

Die Funktion liefert TRUE, wenn der Baum entfernt wurde, FALSE sonst.


!subnode CheckWindow

VOID CheckWindow ( LONG win_id );


In SysGem darf der Arbeitsbereich eines Fensters immer nur ein
Vielfaches der Scrollbreiten (siehe scroll_... unter OpenWindow)
sein. Beim ôffnen eines Fensters erledigt SysGem dieses von selbst,
aber wenn Sie z. B. eine neue Liste in ein Textfenster hÑngen, so
kann dies nicht immer garantiert werden.

Mit CheckWindow kann das neuberechnen des Fensters vom Programm her
ausgelîst werden.


!subnode GetWindowFont

VOID GetWindowFont ( LONG win_id, INT *font_id, INT *font_pt );


Mit dieser Funktion ist es mîglich, den im Fenster mit der Id
'win_id' eingestellten Font abzufragen.


!node Redrawfunktionen

SysGem bietet fÅr das Redraw bzw. Manipulation von Objekten auch noch
ein paar Funktionen an. Aber sehen Sie selbst:


!subnode LinkOwnRedraw

BOOL LinkOwnRedraw ( OBJECT *tree, INT obj );


Mit dieser Funktion ist es mîglich, ein Objekt nach dem eigentlichen
Zeichnen noch zu manipulieren. So kînnen Sie z. B. in einen Dialog
eine BOX legen, in die Sie z. B. ein Bild legen wollen. Sie melden
dazu einfach mit dieser Funktion diese Box an. Nach dem Redraw, wel-
ches SysGem ausfÅhrt, erhalten Sie dann bei Ihrer Handlerfunktion die
Nachricht SG_DRAWOWN und die benîtigten Koordinaten. Sie kînnen dann
zeichnen, was immer Sie wollen. Die Mîglichkeiten sind dabei nur
durch Ihre Phantasie begrenzt...
!begin_xlist [xxxxxxx]
 !item [tree]    ist ein Zeiger auf den Objektbaum, in dem das Objekt liegt,
         welches Sie anmelden wollen. Der Baum muû vorher mit
         NewDialog angemeldet worden sein.

 !item [obj]     ist die Nummer des Objektes, welches angemeldet werden soll.
!end_xlist
Die Funktion liefert TRUE, wenn das Objekt angemeldet wurde, FALSE
sonst.

Es ist zu empfehlen, bei Eintreffen der Nachricht SG_QUIT, die so an-
gemeldeten Objekte mit RemoveOwnRedraw wieder zu entfernen.


!subnode RemoveOwnRedraw

BOOL RemoveOwnRedraw ( OBJECT *tree, INT obj );


Diese Funktion entfernt das Objekt wieder, welches Sie vorher mit
LinkOwnRedraw angemeldet haben, so daû Sie keine SG_DRAWOWN-Nachricht
fÅr dieses Objekt erhalten.
!begin_xlist [xxxxxxxx]
 !item [tree]    ist ein Zeiger auf den Objektbaum, in dem das Objekt liegt,
         welches Sie abmelden wollen. Das Objekt muû vorher mit
         LinkOwnRedraw angemeldet worden sein.

 !item [obj]     ist die Nummer des Objektes, welches abgemeldet werden soll.
!end_xlist
Die Funktion liefert TRUE, wenn das Objekt abgemeldet wurde, FALSE
sonst.


!subnode RedrawArea

VOID RedrawArea ( INT handle, RECT *area );


Diese Funktion bewirkt ein Neuzeichnen des Rechtecks, welches durch
'area' beschrieben ist, in dem Fenster mit dem AES-Handle 'handle'.

Siehe auch: GetHandle


!subnode SetClipping

VOID SetClipping ( RECT *r );


Diese Funktion setzt das Clipping-Rechteck auf das durch 'r'
be!-schriebene. Diese Funktion ist normalerweise unnîtig; Sie werden
sie hîchstens in absoluten AusnahmefÑllen ihrerseits verwenden
kînnen.


!subnode RedrawWindow

VOID RedrawWindow ( INT handle );


Diese Funktion zeichnet das Fenster mit dem AES-Handle 'handle'
komplett neu.

Wird als handle -1 Åbergegeben, werden alles Fenster neu gezeichnet.

Siehe auch: GetHandle



!subnode RedrawWindowById

BOOL RedrawWindowById ( LONG win_id );

Diese Funktion zeichnet das Fenster mit der Fenster-Id 'win_id' neu.


!subnode RedrawObj
!begin_verbatim
VOID RedrawObj ( OBJECT *tree, INT obj, INT depth, INT state, INT flag );
!end_verbatim

Diese Funktion dient zum Neuzeichnen einzelner Objekte oder ganzer
BÑume, wobei - was wie gezeichnet werden soll - frei konfigurierbar
ist.
!begin_xlist [xxxxxxxx]
 !item [tree]     Zeiger auf den Baum, in dem das zu zeichnende Objekt liegt.
          Dieser Baum muû vorher mit NewDialog angemeldet worden
          sein.

 !item [obj]      Das Objekt, welches neu gezeichnet werden soll.

 !item [depth]    Die Tiefe, mit der gezeichnet werden soll. Bei einem einzel-
          nen Objekt normalerweise 0.

 !item [state]    ein Status, der bei 'flag' beachtet werden soll.

 !item [flag]     gibt an, wie gezeichnet werden soll:

          (!B)SET_STATE(!b) setzt den Status des Objektes auf 'state' (wird
          verodert), wenn er noch nicht gesetzt ist. Ansonsten bricht
          die Funktion ab.

          (!B)DEL_STATE(!b) lîscht den Status des Objektes, wenn er gesetzt
          war. Ansonsten bricht die Funktion ab.

          (!B)UPD_STATE(!b) zeichnet das Objekt neu.

          (!B)FLIP_STATE(!b) setzt den Status 'state' bei dem Objekt, wenn er
          noch nicht gesetzt war oder entfernt ihn, wenn er gesetzt
          war.

          (!B)TAKE_STATE(!b) setzt den Status des Objektes auf 'state'
          (gleichsetzung).

          (!B)USER_STATE(!b) muû zusammen mit UPD_STATE angegeben werden,
          wenn es sich bei dem zu zeichnenden Objekt um eines
          handelt, welches mit LinkOwnRedraw angemeldet wurde.
!end_xlist
Alle diese Werte kînnen verodert werden. Wird fÅr Flag z. B. angege-
ben:

RedrawObj ( ..., ..., ..., SELECTED, SET_STATE | UPD_STATE );


wird das Objekt nur dann neu gezeichnet, wenn der Status SELECTED bei
dem Objekt noch nicht gesetzt war. WÅrde UPD_STATE fehlen, wÅrde der
Status zwar gesetzt, aber das Objekt nicht neu gezeichnet.


!subnode DisableObj

VOID DisableObj ( OBJECT *tree, INT obj, BOOL draw );


Diese Funktion setzt das Objekt mit der Nummer 'obj' im Baum 'tree'
auf DISABLED (nicht anwÑhlbar) und zeichnet es gleichzeitig neu, wenn
'draw' gleich TRUE ist.


!subnode EnableObj

VOID EnableObj ( OBJECT *tree, INT obj, BOOL draw );


Diese Funktion entfernt bei dem Objekt mit der Nummer 'obj' im Baum
'tree' den Status DISABLED (nicht anwÑhlbar) und zeichnet es gleich-
zeitig neu, wenn 'draw' gleich TRUE ist.


!subnode HideObj

VOID HideObj ( OBJECT *tree, INT obj, BOOL draw );


Diese Funktion setzt das Objekt mit der Nummer 'obj' im Baum 'tree'
auf HIDETREE (nicht sichtbar) und zeichnet den Untergrund gleich-
zeitig neu, wenn 'draw' gleich TRUE ist.


!subnode ShowObj

VOID ShowObj ( OBJECT *tree, INT obj, BOOL draw );


Diese Funktion entfernt bei dem Objekt mit der Nummer 'obj' im Baum
'tree' das Flag HIDETREE (nicht sichtbar) und zeichnet es gleich-
zeitig neu, wenn 'draw' gleich TRUE ist.


!node Die Online-Hilfe

Heutige Programme kommen ohne eine Online-Hilfe nicht mehr aus, ist
sie doch einfach zu bedienen und spart eine Menge Papier.

Da sich mittlerweile @{"ST-Guide" LINK "ST-GUIDE.HYP/Main"} von Holger Weets als Standard etabliert
hat, unterstÅtzt SysGem auch dieses Hypertext-System.

Die Verwaltung der Online-Hilfe ist bei SysGem in folgenden beiden
Funktionen zusammengefasst:

!subnode SetOnlineHelp

VOID SetOnlineHelp ( BYTE *name1, BYTE *name2, BYTE *file_name );

!begin_xlist [xxxxxxxxxxx]
 !item [name1]        ist der Name des Programms der Online-Hilfe, wie es im
              Speicher zu finden ist. Bei @{"ST-Guide" LINK "ST-GUIDE.HYP/Main"} halt "ST-GUIDE".

 !item [name2]        ist der Dateiname und Pfad der Online-Hilfe, wenn das
              Programm im Speicher nicht gefunden wurde. Findet
              SysGem das Programm, wird es von der Platte nachgeladen
              und gestartet.

 !item [file_name]    ist der Dateiname des Hypertextes, welches @{"ST-Guide" LINK "ST-GUIDE.HYP/Main"}
              laden soll, z. B. "SYS_GEM2.HYP".
!end_xlist
Siehe auch: CallOnlineHelp


!subnode CallOnlineHelp

BOOL CallOnlineHelp ( BYTE *help )


Diese Funktion ruft das Programm fÅr die Online-Hilfe auf, welches
Sie vorher mit SetOnlineHelp festgelegt haben. Dabei wird als
Stichwort, welche Seite das Programm anzeigen soll, der String 'help'
Åbergeben.

Zuerst sucht SysGem das Programm im Speicher. Findet SysGem es, so
wird versucht, es mit einer AV_START-Meldung zu starten. Ist das Pro-
gramm noch nicht geladen worden, so lÑdt SysGem es nach.

Die Funktion liefert TRUE, wenn die Online-Hilfe gestartet wurde,
FALSE sonst.

Beispiel:

SetOnlineHelp( "ST-GUIDE", "C:\\HELP\\ST-GUIDE.APP", "*:\\SYS_GEM2.HYP"); (!nl)
... (!nl)
CallOnlineHelp ( "Titel" ); (!nl)

wÅrde den (!xlink [ST-Guide] [ST-GUIDE.HYP/Main]) starten mit der Aufforderung, aus dem Hypertext
von SysGem die Seite "Titel" anzuzeigen.


!node Die MenÅzeile

SelbstverstÑndlich unterstÅtzt SysGem auch die ganz normale MenÅ-
zeile. Dazu sind die beiden folgenden Funktionen vorgesehen:

!subnode SetDeskTopMenu

typedef INT ( *MPROC )( INT *msg, INT item );

VOID SetDeskTopMenu ( OBJECT *menu, MPROC proc );


Diese Funktion meldet die MenÅzeile 'menu' als Desktop-MenÅzeile an.
Die Handlerfunktion vom Typ MPROC erhÑlt bei Anwahl den Nachrichten-
Puffer und die Objektnummer des Eintrages, den der Benutzer angewÑhlt
hat. Der Nachrichten-Puffer ist nur belegt, wenn ein MenÅpunkt mit der
Maus ausgewÑhlt wurde, sonst NULL.

Tippt der Benutzer auf die HELP-Taste, wird die Handlerfunktion mit
-1 fÅr 'item' aufgerufen.

Die Handlerfunktion kann SG_CONT oder SG_TERM liefern.  


!subnode RemDeskTopMenu

VOID RemDeskTopMenu ( VOID );


Diese Funktion entfernt die vorher mit SetDeskTopMenu angemeldete
MenÅzeile wieder.

!subnode MenuDivider

VOID MenuDivider ( BOOL disable);


SysGem kann auf wunsch die Trenner innerhalb der Desktop-MenÅzeile
selbst zeichnen. Hierzu muû dieser Funktion FALSE Åbergeben werden.
Bei TRUE lÑût SysGem die Finger von der MenÅzeile.

Die Einstellung muû vor dem Aufruf der Funktion SetDeskTopMenu
erfolgen damit sie eine Wirkung haben soll.

Bei MenÅzeilen in Fenstern werden die Trenner automatisch von SysGem
gezeichnet.


!node Mausfunktionen

SysGem unterstÅtzt alle gebrÑuchlichen Mausformen und noch ein paar
darÅber hinaus, die mir freundlicherweise von Dirk Hagedorn zur
VerfÅgung gestellt wurden. Da er sehr lange daran herumgepixelt hat
und die Teile sehr gut aussehen, ist es viel zu schade, diese nicht
zu benutzen.

!subnode ShowArrow

VOID ShowArrow ( VOID );


Zeigt den Mauscursor als Pfeil.


!subnode ShowBee

VOID ShowBee ( VOID );


Zeigt den Mauscursor als Biene.


!subnode ShowHour

VOID ShowHour ( VOID );


Zeigt den Mauscursor als Biene.


!subnode ShowFinger

VOID ShowFinger ( VOID );


Zeigt den Mauscursor als zeigende Hand.


!subnode ShowHand

VOID ShowHand ( VOID );


Zeigt den Mauscursor als flache Hand.


!subnode ShowThinCross

VOID ShowThinCross ( VOID );


Zeigt den Mauscursor als feines Fadenkreuz.


!subnode ShowThickCross

VOID ShowThickCross ( VOID );


Zeigt den Mauscursor als breites Fadenkreuz.


!subnode ShowOutlineCross

VOID ShowOutlineCross ( VOID );


Zeigt den Mauscursor als umrissenes Fadenkreuz.


!subnode ShowMouse

VOID ShowMouse ( VOID );


Schaltet die Maus ein.


!subnode HideMouse

VOID HideMouse ( VOID );


Schaltet die Maus aus.


!subnode ShowRotor

!begin_verbatim
VOID    ShowRotor       ( VOID );
VOID    UpdateRotor     ( VOID );
VOID    EndRotor        ( VOID );
!end_verbatim

Diese Funktionen animieren einen Mauscursor als rotierende Scheibe.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowClock

!begin_verbatim
VOID    ShowClock       ( VOID );
VOID    UpdateClock     ( VOID );
VOID    EndClock        ( VOID );
!end_verbatim

Diese Funktionen animieren einen Mauscursor als Uhr mit Ziffernblatt,
wobei sich die Zeiger bewegen.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowCoffee

!begin_verbatim
VOID    ShowCoffee      ( VOID );
VOID    UpdateCoffee    ( VOID );
VOID    EndCoffee       ( VOID );
!end_verbatim

Diese Funktionen animieren eine Kaffeetasse mit aufsteigendem Dampf.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowDisc

!begin_verbatim
VOID    ShowDisc        ( VOID );
VOID    UpdateDisc      ( VOID );
VOID    EndDisc         ( VOID );
!end_verbatim

Diese Funktionen animieren eine Diskette mit sich bewengendem
Schuber.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowAbacus

!begin_verbatim
VOID    ShowAbacus      ( VOID );
VOID    UpdateAbacus    ( VOID );
VOID    EndAbacus       ( VOID );
!end_verbatim

Diese Funktionen animieren einen Abacus mit sich bewegenden Kugeln.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowDice

!begin_verbatim
VOID    ShowDice        ( VOID );
VOID    UpdateDice      ( VOID );
VOID    EndDice         ( VOID );
!end_verbatim

Diese Funktionen animieren einen WÅrfel mit den Zahlen 1-6.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!subnode ShowPaper

!begin_verbatim
VOID    ShowPaper       ( VOID );
VOID    UpdatePaper     ( VOID );
VOID    EndPaper        ( VOID );
!end_verbatim

Diese Funktionen animieren einen Drucker, aus dem Papier
hervorquillt.

Die Mausform wird mit 'Show...' dargestellt, mit jedem weiteren
Aufruf von 'Update...' animiert und bei Aufruf von 'End...' wird
wieder auf den Mauspfeil zurÅckgeschaltet.


!node Das Iconify von SysGem

SysGem unterstÅtzt sowohl das Iconify von MultiTos und MagiC3 als
auch unter SingleTos mit (!xlink [ICFS] [ICFS.HYP/Titel]).

Wenn ein Fenster geîffnet wird, bindet SysGem fÅr dieses Fenster
schon ein Standard-Icon ein, welches dann beim Iconify erscheint.
SysGem lÑût Ihnen jedoch mit den folgenden Funktionen viele Freiheiten
in Bezug auf die Konfiguration (Hi Thorsten!)

Ein kleiner öberblick Åber die Funktionen dieses Kapitels:


!subnode LinkImage

VOID LinkImage ( LONG win_id, BITBLK *image, BYTE *text );


Mit dieser Funktion kînnen Sie fÅr ein Fenster ein eigenes Icon
festlegen. Das Bildchen gilt jedoch nur fÅr dieses eine Fenster und
darf eine Grîûe von 32x32 Pixeln nicht Åberschreiten.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Fenster, zum dem das Bildchen gehîren soll.

 !item [image]     ist ein Zeiger auf eine Bitplane, die SysGem dann zen-
           triert im iconifizierten Zustand zeichnet.

 !item [text]      ist ein bis zu 8 Zeichen langer String, der als Text unter
           dem Bild gezeichnet wird.

           öbergeben Sie einen Leerstring, so wird als Bildtitel die
           Id des Fenster genommen.
!end_xlist

!subnode LinkMainImage

VOID LinkMainImage ( BITBLK *image, BYTE *text );


Mit dieser Funktion kînnen Sie fÅr das Programm ein Icon festlegen,
welches gezeichnet wird, wenn alle Fenster in eines zusammengelegt
werden.
!begin_xlist [xxxxxxxx]
 !item [image]     ist ein Zeiger auf eine Bitplane, die SysGem dann zen-
           triert im iconifizierten Fenster zeichnet.

 !item [text]      ist ein bis zu 8 Zeichen langer String, der als Text unter
           dem Bild gezeichnet wird.

           öbergeben Sie einen Leerstring, so wird als Bildtitel die
           Id des Programms (siehe auch InitGem) genommen.
!end_xlist

!subnode SetIconifyName

VOID SetIconifyName ( BYTE *name );


Normalerweise nimmt SysGem die Programm-Id, die Sie bei InitGem ange-
geben haben, als Titel fÅr ein iconifiziertes Fenster. Wenn Sie
jedoch einen anderen Wunsch haben, kînnen Sie hiermit einen neuen
Titel festlegen.

Um wieder auf die Programm-Id umzuschalten, brauchen Sie diese Funk-
tion nur mit einem Leerstring als Parameter aufzurufen.


!subnode SetIconRedraw

typedef VOID ( *IPROC )( LONG win_id, RECT *r );

VOID SetIconRedraw ( LONG win_id, IPROC proc );


Um eine Mîglichkeit zu schaffen, auch Animationen im iconifizierten
Fenster darzustellen, wurde diese Funktion implementiert. Mit dieser
Funktion ist es mîglich, eine Routine anzumelden, die immer dann auf-
gerufen wird, wenn ein iconifiziertes Fenster neuzuzeichnen ist (bei
Animationen dann in Verbindung mit einem Timer).

Die angemeldete Funktion gilt jedoch nur fÅr das Fenster mit der Id
'win_id'.

Die Zeichenroutine wird jeweils mit einem Zeiger auf ein Rechteck auf-
gerufen, welches Sie dann zeichnen mÅssen. Die Zeichenroutine wird
fÅr jedes einzelne Rechteck separat aufgerufen.

Die Maus wird jedoch beim Aufruf nicht versteckt. Wenn Sie also via
dem VDI zeichnen, so mÅssen Sie die Maus selbst abschalten.


!subnode SetLinkIconColor

VOID SetLinkIconColor ( LONG win_id, INT color );


Mit dieser Funktion kann fÅr die Bitplane, die mit LinkImage angemeld-
et wurde, eine Farbe gesetzt werden.
!begin_xlist [xxxxxxxx]
 !item [win_id]    die Id des Fensters, fÅr das die Farbe gelten soll

 !item [color]     die Farbe selbst.
!end_xlist
Siehe auch: SetLinkTextColor


!subnode SetLinkTextColor

VOID SetLinkTextColor ( LONG win_id, INT color );


Mit dieser Funktion kann die Farbe des Textes gesetzt werden, der
unter dem Icon (s.a. LinkImage / SetLinkIconColor) bei der
Iconifizierung erscheint.
!begin_xlist [xxxxxxxx]
 !item [win_id]    die Id des Fensters, fÅr das die Farbe gelten soll

 !item [color]     die Farbe selbst.
!end_xlist

!node Dialogverwaltung

Dialoge sind fÅr ein Programm sehr wichtig, sind sie doch mit das
wichtigste an einem Programm. Aus diesem Grund sind die Dialoge und
deren Konfigurationsmîglichkeiten so ausgelegt, daû der Programmierer
"seinen" Dialog in (fast) jeder wichtigen Eigenschaft beeinflussen
kann. Trotzdem sind die Dialoge in SysGem sehr einfach gehalten, so
daû schnell und vor allem einfach Dialoge genutzt werden kînnen.

(!B)Was Sie unbedingt beachten mÅssen:(!b)

Alle BÑume, die Sie in Fenstern oder als Dialog benutzen wollen,
mÅssen vor deren Benutzung mit Hilfe der Funktion NewDialog angemeld-
et werden! Das hat folgenden Grund:

SysGem verwaltet die fÅr die Verwaltung der Dialoge notwendigen
Strukturen dynamisch, ist also nicht mehr - wie in der 1.x - auf eine
bestimmte Anzahl begrenzt. Durch die 3D-Darstellung bedingt werden
auch die SysGem eigenen Zeichenroutinen "eingeklinkt", die Objekt-
typen also in USERDEF gewandelt. Dies hat zur Folge, daû Sie (!B)nie(!b)
schreibend auf ein Text- oder String-Objekt zugreifen dÅrfen, da die
Zeiger nicht auf den Text, sondern auf die Zeichenroutine zeigen. Und
wenn Sie da was reinschreiben, ist es logisch, daû das Programm
abstÅrzen wird.

Hier mal eine kurze öbersicht Åber die Dialogfunktionen:


!subnode NewDialog

BOOL NewDialog ( OBJECT *tree );


Diese Funktion meldet einen Objektbaum bei SysGem an und meldet TRUE,
wenn alles glatt ging, FALSE im Fehlerfalle. Beim Anmelden geschieht
folgendes:
!begin_enumerate
  !item SysGem prÅft, ob die Baumadresse schon einmal vorkommt bzw. ange-
     meldet wurde. Sollte dies der Fall sein, liefert die Funktion
     FALSE und alle weiteren Funktionen, denen Sie diese Baumadresse
     anbieten, werden mit einer Fehlermeldung abbrechen.

  !item Die Zeichenroutinen fÅr die erweiterten Objekttypen werden
     eingetragen.

  !item Der Dialog wird neben einigen weiteren - fÅr SysGem wichtigen -
     Daten gespeichert.
!end_enumerate
NatÅrlich kînnte dies alles auch zur Laufzeit geschehen, allerdings
habe ich mich aus Verwaltungs- und GeschwindigkeitsgrÅnden fÅr diese
Form entschieden.

(!B)Bitte beachten:(!b)

Da die Objekte in Userdef gewandelt werden, darf auf alles, was mit
ob_spec zu tun hat, niemals schreibend zugegriffen werden! Dieses
wÅrde katastrophale Folgen nach sich ziehen!

Siehe auch: DelDialog


!subnode DelDialog

BOOL DelDialog ( OBJECT *tree );


Diese Funktion meldet einen mit NewDialog angemeldeten Dialog wieder
ab, was dazu fÅhrt, daû SysGem alle internen Strukturen, die zu
diesem Baum gehîren, wieder freigibt. Ein erneutes Anmelden mit
NewDialog ist mîglich.

Diese Funktion ist eigentlich nur fÅr interne Zwecke gedacht, sollte
und braucht eigentlich von Ihnen nie aufgerufen zu werden, da dies
die Funktion ExitGem schon von selbst erledigt.

Siehe auch: NewDialog


!subnode WindowDialog
!begin_verbatim
BOOL WindowDialog ( LONG    id,
                    INT     xpos,
                    INT     ypos,
                    BYTE    *name,
                    BYTE    *info,
                    BOOL    shut,
                    BOOL    force,
                    OBJECT  *tree,
                    OBJECT  *menu,
                    INT     edit,
                    VOID    *user,
                    DPROC   proc );
!end_verbatim

WindowDialog erstellt und zeichnet einen Fensterdialog. Der Dialog,
der dargestellt werden soll, muû vorher mit NewDialog angemeldet
worden sein; ansonsten erscheint kein Fenster und die Funktion
liefert FALSE.

WindowDialog liefert dann TRUE, wenn das Fenster geîffnet wurde,
FALSE, wenn ein Fehler auftrat, bzw. das Fenster nicht geîffnet wer-
den konnte.
!begin_xlist [xxxxxxx]
 !item [id]       ist die Fenster-Id des Dialogs. So wÑre z. B. 'MAIN' fÅr
          den Hauptdialog eine passende Id; Sie kînnen allerdings
          jede Ihnen passende Id vergeben - bis auf 0L.

          Die ID wird spÑter bei allen Nachrichten von SysGem an die
          Handlerfunktion Åbermittelt.

 !item [xpos]     ist die X-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in X-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [ypos]     ist die Y-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in Y-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [name]    ist ein Zeiger auf den Namen des Dialogs, der als Fen-
          stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
          vor und hinter den Namen jeweils ein Leerzeichen, so daû
          Sie es im Programm nicht immer machen mÅssen (spart immer 2
          Byte :-))

          Vor den ganzen Text setzt SysGem - wenn das Programm in
          einer Multitasking-Umgebung lÑuft - immer den Pro-
          grammnamen, der automatisch von InitGem Åbernommen wird
          (Sie haben ihn ja dort angegeben), um dem Benutzer zu
          zeigen, zu welchem Prozeû das Fesnter gehîrt.

          Sollte als erstes Zeichen ein Balken ('|') stehen, so
          Åbernimmt SysGem den gesamten String ohne irgendwelche
          énderungen.

 !item [info]     Wird hier ein Text Åbergeben, so setzt SysGem diesen Text
          in die Infozeile des Fensters. Der Text wird nicht
          verÑndert.

          Geben Sie statt einem Text einen Leerstring an, so er-
          scheint keine Infozeile im Fenster.

 !item [shut]     öbergeben Sie hier TRUE, so erhÑlt der Fensterdialog einen
          Closer (bei FALSE eben keinen). Sollte der Closer vom
          Benutzer angeklickt werden, so wird bei SG_END fÅr 'button'
          eine -1 geliefert, damit Sie genau unterscheiden kînnen,
          was angeklickt wurde.

 !item [force]    öbergeben Sie hier TRUE, so kann nur dieser Dialog im Pro-
          gramm bearbeitet werden. So lassen sich dann, solange
          dieser Dialog bearbeitet wird, keine anderen Fenster in den
          Vordergrund holen oder die Desktop-MenÅzeile bearbeiten.

          Es dÅrfen auch keine weiteren Dialoge geîffnet werden, es
          sei denn, auch diese haben bei 'force' TRUE angegeben.

 !item [tree]     ist ein Zeiger auf den Objektbaum, der als Dialog im Fen-
          ster dargestellt werden soll. Er muû vorher mit NewDialog
          angemeldet worden sein, ansonsten wird das Fenster nicht
          erscheinen!

 !item [menu]     ist ein Zeiger auf einen Baum, der als MenÅzeile erscheinen
          soll. öbergeben Sie NULL, wird keine MenÅzeile ans Fenster
          gebunden.

 !item [edit]     ist die Objektnummer eines Editfeldes, in das der Cursor
          beim ôffnen des Dialog gesetzt werden soll.

          öbergeben Sie eine 0, wird kein Cursor gezeichnet und
          SysGem nimmt an, daû in dem Dialog kein Editfeld existiert,
          bzw. ein Editieren nicht erwÅnscht ist.

          öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
          matisch in das erste Editfeld.

 !item [user]     ist ein beliebiger Zeiger, den Sie dem Fenster mitgeben
          kînnen. FÅr was er gut ist, bestimmen ja Sie. Dieser Zeiger
          wird in der DIALOG_INFO Struktur der jeweiligen Handlerfunk-
          tion immer mitgegeben.

 !item [proc]     ist ein Zeiger auf die eigentliche Handlerfunktion, die
          alle Nachrichten von SysGem erhÑlt und auswerten muû.

          Sollten Sie hier einfach NULL Åbergeben, so erscheint der
          Dialog trotzdem. Er wird jedoch bei der ersten
          BenutzeraktivitÑt, die eine SG_END Nachricht zur Folge hat,
          wieder geschlossen. Diese Vorgehensweise eignet sich z. B.
          sehr gut fÅr einen Info-Dialog, der normalerweise ja nur
          einen OK-Button besitzt und geschlossen werden soll, wenn
          der Benutzer diesen anklickt.
!end_xlist
Sollten Sie WindowDialog eine Fenster-Id Åbergeben, die schon
existiert (das Fenster befindet sich auf dem Bildschirm) wird das
bereits offene Fenster getoppt und die Funktion liefert TRUE zurÅck.

Es ist somit niemals mîglich, mehrere Fenster unter der gleichen Id
auf dem Bildschirm geîffnet zu haben.


!subnode xWindowDialog
!begin_verbatim
BOOL xWindowDialog ( LONG    id,
                     INT     xpos,
                     INT     ypos,
                     BYTE    *name,
                     BYTE    *info,
                     BOOL    shut,
                     BOOL    force,
                     OBJECT  *tree,
                     OBJECT  *menu,
                     INT     edit,
                     VOID    *user,
                     DPROC   proc );
!end_verbatim

xWindowDialog erstellt und zeichnet einen Fensterdialog. Im Gegensatz
zu WindowDialog (und so wie bei DoDialog) stoppt dabei allerdings die
ProgrammausfÅhrung, d.h., das Programm lÑuft erst dann weiter, wenn
der Fensterdialog geschlossen wurde.

Der Dialog, der dargestellt werden soll, muû vorher mit NewDialog an-
gemeldet worden sein; ansonsten erscheint kein Fenster und die Funk-
tion liefert FALSE.

xWindowDialog liefert dann TRUE, wenn das Fenster geîffnet wurde,
FALSE, wenn ein Fehler auftrat, bzw. das Fenster nicht geîffnet wer-
den konnte.
!begin_xlist [xxxxxxx]
 !item [id]       ist die Fenster-Id des Dialogs. So wÑre z. B. 'MAIN' fÅr
          den Hauptdialog eine passende Id; Sie kînnen allerdings
          jede Ihnen passende Id vergeben - bis auf 0L.

          Die ID wird spÑter bei allen Nachrichten von SysGem an die
          Handlerfunktion Åbermittelt.

 !item [xpos]     ist die X-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in X-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [ypos]     ist die Y-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in Y-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [name]     ist ein Zeiger auf den Namen des Dialogs, der als Fen-
          stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
          vor und hinter den Namen jeweils ein Leerzeichen, so daû
          Sie es im Programm nicht immer machen mÅssen (spart immer 2
          Byte :-))

          Vor den ganzen Text setzt SysGem - wenn das Programm in
          einer Multitasking-Umgebung lÑuft - immer den Pro-
          grammnamen, der automatisch von InitGem Åbernommen wird
          (Sie haben ihn ja dort angegeben), um dem Benutzer zu
          zeigen, zu welchem Prozeû das Fesnter gehîrt.

          Sollte als erstes Zeichen ein Balken ('|') stehen, so
          Åbernimmt SysGem den gesamten String ohne irgendwelche
          énderungen.

 !item [info]     Wird hier ein Text Åbergeben, so setzt SysGem diesen Text
          in die Infozeile des Fensters. Der Text wird nicht
          verÑndert.

          Geben Sie statt einem Text einen Leerstring an, so er-
          scheint keine Infozeile im Fenster.

 !item [shut]     öbergeben Sie hier TRUE, so erhÑlt der Fensterdialog einen
          Closer (bei FALSE eben keinen). Sollte der Closer vom
          Benutzer angeklickt werden, so wird bei SG_END fÅr 'button'
          eine -1 geliefert, damit Sie genau unterscheiden kînnen,
          was angeklickt wurde.

 !item [force]    öbergeben Sie hier TRUE, so kann nur dieser Dialog im Pro-
          gramm bearbeitet werden. So lassen sich dann, solange
          dieser Dialog bearbeitet wird, keine anderen Fenster in den
          Vordergrund holen oder die Desktop-MenÅzeile bearbeiten.

          Es dÅrfen auch keine weiteren Dialoge geîffnet werden, es
          sei denn, auch diese haben bei 'force' TRUE angegeben.

 !item [tree]     ist ein Zeiger auf den Objektbaum, der als Dialog im Fen-
          ster dargestellt werden soll. Er muû vorher mit NewDialog
          angemeldet worden sein, ansonsten wird das Fenster nicht
          erscheinen!

 !item [menu]     ist ein Zeiger auf einen Baum, der als MenÅzeile erscheinen
          soll. öbergeben Sie NULL, wird keine MenÅzeile ans Fenster
          gebunden.

 !item [edit]     ist die Objektnummer eines Editfeldes, in das der Cursor
          beim ôffnen des Dialog gesetzt werden soll.

          öbergeben Sie eine 0, wird kein Cursor gezeichnet und
          SysGem nimmt an, daû in dem Dialog kein Editfeld existiert,
          bzw. ein Editieren nicht erwÅnscht ist.

          öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
          matisch in das erste Editfeld.

 !item [user]     ist ein beliebiger Zeiger, den Sie dem Fenster mitgeben
          kînnen. FÅr was er gut ist, bestimmen ja Sie. Dieser Zeiger
          wird in der DIALOG_INFO Struktur der jeweiligen Handlerfunk-
          tion immer mitgegeben.

 !item [proc]     ist ein Zeiger auf die eigentliche Handlerfunktion, die
          alle Nachrichten von SysGem erhÑlt und auswerten muû.

          Sollten Sie hier einfach NULL Åbergeben, so erscheint der
          Dialog trotzdem. Er wird jedoch bei der ersten
          BenutzeraktivitÑt, die eine SG_END Nachricht zur Folge hat,
          wieder geschlossen. Diese Vorgehensweise eignet sich z. B.
          sehr gut fÅr einen Info-Dialog, der normalerweise ja nur
          einen OK-Button besitzt und geschlossen werden soll, wenn
          der Benutzer diesen anklickt.
!end_xlist
Sollten Sie xWindowDialog eine Fenster-Id Åbergeben, die schon
existiert (das Fenster befindet sich auf dem Bildschirm) wird das
bereits offene Fenster getoppt und die Funktion liefert TRUE zurÅck.

Es ist somit niemals mîglich, mehrere Fenster unter der gleichen Id
auf dem Bildschirm geîffnet zu haben.


!subnode DPROC

typedef INT ( *DPROC )( INT msg, INT button, DIALOG_INFO *inf );


Eine Handlerfunktion fÅr einen Fensterdialog muû immer von obigem Typ
sein.

Bei einem Aufruf werden an 'msg' die Nachrichten von SysGem, an
'button' ein Wert abhÑngig von der Nachricht und in 'inf' ein Zeiger
auf die DIALOG_INFO Struktur Åbergeben.

Als RÅckgabewert wird immer ein INT erwartet; siehe dazu bei "Nach-
richten an SysGem".


!subnode DoDialog

INT DoDialog ( OBJECT *tree, INT edit, BYTE *title );


DoDialog ist eine Kurzform von WindowDialog. DoDialog stellt den
gewÑlten Dialog zwar auch in einem Fenster dar, hat aber keine
Handlerfunktion.

Der Dialog bleibt solange auf dem Bildschirm, bis er vom Benutzer
oder vom Programm geschlossen wird. Dabei verhÑlt sich das Fenster
so, wie unter WindowDialog beim Parameter 'force' beschrieben.
!begin_xlist [xxxxxxx]
 !item [tree]     ist der Zeiger auf den Dialog, der im Fenster dargestellt
          werden soll. Dieser muû vorher mittels NewDialog angemeldet
          worden sein.

 !item [edit]     ist die Objektnummer eines Editfeldes, in das der Cursor
          beim ôffnen des Dialog gesetzt werden soll.

          öbergeben Sie eine 0, wird kein Cursor gezeichnet und
          SysGem nimmt an, daû in dem Dialog kein Editfeld existiert,
          bzw. ein Editieren nicht erwÅnscht ist.

          öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
          matisch in das erste Editfeld.

 !item [title]    ist ein Zeiger auf den Namen des Dialogs, der als Fen-
          stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
          vor und hinter den Namen jeweils ein Leerzeichen, so daû
          Sie es im Programm nicht immer machen mÅssen (spart immer 2
          Byte :-))

          Vor den ganzen Text setzt SysGem - wenn das Programm in
          einer Multitasking-Umgebung lÑuft - immer den Pro-
          grammnamen, der automatisch von InitGem Åbernommen wird
          (Sie haben ihn ja dort angegeben), um dem Benutzer zu
          zeigen, zu welchem Prozeû das Fesnter gehîrt.

          Sollte als erstes Zeichen ein Balken ('|') stehen, so
          Åbernimmt SysGem den gesamten String ohne irgendwelche
          énderungen.
!end_xlist
Die Funktion liefert als RÅckgabewert die Objektnummer des Buttons,
der einen Abbruch verursacht hat (siehe auch unter SG_END).


!subnode BeginDialog

BOOL BeginDialog ( LONG win_id, OBJECT *tree, INT edit, BYTE *title );


WÑhrend DoDialog dem Programmierer keine Mîglichkeit bietet, auf die
BenutzeraktivitÑten (z. B. Anklicken eines Buttons) zu reagieren,
bieten diese und die folgenden zwei Funktionen die Mîglichkeit der
manuellen Dialogverarbeitung.

BeginDialog îffnet einen Fensterdialog (und mehr nicht). Die Benutzer-
eingaben werden von HandleDialog geliefert.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist eine eindeutige Fenster-Id,

 !item [tree]      ist der Zeiger auf den Dialog, der im Fenster dargestellt
           werden soll. Dieser muû vorher mittels NewDialog angemeld-
           et worden sein.

 !item [edit]      ist die Objektnummer eines Editfeldes, in das der Cursor
           beim ôffnen des Dialog gesetzt werden soll.

           öbergeben Sie eine 0, wird kein Cursor gezeichnet und
           SysGem nimmt an, daû in dem Dialog kein Editfeld
           existiert, bzw. ein Editieren nicht erwÅnscht ist.

           öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
           matisch in das erste Editfeld.

 !item [title]     ist ein Zeiger auf den Namen des Dialogs, der als Fen-
           stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
           vor und hinter den Namen jeweils ein Leerzeichen, so daû
           Sie es im Programm nicht immer machen mÅssen (spart immer
           2 Byte :-))

           Vor den ganzen Text setzt SysGem dann - wenn das Programm
           in einer Multitasking-Umgebung lÑuft - immer den Pro-
           grammnamen, der automatisch von InitGem Åbernommen wird.
           Sie kînnen ihn aber jederzeit mit SetProgramName umÑndern.

           Sollte als erstes Zeichen ein Balken ('|') stehen, so
           Åbernimmt SysGem den gesamten String ohne énderungen als
           Fenstertitel, bzw. Dialognamen.
!end_xlist
Die Funktion liefert TRUE, wenn das Fenster geîffnet wurde, FALSE
sonst.


!subnode HandleDialog

INT HandleDialog ( LONG win_id );


Die Funktion verwaltet alle BenutzeraktivitÑten des Fensters mit der
Id 'win_id', das vorher mit BeginDialog geîffnet wurde.

HandleDialog liefert die Objektnummer des Buttons zurÅck, auf den der
Benutzer geklickt hat und der den EXIT oder TOUCHEXIT Status hat.

Das Fenster bleibt weiterhin geîffnet. Sie kînnen jederzeit wieder
HandleDialog aufrufen, wenn Sie noch auf andere AktivitÑten des
Benutzers warten.

Soll das Fenster geschlossen werden, mÅssen Sie es selbst mit
FinishDialog schlieûen.


!subnode FinishDialog

VOID FinishDialog ( LONG win_id );


Das Fenster mit der Id 'win_id', das Sie vorher mit BeginDialog
geîffnet haben, wird mit Aufruf dieser Funktion geschlossen und
wieder vom Bildschirm entfernt.


!subnode MultipleDialog
!begin_verbatim
BOOL MultipleDialog ( LONG   id,
                      INT    xpos,
                      INT    ypos,
                      BYTE   *name,
                      BYTE   *info,
                      OBJECT *top,
                      INT    active,
                      OBJECT *tree,
                      OBJECT *menu,
                      INT    edit,
                      VOID   *user,
                      DPROC  proc );
!end_verbatim

!image  IMG412.IMG Die sogenannten Reiter in SysGem (monochrom)

!image IMG411.IMG ...und gedithert in Farbe und 3D...

Diese Funktion stellt mehrere Dialoge in einem Fenster zur VerfÅgung,
unter denen mit Hilfe der Reiter hin- und hergeschaltet werden kann.
Die Programmierung unterscheidet sich lediglich in 2 Zeilen zu der
von WindowDialog (und der Aufruf hat einen Parameter weniger).
!begin_xlist [xxxxxxxx]
 !item [id]       ist die Fenster-Id des Dialogs.

          Die ID wird spÑter bei allen Nachrichten von SysGem an die
          Handlerfunktion Åbermittelt.

 !item [xpos]     ist die X-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in X-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [ypos]     ist die Y-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in Y-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [name]     ist ein Zeiger auf den Namen des Dialogs, der als Fen-
          stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
          vor und hinter den Namen jeweils ein Leerzeichen, so daû
          Sie es im Programm nicht immer machen mÅssen (spart immer 2
          Byte :-))

          Vor den ganzen Text setzt SysGem dann - wenn das Programm
          in einer Multitasking-Umgebung lÑuft - immer den Pro-
          grammnamen, der automatisch von InitGem Åbernommen wird.
          Sie kînnen ihn aber jederzeit mit SetProgramName umÑndern.

          Sollte als erstes Zeichen ein Balken ('|') stehen, so
          Åbernimmt SysGem den gesamten String ohne énderungen als
          Fenstertitel, bzw. Dialognamen.

 !item [info]     Wird hier ein Text Åbergeben, so setzt SysGem diesen Text
          in die Infozeile des Fensters. Der Text wird nicht
          verÑndert.

          Geben Sie statt einem Text einen Leerstring an, so er-
          scheint keine Infozeile im Fenster.

 !item [top]      ist ein Zeiger auf den Objektbaum, der die Reiter als
          Objekte enthÑlt. Dieser Baum muû vorher mit NewDialog ange-
          meldet worden sein.

 !item [active]   ist die Objektnummer des Reiters, der beim Zeichnen aktiv
          sein soll.

 !item [tree]     ist ein Zeiger auf den Objektbaum, der als Dialog im Fen-
          ster dargestellt werden soll, bzw. ist der zum Reiter
          'active' korrespondierende Objektbaum/Dialog. Er muû vorher
          mit NewDialog angemeldet worden sein, ansonsten wird das
          Fenster nicht erscheinen!

 !item [menu]     ist ein Zeiger auf einen Baum, der als MenÅzeile erscheinen
          soll. öbergeben Sie NULL, wird keine MenÅzeile ans Fenster
          gebunden.

 !item [edit]     ist die Objektnummer eines Editfeldes, in das der Cursor
          beim ôffnen des Dialog gesetzt werden soll. Die Objekt-
          nummer bezieht sich auf den Dialog, der als erstes gezeich-
          net werden soll (tree).

          öbergeben Sie eine 0, wird kein Cursor gezeichnet und
          SysGem nimmt an, daû in dem Dialog kein Editfeld existiert,
          bzw. ein Editieren nicht erwÅnscht ist.

          öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
          matisch in das erste Editfeld.

 !item [user]     ist ein beliebiger Zeiger, den Sie dem Fenster mitgeben
          kînnen. FÅr was er gut ist, bestimmen ja Sie. Dieser Zeiger
          wird in der DIALOG_INFO Struktur der jeweiligen Handlerfunk-
          tion immer mitgegeben.

 !item [proc]     ist ein Zeiger auf die eigentliche Handlerfunktion, die
          alle Nachrichten von SysGem erhÑlt und auswerten muû. Im
          Gegensatz zu WindowDialog ist hier ein NULL-Zeiger nicht
          erlaubt und auch nicht mîglich, da ja irgendwie die Reiter
          verwaltet werden wollen.
!end_xlist
Die Funktion liefert TRUE, wenn das Fenster geîffnet werden konnte
und schickt der Handlerfunktion die Nachricht SG_START.

Im Fehlerfalle (z. B. ist der zu zeichnende Objektbaum nicht vorher
mit NewDialog angemeldet worden) liefert die Funktion FALSE und die
Handlerfunktion erhÑlt zur BestÑtigung noch die Nachricht SG_NOWIN.

Der Benutzer kann nun mit einem Mausklick auf einen Reiter die ent-
sprechenden Dialoge wÑhlen. Dazu wird dann an die Handlerfunktion die
Nachricht SG_NEWDIAL geschickt und die Handlerfunktion muû dann
entweder mit SG_CONT oder SG_TAKEDIAL antworten.

!subnode xMultipleDialog
!begin_verbatim
BOOL xMultipleDialog ( LONG   id,
                      INT    xpos,
                      INT    ypos,
                      BYTE   *name,
                      BYTE   *info,
                      OBJECT *top,
                      INT    active,
                      OBJECT *tree,
                      INT    edit,
                      VOID   *user,
                      DPROC  proc );
!end_verbatim

!image IMG412.IMG Die sogenannten Reiter in SysGem (monochrom)


!image IMG411.IMG ...und gedithert in Farbe und 3D...

xMultipleDialog erstellt und zeichnet einen Fensterdialog mit Reitern.
Im Gegensatz zu MultipleDialog stoppt dabei allerdings die Programm- 
ausfÅhrung, d.h., das Programm lÑuft erst dann weiter, wenn der Fenster-
dialog geschlossen wurde.

Diese Funktion stellt mehrere Dialoge in einem Fenster zur VerfÅgung,
unter denen mit Hilfe der Reiter hin- und hergeschaltet werden kann.
Die Programmierung unterscheidet sich lediglich in 2 Zeilen zu der
von WindowDialog (und der Aufruf hat einen Parameter weniger).
!begin_xlist [xxxxxxxxxxx]
 !item [id]       ist die Fenster-Id des Dialogs.

          Die ID wird spÑter bei allen Nachrichten von SysGem an die
          Handlerfunktion Åbermittelt.

 !item [xpos]     ist die X-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in X-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [ypos]     ist die Y-Koordinate, an der der Dialog erscheinen soll.
          öbergeben Sie -1, wird der Dialog in Y-Richtung zentriert
          ausgegeben, wenn Sie nicht mit DialPosXY etwas anderes
          eingestellt haben.

 !item [name]     ist ein Zeiger auf den Namen des Dialogs, der als Fen-
          stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
          vor und hinter den Namen jeweils ein Leerzeichen, so daû
          Sie es im Programm nicht immer machen mÅssen (spart immer 2
          Byte :-))

          Vor den ganzen Text setzt SysGem dann - wenn das Programm
          in einer Multitasking-Umgebung lÑuft - immer den Pro-
          grammnamen, der automatisch von InitGem Åbernommen wird.
          Sie kînnen ihn aber jederzeit mit SetProgramName umÑndern.

          Sollte als erstes Zeichen ein Balken ('|') stehen, so
          Åbernimmt SysGem den gesamten String ohne énderungen als
          Fenstertitel, bzw. Dialognamen.

 !item [info]     Wird hier ein Text Åbergeben, so setzt SysGem diesen Text
          in die Infozeile des Fensters. Der Text wird nicht
          verÑndert.

          Geben Sie statt einem Text einen Leerstring an, so er-
          scheint keine Infozeile im Fenster.

 !item [top]      ist ein Zeiger auf den Objektbaum, der die Reiter als
          Objekte enthÑlt. Dieser Baum muû vorher mit NewDialog ange-
          meldet worden sein.

 !item [active]   ist die Objektnummer des Reiters, der beim Zeichnen aktiv
          sein soll.

 !item [tree]     ist ein Zeiger auf den Objektbaum, der als Dialog im Fen-
          ster dargestellt werden soll, bzw. ist der zum Reiter
          'active' korrespondierende Objektbaum/Dialog. Er muû vorher
          mit NewDialog angemeldet worden sein, ansonsten wird das
          Fenster nicht erscheinen!

 !item [edit]     ist die Objektnummer eines Editfeldes, in das der Cursor
          beim ôffnen des Dialog gesetzt werden soll. Die Objekt-
          nummer bezieht sich auf den Dialog, der als erstes gezeich-
          net werden soll (tree).

          öbergeben Sie eine 0, wird kein Cursor gezeichnet und
          SysGem nimmt an, daû in dem Dialog kein Editfeld existiert,
          bzw. ein Editieren nicht erwÅnscht ist.

          öbergeben Sie eine -2, so setzt SysGem den Cursor auto-
          matisch in das erste Editfeld.

 !item [user]     ist ein beliebiger Zeiger, den Sie dem Fenster mitgeben
          kînnen. FÅr was er gut ist, bestimmen ja Sie. Dieser Zeiger
          wird in der DIALOG_INFO Struktur der jeweiligen Handlerfunk-
          tion immer mitgegeben.

 !item [proc]     ist ein Zeiger auf die eigentliche Handlerfunktion, die
          alle Nachrichten von SysGem erhÑlt und auswerten muû. Im
          Gegensatz zu WindowDialog ist hier ein NULL-Zeiger nicht
          erlaubt und auch nicht mîglich, da ja irgendwie die Reiter
          verwaltet werden wollen.
!end_xlist
Die Funktion liefert TRUE, wenn das Fenster geîffnet werden konnte
und schickt der Handlerfunktion die Nachricht SG_START.

Im Fehlerfalle (z. B. ist der zu zeichnende Objektbaum nicht vorher
mit NewDialog angemeldet worden) liefert die Funktion FALSE und die
Handlerfunktion erhÑlt zur BestÑtigung noch die Nachricht SG_NOWIN.

Der Benutzer kann nun mit einem Mausklick auf einen Reiter die ent-
sprechenden Dialoge wÑhlen. Dazu wird dann an die Handlerfunktion die
Nachricht SG_NEWDIAL geschickt und die Handlerfunktion muû dann
entweder mit SG_CONT oder SG_TAKEDIAL antworten.


!subnode SetText

VOID SetText ( OBJECT *tree, INT index, BYTE *text );


Diese Funktion setzt einen Text fÅr ein beliebiges Objekt.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [text]     ist ein Zeiger auf den Text, der Åbernommen werden soll.
!end_xlist
Wollen Sie den Text eines Buttons verÑndern, so sollten Sie statt
dieser besser die Funktion ChangeButton verwenden, da bei
ChangeButton auch eine énderung des Shortcuts erfolgen kann.

!subnode xSetText

VOID xSetText ( OBJECT *tree, INT index, BYTE *text );


Diese Funktion setzt einen Text fÅr ein beliebiges Objekt.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [text]     ist ein Zeiger auf den Text, der Åbernommen werden soll.
!end_xlist
Im Gegensatz zu SetText wird bei den Objekttypen G_FTEXT,
G_FBOXTEXT, G_TEXT und G_BOXTEXT die Justierung des Text beachtet.

Wollen Sie den Text eines Buttons verÑndern, so sollten Sie statt
dieser besser die Funktion ChangeButton verwenden, da bei
ChangeButton auch eine énderung des Shortcuts erfolgen kann.


!subnode GetText

BYTE *GetText ( OBJECT *tree, INT index, BYTE *text );


Diese Funktion liest den Text eines Objektes aus.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [text]     ist ein Zeiger auf einen String, in den der Text des
          Objektes geschrieben wird. Achten Sie darauf, daû dieser
          Speicherbereich groû genug ist!
!end_xlist
Die Funktion liefert als Ergebnis die Adresse von 'text' zurÅck, so
daû Sie die Funktion selbst als Argument Åbergeben kînnen.

Geben Sie bei 'text' NULL an, so liefert die Funktion die Adresse des
Textes von dem Objekt zurÅck.

!subnode SetBoxChar

VOID SetBoxChar	( OBJECT *tree, INT index, BYTE c );


Diese Funktion setzt das Zeichen fÅr ein Objekt des Typs G_BXCHAR aus.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [c]        Zeichen das Åbernommen werden soll.
!end_xlist

!subnode GetBoxChar

VOID GetBoxChar ( OBJECT *tree, INT index, BYTE *c );


Diese Funktion liest das Zeichen eines Objekt des Typs G_BOXCHAR aus.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [c]        ist ein Zeiger auf eine BYTE Variable in der das Zeichen
          Åbergeben wird.
!end_xlist
Die Funktion liefert als Ergebnis TRUE wenn das Zeichen ermittel werden
konnte, sonst FALSE.

!subnode SetInt

VOID SetInt ( OBJECT *tree, INT index, INT Wert );


Diese Funktion setzt eine Integerzahl in ein Text-Objekt.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [Wert]     Zahl die in das Objekt Åbernommen werden soll.
!end_xlist
Wollen Sie den Text eines Buttons verÑndern, so sollten Sie statt
dieser besser die Funktion ChangeButton verwenden, da bei
ChangeButton auch eine énderung des Shortcuts erfolgen kann.

!subnode GetInt

INT GetInt ( OBJECT *tree, INT index );


Diese Funktion liest aus einem Text-Objektes die Zeichenkette und
versucht sie als Integerzahl zu interpretieren.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.
!end_xlist
Die Funktion liefert als Ergebnis den Wert zurÅck oder 0 falls der
Text nicht numerisch auswertbar ist.

!subnode SetLong

VOID SetLong ( OBJECT *tree, INT index, LONG Wert );


Diese Funktion setzt eine Integerzahl (long) in ein Text-Objekt.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [Wert]     Zahl die in das Objekt Åbernommen werden soll.
!end_xlist
Wollen Sie den Text eines Buttons verÑndern, so sollten Sie statt
dieser besser die Funktion ChangeButton verwenden, da bei
ChangeButton auch eine énderung des Shortcuts erfolgen kann.

!subnode SetULong

VOID SetULong ( OBJECT *tree, INT index, ULONG Wert );


Diese Funktion setzt eine Integerzahl (unsigned long) in ein Text-Objekt.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.

 !item [Wert]     Zahl die in das Objekt Åbernommen werden soll.
!end_xlist
Wollen Sie den Text eines Buttons verÑndern, so sollten Sie statt
dieser besser die Funktion ChangeButton verwenden, da bei
ChangeButton auch eine énderung des Shortcuts erfolgen kann.

!subnode GetLong

LONG GetLong ( OBJECT *tree, INT index );


Diese Funktion liest aus einem Text-Objektes die Zeichenkette und
versucht sie als Integerzahl zu interpretieren.
!begin_xlist [xxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem das Objekt liegt.

 !item [index]    ist die Objektnummer des gewÅnschten Objektes.
!end_xlist
Die Funktion liefert als Ergebnis den Wert zurÅck oder 0 falls der
Text nicht numerisch auswertbar ist.

!subnode ClearEditFields

VOID ClearEditFields ( OBJECT *tree );


Diese Funktion lîscht alle Editfelder in einem Dialog. Sollten keine
Editfelder im Dialog sein, so geschieht auch nichts.

Hat ein Editfeld den Status DISABLED oder das Flag HIDETREE gesetzt,
so bleibt der Inhalt des Editfeldes unangetastet.


!subnode SetEditField

BOOL SetEditField ( OBJECT *tree, INT field );


Diese Funktion setzt den Cursor in ein anderes Editfeld.
!begin_xlist [xxxxxxxx]
 !item [tree]     Adresse des Objektbaumes, in dem das Editfeld liegt.

 !item [field]    ist die Objektnummer des Editfeldes, in das der Cursor
          gesetzt werden soll. Befindet sich der Cursor bereits in
          diesem Editfeld verfÅgt das angegebene Objekt nicht Åber
          das Flag EDITABLE, so geschieht nichts.
!end_xlist
Die Funktion liefert TRUE, wenn der Cursor in das angegebene Feld
gesetzt wurde, FALSE sonst.


!subnode PopUp

INT PopUp ( OBJECT *tree, INT x, INT y, INT start, INT first );


Diese Funktion stellt ein Popup dar.
!begin_xlist [xxxxxxxx]
 !item [tree]     Zeiger auf den Objektbaum, der als Popup dargestellt werden
          soll. Dieser muû vorher mit NewDialog angemeldet worden
          sein.

 !item [x]        X-Koordinate, wo die linke obere Ecke des Popups liegen
          soll.

 !item [y]       Y-Koordinate, wo die obere Kante des Popups liegen soll.

 !item [start]    ist die Nummer des Objekte, ab dem gezeichnet werden soll.
          Normalerweise wird dies die Objektnummer des BOX-Objektes
          sein, die die einzelnen EintrÑge enthÑlt.

 !item [first]    Hier kînnen Sie die Nummer des Objektes angeben, die beim
          ôffnen des Popups unter dem Mauszeiger liegen soll. Die Y-
          Koordinate wird dabei automatisch entsprechend angepasst.

          Ist kein Objekt gewÅnscht, Åbergeben Sie einfach den Wert
          0.
!end_xlist
Die Funktion liefert die Objektnummer des angeklickten Eintrages
zurÅck. Klickt der Benutzer neben das Popup, liefert die Funktion den
Wert -1.

Siehe auch: "Erweiterter Typ: PopUp"


!subnode xPopUp

!begin_verbatim
INT xPopUp ( OBJECT *tree, INT obj, OBJECT *tree2, INT start,
             INT *first );
!end_verbatim

Diese Funktion baut auf PopUp auf. WÑhlt der Benutzer einen Eintrag
aus einem PopUp aus, mÅssen Sie als Programmierer/in diesen Eintrag
meist erst auslesen, und dann in ein bestimmtes Feld des Dialogs
Åbernehmen. Dies ist natÅrlich mit etwas Arbeit verbunden, doch
SysGem kann Ihnen diese Arbeit etwas abnehmen, mit dieser Funktion.

xPopUp stellt ein PopUp dar und schreibt, nachdem der Benutzer einen
Eintrag gewÑhlt hat, diesen in ein anderes Feld. SysGem kopiert dabei
lediglich den Text. Deshalb muû sowohl der Eintrag des Popups als
auch das Zielobjekt vom Typ String oder Text sein!
!begin_xlist [xxxxxxxx]
 !item [tree]     Zeiger auf den Objektbaum, in dem das Objekt liegt, welches
          das Popup ausgelîst hat und der das Objekt enthÑlt, in das
          nach dem Aufruf der Text geschrieben werden soll.

 !item [obj]      die Nummer des Objekts, in das nach dem Aufruf der Text
          geschrieben werden soll.

 !item [tree2]    ist ein Zeiger auf den Objektbaum, der als Popup dargestel-
          lt werden soll. Siehe auch bei PopUp.

 !item [start]    ist die Nummer des Objekte, ab dem gezeichnet werden soll
          (aus dem Baum 'tree2'. Normalerweise wird dies die Objekt-
          nummer des BOX-Objektes sein, die die einzelnen EintrÑge
          enthÑlt.

 !item [first]    Hier kînnen Sie die Nummer des Objektes angeben, die beim
          ôffnen des Popups unter dem Mauszeiger liegen soll. Die Y-
          Koordinate wird dabei automatisch entsprechend angepasst.

          Ist kein Objekt gewÅnscht, Åbergeben Sie einfach den Wert
          0.

          (!B)Vorsicht:(!b) Dieser Parameter ist als Zeiger auf ein int
          deklariert! Dieser wird einerseits ausgelesen, andererseits
          enthÑlt er nach dem Aufruf die Nummer des Objektes, welches
          der Benutzer in dem Popup angeklickt hat.
!end_xlist
Die Funktion liefert (wie bei 'first') die Nummer des Objektes
zurÅck, den der Benutzer angeklickt hat. Klickt der Benutzer neben
das Popup, so liefert die Funktion den Wert -1.

éndert sich der Inhalt des Textes (wofÅr die Funktion eigentlich
gedacht ist), zeichnet SysGem das Textobjekt automatisch neu.

Siehe auch: "Erweiterter Typ: PopUp"


!subnode Cycle

!begin_verbatim
INT Cycle ( OBJECT *home, INT home_obj, OBJECT *tree, INT first,
            INT last, INT *ret );
!end_verbatim

Cycle ist ebenfalls eine Sonderform der Popup's, macht sie doch
"nichts anderes", als die einzelnen EintrÑge durchzuscrollen. Bei
Erreichen des letzten Eintrags wird dabei dann wieder von vorne
angefangen.

Die Parameter:
!begin_xlist [xxxxxxxxxxx]
 !item [home]        ist ein Zeiger auf den Dialog, in dem der Boxtext liegt,
             der den Text enthÑlt.

 !item [home_obj]    ist die Objektnummer dieses Boxtextes.

 !item [tree]        ist der Zeiger auf den Baum des Popup's.

 !item [first]       Die Objektnummer des ersten Textes innerhalb dieses
             Popup's.

 !item [last]        Die Objektnummer des letzten Textes innerhalb dieses
             Popup's.

 !item [ret]         Hier wird die Objektnummer des Eintrages - 1 Åbergeben,
             der nach Aufruf dieser Funktion in dem mit "home_obj" an!-gegebenen
             Objekt geschrieben werden soll.
!end_xlist
Rembrandt? Bahnhof? Abfahrt? Also noch mal...

Sehen Sie sich einfach mal folgendes Bild an:


!image IMG410.IMG Ein offenes PopUp als Beispiel

Merken Sie sich, daû die Box die Nummer 20, Weiû 21 und Schwarz 22
hat. Ok? Gut.

Im Boxtext im Dialog steht nun "Weiû" (wenn nicht, definiere ich es
so...). Sie mîchten nun die Funktion Cycle benutzen und mîchten, daû
statt "Weiû" nun "Schwarz" im Boxtext erscheint. Dazu rufen Sie die
Funktion wie folgt auf:

INT ret;

ret = 21;  /* Merke: Eintrag - 1 */

Cycle ( dialog, boxtext, poptree, 21, 26, &ret );


SysGem rechnet nun: ret + 1 = 22 (!!!). Es wird also der Text des
Objektes Nr. 22 (Schwarz) aus dem Popup ausgelesen und in besagten
Boxtext geschrieben. Beim nÑchsten Aufruf ist dann ret = 22; also ret
+ 1 = 23; auslesen und in den Boxtext scheiben usw.

Die Funktion liefert sowohl in "ret" als auch als Funktionswert die
Objektnummer von dem Popup-Eintrag zurÅck, dessen Text gerade in
"home_obj" geschrieben wurde.

Der RÅckgabewert kann natÅrlich hervorragend als "first" fÅr xPopUp
verwendet werden.

Siehe auch: "Erweiterter Typ: Circle"


!subnode CycleBack

!begin_verbatim
INT CycleBack ( OBJECT *home, INT home_obj, OBJECT *tree,
                INT first, INT last, INT *ret );
!end_verbatim

CycleBack arbeitet wie Cycle, nur daû anstatt vorwÑrts, mit dieser
Funktion rÅckwÑrts geblÑttert wird.

Siehe auch: "Erweiterter Typ: Circle", Cycle


!subnode Listbox

INT Listbox ( BYTE *strings, INT count, INT len, OBJECT *tree, INT box );


Diese Funktion stellt eine Listbox dar, so Ñhnlich, wie sie auch in
den neuen AES-Versionen implementiert ist. Da jedoch unter jeder TOS-
Version diese Funktion zur VerfÅgung stehen soll, kommt man (in
diesem Falle: ich) um eine eigene Funktion leider nicht herum.

Zur Verdeutlichung noch mal ein Bildchen von einer


!image IMG409.IMG Listbox

Und nun die Parameter:
!begin_xlist [xxxxxxxxx]
 !item [strings]     ist entweder ein Zeiger auf einen Speicherbereich oder
             aber ein Zeiger auf einen C-String. Dazu muû gesagt wer-
             den, daû SysGem Listboxen auf zwei Arten erzeugen kann:
             Einerseits kann eine Listbox so aufgebaut sein, wie bei
             "LinkSlider" beschrieben, andererseits kann auch ein
             einfacher String Åbergeben werden. Nennen wir das erste
             Buffer-Variante, das andere die String-Variante.

             (!B)Buffer-Variante:(!b)

             "strings" ist in diesem Falle ein Zeiger auf einen
             globalen Speicherbereich, in dem die Texte fÅr die
             Listbox liegen. Jeder einzelne String (Eintrag) muû mit
             einem 0-Byte abgeschlossen sein! Siehe auch die Beschrei-
             bung bei "count" und "len"!

             (!B)String-Variante:(!b)

             "strings" zeigt dabei auf einen String (0-Byte am
             Ende!), der die einzelnen Zeilen (getrennt durch das
             Zeichen '|') enthÑlt. SysGem friemelt sich dann selbst
             einen Buffer intern zusammen. Diese Variante ist eigent-
             lich nur dann "zu gebrauchen", wenn es nicht zu viele
             EintrÑge sind. Denn die Listbox kann bis zu 32000 Ein-
             trÑge aufnehmen, was sich als ausreichend herausgestellt
             hat. Aber da in C die LÑnge eines Strings ja beliebig
             ist...

             Es soll aber nicht verschwiegen werden, daû die String-
             Variante etwas langsamer ist (bei vielen EintrÑgen), da
             der String ja erst in "HÑppchen" (die einzelnen Ein-
             trÑge) zerlegt werden muû.

 !item [count]       (!B)Buffer-Variante:(!b)

             "count" gibt die Anzahl der EintrÑge an, die sich im
             Buffer befinden, bzw, die in der Listbox dargestellt wer-
             den sollen.

             (!B)String-Variante:(!b)

             "count" muû -1 sein!

 !item [len]         (!B)Buffer-Variante:(!b)

             gibt die LÑnge einer Textzeile inclusive dem 0-Byte am
             Ende an. Alle Zeilen im Buffer mÅssen die gleiche LÑnge
             aufweisen; soll heiûen: Ist der lÑngste String 30
             Zeichen lang und Sie Åbergeben an "len" eine 31 (0-Byte
             zÑhlt mit!), dann bedeutet dies, daû von der
             Startadresse des Buffers an alle 31 Byte ein weiterer
             String (bzw. das erste Zeichen von ihm) zu finden ist.
             Der Einfachheit halber kann (wenn Sie ein Stringarray
             benutzen) die LÑnge auch einfach mit sizeof berechnet
             werden.

             (!B)String-Variante:(!b)

             "len" muû -1 sein!

 !item [tree]        Zeiger auf den Dialog, in dem der Boxtext liegt, der die
             Listbox ausgelîst hat.

 !item [box]         ist die Objektnummer dieses Boxtextes.
!end_xlist
(!B)Achtung:(!b) Der Text (bzw. die LÑnge; Anzahl der Zeichen) des Boxtextes
bestimmt die Breite der Listbox! Die Listbox (bzw. die EintrÑge) wer-
den nur so breit gezeichnet, wie Zeichen im Boxtext stehen. Eventuell
lÑngere EintrÑge werden abgeschnitten. Die maximale LÑnge (Breite)
eines Eintrags liegt bei 80 Zeichen; lÑnger ist nicht!

Sie sollten also darauf achten, daû der Text im Boxtext bis zu seiner
MaximallÑnge mit Leerzeichen aufgefÅllt ist (ist bei Benut- zung von
SetText eh der Fall, es sei denn, Sie haben das AuffÅl- len
verboten).

Die Funktion liefert (beginnend bei Index 0) den Index des
angeklickten Eintrages zurÅck, oder, falls der Benutzer "daneben"
klickt und somit nichts angewÑhlt hat, eine -1.

Siehe auch: "(!link [Erweiterter Typ: Listbox] [Erweiterter Typ: PopUp])"


!subnode xListbox

!begin_verbatim
INT xListbox ( BYTE *strings, INT count, INT len, OBJECT *tree,
               INT box, SPROC redraw );
!end_verbatim

Diese Funktion arbeitet exakt so wie Listbox, nur mit dem Unter-
schied, daû Sie hier die Mîglichkeit haben, eine eigene Redraw-Funk-
tion anzumelden, um die EintrÑge zu zeichnen.

Bei Aufruf dieser Funktion darf 'count' und 'len' niemals <= 0 sein!

Siehe auch: Listbox


!subnode CalcArea

VOID CalcArea ( OBJECT *tree, INT obj, RECT *r );


Diese Funktion berechnet die Ausmaûe des Objektes 'obj' im Baum
'tree' und liefert die absoluten Koordinaten sowie die Breite und
Hîhe in der Struktur 'r' zurÅck.


!node Timer

In vielen FÑllen ist es notwendig oder erwÅnscht, daû bestimmte
Arbeiten oder Aktionen zu einer bestimmten Zeit oder in einem ganz
bestimmten Intervall ausgefÅhrt werden.

FÅr diesen Zweck bietet SysGem beliebig viele Timer - die natÅrlich
auch konfigurierbar sind, fÅr die verschiedensten Anwendungsgebiete.

Da das AES nur einen Timer zur VerfÅgung stellt, benutzt SysGem eine
Liste, um die angemeldeten Timer pÅnktlich mit einem Aufruf zu versor-
gen. Der Sheduler prÅft dabei alle 25ms, ob ein Timer bearbeitet wer-
den muû, wenn ja, unterbricht SysGem seine Arbeit, um den Timer
abzuarbeiten.

Es ist bei der Vorgehensweise nur logisch, daû jeder Timer am besten
also ein Vielfaches von 25ms betragen sollte, was aber auch gering
genug fÅr ein GEM-Programm sein sollte.

Auûerdem sollten Sie bedenken, daû Ihre Timerfunktionen kurz sein
sollten, also nicht soviel Zeit beanspruchen sollten, damit eine
mîglichst gleichmÑûige Verteilung (obwohl SysGem einigen Aufwand
betreibt, um dies dennoch zu gewÑhrleisten) garantiert werden kann.

Hier eine Aufstellung Åber die Funktionen:


!subnode EnableTimer

VOID EnableTimer ( VOID );


Diese Funktion aktiviert die Timer. Ohne Aufruf dieser Funktion sind
die Timer inaktiv.

Wenn Sie also Timer benutzen mîchten, mÅssen Sie diese ab dem Zeit-
punkt, an dem Sie dies wÅnschen, mit Aufruf dieser Funktion
aktivieren.


!subnode DisableTimer

VOID DisableTimer ( VOID );


Diese Funktion schaltet die Timer ab. Dies betrifft jedoch nur die
mittels SetWindowTimer angemeldeten Timer, mittels SetXTimer angemeld-
ete Timer laufen weiter, werden also durch Aufruf dieser Funktion
nicht beeinfluût.


!subnode SetTimer

VOID SetTimer ( INT ms_low, INT ms_high );


Diese Funktion setzt die Zeitspanne fÅr einen mit SetProcTimer ange-
meldeten Timer. Dabei wird das Zeitintervall wie beim AES in
Millisekunden in 'ms_low' und 'ms_high' angegeben.

Wollen Sie den Timer wieder deaktivieren, so Åbergeben Sie fÅr jeden
Parameter einfach jeweils eine 0.


!subnode SetProcTimer

typedef VOID ( *TPROC )( VOID );

VOID SetProcTimer ( TPROC proc );


Mit SetProcTimer kînnen Sie eine Funktion anmelden, die in der mit
SetTimer angegebenen Zeitspanne periodisch aufgerufen wird. Um die an-
gemeldete Funktion zu lîschen, brauchen Sie nur SetProcTimer mit NULL
als Parameter aufzurufen.

Sie kînnen die Timerfunktion jederzeit durch öbergabe einer neuen
Funktion "umÑndern".


!subnode SetWindowTimer

VOID SetWindowTimer ( LONG win_id, INT ms_low, INT ms_high );


Diese Funktion bindet einen Timer an das Fenster mit der Id 'win_id'.
Die Handlerfunktion des Fensters (Fenster oder Fensterdialog) erhÑlt
dabei periodisch die Nachricht SG_TIMER. Das Zeitintervall wie beim
AES in Millisekunden in 'ms_low' und 'ms_high' angegeben.

Wird das Fenster geschlossen, wird auch der Timer automatisch
gelîscht.

Um den Timer vorzeitig zu beenden, genÅgt es, fÅr 'ms_low' und
'ms_high' jeweils 0 zu Åbergeben.

Beispiel:

SetWindowTimer ( 'MAIN', 1000, 0 );

wÅrde fÅr das Fenster mit der Id 'MAIN' einen Timer anmelden, so daû
die Handlerfunktion des Fensters jede Sekunde (= 1000 ms) mit der
Nachricht SG_TIMER aufgerufen wird.


!subnode UseFastTimer

VOID UseFastTimer ( LONG win_id, BOOL enable );


SysGem unterscheidet zwei Arten von Timern: einmal SG_TIMER, wobei
die Strukturen WINDOW_INFO bzw. DIALOG_INFO alle Parameter enthalten,
und SG_FTIMER (SysGem-FastTimer), wobei die Zeiger auf die Strukturen
jeweils NULL sind, wodurch sich ein klein wenig Zeit einsparen lÑût.

öbergeben Sie der Funktion fÅr 'enable' TRUE, so erhÑlt die Handler-
funktion von da an die Nachricht SG_FTIMER.

Die Voreinstellung ist das Versenden von SG_TIMER.

Wurde einmal SG_FTIMER aktiviert, kann jederzeit mit öbergabe von
'enable' == FALSE wieder auf SG_TIMER zurÅckschalten.


!subnode SetXTimer

typedef VOID ( *TPROC )( VOID );

!begin_verbatim
VOID SetXTimer ( LONG id, TPROC proc, INT ms_low, INT ms_high,
                 VOID *user1, VOID *user2 );
!end_verbatim

SetXTimer ist die universellste Timer-Funktion von SysGem. Einerseits
arbeitet sie unabhÑngig von EnableTimer und andererseits kann man ihr
sowohl eine Id als auch zwei freie Parameter mitgeben, die in der
Timerfunktion abgefragt werden kînnen.
!begin_xlist [xxxxxxxxxxxxxxxx]
 !item [id]                ist die Id des Timers. Sie muû innerhalb der
                    Timerfunktionen eindeutig und != 0L sein, anson-
                    sten wird der Timer nicht angenommen.

 !item [proc]               ist die Funktion, die periodisch aufgerufen wird.

 !item [ms_low, ms_high]    ist das Zeitintervall, mit dem die Funktion
                    'proc' aufgerufen werden soll. Dieses Intervall
                    wird wie beim AES in Millisekunden und in High-
                    und Low-Byte angegeben.

 !item [user1, user2]       sind zwei beliebige Zeiger, die Sie der Funktion
                    mitgeben kînnen.
!end_xlist
Siehe auch: GetXTimerId, GetXTimerUser1, GetXTimerUser2


!subnode DelXTimer

VOID DelXTimer ( LONG id );


Diese Funktion lîscht den Timer mit der Id 'id', den Sie vorher mit
der Funktion SetXTimer angemeldet haben.


!subnode GetXTimerId

LONG GetXTimerId ( VOID );


Innerhalb der Handlerfunktion, die Sie bei SetXTimer angegeben haben,
kînnen Sie mit dieser Funktion die Id des Timers in Erfahrung
bringen.

Somit ist es mîglich, eine einzige Handlerfunktion bei mehreren
Timern anzugeben und trotzdem zu unterscheiden, welcher Timer gemeint
ist.

Siehe auch: GetXTimerUser1, GetXTimerUser2


!subnode GetXTimerUser1

VOID *GetXTimerUser1 ( VOID );


Innerhalb der Handlerfunktion, die Sie bei SetXTimer angegeben haben,
kînnen Sie mit dieser Funktion den ersten User-Zeiger ('user1') des
Timers in Erfahrung bringen.

Siehe auch: GetXTimerId, GetXTimerUser2


!subnode GetXTimerUser2

VOID *GetXTimerUser2 ( VOID );


Innerhalb der Handlerfunktion, die Sie bei SetXTimer angegeben haben,
kînnen Sie mit dieser Funktion den zweiten User-Zeiger ('user2') des
Timers in Erfahrung bringen.

Siehe auch: GetXTimerId, GetXTimerUser1


!node Textfenster

Ein Programm besteht nicht nur aus Dialogen. HÑufig besteht die
Notwendigkeit, Texte in Fenstern dem Benutzer zu prÑsentieren, sei es
eine Liste von Dateien, von Adressen oder sonstwas. FÅr diesen Zweck
bietet SysGem komplexe Routinen an, mit denen Sie so ziemlich jedes
Problem, was Text im Fenster angeht, bewÑltigen kînnen.

Achtung: Von den Grundroutinen gibt es zwei Arten. Einmal mit, und
einmal ohne ein vorgestelltes kleines 'x'. Die 'x'-Funktionen ver-
walten zu jeder einzelnen Textzeile noch einen eigenen User-Zeiger,
Åber den Sie frei verfÅgen kînnen. Wenn Sie eine Zeile mit einer 'x'-
Funktion angemeldet haben, sollten Sie auch die Manipulationsroutinen
mit dem 'x' benutzen.

Hier eine kleine öbersicht Åber die Funktionen dieses Kapitels:

!subnode LinkList

BYTE *LinkList ( LONG win_id, BYTE *text );


LinkList hÑngt eine Textzeile in den bestehendes Fenster ein und
initialisiert die von SysGem benîtigten Strukturen fÅr die Text-
fenster. Desweiteren hÑngt LinkList (und xLinkList) die Redraw-Funk-
tion fÅr das Fenster ein.

LinkList (!B)muû(!b) mit der allerersten Textzeile aufgerufen werden, da alle
sonstigen Funktionen mit einer Fehlermeldung abbrechen werden. Die
Textfenster kînnen bis zu 65000 (und ein paar Zerquetschte) Zeilen
enthalten, die nacheinander mit AddToList zu der bereits bestehenden
Liste hinzugefÅgt werden kînnen.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte ChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit AddToList hinzuge-
fÅgt haben und richtet den Dokumentbereich sowie die Slider entsprech-
end aus.


!subnode xLinkList

BYTE *xLinkList ( LONG win_id, BYTE *text, INT effect, VOID *user );


xLinkList hÑngt eine Textzeile in den bestehendes Fenster ein und
initialisiert die von SysGem benîtigten Strukturen fÅr die Text-
fenster. Der Unterschied zu LinkList besteht einfach darin, daû mit
den x...Funktionen zu jeder Textzeile ein eigener Zeiger mitgegeben
werden kann, dessen Nutzen von Ihnen selbst abhÑngt.

xLinkList (!B)muû(!b) mit der allerersten Textzeile aufgerufen werden, da
alle sonstigen Funktionen mit einer Fehlermeldung abbrechen werden.
Die Textfenster kînnen bis zu 65000 (und ein paar Zerquetschte)
Zeilen enthalten, die nacheinander mit xAddToList zu der bereits
bestehenden Liste hinzugefÅgt werden kînnen.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.

 !item [effect]    der neue bitcodierte Effect, der fÅr die angegebene Zeile
           gesetzt werden soll.

 !item [user]      ist ein fÅr Sie frei verfÅgbarer Zeiger, der mit der Zeile
           selbst gespeichert wird. Abfragen kînnen Sie ihn jederzeit
           mittels GetListUserPtr.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte xChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit AddToList hinzuge-
fÅgt haben und richtet den Dokumentbereich sowie die Slider entsprech-
end aus.


!subnode AddToList

BYTE *AddToList ( LONG win_id, BYTE *text );


AddToList fÅgt zu einem Textfenster, welches vorher mit einem Aufruf
von LinkList initialisiert worden ist, eine weitere Textzeile hinzu.
Diese wird einfach hinter die bereits bestehenden Textzeilen gesetzt.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte ChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit AddToList hinzuge-
fÅgt haben und richtet den Dokumentbereich sowie die Slider entsprech-
end aus.


!subnode xAddToList

BYTE *xAddToList ( LONG win_id, BYTE *text, INT effect, VOID *user );


xAddToList fÅgt zu einem Textfenster, welches vorher mit einem Aufruf
von xLinkList initialisiert worden ist, eine weitere Textzeile hinzu.
Diese wird einfach hinter die bereits bestehenden Textzeilen gesetzt.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.

 !item [effect]    der neue bitcodierte Effect, der fÅr die angegebene Zeile
           gesetzt werden soll.

 !item [user]      ist ein fÅr Sie frei verfÅgbarer Zeiger, der mit der Zeile
           selbst gespeichert wird. Abfragen kînnen Sie ihn jederzeit
           mittels GetListUserPtr.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte xChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit xAddToList hinzuge-
fÅgt haben und richtet den Dokumentbereich sowie die Slider entsprech-
end aus.


!subnode InsInList

BYTE *InsInList ( LONG win_id, UINT line, BYTE *text );


InsInList fÅgt eine Textzeile in ein Textfenster, daû vorher mit
einem Aufruf von LinkList initialisiert worden ist, an einer beliebi-
gen Stelle ein. Die ZÑhlung der Textzeilen beginnt dabei mit 0.
Wollen Sie also eine Zeile einfÅgen, die an der ersten Stelle stehen
soll, so Åbergeben Sie fÅr die Zeilennummer eine 0.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [line]      gibt die Zeilennummer an, an der die neue Zeile eingefÅgt
           werden soll. Die ZÑhlung beginnt dabei mit 0.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte ChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit AddToList oder
InsInList hinzugefÅgt haben und richtet den Dokumentbereich sowie die
Slider entsprechend aus.


!subnode xInsInList

BYTE *xInsInList ( LONG win_id, UINT line, BYTE *text, INT effect, VOID *user );


xInsInList fÅgt eine Textzeile in ein Textfenster, daû vorher mit
einem Aufruf von xLinkList initialisiert worden ist, an einer beliebi-
gen Stelle ein. Die ZÑhlung der Textzeilen beginnt dabei mit 0.
Wollen Sie also eine Zeile einfÅgen, die an der ersten Stelle stehen
soll, so Åbergeben Sie fÅr die Zeilennummer eine 0.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [line]      gibt die Zeilennummer an, an der die neue Zeile eingefÅgt
           werden soll. Die ZÑhlung beginnt dabei mit 0.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.

 !item [effect]    der neue bitcodierte Effect, der fÅr die angegebene Zeile
           gesetzt werden soll.

 !item [user]      ist ein fÅr Sie frei verfÅgbarer Zeiger, der mit der Zeile
           selbst gespeichert wird. Abfragen kînnen Sie ihn jederzeit
           mittels GetListUserPtr.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only! FÅr Manipulationen der
Textzeile benutzen Sie bitte xChgInList!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit xAddToList oder
xInsInList hinzugefÅgt haben und richtet den Dokumentbereich sowie
die Slider entsprechend aus.


!subnode ChgInList

BYTE *ChgInList ( LONG win_id, UINT line, BYTE *text );


ChgInList ersetzt eine bestehende Textzeile in einem Textfenster. Die
ZÑhlung der Textzeilen beginnt dabei mit 0. Wollen Sie also eine
Zeile austauschen, die an der ersten Stelle steht, so Åbergeben Sie
fÅr die Zeilennummer eine 0.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [line]      gibt die Zeilennummer der Textzeile an, die gegen den
           neuen Text ersetzt werden soll. Die ZÑhlung beginnt dabei
           mit 0.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit AddToList, InsInList
oder ChgInList hinzugefÅgt haben und richtet den Dokumentbereich
sowie die Slider entsprechend aus.


!subnode xChgInList

BYTE *xChgInList ( LONG win_id, UINT line, BYTE *text, VOID *user );


xChgInList ersetzt eine bestehende Textzeile in einem Textfenster.
Die ZÑhlung der Textzeilen beginnt dabei mit 0. Wollen Sie also eine
Zeile austauschen, die an der ersten Stelle steht, so Åbergeben Sie
fÅr die Zeilennummer eine 0.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [line]      gibt die Zeilennummer der Textzeile an, die gegen den
           neuen Text ersetzt werden soll. Die ZÑhlung beginnt dabei
           mit 0.

 !item [text]      ist ein Zeiger auf die Textzeile, die in das Fenster
           Åbernommen werden soll. Der Text braucht nicht statisch
           von Ihrem Programm gehalten zu werden, nach dem Aufruf
           kopiert SysGem die Textzeile in einen eigenen Speicherbe-
           reich.

 !item [user]      ist ein fÅr Sie frei verfÅgbarer Zeiger, der mit der Zeile
           selbst gespeichert wird. Abfragen kînnen Sie ihn jederzeit
           mittels GetListUserPtr.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
ab sofort liegt. Dieser Zeiger ist Read-Only!

Liefert die Funktion NULL zurÅck, so ist ein Fehler aufgetreten und
der Text wird nicht in das Fenster Åbernommen.

SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile, die Sie mit xAddToList,
xInsInList oder xChgInList hinzugefÅgt haben und richtet den Dokument-
bereich sowie die Slider entsprechend aus.


!subnode DelInList

BOOL DelInList ( LONG win_id, UINT line );


DelInList ermîglicht das lîschen einer Textzeile aus der bestehenden
Liste. Die ZÑhlung der Zeilen beginnt dabei mit 0. Wollen Sie also
die erste Textzeile im Fenster lîschen bzw. entfernen, Åbergeben Sie
fÅr 'line' eine 0.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters.

 !item [line]      gibt die Zeilennummer der Textzeile an, die aus der
           Textliste entfernt werden soll. Die ZÑhlung beginnt dabei
           mit 0.
!end_xlist
SysGem passt den den Dokumentbereich des Fensters automatisch an.
Dazu nimmt SysGem die lÑngste Zeile und richtet den Dokumentbereich
sowie die Slider entsprechend aus.


!subnode CountLines

UINT CountLines ( LONG win_id );


CountLines liefert die Anzahl der Textzeilen im Textfenster mit der
Id 'win_id' zurÅck.


!subnode RedrawLine

VOID RedrawLine ( LONG win_id, UINT line );


RedrawLine zeichnet eine einzige Zeile mit dem Index 'line' (die
ZÑhlung beginnt bei 0) im Fenster mit der Id 'win_id' neu.


!subnode DelCompleteList

VOID DelCompleteList ( LONG win_id );


Diese Funktion entfernt (!B)alle(!b) Textzeilen aus einem Textfenster.
DelCompleteList ist eine schnellere Lîsung, als jede einzelne Zeile
mittels DelInList zu lîschen.

Achtung: Alle gesetzten @{"Tabulatoren" LINK "SetListTab" 3} werden ebenfalls gelîscht! Bei
einem erneuten Einlinken von Textzeilen mÅssen also auch die
@{"Tabulatoren" LINK "SetListTab" 3} wieder gesetzt werden!


!subnode GetLinePtr

BYTE *GetLinePtr ( LONG win_id, UINT line );


Da SysGem jede Zeile in einen eigenen Speicherbereich legt, gibt es
diese Funktion, um die Startadresse einer Textzeile zu ermitteln.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.
!end_xlist
Die Funktion liefert einen Zeiger auf die Åbernommene Textzeile
zurÅck, also einen Zeiger auf einen Speicherbereich, in dem der Text
liegt. Dieser Zeiger ist Read-Only! Die Funktion liefert NULL, wenn
es die angegebene Zeile nicht gibt.


!subnode GetListUserPtr

VOID *GetListUserPtr ( LONG win_id, UINT line );


Diese Funktion dient dazu, den User-Zeiger, den Sie bei xAddToList an-
gegeben haben, in Erfahrung zu bringen.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.
!end_xlist

!subnode SetFirstLine

VOID SetFirstLine ( LONG win_id, UINT line )

Mit dieser Funktion kann die erste Zeile eines Textfensters festgelegt
werden.

!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile die oben im Fenster dargestellt
                   werden soll, wobei die ZÑhlung mit 0 beginnt.
!end_xlist

Damit dies eine Wirkung hat muss danach (!nolink [ScrollWindow]) ausgefÅhrt weren.

Beispiel:

!begin_verbatim
SetFirstLine ( 'NAIX', i );
ScrollWindow ( inf->handle, -1 );
!end_verbatim


!subnode SetListUserPtr

BOOL SetListUserPtr ( LONG win_id, UINT line, VOID *user );


Diese Funktion ist das GegenstÅck zu GetListUserPtr. Mit ihr ist es
mîglich, zur Laufzeit einen User-Zeiger fÅr die angegebene Zeile zu
Ñndern.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.

 !item [user]      der neue Wert des User-Zeigers, der Åbernommen werden
           soll.
!end_xlist
Die Funktion liefert TRUE, wenn der neue Zeiger Åbernommen wurde,
FALSE sonst.


!subnode SetLineEffect

INT SetLineEffect ( LONG win_id, UINT line, INT effect );


Es kann durchaus von Nutzen und auch erwÅnscht sein, einzelne Zeilen
besonders hervorzuheben, z. B. fett oder unterstrichen.

Mit SetLineEffect kînnen Sie einzelnen Zeilen bestimmte Effekte
zuordnen. Die Mîglichkeiten entsprechen denen der VDI-Funktion
'(!xlink [vst_effects] [TOS.HYP/vst_effects])'.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.

 !item [effect]    der neue bitcodierte Effect, der fÅr die angegebene Zeile
           gesetzt werden soll.

           Wird hier -1 Åbergeben, liefert die Funktion den aktuell
           eingestellten Effect zurÅck.
!end_xlist
SysGem zeichnet die Zeile nicht automatisch neu. Dies mÅssen Sie
selbst mit einem Aufruf von RedrawLine veranlassen.


!subnode SetLineColor

INT SetLineColor ( LONG win_id, UINT line, INT color );


SysGem kann jede einzelne Zeile mit einer anderen Farbe darstellen.
Mit dieser Funktion kînnen Sie fÅr eine Zeile die Voreinstellung
(Schwarz) Ñndern.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.

 !item [color]     ist die neue Farbe, die fÅr die Zeile gesetzt werden soll.

           Wird hier -1 Åbergeben, liefert die Funktion die aktuell
           eingestellte Farbe zurÅck.
!end_xlist
SysGem zeichnet die Zeile nicht automatisch neu. Dies mÅssen Sie
selbst mit einem Aufruf von RedrawLine veranlassen.


!subnode SetLineFlags

INT SetLineFlags ( LONG win_id, UINT line, INT flags );


SysGem kann eine Zeile nicht nur fett oder in beliebigen Farben
ausgeben, sondern auch invertiert. Dies ist meist gewÅnscht, wenn der
Benutzer eine Zeile im Textfenster angeklickt hat.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.

 !item [flags]     ist bitcodiert und gibt (derzeit) an, ob eine Zeile inver-
           tiert (Bit 0 gesetzt) oder normal (Bit 0 gelîscht) ausgege-
           ben wird. Die anderen Bits sind fÅr zukÅnftige Versionen
           reserviert.

           Wird hier -1 Åbergeben, liefert die Funktion die aktuell
           eingestellte Flag-Einstellung zurÅck.

           Wird hier -2 Åbergeben, wechhselt Bit 0 den Zustand.
!end_xlist
SysGem zeichnet die Zeile nicht automatisch neu. Dies mÅssen Sie
selbst mit einem Aufruf von RedrawLine veranlassen.

Siehe auch: SetSelColor, SetSelTextColor


!subnode SetLineUser

INT SetLineUser ( LONG win_id, UINT line, INT user );


Zuweilen kann es sinnvoll und notwendig sein, zu einer Textzeile
nicht nur einen User-Zeiger, sondern auch noch bestimmte Flags oder
Stati mitzufÅhren, auf die Ihr Programm reagiert.

Mit dieser Funktion kînnen Sie unabhÑngig vom User-Zeiger noch ein
INT mitfÅhren, daû Ihr Programm selbst verwaltet.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt.

 !item [line]      die Nummer der Zeile, wobei die ZÑhlung mit 0 beginnt.

 !item [user]      ist ein INT, welches Sie nutzen kînnen, wie Sie wollen.

           Wird hier -1 Åbergeben, liefert die Funktion den aktuell
           eingestellten Wert zurÅck.
!end_xlist

!subnode GetLineHeight

INT GetLineHeight ( LONG win_id );


Diese Funktion liefert die Hîhe einer Zeile fÅr das Textfenster mit
der Id 'win_id'.


!subnode BeginListUpdate

VOID BeginListUpdate ( LONG win_id );


Bei jeder VerÑnderung an einem Textfenster bzw. an dessen Liste
zeichnet SysGem das Fenster neu, um auf die énderungen zu reagieren.
Dies kann aber gerade dann, wenn mehrere Zeilen via AddToList oder
xAddToList zu der Liste hinzugefÅgt werden, sehr stîrend sein - nach
jedem Aufruf wÅrde das Fenster neugezeichnet.

Um das Neuzeichnen zeitweise zu unterbinden, gibt es diese Funktion.
Bei einem Aufruf der Funktion mit der Id des Textfensters wird das
Neuzeichnen des Fensters so lange unterbunden, bis Sie das Neuzeich-
nen via EndListUpdate wieder aktivieren.

Zwischen Begin... und End... kînnen Sie also das komplette Text-
fenster so gestalten, wie Sie wollen, ohne daû es stÑndig gezeichnet
wird.

Beispiel:
!begin_verbatim
...
BeginListUpdate ( 'TEXT' );
if ( LinkList ( 'TEXT', "Dies ist ein Test" ) != NULL )
  {
    forever
      {
        AddToList ( 'TEXT', ... );
        if ( ... ) break;
      }
  }
EndListUpdate ( 'TEXT' );
!end_verbatim

!subnode EndListUpdate

VOID EndListUpdate ( LONG win_id );


Hebt den vorhergehenden Aufruf von BeginListUpdate wieder auf. Nach
Aufruf dieser Funktion wird das Fenster automatisch neu gezeichnet,
um auf die zwischenzeitlichen énderungen zu reagieren.


!subnode SetListTab

BOOL SetListTab ( LONG win_id, INT pos, INT just );


Da SysGem auch proportionale Fonts in den Textfenstern zulÑût (siehe
SetWindowFont), kann es bei Listen, bei denen bestimmte Daten (z. B.
DateilÑngen) untereinander stehen mÅssen, zu Schwierigkeiten kînnen.

Aus diesem Grunde unterstÅtzt SysGem sowohl in Textfenstern als auch
in Sliderboxen Tabulatoren; und davon gleich 4 verschiedene.

Als Tabulator-Zeichen verwendet SysGem dabei das Zeichen '\t' (ASCII
9). Der Tabulator wirkt dabei immer auf den Text, der nach dem
Tabulator folgt!

Beispiel (in C):

"\tDieses ist der erste \tund dies der zweite Tabulator"


SysGem wÅrde nun den Text "Dieses ist der erste" dem ersten Tabulator
und "und dies der zweite Tabulator" dem zweiten zuordnen und ent-
sprechend den Angaben ausrichten.

Hier mal die Parameter:
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Fenster-Id des Textfensters, fÅr das Sie die
           Tabulatoren definieren wollen.

 !item [pos]       ist die Position des Tabulators. Die Position wird immer
           in Zeichen angegeben, wobei SysGem bei einem
           Proportionalfont die Breite des Zeichens 'W' annimmt und
           diese Position dann in Pixeln umrechnet. So ist
           gewÑhrleistet, daû die Position bei jedem Font eingehalten
           werden kann.

 !item [just]      ist die Angabe, wie SysGem den Text an dem Tabulator
           ausrichten soll. Es gibt dabei folgende Konstanten:

           (!B)TAB_LEFT(!b) richtet den Text an dem Tabulator nach links aus,
           also linksbÅndig. Der Text wÅrde also zur rechten des
           Tabulators stehen.

           (!B)TAB_RIGHT(!b) richtet den Text an dem Tabulator nach rechts
           aus, also rechtsbÅndig. Der Text wÅrde also zur linken des
           Tabulators stehen.

           (!B)TAB_CENTER(!b) richtet den Text genau zentriert unter dem
           Tabulator aus.

           (!B)TAB_DECIMAL(!b) richtet z. B. eine Zahlenkolonne so aus, daû
           der Dezimaltrenner immer unter dem Tabulator steht. Um
           Problemen mit den verschiedenen Dezimaltrennern aus dem
           Wege zu gehen, nimmt SysGem das Zeichen als Dezimaltrenner
           an, welches von rechts nach links gelesen als ersten dem
           '.' oder ',' entspricht.

           Bei 1,234,567.89 wÅrde SysGem das '.' als Dezimaltrenner
           ansehen, bei 1.234.567,89 das ','. Beide Formen kînnen
           auch beliebig gemischt werden, SysGem sucht bei jedem
           Dezimaltrenner den Text separat ab.
!end_xlist
Die Funktion liefert TRUE, wenn der Tabulator gesetzt wurde, FALSE
sonst.


!subnode UpdListTab

BOOL UpdListTab ( LONG win_id, INT tab, INT pos, INT just );


Mit dieser Funktion ist es mîglich, einen Tabulator zu Ñndern. Der
Tabulator mit der Nummer 'tab' (die ZÑhlung lÑuft von links nach
rechts, beginnend bei 0) kann sowohl in seiner Position als auch in
seiner Ausrichtigung geÑndert werden.

Zu den Parametern siehe: SetListTab


!subnode SetLineIcon

BOOL SetLineIcon ( LONG win_id, UINT line, OBJECT *tree, INT start );


Mit dieser Funktion ist es mîglich, fÅr eine Zeile (oder mehrere) ein
beliebiges Icons vorzusetzen, wie das Bild hier zeigt:


!image IMG408.IMG
Der nachfolgende Text wird nicht automatisch ausgerichtet, sie soll-
ten dafÅr einen der(!link [Tabulatoren] [SetListTab]) verwenden.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt, fÅr
           die ein Icon angemeldet werden soll.

 !item [line]      ist die Nummer der Zeile (beginnend bei 0), fÅr die das
           Icon gelten soll.

 !item [tree]      ist ein Zeiger auf einen Objektbaum, in dem das zu
           zeichnende Icon (oder sonstwas!) liegt. Dieser Baum muû
           vorher mittels NewDialog angemeldet worden sein.

 !item [start]     ist die Objektnummer innerhalb des Baumes, ab dem gezeich-
           net werden soll. Als Tiefe nimmt SysGem immer MAX_DEPTH
           (8).
!end_xlist
Die Hîhe der einzelnen Zeilen wird immer auf den Wert gesetzt, den
das hîchste Icon einnimmt. Alle anderen Zeilen werden dann in der
Hîhe an dieser Zeile ausgerichtet.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!

Die Funktion liefert TRUE, wenn das Icon angenommen wurde, FALSE
sonst.


!subnode xSetLineIcon

BOOL xSetLineIcon ( LONG win_id, UINT line, OBJECT *tree, INT start );


Mit dieser Funktion ist es mîglich, fÅr eine Zeile (oder mehrere) ein
beliebiges Icons vorzusetzen, wie das Bild hier zeigt:


!image IMG407.IMG
Der nachfolgende Text wird nicht automatisch ausgerichtet, sie soll-
ten dafÅr einen der (!link [Tabulatoren] [SetListTab]) verwenden.

Im Gegensatz zur Funktion SetLineIcon wird bei dieser die Umrahmung
des Icons bzw. der gesamten Zeile (!B)nicht(!b) gezeichnet, sondern (!B)nur(!b) das
Icon.
!begin_xlist [xxxxxxxx]
 !item [win_id]    ist die Id des Textfensters, in dem die Zeile liegt, fÅr
           die ein Icon angemeldet werden soll.

 !item [line]      ist die Nummer der Zeile (beginnend bei 0), fÅr die das
           Icon gelten soll.

 !item [tree]      ist ein Zeiger auf einen Objektbaum, in dem das zu
           zeichnende Icon (oder sonstwas!) liegt. Dieser Baum muû
           vorher mittels NewDialog angemeldet worden sein.

 !item [start]     ist die Objektnummer innerhalb des Baumes, ab dem gezeich-
           net werden soll. Als Tiefe nimmt SysGem immer MAX_DEPTH
           (8).
!end_xlist
Die Hîhe der einzelnen Zeilen wird immer auf den Wert gesetzt, den
das hîchste Icon einnimmt. Alle anderen Zeilen werden dann in der
Hîhe an dieser Zeile ausgerichtet.

Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!

Die Funktion liefert TRUE, wenn das Icon angenommen wurde, FALSE
sonst.


!subnode SetWindowFont

BOOL SetWindowFont ( LONG win_id, INT font_id, INT font_pt );


Diese Funktion ermîglicht es, einem Textfenster einen beliebigen Font
zuzuordnen.
!begin_xlist [xxxxxxxx]
 !item [win_id]     ist die Id des Fenster, fÅr das der neue Font gelten
            soll.

 !item [font_id]    ist die Id des Fonts, der eingestellt werden soll.

 !item [font_pt]    ist die Hîhe des Fonts in Punkten, die eingestellt werden
            soll.
!end_xlist
Beachten Sie, daû SysGem das Fenster nach Aufruf dieser Funktion auto-
matisch neuzeichnet, wenn Sie dieses Neuzeichnen nicht mit einem
Aufruf von BeginListUpdate unterbunden haben!

Die Funktion liefert TRUE, wenn der Font eingestellt wurde, FALSE
sonst.


!subnode Display

LONG Display ( BYTE *fname, BYTE *wname, BYTE *winfo, INT len,
               LONG win_id, INT x, INT y, INT w, INT h,
               APROC action );


Diese Funktion lÑdt eine Textdatei und stellt diese in einem Fenster
dar.
!begin_xlist [xxxxxxx]
 !item [fname]     ist der Name und Pfad der Datei, die geladen werden soll.

 !item [wname]     ist ein Zeiger auf den Namen des Fensters, der als Fen-
           stertitel verwendet wird. Dabei setzt SysGem selbststÑndig
           vor und hinter den Namen jeweils ein Leerzeichen, so daû
           Sie es im Programm nicht immer machen mÅssen (spart immer
           2 Byte :-))

           Vor den ganzen Text setzt SysGem dann - wenn das Programm
           in einer Multitasking-Umgebung lÑuft - immer den Pro-
           grammnamen, der automatisch von InitGem Åbernommen wird.
           Sie kînnen ihn aber jederzeit mit SetProgramName umÑndern.

           Sollte als erstes Zeichen ein Balken ('|') stehen, so
           Åbernimmt SysGem den gesamten String ohne énderungen als
           Fenstertitel.

 !item [winfo]     ist ein Zeiger auf eine optionale Infozeile. Wird hier ein
           Leerstring angegeben, so stellt SysGem keine Infozeile
           dar.

 !item [len]       ist die maximale LÑnge einer Zeile in Zeichen, die
           berÅcksichtigt werden soll. LÑngere Zeilen werden
           abgeschnitten.

 !item [win_id]    ist die Fenster-Id, die das Textfenster erhalten soll.

 !item [x]         ist die X-Koordinate des Arbeitsbereiches, an der das Fen-
           ster auf dem Bildschirm erscheinen soll.

 !item [y]         ist die Y-Koordinate des Arbeitsbereiches, an der das Fen-
           ster auf dem Bildschirm erscheinen soll.

 !item [w]         ist die Breite in Pixeln, die der Arbeitsbereich beim
           ôffnen einnehmen soll.

 !item [h]         ist die Hîhe in Pixeln, die der Arbeitsbereich beim ôffnen
           einnehmen soll.

 !item [action]    ist die Handlerfunktion fÅr das Fenster, die alle Benutzer-
           aktivitÑten von SysGem erhÑlt.

           Sie kînnen hier auch NULL angeben, dann wird das Fenster
           erst dann geschlossen, wenn der Benutzer den Closer
           betÑtigt.
!end_xlist
Das Redraw des Fensters wird vollstÑndig von SysGem Åbernommen.

Die Funktion liefert einen positiven Wert zurÅck, der die Anzahl der
geladenen Zeilen angibt.

Im Fehlerfalle liefert die Funktion einen negativen LONG-Wert zurÅck,
der dem GEMDOS-Fehlercode entspricht.


!subnode do_qsort

typedef INT ( *VPROC )( BYTE *s1, BYTE *s2 );

VOID do_qsort ( LONG win_id, VPROC compare );


Es kann durchaus wÅnschenswert sein, eine Textliste nach beliebigen
Kriterien sortieren zu lassen. SysGem stellt dafÅr diese Funktion
bereit, die beliebige Textlisten sortieren kann.

FÅr den Standardfall, auf- und absteigende Sortierung, bietet SysGem
schon vordefinierte Funktionen. Aber auch wenn es etwas spezieller
sein darf, muû SysGem nicht passen.

Hier mal die Beschreibung der Funktion:
!begin_xlist [xxxxxxxxxxx]
 !item [win_id]     ist die Fenster-Id des Textfensters, das sortiert werden
            soll.

 !item [compare]    ist ein Zeiger auf eine Funktion, die die
            Sortierreihenfolge angibt.

            öbergeben Sie einfach

            (!B)cmp_strings_up(!b), wenn die Liste aufsteigend sortiert wer-
            den soll und

            (!B)cmp_strings_dn(!b), wenn die Liste in absteigender
            Reihenfolge sortiert werden soll.
!end_xlist
Wenn Sie einen Spezialfall haben (es soll z. B. nach Zahlen innerhalb
der Textzeilen sortiert werden), gehen Sie einfach so vor:
!begin_enumerate
  !item Sie definieren eine Funktion vom Typ VPROC.

  !item Der Funktion werden beim Sortiervorgang zwei Zeiger auf jeweils
     eine Textzeile Åbergeben. Aus diesen Zeilen kînnen Sie dann die
     Information herausfiltern, nach denen Sie sortieren wollen.

  !item Ihre Funktion muû folgende Werte zurÅckliefern:

     0, wenn s1 == s2

     -1, wenn s1 < s2

     1, wenn s1 > s2
!end_enumerate
Das Umsortieren der einzelnen Textzeilen Åbernimmt SysGem von allein.

Nach erfolgtem Sortieren wird das Fenster automaisch neu gezeichnet.


!subnode xdo_qsort

typedef INT ( *XPROC )( BYTE *s1, VOID *u1, BYTE *s2, VOID *u2 );

VOID xdo_qsort ( LONG win_id, XPROC compare );


Diese Funktion arbeitet exakt so wie auch do_qsort, nur mit der
Besonderheit, daû der eigentlichen Sortierfunktion auûer dem Zeiger
auf die Textzeilen in 'u1' und 'u2' jeweils noch der User-Zeiger
(siehe auch bei xAddToList) mit Åbergeben wird.

Die RÅckgabewerte entsprechen denen wie bei do_qsort beschrieben.

Das Umsortieren der einzelnen Textzeilen Åbernimmt SysGem von allein.

Nach erfolgtem Sortieren wird das Fenster automaisch neu gezeichnet.


!subnode GetTabPosition

INT GetTabPosition ( LONG win_id, INT tab_nr, BOOL pixel );


Diese Funktion liefert die Position eines Tabulators mit der Nr
"tab_nr" im Fenster mit der Id "win_id".

Ist "pixel" == TRUE, wird die Tabulatorposition absolut zum Nullpunkt
des Dokumentbereiches in Pixel geliefert. Ist "pixel" == FALSE, so
liefert die Funktion die Tabulatorposition in Zeichen.

Die Funktion liefert -1, wenn ein Fehler auftrat (Fenster oder
Tabulator nicht gefunden).


!subnode OpenTextWindow

!begin_verbatim
INT OpenTextWindow  ( LONG id, BYTE *name, BYTE *info, OBJECT *menu,
                      INT x, INT y, INT w, INT h, VOID *user,
                      APROC action );
!end_verbatim

Diese Funktion arbeitet exakt so wie OpenWindow, nur mit dem Unter-
schied, daû diese Funktion fÅr das ôffnen von Textfenstern gedacht
ist, da in den (zu OpenWindow) fehlenden Parametern die notwendigen
von SysGem schon selbst eingetragen werden.


!node Sliderboxen

FÅr ein besseres VerstÑndnis hier erstmal ein Bildchen, welches den
Aufbau einer Sliderbox recht deutlich macht:


!image IMG406.IMG
Die ZeichenerklÑrung:
!begin_enumerate
  !item Eine BOX mit erweitertem Typ 7 (in dieser Box werden spÑter die
     Texte der Sliderbox ausgegeben).

  !item Ein BOXCHAR mit erweitertem Typ 10

  !item Eine BOX mit erweitertem Typ 8

  !item Eine BOX mit erweitertem Typ 9

  !item Ein BOXCHAR mit erweitertem Typ 7

  !item Ein BOXCHAR mit erweitertem Typ 8

  !item Eine BOX mit erweitertem Typ 9

  !item Eine BOX mit erweitertem Typ 8

  !item Ein BOXCHAR mit erweitertem Typ 9
!end_enumerate
(!B)Achtung:(!b)
!begin_itemize
   !item Die Elemente 6 bis 9 werden nur benutzt, wenn Sie einen
     horizontalen Slider mit LinkHorSlider anmelden.

   !item Das Element 3 muû immer Child von 4 sein, ebenso 8 von 9.

   !item Sie brauchen die Elemente nicht pixelweise zu positionieren.
     Diese Arbeit nimmt Ihnen SysGem beim Aufruf von LinkSlider schon
     ab!

  !item Innerhalb des Elementes 1 dÅrfen sich keine weiteren Elemente
     mehr befinden. SysGem benutzt die Ausmaûe dieses Objektes, um
     dort die Texte reinzuschreiben.
!end_itemize
Nun noch eine öbersicht Åber die Routinen fÅr die Sliderbox:


!subnode LinkSlider

!begin_verbatim
BOOL LinkSlider ( OBJECT *tree, INT up, INT dn, INT show, INT hide,
                  INT max, INT box, VOID *buf, INT len, BOOL icons );
!end_verbatim

Bevor es an die Parameter geht, noch mal ein Schema fÅr den Aufbau
einer Sliderbox (nicht schîn, aber selten :-)
!begin_verbatim
    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫                       Dialogbox                           ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫                                                           ∫
    ∫    ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒø        ∫
    ∫    ≥ Testzeile 1, die hier ein wenig lÑnger ist≥≥<- 'up' ∫
    ∫    ≥ Testzeile 2, die hier ein wenig lÑnger ist√ƒ¥        ∫
    ∫    ≥ Testzeile 3, die hier ein wenig lÑnger ist≥ ≥        ∫
    ∫    ≥ ^                                        ^≥ ≥<-'hide'∫
    ∫    ≥ ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ≥ ≥        ∫
    ∫    ≥          'len' zzgl. Nullbyte             ≥±≥        ∫
    ∫    ≥                                           ≥±≥<-'show'∫
    ∫    ≥                                           ≥±≥        ∫
    ∫    ≥                                           √ƒ¥        ∫
    ∫    ≥                                           ≥≥<-'dn'  ∫
    ∫    ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒŸ        ∫
    ∫       ^                                                   ∫
    ∫ 'box'ƒŸ                                                   ∫
    ∫                                                           ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
!end_verbatim
Hier die Parameter:
!begin_xlist [xxxxxxxx]
 !item [tree]     ist der Zeiger auf den Dialog, in dem die 'box' liegt. Der
          Dialog muû vorher mit NewDialog angemeldet worden sein.

 !item [up]       ist die Nummer des Objektes, mit dem der Benutzer die Ein-
          trÑge scrollen kann, also "Pfeil hoch".

 !item [dn]       ist die Nummer des Objektes, mit dem der Benutzer die Ein-
          trÑge schollen kann, also "Pfeil runter".

 !item [show]     ist die Nummer des Objektes, welches als vertikaler Scroll-
          balken fungiert.

 !item [hide]     ist die Nummer des Objektes, welches den vertikalen Scroll-
          balken (show) beinhaltet. In Monochrom fast immer mit einem
          Muster versehen, damit sich der Scrollbalken unterscheiden
          lÑût.

 !item [max]      gibt die Anzahl der EintrÑge an, die im Moment in der
          Sliderbox dargestellt werden sollen. Sind z. B. zwei Ein-
          trÑge als Text vorhanden, so Åbergeben Sie hier eine 2.

 !item [box]      ist die Objektnummer der BOX, in der die Texte der Slider-
          box dargestellt werden sollen. Dieser Parameter dient auch
          zur Identifizierung bei der Handlerfunktion. Bei SG_SLIDER
          wird dann immer der Parameter 'box' mitgeliefert, so daû
          Sie die Sliderbox, auf die sich die Nachricht bezieht,
          sofort erkennen kînnen. Schlieûlich kînnen ja mehrere
          Sliderboxen sich in einem Dialog tummeln.

 !item [buf]      ist ein Zeiger auf einen Speicherbereich, in dem die Ein-
          trÑge fÅr die Sliderbox abgelegt sind. Dieser Buffer muû
          vom Programm fÅr die Laufzeit der Sliderbox statisch gehal-
          ten werden. Jeder einzelne Eintrag muû mit einem 0-Byte
          abgeschlossen sein.

 !item [len]      gibt an, wie lang (incl. Nullbyte) ein Eintrag in der
          Sliderbox ist. Stellen Sie sich einfach den Buffer wie ein
          Array vor; jeder Eintrag muû dort eine bestimmte LÑnge
          besitzen.

 !item [icons]    Wenn Sie vor die EintrÑge der Sliderbox ein Icon plazieren
          wollen, Åbergeben Sie hier TRUE, ansonsten FALSE. FÅr eine
          genaue Beschreibung, wie das mit den Icons geht, siehe
          weiter unten.
!end_xlist
Die Funktion plaziert beim Aufruf die Objekte 'up', 'dn', 'show' und
'hide' automatisch pixelgenau an die rechte Seite der Box. Hier ein
kleines Beispiel:


!image IMG405.IMG Sliderboxen - Ausschnitt aus (!xlink [SysInfo] [SYSINFO.HYP/Inhalt]) in 3D

SysGem kann wie bei den Textfenstern auch vor jeden Eintrag in der
Sliderbox ein Icon bzw. ein beliebiges Objekt plazieren.

Dazu mÅssen die folgenden Voraussetzungen gegeben sein:
!begin_enumerate
  !item Bei LinkSlider muû fÅr 'icons' TRUE angegeben worden sein.

  !item Der Baum, aus dem die Objekte genommen werden sollen, muû via
     NewDialog angemeldet worden sein.

  !item Das erste Byte eines Eintrages in der Sliderbox muû den Wert 255
     haben!
!end_enumerate
Anhand der Kennung 255 erkennt SysGem, daû fÅr diesen Eintrag ein
Icon existiert, welches gezeichnet werden soll. Die Adresse des
Baumes (als LONG) folgt darauf. Danach folgt noch ein Byte, welches
die Nummer des Objektes angibt, daû gezeichnet werden soll.

Beispiel:

Der Text des Eintrages wÅrde "hallo" lauten. Die Adresse des Baumes
wÑre 0x01020304 und das Objekt, daû gezeichnet werden soll, hat die
Nummer 0xA0.

Ein String sÑhe dann so im Speicher aus:
!begin_verbatim
+-------+------+------+------+------+------+-----+-----+-----+
|  255  |  01  |  02  |  03  |  04  |  A0  | 'h' | 'a' | 'l' |
+-------+------+------+------+------+------+-----+-----+-----+
!end_verbatim
In C kînnen Sie diese EintrÑge einfach erzeugen. Hier ein Codefrag-
ment aus dem mitgelieferten Demo:

!begin_verbatim
OBJECT  *rsc_main;                /* Baum-Adresse            */
OBJECT  *rsc_icon;                /* Baum-Adresse            */
BYTE    slider_buffer   [20][30]; /* Buffer fÅr die EintrÑge */

...

for ( i = 0; i < 20; i++ )
  {
    sprintf ( slider_buffer [i], "*----+\tTest Nr. %3d", i + 1 );
    slider_buffer [i][0] = 255;
    slider_buffer [i][1] = (BYTE)((LONG)( rsc_icon ) >> 24 );
    slider_buffer [i][2] = (BYTE)((LONG)( rsc_icon ) >> 16 );
    slider_buffer [i][3] = (BYTE)((LONG)( rsc_icon ) >>  8 );
    slider_buffer [i][4] = (BYTE)((LONG)( rsc_icon ) >>  0 );
    slider_buffer [i][5] = (BYTE) <Objektnummer des Icons>;
  }
LinkSlider ( rsc_main, MA_UP, MA_DN, MA_SHOW, MA_HIDE, 20, MA_BOX,
             &slider_buffer [0][0], 30, TRUE );
!end_verbatim

Das Ergebnis kînnte dann so aussehen:


!image IMG404.IMG Ausschnitt aus dem Demo

LinkSlider liefert TRUE, wenn die Sliderbox angemeldet wurde, FALSE
im Fehlerfalle.


!subnode SPROC
!begin_verbatim
typedef struct
  {
    INT         pos;
    INT         just;
  } TABULAR;

typedef struct
  {
    OBJECT      *tree;
    BYTE        *buffer;
    TABULAR     *tab;
    RECT        area;
    RECT        clip;
    INT         len;
    INT         box;
    INT         line;
    INT         hpos;
    BYTE        *text;
    BOOL        selected;
    BOOL        changed;
    BOOL        drawn;
  } SLD_ENTRY;
!end_verbatim
typedef VOID ( *SPROC )( SLD_ENTRY *entry );


Eine Funktion vom Typ SPROC kÅmmert sich um eine eventuelle Mehrfach-
selektion von EintrÑgen, oder aber, Sie kînnen auch innerhalb dieser
Funktion die einzelnen EintrÑge zeichnen.

FÅr jede Zeile wird dabei die Funktion mit einem Zeiger auf die
Struktur SLD_ENTRY aufgerufen. Diese hat folgende Belegung:
!begin_xlist [xxxxxxxxxxx]
 !item [tree]         ist ein Zeiger auf den Objektbaum, in dem die Sliderbox
              liegt, die mit xLinkSlider angemeldet wurde.

 !item [buffer]       ist der Zeiger, den Sie bei xLinkSlider bei 'buf'
              Åbergeben haben

 !item [tab]          ist ein Zeiger auf ein Array von TABULAR, das die Liste
              der gesetzten (!link [Tabulatoren] [SetListTab]) enthÑlt. Das Ende der Liste
              wird durch einen Eintrag gekennzeichnet, wo sowohl
              'pos' als auch 'just' den Wert -1 besitzen. Siehe auch:
              SetSliderTab

              (!B)Achtung:(!b) Das Array ist read-only!

 !item [area]         beschreibt die genaue Position und die Ausmaûe der
              Zeile, zu dem die Struktur gehîrt.

 !item [clip]         sind die Position und Ausmaûe des Rechtecks, in dem ge-
              zeichnet werden darf (so Sie sollen). Das Clipping-
              Rechteck ist dabei schon gesetzt, Sie kînnen also
              einfach drauflos malen.

 !item [len]         ist die LÑnge einer Zeile im Buffer inclusive des
              Nullbytes.

 !item [box]          ist die Objektnummer der Box, die die Sliderbox
              referenziert.

 !item [line]         ist die Nummer der Zeile, zu der die Struktur gehîrt,
              bzw., die zu zeichnen ist.

 !item [hpos]         ist der horizontale Versatz beim (evtl. vorhandenen)
              horizontalen Slider. Dieser Wert muû beim Zeichnen zu
              'area.x' und einem eventuellen Tabulator dazuaddiert
              werden!

 !item [text]         ist ein Zeiger auf den Text des Eintrags. Aber Achtung:
              Er kann auch NULL sein, z. B. dann, wenn Sie bei
              xLinkSlider fÅr 'buf' NULL Åbergeben haben und somit
              das komplette Zeichnen Åbernehmen wollen.

              Wollen Sie lediglich den Text selbst bestimmen, so
              belegen Sie 'text' einfach mit einem Zeiger auf den
              Text, den SysGem fÅr den Eintrag zeichnen soll.

 !item [selected]     Belegen Sie diese Variable mit TRUE, so zeichnet SysGem
              nach RÅckkehr aus dieser Funktion den Eintrag selek-
              tiert.

 !item [changed]      Belegen Sie diese Variable mit TRUE, so zeichnet SysGem
              nach RÅckkehr aus dieser Funktion den Hintergrund und
              den Eintrag neu (der Wert von 'selected' wird
              beachtet).

 !item [drawn]        Diese Variable (!B)mÅssen(!b) Sie auf TRUE setzen, wenn Sie den
              Eintrag selbst gezeichnet haben. Soll SysGem den
              Eintrag zeichnen, so setzen Sie ihn auf FALSE.
!end_xlist
SysGem zeichnet den Eintrag bzw. die Zeile nach RÅckkehr aus dieser
Funktion nur dann neu, wenn 'text' einen Wert != NULL hat und 'drawn'
== FALSE ist - die Werte aus 'selected' und 'changed' werden dann
allerdings beachtet.


!subnode xLinkSlider

!begin_verbatim
BOOL xLinkSlider ( OBJECT *tree, INT up, INT dn, INT show, INT hide,
                   INT max, INT box, VOID *buf, INT len, BOOL icons,
                   SPROC redraw );
!end_verbatim

Die Funktion LinkSlider hat zwei Nachteile:
!begin_enumerate
  !item Es kann immer nur ein Eintrag selektiert sein und

  !item Es gibt keine Mîglichkeit, die EintrÑge selbst zu zeichnen, wenn
     mal die Notwendigkeit dazu bestehen sollte.
!end_enumerate
Aus diesem Grund wurde die Funktion erweitert, zu xLinkSlider. öber
das Konzept einer eigenen Redraw-Funktion sind somit alle nur
denkbaren Manipulationen durchfÅhrbar.

Ein weiterer (wenn auch geringer) Nachteil ist, daû der Buffer fÅr
den Text immer statisch gehalten werden muû, solange die Sliderbox
"lebt". Hat man sehr viele EintrÑge, kann dies natÅrlich zu
Speicherknappheit fÅhren.

Durch die Redrawfunktion ist es auch mîglich, die EintrÑge weiterhin
von SysGem zeichnen zu lassen (mit den (!link [Tabulatoren] [SetListTab]) und allem, was
dazugehîrt), nur mit dem Unterschied, daû man innerhalb der
Redrawfunktion lediglich den Text angibt, der gezeichnet werden soll.

FÅr weitere Informationen siehe unter SPROC.


!subnode LinkHorSlider

BOOL LinkHorSlider ( OBJECT *tree, INT box, INT left, INT right,
                     INT show, INT hide );


Diese Funktion installiert einen Horizontalen Slider an eine bereits
mit LinkSlider angemeldete Sliderbox.
!begin_xlist [xxxxxxxx]
 !item [tree]     ist die Adresse des Baumes, in dem die Sliderbox liegt.

 !item [box]      ist exakt der Parameter 'box' von LinkSlider. öber diesen
          Parameter wird die Sliderbox eindeutig identifiziert (es
          kînnen ja mehrere vorhanden sein).

 !item [left]     ist die Nummer des Objekts zum scrollen, fÅr das Objekt
          "Pfeil links".

 !item [right]    ist die Nummer des Objekts zum scrollen, fÅr das Objekt
          "Pfeil rechts".

 !item [show]     ist die Nummer des beweglichen Sliders. Dieser muû Child
          von 'hide' sein.

 !item [hide]     ist das Objekt, in dem der bewegliche Slider liegt.
!end_xlist
Nach Aufruf der Funktion positioniert SysGem die einzelnen Objekte
pixelgenau an den unteren Rand der Sliderbox. Sie brauchen dies also
nicht selbst zu erledigen.

Die Funktion liefert TRUE, wenn der Horizontale Slider eingetragen
wurde, FALSE im Fehlerfalle.


!subnode SetSliderTab

BOOL SetSliderTab ( OBJECT *tree, INT box, INT pos, INT just );


Wie auch schon bei den Textfenstern bietet SysGem auch bei den Slider-
boxen die Mîglichkeiten der (!link [Tabulatoren] [SetListTab]), da auch Sliderboxen in einem
beliebigen Font dargestellt werden kînnen (siehe SetSliderFont).
!begin_xlist [xxxxxxxx]
 !item [tree]    Zeiger auf den Objektbaum, in dem die Sliderbox liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.

 !item [pos]     ist die Position des Tabulators. Die Position wird immer in
         Zeichen angegeben, wobei SysGem bei einem Proportionalfont
         die Breite des Zeichens 'W' annimmt und diese Position dann
         in Pixeln umrechnet. So ist gewÑhrleistet, daû die Position
         bei jedem Font eingehalten werden kann.

 !item [just]    ist die Angabe, wie SysGem den Text an dem Tabulator
         ausrichten soll. Es gibt dabei folgende Konstanten:

         (!B)TAB_LEFT(!b) richtet den Text an dem Tabulator nach links aus,
         also linksbÅndig. Der Text wÅrde also zur rechten des
         Tabulators stehen.

         (!B)TAB_RIGHT(!b) richtet den Text an dem Tabulator nach rechts aus,
         also rechtsbÅndig. Der Text wÅrde also zur linken des
         Tabulators stehen.

         (!B)TAB_CENTER(!b) richtet den Text genau zentriert unter dem
         Tabulator aus.

         (!B)TAB_DECIMAL(!b) richtet z. B. eine Zahlenkolonne so aus, daû der
         Dezimaltrenner immer unter dem Tabulator steht. Um Problemen
         mit den verschiedenen Dezimaltrennern aus dem Wege zu gehen,
         nimmt SysGem das Zeichen als Dezimaltrenner an, welches von
         rechts nach links gelesen als ersten dem '.' oder ','
         entspricht.

         Bei 1,234,567.89 wÅrde SysGem das '.' als Dezimaltrenner
         ansehen, bei 1.234.567,89 das ','. Beide Formen kînnen auch
         beliebig gemischt werden, SysGem sucht bei jedem Dezimaltren-
         ner den Text separat ab.
!end_xlist
Die Funktion liefert TRUE, wenn der Tabulator gesetzt wurde, FALSE im
Fehlerfall.


!subnode UpdSliderTab
!begin_verbatim
BOOL UpdSliderTab ( OBJECT *tree, INT tab, INT box, INT pos, INT just );
!end_verbatim

Mit dieser Funktion ist es mîglich, einen Tabulator zu Ñndern. Der
Tabulator mit der Nummer 'tab' (die ZÑhlung lÑuft von links nach
rechts, beginnend bei 0) kann sowohl in seiner Position als auch in
seiner Ausrichtigung geÑndert werden.

Zu den Parametern siehe: SetSliderTab


!subnode SetSliderFont

!begin_verbatim
VOID SetSliderFont ( OBJECT *tree, INT box, INT font_id, INT font_pt,
                     BOOL draw );
!end_verbatim
Die EintrÑge in einer Sliderbox kînnen in einem beliebigen Font darge-
stellt werden, wobei sogar jede Sliderbox einen anderen Font und/oder
eine andere Grîûe besitzen kann. Mit dieser Funktion kann der Font
gesetzt werden.

SysGem Åbernimmt beim Anmelden mit LinkSlider automatisch den einge-
stellten (lokalen) System-Font (siehe auch: SetSysFont).
!begin_xlist [xxxxxxxx]
 !item [tree]       ist die Adresse des Objektbaumes, in dem die Sliderbox
            liegt.

 !item [box]       ist die Objektnummer der Box, die die Sliderbox
            beschreibt. Siehe dazu auch unter bei LinkSlider.

 !item [font_id]    ist die Id des Fonts, der eingestellt werden soll.

 !item [font_pt]    ist die Hîhe des Fonts in Punkten, die eingestellt werden
            soll.

 !item [draw]       gibt an, ob nach dem Einstellen des Fonts die Sliderbox
            neu gezeichnet werden soll (TRUE) oder nicht (FALSE).
            FALSE wÑre z. B. bei einer Vorbelegung innerhalb von
            SG_START nÅtzlich.
!end_xlist

!subnode RedrawSliderBox

VOID RedrawSliderBox ( OBJECT *tree, INT box );


Diese Funktion zeichnet die Sliderbox mit der Box 'box' im Baum
'tree' neu, wobei der gesamte Hintergrund der Sliderbox zuerst in
Weiû gezeichnet wird, und dann die EintrÑge selbst.

Siehe auch: FastDrawSldBox


!subnode FastDrawSldBox

VOID FastDrawSldBox ( OBJECT *tree, INT box );


Diese Funktion zeichnet dieSliderbox mit der Box 'box' im Baum 'tree'
neu, wobei im Gegensatz zu RedrawSliderBox (!B)nur(!b) die EntrÑge gezeichnet
werden.


!subnode ScrollSlider

VOID ScrollSlider ( OBJECT *tree, INT box, INT what );


Mit dieser Funktion ist es mîglich, die EintrÑge der Sliderbox mit
der Box 'box' im Baum 'tree' programmgesteuert zu scrollen.

Parameter fÅr 'what':
!begin_xlist  [xxxxxxxxxxxxxxxxx]
 !item [SCROLL_UP]          Scrollt um eine Zeile nach oben.

 !item [SCROLL_DOWN]        Scrollt um eine Zeile nach unten.

 !item [ SCROLL_RIGHT]       Scrollt um eine Zeile nach rechts.

  !item [SCROLL_LEFT]        Scrollt um eine Zeile nach links.

  !item [SCROLL_PG_UP]       Scrollt um eine Seite nach oben.

  !item [SCROLL_PG_DOWN]     Scrollt um eine Seite nach unten.

  !item [SCROLL_PG_RIGHT]    Scrollt um eine Seite nach rechts.

  !item [SCROLL_PG_LEFT]     Scrollt um eine Seite nach links.
!end_xlist

Sollte eine Aktion nicht ausfÅhrbar sein, so wird der Aufruf
ignoriert.


!subnode AddSliderItem

BOOL AddSliderItem ( OBJECT *tree, INT box, INT anz_items );


SysGem zeichnet nur soviel EintrÑge in der Sliderbox, wie Sie bei
LinkSlider unter 'max' angegeben haben. Nun kann es aber durchaus
sein, daû sich zur Laufzeit die Anzahl der EintrÑge verÑndern. Auf
dieses Problem kann man mit dieser Funktion reagieren.
!begin_xlist [xxxxxxxxxxx]
 !item [tree]         ist die Adresse des Objektbaumes, in dem die Sliderbox
              liegt.

 !item [box]          ist die Objektnummer der Box, die die Sliderbox
              beschreibt. Siehe dazu auch unter bei LinkSlider.

 !item [anz_items]    Ist dieser Wert positiv, so wird die Anzahl der sichtba-
              ren EintrÑge erhîht, anderenfalls erniedrigt. Sollen
              zum Beispiel zwei EintrÑge mehr als unter 'max' bei
              LinkSlider angegeben dargestellt werden, so wÑre der
              Wert fÅr 'anz_items' gleich 2; sind EintrÑge weggefal-
              len, so kann mit einem negativen Wert dies korrigiert
              werden.
!end_xlist
Nach Aufruf dieser Funktion wird die Sliderbox automatisch neu ge-
zeichnet.


!subnode SetSliderPos

INT SetSliderPos ( OBJECT *tree, INT box, INT pos, BOOL draw );


Mit dieser Funktion ist es mîglich, einen ganz bestimmten Eintrag der
Sliderbox an die oberste Stelle des sichtbaren Bereichs zu setzen.
!begin_xlist [xxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.

 !item [pos]     bestimmt, welcher Eintrag an die erste Stelle des sichtbaren
         Bereiches gesetzt wird. Die ZÑhlung der Zeilen beginnt bei
         0.

 !item [draw]    öbergeben Sie hier TRUE, wird die Sliderbox nach dem
         Positionieren des Eintrages neu gezeichnet. Ist dies nicht
         erwÅnscht (z. B. innerhalb SG_START), Åbergeben Sie einfach
         FALSE.
!end_xlist
öbergeben Sie fÅr 'pos' eine -1, liefert die Funktion die Nummer des
Eintrages zurÅck, die an erster Stelle des sichtbaren Bereiches
liegt.


!subnode UnLinkSlider

BOOL UnLinkSlider ( OBJECT *tree, INT box );


Diese Funktion entfernt eine Sliderbox aus der SysGem-Verwaltung.
Diese Funktion muû z. B. aufgerufen werden, wenn Sie den Speicherbe-
reich, in dem Sie die EintrÑge halten, freigeben.
!begin_xlist [xxxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.
!end_xlist
Die Funktion liefert TRUE, wenn die Sliderbox entfernt wurde, FALSE
sonst.


!subnode SelectSldItem

BOOL SelectSldItem ( OBJECT *tree, INT box, INT line, BOOL draw );


Wie Sie auf dem Bild bei den Sliderboxen sehen kînnen, kann ein
Eintrag invertiert dargestellt werden.
!begin_xlist [xxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.

 !item [line]    ist die Nummer des Eintrages, welcher invertiert dargestellt
         werden soll.

 !item [draw]    öbergeben Sie hier TRUE, wird die Sliderbox nach dem
         Positionieren des Eintrages neu gezeichnet. Ist dies nicht
         erwÅnscht (z. B. innerhalb SG_START), Åbergeben Sie einfach
         FALSE.
!end_xlist
Nach Aufruf wird der Eintrag von SysGem selbststÑndig neu gezeichnet.

Ein schon bei Aufruf dieser Funktion invertierter Eintrag wird auto-
matisch wieder deselektiert.

Das deselektieren eines Eintrages kann entweder mit Aufruf von
DeSelSldItem oder Åbergabe von -1 bei 'line' erfolgen.

Die Funktion liefert TRUE, wenn die entsprechende Aktion ausgefÅhrt
wurde, FALSE sonst.

Siehe auch: SetSelColor, SetSelTextColor


!subnode DeSelSldItem

BOOL DeSelSldItem ( OBJECT *tree, INT box, BOOL draw );


Diese Funktion deselektiert einen Eintrag in einer Sliderbox und
zeichnet die Sliderbox danach wieder neu (bzw. den Eintrag).
!begin_xlist [xxxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.

 !item [draw]    öbergeben Sie hier TRUE, wird die Sliderbox nach dem
         Positionieren des Eintrages neu gezeichnet. Ist dies nicht
         erwÅnscht (z. B. innerhalb SG_START), Åbergeben Sie einfach
         FALSE.
!end_xlist
Die Funktion liefert TRUE, wenn die entsprechende Aktion ausgefÅhrt
wurde, FALSE sonst.


!subnode DrawSlider
!begin_verbatim
INT DrawSlider ( OBJECT *tree, INT hide, LONG p1, LONG p2, BOOL draw );
!end_verbatim

Mit dieser Funktion kann ein Prozent-Balken auf einfachste Weise
realisiert werden. Dazu wird nur der Maximalwert (der 100%
entspricht) und der aktuelle Wert der Funktion Åbergeben. DrawSlider
zeichnet dann einen Slider in AbhÑngigkeit dieser Werte.


!image IMG403.IMG So kann ein Prozent-Balken aussehen
!begin_xlist [xxxxxxx]
 !item [tree]    Adresse des Objektbaumes, in dem der Balken liegt.

 !item [hide]    ist die Objektnummer des Hintergrundobjekes, in dem der
         farbige Balken liegt. Bei obigem Bild wÑre dies die Objekt-
         nummer des weiûen Balkens. Da der farbige Balken immer das
         Child des "groûen" sein muû, addiert SysGem, um an die
         Objektnummer dessen zu gelangen, einfach eine 1.

 !item [p1]     ist der aktuelle Wert, also der, der sich den 100% nÑhert.

 !item [p2]      ist der Wert, der, wenn er erreicht wird, den 100%
         entspricht. Ist 'p1' == 'p2', so wÅrde der Prozent-Balken
         bis ganz rechts an den Rand der Begrenzung reichen.

 !item [draw]    gibt an, ob sofort (TRUE) oder nicht (FALSE) gezeichnet wer-
         den soll.
!end_xlist
Die Funktion liefert als Ergebnis die Prozentzahl zurÅck, die darge-
stellt wird (0 <= x <= 100).


!subnode RedrawTheSlider

VOID RedrawTheSlider ( OBJECT *tree, INT box, BOOL draw );


Diese Funktion ermîglicht das Neuzeichnen der Sliderelemente einer
Sliderbox.
!begin_xlist [xxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.

 !item [draw]    ist TRUE, wenn die Sliderelemente sofort gezeichnet werden
         sollen, FALSE sonst,
!end_xlist

!subnode GetSliderItems

INT GetSliderItems ( OBJECT *tree, INT box );


Diese Funktion liefert die Anzahl der in der Sliderbox vorhandenen
Zeilen bzw. EintrÑge.
!begin_xlist [xxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.
!end_xlist

!subnode GetSelectSldItem

INT GetSelectSldItem ( OBJECT *tree, INT box );


Diese Funktion liefert den invertiert Eintrag der Sliderbox oder -1
wenn keiner vorhanden ist.
!begin_xlist [xxxxxxx]
 !item [tree]    ist die Adresse des Objektbaumes, in dem die Sliderbox
         liegt.

 !item [box]     ist die Objektnummer der Box, die die Sliderbox beschreibt.
         Siehe dazu auch unter bei LinkSlider.
!end_xlist

!node Logfenster

WÑhrend des Programmlaufes kann es manchmal wÅnschenswert sein,
bestimmte Meldungen des Programmstatus oder vielleicht
Fehlermeldungen auszugeben. Wenn dann schon alles in GEM lÑuft, wÑre
es natÅrlich auch schîn, wenn die Meldungen ebenfalls in einem Fen-
ster erscheinen wÅrden.

In TOS-Programmen war dies kein Problem, und gerade in C hilft die
FlexibilitÑt von printf enorm. SysGem bietet nun die Mîglichkeit, mit
Hilfe eines modifizierten printf, diese Ausgaben in ein Fenster
umzuleiten, bzw. beliebige Texte in ein Fenster auszugeben.

Mit den Funktionen, die SysGem fÅr die Logfenster bereitstellt, ist
es auch ein leichtes, eine Art Mini-Editor mit geringstem Aufwand zu
realisieren.

Um die aktuelle Textposition zu verdeutlichen, zeichnet SysGem an
diese Position einen blinkenden Blockcursor.

Hier ein Beispiel, wie ein solches Fenster aussehen kann:


!image IMG402.IMG So kann ein Logfenster aussehen

...und hier die öbersicht Åber die angebotenen Funktionen:


!subnode OpenLogWindow

!begin_verbatim
BOOL OpenLogWindow ( LONG win_id, BYTE *title, BYTE *info,
                     INT columns, INT rows, INT x, INT y,
                     APROC action );
!end_verbatim


Diese Funktion îffnet - wie der Name schon sagt - ein Logfenster.
!begin_xlist [xxxxxxxx]
 !item [win_id]     ist die Fenster-Id, unter der das Fenster im weiteren Pro-
            grammlauf angesprochen werden soll.

 !item [title]      ist ein Zeiger auf den Namen, der als Fenstertitel
            verwendet wird. Dabei setzt SysGem selbststÑndig vor und
            hinter den Namen jeweils ein Leerzeichen, so daû Sie es
            im Programm nicht immer machen mÅssen (spart immer 2 Byte
            :-))

            Vor den ganzen Text setzt SysGem dann - wenn das Programm
            in einer Multitasking-Umgebung lÑuft - immer den Pro-
            grammnamen, der automatisch von InitGem Åbernommen wird.
            Sie kînnen ihn aber jederzeit mit SetProgramName
            umÑndern.

            Sollte als erstes Zeichen ein Balken ('|') stehen, so
            Åbernimmt SysGem den gesamten String ohne énderungen als
            Fenstertitel.

 !item [info]       ist ein Zeiger auf eine optionale Infozeile. Wenn angege-
            ben, wird der String ohne énderungen Åbernommen.

            Wollen Sie keine Infozeile, so Åbergeben Sie einfach
            einen Leerstring.

 !item [columns]    ist die Anzahl der Spalten, Åber die das Fenster verfÅgen
            soll. Geben Sie z. B. 50 an, so ist das Fenster 50
            Zeichen breit.

 !item [rows]       gibt die Anzahl der Zeilen an, Åber die das Fenster
            verfÅgen soll. Die Mindestgrîûe ist 3 Zeilen, die
            Maximalgrîûe 60 Zeilen. Geben Sie einen Wert < 3 oder >
            60 an, korrigiert SysGem diese Werte automatisch.

 !item [x]          ist die X-Koordinate, an der das Fenster auf dem
            Bildschirm erscheinen soll.

 !item [y]          ist die Y-Koordinate, an der das Fenster auf dem
            Bildschirm erscheinen soll.

 !item [action]     ist die Handlerfunktion des Fensters. Sie erhÑlt alle Be-
            nutzeraktivitÑten.

            Sie kînnen hier auch NULL angeben, dann wird das Fenster
            geschlossen, wenn der Benutzer auf den Closer klickt.

            Die Angabe einer Handlerfunktion ist nîtig, wenn Sie
            vorhaben, aus dem Fenster eine Art Mini-Editor zu bauen.
            Mit Hilfe der SG_KEY-Nachricht ist dies schnell und
            unkompliziert mîglich.
!end_xlist
Die Funktion îffnet das Fenster in der Grîûe, wie dies aus der
Berechnung der Zeilen und Spalten mit dem aktuellen Font hervorgeht.

Die Funktion liefert TRUE, wenn das Fenster geîffnet wurde, FALSE
sonst.

!subnode xOpenLogWindow


!begin_verbatim
BOOL xOpenLogWindow ( LONG win_id, BYTE *title, BYTE *info,
                      INT anz_trees, XTREE *trees, INT columns,
                      INT rows, INT x, INT y, VOID *user,
                      APROC action );
!end_verbatim

Diese Funktion îffnet, wie auch OpenLogWindow ein Logfenster. Allerdings
bestehen noch mehr Mîglichkeiten z.B. kann man einen Userzeiger Åbergeben.
!begin_xlist [xxxxxxxxx]
 !item [win_id]     ist die Fenster-Id, unter der das Fenster im weiteren Pro-
            grammlauf angesprochen werden soll.

 !item [title]      ist ein Zeiger auf den Namen, der als Fenstertitel
            verwendet wird. Dabei setzt SysGem selbststÑndig vor und
            hinter den Namen jeweils ein Leerzeichen, so daû Sie es
            im Programm nicht immer machen mÅssen (spart immer 2 Byte
            :-))

            Vor den ganzen Text setzt SysGem dann - wenn das Programm
            in einer Multitasking-Umgebung lÑuft - immer den Pro-
            grammnamen, der automatisch von InitGem Åbernommen wird.
            Sie kînnen ihn aber jederzeit mit SetProgramName
            umÑndern.

            Sollte als erstes Zeichen ein Balken ('|') stehen, so
            Åbernimmt SysGem den gesamten String ohne énderungen als
            Fenstertitel.

 !item [info]       ist ein Zeiger auf eine optionale Infozeile. Wenn angege-
            ben, wird der String ohne énderungen Åbernommen.

            Wollen Sie keine Infozeile, so Åbergeben Sie einfach
            einen Leerstring.

 !item [anz_trees]	Muû die Anzahl der ObjektbÑume enthalten, die man bei 
            trees Åbergibt.
 
 !item [trees]			Struktur die die ObjektbÑume, welche in den Dialog einge-
 						bettet werden enthÑlt. (siehe XTREE)

 !item [columns]    ist die Anzahl der Spalten, Åber die das Fenster verfÅgen
            soll. Geben Sie z. B. 50 an, so ist das Fenster 50
            Zeichen breit.

 !item [rows]       gibt die Anzahl der Zeilen an, Åber die das Fenster
            verfÅgen soll. Die Mindestgrîûe ist 3 Zeilen, die
            Maximalgrîûe 60 Zeilen. Geben Sie einen Wert < 3 oder >
            60 an, korrigiert SysGem diese Werte automatisch.

 !item [x]          ist die X-Koordinate, an der das Fenster auf dem
            Bildschirm erscheinen soll.

 !item [y]          ist die Y-Koordinate, an der das Fenster auf dem
            Bildschirm erscheinen soll.

 !item [user]       Zeiger auf irgendwas. Zur freien VerfÅgung.

 !item [action]     ist die Handlerfunktion des Fensters. Sie erhÑlt alle Be-
            nutzeraktivitÑten.

            Sie kînnen hier auch NULL angeben, dann wird das Fenster
            geschlossen, wenn der Benutzer auf den Closer klickt.

            Die Angabe einer Handlerfunktion ist nîtig, wenn Sie
            vorhaben, aus dem Fenster eine Art Mini-Editor zu bauen.
            Mit Hilfe der SG_KEY-Nachricht ist dies schnell und
            unkompliziert mîglich.
!end_xlist
Die Funktion îffnet das Fenster in der Grîûe, wie dies aus der
Berechnung der Zeilen und Spalten mit dem aktuellen Font hervorgeht.

Die Funktion liefert TRUE, wenn das Fenster geîffnet wurde, FALSE
sonst.


!subnode wprintf

VOID wprintf ( LONG win_id, BYTE *format, ... );


wprintf arbeitet exakt so wie printf aus <stdio.h>. Der einzige
Unterschied zu printf, ist die Angabe der Fenster-Id, die Kennung, in
welches Fenster die Daten geschrieben werden sollen.

wprintf fÑngt erst dann eine neue Zeile an, wenn Sie explizit ein
'\n' oder '\r' ausgeben; sollten Sie etwas ausgeben, was so breit ist,
daû es rechts aus dem Fenster "raushÑngen" wÅrde, so wird nicht umge-
brochen, sondern der Rest des String abgeschnitten.

Wird der untere Rand des Fensters erreicht, so scrollt SysGem den Fen-
sterinhalt automatisch nach oben.

Der Cursor wird immer hinter das letzte ausgegebene Zeichen gesetzt.


!subnode wcls

VOID wcls ( LONG win_id );


Diese Funktion lîscht das Logfenster mit der Id 'win_id' und setzt
den Cursor in die linke obere Ecke (0, 0)


!subnode wposxy

VOID wposxy ( LONG win_id, INT x, INT y );


Mit dieser Funktion kînnen Sie den Cursor auf eine beliebige Zelle
innerhalb des Logfensters mit der Id 'win_id' setzten.

An diesen Koordinaten wird dann auch der nÑchste Text, der mit
wprintf ausgegeben werden soll, ausgegeben.

Die linke obere Ecke liegt dabei an den Koordinaten (0, 0). Illegale
Koordinaten werden ignoriert.


!subnode wgetxy

VOID wgetxy ( LONG win_id, INT *x, INT *y );


Diese Funktion liefert die Koordinaten des Cursors in dem Logfenster
mit der Id 'win_id'.


!subnode wgetchar

BYTE wgetchar ( LONG win_id, INT x, INT y, INT *effect );


Diese Funktion liefert den ASCII-Code des Zeichens, der sich im
Logfenster 'win_id' an den Koordinaten (x, y) befindet.

'effect' ist reserviert fÅr zukÅnftige Versionen, die öbergabe von
NULL ist zulÑssig. Wird ein Zeiger auf eine Variable Åbergeben,
schreibt SysGem dorthinein den Wert 0 (Stand: SysGem 2.01)


!subnode HideCursor

VOID HideCursor ( LONG win_id );


Diese Funktion schaltet in dem Logfenster mit der Id 'win_id' den
Cursor aus.


!subnode ShowCursor

VOID ShowCursor ( LONG win_id );


Diese Funktion schaltet in dem Logfenster mit der Id 'win_id' den
Cursor ein (Voreinstellung).

!subnode NoEscSequence

VOID NoEscSequence ( LONG win_id, BOOL esc )


Diese Funktion schaltet in dem Logfenster mit der Id 'win_id' die
Auswertung von ESC Sequencen aus (TRUE) oder an (FALSE).

!node Fontroutinen

SysGem 2.01 kann problemlos mit verschiedenen Fonts umgehen. Daraus
resultieren ein paar Funktionen:


!subnode FontSelect

!begin_verbatim
BOOL FontSelect ( INT buttons, INT *id, INT *pt, BYTE *title,
                  BYTE *example, BOOL internal, TPROC help );
!end_verbatim

Diese Funktion stellt den SysGem eigenen Fontselektor dar. Dieser ist
eigentlich als Notnagel gedacht, falls kein (!xlink [xFSL] [XFSL.HYP/Titel])-kompatibler gefunden
wird (z. B. (!xlink [Calvino] [CALVINO.HYP/Titel])). Erwarten Sie deshalb nicht den ultimativen
Konfort.


!image IMG401.IMG Der eingebaute Font-Selector

Hier die Parameter:
!begin_xlist [xxxxxxxx]
 !item [buttons]    ist ein Bitfeld, welches angibt, welche Buttons im
            Fontselector zu sehen sein sollen.

            (!B)BUT_OK(!b) stellt den "OK"-Button zur VerfÅgung

            (!B)BUT_ABORT(!b) stellt den "Abbruch"-Button zur VerfÅgung

            (!B)BUT_SYSTEM(!b) stellt den "System"-Button zur VerfÅgung.
            Klickt der Benutzer auf diesen Button, wird der
            Applikationslokale Systemfont auf diesen Font geÑndert
            und allen anderen Fenstern mittels der Nachricht
            SG_NEWFONT mitgeteilt.

            (!B)BUT_HELP(!b) stellt den "HILFE"-Button dar.

            (!B)BUT_ALL(!b) stellt alle Buttons dar.

            Wollen Sie nur einzelne Buttons darstellen lassen, so
            verodern Sie einfach die entsprechenden Konstanten.

 !item [id]         enthÑlt nach dem Aufruf die Id des Fonts, der ausgewÑhlt
            wurde.

            Wird ein Zeiger auf ein INT Åbergeben, liest SysGem
            diesen aus und versucht, den entsprechenden Font beim
            ôffnen des Fontselektors zu selektieren.

 !item [pt]         enthÑlt nach dem Aufruf die Grîûe des Fonts in Punkten,
            der ausgewÑhlt wurde.

            Wird ein Zeiger auf ein INT Åbergeben, liest SysGem
            diesen aus und versucht, die entsprechende Grîûe beim
            ôffnen des Fontselektors zu selektieren.

 !item [title]      ist ein String, der als Fenstertitel dienen soll.

            Dabei setzt SysGem selbststÑndig vor und hinter den Namen
            jeweils ein Leerzeichen, so daû Sie es im Programm nicht
            immer machen mÅssen (spart immer 2 Byte :-))

            Vor den ganzen Text setzt SysGem dann - wenn das Programm
            in einer Multitasking-Umgebung lÑuft - immer den Pro-
            grammnamen, der automatisch von InitGem Åbernommen wird.
            Sie kînnen ihn aber jederzeit mit SetProgramName
            umÑndern.

            Sollte als erstes Zeichen ein Balken ('|') stehen, so
            Åbernimmt SysGem den gesamten String ohne énderungen als
            Fenstertitel.

            Der Name braucht nicht statisch gehalten zu werden.

 !item [example]    ist ein Text, der als Beispiel dargestellt werden soll.
            Soll der eingebaute genommen werden, Åbergeben Sie
            einfach einen Leerstring oder NULL.

 !item [internal]   ist TRUE, wenn Sie die Darstellung des eingebauten Font-
            Selektors erzwingen wollen. öbergeben Sie FALSE, wird,
            wenn vorhanden, ein (!xlink [xFSL] [XFSL.HYP/Titel])-kompatibler genommen. Erst wenn
            dies fehlschlÑgt, erscheint der interne.

 !item [help]       ist eine CallBack-Funktion, die dann aufgerufen wird,
            wenn der Benutzer auf den HELP-Button geklickt hat.
!end_xlist
Die Funktion liefert TRUE, wenn der Benutzer einen Font ausgewÑhlt
hat, FALSE wenn nicht.


!subnode FontExists

BOOL FontExists ( INT font_id );


Diese Funktion liefert TRUE, wenn ein Font mit der Id 'font_id'
existiert, FALSE, wenn nicht.


!subnode GetFontId

INT GetFontId ( BYTE *font_name );


Diese Funktion sucht zu einem Fontnamen die Id und liefert diese -
wenn gefunden - zurÅck, ansonsten -1.


!subnode GetFontName

BYTE *GetFontName ( INT font_id );


Diese Funktion liefert zu einer Font-Id einen Zeiger auf den Font-
Namen (Null-Terminiert) zurÅck. Dieser Zeiger ist READ-ONLY!

Die Funktion liefert NULL, wenn der Font nicht gefunden wurde.


!subnode VectorFont

BOOL VectorFont ( INT font_id );


Die Funktion liefert TRUE, wenn es sich bei dem Font mit der Id
'font_id' nicht um einen Bitmap-Font handelt.


!subnode NormalFont

VOID NormalFont ( VOID );


Schaltet auf den normalen System-Font zurÅck.


!subnode SmallFont

VOID SmallFont ( VOID );


Schaltet auf den kleinen System-Font zurÅck.


!subnode SetFont

VOID SetFont ( INT font_id, INT pt );


Setzt fÅr die nÑchsten Ausgaben via v_xtext oder v_stext den
Zeichensatz auf den Font 'font_id' mit der Grîûe von 'pt' Punkten.


!subnode StringWidth

INT StringWidth ( BYTE *text );


Liefert die Breite eines Strings in Pixeln zurÅck. Proportionalfonts
werden berÅcksichtigt. Es gilt der aktuelle Font.

Siehe auch: SetFont


!subnode StringHeight

INT StringHeight ( VOID );


Liefert die Hîhe des grîûten Zeichens in Pixeln zurÅck. Es gilt der
aktuelle Font.

Siehe auch: SetFont


!subnode CenterX

INT CenterX ( INT x1, INT x2, BYTE *text );


Diese Funktion zentriert den Text 'text' zwischen den beiden
Koordinaten 'x1' (links) und 'x2' (rechts) und liefert die daraus
resultierende X-Koordinate als Funktionswert zurÅck.

Es gilt der aktuelle Font.

Siehe auch: SetFont


!subnode CenterY

INT CenterY ( INT y1, INT y2 );


Diese Funktion zentriert das hîchste Zeichen des aktuellen Fonts
zwischen den beiden Koordinaten 'y1' (oben) und 'y2' (unten) und
liefert die daraus resultierende Y-Koordinate als Funktionswert
zurÅck.

Siehe auch: SetFont


!subnode v_xtext

VOID v_xtext ( INT color, INT x, INT y, BYTE *text );


Diese Funktion zeichnet den Text 'text' im aktuell eingestellten
Zeichensatz an den Koordinaten (x, y) in der Farbe 'color'.

Der Text, der ausgegeben werden soll, darf lÑnger als 127 Zeichen
sein.

Siehe auch: v_stext


!subnode v_stext

VOID v_stext ( INT color, INT x, INT y, BYTE *text );


Diese Funktion zeichnet den Text 'text' im aktuell eingestellten
Zeichensatz an den Koordinaten (x, y) in der Farbe 'color'.

Der Text, der ausgegeben werden soll, darf (!B)nicht(!b) lÑnger als 127
Zeichen sein.

Siehe auch: v_xtext


!subnode SetSysFont

VOID SetSysFont ( INT font_id );


Diese Funktion "jubelt" SysGem einen neuen System-Font unter. Ab
sofort wird dann jeder Text, Button usw. in dem Font mit der Id
'font_id' gezeichnet.

Als Grîûe wird die Punktgrîûe des vorherigen System-Fonts genommen.

Alle Handlerfunktionen erhalten nach dem Aufruf die Nachricht
SG_NEWFONT.

Es ist jeder beliebige Font zulÑssig.


!subnode SendFontChanged

VOID SendFontChanged ( INT font_id, INT font_pt );


Schickt allen Handlerfunktionen die Nachricht SG_NEWFONT mit den
beiden angegebenen Parametern.


!subnode ResetSysFont

VOID ResetSysFont ( VOID );


Wurde der System-Font mit SetSysFont geÑndert, so kann mit Aufruf
dieser Funktion der eigentliche System-Font wieder hergestellt wer-
den.


!node Nachrichten von SysGem

Die gesamte Kommunikation von SysGem mit den anderen Komponenten (Fen-
stern, Dialogen usw.) wird Åber Nachrichten abgewickelt.

Bei jeder AktivitÑt des Benutzers oder bei Mitteilungen von SysGem an
eine Komponente wird der jeweiligen Handlerfunktion eine Nachricht
geschickt. Die Handerfunktion hat dann die Mîglichkeit, auf diese
Nachricht zu reagieren. Sie kann weitere Aktionen ausfÅhren, die
gerade aktuelle Aktion abblocken oder sich in das weitere Verhalten
von SysGem einmischen.

Die Nachrichten im einzelnen:


!subnode SG_START

SG_START wird verschickt, wenn ein Fenster geîffnet wurde und auf dem
Bildschirm erschienen ist. Jetzt wÑre also der richtige Ort und die
Zeit, bestimmte Voreinstellungen zu treffen. Handelt es sich bei dem
Fenster um einen Fensterdialog, so kann man bei Eintreffen dieser
Nachricht z. B. Radiobuttons oder Editfelder vorbelegen.

Sind im Fensterdialog Editfelder vorhanden, so sind diese beim
Eintreffen dieser Nachricht bereits gelîscht. Es ist also kein Aufruf
von ClearEditFields mehr nîtig.

Erst wenn die Handlerfunktion zurÅckkehrt, wird der Inhalt des Fen-
sters gezeichnet.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_NOWIN

SG_NOWIN wird verschickt, wenn ein Fenster geîffnet werden sollte,
aber aus irgendeinem Grunde (kein Handle mehr frei) dieses nicht
geîffnet werden konnte. Die entsprechende Funktion wird zwar einen
Fehlercode liefern, allerdings wird der Handlerfunktion zur
Sicherheit nochmal diese Nachricht geschickt.

                               (!B)Achtung(!b)

Sowohl der Zeiger auf WINDOW_INFO als auch auf DIALOG_INFO ist NULL;
es gibt ja kein Fenster, zu dem Informationen existieren wÅrden.

Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_END

SG_END wird verschickt, wenn die Mîglichkeit besteht, daû das Fenster
geschlossen werden soll. Dieser Fall tritt ein, wenn z. B. in einem
Fensterdialog der Benutzer einen Button angeklickt hat. Wie das Pro-
gramm darauf reagiert - ob es jetzt einen weiteren Dialog îffnet,
eine Datei lÑdt oder das Fenster tatsÑchlich schlieût, bleibt diesem
Åberlassen.

(!B)Wichtig: SG_END tritt nur bei Fensterdialogen auf! Bei "normalen" Fen!-stern
wird SG_BUTTON verschickt!(!b)

(!B)SG_END hat bei "normalen" Fenstern eine andere Bedeutung, siehe
unten!(!b)

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

Der Parameter 'button' der Handlerfunktion enthÑlt die Nummer des
Objektes, welches der Benutzer angeklickt hat.

(!B)Achtung:(!b) Hat 'button' den Wert -1, so wurde der Closer des Fensters
angeklickt (sofern das Fenster einen Closer haben durfte).

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

SG_END wird an ein normales Fenster geschickt, wenn der Closer des
Fensters angeklickt wurde. Ansonsten tritt diese Nachricht nie auf.

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_END2

Entspricht SG_END, nur besagt SG_END2, daû das Objekt mit einem
Doppelklick angewÑhlt wurde.


!subnode SG_REND

Entspricht SG_END, nur besagt SG_REND, daû das Objekt mit einem Klick
der rechten Maustaste angewÑhlt wurde.


!subnode SG_REND2

Entspricht SG_END2, nur besagt SG_REND2, daû das Objekt mit einem
Doppelklick der rechten Maustaste angewÑhlt wurde.


!subnode SG_QUIT

Diese Nachricht wird verschickt, wenn ein Fenster geschlossen wurde.
Da mittels des User-Zeigers meistens noch eigendwelche Daten und
Speicherbereiche zu diesem Fenster gefÅhrt werden, ist es notwendig,
diese wieder zu entfernen bzw. freizugeben. Das kann und muû bei
Eintreffen von SG_QUIT geschehen. Nach RÅckkehr aus der Handlerfunk-
tion existiert das Fenster nicht mehr.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_TIMER

Es ist ein Timer-Event aufgetreten.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_FTIMER

Ein Timer-Event ist aufgetreten. Wie mit UseFastTimer festgelegt,
wird aus GeschwindigkeitsgrÅnden auf die Belegung der Strukturen
verzichtet.

Die Zeiger auf die Strukturen (WINDOW_INFO/DIALOG_INFO) sind jeweils
NULL!!!

Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_POSX

Ein Fensterdialog wurde in X-Richtung verschoben.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

Die neue X-Koordinate wird der Handlerfunktion im Parameter 'button'
mitgeteilt.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT (= Neue Position akzeptieren), SG_ABORT


!subnode SG_POSY

Ein Fensterdialog wurde in Y-Richtung verschoben.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

Die neue Y-Koordinate wird der Handlerfunktion im Parameter 'button'
mitgeteilt.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT (= Neue Position akzeptieren), SG_ABORT


!subnode SG_VISIBLE

Das Fenster ist wieder sichtbar, daû heiût, der Arbeitsbereich (oder
zumindest ein Teil davon) ist auf dem Bildschirm wieder zu sehen.

SG_VISIBLE wird z. B. nach dem Ent-Iconifizieren oder nach dem
Einblenden (MagiC) verschickt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_INVISIBLE

Das Fenster ist ab dem Eintreffen der Nachricht nicht mehr sichtbar,
entweder, weil es ausgeblendet (MagiC) oder iconifiziert oder aber
der Arbeitsbereich komplett aus dem Bildschirm "geschoben" wurde.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_TOP

Das Fenster wurde getoppt, bzw. es liegt nun an der obersten Stelle
auf dem Bildschirm.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_UNTOP

Das Fenster liegt unter einem (oder mehreren) Fenstern.

Die Nachricht wird nur verschickt, wenn das Fenster vorher das aktive
war.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_SIZED

Das Fenster hat seine Grîûe geÑndert, bzw., soll seine Grîûe Ñndern.

Diese Nachricht wird nur an ein "normales" Fenster verschickt, bei
einem Fensterdialog tritt diese Nachricht nie auf.

!begin_verbatim
Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des (!B)alten(!b) Brutto- Arbeitsberei-
               ches. Eventuell eingelinkte BÑume zÑhlen zu diesem
               Rechteck dazu!

 draw_area     enthÑlt die Ausmaûe des (!B)alten(!b) Netto- Arbeitsbereiches.
               Dieses Rechteck entspricht dem reinen Arbeitsbereich,
               in dem Daten des Programms dargestellt werden kînnen.

 clip          Die neuen Koordinaten des Fensters und die neuen
               Ausmaûe des Netto-Arbeitsbereiches.
!end_verbatim
Sollten die Koordinaten nicht "gefallen", so kînnen sie mit den Funk-
tionen SetFulledX, SetFulledY, SetFulledW und SetFulledH dementsprech-
end geÑndert werden.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ABORT


!subnode SG_FULLED

Das Fenster wurde auf die volle Bildschirmgrîûe gebracht, bzw, soll
auf die volle Bildschirmgrîûe gebracht werden.

Diese Nachricht wird nur an ein "normales" Fenster verschickt, bei
einem Fensterdialog tritt diese Nachricht nie auf.

!begin_verbatim
Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des (!B)alten(!b) Brutto- Arbeitsberei-
               ches. Eventuell eingelinkte BÑume zÑhlen zu diesem
               Rechteck dazu!

 draw_area     enthÑlt die Ausmaûe des (!B)alten(!b) Netto- Arbeitsbereiches.
               Dieses Rechteck entspricht dem reinen Arbeitsbereich,
               in dem Daten des Programms dargestellt werden kînnen.

 clip          Die neuen Koordinaten des Fensters und die neuen
               Ausmaûe des Netto-Arbeitsbereiches.
!end_verbatim
Sollten die Koordinaten nicht "gefallen", so kînnen sie mit den Funk-
tionen SetFulledX, SetFulledY, SetFulledW und SetFulledH dementsprech-
end geÑndert werden.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ABORT


!subnode SG_MOVED

Das Fenster hat seine Position geÑndert, bzw., soll seine Position
Ñndern.

Diese Nachricht wird nur an ein "normales" Fenster verschickt, bei
einem Fensterdialog tritt diese Nachricht nie auf.

!begin_verbatim
Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des (!B)alten(!b) Brutto- Arbeitsberei-
               ches. Eventuell eingelinkte BÑume zÑhlen zu diesem
               Rechteck dazu!

 draw_area     enthÑlt die Ausmaûe des (!B)alten(!b) Netto- Arbeitsbereiches.
               Dieses Rechteck entspricht dem reinen Arbeitsbereich,
               in dem Daten des Programms dargestellt werden kînnen.

 clip          Die neuen Koordinaten des Fensters und die neuen
               Ausmaûe des Netto-Arbeitsbereiches.
!end_verbatim
Sollten die Koordinaten nicht "gefallen", so kînnen sie mit den Funk-
tionen SetFulledX und SetFulledY dementsprechend geÑndert werden.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ABORT


!subnode SG_LCLICK1

Diese Nachricht wird verschickt, wenn der Benutzer einen Einfachklick
in den Arbeitsbereich des Fenster getÑtigt hat.

Diese Nachricht wird nur an ein "normales" Fenster verschickt, bei
einem Fensterdialog tritt diese Nachricht nie auf.

!begin_verbatim
Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 state         enthÑlt den Status der Sondertasten.

 mx, my        enthalten die X und Y-Position des Punktes, auf den
               der Benutzer geklickt hat. Die Angaben erfolgen in
               Pixeln.

 line          Befindet sich im Fenster eine mit LinkList oder
               xLinkList hinzugefÅgte Liste, und befindet sich unter
               dem Punkt, den der Benutzer angeklickt hat, eine
               Textzeile, so enthÑlt 'line' die Nummer der Zeile, die
               unter dem angeklickten Punkt liegt.

               Befindet sich dort keine Zeile, ist 'line' == -1L.

 column        Befindet sich im Fenster eine mit LinkList oder
               xLinkList hinzugefÅgte Liste, und befindet sich unter
               dem Punkt, den der Benutzer angeklickt hat, eine
               Textzeile, so enthÑlt 'column' die Nummer der Spalte,
               die unter dem angeklickten Punkt liegt.

               Befindet sich dort kein Zeichen (weil die Zeile zu
               kurz ist), hat 'column' den Wert -1L.

 line_ptr      wenn 'line' != -1L, so enthÑlt dieser Zeiger einen
               Zeiger auf das erste Zeichen des Textes, der sich in
               dieser Zeile befindet. Der Text dieser Zeile darf
               nicht verÑndert werden, er ist (!B)read-only(!b)! Zum éndern
               kînnen Sie die Funktionen ChgInList oder xChgInList
               verwenden.

 line_user     Bei den xLink... Funktionen kînnen Sie fÅr jede Zeile
               einen eigenen User-Zeiger mitgeben. War einer angege-
               ben, enthÑlt diese Variable diesen Zeiger, ansonsten
               NULL.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_LCLICK2

Exakt wie bei SG_LCLICK1, jedoch zeigt diese Nachricht an, daû der
Benutzer diesen Punkt mit einem Doppelklick angewÑhlt hat.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_RCLICK1

Exakt wie bei SG_LCLICK1, jedoch zeigt diese Nachricht an, daû der
Benutzer diesen Punkt mit der rechten Maustaste angewÑhlt hat.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_RCLICK2

Exakt wie bei SG_LCLICK2, jedoch zeigt diese Nachricht an, daû der
Benutzer diesen Punkt mit einem Doppelklick mit der rechten Maustaste
angewÑhlt hat.

Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_BUTTON

SG_BUTTON wird verschickt, wenn die Mîglichkeit besteht, daû das Fen-
ster geschlossen werden soll. Dieser Fall tritt ein, wenn ein Button
angeklicht wurde, er in das Fenster eingelinkt wurde. Wie das Pro-
gramm darauf reagiert - ob es jetzt einen weiteren Dialog îffnet,
eine Datei lÑdt oder das Fenster tatsÑchlich schlieût, bleibt diesem
Åberlassen.

!begin_verbatim
Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, welches der
               Benutzer angeklickt hat und was zu dieser Nachricht
               fÅhrte.

 obj_id        enthÑlt die ID des Baumes, die Sie entweder bei
               LinkTree oder bei XTREE angegeben haben.

 tree          ist ein Zeiger auf den Objektbaum, in dem das Objekt
               liegt, welches der Benutzer angeklickt hat.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_BUTTON2

Entspricht SG_BUTTON, nur besagt SG_BUTTON2, daû das Objekt mit einem
Doppelklick angewÑhlt wurde.


!subnode SG_RBUTTON

Entspricht SG_BUTTON, nur besagt SG_RBUTTON, daû das Objekt mit einem
Klick der rechten Maustaste angewÑhlt wurde.


!subnode SG_RBUTTON2

Entspricht SG_BUTTON2, nur besagt SG_RBUTTON2, daû das Objekt mit
einem Doppelklick der rechten Maustaste angewÑhlt wurde.


!subnode SG_KEY

SG_KEY wird verschickt, wenn der Benutzer eine Taste gedrÅckt hat.
Bevor jedoch diese Nachricht verschickt wird, geht SysGem wie folgt
vor:
!begin_enumerate
  !item Der Benutzer betÑtigt eine Taste.

  !item Hat das Programm eine MenÅzeile, prÅft SysGem, ob der Shortcut
     auf einen Eintrag passt. Ist dies der Fall, bricht SysGem die
     Verarbeitung ab und teilt der Handlerfunktion der MenÅzeile den
     passenden MenÅeintrag mit.

  !item Hat das aktuelle Fenster eine MenÅzeile, prÅft SysGem, ob der
     Shortcut auf einen dieser EintrÑge passt. Ist dies der Fall,
     bricht SysGem die Verarbeitung ab und teilt der Handlerfunktion
     mittels der Nachricht SG_MENU die Anwahl der MenÅzeile mit.

  !item SysGem prÅft, ob der Tastendruck auf einen Shortcut eines But-
     tons passt. Ist dies der Fall, wird mittels SG_END oder
     SG_BUTTON dies der Handlerfunktion mitgeteilt.

  !item Ist die Taste die Help-Taste, wird die Nachricht SG_HELP
     verschickt.

  !item Ist die Taste die Undo-Taste, wird die Nachricht SG_UNDO
     verschickt.

  !item Wurde mittels TellKeyStrokes festgelegt (und nur dann), daû
     TastendrÅcke vorab zu senden sind, bevor SysGem diese weiter
     auswertet (z. B. Clipboard-Kopierfunktionen), wird nun SG_KEY
     verschickt. Darf und soll der Tastendruck nicht weiter verarbei-
     tet werden, muû die Handlerfunktion SG_KEYUSED zurÅckliefern.

  !item Handelt es sich bei dem Fenster um einen Fensterdialog, wird
     SG_EDKEY verschickt. FÅr weitere Informationen siehe dort.

  !item Handelt es sich bei dem Fenster um ein normales Fenster, wird
     jetzt erst die Nachricht SG_KEY verschickt.
!end_enumerate

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt den Scancode der gedrÅckten Taste im NKCC-Format.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 kstate        enthÑlt den Status der Sondertasten.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 denied        enthÑlt den Scancode der gedrÅckten Taste im AES-
               Format (wie EventMulti ihn liefert).

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 key           enthÑlt den Scancode der gedrÅckten Taste im NKCC-
               Format.

 state         enthÑlt den Status der Sondertasten.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 denied        enthÑlt den Scancode der gedrÅckten Taste im AES-
               Format (wie EventMulti ihn liefert).
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_KEYCONT, SG_KEYUSED

Handelt es sich bei dem Fenster um einen Fensterdialog und wird
SG_KEYCONT zurÅckgeliefert, so verarbeitet SysGem den Tastendruck
weiter, so z. B. an die Routine, die fÅr die Cursorsteuerung in den
Editfeldern zustÑndig ist usw.

Es ist also wichtig, daû Sie, wenn Sie den Tastendruck nicht
brauchen, immer SG_KEYCONT zurÅckliefern!


!subnode SG_EDKEY

In vielen FÑllen ist es wÅnschenswert zu wissen, welches Zeichen in
ein Editfeld eingefÅgt werden soll, noch bevor es eingefÅgt wurde. So
waren in der Version 1.x z. B. Passworteingaben wegen dieser
fehlenden Funktion nicht mîglich.

Jedesmal, wenn der Benutzer eine Taste gedrÅckt hat, die in ein
Editfeld eingefÅgt werden soll, schickt SysGem an die Handlerfunktion
die Nachricht SG_EDKEY. Die Handlerfunktion kann nun entscheiden, ob
das Zeichen (oder ein anderes!) eingefÅgt werden soll, oder nicht.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt den Scancode der gedrÅckten Taste im NKCC-Format.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 kstate        enthÑlt den Status der Sondertasten.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 denied        enthÑlt den Scancode der gedrÅckten Taste im AES-
               Format (wie EventMulti ihn liefert).
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ABORT, SG_CALL, SG_TAKEKEY


!subnode SG_EDCHANGED

Manchmal ist es sinnvoll, zu wissen, was in einem Editfeld steht,
wenn der Benutzer dieses wechselt oder weitergeht. So kînnen z. B.
bei Eingabe des Namens gleich andere Editfelder vorbelegt werden (z.
B. Straûe, Wohnort o.Ñ.).

BetÑtigt der Benutzer eine Taste, die dazu fÅhrt, daû der Cursor von
einem Editfeld in ein anderes wechselt, so wird diese Nachricht
verschickt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Editfeldes, in welches der
Cursor als nÑchstes gesetzt werden soll.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 kstate        enthÑlt den Status der Sondertasten.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht - welches verlassen werden soll.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ABORT


!subnode SG_MENU

Ein Eintrag der FenstermenÅzeile wurde angewÑhlt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Eintrages, welcher angewÑhlt
wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 mItem         enthÑlt die Objektnummer des Eintrages, welcher
               angewÑhlt wurde.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_DRAGDROP

Der Benutzer hat ein Objekt auf ein Fenster des Programms gezogen.
Die Handlerfunktion dieses Fensters erhÑlt dann diese Nachricht, um
darauf reagieren zu kînnen.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 dd            Zeiger auf die DRAG_DROP Struktur, die alle weiteren
               Daten enthÑlt.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 dd            Zeiger auf die DRAG_DROP Struktur, die alle weiteren
               Daten enthÑlt.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_HELP

Der Benutzer hat die HELP-Taste gedrÅckt. Hat das Fenster oder der
Dialog einen als Help-Button angegebenen Button, so wurde dieser bei
Eintreffen dieser Nachricht schon selektiert.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_UNDO

Der Benutzer hat die UNDO-Taste gedrÅckt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_EXCEPTION

Eine Handlerfunktion hat einen fehlerhaften RÅckgabewert geliefert,
bzw. einen RÅckgabewert, der SysGem nicht bekannt ist. Die mîglichen
RÅckgabewerte sind bei "Nachrichten an SysGem" beschrieben.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 denied        Das untere Wort enthÑlt den fehlerhaften RÅckgabewert.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 denied        Das untere Wort enthÑlt den fehlerhaften RÅckgabewert.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_TERMDENIED

Wird noch nicht unterstÅtzt. Reserviert fÅr die zukÅnftige Modul-
schnittstelle.


!subnode SG_DRAWOWN

Wenn Sie ein Objekt mittels der Funktion LinkOwnRedraw angemeldet
haben, erhalten Sie diese Nachricht, wenn Sie es "zeichnen" sollen.

Mit Hilfe dieser Nachricht kînnen Sie z. B. das von Windows bekannte
grÅne HÑckchen auf den OK-Button pinseln...

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Objektes, mit dem oder in dem
Sie etwas zeichnen wollen.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich das zu
               zeichnende Objekt befindet.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 clip          enthÑlt die Koordinaten sowie Breite und Hîhe des
               Objektes. Das Clipping-Rechteck fÅr dieses Objekt ist
               bereits gesetzt, ebenso wind_update. Desweiteren wurde
               bereits die Maus versteckt, Sie brauchen Sie also
               nicht noch einmal zu verstecken.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, mit dem oder in
               dem Sie etwas zeichnen wollen.

 obj_id        enthÑlt die ID des Baumes, in dem sich das Objekt
               befindet.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich das
               Objekt befindet.

 clip          enthÑlt die Koordinaten sowie Breite und Hîhe des
               Objektes. Das Clipping-Rechteck fÅr dieses Objekt ist
               bereits gesetzt, ebenso wind_update. Desweiteren wurde
               bereits die Maus versteckt, Sie brauchen Sie also
               nicht noch einmal zu verstecken.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_SLIDER

Diese Nachricht wird verschickt, wenn der Benutzer eine Zeile
innerhalb einer Sliderbox angeklickt hat. Die Handlerfunktion kann
dann den Selektierbalken umstellen oder etwas anderes machen...

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Zeilennummer (beginnend bei 0) auf die der
Benutzer geklickt hat.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich das zu
               zeichnende Objekt befindet.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 box           enthÑlt die Objektnummer der Box, in der sich der
               Eintrag befindet, den der Benutzer angewÑhlt hat.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Zeilennummer (beginnend bei 0) auf die
               geklickt wurde. Ein Wert von -1 besagt, daû er zwar in
               die Sliderbox geklickt hat, sich an der Position
               jedoch kein Eintrag befindet.

 obj_id        enthÑlt die ID des Baumes, in dem sich die Sliderbox
               befindet.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich die
               Sliderbox befindet.

 denied        Das untere Wort enthÑlt die Objektnummer der Box, in
               der sich die EintrÑge befinden.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL, SG_PIPE

Siehe auch: SG_EMPTYSLDLINE, SG_SLIDER2, SG_RSLIDER, SG_RSLIDER2


!subnode SG_EMPTYSLDLINE

Diese Nachricht wird verschickt, wenn der Benutzer eine Zeile
innerhalb einer Sliderbox angeklickt hat, diese aber keinen Text
enthÑlt, bzw. nicht belegt ist. Dies ist z. B. der Fall, wenn nur
zwei Zeilen in der Sliderbox enthalten sind, der Benutzer aber z. B.
auf die vierte klickt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Zeilennummer (beginnend bei 0) auf die der
Benutzer geklickt hat.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich das zu
               zeichnende Objekt befindet.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 box           enthÑlt die Objektnummer der Box, in der sich der
               Eintrag befindet, den der Benutzer angewÑhlt hat.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Zeilennummer (beginnend bei 0) auf die
               geklickt wurde. Ein Wert von -1 besagt, daû er zwar in
               die Sliderbox geklickt hat, sich an der Position
               jedoch kein Eintrag befindet.

 obj_id        enthÑlt die ID des Baumes, in dem sich die Sliderbox
               befindet.

 tree          enthÑlt einen Zeiger auf den Baum, in dem sich die
               Sliderbox befindet.

 denied        Das untere Wort enthÑlt die Objektnummer der Box, in
               der sich die EintrÑge befinden.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL, SG_PIPE

Siehe auch: SG_SLIDER


!subnode SG_SLIDER2

Entspricht SG_SLIDER, nur mit dem Unterschied, daû der Benutzer den
Eintrag mit einem Doppelklick angewÑhlt hat.


!subnode SG_RSLIDER

Entspricht SG_SLIDER, nur mit dem Unterschied, daû der Benutzer den
Eintrag mit der rechten Maustaste angewÑhlt hat.


!subnode SG_RSLIDER2

Entspricht SG_SLIDER, nur mit dem Unterschied, daû der Benutzer den
Eintrag mit einem Doppelklick mit der rechten Maustaste angewÑhlt
hat.


!subnode SG_3DSTATE

Der Status der 3D-Darstellung hat sich geÑndert. Der jetzt aktive
Status kann mit SysGem3D abgefragt werden.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_CLIPBOARD

Diese Nachricht wird verschickt, wenn bekannt wird, daû sich der
Inhalt des Clipboards geÑndert hat.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_CHILDEXIT

Ein Programm, das via shel_write gestartet wurde, hat sich wieder
beendet.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 denied        Das obere Wort enthÑlt die AES-Id des Prozesses, das
               untere Wort den Returncode des Prozesses.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 denied        Das obere Wort enthÑlt die AES-Id des Prozesses, das
               untere Wort den Returncode des Prozesses.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_SELECT

In einem Baum wurde ein Selectable-Button angeklickt und hat seinen
Status auf "Selektiert/AngewÑhlt" geÑndert. Das Kreuzchen wird
gesetzt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Buttons, der angewÑhlt wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Buttons, der angewÑhlt
               wurde.

 obj_id        enthÑlt die ID des Baumes, in dem der Button liegt.

 tree          enthÑlt einen Zeiger auf den Baum, in dem der Button
               liegt.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_DESELECT

Wie SG_SELECT, jedoch wurde der Button deselektiert. Das Kreuzchen
wurde entfernt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Buttons, der angewÑhlt wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Buttons, der angewÑhlt
               wurde.

 obj_id        enthÑlt die ID des Baumes, in dem der Button liegt.

 tree          enthÑlt einen Zeiger auf den Baum, in dem der Button
               liegt.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_RADIO

Der Benutzer hat einen Radio-Button angewÑhlt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Buttons, der angewÑhlt wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Buttons, der angewÑhlt
               wurde.

 obj_id        enthÑlt die ID des Baumes, in dem der Button liegt.

 tree          enthÑlt einen Zeiger auf den Baum, in dem der Button
               liegt.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_NEXTSTART

Das Programm hat eine AV_START-Nachricht erhalten. In 'denied' wird
jeweils ein Zeiger auf die neue Kommandozeile Åbergeben.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 denied        enthÑlt einen Zeiger auf die neue Kommandozeile.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 denied        enthÑlt einen Zeiger auf die neue Kommandozeile.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_NEWDIAL

Innerhalb eines MultipleDialog wurde ein neuer Reiter angewÑhlt.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Reiters, welcher angewÑhlt
wurde. Der neue Baum wird mittels RÅckgabe von SG_TAKEDIAL angegeben.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_TAKEDIAL

Im Falle von SG_CONT bleibt der dargestellte Dialog erhalten.

Siehe auch: SG_EDITABLE


!subnode SG_NEWFONT

Der Benutzer oder das Programm hat einen neuen System-Font
eingestellt. Siehe dazu auch unter SetSysFont.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die neue Font-Id.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 box           enthÑlt die Grîûe des Fonts in Punkten.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die neue Font-Id.

 state         enthÑlt die Grîûe des Fonts in Punkten.
!end_verbatim
Der einzig legale RÅckgabewert ist SG_CONT.


!subnode SG_OPENICONIFIED

Diese Nachricht wird noch vor SG_START verschickt. Liefert die
Handlerfunktion SG_ICONIFY zurÅck, so wird das Fenster im
iconifizierten Zustand geîffnet. Bei allen anderen RÅckgabewerten
wird das Fenster wie Åblich geîffnet.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT, SG_ICONIFY


!subnode SG_LCIRCLE

Eine Circle-Box wurde mit der linken Maustaste angeklickt. Dabei
wurde genau auf das Objekt mit dem "Kreis" geklickt, so daû ohne
weiteres die Funktion Cycle oder CycleBack aufgerufen werden kann.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer der Circle-Box, welche angeklickt
wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, welches der
               Benutzer angeklickt hat und was zu dieser Nachricht
               fÅhrte.

 obj_id        enthÑlt die ID des Baumes, die Sie entweder bei
               LinkTree oder bei XTREE angegeben haben.

 tree          ist ein Zeiger auf den Objektbaum, in dem das Objekt
               liegt, welches der Benutzer angeklickt hat.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_RCIRCLE

Eine Circle-Box wurde mit der rechten Maustaste angeklickt. Dabei
wurde genau auf das Objekt mit dem "Kreis" geklickt, so daû ohne
weiteres die Funktion Cycle oder CycleBack aufgerufen werden kann.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer der Circle-Box, welche angeklickt
wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, welches der
               Benutzer angeklickt hat und was zu dieser Nachricht
               fÅhrte.

 obj_id        enthÑlt die ID des Baumes, die Sie entweder bei
               LinkTree oder bei XTREE angegeben haben.

 tree          ist ein Zeiger auf den Objektbaum, in dem das Objekt
               liegt, welches der Benutzer angeklickt hat.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_TOUCH

Der Benutzer hat auf ein Objekt geklickt, welches keinen EXIT-Status
besitzt, bzw. welches keine andere Nachricht zur Folge hat.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Objektes, welche angeklickt
wurde.

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 kstate        enthÑlt den Status der Sondertasten.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, welches der
               Benutzer angeklickt hat und was zu dieser Nachricht
               fÅhrte.

 state         enthÑlt den Status der Sondertasten.

 obj_id        enthÑlt die ID des Baumes, die Sie entweder bei
               LinkTree oder bei XTREE angegeben haben.

 tree          ist ein Zeiger auf den Objektbaum, in dem das Objekt
               liegt, welches der Benutzer angeklickt hat.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED

!subnode SG_LASTEDIT

Diese Nachricht tritt auf, wenn der Benutzer durch die Editfelder
wandert und dabei das letzte Editfeld verlassen will. Ignoriert die
Handlerfunktion diese Nachricht, wo wird der Cursor wieder in das
erste Editfeld des Dialogs gesetzt.

Eine sinnvolle Reaktion der Handlerfunktion wÑre z. B. das Lîschen
der Editfelder mit ClearEditFields, das Speichern eines Datensatzes
o.Ñ.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_EDITABLE

Diese Nachricht tritt nur im Zusammenhang mit SG_NEWDIAL auf. Dabei
ist es mîglich, das Editfeld zu bestimmen, in das der Cursor nach dem
Wechsel des Dialogs gesetzt werden soll. Dazu wird einfach bei
SG_CONT im oberen Byte die Nummer des Editfeldes Åbergeben.

Beispiel:

return (( 7 << 8 | SG_CONT );


Haben Sie keinen besondern Wunsch, was die platzierung des Cursors
angeht, ignorieren Sie diese Nachricht einfach; SysGem setzt dann den
Cursor in das erste verfÅgbare Editfeld.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CLOSE, SG_REDRAW, SG_REDRAWALL, SG_TERM, SG_CONT, SG_CALL,
SG_PIPE, SG_SELECTED


!subnode SG_BEGINHELP

Der Benutzer hat die Maus auf einem Objekt fÅr min. 2 Sekunden
"geparkt". SysGem versendet dann diese Nachricht, auf die Sie dann
mit einem Aufruf von BeginHelp reagieren kînnen. Sie kînnen diese
Nachricht aber auch ignorieren.

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

'button' enthÑlt die Objektnummer des Objektes, Åber welchem die Maus
"parkt".

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 item          enthÑlt die Objektnummer des Objektes, Åber welchem
               der Benutzer die Maus geparkt hat.

 obj_id        enthÑlt die ID des Baumes, die Sie entweder bei
               LinkTree oder bei XTREE angegeben haben.

 tree          ist ein Zeiger auf den Objektbaum, in dem das Objekt
               liegt, welches der Benutzer angeklickt hat.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT


!subnode SG_ENDHELP

Diese Nachricht ist das GegenstÅck zu SG_BEGINHELP und besagt nur,
daû, wenn Sie mit BeginHelp einen Hilfetext geîffnet haben, diesen
nun mit einem Aufruf von EndHelp entfernen (!B)mÅssen!(!b)

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT

!subnode SG_SLIDERMOVE

Diese Nachricht ist das GegenstÅck zu SG_BEGINHELP und besagt nur,
daû, wenn Sie mit BeginHelp einen Hilfetext geîffnet haben, diesen
nun mit einem Aufruf von EndHelp entfernen (!B)mÅssen!(!b)

!begin_verbatim
Handlerfunktion vom Typ DPROC: DIALOG_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensterdialogs

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen angegeben
               haben.

 tree          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.
 
 edit_field    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

Handlerfunktion vom Typ APROC: WINDOW_INFO ist wie folgt belegt:
----------------------------------------------------------------------

 id            enthÑlt die ID des Fensters.

 handle        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 pos_x, pos_y  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 doc_x, doc_y  enthalten die Grîûe des Document-Bereiches in Pixeln.

 user          enthÑlt den User-Zeiger, den Sie beim ôffnen des Fen-
               sters angegeben haben.

 work_area     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 draw_area     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.
!end_verbatim
Die Handlerfunktion kann folgende Werte zurÅckliefern:

SG_CONT



!node Nachrichten an SysGem

Wenn SysGem Nachrichten an die Handlerfunktionen zustellt, ist es oft
nîtig, auf eine ganz bestimmte "Antwort" zu warten, damit SysGem die
richtige Entscheidung treffen kann, wie es weiterarbeiten bzw. wie es
sich weiter verhalten soll. Das ist z. B. bei einer Aufforderung zum
Schlieûen des Fensters so: Die Handlerfunktion kann es zulassen, aber
auch ablehnen.

Wie sich SysGem auf verschiedene Nachrichten verhÑlt, wird mit den
folgenden Werten festgelegt, die eine Handlerfunktion zurÅckliefern
kann und darf:


!subnode SG_CLOSE

Liefert eine Handlerfunktion SG_CLOSE zurÅck, so schlieût SysGem das
Fenster. Dazu wird die Handlerfunktion noch einmal mit der Nachricht
SG_QUIT aufgerufen, damit das Programm alle "Reste" entfernen kann.


!subnode SG_REDRAW

Liefert eine Handlerfunktion SG_REDRAW zurÅck, so zeichnet SysGem das
komplette Fenster neu.


!subnode SG_REDRAWALL

Liefert eine Handlerfunktion SG_REDRAWALL zurÅck, so veranlaût SysGem
ein Neuzeichnen (!B)aller(!b) Fenster des Programms.


!subnode SG_TERM

Liefert eine Handlerfunktion SG_TERM zurÅck, so ist dies dasselbe,
als wenn Sie die Funktion TerminateSysGem aufgerufen hÑtten. Die Funk-
tion HandleSysGem wird verlassen; wodurch sich Ihr Programm
terminieren soll.


!subnode SG_CONT

Teilt SysGem mit, daû es einfach weitermachen soll, das heiût, keine
Spezialbehandlung auf die erfolgte Nachricht nîtig ist.

SG_CONT ist in den meisten FÑllen der einzig legale RÅckgabewert der
Handlerfunktion!


!subnode SG_ABORT

Teilt SysGem mit, daû die Anfrage, die an die Handlerfunktion
gestellt wurde, abgelehnt wurde. Die weitere Bearbeitung wird also
abgebrochen.


!subnode SG_KEYUSED

Der Tastendruck, den SysGem der Handlerfunktion zugestellt hat, wurde
von der Handlerfunktion verarbeitet und soll nicht weitergeleitet wer-
den.


!subnode SG_KEYCONT

Teilt SysGem mit, daû die Handlerfunktion mit dem Tastendruck nichts
angangen konnte. Er soll weiter verteilt werden.


!subnode SG_CALL

SysGem bietet die Mîglichkeit, daû sich Handlerfunktionen mit einer
beliebigen Nachricht noch einmal selbst aufrufen kînnen. Dazu wird
der RÅckgabewert mit SG_CALL verodert.

Beispiel: Will sich eine Handlerfunktion nochmal mit SG_END aufrufen
lassen, so liefert sie als RÅckgabewert zurÅck:

return (( SG_END << 8 ) | SG_CALL );

SÑmtliche Werte, die in DIALOG_INFO oder WINDOW_INFO standen (je nach
Handlerfunktion) bleiben erhalten. Es ist sogar erlaubt, diese fÅr
den nÑchsten Aufruf zu manipulieren, also neue Werte zu Åbergeben.

Eine Handlerfunktion kann sich beliebig oft via SG_CALL aufrufen
lassen.

Aber vorsicht: SysGem erkennt eine Deadlock-Situation nicht, da sonst
eine beliebige Aufruffolge nicht mîglich wÑre. Sie mÅssen also selbst
darauf achten, daû Sie sich nicht ewig und drei Tage aufrufen!


!subnode SG_PIPE

SG_PIPE ist Ñhnlich wie SG_CALL, nur wird die Nachricht, die
verschickt werden soll (das ist die, mit der die Handlerfunktion
gerade aufgerufen worden ist), nicht der eigenen Handlerfunktion (das
geht aber auch), sondern einer anderen zugestellt.

Dazu belegt die Handlerfunktion den Wert 'id' der öbergabestruktur
mit der ID des Fensters vor, der die gleiche Nachricht zugestellt wer-
den soll.

Mit SG_PIPE ist es mîglich, eine Nachricht, die an ein Fenster
gerichtet ist, einem anderen Fenster gleicher Art zustellen zu
lassen.


!subnode SG_SELECTED

Wenn der Benutzer einen Button anklickt, oder mittels eines Shortcuts
einen Button anwÑhlt, so selektiert ihn SysGem. Nach Zustellung der
entsprechenden Nachricht deselektiert SysGem ihn automatisch wieder.

Ab und zu kann es aber gewÅnscht sein, daû der Button, der angewÑhlt
wurde, selektiert bleibt. Dies kînnen Sie mit RÅckgabe von
SG_SELECTED erreichen.

Soll der Button wieder zurÅckgesetzt werden, so kînnen Sie dazu die
Funktionen DelState oder RedrawObj benutzen.


!subnode SG_TAKEKEY

Wenn SysGem der Handlerfunktion via SG_EDKEY eine Taste zustellt, Sie
statt dieser aber eine andere Taste in das Editfeld eingefÅgt haben
wollen, so kînnen Sie SG_TAKEKEY zurÅckliefern.

Der ASCII-Code des gewÅnschten Zeichens wird dabei im oberen Byte
zurÅckgeliefert.

Beispiel: Sie wollen eine Passworteingabe realisieren. Der Benutzer
tippt ein 'A', im Editfeld soll jedoch ein '*' erscheinen. Die
Handlerfunktion muû dann folgendes zurÅckliefern:
!begin_verbatim
INT  i;
...
i = (INT) '*';
return (( i << 8 ) | SG_TAKEKEY );
!end_verbatim

!subnode SG_TAKEDIAL

Bei einem 'MultipleDialog' soll der Baum gewechselt werden. Dazu
schreiben Sie in 'tree' aus der DIALOG_INFO Struktur die Adresse des
Baumes, der nach RÅckkehr aus der Handlerfunktion dargestellt werden
soll.

Vor der RÅckkehr muû dieser "neue" Baum jedoch schon fertig
initialisiert sein!

Beispiel fÅr eine Handlerfunktion mit vier Reitern:

!begin_verbatim
INT BehandleReiter ( INT msg, INT button, DIALOG_INFO *inf )

{
  switch ( msg )
    {
      case SG_START    : /* -------------------------------------
                          * Voreinstellungen
                          * ------------------------------------- */
                         break;

      case SG_END      : /* -------------------------------------
                          * Fenster schlieûen
                          * ------------------------------------- */
                         return ( SG_CLOSE );

      case SG_HELP     : /* -------------------------------------
                          * User hat HELP gedrÅckt oder auf den
                          * HILFE-Button geklickt
                          * ------------------------------------- */
                         CallOnlineHelp ( ... );
                         break;

      case SG_NEWDIAL  : /* -------------------------------------
                          * Je nachdem, welcher Reiter angewÑhlt
                          * wurde, wird hier der richtige Dialog
                          * dazu eingetragen
                          * ------------------------------------- */
                         switch ( button )
                           {
                             case REITER1 : inf->tree = rsc_reiter1;
                                            break;
                             case REITER2 : inf->tree = rsc_reiter2;
                                            break;
                             case REITER3 : inf->tree = rsc_reiter3;
                                            break;
                             case REITER4 : inf->tree = rsc_reiter4;
                                            break;
                             default      : return ( SG_CONT );
                           }
                         return ( SG_TAKEDIAL );
      default          : break;
    }
  return ( SG_CONT );
}
!end_verbatim

!subnode SG_ICONIFY

Diesen Wert kînnen Sie nur bei Auftreten der Nachricht
SG_OPENICONIFIED zurÅckliefern und besagt, daû Sie das Fenster im
iconifizierten Zustand îffnen wollen.


!node Das interne Hilfe-System

SysGem unterstÅtzt ein Hilfesystem, welches Sie vielleicht vom Mac
oder unter Windows (Word, Excel) kennen: "Parkt" man die Maus fÅr 2
Sekunden Åber einem Objekt, erscheint zu diesem Objekt eine kurze
Hilfe. Auch dieses ist mit den folgenden Routinen einfach zu
realisieren:


!subnode BeginHelp

VOID BeginHelp ( OBJECT *tree, INT obj, BYTE *text );


ErhÑlt die Handlerfunktion eines Fensters von SysGem die Nachricht
SG_BEGINHELP, so kann mit dieser Funktion ein kleiner Hilfetext darge-
stellt werden, der solange sichtbar bleibt, bis die Maus wieder
verschoben wird.

Damit Sie es sich mal vorstellen kînnen, hier ein Bildchen:


!image IMG400.IMG Ein Ausschnitt aus dem neuen Demo...

Die Parameter:
!begin_xlist [xxxxxxx]
 !item [tree]     ist der Baum, in dem das Objekt liegt, zu dem der Hilfetext
          gezeigt werden soll. SysGem platziert den Text dann etwas
          unterhalb dieses Objektes, damit das Objekt auch richtig zu
          sehen ist.

          (!B)Achtung:(!b) Wollen Sie den Hilfetext an der Mausposition
          erscheinen lassen, Åbergeben Sie hier einfach den Wert
          NULL.

 !item [obj]      ist die Nummer des Objektes, zu dem die Hilfe erscheinen
          soll. SysGem platziert den Text dann etwas unterhalb dieses
          Objektes, damit das Objekt auch richtig zu sehen ist.

          (!B)Achtung:(!b) Wollen Sie den Hilfetext an der Mausposition
          erscheinen lassen, Åbergeben Sie hier einfach den Wert 0.

 !item [text]     ist ein Zeiger auf den Hilfe-Text. Dieser kann beliebig
          lang sein und Åber beliebig viele Zeilen verfÅgen. Aller-
          dings ist er nicht scrollbar und sollte schon die Grîûe des
          Bildschirms nicht Åberschreiten...

          Einzelne Zeilen werden durch einen Balken "|" getrennt,
          eine Leerzeile erreichen Sie, indem Sie ein Leerzeichen
          zwischen die Balken setzen.

          Beispiel:

          BeginHelp ( NULL, 0, " Dieses ist ein | | Text " );

          wÅrde einen dreizeiligen Hilfetext an der Mausposition
          ausgeben.
!end_xlist
Das Fenster wird immer in der Grîûe geîffnet, so daû der Text genau
hineinpasst. Die Funktion liefert keinen Parameter.

                         (!B)Bitte beachten Sie:(!b)

Wollen Sie diese Funktion aufrufen, (!B)ohne(!b) den Erhalt von SG_BEGINHELP,
so mÅssen Sie vorher die Funktion DisableHelp aufrufen!

In diesem Falle mÅssen Sie sich auch um das Entfernen des Textes
mittels EndHelp selbst kÅmmern!


!subnode EndHelp

VOID EndHelp ( VOID );


Mit Aufruf dieser Funktion wird der mittels BeginHelp dargestellte
Text wieder vom Bildschirm genommen. Diese Funktion (!B)muû(!b) aufgerufen
werden, wenn Sie die Nachricht SG_ENDHELP erhalten und mit BeginHelp
einen Hilfetext geîffnet haben!


!subnode EnableHelp

VOID EnableHelp ( VOID );


Diese Funktion hebt die Sperre von DisableHelp wieder auf, und
erlaubt SysGem, wieder die Nachricht SG_BEGINHELP zu versenden.


!subnode DisableHelp

VOID DisableHelp ( VOID );


Diese Funktion schaltet im Prinzip die öberwachung von SysGem ab, ob
der Mauscursor 2 Sekunden stillsteht und verhindert gleichzeitig das
versenden von SG_BEGINHELP.

Siehe auch: SG_BEGINHELP, BeginHelp


!subnode SetHelpTime

VOID SetHelpTime ( INT count );


Mit dieser Funktion kînnen Sie die Zeitspanne einstellen, die
vergehen soll, bis SysGem eine SG_BEGINHELP Nachricht schickt, wenn
die Maus Åber einem Objekt geparkt wird.

Die Zeitspanne wird dabei in Einheiten zu 200ms angegeben.


!subnode SetHelpColor

VOID SetHelpColor ( INT color );


Mit dieser Funktion stellen Sie die Hintergrundfarbe des
Hilfefensters ein. StandardmÑûig ist die Farbe in Monochrom auf Weiû,
unter Farbe auf Gelb eingestellt.


!node Das Config

Da es meist immer sehr aufwendig ist, um Parameter des Programms zu
speichern (Einstellungen, SchlÅssel, oder sonstwas...) bietet SysGem
auch fÅr diesen Fall eine Lîsung an: NÑmlich das Config von SysGem.
Es bietet Routinen fÅr das komfortable Laden/Speichern und verwalten
von Daten.

Die Verwaltung geschieht dabei Åber "SchlÅsselwîrter": Den Dateinamen
einer Resource-Datei kînnen Sie z. B. mit "Resource-File" ansprechen,
wobei die Daten direkt im Speicher verÑndert und/oder abgefragt wer-
den kînnen.

Hier ein öberblick Åber die Routinen:


!subnode SetConfig

BOOL SetConfig ( BYTE *keyword, VOID *value, LONG len );


SetConfig fÅgt ein Element in die Liste ein.
!begin_xlist [xxxxxxxxxx]
 !item [keyword]     ist ein Zeiger auf das SchlÅsselwort, unter dem der ent-
             sprechende Wert angesprochen werden soll. Dabei wird
             zwischen Groû- und kleinschreibung unterschieden; die
             LÑnge ist dabei nicht von Belag. Theoretisch kann ein
             SchlÅsselwort 4 GB in Anspruch nehmen...

 !item [value]       ist ein Zeiger auf die Daten, die unter dem "keyword"
             abgelegt werden sollen.

             (!B)Achtung:(!b) Die Daten werden dabei in SysGem kopiert, der
             Originalzeiger ist also nicht weiter von Belang.

 !item [len]         gibt die LÑnge der Daten in Bytes an, die Åbernommen wer-
             den sollen. Beachten Sie bei der Speicherung von
             Strings, daû Sie das Nullbyte nicht auûer acht lassen!
!end_xlist
Die Funktion liefert TRUE, wenn der entsprechende Wert kopiert wurde.

                              (!B)Achtung:(!b)

Wenn das keyword schon existiert, wird der alte Wert verworfen und
der neue Wert und die neue LÑnge Åbernommen.


!subnode GetConfigPtr

BOOL GetConfigPtr ( BYTE *keyword, VOID *value, LONG *len );


Diese Funktion bietet die Mîglichkeit, Informationen Åber ein keyword
und dessen Wert zu erhalten.
!begin_xlist [xxxxxxxxxx]
 !item [keyword]     ist ein Zeiger auf das SchlÅsselwort, unter dem der ent-
             sprechende Wert angesprochen werden soll. Dabei wird
             zwischen Groû- und kleinschreibung unterschieden.

 !item [value]       liefert einen Zeiger auf den Speicherbereich, in dem die
             Daten gespeichert sind.

 !item [len]         gibt die LÑnge der Daten in Bytes an, die Åbernommen
             worden sind.
!end_xlist
Die Funktion liefert TRUE, wenn das keyword existiert und die Infor-
mationen geliefert wurden, FALSE sonst.


!subnode GetConfig

BOOL GetConfig ( BYTE *keyword, VOID *value );


Diese Funktion sucht das keyword "keyword" und schreibt in den
Buffer, dessen Zeiger in "value" Åbergeben wurde, "len" Bytes (die
bei SetConfig angegeben wurden). Sie sollten also auf einen
ausreichend groûen Buffer achten.

FÅr "value" kann auch NULL Åbergeben werden; so kann auf Existenz
eines keywords geprÅft werden.

Die Funktion liefert TRUE, wenn das Keyword gefunden wurde, FALSE
sonst.


!subnode DelConfig

BOOL DelConfig ( BYTE *keyword );


Diese Funktion sucht das keyword "keyword" und entfernt es aus der
Verwaltung.

Die Funktion liefert TRUE, wenn das keyword gelîscht wurde, FALSE
sonst.


!subnode CountKeywords

UINT CountKeywords ( VOID );


Diese Funktion liefert die Anzahl der Parameter, die bereits im
Config gespeichert sind.


!subnode SaveConfig

LONG SaveConfig ( BYTE *file_name );


Diese Funktion speichert alle keywords und deren komplette Daten, die
mit SetConfig Åbernommen wurden, in der Datei mit dem Namen
"file_name".

Die Funktion liefert die Anzahl der keywords, die geschrieben wurden,
oder 0L im Fehlerfall.

Siehe auch: LoadConfig unter "Beachten Sie"


!subnode LoadConfig

LONG LoadConfig ( BYTE *file_name );


Diese Funktion lÑdt eine Config-Datei mit dem Namen "file_name" und
ersetzt dabei die bereits im Speicher befindlichen keywords.

Die Funktion liefert die Anzahl der keywords, die geladen wurden.
Im Fehlerfall:
!begin_xlist [xxxxxxx] !short
 !item [-4711] 	PrÅfsummen Fehler oder Fehler beim lesen eines Keywords oder
        desen Wert
 !item [-39]     Kein Speicher mehr frei
 !item [-??]     Felher beim îffnen der Datei.
 !item [0]       Fehler beim einlesen, Header eines Keyword ist defekt.
!end_xlist
!begin_center
                         (!B)Bitte beachten Sie:(!b)
!end_center
Die Datei wird mit einem eigenen Header und die einzelnen EintrÑge
mit PrÅfsummen versehen gespeichert, um die Mîglichkeit von
fehlerhaften Daten auszuschlieûen. Versuche, von auûen die Daten zu
Ñndern, sind also schon beim Versuch zum scheitern verurteilt.

Liefert die Funktion 0L, so sind (!B)keine(!b) keywords verfÅgbar!

!subnode DebugTheConfig

VOID DebugTheConfig ( INT x, INT y, INT w_char, INT h_char);

Damit man einen öberblich Åber die in der Config gespeicherten Variablen
und deren Inhalt bekommt kann man diese Funktion aufrufen. Es erscheint
dann ein entsprechendes Fenster.
!begin_xlist [xxxxxxxxxxxxxx]
!item [x, y]            Geben die Koordinaten die das Fenster beim ôffnen haben
                soll.

!item [w_char, h_char]	Die Breite und Hîhe, in Zeichen, des Fensters.
!end_xlist       
Der Fensterinhalt wird automatisch aktuallisiert, wenn sich der Inhalt
einer Variable Ñndert. Die angezeigten Daten sind die die sich im Speicher
befinden.

Das Fenster hat die ID 'DSpy'.

!subnode DebugConfigInt

VOID DebugConfigInt(BOOL int);

Da in der Regel Variablen mit zwei Byte LÑnge einen Integerwert darstellen,
kann man mit dieser Funktion der Debugfunktion mitteilen ob dies tatsÑchlich
der Fall ist.
!begin_xlist [xxxxxxx]
!item [int]		FALSE der Wert wird als String dargestellt, sonst als Integerwert.
!end_xlist
Die Funktion muû nach jedem Aufruf von @{"DebugTheConfig" LINK "DebugTheConfig" 1}
erfolgen, wenn man Werte als Integer dargestellt haben will.


!node Die Modulschnittstelle

Um Programme oder grîûere Projekte modular gestalten zu kînnen,
kînnen ganze Funktionen oder Programmteile in Module ausgelagert wer-
den. Diese Module kînnen jederzeit zur Laufzeit nachgeladen und
ausgefÅhrt werden, wobei die Module natÅrlich einerseits den vollen
Zugriff auf alle Funktionen von SysGem haben und sich andererseits
mit anderen Modulen "unterhalten" kînnen.

Dabei ist das Erstellen und die Verwaltung von Modulen sehr einfach
und schnell: Wie Sie es von SysGem halt gewohnt sind... :-)))

Die folgenden Routinen sind fÅr die Module zustÑndig:


!subnode Der Aufbau eines Moduls

Ein Modul ist im Grunde ein ganz normales Programm, nur mit dem Unter-
schied, daû es Åber einen eigenen Startup-Code verfÅgt, den Sie unter
SGMSTART.S und SGMSTART.O im Archiv finden.
!begin_verbatim
Er sieht folgendermaûen aus:

*
*
* Startmodul fÅr SysGem 2.02-Module
*
*
        .IMPORT ModuleMain

        jmp     ModuleMain

        .END
!end_verbatim

Ein "normales" Programm verfÅgt Åber eine Funktion mit dem Namen
"main"; ein Modul Åber den Namen "ModuleMain", welches von SysGem
angesprungen wird.

Die Hauptfunktion "ModuleMain" muû wie folgt deklariert sein:


LONG ModuleMain ( INT msg, INT user, VOID *p )


Ein Modul wird dabei Åber Nachrichten aktiviert. Folgende Nachrichten
muû ein Modul verarbeiten:
!begin_xlist [xxxxxxxxxxx]
 !item [SGM_IDENTIFY]     Ein Modul muû sich nach dem Laden identifizieren.
                  Dazu wird im Parameter "p" in Zeiger auf folgende
                  Struktur geliefert:

                  typedef struct (!nl)
                    { (!nl)
                      BYTE  *name; (!nl)
                      BYTE  *author; (!nl)
                    } IDENTIFY; (!nl)

                  Das Modul muû dann die beiden Zeiger der Struktur
                  mit einem Zeiger auf den Namen des Moduls und auf
                  eine Copyrightmeldung liefern.

 !item [SGM_INIT]         Das Modul kann sich initialisieren - darf aber
                  nicht starten! Dabei ist der Wert 'user'
                  undefiniert; p liefert einen Zeiger auf die
                  Struktur FUNCTIONS, die im Modul unter der Variable
                  'fkt' gespeichert werden muû, da die defines diesen
                  Variablennamen benutzen.

 !item [SGM_START]        Das Modul soll starten, bzw., mit seiner Arbeit
                  beginnen. Dabei ist der Wert 'user' undefiniert; p
                  liefert einen Zeiger auf irgendwas, bzw. den Wert,
                  den Sie bei StartSysGemModul Åbergeben haben.

 !item [SGM_QUIT]         Das Modul (!B)muû(!b) terminieren! Dabei muû das Modul:

                  (!B)alle(!b) Fenster, die es geîffnet hat, schlieûen.

                  (!B)allen(!b) Speicher, der mit Allocate aus der Struktur
                  FUNCTIONS angefordert wurde, wieder mit Dispose
                  freigeben.

                  (!B)alle(!b) Dialoge, die mit NewDialog angemeldet wurden,
                  mit DelDialog wieder freigeben.

                  Das Modul wird nach dem Aufruf mit dieser Nachricht
                  komplett aus dem Speicher entfernt und der belegte
                  Speicher wieder an SysGem zurÅckgegeben.

 !item [SGM_USER]         Diese Nachricht ist fÅr die Entwickler von Modulen
                  und fÅr die Module selbst interessant und
                  reserviert. Der Parameter 'user' und 'p' kînnen
                  dabei beliebig benutzt werden und das Modul kann
                  einen beliebigen Wert zurÅckliefern.

                  Diese Nachricht wird durch einen Aufruf von
                  AskModule verschickt.
!end_xlist
Das GrundgerÅst fÅr ein Modul sieht also etwa so aus:

!begin_verbatim
#include        <sys_mod2.h>

[...]

FUNCTIONS       *fkt;

[...]

LONG ModuleMain ( INT msg, INT user, VOID *p )

{
  IDENTIFY      *ident;

  switch ( msg )
    {
      case SGM_IDENTIFY : ident = (IDENTIFY *) p;
                          ident->name   = "Testmodul fÅr SysGem";
                          ident->author = "V1.00 / @{"Andreas Pietsch" LINK "Autor" 3}";
                          break;
      case SGM_INIT     : fkt = (FUNCTIONS *) p;
                          break;
      case SGM_START    : OpenWindow ( ... );
                          Allocate ( ... );
                          NewDialog ( ... );
                          break;
      case SGM_QUIT     : CloseWindow ( ... );
                          Dispose ( ... );
                          DelDialog ( ... );
                          break;
      case SGM_USER     : switch ( user )
                            {
                              ...
                            }
                          break;
    }
  return ( 0L );
}
!end_verbatim

Alle SysGem-Funktionen und die am hÑufigsten benutzten C-Funktionen
sind dabei in der Struktur FUNCTIONS enthalten, die in der Datei
"sys_mod2.h" definiert ist. Ein Includen von "sys_gem2.h" ist nicht
mehr notwendig, da erstere include-Datei alle nîtigen Anpassungen
Åbernimmt.


!subnode LoadSysGemModul

BOOL LoadSysGemModul ( BYTE *name );


SysGem verwaltet alle Module anhand ihres Namens. Dabei sind nur die
ersten 8 Zeichen relevant; SysGem fÅgt die Extension "SGM" (!B)selbst!-stÑndig(!b)
hinzu.

LoadSysGemModul lÑdt das unter "name" angegebene Modul, welches sich
im dem Pfad befindet, der vorher mit SetModulePath festgelegt wurde.

Die Funktion liefert TRUE, wenn das Modul geladen wurde oder wenn es
sich schon im Speicher befindet, FALSE sonst.


!subnode StartSysGemModul

VOID StartSysGemModul ( BYTE *name, VOID *p );


Diese Funktion startet ein Modul mit dem Namen "name". Dabei ist
"name" der Name, den Sie auch bei LoadSysGemModul angegeben haben.

Als Parameter kann dem Modul ein Zeiger "p" auf irgendwas Åbermittelt
werden, z. B. ein Zeiger auf ein Parameterarray oder sonstwas...

Das angesprochene Modul erhÑlt dabei die (!link [SGM_START] [Der Aufbau eines Moduls]) Nachricht.


!subnode ModulAvail

BOOL ModulAvail ( BYTE *name );


Diese Funktion liefert TRUE, wenn das Modul mit dem Namen "name" sich
im Speicher befindet, FALSE sonst. Dabei ist "name" der Name, den Sie
auch bei LoadSysGemModul angegeben haben.


!subnode AskModule

LONG AskModule ( BYTE *name, INT user, VOID *p );


Diese Funktion schickt die Nachricht "user" und den Zeiger "p" an das
Modul mit dem Namen "name". Der RÅckgabewert entspricht dem
RÅckgabewert des Moduls.


!subnode SetModulePath

VOID SetModulePath ( BYTE *path );


Diese Funktion setzt den Pfad, in dem SysGem bei LoadSysGemModul das
Modul sucht.


!subnode GetModuleInfo

BOOL GetModuleInfo ( INT nr, BYTE *name, BYTE *mname, BYTE *mauthor );


Diese Funktion schlÑgt zwei Fliegen mit einer Klappe: Einerseits kann
Sie zu einem einzigen Modul die Informationen (Name, Autor/Copyright)
ermitteln, andererseits kann aber auch die gesamte Liste aller Module
Ñhnlich Fsfirst/Fsnext durchlaufen werden.
!begin_xlist [xxxxxxxxxxx]
 !item [nr]          muû den Wert -1 haben, wenn Sie fÅr ein einziges Modul
             die Informationen ermitteln mîchten. In diesem Fall wird
             nur das Modul mit dem Namen "name" beachtet.

             Wollen Sie die Liste durchlaufen, so Åbergeben Sie als
             erstes den Wert 0, und zÑhlen dann solange weiter hoch
             (+1), bis die Funktion FALSE liefert.

 !item [name]        ist ein Zeiger auf den Namen des Moduls, fÅr das Sie die
             Informationen ermitteln wollen und "nr" -1 ist.

             öbergeben Sie hier einen gÅltigen Zeiger auf einen min.
             20 Byte groûen Buffer und durchlaufen die Liste, liefert
             die Funktion auch den Namen, unter dem das Modul geladen
             wurde.

 !item [mname]       Åbergeben Sie hier einen Zeiger auf einen min. 41 Byte
             gro0en Buffer, liefert die Funktion hier den
             Klartextnamen des Moduls. Die Angabe von NULL ist aber
             ebenfalls erlaubt.

 !item [mauthor]     Åbergeben Sie hier einen Zeiger auf einen min. 41 Byte
             gro0en Buffer, liefert die Funktion hier den Ver-
             sionsstring oder das Copyright des Moduls. Die Angabe
             von NULL ist aber ebenfalls erlaubt.
!end_xlist
Die Funktion liefert TRUE, wenn die Informationen geliefert wurden,
FALSE sonst.


!subnode TermSysGemModul

VOID TermSysGemModul ( BYTE *name );


Diese Funktion schickt die Nachricht (!link [SGM_QUIT] [Der Aufbau eines Moduls]) an das Modul. Nach
Aufruf dieser Funktion ist das Modul aus dem Speicher verschwunden.

(!B)Achtung:(!b) Diese Funktion darf NIEMALS von einem Modul selbst aufge-
rufen werden, weshalb der Funktionszeiger auch nicht in FUNCTIONS zu
finden ist.

!subnode DebugTheModule

VOID DebugTheModule ( INT x, INT y );

ôffnet ein Logfenster. In diesem Fenster werden alle Nachrichrichten, die
an ein Modul gesendet werden, mit den Parametern ausgegeben.
!begin_xlist
!item [x, y]	Geben die Koordinaten die das Fenster beim ôffnen haben soll.
!end_xlist

Das Fenster hat die ID 'MSpy'.

!node GEMScript

SysGem unterstÅtz auch das GEMScript Protokoll, welches eine definierte
Mîglichkeit darstellt Programme fernzusteuern.

!subnode RegisterGemScript

VOID	RegisterGemScript ( GS_PROC p );

!begin_verbatim
typedef INT (*GS_PROC)( INT cmd, BYTE *arg, BYTE *buffer,
                        INT appl_id, INT id );
!end_verbatim

Um dies nutzen zu kînnen muû man mit Hilfe von RegisterGemScript eine
Funktion eintragen. Diese Funktion wird beim auftreten einer GEMScript-
Message mit folgenden Parametern aufgerufen.
!begin_xlist [xxxxxxxxxxx]
!item [cmd]       GEMScript Komanndo z.Z. immer GS_COMMAND.

!item [arg]				Zeiger auf die Kommandozeile.

!item [buffer]		Zeiger auf einen Buffer in dem man RÅckgabewerte ablegen kann.
					(Grîûe 4096 Bytes)

!item [appl_id]		Applikations ID aus der GEMScript Message (msg[3]).

!item [id]        ID aus der GEMScript Message (msg[7]).
!end_xlist

Die Funktion muû TRUE zurÅckliefern, dann wird automtisch der das Kommando
GS_ACK gesendet mit dem Inhalt des Buffer.

Das Anmeldung von GEMScript Åbernimmt dabei SysGem automatisch.

!node Dateinamen und Pfade

!subnode FileExists

WORD FileExists ( BYTE *filename );

PrÅft das Vorhandensein der unter filename angegebenen Datei. Liefert
TRUE wenn die Datei vorhanden ist, sonst FALSE;

!subnode PathExists

WORD PathExists ( BYTE *pathname );

PrÅft das Vorhandensein des unter pathname angegebenen Pfad. Liefert
TRUE wenn der Pfad vorhanden ist, sonst FALSE;

!subnode GetPath

WORD GetPath ( BYTE *path, BYTE drive );

Liefert den aktuellen Pfad. (drive = 0 fÅr Defaultdrive) Liefert
TRUE wenn kein Fehler auftrat, sonst FALSE;

!subnode SetPath

WORD SetPath ( BYTE *path );

Liefert den aktuellen Pfad. (drive = 0 fÅr Defaultdrive) Liefert
TRUE wenn kein Fehler auftrat, sonst FALSE;

!subnode SplitFilename

VOID SplitFilename(BYTE *fullname, BYTE *path, BYTE *name);

Spaltet einen kompletten Dateipfad in Pfad und Name auf.
Wenn Pfad oder Name nicht interessieren, kann NULL angegeben
werden.

!subnode SplitExtension

VOID SplitExtension(BYTE *filename, BYTE *name, BYTE *extension);

Spaltet einen kompletten Dateinamen in Namen und Extender
(ohne Punkt) auf. Versteckte UNIX-Dateinamen (Dateien, die mit
einem Punkt am Anfang beginnen), werden berÅcksichtigt.
Wenn Name oder Extender nicht interessieren, kann NULL angegeben
werden.

!subnode MakeNormalPath

WORD MakeNormalPath(BYTE *path);

Wandelt Pfad in einen gÅltigen um (ggf. mit unx2dos).
Liefert das Ergebnis von PathExists(path) zurÅck.

!subnode MakeShortPath

VOID MakeShortPath(BYTE *path, BYTE *shortpath, WORD maxlen)

KÅrzt <path> auf <maxlen>. Falls <path> zulang ist, werden
'..' eingefÅgt.

!subnode SetExtension

VOID SetExtension(BYTE *filename, BYTE *new_ext);

éndert die Datei-Extension in einem Namen.
Versteckte UNIX-Dateinamen (Dateien, die mit
einem Punkt am Anfang beginnen), werden berÅcksichtigt.

!node Sonstige Routinen

In diesem Abschnitt finden Sie die Funktionen, die nicht zu den
anderen Kapiteln so richtig passen wollen.


!subnode GetCookie

BOOL GetCookie ( LONG id, LONG *value );


Diese Funktion sucht nach dem Cookie mit der Id 'id' und schreibt in
'value' dessen Wert, falls gefunden.

Die Funktion liefert TRUE, wenn der Cookie gefunden wurde, FALSE
sonst.

Wollen Sie nur testen, ob ein Cookie existiert, kînnen Sie fÅr
'value' auch NULL Åbergeben.


!subnode crc_16

UINT crc_16 ( BYTE *s, ULONG len );


Berechnet eine CRC-16 PrÅfsumme Åber den Speicherbereich, der bei 's'
beginnt und 'len' Bytes lang ist.


!subnode crc_32

ULONG crc_32 ( BYTE *s, ULONG len );


Berechnet einen CRC-32 PrÅfsumme Åber den Speicherbereich, der bei
's' beginnt und 'len' Bytes lang ist.


!subnode ShowMessage

VOID ShowMessage ( BYTE *text );


ôffnet ein kleines Fenster, in dem der Text 'text' zentriert gezeigt
wird. Ein erneuter Aufruf der Funktion Ñndert den Text.

Diese Funktion ist zum Anzeigen von Programmnachrichten gedacht, so
was wie "Bitte warten..." oder "Datei x wird geladen..." oder so.

Das Fenster wird mit EndMessage wieder geschlossen.


!subnode EndMessage

VOID EndMessage ( VOID );


Diese Funktion schlieût das Fenster, welches vorher mit ShowMessage
geîffnet wurde.


!subnode SelectPrinter

INT SelectPrinter ( VOID );


Wenn Åber (!xlink [GDOS] [GDOS_FAQ/Main]) gedruckt werden soll, stellt sich meist die Frage, auf
welchen Drucker. Unter NVDI ist es ja mîglich, mehrere Drucker anzu-
melden. Es wird also eine Art Auswahlbox benîtigt; und die stellt
SysGem zur VerfÅgung:


!image IMG399.IMG Der Druckerauswahl-Dialog

Bei Aufruf erscheint das obige Bild, in dem alle verfÅgbaren Drucker
aufgelistet werden. WÑhlt der Benutzer einen an, wird die Kennung des
Druckers zurÅckgeliefert.

Klickt der Benutzer auf 'Abbruch', liefert die Funktion eine -1;
ebenso, wenn diese Funktion ohne (!xlink [GDOS] [GDOS_FAQ/Main]) aufgerufen wird.


!subnode ShowStatus
!begin_verbatim
VOID ShowStatus ( BYTE *text1, BYTE *text2, LONG p, LONG p100, INT esc );
!end_verbatim

Diese Funktion zeichnet eine Art Info-Fenster, so wie dieses Bild
hier zeigt:


!image IMG398.IMG Das Statusfenster

Dabei stehen als Nachricht fÅr den Benutzer zwei Textzeilen zur
VerfÅgung, und ein "Balken", der von links nach rechts wandert. Mit
dieser Funktion ist es ein einfaches, z. B. einen Ladevorgang oder
eine Kopieraktion dem Benutzer zu verdeutlichen und zu zeigen, wie
lange das Programm noch braucht.

Die Parameter:
!begin_xlist [xxxxxxxxx]
 !item [text1]      ist der Text, der in der obersten Zeile dargestellt wer-
            den soll.

 !item [text2]      ist der Text, der in der unteren Zeile dargestellt werden
            soll.

 !item [p]         ist der Wert, der anzeigt, wie weit die Aktion
            fortgeschritten ist, wobei

 !item [p100]       den Wert angibt, bei dem 100 % erreicht sind.

 !item [esc]        Ist esc TRUE erscheint der Text "Abbruch mit ESC", sonst
            nicht. Dieser Parameter hat nur einfluût beim ersten
            Aufruf. Bei allen weitern wird er ignoriert.
!end_xlist
Beispiel:

Sie wollen 300 Dateien kopieren und beginnen bei der ersten Datei.
Ein Aufruf kînnte dann so aussehen:

ShowStatus ( "Dateien werden kopiert...", "<Dateiname>", 1L, 300L, FALSE );


Im Beispiel wÅrde dann der Balken ganz links stehen und als Anzeige
"0 %" im Balken erscheinen.

Um den Status anzugleichen, wird die Funktion einfach mit den neuen
Parametern aufgerufen, wobei 'p' und 'p100' (!B)immer(!b) Åbergeben werden
mÅssen!

Wollen Sie 'text1' oder 'text2' Ñndern, Åbergeben Sie einfach den
neuen Text; wollen Sie ihn (!B)nicht(!b) Ñndern, sondern nur die
Prozentanzeige angleichen, Åbergeben Sie fÅr den Text, den Sie (!B)nicht(!b)
Ñndern wollen, einfach NULL.

Das Fenster wird mit EndStatus wieder entfernt.


!subnode EndStatus

VOID EndStatus ( VOID );


Diese Funktion entfernt ein mit ShowStatus dargestelltes Fenster
wieder vom Bildschirm.

!subnode FileSelect

!begin_verbatim
BOOL FileSelect ( BYTE *name, BYTE *path, BYTE *suffix,
                  BYTE *title, BYTE *file_name );
!end_verbatim
Ruft den Dateiauswahldialog auf. Falls vorhanden wird die MagiC Datei-
auswahl im Fenster aufgerufen.

Die Parameter:
!begin_xlist [xxxxxxxxxxx]
 !item [name]       Dateiname mit dem die Auswahl vorbelegt werde soll.
 						Nachdem dem Aufruf steht ihr der ausgewÑhlte Dateiname.

 !item [path]       Beim Aufruf der einzustellende Pfad, als RÅckgabe der
            eingestellte Pfad.

 !item [suffix]     Extention nach der selektiert werden soll. Ist MagiC vorhanden
 						dann kann man mehr als eine Extention angeben. Dies muû dann
 						folgendermaûen geschehen:
 						Dateinamensmuster wie "*.TXT", "*.PRG" oder "*.IMG".
 						Einzel anwÑhlbare Muster sind durch EOS getrennt und
 						durch EOS,EOS abgeschlossen.

 !item [titel]      Wird als öberschrift benutzt falls die TOS Version dies
            zulÑût.
            
 !item [file_name]  RÅckgabe des ausgewÑhlten Dateinamen + Verzeichnis.
!end_xlist
Gibt TRUE zurÅck, wenn der OK Button angewÑhlt wurde.

!subnode get_cpu


WORD get_cpu( VOID );

Liest den Cookie _CPU aus und gibt die entsprechenden Werte zurÅck.
!begin_verbatim
   0 = MC-68000
  10 = MC-68010
  20 = MC-68020
  30 = MC-68030
  40 = MC-68040
!end_verbatim
Falls der Cookie nicht vorhanden wird die Systemvaribale _longframe
ausgewertet.

!subnode get_longframe


LONG get_longframe( VOID );

Liest die Systemvaribale _longframe aus.

!subnode get_mch


WORD get_mch( VOID );

Ermittelt den Computertyp. Dabei gilt
!begin_verbatim
-1 = Emulator
0  = Atari ST
1  = Atari STE
2  = Atari Book
3  = Atari MegaSTE
4  = Atari TT
5  = Atari Falcon
6  = Medusa
7  = Hades
8  = Sparrow (Falcon-VorseriengerÑt) 
9  = Milan
10 = ARAnyM
!end_verbatim

!node Strukturen

SysGem verwendet mehrere feste Strukturen, um verschiedene Daten an
die Funktion zu bringen. Hier mal eine Auflistung:

!subnode XTREE
!begin_verbatim
typedef struct
  {
    LONG        id;
    OBJECT      *tree;
    INT         pos;
    INT         start;
    INT         depth;
    INT         edit;
  } XTREE;
!end_verbatim
!begin_xlist [xxxxxxx]
 !item [id]       ist eine eindeutige ID, die den Baum nÑher beschreibt. Alle
          Reaktionen von SysGem an die Handlerfunktion wird dann Åber
          diese ID klassifiziert.

 !item [tree]     Zeiger auf den Objektbaum, der gezeichnet werden soll. Der
          Baum nuû vorher mit NewDialog angemeldet worden sein.

 !item [pos]      ist die Positionsangabe, wo der Baum gezeichnet werden
          soll.

          LINK_TOP zeichnet den Baum unterhalb der (vielleicht)
          vorhandenen MenÅzeile. Die Breite des Baumes wird dabei
          automatisch an die Breite des Fensters angepasst.

          LINK_LEFT zeichnet den Baum an die linke Seite des Fen-
          sters. Die Hîhe des Baumes wird dabei automatisch an die
          Hîhe des Fensters angepasst.

          LINK_RIGHT wie bei LINK_LEFT, nur auf der rechten Seite des
          Fensters.

          LINK_BOTTOM wie bei LINK_TOP, nur am unteren Rand des Fen-
          sters.

 !item [start]    gibt die Objektnummer an, ab der gezeichnet werden soll.
          Normalerweise sollte dies 0 (ROOT) sein.

 !item [depth]    gibt die Tiefe an, bis zu der gezeichnet werden soll.
          Normalerweise ist dieser Wert 8 (MAX_DEPTH).

 !item [edit]     Reserviert. Immer 0.
!end_xlist
Bitte beachten:
!begin_enumerate
  !item Bei GrîûenÑnderungen des Fensters werden die Positionen und
     Ausmaûe (Breite und auch Hîhe (LINK_TOP/BOTTOM)) automatisch
     angepasst und neu gezeichnet.

  !item Es kînnen beliebig viele BÑume an der gleichen Stelle stehen!

     Somit ist es also ohne Probleme mîglich, z. B. 6 BÑume mit
     LINK_TOP anzumelden. Diese BÑume werden dann in der Reihenfolge
     ihrer Definition gezeichnet und untereinander plaziert.

     Das gleiche gilt natÅrlich auch fÅr die anderen LINK_... Komman-
     dos.
!end_enumerate

!subnode DRAG_DROP
!begin_verbatim
typedef struct
  {
    BOOL        gemini;
    LONG        data_type;
    BYTE        *data;
    LONG        data_len;
    BYTE        data_id  [128];
    BYTE        filename [128];
    INT         x;
    INT         y;
    INT         state;
    INT         obj;
    LONG        id;
  } DRAG_DROP;
!end_verbatim

Die Elemente im Einzelnen:
!begin_xlist [xxxxxxxxxxxx]
 !item [gemini]       ist TRUE, wenn die Nachricht von Gemini kam, FALSE,
              wenn von MiNT.

 !item [data_type]    Typ-Id von MiNT.

 !item [data]         Zeiger auf die Daten, die Åbertragen wurden. Diese wer-
              den von SysGem zwischengepuffert.

 !item [data_len]     LÑnge von 'data'. Nur belegt, wenn die Nachricht von
              MiNT kam, bei Gemini entspricht die LÑnge = strlen (
              data );

 !item [data_id]      Klassifizierung der Daten von MiNT.

 !item [filename]     Filename von Irgendwas. Kommt von MiNT.

 !item [x, y]         Koordinaten der Maus.

 !item [state]        Status der Sondertasten.

 !item [obj]          Ist != -1, wenn die Maus Åber einem Objekt im Fenster
              losgelassen wurde. Dann enthÑlt 'obj' die Nummer dieses
              Objektes.

 !item [id]           enthÑlt die Id des Baumes, wenn obj != -1.
!end_xlist

!subnode DIALOG_INFO

Diese Struktur wird jeder Handlerfunktion eines Fensterdialogs bei
öbermittlung einer Nachricht mit Åbergeben. In dieser Struktur werden
grundlegende Daten als auch Parameter, die die Nachricht betreffen,
angegeben.
!begin_verbatim
typedef struct
  {
    LONG        id;
    VOID        *user;
    DRAG_DROP   *dd;
    LONG        denied;
    OBJECT      *tree;
    INT         kstate;
    INT         edit_field;
    INT         box;
    RECT        clip;
  } DIALOG_INFO;
!end_verbatim
Da nicht jedesmal alle Parameter belegt sind, kann hier auch nur eine
kurze öbersicht Åber die EintrÑge gegeben werden, wozu diese (!B)meistens(!b)
benutzt werden. Die genaue Belegung ist bei den entsprechenden Nach-
richten von SysGem beschrieben.
!begin_xlist [xxxxxxxxxxxxxx]
 !item [id]            enthÑlt die ID des Fensterdialogs

 !item [user]          enthÑlt einen User-Zeiger, der es ermîglicht, dem
               Dialog Daten mitzugeben, die man im Programm nicht
               statisch sichern will.

 !item [dd]            enthÑlt beim Eintreffen von SG_DRAGDROP einen Zeiger
               auf die DRAG_DROP Struktur. Ansonsten ist sie immer
               NULL.

 !item [denied]        ist ein Mehrzweckfeld und wird fÅr die unterschiedlich-
               sten Dinge gebraucht und benutzt. Die Namesgebung
               entstand bei der Programmierung der Modulschnitt-
               stelle, die allerdings noch nicht îffentlich ist.

 !item [tree]          enthÑlt einen Zeiger auf den Baum, der als Dialog
               gerade im Fenster dargestellt wird.

 !item [kstate]        enthÑlt immer den Status der Sondertasten beim
               Eintreffen einer Nachricht.

 !item [edit_field]    enthÑlt die Objektnummer des Editfeldes, in dem der
               Cursor gerade steht.

 !item [box]           wird nur bei SG_SLIDER benutzt, ansonsten 0.

 !item [clip]          wird nur bei SG_DRAWOWN benutzt, ansonsten nicht
               definiert.
!end_xlist

!subnode WINDOW_INFO

Diese Struktur wird jeder Handlerfunktion eines Fensters bei
öbermittlung einer Nachricht mit Åbergeben. In dieser Struktur werden
grundlegende Daten als auch Parameter, die die Nachricht betreffen,
angegeben.
!begin_verbatim
typedef struct
  {
    LONG        id;
    INT         handle;
    LONG        pos_x;
    LONG        pos_y;
    LONG        doc_x;
    LONG        doc_y;
    INT         key;
    INT         state;
    INT         mTitle;
    INT         mItem;
    INT         mx, my;
    LONG        line;
    LONG        column;
    BYTE        *line_ptr;
    VOID        *line_user;
    RECT        work_area;
    RECT        draw_area;
    RECT        clip;
    VOID        *user;
    OBJECT      *tree;
    LONG        obj_id;
    INT         item;
    INT         box;
    DRAG_DROP   *dd;
    LONG        denied;
  } WINDOW_INFO;
!end_verbatim
Da nicht jedesmal alle Parameter belegt sind, kann hier auch nur eine
kurze öbersicht Åber die EintrÑge gegeben werden, wozu diese (!B)meistens(!b)
benutzt werden. Die genaue Belegung ist bei den entsprechenden Nach-
richten von SysGem beschrieben.
!begin_xlist [xxxxxxxxxxxxxx]
 !item [id]            enthÑlt die ID des Fensters.

 !item [handle]        enthÑlt das AES-Handle des Fensters. Beachten Sie aber
               bitte immer, daû sich das Handle jederzeit Ñndern
               kann!

 !item [pos_x, pos_y]  enthalten die Koordinaten des Arbeitsbereiches relativ
               zum Nullpunkt des Dokumentbereiches. Die Werte sind in
               Pixeln angegeben.

 !item [doc_x, doc_y]  enthalten die Grîûe des Document-Bereiches in Pixeln.

 !item [key]           wird fÅr die öbergabe von Tastencodes benutzt.

 !item [state]         enthÑlt den Status der Sondertasten.

 !item [mTitle]        Relikt aus der 1.x. Nicht mehr genutzt.

 !item [mItem]         EnthÑlt die Objektnummer eines Eintrages der Fen-
               stermenÅzeile.

 !item [mx, my]        enthalten die Mausposition.

 !item [line]          Befindet sich im Fenster eine mit LinkList oder
               xLinkList hinzugefÅgte Liste, und befindet sich unter
               dem Punkt, den der Benutzer angeklickt hat, eine
               Textzeile, so enthÑlt 'line' die Nummer der Zeile, die
               unter dem angeklickten Punkt liegt.

 !item [column]        Befindet sich im Fenster eine mit LinkList oder
               xLinkList hinzugefÅgte Liste, und befindet sich unter
               dem Punkt, den der Benutzer angeklickt hat, eine
               Textzeile, so enthÑlt 'column' die Nummer der Spalte,
               die unter dem angeklickten Punkt liegt.

 !item [line_ptr]      wenn 'line' != -1L, so enthÑlt dieser Zeiger einen
               Zeiger auf das erste Zeichen des Textes, der sich in
               dieser Zeile befindet. Der Text dieser Zeile darf
               nicht verÑndert werden, er ist (!B)read-only(!b)! Zum éndern
               kînnen Sie die Funktionen ChgInList oder xChgInList
               verwenden.

 !item [line_user]     Bei den xLink... Funktionen kînnen Sie fÅr jede Zeile
               einen eigenen User-Zeiger mitgeben. War einer angege-
               ben, enthÑlt diese Variable diesen Zeiger, ansonsten
               NULL.

 !item [work_area]     enthÑlt die Ausmaûe des Brutto-Arbeitsbereiches.
               Eventuell eingelinkte BÑume zÑhlen zu diesem Rechteck
               dazu!

 !item [draw_area]     enthÑlt die Ausmaûe des Netto-Arbeitsbereiches. Dieses
               Rechteck entspricht dem reinen Arbeitsbereich, in dem
               Daten des Programms dargestellt werden kînnen.

 !item [clip]          Wird fÅr Redraw-Kommdos benutzt.

 !item [user]          enthÑlt einen User-Zeiger, der es ermîglicht, dem
               Dialog Daten mitzugeben, die man im Programm nicht
               statisch sichern will.

 !item [tree]          enthÑlt ab und zu einen Zeiger auf einen Baum.
               AbhÑngig von der jeweiligen Nachricht.

 !item [obj_id]        EnthÑlt ab und zu die ID eines Baumes. AbhÑngig von
               der jeweiligen Nachricht.

 !item [box]           Normalerweise nicht benutzt.

 !item [dd]            enthÑlt beim Eintreffen von SG_DRAGDROP einen Zeiger
               auf die DRAG_DROP Struktur. Ansonsten ist sie immer
               NULL.

 !item [denied]        ist ein Mehrzweckfeld und wird fÅr die unterschiedlich-
               sten Dinge gebraucht und benutzt. Die Namesgebung
               entstand bei der Programmierung der Modulschnitt-
               stelle, die allerdings noch nicht îffentlich ist.
!end_xlist

!subnode RECT
!begin_verbatim
typedef struct
  {
    INT     x;
    INT     y;
    INT     w;
    INT     h;
  } RECT;
!end_verbatim

Diese Struktur wird in SysGem dazu verwendet, Bildschirmbereiche zu
beschreiben und zwar anhand ihrer linken oberen Ecke (x, y) dessen
Breite (w) und dessen Hîhe (h) in Pixeln.


!subnode FUNCTIONS

Diese Struktur enthÑlt alle Funktionszeiger auf die SysGem-Funktion-
en. Bitte lesen Sie auch unbedingt: Der Aufbau eines Moduls

Ebenfalls in dieser Struktur enthalten sind auch Zeiger auf
rudimentÑre Funktionen, die in jedem Programm gebraucht werden. Diese
kînnen jedoch wie auch alle anderen Funktionen Åber ihren normalen
Namen angesprochen werden, da in der Datei "sys_mod2.h" alle Funk-
tionsnamen via #define umgenagelt werden.

Alle hier nicht fett geschriebenen Funkionen sind die Standardfunktio-
nen, die fÅr Module zusÑtzlich noch verfÅgbar sind.

!begin_verbatim
typedef struct
  {
    VOID   *( *Allocate        )( LONG size );
    VOID    ( *Dispose         )( VOID *ptr );
    BOOL    ( *AddSliderItem   )( OBJECT *tree, INT box, INT anz_items );
    BYTE   *( *AddToList       )( LONG win_id, BYTE *text );
    INT     ( *Alert           )( INT priority, INT def, BYTE *str );
    LONG    ( *AskModule       )( BYTE *name, INT cmd, VOID *ptr );
    BOOL    ( *BeginDialog     )( LONG win_id, OBJECT *tree, INT edit,
                                  BYTE *title );
    VOID    ( *BeginListUpdate )( LONG win_id );
    VOID    ( *CalcArea        )( OBJECT *tree, INT obj, RECT *r );
    BOOL    ( *CallOnlineHelp  )( BYTE *help );
    VOID    ( *CalcWinTrees    )( LONG win_id );
    INT     ( *CenterX         )( INT x1, INT x2, BYTE *text );
    INT     ( *CenterY         )( INT y1, INT y2 );
    VOID    ( *ChangeButton    )( OBJECT *tree, INT obj, BYTE *text );
    VOID    ( *CheckWindow     )( LONG win_id );
    BYTE   *( *ChgInList       )( LONG win_id, UINT line, BYTE *text );
    VOID    ( *ClearArea       )( AREA *p );
    VOID    ( *ClearEditFields )( OBJECT *tree );
    VOID    ( *ClipboardChanged)( VOID );
    VOID    ( *CloseAllWindows )( VOID );
    BOOL    ( *CloseWindow     )( INT handle );
    BOOL    ( *CloseWindowById )( LONG id );
    VOID    ( *CopyArea        )( INT vdi_handle, AREA *p, INT x, INT y );
    UINT    ( *CountKeywords   )( VOID );
    UINT    ( *CountLines      )( LONG win_id );
    INT     ( *CountWindows    )( VOID );
    INT     ( *Cycle           )( OBJECT *tree, INT obj, OBJECT *pop_tree,
                                  INT first, INT last, INT *ret );
    INT     ( *CycleBack       )( OBJECT *tree, INT obj, OBJECT *pop_tree,
                                  INT first, INT last, INT *ret );
    VOID    ( *CycleWindow     )( BOOL show_window );
    BOOL    ( *DeSelSldItem    )( OBJECT *tree, INT box, BOOL draw );
    VOID    ( *DelCompleteList )( LONG win_id );
    BOOL    ( *DelConfig       )( BYTE *keyword );
    BOOL    ( *DelDialog       )( OBJECT *tree );
    BOOL    ( *DelInList       )( LONG win_id, UINT line );
    VOID    ( *DelXTimer       )( LONG id );
    VOID    ( *DialPosXY       )( BOOL center );
    VOID    ( *Disable3D       )( VOID );
    VOID    ( *DisableObj      )( OBJECT *tree, INT obj, BOOL draw );
    VOID    ( *DisableTimer    )( VOID );
    VOID    ( *DispatchEvents  )( VOID );
    LONG    ( *Display         )( BYTE *fname, BYTE *wname, BYTE *winfo,
                                  INT len, LONG win_id, INT x, INT y,
                                  INT w, INT h, APROC action );
    INT     ( *DoDialog        )( OBJECT *tree, INT edit, BYTE *title );
    INT     ( *DrawSlider      )( OBJECT *tree, INT hide, LONG p1,
                                  LONG p2, BOOL draw );
!end_verbatim

Siehe auch: FUNCTIONS2

!subnode FUNCTIONS2
!begin_verbatim

    VOID    ( *Enable3D        )( VOID );
    VOID    ( *EnableObj       )( OBJECT *tree, INT obj, BOOL draw );
    VOID    ( *EnableTimer     )( VOID );
    VOID    ( *(!link [EndAbacus] [ShowAbacu])       )( VOID );
    VOID    ( *(!link [EndClock] [ShowClock])        )( VOID );
    VOID    ( *(!link [EndCoffee] [ShowCoffee])       )( VOID );
    VOID    ( *(!link [EndDice] [ShowDice])         )( VOID );
    VOID    ( *(!link [EndDisc] [ShowDisc])         )( VOID );
    VOID    ( *EndListUpdate   )( LONG win_id );
    VOID    ( *EndMessage      )( VOID );
    VOID    ( *EndStatus       )( VOID );
    VOID    ( *(!link [EndPaper] [ShowPaper])        )( VOID );
    VOID    ( *(!link [EndRotor] [ShowRotor])        )( VOID );
    VOID    ( *FastDrawSldBox  )( OBJECT *tree, INT box );
    INT     ( *FileSelect      )( BYTE *name, BYTE *path, BYTE *suffix,
                                  BYTE *title, BYTE *file_name );
    VOID    ( *FinishDialog    )( LONG win_id );
    BOOL    ( *FontExists      )( INT font_id );
    BOOL    ( *FontSelect      )( INT buttons, INT *id, INT *pt,
                                  BYTE *title, BYTE *example,
                                  BOOL internal, TPROC help_proc );
    VOID    ( *FrameTextColor  )( INT color );
    VOID    ( *FreeArea        )( AREA *p );
    BOOL    ( *GetConfig       )( BYTE *keyword, VOID *value );
    BOOL    ( *GetConfigPtr    )( BYTE *keyword, VOID *value, LONG *len );
    BOOL    ( *GetCookie       )( LONG id, VOID *value );
    INT     ( *GetFontId       )( BYTE *font_name );
    BYTE   *( *GetFontName     )( INT font_id );
    INT     ( *GetHandle       )( LONG win_id );
    INT     ( *GetInt          )( OBJECT *tree, INT index);
    INT     ( *GetLineHeight   )( LONG win_id );
    BYTE   *( *GetLinePtr      )( LONG win_id, UINT line );
    VOID   *( *GetListUserPtr  )( LONG win_id, UINT line );
    LONG    ( *GetLong         )( OBJECT *tree, INT index);
    VOID    ( *GetParStruct    )( (!link [PARAMETER] [GetParStruct]) *par );
    INT     ( *GetParam        )( INT par );
    INT     ( *GetSliderItems  )( OBJECT *tree, INT box );
    INT     ( *GetTabPosition  )( LONG win_id, INT tab, BOOL pixel );
    BYTE   *( *GetText         )( OBJECT *tree, INT index, BYTE *text );
    INT     ( *GetTopWindow    )( VOID );
    LONG    ( *GetTopWindowId  )( VOID );
    VOID   *( *GetWinUser      )( LONG win_id );
    LONG    ( *GetWindowId     )( INT handle );
    LONG    ( *GetXTimerId     )( VOID );
    VOID   *( *GetXTimerUser1  )( VOID );
    VOID   *( *GetXTimerUser2  )( VOID );
    INT     ( *HandleDialog    )( LONG win_id );
    VOID    ( *HandleSysGem    )( VOID );
    VOID    ( *HideCursor      )( LONG win_id );
    VOID    ( *HideObj         )( OBJECT *tree, INT obj, BOOL draw );
    BOOL    ( *InitResource    )( OBJECT *rsc_tree, UINT num_obs,
                                  UINT num_trees, VOID *rgb_table,
                                  BOOL long_rsc );
    VOID    ( *InitXWindow     )( (!link [XWIN] [XWindow]) *xwin );
    BYTE   *( *InsInList       )( LONG win_id, UINT line, BYTE *text );
    BOOL    ( *LinkHorSlider   )( OBJECT *tree, INT box, INT left,
                                  INT right, INT show, INT hide );
    VOID    ( *LinkImage       )( LONG win_id, BITBLK *image,BYTE *text);
    BYTE   *( *LinkList        )( LONG win_id, BYTE *text );
    VOID    ( *LinkMainImage   )( BITBLK *image, BYTE *text );
    BOOL    ( *LinkOwnRedraw   )( OBJECT *tree, INT obj );
!end_verbatim
Siehe auch: FUNCTIONS3


!subnode FUNCTIONS3
!begin_verbatim
    BOOL    ( *LinkSlider      )( OBJECT *tree, INT up, INT dn, INT show,
                                  INT hide, INT max, INT box, VOID *buf,
                                  INT len, BOOL icons );
    BOOL    ( *LinkTree        )( LONG win_id, OBJECT *tree, LONG id,
                                  INT pos );
    BOOL    ( *UnLinkTree      )( LONG win_id, OBJECT *tree );
    INT     ( *Listbox         )( BYTE *strings, INT count, INT len,
                                  OBJECT *tree, INT box );
    LONG    ( *LoadConfig      )( BYTE *file_name );
    INT     ( *LoadResource    )( BYTE *rsc_name, BOOL long_rsc );
    BOOL    ( *LoadSysGemModul )( BYTE *name );
    BOOL    ( *ModulAvail      )( BYTE *name );
    VOID    ( *MoveScreen      )( INT vdi_handle, RECT *r, INT x, INT y );
    BOOL    ( *MultipleDialog  )( LONG id, INT xpos, INT ypos, BYTE *name,
                                  BYTE *info, OBJECT *top, INT active,
                                  OBJECT *tree, INT edit, VOID *user,
                                  DPROC proc );
    BOOL    ( *NewArea         )( AREA *p );
    BOOL    ( *NewDialog       )( OBJECT *tree );
    VOID    ( *NormalFont      )( VOID );
    BOOL    ( *OpenLogWindow   )( LONG win_id, BYTE *title, BYTE *info,
                                  INT columns, INT rows, INT x, INT y,
                                  APROC action );
    INT     ( *OpenTextWindow  )( LONG id, BYTE *name, BYTE *info,
                                  OBJECT *menu, INT x, INT y, INT w,
                                  INT h, VOID *user, APROC action );
    INT     ( *OpenWindow      )( LONG id, BYTE *name, BYTE *info,
                                  INT flags, OBJECT *menu, INT align,
                                  BOOL part, INT scr_x, INT scr_y,
                                  LONG doc_x, LONG doc_y, INT x, INT y,
                                  INT w, INT h, VOID *user, RPROC redraw,
                                  APROC action );
    INT     ( *PopUp           )( OBJECT *tree, INT x, INT y, INT start,
                                  INT first );
    VOID    ( *ReSizeWindow    )( LONG win_id, RECT *size );
    VOID    ( *RectIntersect   )( RECT *r1, RECT *r2 );
    BOOL    ( *RectVisible     )( RECT *r );
    VOID    ( *RedrawArea      )( INT handle, RECT *area );
    VOID    ( *RedrawLine      )( LONG win_id, UINT line );
    VOID    ( *RedrawObj       )( OBJECT *tree, INT obj, INT depth,
                                  INT state, INT flag );
    VOID    ( *RedrawSliderBox )( OBJECT *tree, INT box );
    VOID    ( *RedrawTheSlider )( OBJECT *tree, INT box, BOOL draw );
    VOID    ( *RedrawWindow    )( INT handle );
    BOOL    ( *RemoveOwnRedraw )( OBJECT *tree, INT obj );
    VOID    ( *ResetSysFont    )( VOID );
    VOID    ( *RestoreArea     )( INT vdi_handle, AREA *p );
    OBJECT *( *RscAdr          )( INT tree_type, INT index );
    VOID    ( *RscFree         )( VOID );
    BOOL    ( *SaveArea        )( INT vdi_handle, AREA *p, RECT *r );
    LONG    ( *SaveConfig      )( BYTE *file_name );
    VOID    ( *ScrollSlider    )( OBJECT *tree, INT box, INT what );
    VOID    ( *ScrollWindow    )( INT handle, INT what );
    INT     ( *SearchProgram   )( BYTE *prg_name );
    INT     ( *SelectPrinter   )( VOID );
    BOOL    ( *SelectSldItem   )( OBJECT *tree, INT box, INT line,
                                  BOOL draw );
    VOID    ( *SendFontChanged )( INT font_id, INT font_pt );
!end_verbatim
Siehe auch: FUNCTIONS4


!subnode FUNCTIONS4
!begin_verbatim
    VOID    ( *Set3DAlertColor )( INT icn1, INT icn2, INT icn3 );
    VOID    ( *SetAccProc      )( TPROC acc_open, TPROC acc_close );
    VOID    ( *SetAlertColor   )( INT icn1, INT icn2, INT icn3 );
    VOID    ( *SetAlertTitle   )( BYTE *name );
    VOID    ( *SetButton       )( INT just );
    VOID    ( *SetClipping     )( RECT *r );
    BOOL    ( *SetConfig       )( BYTE *keyword, VOID *value, LONG len );
    VOID    ( *SetDispatchTime )( INT ms_low, INT ms_high );
    BOOL    ( *SetEditField    )( OBJECT *tree, INT field );
    VOID    ( *SetFont         )( INT font_id, INT pt );
    VOID    ( *SetFulledH      )( INT h );
    VOID    ( *SetFulledW      )( INT w );
    VOID    ( *SetFulledX      )( INT x );
    VOID    ( *SetFulledY      )( INT y );
    VOID    ( *SetIconRedraw   )( LONG win_id, (!link [IPROC] [SetIconRedraw]) proc );
    VOID    ( *SetIconifyName  )( BYTE *name );
    VOID    ( *SetInt          )( OBJECT *tree, INT index, INT i );
    VOID    ( *SetLanguage     )( BOOL english );
    INT     ( *SetLineColor    )( LONG win_id, UINT line, INT color );
    INT     ( *SetLineEffect   )( LONG win_id, UINT line, INT effect );
    INT     ( *SetLineFlags    )( LONG win_id, UINT line, INT flags );
    BOOL    ( *SetLineIcon     )( LONG win_id, UINT line, OBJECT *tree,
                                  INT obj );
    INT     ( *SetLineUser     )( LONG win_id, UINT line, INT user );
    VOID    ( *SetLinkIconColor)( LONG win_id, INT color );
    VOID    ( *SetLinkTextColor)( LONG win_id, INT color );
    BOOL    ( *SetListTab      )( LONG win_id, INT pos, INT just );
    BOOL    ( *SetListUserPtr  )( LONG win_id, UINT line, VOID *user );
    VOID    ( *SetLong         )( OBJECT *tree, INT index, LONG i );
    VOID    ( *SetMonoEditFrame)( BOOL paint );
    VOID    ( *SetOnlineHelp   )( BYTE *prg_name1, BYTE *prg_name2,
                                  BYTE *file_name );
    VOID    ( *SetProcEvent    )( TPROC proc );
    VOID    ( *SetProcTimer    )( TPROC proc );
    VOID    ( *SetProgramName  )( BYTE *name );
    VOID    ( *SetReturn       )( BOOL like_sysgem );
    VOID    ( *CheckLogFont    )( BOOL check );
    INT     ( *SetSelColor     )( INT color );
    INT     ( *SetSelTextColor )( INT color );
    VOID    ( *SetSliderFont   )( OBJECT *tree, INT box, INT font_id,
                                  INT font_pt, BOOL draw );
    INT     ( *SetSliderPos    )( OBJECT *tree, INT box, INT pos,
                                  BOOL draw );
    BOOL    ( *SetSliderTab    )( OBJECT *tree, INT box, INT pos,
                                  INT just );
    VOID    ( *SetSysFont      )( INT font_id );
    VOID    ( *SetText         )( OBJECT *tree, INT index, BYTE *text );
    VOID    ( *SetTextColor    )( OBJECT *tree, INT obj, INT color );
    VOID    ( *SetTimer        )( INT ms_low, INT ms_high );
    VOID    ( *SetULong        )( OBJECT *tree, INT index, ULONG i );
    VOID    ( *SetUnknownEvent )( UPROC proc );
    VOID    ( *SetWinBackground)( LONG win_id, INT color );
    VOID    ( *SetWinMaxSize   )( LONG win_id, INT w, INT h );
    VOID    ( *SetWinMinSize   )( LONG win_id, INT w, INT h );
    VOID    ( *SetWinUser      )( LONG win_id, VOID *user );
    BOOL    ( *SetWindowFont   )( LONG win_id, INT font_id, INT font_pt );
    VOID    ( *GetWindowFont   )( LONG win_id, INT *id, INT *pt );
    VOID    ( *SetWindowInfo   )( INT handle, BYTE *info );
    VOID    ( *SetWindowName   )( INT handle, BYTE *name );
!end_verbatim
Siehe auch: FUNCTIONS5


!subnode FUNCTIONS5
!begin_verbatim
    LONG    ( *SetWindowParm   )( INT handle, INT what, LONG value );
    VOID    ( *SetWindowTimer  )( LONG win_id, INT ms_low, INT ms_high );
    VOID    ( *SetXTimer       )( LONG id, TPROC proc, INT ms_low,
                                  INT ms_high, VOID *user1, VOID *user2);
    VOID    ( *ShortCutColor   )( INT color );
    VOID    ( *ShowAbacus      )( VOID );
    VOID    ( *ShowClock       )( VOID );
    VOID    ( *ShowCoffee      )( VOID );
    VOID    ( *ShowCursor      )( LONG win_id );
    VOID    ( *ShowDice        )( VOID );
    VOID    ( *ShowDisc        )( VOID );
    VOID    ( *ShowMessage     )( BYTE *text );
    VOID    ( *ShowStatus      )( BYTE *text1, BYTE *text2, LONG p,
                                  LONG p100, INT esc );
    VOID    ( *ShowObj         )( OBJECT *tree, INT obj, BOOL draw );
    VOID    ( *ShowPaper       )( VOID );
    VOID    ( *ShowRotor       )( VOID );
    VOID    ( *SmallFont       )( VOID );
    VOID    ( *StartSysGemModul)( BYTE *name, VOID *p );
    INT     ( *StringHeight    )( VOID );
    INT     ( *StringWidth     )( BYTE *text );
    BOOL    ( *SysGem3D        )( VOID );
    BYTE   *( *SysGemVerStr    )( INT i );
    UINT    ( *SysGemVersion   )( VOID );
    VOID    ( *TakeEvent       )( INT event, INT x, INT y, INT state,
                                  INT kstate, INT key, INT clicks,
                                  INT *msg );
    VOID    ( *TellKeyStrokes  )( BOOL tell );
    INT     ( *TerminateSysGem )( VOID );
    BOOL    ( *TopWindow       )( INT handle );
    BOOL    ( *UnLinkSlider    )( OBJECT *tree, INT box );
    VOID    ( *(!link [UpdateAbacus] [ShowAbacus])    )( VOID );
    VOID    ( *(!link [UpdateClock] [ShowClock])     )( VOID );
    VOID    ( *(!link [UpdateCoffee] [ShowCoffee])    )( VOID );
    VOID    ( *(!link [UpdateDice] [ShowDice])      )( VOID );
    VOID    ( *(!link [UpdateDisc] [ShowDisc])      )( VOID );
    VOID    ( *(!link [UpdatePaper] [ShowPaper])     )( VOID );
    VOID    ( *(!link [UpdateRotor] [ShowRotor])     )( VOID );
    VOID    ( *UseFastTimer    )( LONG win_id, BOOL enable );
    VOID    ( *UseOwnEditFields)( VOID );
    VOID    ( *UseRoundButtons )( BOOL use );
    BOOL    ( *VectorFont      )( INT font_id );
    VOID    ( *WaitAfterClose  )( BOOL wait );
    VOID    ( *WhiteArea       )( RECT *r, INT color );
    BOOL    ( *WindowDialog    )( LONG id, INT xpos, INT ypos,
                                  BYTE *name, BYTE *info, BOOL shut,
                                  BOOL force, OBJECT *tree, OBJECT *menu,
                                  INT edit, VOID *user, DPROC proc );
    BOOL    ( *WindowVisible   )( INT handle );
    VOID   *( *XWindow         )( (!link [XWIN] [XWindow]) *xwin );
    INT     ( *cmp_strings_dn  )( BYTE *str1, BYTE *str2 );
    INT     ( *cmp_strings_up  )( BYTE *str1, BYTE *str2 );
    UINT    ( *crc_16          )( BYTE *s, ULONG len );
    ULONG   ( *crc_32          )( BYTE *s, ULONG len );
!end_verbatim
Siehe auch: FUNCTIONS6


!subnode FUNCTIONS6
!begin_verbatim
    VOID    ( *do_qsort        )( LONG win_id, (!link [VPROC] [do_qsort]) compare );
    VOID   *( *memcpy          )( VOID *dest, CONST VOID *src,
                                  size_t len );
    VOID   *( *memset          )( VOID *ptr, INT val, size_t len );
    BYTE   *( *strcat          )( BYTE *s1, CONST BYTE *s2 );
    BYTE   *( *strchr          )( CONST BYTE *s, INT c );
    INT     ( *strcmp          )( CONST BYTE *s1, CONST BYTE *s2 );
    BYTE   *( *strcpy          )( BYTE *s1, CONST BYTE *s2 );
    INT     ( *stricmp         )( CONST BYTE *s1, CONST BYTE *s2 );
    BYTE   *( *strncat         )( BYTE *s1, CONST BYTE *s2, size_t n );
    INT     ( *strncmp         )( CONST BYTE *s1, CONST BYTE *s2,
                                  size_t n );
    BYTE   *( *strncpy         )( BYTE *s1, CONST BYTE *s2, size_t n );
    INT     ( *strnicmp        )( CONST BYTE *s1, CONST BYTE *s2,
                                  size_t n );
    BYTE   *( *strrchr         )( CONST BYTE *s, INT c );
    VOID    ( *v_stext         )( INT color, INT x, INT y, BYTE *text );
    VOID    ( *v_xtext         )( INT color, INT x, INT y, BYTE *text );
    VOID    ( *wcls            )( LONG win_id );
    BYTE    ( *wgetchar        )( LONG win_id, INT x, INT y, INT*eff );
    VOID    ( *wgetxy          )( LONG win_id, INT *x, INT *y );
    VOID    ( *wposxy          )( LONG win_id, INT x, INT y );
    VOID    ( *wprintf         )( LONG win_id, BYTE *format, ... );
    BYTE   *( *xAddToList      )( LONG win_id, BYTE *text,  INT effect,
                                  VOID *user );
    BYTE   *( *xChgInList      )( LONG win_id, UINT line, BYTE *text,
                                  VOID *user );
    BYTE   *( *xInsInList      )( LONG win_id, UINT line, BYTE *text,
                                  INT effect, VOID *user );
    BYTE   *( *xLinkList       )( LONG win_id, BYTE *text,  INT effect,
                                  VOID *user );
    BOOL    ( *xLinkSlider     )( OBJECT *tree, INT up, INT dn, INT show,
                                  INT hide, INT max, INT box, VOID *buf,
                                  INT len, BOOL icons, SPROC redraw );
    INT     ( *xListbox        )( BYTE *strings, INT count, INT len,
                                  OBJECT *tree, INT box, SPROC redraw );
    INT     ( *xPopUp          )( OBJECT *tree, INT obj, OBJECT *tree2,
                                  INT start, INT *first );
    BOOL    ( *xSetLineIcon    )( LONG win_id, UINT line, OBJECT *tree,
                                  INT obj );
    INT     ( *memcmp          )( CONST VOID *ptr1, CONST VOID *ptr2,
                                  size_t len );
    INT     ( *sprintf         )( BYTE *string, CONST BYTE *format,...);
    size_t  ( *strlen          )( CONST BYTE *s );
    VOID    ( *BeginHelp       )( OBJECT *tree, INT obj, BYTE *text );
    VOID    ( *EndHelp         )( VOID );
    VOID    ( *EnableHelp      )( VOID );
    VOID    ( *DisableHelp     )( VOID );
    VOID    ( *SetHelpTime     )( INT count );
    VOID    ( *SetHelpColor    )( INT color );
    VOID    ( *DebugTheModule  )( INT x, INT y );
    VOID    ( *DebugTheConfig  )( INT x, INT y, INT w_char, INT h_char );
    VOID    ( *winsert         )( LONG win_id );
    BOOL    ( *xOpenLogWindow  )( LONG win_id, BYTE *title, BYTE *info,
                                  INT anz_trees, XTREE *trees, INT columns,
                                  INT rows, INT x, INT y, VOID *user,
                                  APROC action );
    INT     ( *graf_mouse      )( int gr_monumber, MFORM *gr_mofaddr );
    INT     ( *sscanf          )( char *, const char *, ... );
    LONG    ( *Supexec         )( long (*func)( ));
    VOID    ( *qsort           )( void *base, size_t nmemb, size_t size, int (*compar)( ));
    INT     ( *Fsfirst         )( const char *filename, int attr );
    INT     ( *Fsnext          )( VOID );
    DTA    *( *Fgetdta         )( VOID );
    VOID   *( *Mxalloc         )( long amount, int mode );
    INT     ( *rsrc_obfix      )( OBJECT *re_otree, int re_oobject );
    INT     ( *get_cpu         )( VOID );
    LONG    ( *get_longframe   )( VOID );
    INT     ( *get_mch         )( VOID );
    VOID    ( *SetOwner        )( LONG owner );
    LONG    ( *GetOwner        )( LONG win_id );
    VOID    ( *xSetText        )( OBJECT *tree, INT index, BYTE *text );
    BYTE   *( *GetModuleName   )( BYTE *real_name );
    FILE   *( *fopen           )( const char *, const char * );
    INT     ( *fclose          )( FILE * );
    INT     ( *fprintf         )( FILE *, const char *, ... );
    BYTE   *( *fgets           )( char *, int, FILE * );
    INT     ( *fseek           )( FILE *, LONG, INT );
    size_t  ( *fread           )( VOID *, size_t, size_t, FILE *);
    size_t  ( *fwrite          )( const VOID *, size_t, size_t, FILE *);
    VOID    ( *SendSliderPos   )( BOOL send );
    VOID    ( *ChangeDialog    )( LONG id, INT active );
  } FUNCTIONS;
!end_verbatim

!begin_appendix

!node Fenster-Id

In SysGem werden Fenster oder Dialoge nicht durch das Handle gekenn-
zeichnet, welches das AES einem Fenster vergibt, sondern durch eine
Id.

Diese Id ist eigentlich ein Long (32-Bit) und kann so 4 Zeichen
aufnehmen. Anhand dieser Id kînnen Sie dann ein Fenster oder einen
Dialog oder auch einen Baum im Fenster wie mit einem richtigen Namen
ansprechen.

Dies hat mehrere Vorteile:
!begin_enumerate
  !item Sie kînnen sich einen solchen Namen leichter merken, als eine Va-
     riable.

  !item Sie brauchen nicht fÅr jeden Baum im Fenster oder fÅr jedes Fen-
     ster generell eine statische Variable mitfÅhren, durch die es
     angesprochen werden kann.

  !item Die vom AES vergebenen Handles kînnen sich in SysGem Ñndern. Es
     ist also nie garantiert, daû ein Fenster, das geschlossen werden
     soll, noch das gleiche Handle besitzt wie das, als es geîffnet
     wurde. Die Id hingegen Ñndert sich nie.

  !item Es ist mîglich, eine Handlerfunktion fÅr mehrere Fenster anzu-
     melden. Da die Id immer "mitgeliefert" wird, ist immer eine ein-
     deutige Referenz auf den aktuellen Baum gegeben.
!end_enumerate
Alles in allem also eine sinnvolle Eigenschaft, die gerade den
AnfÑngern das Leben ungemein erleichtet.

Die Id darf jeden Wert annehmen, wie dies auch bei den Cookies
mîglich ist; sie darf aber (!B)nie(!b) den Wert 0L haben. Sollten Sie es
einmal versuchen, wird jede Funktion, die eine Id erwartet, bei 0L
mit einer Fehlermeldung abbrechen.


!node Shortcut

Ein Shortcut ist eine Tastenkombination, mit der es mîglich ist,
einen Button in einem Dialog anzuwÑhlen, ohne die Maus zu benutzen.

Ist ein Button mit der Tastatur anwÑhlbar, so wird dies dadurch
verdeutlicht, daû innerhalb des Buttons ein Zeichen unterstrichen
ist. Durch DrÅcken der Taste ALTERNATE gleichzeitig mit dem
unterstrichenen Buchstaben simuliert so ein Anklicken des Buttons mit
der Maus.

Damit ein Button eine solche FunktionalitÑt erhÑlt, wird einfach vor
das Zeichen, das unterstrichen werden soll, eine îffnende eckige
Klammer '[' gesetzt. Anhand dieses Zeichens erkennt SysGem dann den
Buchstaben, den SysGem unterstreichen soll. Es ist allerdings nur
logisch, daû jeder Buchstabe nur einmal vorkommen darf. Haben z. B.
zwei Buttons als Shortcut das 'A', so nimmt SysGem den ersten Button,
auf den dieses Zeichen passt.

Als Shortcut akzeptiert SysGem alle Buchstaben von A bis Z und die
Zahlen 0 bis 9. Alle Åbrigen Zeichen werden nicht unterstÅtzt.

Die Klammer '[' wird beim Zeichnen natÅrlich nicht dargestellt.


!node Reiter

Die "Reiter" sind neu in SysGem 2.00. Ich muû zugeben, daû ich mich
habe von Windows beim Design inspirieren lassen, denn dort gefallen
sie mir nÑmlich sehr gut. Und es soll ja auch etwas fÅr das Auge
sein...


!image IMG397.IMG Die Reiter in der Resource

FÅr ein besseres Bild siehe auch bei MultipleDialog.

Reiter bestehen aus einem BOX-Objekt (Objektnummer 0!) und dem
erweiterten Typ 16 als Untergrund. Dieses Objekt sollte 1,5 Zeichen
(24 Pixel) hoch sein, damit die Reiter genug Platz finden (die Short-
cuts mÅssen ja auch noch irgendwo hin). Die Breite des Objekts muû
genauso breit sein, wie die einzelnen Dialoge bzw. deren ObjektbÑume.

Die einzelnen Reiter selbst sind vom Typ BUTTON und haben den
Erweiterten Typ 3; ansonsten keine weiteren Stati oder Flags. Sie
sind ebenfalls 1,5 Zeichen (24 Pixel) hoch, die Breite hÑngt von der
Menge und Ihrem Geschmack ab.

Der erste Reiter sollte 1 Zeichen Platz zum linken Rand besitzen und
die einzelnen Reiter sollten jeweils ein halbes Zeichen Zwischenraum
zum nÑchsten haben. Mit diesen Angaben sehen die Reiter (nach meinem
Geschmack) am besten aus.

Die Objektnummern der einzelnen Reiter sollten Sie sich merken, denn
mit ihnen wird der im Fenster darzustellende Dialog referenziert.


!node Erweitertere Typen
!subnode Erweiterter Typ: PopUp

SysGem unterstÅtzt einen besonderen Typ eines BOXTEXT. Dieser wird
dann so gezeichnet, daû er sofort als Popup oder Listbox fungieren
kann, wie Sie auf den beiden unteren Bildchen sehen kînnen.

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von 
(!xlink [ZeigsMir] [ZEIGSMIR.HYP/Main]) mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:


!image IMG396.IMG Ein Popup sieht in 3D so aus...


!image IMG395.IMG ...und so in Monochrom

Dieses Popup- oder Listbox-Element wird einfach erzeugt, indem Sie
einen BOXTEXT mit dem erweiterten Typ 2 versehen.


!subnode Erweiterter Typ: Editfeld

Damit in 3D die Editfelder zu unterscheiden sind, und damit das
Redraw nicht in ein Chaos ausbricht, wenn Sie (!B)nicht(!b) UseOwnEditFields
angeben, zeichnet SysGem um die Editfelder einen Rahmen und den
Inhalt des Editfeldes weiû. Das ganze kînnen Sie sich auf den
Bildchen unten einmal ansehen. UseOwnEditFields ist aktiv, zu
erkennen an dem etwas dickeren Cursor...

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von
(!xlink [ZeigsMir] [ZEIGSMIR.HYP/Main]) mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:


!image IMG394.IMG Ein Editfeld kann in 3D so aussehen...


!image IMG393.IMG ...und so in Monochrom

Die Editfelder werden automatisch so gezeichnet, wenn - und nur wenn
- UseOwnEditFields aktiv ist. Ansonsten sollten Sie eine Box mit
Erweitertem Typ 4 um die Editfelder legen. Diesen Rahmen sehen Sie
dann nur in 3D, er stellt aber sicher, daû die Editfelder auf weiûem
Grund liegen. Das AES kommt nÑmlich nicht damit zurecht, wenn
Editfelder auf grauem Hintergrund liegen.

(!B)Bitte beachten:(!b)

Innerhalb von Editfeldern haben folgende Tasten noch eine besondere
Bedeutung:
!begin_xlist [xxxxxxxxxxxxx]
 !item [Control-X]    Schneidet den Text, der sich im Editfeld befindet aus
              und speichert ihn im Clipboard. Existiert ein
              physikalisches Clipboard nicht, speichert SysGem den
              Text in einem internen Buffer. Anschlieûend wird das
              Editfeld gelîscht.

 !item [Control-C]    Kopiert den Text, der sich im Editfeld befindet aus und
              speichert ihn im Clipboard. Existiert ein
              physikalisches Clipboard nicht, speichert SysGem den
              Text in einem internen Buffer. Der Text im Editfeld
              bleibt erhalten.

 !item [Control-V]    FÅgt den Inhalt des Clipboards in das Editfeld ein. Der
              ursprÅngliche Inhalt geht dabei verloren.

 !item [Control-D]    Lîscht den Inhalt des Clipboards.

 !item [HOME]         Setzt den Cursor in das erste Editfeld des Dialogs.

 !item [Shift-Home]   Setzt den Cursor in das letzte Editfeld des Dialogs.

 !item [Shift-Left]   Setzt den Cursor an den Anfang der Zeile

 !item [Shift-Right]  Setzt den Cursor an das Ende der Zeile
!end_xlist

!subnode Erweiterter Typ: Circle

SysGem unterstÅtzt einen besonderen Typ eines BOXTEXT. Dieser wird
dann so gezeichnet, daû er sofort als Circle-Button fungieren kann
(mit Hilfe der Funktion Cycle), wie Sie auf den beiden unteren
Bildchen sehen kînnen.

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von
(!xlink [ZeigsMir] [ZEIGSMIR.HYP/Main]) mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:


!image IMG392.IMG Eine Circle-Box in SysGem (3D)


!image IMG391.IMG ...und so in monochrom

Dieser Circle-Button wird einfach erzeugt, indem Sie einen BOXTEXT
mit dem erweiterten Typ 3 versehen.


!subnode Erweiterter Typ: Boxchar

SysGem bietet auch bei den Boxchars (Objekte, die nur ein Zeichen
aufnehmen kînnen) ein paar Besonderheiten. So sind Pfeile z. B. fÅr
den Einsatz in der Sliderbox gedacht, aber das hÑngt von Ihrem
Geschmack ab. SysGem stellt Ihnen jedoch diese Objekte fÅr den Fall
des Falles zur VerfÅgung (mir gefallen Sie besser als die AES-
Pfeile...)

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von
(!xlink [ZeigsMir] [ZEIGSMIR.HYP/Main]) mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:
!begin_raw
@Image I:\C\SRC\SYSGEM\DOC\QUELLEN\IMG390.IMG 2 


             Erweiterter Typ 0


             Erweiterter Typ 1


             Erweiterter Typ 2


             Erweiterter Typ 3


             Erweiterter Typ 4


             Erweiterter Typ 5


             Erweiterter Typ 6


             Erweiterter Typ 7


             Erweiterter Typ 8


             Erweiterter Typ 9


             Erweiterter Typ 10


             Erweiterter Typ 1 (Shadowed)


             Erweiterter Typ 3 (Shadowed)


             Erweiterter Typ 4 (Shadowed)


             Erweiterter Typ 5 (Shadowed)


             Erweiterter Typ 6 (Shadowed)


!end_raw


...in Monochrom sehen die einzelnen Boxchars dann so aus:


!image IMG389.IMG

!subnode Erweiterter Typ: BOXen

Gerade in 3D ist es wichtig, daû fÅr Abgrenzungen und Hervorhebungen
entsprechende Mittel bereitstehen. SysGem nutzt dafÅr die Objekte vom
Typ BOX, die mit erweiterten Typen eine FÅlle von Mîglichkeiten
bieten. Ob Sie nun ein Objekt brauchen, das ein wenig "aus dem
Dialog" herausschaut oder wie eingelassen wirkt, SysGem bietet fÅr
jeden Zweck das richtige Mittel.

Bedenken Sie jedoch, daû es mehrere Objekte gibt, die erst unter 3D
ihr "wahres" Gesicht zeigen und in Monochrom gleich aussehen.

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von @{"ZeigsMir" LINK "ZEIGSMIR.HYP/Main"} mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:
!begin_raw
@Image I:\C\SRC\SYSGEM\DOC\QUELLEN\IMG388.IMG 1



                               Erweiterter Typ 2







                               Erweiterter Typ 3







                               Erweiterter Typ 4
                               (nur sichtbar in 3D)






                               Erweiterter Typ 5






                               Erweiterter Typ 2
                               (Selected)






                               Erweiterter Typ 3
                               (Selected)






                               Erweiterter Typ 7







                               Erweiterter Typ 8







                               Erweiterter Typ 9






                               Erweiterter Typ 12






                               Erweiterter Typ 13
                               (nur in 3D)




!end_raw


In Monochrom sehen die Boxen dann so aus:


!image IMG387.IMG

!subnode Erweiterter Typ: Buttons

Sehr viel Arbeit hat das Design der Buttons in Anspruch genommen,
kommen diese doch in jedem Dialog vor. Auch hier bietet SysGem wieder
ein paar Besonderheiten, z. B. die Help-Buttons.  Beide haben eins
gemeinsam: klickt der Benutzer auf diesen Button, wird immer auto-
matisch die SG_HELP Nachricht verschickt.

Bitte beachten Sie: Da ich nur einen Monochrom-Monitor besitze, habe
ich leichte Probleme, mit Farbbildern umzugehen. Desweiteren will ich
anderen Monochrom-Besitzern auch ein ungefÑhres Bild verschaffen, wie
so ein Popup in 3D aussieht. Deshalb wurde das XIMG von @{"ZeigsMir" LINK "ZEIGSMIR.HYP/Main"} mit
dem Dithermodul "Halbtondither 5 GS" in Monochrom umgerechnet. Dieses
verwendet eine 2x2 Matrix, wodurch das Farbbild in Monochrom ein
StÅck grîûer wird, aber Sie sollen ja auch was erkennen kînnen...

Hier die Bildchen:
!begin_raw
@Image I:\C\SRC\SYSGEM\DOC\QUELLEN\IMG386.IMG 1 


                               Touchexit




                               Exit & Selectable




                               Exit & Selectable & Default




                               Disabled




                               Erweiterter Typ 1 -> Help-Button




                               Erweiterter Typ 2 -> Help-Button


!end_raw

Diese Objekte sehen dann in monochrom so aus:


!image IMG385.IMG

!node Autor

Sollten Sie eine Funktion vermissen, einen Wunsch, eine Anregung oder
vielleicht eine Fehlermeldung haben, so kînnen Sie sich direkt an
mich wenden. Fehler werden sofort beseitigt, sinnvolle WÅnsche oder
Anregungen kînnen allerdings schon mal ein paar Tage dauern.

Auch bei Fragen bezÅglich der (!link [Registrierung] [SetKey]) kînnen Sie sich gerne an
mich wenden.

Erreichen kînnen Sie mich auf folgenden elektronischen Wegen:

Telefon  02651-900494

Maus     WI2
Internet Andreas_Pietsch@wi2.maus.de

oder aber per Snail-Mail:

Andreas Pietsch
Polcher Straûe 14-16
56727 Mayen, FRG

...und die Bankverbindung, wenn Sie Åberweisen wollen:

Kreissparkasse Mayen
KTO 100 060 466
BLZ 576 500 10

Da ich die Library so umfangreich und komfortabel wie mîglich
gestalten mîchte, sollten Sie sich also nicht scheuen, mir Ihre
WÅnsche mitzuteilen.


!ifndest [pch]
!node Thorsten Bergner

Das SysGem so ist, wie es ist, ist auch der Verdienst von einem
Berliner, der erst durch einen Mayener erfuhr, daû Berliner Berliner,
und nicht Krapfen oder Pfannkuchen (schauder...) heiûen, nÑmlich
Thorsten Bergner. Ihm gilt mein besonderer Dank, denn ohne ihn wÑre
in SysGem nur ein Zwanzigstel so viel einstellbar und auch so manch
andere Funktion wÑre nicht implementiert.

Mein besonderer Dank gilt ihm fÅr die Geduld, die er aufbringen
muûte, als ich als Mono-Besitzer die 3D-Farbroutinen entwickelte. Die
aufmunternden SÑtze wie "Du, ist die Linie da wirklich richtig?" oder
"Du, da fehlt aber noch ein Pixel..." klingen mir immer noch im
Ohr...

Desweiteren gilt ihm mein Dank, da er jeden Bug - egal, wie gut ich
ihn auch versteckt habe - aufgespÅhrt hat, so daû die Lib eigentlich
das PrÑdikat "Bug-Free" verdient hÑtte.

Was man mit SysGem (auch wenn sie nach Thorstens Meinung immer noch
zu groû ist) alles machen kann, hat er an einem kleinen Programm
verdeutlicht, welches das Leben eines jeden Programmierers enorm
erleichtet, nÑmlich


!image IMG384.IMG
klein, nett, wichtig, unentbehrlich, und mit SysGem geschrieben.
Schauen Sie doch einfach mal in (!xlink [SysInfo] [SYSINFO.HYP/Inhalt]) rein.
Es lohnt sich...

!endif

!ifndest [pch]

!node Danksagung

Ein Kapitel, daû in keiner Doku fehlen darf.

Mein Dank, daû SysGem das ist, was es ist, gehîrt folgenden:
!begin_itemize
   !item Mr. "Ist das auch konfigurierbar?" Thorsten Bergner

   !item (!link [Dirk Hagedorn] [Mausfunktionen])

   !item Roger Jordan

   !item Holger Weets

   !item Christoph Spengler (der immer noch auf die Pascal-Version
     wartet)

   !item Dirk Haun

   !item allen Usern von SysGem

   !item diejenigen, die mir gerade nicht einfallen und die ich deswegen
     nicht nennen kann... (Es muû ja schlieûlich einen Grund fÅr eine
     neue Version geben!)
!end_itemize

!endif

!ifndest [pch]

!node Tips & Trix

Im Laufe der Zeit haben sich ein paar Sachen angehÑuft, die in die
Kategorie "Tips und Tricks" fallen. Dabei sind es teilweise triviale
Dinge, die ganz einfach zu realisieren sind, wenn man weis, wie es
geht...

Hier mal ein paar Dinge, die immer wieder gefragt werden. Dabei wurde
aus den vielen, vielen Bewerbungen, hier doch mitspielen zu dÅrfen,
ein gewisser Thorsten Bergner ausgelost {Tusch!}. Er wird ein paar
Fragen stellen...
!begin_xlist [Thorsten:x]
 !item [Thorsten:] In der Beschreibung zu SysGem steht, daû ich die Fenster
           iconifizieren kann. Wie geht das? Ich habe keine Funktion
           gefunden.

 !item [Andreas:]  Nun ja, es gibt auch keine Funktion dafÅr. Dieses
           Åbernimmt SysGem von allein, ohne daû du dich darum
           kÅmmern muût. Die Handler-Funktion des Fensters erhÑlt
           lediglich eine Nachricht (SG_INVISIBLE), daû das Fenster
           fÅr eine Weile "Out Of Order" ist.

 !item [Thorsten:] Aha. Dann verhÑlt es sich beim Drag & Drop wohl genauso,
           oder? Da gibt es ja auch keine Funktion fÅr.

 !item [Andreas:]  Das ist korrekt. Auch das Drag & Drop wird komplett von
           SysGem Åbernommen. Das Protokoll von Mint ist in der
           Hinsicht leicht chaotisch, so daû ich es der Einfachheit
           halber direkt in die Lib mit eingebaut habe.

 !item [Thorsten:] Bei der Gelegenheit fÑllt mir noch was auf: Wenn ein Fen-
           ster iconifiziert ist, und ich dragge ein Objekt darauf,
           dann passiert nichts!

 !item [Andreas:]  Das ist so gewollt. Die Iconifizierung kann man ja mit dem
           Ausblenden unter Mag!X vergleichen; das Fenster ist nicht
           mehr da und der Benutzer kann ja innerhalb des Fensters
           nichts auswÑhlen. Aus diesem Grund wird dann ein D&D
           abgewiesen.

 !item [Thorsten:] Wie ja bekannt ist, kann ich unter (!xlink [ICFS] [ICFS.HYP/Titel]) mit gedrÅckter
           Control-Taste und einem Klick auf einen Closer alle Fen-
           ster iconifizieren lassen. Jetzt mîchte ich aber, daû ich
           alle Fenster auch wieder in den Normalzustand bekomme.
           Geht das?

 !item [Andreas:]  Logo. Einfach mit gedrÅckter Control-Taste ein
           Iconifiziertes Fenster anklicken. Dann werden alle anderen
           auch "zurÅckverwandelt".

 !item [Thorsten:] So einfach?

 !item [Andreas:]  It's not a trick, it's SysGem!

 !item [Thorsten:] Bei den Sliderboxen ist mir noch was aufgefallen: Es ist
           so mÅhsam, die Scrollelemente da so Pixelgenau zu
           positionieren. Geht das nicht einfacher?

 !item [Andreas:]  Doch. Du brauchst dich darum Åberhaupt nicht zu kÅmmern!
           SysGem setzt die Elemente von allein pixelgenau an die
           richtige Stelle und passt die Elemente natÅrlich auch an
           den 3D-Look an, sollte er vorhanden sein.

 !item [Thorsten:] Das ist ja toll. Und ich mach mir hier soviel Arbeit. Aber
           noch ein ganz anderes Problem: Wenn ich meine Dialoge in
           Interface zusammenbaue, kann ich mir das Ergebnis nicht
           ansehen, wenn ich dort "F9" tippe...

 !item [Andreas:]  Doch, das geht. Du muût nur das Programm EXTOBFIX.PRG, wel-
           ches sich im Archiv befindet, in den Interface-Ordner
           kopieren. Kann kannst du die Dialoge so sehen, wie SysGem
           sie spÑter auch im Programm darstellt.

 !item [Thorsten:] Auch nicht schlecht; nur noch ein paar Fragen, dann bin
           ich fertig. Ich habe hier einen normalen Timer mit
           SetProcTimer angemeldet und einen Fenstertimer mit
           SetWindowTimer. Es kommt aber kein Timer.

 !item [Andreas:]  Hast du die Funktion EnableTimer am Programmstart aufge-
           rufen?

 !item [Thorsten:] Oh. Nein, dann wird es wohl daran liegen.

 !item [Thorsten:] Kann ich eigentlich einen Timer abschalten, ohne die
           anderen zu beeinflussen?

 !item [Andreas:]  Ja, klar! Du muût die Zeit des Timers einfach nur auf 0
           stellen. Dann bleibt er "stehen" und wird von SysGem
           ignoriert.

 !item [Thorsten:] Na gut. Das war ja dann schon fast alles. Ich hab mich
           jetzt fÅr diese absolut lÑcherliche Summe von 40 DM
           registrieren lassen und nun? Wie bekomme ich jetzt eine
           registrierte Fassung von SysGem? Was mache ich mit dem
           SchlÅssel?

 !item [Andreas:]  Lies einfach noch mal unter SetKey nach.

 !item [Thorsten:] Aha. Na gut, wer die Doku liest, ist also klar im Vorteil.
           im Moment habe ich dann keine Probleme mehr. Wenn es jetzt
           eine neue Version gibt, wie bekomme ich das denn raus? Und
           wie kann ich an eine neue Version kommen?

 !item [Andreas:]  Ganz einfach. Zum ersten wird jede neue Version im MAUS-
           Netz bekanntgegeben und die neueste Version liegt immer in
           der WI2 unter dem Namen "SGEM???*.LZH", wobei die '?' fÅr
           die Versionsnummer stehen und das '*' ein C oder P sein
           kann, je nachdem, ob es sich um die Version fÅr C oder
           Pascal handelt. Wenn du nicht in der Maus bist, kannst du
           mich ja ab und zu mal einfach anrufen und fragen. Und dann
           gibt es auch zwei Mîglichkeiten. Entweder Åbertragen wir
           die neue Version via Modem oder du schickst mir einfach
           eine Diskette und RÅckporto.

 !item [Thorsten:] So einfach, ja? Das ist ja toll. Also gut, das waren schon
           meine Fragen, bis dann mal wieder!
!end_xlist
...beide verlassen die BÅhne, ein tobender Applaus setzt ein; beide
kommen nochmals auf die BÅhne, verneigen sich, eine Standing- Ovation
folgt, das Publikum tobt, beide verlassen wieder die BÅhne und man
kann leise hîren: "Pizza?". "Klar man, was sonst..."

!endif

!end_appendix

!end_document
