
 0. INHALT:
============

 I.   Allgemeine Hinweise

        1.  öbersetzung der Library mit Pure C, GNU-C und Lattice C
              a. Pure C
              b. GNU-C/Lattice C
        2.  Nutzung der Library mit Pure C, GNU-C und Lattice C

 II.  Neue Mîglichkeiten in Eingabefeldern

 III. erweiterte Objekt-Typen sowie Resource-Aufbau

        1.  Debugging
        2.  Highbyte des Objekt-Typs

 IV.  Globale Variablen der Library

 V.   Funktionen, Strukturen und Konstanten der Library

        1.  Routinen zur Verwaltung des Cookie-Jars
        2.  Routinen zur Verwaltung des Environments
        3.  Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        4.  Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
        5.  VDI-Attribut- und Clipping-Funktionen
        6.  Erweiterte Scrap-Directory-Routinen
        7.  Erweiterte Grafik-Routinen
        8.  MenÅ-Funktionen
        9.  Dialog-Optionen und -optik setzen
        10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        11. Resource- und Objekt-Initialisierung
        12. Ereignis-Auswertung
        13. Dialog-Funktionen
        14. Fenster-Funktionen
        15. Popup-Funktion
        16. XAcc-2- und AV-Protokoll-Funktionen
        17. Drag & Drop-Funktionen
        18. Auskunftsfunktionen
        19. Datei-/Pfadfunktionen
        20. Verschiedene Funktionen
        21. Definitionen hÑufig benîtigter (Protokoll-) Konstanten


 I. Allgemeine Hinweise:
=========================

 1. öbersetzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    WICHTIG:
    Bei der öbersetzung der Library darf keine Stack-öberprÅfung aktiviert
    sein, da einige Library-Funktionen (z.B. benutzerdefinierte Objekte) vom
    AES aufgerufen werden und somit den AES-Stack verwenden.

    Light-Version:
    --------------
    Wird die Library mit definiertem Konstanten-Makro 'SMALL_EGEM' (s.a.
    Projekt-Datei 'EGEMLGHT.PRJ' bzw. 'EGEMMNTL.PRJ') Åbersetzt, so sind
    keine Eingaben in Dialogen (Edit-Felder) mîglich und die Funktionen
    ob_clear_edit() sowie ascii_box() stehen nicht zur VerfÅgung. Auûer-
    dem sind bei den erweiterten Objekttypen weniger Images vorhanden.
    Sinn und Zweck ist, daû dadurch der Overhead durch die Library geringer
    wird (u.a. bei Programmen, die z.B. nur erweiterte Alertboxen nutzen)

    a. Pure C

    EnhancedGEM lÑût sich sowohl mit den Pure-C-Libraries als auch mit den
    MiNT-Libraries ab Patchlevel 30 compilieren.
    Hierzu muû jedoch im Header-File AESBIND.H der MiNT-Libraries die Zeile

    __EXTERN int    evnt_timer __PROTO((unsigned long Interval));

    in

    __EXTERN int    evnt_timer __PROTO((int Int_locount,int Int_hicount));

    geÑndert werden.
    Weiterhin muû das Makro __MINT_LIB__ definiert werden (s. E_GEMMNT.PRJ)

    b. GNU-C/Lattice C

    Ebenfalls lÑût sich EnhancedGEM mit GNU-C und Lattice C Åbersetzen,
    wobei allerdings die MiNT-Library sowie die entsprechenden Makefiles
    (Makefile.GCC bzw. Makefile.LCC) benutzt werden mÅssen. Eventuell auf-
    tretende Warnungen bei der öbersetzung sind (hoffentlich) bedeutungslos.

 2. Nutzung der Library mit Pure C, GNU-C und Lattice C
    -------------------------------------------------------

    a. Wurde EnhancedGEM mit Hilfe der MiNT-Libraries Åbersetzt, so MöSSEN
    die MiNT-Libraries und die dazugehîrigen Header-Dateien auch benutzt wer-
    den. Ansonsten sind die Reaktionen nicht vorhersehbar, aber hîchstwahr-
    scheinlich resultieren daraus Fehlfunktionen (auûer evtl. bei GNU-C).

    b. Die Funktionen evnt_multi, EvntMulti (Pure C) sowie evnt_mesag des
    AES sollten nicht mehr benutzt werden! Stattdessen sollte immer die
    Funktion Event_Multi benutzt werden! Weitere Details zur Ereignisver-
    arbeitung s. Funktionen Event_Multi() und Event_Handler().

    c. Alle internen, modulÅbergreifenden globalen Variablen und Funktionen
    der Library beginnen mit einem Unterstrich '_', so daû es zu keinen
    öberschneidungen kommen sollte.

 II. Neue Mîglichkeiten in Eingabefeldern:
===========================================

    - zusÑtzliche GÅltigkeitsmasken:
        'c','C': Ziffern "0-9", Komma ".,", Rechenzeichen "+-*/^",
                 Klammern "(){}[]"
        'l','L': LED-Ziffern "0-9"
        '<Ziffer>': Ziffer='0'-'9', alle Ziffern von '0' bis <Ziffer>, z.B.
                 '1': BinÑrziffern '01'
                 '7': Oktalziffernn '01234567'
                 '9': Dezimalziffern '0123456789'
        'h','H': Hexadezimalziffern "0-9A-F",
                 Umwandlung in Klein/Groûbuchstaben
        'u','U': ASCII 32-127, Umwandlung in Klein-/Groûbuchstaben
        'v','V': ASCII 32-255, Umwandlung in Klein-/Groûbuchstaben
        'w','W': ASCII 32-127
        'y','Y': ASCII 32-255

    - kleiner/groûer System-Font kînnen in Eingabefeldern benutzt
      werden. UnterstÅtzt das AES auch nicht-proportionale GDOS-Fonts,
      so kînnen diese ebenfalls in Eingabefeldern verwendet werden.

    - ein Eingabefeld darf maximal MAX_EDIT-Zeichen lang werden (ansonsten
      muû die Konstante bei Bedarf in der Datei 'E_GEM.H' geÑndert und die
      Library neu Åbersetzt werden)

    - Eingabefelder dÅrfen einen Klammeraffen '@' am Anfang besitzen

 III. erweiterte Objekt-Typen sowie Resource-Aufbau:
=====================================================

    1. Debugging:
    -------------

    Wird die Library mit definiertem Konstanten-Makro 'DEBUG' (s.a.
    Projekt-Datei 'E_GEM.PRJ' bzw. 'E_GEMMNT.PRJ') Åbersetzt, so gibt die
    Library Fehlermeldungen (Alert-Boxen) aus, wenn Fehler im Resource-
    Aufbau gefunden wurden (z.B. doppelt vergebene Hotkeys, mehr als ein
    Help-/Undo-/Default-Button usw.). Dabei werden die Art des Fehlers und
    die Nummer des fehlerhaften Objekts ausgegeben.

    2. Highbyte des Objekt-Typs (s.a. STARTUP.RSC):
    -----------------------------------------------

        TriState-Checkboxen:
        --------------------

        Ist das Flag TOUCHEXIT bei einer Checkbox gesetzt, so kann die
        Checkbox noch einen dritten Zustand (neben selektiert und nicht
        selektiert) annehmen, bei dem das Innere der Checkbox mit einem
        grauen Muster gezeichnet wird. In diesem Zustand ist der Status
        CHECKED gesetzt.

        #define CHECKBOX        1   /* Check-Box */
        #define HEADER          2   /* öberschrift */
        #define RADIO           3   /* Radio-Button */
        #define UNDERLINE       4   /* Unterstrich */
        #define HOTKEY          5   /* Hotkey-Objekt */
        #define CHKHOTKEY       6   /* Check-Box mit Hotkey */
        #define RBHOTKEY        7   /* Radio-Button mit Hotkey */
        #define INDHOTKEY       8   /* Hotkey-Objekt einer Check-Box oder
                                       eines Radio-Buttons */
        #define FLYDIAL         9   /* Flugecke */
        #define TXTDEFAULT      10  /* Status des DEFAULT-Objekts ist von
                                       diesem Text-Objekt abhÑngig */
        #define USERFLY         11  /* beliebiges Flugobjekt */
        #define HELP_BTN        12  /* Help-Button */

        GDOS-Fonts:
        -----------

        Der erweiterte Objekttyp 'ATTR_TEXT' unterstÅtzt auch die Ausgabe
        von beliebigen, u.a. proportinalen GDOS-Fonts unabhÑngig vom
        AES! Dabei mÅssen die Felder 'te_fontid', 'te_fontsize' der
        TEDINFO-Struktur auf die ID und die Grîûe in Punkt des Fonts ge-
        setzt werden. Auûerdem muû das Feld 'te_font' auf eine der fol-
        genden Konstanten gesetzt werden:

             #define GDOS_PROP    0 /* Speedo GDOS font */
             #define GDOS_MONO    1 /* Speedo GDOS font, monospace */
             #define GDOS_BITM    2 /* GDOS bit map font */

        Nach dem Initialisieren der Objekte durch fix_objects(), rsrc_calc()
        oder rsrc_init() ist der Objekttyp auf 'G_XTEXT' gesetzt und die
        Variable 'ob_spec' der OBJECT-Struktur zeigt auf einen benutzer-
        definierten Block USERBLK, dessen Parameter 'ub_parm' auf folgende
        Struktur zeigt, welche mit den Werten aus der Resource-Datei initia-
        lisiert ist (ein evtl. vorhandenes EDITABLE-Flag wird gelîscht!):

        X_TEXT-Struktur:
        ----------------

        typedef struct
        {
            /* Zeiger auf Text (sollte nur mit ob_get_text()/ob_set_text()
               gesetzt oder ermittelt werden) */
            char    *string;

            /* Font-ID, -hîhe (<0: in Punkt, >0: in Pixel) */
            int     font_id,font_size;

            /* Farbe (0-15, kann nachtrÑglich auf beliebige VDI-Farbe
               gesetzt werden) */
            int     color;

            /* Zentrierung des Textes (TE_LEFT,TE_CNTR,TE_RIGHT) */
            int     center;

            /* Schreibmodus (MD_REPLACE,MD_TRANS,MD_XOR,MD_ERASE) */
            int     mode;

            /* Alle weiteren Variablen dieser Struktur sind fÅr interne
               Zwecke reserviert! */
        } X_TEXT;

        #define ATTR_TEXT       13  /* Text mit Attributen */

        #define CYCLE_BUTTON    14  /* Cycle-Button */
        #define ARROW_LEFT      15  /* Pfeil links */
        #define ARROW_RIGHT     16  /* Pfeil rechts */
        #define ARROW_UP        17  /* Pfeil hoch */
        #define ARROW_DOWN      18  /* Pfeil runter */
        #define UNDO_BTN        19  /* Undo-Button */

    Jedem Objekt kînnen die erweiterten Typen UNDO_BTN, HELP_BTN, HEADER
    und USERFLY zugeordnet werden. Bei ATTR_TEXT sowie TXTDEFAULT muû
    es sich um ein Text-Objekt (auch G_STRING), bei UNDERLINE sollte es
    sich um den Typ G_BOX handeln. Alle anderen erweiterten Typen
    sollten (mÅssen aber nicht) dem Typ G_BOXCHAR zugeordnet werden.

        #define G_UNMODAL   0x4000  /* unmodales Objekt */
        #define G_MODAL     0x8000  /* modales Objekt */

    ZusÑtzlich kînnen alle (!) Objekte durch Setzen von Bit 14 (G_UNMODAL)
    bzw. Bit 15 (G_MODAL) im Objekt-Typ (erweiterter Objekttyp mit 64 bzw.
    128 verodern) zu einem unmodalen oder modalen Objekt deklariert werden,
    welches nur in unmodalen bzw. modalen Dialogen erscheint.

    WICHTIG:
    --------
    Will man den Objekttyp ermitteln, so sollte man die Variable 'ob_type'
    der OBJECT-Struktur mit der Konstante G_TYPE maskieren!

    Nach dem Initialisieren der Resource durch die Library werden der
    Objekttyp und teilweise das obere Byte des Objektstatus der erweiterten
    Objekte verÑndert. Ebenso zeigt 'ob_spec' meistens auf den USERBLK des
    Objekts. Daher sollte man auf diese Variablen nicht mehr zugreifen,
    sofern die énderungen nicht dokumentiert sind (wie z.B. bei ATTR_TEXT)

    Weitere (Kombinations-) Mîglichkeiten s.a. Beispielprogramm sowie
    Startup-Resource (STARTUP.RSC).

    WICHTIG:
    --------
    Werden die Funktionen rsrc_calc() oder rsrc_init() mit der Grîûe des
    Entwurfsfonts aufgerufen, so SOLLTEN nur Pull-Down-MenÅs G_TITLE-
    Objekte enthalten. Ansonsten wird der Dialog normal vom AES an die
    Grîûe des System-Fonts skaliert.

 IV. Globale Variablen der Library:
====================================

    int _app;
        -> Programm wurde als Applikation (_app!=0) oder Accessory (_app==0)
           gestartet

    int ap_id:
        -> Applikationsidentifikation (RÅckgabewert von appl_init())
           oder negativer Wert, wenn AES-Initialisierung nicht erfolg-
           reich war

    int menu_id:
        -> Nummer des Eintrags im Accessory-MenÅ oder negativer Wert

    int grhandle:
        -> Handle der AES-Workstation (RÅckgabewert von graf_handle)

    int x_handle:
        -> Handle der Library-Workstation

    int gr_cw,gr_ch:
        -> Breite/Hîhe des System-Zeichensatzes (IBM) in Pixel

    int gr_bw,gr_bh:
        -> Breite/Hîhe eines Rechtecks, das jedes einzelne Zeichen
           des System-Zeichensatzes (IBM) vollstÑndig umgibt.

    int gr_sw,gr_sh:
        -> Breite/Hîhe des kleinen System-Zeichensatzes (SMALL) in Pixel

    int ibm_font,ibm_font_id;
        -> Hîhe des System-Zeichensatzes (IBM) in Punkt sowie Font-ID

    int small_font,small_font_id;
        -> Hîhe des kleinen System-Zeichensatzes (SMALL) in Punkt
           sowie Font-ID

    int fonts_loaded;
        -> GDOS-Fonts wurden geladen (werden die GDOS-Fonts von der
           Anwendung geladen, so muû diese Variable auf einen Wert un-
           gleich Null gesetzt oder die Fonts selbstÑndig entfernt werden)

    int max_w,max_h:
        -> Breite/Hîhe des Bildschirms in Pixel

    int planes, colors:
        -> Anzahl der Farbebenen sowie gleichzeitig darstellbaren
           Farben

    int colors_available;
        -> Anzahl der Farbabstufungen der Farbpalette
           (2: monochrom, 0: mehr als 32767 Farben)

    MFDB *screen;
        -> Memory Form Definition Block des Bildschirms

    GRECT desk;
    VRECT clip;
        -> Ausmaûe des Desktop-Fensters als GRECT bzw. VRECT

    int aes_version:
        -> AES-Versionsnummer

    int magx:
        -> Versionsnummer von MagiC ab Version 2.00

    int winx:
        -> Versionsnummer von Winx ab Version 2.10

    int mint:
        -> MiNT-Versionsnummer

    int multi:
        -> AES-Multitasking-Betriebssystem vorhanden

    int search:
        -> appl_search()-Funktion vorhanden

    int AvServer;
        -> Applikations-ID des AV-Protokoll-Servers oder negativer Wert

    int menu_available;
        -> Anwendung darf eigene Drop-Down-MenÅleiste anmelden
           (menu_available!=0)

    OBJECT *iconified;
        -> Zeiger auf Objektbaum, der fÅr die Darstellung von ikonifizierten
           Fenstern benutzt wird (ansonsten weiûer Hintergrund des Fensters,
           falls Zeiger nicht gesetzt wurde)

 V. Funktionen, Strukturen und Konstanten der Library:
=======================================================

    1. Routinen zur Verwaltung des Cookie-Jars
       ---------------------------------------

        COOKIE-Struktur:
        ----------------
            typedef struct
            {
                long    cookie_id;      /* ID des Cookies */
                long    cookie_value;   /* Wert des Cookies */
            } COOKIE;

        void create_cookie(COOKIE *cookie,long id,long value);
            -> Cookie 'cookie' wird mit der Identifikation 'id' und
               dem Wert 'value' initialisiert

        boolean new_cookie(COOKIE *cookie);
            -> Cookie 'cookie' in Cookie-Jar einfÅgen (RÅckgabewert
               gleich FALSE, falls Cookie-Jar nicht existiert oder
               keine freien EintrÑge mehr vorhanden sind)

        boolean get_cookie(long id,long *value);
            -> Cookie mit der Identifikation 'id' im Cookie-Jar suchen
               und Wert gegebenenfalls in der Variable '*value' sichern
               (sofern value!=NULL)
            -> RÅckgabewert ungleich FALSE, wenn Cookie gefunden wurde

        void remove_cookie(long id);
            -> Cookie mit der Identifikation 'id' aus dem Cookie-Jar
               entfernen

        void move_cookiejar(long *new_cookie_jar,long size);
            -> neuen Cookie-Jar 'new_cookie_jar' mit Platz fÅr 'size'
               EintrÑge anlegen und alten Cookie-Jar gegebenfalls
               kopieren
            -> neuer Cookie-Jar muû mindestens so viele EintrÑge wie
               der alte Cookie-Jar haben

        long cookie_size(void);
            -> Anzahl der maximalen EintrÑge im Cookie-Jar ermitteln

    2. Routinen zur Verwaltung des Environments
       ----------------------------------------

        char *getenv(const char *entry);
            -> Variable 'entry' im Environment suchen und im Erfolgsfall
               Zeiger auf Wert der Variable zurÅckgeben (ansonsten NULL)

        int putenv(const char *entry);
            -> Zeichenkette 'entry' ins Environment einfÅgen
            -> RÅckgabewert ungleich Null im Erfolgsfall

    3. Erweiterte Objekt-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -----------------------------------------------------------

        void ob_dostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undostate(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' des Objektstatus des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isstate(OBJECT *tree,int object,int masc);
            -> Bits 'masc' im Objektstatus des Objekts 'object' im Baum
               'tree' testen
            -> RÅckgabewert:
               TRUE (1):  alle Bits gesetzt
               FALSE (0): Bits (teilweise) nicht gesetzt

        void ob_setstate(OBJECT *tree,int object,int state);
            -> Objektstatus des Objekts 'object' im Baum 'tree' auf den
               Wert 'state' setzen

        void ob_select(DIAINFO *info,OBJECT *tree,int object,int select,
                       int draw)
            -> Objekt 'object' im Baum 'tree' in AbhÑngigkeit des
               Parameters 'select' (de-) selektieren und evtl. neuzeichnen
               (draw!=0). Gehîrt der Objektbaum zu einem geîffneten Dialog,
               so sollte ein Zeiger auf die DIAINFO-Struktur des Dialogs
               Åbergeben werden, damit gegebenenfalls der Ausgabebereich
               korrekt berechnet werden kann.
            -> Bedeutung des Parameters 'select':

                   /* Status setzen (=selektieren) */
                   #define SET_STATE    1

                   /* Status lîschen (=deselektieren) */
                   #define CLEAR_STATE  0

                   /* Status invertieren */
                   #define FLIP_STATE   -1

        void ob_disable(DIAINFO *info,OBJECT *tree,int object,int disable,
                       int draw)
            -> Objekt 'object' im Baum 'tree' in AbhÑngigkeit des
               Parameters 'disable' dis-/enablen und evtl. neuzeichnen
               (draw!=0). Parameter und Aufruf s. Funktion ob_select()

        void ob_doflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Veroderung setzen

        void ob_undoflag(OBJECT *tree,int object,int masc);
            -> einzelne Bits 'masc' der Objektflags des Objekts 'object'
               im Baum 'tree' durch Maskierung lîschen

        int ob_isflag(OBJECT *tree,int object,int masc);
            -> Bits 'masc' der Objektflags des Objekts 'object' im Baum
               'tree' testen
            -> RÅckgabewert:
               TRUE (1):  alle Bits gesetzt
               FALSE (0): Bits (teilweise) nicht gesetzt

        void ob_setflags(OBJECT *tree,int object,int flags);
            -> Objektflags des Objekts 'object' im Baum 'tree' auf den
               Wert 'flags' setzen

        void ob_xywh(OBJECT *tree,int object,GRECT *rect);
            -> Ausmaûe und Koordinaten (relativ zur linken oberen Ecke
               des Åbergeordneten Objekts) des Objekts 'object' im Baum
               'tree' ermitteln und in der GRECT-Struktur 'rect' sichern

        char *ob_get_text(OBJECT *tree,int object,int clear);
            -> Zeiger auf den Text des Objekts 'object' im Baum 'tree'
               ermitteln und Text lîschen, sofern 'clear' ungleich Null
               (Funktion beachtet erweiterte Objekttypen (Attribut-Text))
            -> RÅckgabewert gleich NULL, wenn es sich um kein Text-Objekt
               handelt

        void ob_set_text(OBJECT *tree,int object,char *text);
            -> Text des Objekts 'object' im Baum 'tree' auf 'text' setzen
               (Funktion beachtet erweiterte Objekttypen (Attribut-Text))

        void ob_clear_edit(OBJECT *tree)
            -> Text in allen Eingabefeldern des Baums 'tree' lîschen
               (Funktion nur verfÅgbar, wenn Library nicht als Light-
                Version Åbersetzt wurde)

        int ob_set_hotkey(OBJECT *tree,int object,char hotkey);
            -> Hotkey des Objekts 'object' im Baum 'tree' auf den
               Buchstaben 'hotkey' setzen (Hotkey-Unterstrich wird
               automatisch angepaût)
            -> RÅckgabewert ungleich FALSE -> Hotkey konnte gesetzt werden

        char ob_get_hotkey(OBJECT *tree,int object);
            -> Hotkey des Objekts 'object' im Baum 'tree' ermitteln
            -> RÅckgabewert gleich Null, wenn kein Hotkey gesetzt war

        int ob_draw_chg(DIAINFO *info,int object,GRECT *area,
                         int new_state,boolean top);
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen und gegebenenfalls Objektstatus Ñndern
               (new_state>=0, s. objc_change)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Ist der Dialog 'info' der oberste Dialog bzw. im obersten
               Fenster, so kann die Ausgabe durch Setzen des Parameters
               'top' auf einen Wert ungleich Null beschleunigt werden
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekt konnte nicht ausgegeben werden
                FAIL:  Objekt-Status konnte nicht gesetzt werden

        int ob_draw(DIAINFO *info,int object)
            -> Objekt 'object' (und untergeordnete Objekte) des Dialogs
               'info' darstellen (verkÅrzter Aufruf von
               ob_draw_chg(info,object,NULL,FAIL,FALSE))

        int ob_draw_list(DIAINFO *info,int *objects,GRECT *area);
            -> Liste von Objekten 'objects' (und untergeordnete Objekte)
               des Dialogs 'info' darstellen (Abbruch der Liste mit
               negativem Wert oder Null)
            -> Begrenzung des Ausgabebereichs auf das Reckteck 'area' oder
               auf die Ausmaûe des Dialogs (area==NULL)
            -> Diese Funktion ist schneller als die einzelne Ausgabe
               von mehreren Objekten Åber ob_draw_chg()
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Objekte konnten nicht ausgegeben werden

        void ob_draw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Dialog 'tree' zentrieren, Bildschirmbereich reservieren,
               eine sich îffnende Box von der Dialogmitte zu den
               Koordinaten (x,y,w,h) zeichnen (sofern Parameter x,y,w,h
               grîûer als Null sind) und Dialog darstellen

        void ob_undraw_dialog(OBJECT *tree,int x,int y,int w,int h);
            -> Eine sich schlieûende Box von den Koordinaten (x,y,w,h) zur
               Dialogmitte zeichnen (sofern Parameter x,y,w,h grîûer als
               Null sind) und Bildschirmbereich freigeben

        int ob_radio(OBJECT *tree,int parent,int object)
            -> Radio-Buttons innerhalb des Åbergeordneten Objekts 'parent'
               im Baum 'tree' auf neues Objekt 'object' (Index des
               Radio-Buttons, nicht Objekt-Nummer!) setzen bzw.
               aktuell gesetztes Objekt ermitteln (object<0)
            -> RÅckgabewert: Gesetztes Objekt

        int ob_get_parent(OBJECT *tree,int object);
            -> Elternobjekt des Objekts 'object' im Baum 'tree' ermitteln

    4. Erweiterte Rechteck-Routinen (u.a. kompatibel zum PC-GEM 2.0)
       -------------------------------------------------------------

        void rc_grect_to_array(GRECT *rect,int *array);
            -> Reckteck 'rect' in Koordinaten-Feld 'array' wandeln

        void rc_array_to_grect(int *array,GRECT *rect);
            -> Koordianten-Feld 'array' in Rechteck 'rect' wandeln

        int rc_copy(GRECT *src,GRECT *dst);
            -> Rechteck 'src' nach Rechteck 'dst' kopieren
            -> RÅckgabewert ist immer Null

        int rc_equal(GRECT *rect1,GRECT *rect1);
            -> Testet die Rechtecke 'rect1' und 'rect2' auf Gleichheit
               (RÅckgabewert ungleich Null)

        int rc_intersect(GRECT *src,GRECT *dst);
            -> schneidet das Rechteck 'src' mit dem Rechteck 'dst'
               und gibt den gemeinsamen Bereich in 'dst' zurÅck
            -> RÅckgabewert gleich Null, sofern die Rechtecke keinen
               gemeinsamen Bereich besitzen

        int rc_inside(int x,int y,GRECT *rect);
            -> Testet, ob die Koordinaten (x,y) im Rechteck 'rect'
               liegen (RÅckgabewert ungleich Null)

        WICHTIG:
        Alle rc_sc_()-Funktionen schalten weder die Maus an/aus noch
        setzen sie den wind_update()-Status!

        RC_RECT-Struktur:
        -----------------

        typedef struct
        {
            /* Rechteck-Struktur gÅltig? (valid!=0) */
            int valid;

            /* Koordinaten des ursprÅnglichen Bildschirmrechtecks */
            GRECT   area;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } RC_RECT;

        int rc_sc_save(GRECT *area,RC_RECT *rc)
            -> Bildschirmbereich 'area' in Rechteck-Struktur 'rc' sichern
            -> RÅckgabewert: (entsprechend rc->valid)
                TRUE:  Bereich konnte gesichert werden
                FALSE: Nicht genÅgend Speicher oder Bereich teilweise
                       auûerhalb des Bildschirms

        int rc_sc_freshen(int sx,int sy,RC_RECT *rc)
            -> Rechteck-Struktur 'rc' erneuern, d.h. Bildschirmbereich
               an den Koordinaten (sx,sy) in Puffer kopieren
            -> RÅckgabewert:
                TRUE:  Bereich konnte gesichert werden
                FALSE: Rechteck-Struktur nicht gÅltig oder Bereich
                       teilweise auûerhalb des Bildschirms

        int rc_sc_restore(int dx,int dy,RC_RECT *rc,int mode)
            -> Rechteck-Struktur 'rc' freigeben und/oder an Position
               (dx,dy) zurÅckkopieren
            -> Parameter 'mode':
                TRUE:  Bereich zurÅckkopieren und Speicher freigeben
                FALSE: Bereich nur zurÅckkopieren
                FAIL:  Nur Speicher freigeben
            -> RÅckgabewert:
                TRUE:  Alles in Ordnung
                FALSE: Rechteck-Struktur ungÅltig

        void rc_sc_copy(GRECT *src,int x,int y,int mode);
            -> Kopiert den Bildschirmbereich 'src' zu den Koordinaten
               (x,y) (Kopiermodus 'mode' s. vro_cpyfm)

        void rc_sc_clear(GRECT *rect);
            -> Lîscht den Bildschirmbereich 'rect'

        void rc_sc_invert(GRECT *rect);
            -> Invertiert den Bildschirmbereich 'rect'

        int rc_sc_scroll(GRECT *in_out,int dist_x,int dist_y,GRECT *out2)
            -> Rechteck 'in_out' um Distanz (dist_x,dist_y) verschieben
               und neuzuzeichnende Rechtecke in 'in_out' und 'out2'
               zurÅckgeben. Dabei wird automatisch der Bereich auf den
               Bildschirm beschrÑnkt. (diese Funktion ist die Grundlage
               der Funktion scroll_window())
            -> RÅckgabewerte:
               0 - kein Redraw nîtig
               1 - Rechteck 'in_out' muû neugezeichnet werden
               2 - Rechteche 'in_out' und 'out2' mÅssen neugezeichnet
                   werden (nur bei diagonalem Scrolling)

    5. VDI-Attribut- und Clipping-Funktionen
       -------------------------------------

        Hinweis:
        --------
        Das Clipping der internen Workstation ist normalerweise auf das
        Desktopfenster oder wÑhrend eines Redraws auf Bereiche der
        Rechteckliste eines Fensters gesetzt. GrundsÑtzlich ist der
        Ausgabebereich aber INNERHALB des Bildschirms!

        void vsf_aespattern(int handle, int x, int y, int pattern)
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               Workstation 'handle' setzen

        void vs_attr(void);
            -> wurden die Attribute der internen VDI-Workstation x_handle
               nicht Åber Library-Funktionen verÑndert, so muû diese
               Funktion sofort danach aufgerufen werden, um dies der Library
               kenntlich zu machen

        void v_set_text(int font,int height,int color,int out[4])
            -> VDI-Text-Attribute der internen Workstation x_handle setzen:
               font:    Font-ID
               height:  Hîhe in Pixel (>0) oder in Punkt (<0)
               color:   Text-Farbe
               out:     Array fÅr RÅckgabewerte von vst_height/vst_point
                        oder NULL

        void v_set_mode(int mode);
            -> Grafikmodus der internen Workstation x_handle auf
               den Wert 'mode' (0-3) setzen

        void v_set_line(int color,int width);
            -> VDI-Linien-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color: Linien-Farbe
               width: Linien-Dicke

        void v_set_fill(int color,int interior,int style);
            -> VDI-FÅllmuster-Attribute der internen Workstation
               x_handle setzen: (neg. Wert -> keine VerÑnderung)
               color:        FÅllmuster-Farbe
               vsf_interior: FÅllmuster-Typ (0-4)
               vsf_style:    FÅllmuster-Stil

        void v_aespattern(int x,int y,int pattern);
            -> an die Koordinaten (x,y) angepaûtes AES-FÅllmuster
               'pattern' (0-7) berechnen und als neues FÅllmuster der
               internen Workstation x_handle setzen

        void save_clipping(int *array);
            -> aktuellen Clipping-Bereich im Koordinaten-Feld 'array'
               sichern

        void restore_clipping(int *array);
            -> Clipping-Bereich auf Koordinaten-Feld 'array' setzen

        HINWEIS:
        Wird die interne VDI-Workstation benutzt, so muû sichergestellt
        sein, daû entweder Library-Funktionen benutzt oder die Attribute
        in ihren ursprÅnglichen Zustand zurÅckgesetzt werden.
        Ist dies nicht der Fall, muû sofort nach VerÑnderung der Attribute
        die Funktion vs_attr() aufgerufen werden. Allerdings darf auf keinen
        Fall der Clipping-Bereich verÑndert werden, d.h. er ist mit
        save_clipping()/restore_clipping wiederherzustellen.

    6. Erweiterte Scrap-Directory-Routinen
       -----------------------------------

        int scrp_path(char *path,char *file)
            -> vollstÑndigen Zugriffspfad der Clipboard-Datei 'file'
               (sofern file!=NULL) ermitteln. Wird fÅr den Parameter 'file'
               NULL Åbergeben, so wird nur der Clipboard-Pfad ermittelt.
            -> RÅckgabewert:
               TRUE:  Alles in Ordnung
               FALSE: Kein Clipboard-Pfad gesetzt

        void scrp_clear(int all);
            -> Alle Dateien (all!=0) oder nur die 'SCRAP.*'-Dateien
               im Scrap-Directory lîschen

        long scrp_length(void);
            -> Berechnung der LÑnge des Inhalts des Scrap-Directories

        int scrp_find(char *extensions,char *filename);
            -> Scrap-Directory (Clipboard) nach Scrap-Datei mit einer
               der durch Komma, Punkt oder Leerzeichen getrennten
               Erweiterungen 'extensions' durchsuchen, z.B.
               scrp_find("img.txt.asc.ps",scrap). Dabei wird die Liste
               von links nach rechts abgearbeitet.
            -> String 'filename' enthÑlt im Erfolgsfall (RÅckgabewert
               ungleich Null) den kompletten Pfad der gefundenen Datei

        void scrp_changed(int format,long best_ext);
            -> Clipboard-Inhalt wurde verÑndert (SC_CHANGED-Nachricht
               wird (per XAccBroadCast) an alle Applikationen sowie
               AV_PATH_UPDATE an den AV-Server gesendet), wobei nach
               dem Lîschen des Clipboards scrp_changed(SCF_INDEF,0l)
               aufgerufen werden sollte.
            -> format: Bitmap des Dateiformats

            #define SCF_INDEF   0x0000  /* undefiniert */
            #define SCF_DBASE   0x0001  /* Datenbank */
            #define SCF_TEXT    0x0002  /* Text */
            #define SCF_VECTOR  0x0004  /* Vektor-Grafik */
            #define SCF_RASTER  0x0008  /* Raster-Grafik */
            #define SCF_SHEET   0x0010  /* Tabellen-Kalkulation */
            #define SCF_SOUND   0x0020  /* Sound */

            -> best_ext: 4 Zeichen (z.B. ".RTF") fÅr die "beste" der
                         abgespeicherten Dateien

    7. Erweiterte Grafik-Routinen
       --------------------------

        void graf_busy_mouse(void);
            -> Maus als rotierende Scheibe darstellen

        void graf_set_slider(SLINFO *slider,OBJECT *tree,int mode);
            -> Elemente des Sliders 'slider' im Baum 'tree'
               anhand der Werte der SLINFO-Struktur initialisieren und
               gegebenenfalls neuzeichnen
            -> mode: Bitmap der Initialisierung

            #define GRAF_SET_ARROWS     1
                -> Slider-Pfeile setzen
            #define GRAF_SET_SIZE_POS   2
                -> Grîûe/Position des Schiebers berechnen und setzen
            #define GRAF_SET            3
                -> wie GRAF_SET_ARROWS und GRAF_SET_SIZE_POS
            #define GRAF_DRAW_SLIDER    4
                -> Slider-Elemente zeichnen
            #define GRAF_DRAW           7
                -> wie GRAF_SET und GRAF_DRAW_SLIDER

        void graf_arrows(SLINFO *slider,OBJECT *tree,int draw);
            -> Pfeile des Sliders 'slider' im Baum 'tree' initialisieren
               und gegebenenfalls neuzeichnen (draw!=0)

        void graf_rt_slidebox(SLINFO *slider,int object,int double_click);
            -> Echtzeitslider auswerten und darstellen (diese Routine wird
               intern automatisch aufgerufen, wenn die SLINFO-Strukturen
               bei open_dialog() Åbergeben wurden)
            -> Parameter:
                slider: Zeiger auf SLINFO-Struktur des Sliders

                #define HOR_SLIDER      0   /* horizontaler Slider */
                #define VERT_SLIDER     1   /* vertikaler Slider */

                #define SL_STEP         0   /* Einzelschritt */
                #define SL_LINEAR       1   /* linear */
                #define SL_LOG          2   /* logarithmisch */
                #define SL_EXP          3   /* exponential */

                typedef struct
                {
                    /* Scan-Code des Ereignisses (Highbyte: Scan-Code,
                       Low-Byte: ASCII-Code oder Null) */
                    int     scan;

                    /* Sondertastenstatus */
                    int     state;

                    /* Slider-Kommando (s. Beschreibung des
                       Parameters 'object')
                    int     cmd;
                } SLKEY;

                typedef struct
                {
                    /* Zeiger auf DIAINFO-Struktur des Dialogs */
                    DIAINFO *sl_info;

                    /* Nummer des Elternobjekts */
                    int     sl_parent;

                    /* Objektnummer des Schiebers */
                    int     sl_slider;

                    /* Objektnummern der Pfeile oder negative Werte */
                    int     sl_dec,sl_inc;

                    /* Position, SeitenlÑnge und Maximalwert des Schiebers */
                    int     sl_pos,sl_page,sl_max;

                    /* Richtung des Sliders: */
                    char    sl_vh;      /* HOR_SLIDER,VERT_SLIDER  */

                    /* Wiederholungs-Modus der Pfeile */
                    char    sl_mode;    /* SL_STEP,SL_LINEAR,SL_LOG,SL_EXP */

                    /* Verzîgerungsdauer in Milisekunden vor und wÑhrend der
                       Wiederholung */
                    int     sl_delay,sl_speed;

                    /* Zeiger auf Routine (oder NULL), welche nach jeder
                       VerÑnderung des Sliderwerts 'sl_pos' aufgerufen wird */
                    void    (*sl_do)(OBJECT *obj,int pos,int prev,
                                     int max_pos,int top);
                    /* obj:     Zeiger auf das Slider-Objekt
                       pos:     aktuelle Position des Schiebers
                       prev:    vorherige Position des Schiebers
                       max_pos: maximale Position des Schiebers
                       top:     Dialog ist im Vordergrund */

                    /* Zeiger auf Feld mit Slider-Hotkeys oder NULL (wird
                       nur ausgewertet, wenn die SLINFO-Struktur bei
                       open_dialog() Åbergeben wurde) */
                    SLKEY   *sl_keys;

                    /* Anzahl der Hotkeys im Feld 'sl_keys' */
                    int     sl_keys_cnt;
                } SLINFO;

               object: angeklicktes Objekt oder eines der folgenden
                       Kommandos:

                        #define SL_UP       -1  /* Zeile hoch */
                        #define SL_DOWN     -2  /* Zeile runter */
                        #define SL_PG_UP    -3  /* Seite hoch */
                        #define SL_PG_DN    -4  /* Seite runter */
                        #define SL_START    -5  /* Slider-Anfang */
                        #define SL_END      -6  /* Slider-Ende */

               double_click: Objekt wurde per Doppelklick angeklickt

        int graf_rt_rubberbox(int s_x,int s_y,GRECT *rect,int *w,int *h,
                              void(*box_do)(int *array));
            -> Echtzeitgummiband innerhalb des Rechtecks 'rect' mit den
               Start-Koordinaten (s_x,s_y) auswerten und darstellen
            -> Im Erfolgsfall (RÅckgabewert!=0) enthalten die Variablen
               '*w' und '*h' die Breite und Hîhe des Rechtecks
            -> 'box_do' enthÑlt einen Zeiger auf eine Funktion (oder NULL),
               welche nach jeder VerÑnderung des Rechtecks mit einem
               Zeiger auf das Koordinaten-Array 'array' des Rechtecks
               aufgerufen wird

    8. MenÅ-Funktionen
       ---------------

        WICHTIG:
        --------
        Alle MenÅ-Funktionen, bei denen kein Zeiger auf den Objektbaum
        Åbergeben wird, funktionieren nur, wenn vorher eine MenÅ-Leiste
        per menu_install() angemeldet wurde! Ansonsten mÅssen die
        entsprechenden AES-Funktionen benutzt oder die Objekt-Attribute
        direkt manipuliert werden.
        Unter MultiTasking wird beachtet, welcher Applikation die MenÅ-
        leiste gehîrt, um unnîtige Prozeûumschaltungen zu verhindern.

        int menu_install(OBJECT *menu,int show);
            -> MenÅ-Leiste 'menu' darstellen (show!=0) oder lîschen
               (show==0). Diese Funktion berÅcksichtigt, ob gegebenenfalls
               auch ein Accessory eine MenÅ-Leiste besitzen darf und ini-
               tialisiert die MenÅ-Punkte 'Fenster wechseln' und 'Fenster
               schlieûen'
            -> RÅckgabewert wie bei 'menu_bar'

        void menu_enable(boolean enable);
            -> MenÅ-Leiste aktivieren (enable==TRUE) bzw. deaktivieren
               (enable==FALSE) und neuzeichnen.

        void menu_item_enable(int object,int enable)
            -> MenÅ-Eintrag 'object' aktivieren (enable!=0) oder
               deaktivieren (enable==0)

        void menu_select(int title,int select)
            -> MenÅ-Titel 'title' normal (select==0) oder invers
               (select!=0) darstellen

        boolean menu_dropped();
            -> Testen, ob ein Drop-Down-MenÅ der MenÅleiste heruntergeklappt
               ist

    9. Dialog-Optionen und -optik setzen
       ---------------------------------

        void dial_colors(int dialog_pattern,int dialog_color,
                         int cycle_button,int hotkey,int check_box,
                         int radio_button,int arrow,int alert)
            -> Dialog-Optik setzen:
               dialog_pattern: Hintergrundmuster des Dialogs (0-7)
               dialog_color:   Hintergrundfarbe des Dialogs (0-15)
               cycle_button:   Cycle-Button-Farbe (0-15)
               check_box:      Checkbox-Farbe (0-15)
               radio_button:   Radio-Button-Farbe (0-15)
               arrow:          Slider-Arrow-Farbe (0-15)
               alert:          Farbe des Alert-Icons (0-15)

        void dial_options(boolean round,boolean title_frame,
                          boolean title_small,boolean niceline,
                          boolean return_default,boolean background,
                          boolean nonselectable,boolean always_keys,
                          boolean toMouse);
            -> verschiedene Optionen setzen:
               round:          Dialogpositionen und Fensterpositionen
                               auf Bytegrenzen (aus Geschwindigkeits-
                               grÅnden) runden
               title_frame:    öberschriften umrahmen
               title_small:    Kleine Schrift (SMALL) fÅr öberschriften
               niceline:       Niceline fÅr Trennstriche in MenÅs/Popups
               return_default: TRUE:  Return selektiert Default-Objekt
                               FALSE: Return springt zum nÑchsten Eingabefeld
                               FAIL:  Return selektiert Default-Objekt beim
                               letzten Eingabefeld (ansonsten wie FALSE)
               background:     Fensterdialoge (sowie mit open_window() ge-
                               îffnete Fenster) kînnen im Hintergrund
                               wie normale Dialoge bedient werden
               nonselectable:  Fliegende Dialoge fliegen auch beim Anklicken
                               von nicht-selektierbaren/editierbaren
                               Objekten
               always_keys:    TastendrÅcke werden auch bei fliegenden
                               oder modalen Dialogen an die Anwendung
                               weitergegeben
               toMouse:        TastendrÅcke an Fensterdialog unter Maus-
                               zeiger senden, sofern oberster Dialog
                               weder modal noch fliegend ist
                               -> zusammen mit 'background' ist somit eine
                                  vollstÑndige Bedienung von Hintergrund-
                                  dialogen mîglich

        void title_options(boolean mode,int color,int size);
            -> Unterstrichenen Text einstellen:
               mode:  Strich wird Åber die ganze Breite des Dialogs (TRUE)
                      oder Åber die im Resource vorgebenen Koordinaten
                      (FALSE) gezeichnet
               color: Strichfarbe (0-15)
               size:  Strickdicke in Pixel oder Null, wenn der Wert aus
                      der Resource-Struktur entnommen werden soll

        BUTTON-Struktur:
        ----------------
            typedef struct
            {
                /* Zeiger auf monochrome 16x16-Bitmap (32 Bytes) des
                   selektierten und des normalen Buttons im gerÑte-
                   abhÑngigen Format */
                int *but_on,*but_off;
            } BUTTON;

        void radio_image(int index,BUTTON *radiobutton);
            -> vordefinierte Images (index: 0-7) oder benutzerdefinierten
               Button 'radiobutton' (radiobutton!=NULL) fÅr Radio-Buttons
               auswÑhlen

        void check_image(int index,BUTTON *checkbox);
            -> vordefinierte Images (index: 0-5) oder benutzerdefinierten
               Button 'checkbox' (checkbox!=NULL) fÅr Check-Box auswÑhlen

        void cycle_image(int index,BUTTON *cyclebutton);
            -> vordefinierte Images (index: 0-1) oder benutzerdefinierten
               Button 'cyclebutton' (cyclebutton!=NULL) fÅr Cycle-Buttons
               auswÑhlen

        void arrow_image(int index,BUTTON *down,BUTTON *up,BUTTON *left,
                         BUTTON *right);
            -> vordefinierte Images (index: 0-2) oder benutzerdefinierte
               Buttons 'down', 'up' 'left', 'right' (sofern ungleich NULL)
               fÅr Slider-Pfeile auswÑhlen

    10. Bibliothek (AES,VDI) sowie Resource (de-) initialisieren
        --------------------------------------------------------

        boolean open_work(int *handle,int *work_out);
            -> virtuelle Bildschirm-Workstation îffnen
            -> RÅckgabewert ungleich FALSE, wenn Workstation geîffnet
               werden konnte
            -> handle:   VDI-Handle im Erfolgsfall
               work_out: work_out[57]-Feld

        void close_work(int handle);
            -> virtuelle Bildschirm-Workstation 'handle' schlieûen

        boolean init_gem(char *m_entry,char *x_name,char *a_name,
                         int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library
                - Anmeldung beim AES (appl_init)
                - Xacc-2/AV-Protokolle initialisieren
                - interne VDI-Workstation îffnen
                - Scrap-Directory initialisieren
                - globale Variablen sowie interne Strukturen initialisieren
            -> Parameter:
                m_entry:   Eintrag im Accessory-MenÅ (als Accessory oder
                           unter MTOS) oder NULL
                x_name:    (erweiterter) XAcc-2-Programmname
                a_name:    AV-Programmname (8 Zeichen wie bei appl_find)

                av_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht AV_PROTOKOLL (VA_START wird von der
                           Library immer angegeben und ausgewertet!)

                #define MSG_SETSTATUS   0x001 /* VA_SETSTATUS */
                #define MSG_START       0x002 /* VA_START */

                va_msgs:   Bitmap der unterstÅtzten Nachrichten der
                           Nachricht VA_PROTOSTATUS (AV_SENDKEY, AV_EXIT,
                           AV_ACCWINDOPEN/AV_ACCWINDCLOSED sowie
                           AV_PATH_UPDATE werden von der Library immer an-
                           gegeben und ausgewertet!)

                #define MSG_SENDKEY     0x001 /* AV_SENDKEY */
                #define MSG_ASKFILEFONT 0x002 /* AV_ASKFILEFONT */
                #define MSG_ASKCONFONT  0x004 /* AV_ASKCONFONT,
                                                 AV_OPENCONSOLE */
                #define MSG_ASKOBJECT   0x008 /* AV_ASKOBJECT */
                #define MSG_OPENWIND    0x010 /* AV_OPENWIND */
                #define MSG_STARTPROG   0x020 /* AV_STARTPROG */
                #define MSG_ACCWINDOPEN 0x040 /* AV_ACCWINDOPEN,
                                                 AV_ACCWINDCLOSED */
                #define MSG_STATUS      0x080 /* AV_STATUS, AV_GETSTATUS */
                #define MSG_COPY_DRAGGED 0x100 /* AV_COPY_DRAGGED */
                #define MSG_PATH_UPDATE 0x200 /* AV_PATH_UPDATE,
                                                 AV_WHAT_IZIT,
                                                 AV_DRAG_ON_WINDOW */
                #define MSG_EXIT        0x400 /* AV_EXIT */

                xacc_msgs: Bitmap der unterstÅtzten ACC-Nachrichten (alle
                           anderen ACC-Nachrichten werden automatisch
                           ausgewertet)

                #define X_MSG_TEXT      0x001 /* ACC_TEXT */
                #define X_MSG_META      0x002 /* ACC_META */
                #define X_MSG_IMG       0x004 /* ACC_IMG */

            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                       schlug fehl

        void exit_gem(int status);
            -> Deinitialisierung der Library:
                - Dialoge und Fenster schlieûen
                - MenÅleiste abmelden
                - Beenden der XAcc-2-/AV-Protokolle
                - geladene GDOS-Fonts wieder entfernen
                - interne VDI-Workstation schlieûen
                - Abmeldung beim AES (appl_exit), sofern Anwendung als
                  Programm gestartet wurde (ansonsten Endlos-Timer)
                - Programm beenden und Wert 'status' zurÅckgeben

        boolean open_rsc((char *rscname,char *m_entry,char *x_name,char *a_name,int av_msgs,int va_msgs,int xacc_msgs)
            -> Initialisierung der Library (s. init_gem()) sowie Resource
               'rscname' laden
            -> Parameter: s. init_gem()
            -> RÅckgabewert:
                TRUE:  Ok
                FALSE: Anmeldung beim AES oder ôffnen der Workstation
                FAIL:  Resource-File konnte nicht geladen werden (Speicher-
                       mangel oder falscher Pfad)

        void close_rsc(int status);
            -> Resource-Speicher freigeben und Library deinitialisieren
               (s. exit_gem())

    11. Resource- und Objekt-Initialisierung
        ------------------------------------

            void fix_objects(OBJECT *tree,int scaling,
                             int orig_cw,int orig_ch);
                -> erweiterte Objekte des Baums 'tree' initialisieren sowie
                   gegebenenfalls Images/Icons skalieren (scale_image)
                   und ins GerÑteformat konvertieren (trans_image)

                -> Parameter:
                   orig_cw: Breite des Entwurfsfonts in Pixel (meistens 8)
                            oder negativer Wert fÅr rsrc_obfix()-kompatible
                            Anpassung
                   orig_ch: Hîhe des Entwurfsfonts in Pixel (meistens 8 oder
                            16) oder negativer Wert fÅr rsrc_obfix()-kompa-
                            tible Anpassung
                   scaling: Bitmap des Skalierungs-Modus

                    #define NO_SCALING      0   /* keine Skalierung */
                    #define SCALING         1   /* Skalierung */
                    #define TEST_SCALING    2   /* Testen, ob Skalierung not-
                                                   wendig ist */
                    #define DARK_SCALING    4   /* dunkle Skalierung */

                    Beispiele:
                    /* Nie skalieren */
                        images = NO_SCALING;

                    /* Immer skalieren */
                        images = SCALING;

                    /* Bei Bedarf (System-Font kleiner als Entwurfsfont)
                       skalieren */
                        images = SCALING|TEST_SCALING;

                    /* Bei Bedarf dunkel skalieren */
                        images = SCALING|TEST_SCALING|DARK_SCALING;

        void scale_image(OBJECT *object,int scaling,
                         int orig_cw, int orig_ch);
            -> Image/Icon 'object' skalieren
            -> Parameter s. fix_objects()

        void trans_image(OBJECT *object);
            -> Image/Icon 'object' in GerÑteformat konvertieren

        void rsrc_calc(OBJECT *tree,int scaling,int orig_cw,int orig_ch);
            -> Koordinaten und Ausmaûe der Objekte des Baums 'tree' an
               Ausmaûe des System-Fonts unter Beachtung der Ausmaûe des
               Fonts, mit welchem die Resource-Datei erstellt wurde, an-
               passen und anschlieûend erweiterte Objekte initialisieren
               (s. fix_objects())
            -> Parameter s. fix_objects()

        void rsrc_init(int n_tree,int n_obs,int n_frstr,int n_frimg,
                       int scaling,char **rs_strings,long *rs_frstr,
                       BITBLK *rs_bitblk,long *rs_frimg,
                       ICONBLK *rs_iconblk,TEDINFO *rs_tedinfo,
                       OBJECT *rs_object,OBJECT **rs_trindex,
                       RS_IMDOPE *rs_imdope,int orig_cw,int orig_ch)
            -> in Quelltext eingebundene Resource-Datei (*.RSH)
               initialisieren

            -> Parameter:
               n_tree:     Anzahl der BÑume (NUM_TREE)
               n_obs:      Anzahl der Objekte (NUM_OBS)
               n_frstr:    Anzahl der freien Strings (NUM_FRSTR)
               n_frimg:    Anzahl der freien Images (NUM_FRIMG)

               rs_strings: String-Array (Pointer zeigen auf alle
                           Zeichenketten der Resource-Datei)
               rs_frstr:   Index-Array (Indizes der freien Strings
                           fÅr das rs_strings-Array)
               rs_bitblk:  BITBLK-Array (enthÑlt alle Bit-Blîcke)
               rs_frimg:   Index-Array (Indizes der freien Images
                           fÅr das rs_bitblk-Array)
               rs_iconblk: ICONBLK-Array (enthÑlt alle icons)
               rs_tedinfo: TEDINFO-Array (enthÑlt alle TEDINFO-Strukturen)
               rs_object:  OBJECT-Array (enthÑlt alle Objekte)
               rs_trindex: Index-Array (Indizes der ObjektbÑume
                           fÅr das rs_object-Array)
               rs_imdope:  RS_IMDOPE-Array

                RS_IMDOPE-Struktur:
                -------------------

                typedef struct
                {
                    int dummy;
                    /* Zeiger auf Bitmap (Image) */
                    int *image;
                } RS_IMDOPE;

               scaling: s. fix_objects()
               orig_cw: s. fix_objects()
               orig_ch: s. fix_objects()

               HINWEIS:
               An allen Stellen der Resource, an denen normalerweise
               Pointer vorkommen, muû der Element-Index (Long-Wert) des
               entsprechenden Arrays stehen. Die Image-Zeiger der
               Strukturen BITBLK und ICONBLK enthalten den Index des
               zugehîrigen RS_IMDOPE-Elements.

    12. Ereignis-Auswertung
        -------------------

        XEVENT-Struktur:
        ----------------

        typedef struct
        {
            /* PARAMETER: */

            /* Bitmap der gewÅnschten Events:
               MU_KEYBD:     Tastatur-Ereignis
               MU_MESAG:     Nachrichten-Ereignis
               MU_TIMER1-4:  Timer-Ereignis 1-4
               MU_BUTTON1/2: Button-Ereignis 1/2
               MU_M1-4:      Rechteck-Ereignis 1-4 */
            int ev_mflags;

            /* Parameter des 1. Button-Events MU_BUTTON1 */
            int ev_mb1clicks,ev_mb1mask,ev_mb1state

            /* Parameter des 1. Mouse-Event-Rechtecks MU_M1 */
            int ev_mm1flags,ev_mm1x,ev_mm1y,ev_mm1width,ev_mm1height,

            /* Parameter des 2. Mouse-Event-Rechtecks MU_M2 */
            int ev_mm2flags,ev_mm2x,ev_mm2y,ev_mm2width,ev_mm2height;

            /* Parameter des 1. Timer-Events MU_TIMER1 */
            unsigned int ev_mtlocount,ev_mthicount;

            /* RöCKGABEWERTE: */

            /* eingetretene Ereignisse */
            int ev_mwich;

            /* Position des Mauszeigers sowie Zustand der Maustasten
               beim Auftreten des Events */
            int ev_mmox,ev_mmoy,ev_mmobutton;

            /* Zustand der Sondertasten beim Auftreten des Events */
            int ev_mmokstate;

            /* Scancode der gedrÅckten Taste (High-Byte: Scan-Code,
               Low-Byte: ASCII-Code oder Null) */
            int ev_mkreturn;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON1) */
            int ev_mb1return;

            /* Nachrichten-Puffer */
            int ev_mmgpbuf[8];

            /* erweiterte PARAMETER: */
            /* Parameter des 2. Button-Events MU_BUTTON2 */
            int ev_mb2clicks,ev_mb2mask,ev_mb2state;

            /* Parameter des 3. Mouse-Event-Rechtecks MU_M3 */
            int ev_mm3flags,ev_mm3x,ev_mm3y,ev_mm3width,ev_mm3height;

            /* Parameter des 4. Mouse-Event-Rechtecks MU_M4 */
            int ev_mm4flags,ev_mm4x,ev_mm4y,ev_mm4width,ev_mm4height;

            /* Parameter des 2-4. Timer-Events MU_TIMER2-4 */
            long ev_mt2count,ev_mt3count,ev_mt4count;

            /* Zeitpunkt in Milisekunden des letzten Timer-Events
               MU_TIMER1-4 oder Null fÅr aktuelle System-Zeit */
            long ev_mt1last,ev_mt2last,ev_mt3last,ev_mt4last;

            /* Anzahl der Klicks mit der Maustaste (MU_BUTTON2) */
            int ev_mb2return;
        } XEVENT;

        KompatibilitÑts-Makros fÅr EVENT-Struktur und AES-Event-Routinen:
        -----------------------------------------------------------------

            #define ev_mbclicks     ev_mb1clicks
            #define ev_mbmask       ev_mb1mask
            #define ev_bmask        ev_mb1mask
            #define ev_mbstate      ev_mb1state
            #define ev_mbreturn     ev_mb1return

            #define ev_mtlocount    ev_mt1locount
            #define ev_mthicount    ev_mt1hicount
            #define ev_mtlast       ev_mt1last

            #define MU_TIMER1       MU_TIMER
            #define MU_BUTTON1      MU_BUTTON

        int Event_Multi(XEVENT *event);
            -> Auf Ereignis 'event' warten (benîtigte Parameter der
               Struktur mÅssen initialisiert sein, sofern dies nicht
               die Initialisierungs-Routine von Event_Handler(), s.u.,
               Åbernimmt). Die Library wertet dabei selbstÑndig Nachrichten
               der XAcc-2-, AV- und Drag&Drop-Protokolle aus und wandelt
               diese gegebenenfalls um. Ebenso werden Ereignisse, welche
               Fenster (-dialoge) bzw. allgemein die Library betreffen,
               ausgewertet.

               WICHTIG:
               Es werden nur Ereignisse zurÅckgeliefert, welche nicht von
               der Library oder dem durch die Funktion Event_Handler()
               definierten Handler ausgewertet wurden!
               Setzt man die Variable 'ev_mflags' auf Null oder Åbergibt man
               den Wert NULL fÅr den Parameter 'event', so werden KEINE
               Events zurÅckgeliefert! Alle Ereignisse mÅssen dann vom
               Handler initialisiert und ausgewertet werden!
               Library-spezifische Nachrichten (s.u.) werden NUR an den
               Event-Handler geliefert!!!

            -> RÅckgabewert: Bitmap der eingetretenen Ereignisse

        void Event_Timer(int locount,int hicount)
            -> Wartet bis die durch lo_count und hi_count in Millisekunden
               vorgebene Zeit verstrichen ist. Dabei werden allerdings
               noch Nachrichten durch die Library (der Nachrichtenpuffer
               wird komplett geleert) sowie Ereignisse durch den Handler
               ausgewertet, so daû diese Funktion z.B. wÑhrend eines
               rechenintensiven Vorgangs dazu benutzt werden kann,
               Ereignisse durch einen Aufruf mit kurzer Wartezeit auszu-
               werten (z.B. Fenster verschieben, neuzeichnen etc...)

        void Event_Handler(int (*init)(XEVENT *,int,int),
                           int (*handler)(XEVENT *));
            -> Routinen zur Ereignisauswertung festlegen, wobei diese Rou-
               tinen diejenigen Ereignisse auswerten, welche nicht auto-
               matisch von der Library bearbeitet wurden. Durch öbergabe
               von NULL kînnen bereits angemeldete Funktionen einzeln wieder
               abgemeldet werden. Ebenso kann man die Routinen beliebig
               oft neu setzen, z.B. fÅr eine lokale Ereignisauswertung.

            -> Parameter:
                int (*init)(XEVENT *event,int available):
                    -> Routine, welche u.a. von X_Form_Do bei jeder
                       Initialisierung eines Dialogs aufgerufen wird. Die
                       Routine gibt eine Bitmap der gewÅnschten Events zu-
                       rÅck und initialisiert gegebenenfalls Variablen der
                       Åbergebenen XEVENT-Struktur 'event'.
                       Angefordert werden kînnen nur die Events, welche in
                       der Bitmap 'available' gesetzt sind.

                int (*handler)(XEVENT *event):
                    -> Routine, welche u.a. von X_Form_Do aufgerufen wird
                       und die Ereignisse, welche von der Library nicht ver-
                       arbeitet wurden, auswertet. ZurÅckgegeben wird eine
                       Bitmap der ausgewerteten Ereignisse. V.a. bei Tasta-
                       tur-Ereignissen, welche nicht ausgewertet wurden,
                       sollte MU_KEYBD nicht gesetzt sein, damit die Library
                       gegebenenfalls den Tastendruck per Xacc-2- oder AV-
                       -Protokoll weiterleiten kann. Dies kann man natÅrlich
                       unterbinden, indem man stÑndig alle Ereignisse zu-
                       rÅckgibt.

                       WICHTIG:
                       Diese Routine darf keine Variablen der XEVENT-Struk-
                       tur (abgesehen von den Ausgabewerten) verÑndern!

                Library-spezifische Nachrichten (MU_MESAG):
                -------------------------------------------

                    -> Eingabefeld wurde verÑndert:
                        msg[0]        = OBJC_EDITED
                        msg[3]        = Nummer des aktuellen Eingabeobjekts
                                        oder negativer Wert, falls alle
                                        Eingabefelder betroffen sind
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

                    -> Status eines Objekts (kein EXIT-/TOUCHEXIT-Objekt,
                       bei Slidern nach PositionsÑnderung das Schieber-
                       Objekt) hat sich geÑndert:
                        msg[0]        = OBJC_CHANGED
                        msg[3]        = Nummer des Objekts
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

                    -> Grîûe oder Position des Dialogs hat sich geÑndert,
                       wobei die Ausmaûe des Wurzelobjekts bereits angepaût
                       wurden
                        msg[0]        = OBJC_SIZED
                        msg[4]/msg[5] = Zeiger auf die DIAINFO-Struktur des
                                        Dialogs

                    -> Daten wurden an Applikation per Drag&Drop Åbergeben
                        msg[0]        = OBJC_DRAGGED
                        msg[4]/msg[5] = Zeiger auf DRAG_DROP-Struktur

                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       angemeldet
                        msg[0]        = XACC_AV_INIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur

                    -> Applikation hat sich per XAcc-2- oder AV-Protokoll
                       abgemeldet
                        msg[0]        = XACC_AV_EXIT
                        msg[3]        = Applikations-ID
                        msg[4]/msg[5] = Zeiger auf XAcc-Struktur (Struktur
                                        ist nach vollstÑndiger Abmeldung
                                        nicht mehr gÅltig
                                        (Struktur-Variable id<0)

                    -> Status eines Fenster hat sich geÑndert (z.B. wurde
                       das Fenster ikonifiziert/deikonifiziert). U.a. kann
                       sich auch das Fenster-Handle Ñndern!
                        msg[0]        = WIN_CHANGED
                        msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                                        Fensters oder NULL, falls alle
                                        Fenster betroffen sind

                    -> Scrollposition eines Fensters wurde geÑndert
                        msg[0]        = WIN_SCROLLED
                        msg[4]/msg[5] = Zeiger auf die WIN-Struktur des
                                        Fensters
                        msg[6]        = alte horizontale Position (hpos)
                        msg[7]        = alte vertikale Position (vpos)

    13. Dialog-Funktionen
        -----------------

        DIAINFO-Struktur:
        -----------------

        typedef struct
        {
            /* Dialog-Typ
                CLOSED      -> geschlossen
                OPENED      -> normaler Dialog
                FLYING      -> fliegender Dialog
                WINDOW      -> Fenster-Dialog
                WIN_MODAL   -> modaler Fenster-Dialog */
            DIALMODE di_flag;

            /* Zeiger auf Objektbaum */
            OBJECT   *di_tree;

            /* Zeiger auf Fenster-Struktur */
            WIN      *di_win;

            /* alle weiteren Variablen dieser Struktur sind nur fÅr INTERNE
               Zwecke */
        } DIAINFO;

        boolean open_dialog(OBJECT *tree,DIAINFO *info,char *title,
                char *icon_title, OBJECT *icon, boolean center,
                boolean grow_box,int dialog_mode,int edit, SLINFO **slider);
            -> Dialog îffnen (RÅckgabewert ungleich Null, wenn Dialog ge-
               îffnet wurde)
            -> Parameter:
                tree:
                    -> Zeiger auf Objektbaum
                info:
                    -> Zeiger auf DIAINFO-Struktur (wird von dieser
                       Funktion initialisiert)
                title:
                    -> Zeiger auf Fenster-Titel fÅr Fensterdialoge
                icon_title:
                    -> Zeiger auf Fenstertitel im ikonifizierten Zustand
                       oder NULL
                icon:
                    -> Zeiger auf Objektbaum, der fÅr die ikonifizierte
                       Darstellung benutzt wird, oder NULL (in diesem
                       Fall wird der globale Objektbaum 'iconified'
                       benutzt)
                center:
                    TRUE  -> Dialog um Mauszeiger zentrieren
                    FALSE -> Dialog in Bildschirmmitte zentrieren
                             (sichtbarer Ausschnitt des Bildschirms
                             wird beachtet)
                    FAIL  -> Dialog an letzter Position îffnen (beim
                             ersten ôffnen analog wie FALSE)
                grow_box:
                    -> sich vergrîûernder Rechtecke zeichnen
                dialog_mode:
                    -> Bitmap des Dialogtyps:

                        /* fliegender Dialog */
                        #define FLY_DIAL        1

                        /* Fenster-Dialog */
                        #define WIN_DIAL        2

                        /* Fenster-Dialog, sofern Fenster geîffnet werden
                           kann, ansonsten fliegender Dialog
                        #define AUTO_DIAL       (FLY_DIAL|WIN_DIAL)

                        /* modaler Fensterdialog */
                        #define MODAL           4

                        /* Fenster-Dialog mit Rahmen */
                        #define FRAME           8

                        /* Fenster-Dialog kann nicht ikonifiziert werden */
                        #define NO_ICONIFY      16

                        /* Die folgenden Elemente des Dialogfensters mÅssen
                           von der Anwendung ausgewertet u. gesetzt werden!
                           Dabei wird die Grîûe des Fensters automatisch
                           gesetzt, wenn WD_SET_SIZE Åbergeben wird. An-
                           sonsten darf die Grîûe NICHT verÑndert werden! */

                        /* Fenster-Dialog mit horizontalem Slider
                           (Slider,Pfeile rechts/links) */
                        #define WD_HSLIDER      256

                        /* Fenster-Dialog mit vertikalem Slider
                           (Slider,Pfeile hoch/runter) */
                        #define WD_VSLIDER      512

                        /* Fenster-Dialog mit Sizer */
                        #define WD_SIZER        1024

                        /* Fenster-Dialog mit Fuller */
                        #define WD_FULLER       2048

                        /* Fenster-Dialog mit Info-Zeile */
                        #define WD_INFO         4096

                        /* Grîûe bei WM_FULLED/WM_SIZED automatisch an-
                           passen (Nachricht OBJC_SIZED wird anschlieûend
                           an Anwendung geschickt) */
                        #define WD_SET_SIZE     8192

                edit:
                    -> Objektnummer des Eingabefeldes, in welchem sich
                       der Cursor befinden soll (oder negativer Wert)

                slider:
                    -> Zeiger auf Liste mit Adressen der SLINFO-Strukturen
                       (letzter Listen-Eintrag gleich NULL) der Slider des
                       Dialogs oder NULL, wenn die Slider nicht automatisch
                       verwaltet werden sollen

        void close_dialog(DIAINFO *dialog,boolean shrink_box);
            -> Dialog 'dialog' schlieûen und gegebenenfalls sich
               verkleinernde Rechtecke zeichnen (shrink_box!=0)

        void close_all_dialogs(void)
            -> alle geîffneten Dialoge schlieûen

        int X_Form_Do(DIAINFO **dialog)
            -> Bearbeitung der geîffneten Dialoge
            -> ZurÅckgegeben wird die Nummer des angewÑhlten Exit-Objekts
               (bei Doppelklick ist Bit 15 (0x8000) gesetzt) oder die Werte
               W_ABANDON -> Abbruch der Dialogbearbeitung, alle Dialoge
                            wurden geschlossen (z.B. durch AC_CLOSE) bzw.
                            beim Aufruf der Funktion waren keine Dialoge
                            geîffnet
               W_CLOSED  -> Fensterdialog wurde geschlossen
            -> '*dialog' enthÑlt (sofern ungleich NULL) einen Zeiger auf
               die DIAINFO-Struktur des aktuellen Dialogs

        int xdialog(OBJECT *tree,char *title,char *icon_title,OBJECT *icon,
                    boolean center,boolean grow_box,int dialog_mode);
            -> komplette Dialogbearbeitung (Dialog îffnen, bearbeiten und
               schlieûen), wobei diese Funktion nur verwendet werden sollte,
               wenn sonst kein Dialog geîffnet ist oder ein modaler oder
               fliegender Dialog geîffnet wird (z.B. um auf eine Benutzer-
               eingabe zu warten)
            -> Parameter und RÅckgabewerte s. open_dialog() sowie
               X_Form_Do()

        int xalert(int default,int undo,int icon,BITBLK *user_icon,
                   int modal,int center,int width,
                   char *title,char *text,char *buttons)
            -> erweiterte Alertbox darstellen (zurÅckgeliefert wird der
               Index des ausgewÑhlten Buttons oder FAIL im Fehlerfall)
            -> default:   Index des DEFAULT-Buttons oder negativer Wert
               undo:      Index des UNDO-Buttons oder negativer Wert
               icon:      Nummer des Icons oder negativer Wert

                X_ICN_NONE:      /* kein Icon */
                X_ICN_MAX:       /* maximale Icon-Nummer */

                X_ICN_STOP:      /* Stop-Schild (Hinweis) */
                X_ICN_QUESTION:  /* Fragezeichen (Nachfrage) */
                X_ICN_ALERT:     /* Ausrufezeichen (Warnung) */

                X_ICN_DISC_ERR:  /* Disketten-I/O-Fehler */
                X_ICN_ERROR:     /* Bomben-Fehler */
                X_ICN_FLOPPY:    /* Disketten-Station */
                X_ICN_DISC:      /* Diskette */
                X_ICN_INFO:      /* Informations-Zeichen */
                X_ICN_PRT_ERR:   /* Drucker-I/O-Fehler */

               user_icon: Zeiger auf benutzerdefiniertes Icon oder NULL
               modal:     System-/Applikations-modale Alert-Box

                #define SYS_MODAL           0 /* System-Modal */
                #define APPL_MODAL          1 /* Applikations-Modal */

               center:    Ausrichtung der Buttons

                #define BUTTONS_CENTERED    0 /* zentriert */
                #define BUTTONS_LEFT        1 /* linksbÅndig */
                #define BUTTONS_RIGHT       2 /* rechtsbÅndig */

               width:     einheitliche Breite der Buttons (width!=0)
               title:     Zeiger auf Fenster-Titel bei applikationsmodalen
                          bzw. öberschrift bei systemmodalen Dialogen
               text:      Zeiger auf Text (maximale 16 Zeilen getrennt
                          durch '|'). Die Textattribute kînnen durch die
                          folgenden Zeichen (in beliebiger Reihenfolge)
                          am ANFANG einer Textzeile gesetzt werden:

                          Fett          = '!'
                          Unterstrichen = '_'
                          Kursiv        = '/'
                          Hell          = '~'
                          Umrandet      = '#'
                          Schattiert    = '@'

               buttons:   Button-Text (maximal 6 Buttons getrennt durch
                          '|', Hotkeymarkierung durch '[')

        char ascii_box(char *title)
            -> Sonderzeicheneingabebox îffnen (Parameter s. open_dialog())
               (Funktion nur verfÅgbar, wenn Library nicht als Light-
                Version Åbersetzt wurde)
            -> RÅckgabewert: ausgewÑhltes Zeichen

    14. Fenster-Funktionen
        ------------------

        WIN-Struktur:
        -------------

        typedef struct
        {
             /* Handle des Fensters (handle>0, falls Fenster geîffnet) */
             int handle;

             /* VDI-Handle der zum Fenster gehîrenden VDI-Workstation
               (nach Aufruf von open_window() ist die Library-Workstation
                'x_handle' als VDI-Workstation gesetzt)
             int vdi_handle;

             /* Bitmap der Fensterelemente (s. wind_create) */
             int gadgets;

             /* Bitmap des Fenster-Status */
             char iconified;

                 #define ICONIFIED  1  /* Fenster ikonifiziert (MTOS) */
                 #define SHADE      2  /* Fenster eingeklappt (Winx 2.3) */
                 #define ICFS       4  /* Fenster ikonifiziert (ICFS) */

             /* Fenster hat maximale Ausmaûe */
             char fulled;

             /* Position des Mauszeigers beim letzten Aufruf von
                window_mouse() oder window_set_mouse() (Variable ist
                ungÅltig bei Fensterdialogen!) */
             int inside;

                 FAIL:  Fenster ist im Hintergrund
                 FALSE: Mauszeiger auûerhalb des Arbeitsbereiches
                 TRUE:  Mauszeiger innerhalb des Arbeitsbereiches

             /* Grîûe (1-1000)/Position (0-1000) des horiz. Sliders */
             int sl_hpos,sl_hsize;

             /* Grîûe (1-1000)/Position (0-1000) des vert. Sliders */
             int sl_vpos,sl_vsize;

             /* Zeiger auf SCROLL-Struktur oder NULL */
             SCROLL *scroll;

             /* Zeiger auf Fenster-Titel oder NULL */
             char   *name;

             /* Zeiger auf Titel im ikonifizierten Zustand oder NULL */
             char   *icon_name;

             /* minimale Fensterbreite/-hîhe */
             int min_w,min_h;

             /* maximale Fensterausmaûe */
             GRECT max;

             /* Die folgenden Variablen beziehen sich IMMER auf den
                nicht ikonifizierten Zustand des Fensters! */

             /* aktuelle Fensterausmaûe */
             GRECT curr;

             /* vorherige Fensterausmaûe */
             GRECT prev;

             /* Fensterarbeitsbereich */
             GRECT work;

            /* alle weiteren Variablen dieser Struktur sind fÅr
               INTERNE Zwecke reserviert */
        } WIN;

        SCROLL-Struktur:
        ----------------

        typedef struct
        {
            /* automatisches Scrolling (scroll!=0) oder nur Slider
               setzen und neue Werte der SCROLL-Struktur berechnen
               (scroll==0) */
            int scroll;

            /* Index des Objekts, welches beim automatische Scrolling
               (scroll!=0) eines Dialogs neugezeichnet werden soll. Hier
               kann natÅrlich immer das Wurzelobjekt angegeben werden
               (Clipping wird von der Library durchgefÅhrt), aber aus Ge-
               schwindigkeitsgrÅnden sollte man nur das betreffende Objekt
               angeben */
            int obj;

            /* Breite des Bereichs am linken/rechten Rand, der nicht
               verschoben werden darf (z.B. eine Toolbar). Diese Werte
               werden auch fÅr die Berechnung der Sliderposition/-grîûe
               benîtigt */
            int tbar_l,tbar_r;

            /* Breite des Bereichs am oberen/unteren Rand, der nicht
               verschoben werden darf (z.B. eine Toolbar) Diese Werte
               werden auch fÅr die Berechnung der Sliderposition/-grîûe
               benîtigt */
            int tbar_u,tbar_d;

            /* Breite/Hîhe einer Spalte/Zeile
               (z.B. bei Textfenstern die Fontgrîûe, bei Grafikfenstern
                meistens 1) */
            int px_hline,px_vline;

            /* Horizontale/vertikale Position des Fensterinhalts
               (in Spalten/Zeilen) */
            int hpos,vpos;

            /* Horizontale/vertikale Fenstergrîûe (in Spalten/Zeilen) */
            int hsize,vsize;

            /* Horizontale/vertikale Seitengrîûe (in Spalten/Zeilen)
               (diese Variablen dÅrfen nicht verÑndert werden bzw. werden
               von der Library gesetzt!) */
            int hpage,vpage;

            /* Horizontale/vertikale Schrittweite (in Spalten/Zeilen) */
            int hscroll,vscroll;

             /* alle weiteren Variablen dieser Struktur sind fÅr
               INTERNE Zwecke reserviert */
        } SCROLL;

        WICHTIG:
        Es dÅrfen nur noch diejenigen AES-Fensterroutinen verwendet
        werden, deren FunktionalitÑt nicht von einer Ñquivalenten
        Library-Routine angeboten wird bzw. wenn das Fenster nicht
        von der Library verwaltet wird (Fenster 0 (Desktop) oder
        Fenster anderer Applikationen), dÅrfen alle AES-wind-Funktionen
        verwendet werden.
        Bei geîffneten systemmodalen Dialogen oder Popups werden Nach-
        richten und zu setzende Werte automatisch bis zum Schlieûen der
        der Dialoge/Popups gepuffert und dann an die Ereignisverwaltung
        weitergeleitet.

        WIN *open_window(char *title,char *icon_title,char *info,
                         OBJECT *icon,int gadgets,int box,
                         int min_w,int min_h,
                         GRECT *max,GRECT *curr,SCROLL *scroll,
                         void (*redraw)(WIN *,GRECT *))
            -> Fenster îffnen und bei einem evtl. vorhandenen AV-Server
               anmelden (AV_ACCWINDOPEN) sowie egebenenfalls die Hinter-
               grundbedienung aktivieren
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL
               info:       Zeiger auf Infozeile oder NULL
               gadgets:    Bitmap der Fensterelemente wie bei
                           wind_create()
               icon:       Zeiger auf Objektbaum, der fÅr die ikonifizierte
                           Darstellung benutzt wird, oder NULL (in diesem
                           Fall wird der globale Objektbaum 'iconified'
                           benutzt)
               box:        sich vergrîûernde Rechtecke zeichnen (box!=0)
               min_w:      minimale Fensterbreite
               min_h:      minimale Fensterhîhe
               max:        maximale Fensterausmaûe
                           max->g_x/g_y: minimale linke, obere Fenster-
                                         koordinaten (normalerweise die
                                         entsprechenden Koordinaten des
                                         Desktopfensters 'desk')
                           max->g_w/g_h: maximale Fensterbreite/-hîhe
               curr:       Fensterausmaûe
               scroll:     Zeiger auf initialisierte SCROLL-Struktur fÅr
                           automatisches Scrolling oder NULL. Wurde die
                           Scroll-Position geÑndert, so wird eine Nachricht
                           WIN_SCROLLED verschickt. U.a. werden von der
                           Library in diesem Fall auch Slidergrîûe und
                           -position automatisch gesetzt.
               redraw:     Routine, die den Fenster-Redraw Åbernimmt. Dabei
                           muû weder das Åbergebene Rechteck mit der Recht-
                           liste geschnitten noch das Clipping der VDI-
                           Workstation gesetzt werden! (VDI-Handle der
                           WIN-Struktur nach Aufruf von open_window()
                           gegebenenfalls auf anderen Wert als die globale
                           Library-Workstation 'x_handle' setzen)
                           Wird fÅr 'redraw' NULL Åbergeben, so wird
                           die Nachricht WM_REDRAW (wie Åblich) weiterge-
                           leitet.
            -> RÅckgabewert: Zeiger auf WIN-Struktur oder NULL

        void window_reinit(WIN *win,char *title,char *icon_title,
                           char *info,int home)
            -> Fenster 'win' reinitialisieren und neuzeichnen. U.a.
               wird gegebenenfalls die SCROLL-Struktur auf gÅltige
               Werte gesetzt und die Grîûe des Fensters an die maximalen
               bzw. minimalen Ausmaûe angepaût.
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL
               info:       Zeiger auf Infozeile oder NULL
               home:       Scroll-Position in linke obere Ecke (home!=0)

        int close_window(WIN *window,int box)
            -> Fenster 'window' schlieûen und gegebenenfalls (box!=0) sich
               verkleinernde Rechtecke zeichnen. Auûerdem wird das Fenster
               bei einem evtl. vorhandenem AV-Server abgemeldet
            -> RÅckgabewert gleich Null, wenn ein Fehler auftrat

        void close_all_windows(void)
            -> Alle geîffneten Fenster schlieûen. Sind vorher noch Dialoge
               geîffnet, so werden diese ebenfalls geschlossen.

        void redraw_window(WIN *win,GRECT *area)
            -> Lîst einen Redraw Åber das Rechteck 'area' (area!=NULL) des
               Fensters 'win' oder den gesamten Fensterbereich (area==NULL)
               aus. Wurde fÅr das Fenster kein Redraw-Handler angemeldet,
               so wird eine WM_REDRAW-Nachricht verschickt.

        void window_scroll_slider(WIN *win,int vh)
            -> horizontalen (vh==HOR_SLIDER) oder vertikalen
               (vh==VERT_SLIDER) Slider des Fensters 'win' anhand der
               Werte der Scroll-Struktur setzen

        void scroll_window(WIN *win,int mode,GRECT *area)
            -> Fensterinhalt des Fensters 'win' in AbhÑngigkeit vom Para-
               meter 'mode' scrollen (Fenster muû Åber eine SCROLL-Struktur
               verfÅgen!), wobei sowohl Slidergrîûe als auch -position
               automatisch angepaût werden.
            -> Parameter:
                area: Bereich des Fensters oder NULL fÅr gesamtes Fenster
                      abzÅglich der in der SCROLL-Struktur angegebenen
                      Toolbar-Bereiche
                mode:
                /* an Anfang/Ende der Zeile */
                LINE_START,LINE_END

                /* an Anfang/Ende des Fensterinhalts */
                WIN_START,WIN_END

                /* Position (hpos,vpos) bereits gesetzt (wird automatisch
                   an gÅltigen Bereich angepaût) */
                WIN_SCROLL

                /* Seite nach links/oben/rechts/unten */
                PAGE_LEFT,PAGE_UP,PAGE_RIGHT,PAGE_DOWN

                /* Zeile/Spalte nach links/oben/rechts/unten */
                LINE_LEFT,LINE_UP,LINE_RIGHT,LINE_DOWN

        WIN *get_window(int handle)
            -> WIN-Struktur zum Fenster 'handle' ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

        WIN *get_top_window(void)
            -> WIN-Struktur zum obersten Fenster ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte (Fenster gehîrt anderer Applikation oder
               kein Fenster geîffnet)

        int window_first(WIN *win,GRECT *rect);
        int window_next(WIN *win,GRECT *rect);
            -> VerkÅrzte Aufrufe von wind_xget(handle,WF_FIRSTXYWH,...)
               bzw. wind_xget(handle,WF_NEXTXYWH,...).
            -> RÅckgabewert s. wind_xget()

        void window_size(WIN *win,GRECT *size)
            -> Ausmaûe des Fensters 'win' auf 'size' setzen
               (im ikonifizierten Zustand wird die Grîûe erst nach der
                Deikonifizierung gesetzt)
            -> Wurde eine SCROLL-Struktur beim ôffnen des Fenster
               Åbergeben, so werden von dieser Funktion auch Slidergrîûe
               und -position automatisch gesetzt, wobei evtl. der Fenster-
               inhalt verschoben wird.

        void window_slider(WIN *win,int vh,int pos,int size)
            -> Vertikalen (vh==VERT_SLIDER) oder horizontalen
               (vh==HOR_SLIDER) Slider des Fensters 'win' setzen
               (im ikonifizierten Zustand werden die Werte erst nach der
                Deikonifizierung gesetzt)
            -> Parameter:
               pos:  Position des Sliders (0-1000) oder FAIL
               size: Grîûe des Sliders (1-1000) oder
               FAIL

        void window_set_mouse(WIN *win,int in,int out,
                              MFORM *in_form,MFORM *out_form)
            -> Form des Mauszeigers innerhalb und auûerhalb des Arbeits-
               bereiches des Fensters 'win' festlegen und setzen. Der
               Mauszeiger wird i.A. automatisch verwaltet, wobei das
               Verlassen/Betreten des Arbeitsbereiches von der Anwendung
               Åberwacht werden muû (s. Beispielquelltext 'WINVIEW.C').
               Der Arbeitsbereich selber umfaût dabei den Arbeitsbereich
               des Fensters abzÅglich der evtl. angegebenen Ausmaûe von
               "Toolbars".
               Diese Funktion hat keine Auswirkung auf Fensterdialoge!
            -> Parameter:
               in, in_form:   Mausform innerhalb des Arbeitsbereichs
                              (Bedeutung s. graf_mouse()). Wird fÅr den
                              Parameter 'in' ein negativer Wert Åbergeben,
                              so wird die Mausform nicht gesetzt (dies ist
                              voreingestellt)
               out, out_form: Mausform auûerhalb des Arbeitsbereichs, Be-
                              deutung s.o.

        void window_mouse(WIN *win)
            -> Mauszeiger des Fensters 'win' entsprechend den durch
               window_set_mouse() getroffenen Einstellungen setzen

        void window_name(WIN *win,char *title,char *icon_title)
            -> Titel des Fensters 'win' setzen
            -> Parameter:
               title:      Zeiger auf Fenstertitel oder NULL
               icon_title: Zeiger auf Fenstertitel im ikonifizierten Zu-
                           stand oder NULL

        void window_info(WIN *win,char *info)
            -> Info-Zeile des Fensters 'win' setzen (im ikonifizierten
               Zustand wird die Info-Zeile erst nach der Deikonifizierung
               gesetzt)
            -> Parameter:
               info: Zeiger auf Infozeile oder NULL

        void window_top(WIN *win)
            -> Fenster 'win' nach oben bringen (entspricht
               wind_set(handle,WF_TOP))

        void window_bottom(WIN *win)
            -> Fenster 'win' nach unten legen (entspricht
               wind_set(handle,WF_BOTTOM))

        WIN *window_find(int x,int y)
            -> WIN-Struktur des Fensters an den Koordinaten (x,y)
               ermitteln
            -> RÅckgabewert gleich NULL, falls Struktur nicht gefunden
               werden konnte

        void window_calc(int wctype,int kind,GRECT *in,GRECT *out)
            -> Entspricht von der FunktionalitÑt der AES-Funktion
               wind_calc(), nur daû anstatt einzelner Parameter Zeiger
               auf GRECT-Strukturen erwartet werden

        void window_border(int kind,int x,int y,int w,int h,GRECT *out)
            -> Koordinaten des Randbereichs (WC_BORDER) aus der linken,
               oberen Ecke (x,y) des Fensters und der Breite/Hîhe des
               Arbeitsbereiches (w,h) berechnen und im Recheck 'out'
               zurÅckgeben. Dabei wird das Ausgaberechteck automatisch
               auf den Desktop begrenzt.

        void CycleCloseWindows(char cycle_hot,char close_hot,int cycle_menu,
                               int close_menu)
            -> Hotkeys (+Control-Taste) und MenÅpunkte fÅr die Funktionen
               'Fenster wechseln' sowie 'Fenster schlieûen' definieren.
               Beachtet werden alle Fensterdialoge sowie Fenster, die mit
               den Funktionen open_window() und close_window() geîffnet bzw.
               geschlossen werden. Der MenÅtitel wird nur dann deselektiert,
               wenn der Zeiger auf die MenÅleiste 'menu' gesetzt ist!
            -> Parameter:
                cycle_hot,close_hot:
                  -> Hotkey-Buchstaben oder Null (voreingestellt sind
                     die Zeichen 'W' und 'U')
                cycle_menu,close_menu:
                  -> Objektnummern der Pulldown-MenÅeintrÑge oder neg. Werte

    15. Popup-Funktion
        --------------

        POPUP-Struktur:
        ---------------
            typedef struct
            {
                /* Zeiger auf DIAINFO-Struktur des Parent-Dialogs
                   oder NULL */
                DIAINFO *p_info;

                /* Zeiger auf Objektbaum des Popups */
                OBJECT  *p_menu;

                /* Objektnummer des Info-Objekts (meistens Text links vom
                   Popup-Button) oder negativer Wert */
                int     p_parent;

                /* Objektnummer des Popup-Buttons oder negativer Wert */
                int     p_button;

                /* Objektnummer des Cycle-Buttons (dabei muû es sich nicht
                   um den erweiterten Typ CYCLE_BUTTON handeln) oder
                   negativer Wert */
                int     p_cycle;

                /* Beim Erreichen des ersten/letzten Eintrags mit den Cur-
                   sor-Tasten Hoch/Runter wird zum letzten/ersten Eintrag
                   gesprungen */
                boolean p_wrap;

                /* Der Text des Popup-Buttons wird automatisch auf den
                   Wert des aktuellen Eintrags gesetzt und nach dem Ende
                   der Popup-Bearbeitung neugezeichnet */
                boolean p_set;
            } POPUP;

        int Popup(POPUP *popup,int mode,int center,int x,int y,
                  int *index,int select)
            -> Popup 'popup' îffnen, bearbeiten und wieder schlieûen
            -> mode: Popup-Modus

                #define POPUP_BTN   0   /* Popup-Button wurde angeklickt */
                #define POPUP_CYCLE 1   /* Cycle-Button wurde angeklickt */
                #define POPUP_CHECK 2   /* HÑkchen vor aktuellem Eintrag */

                #define POPUP_BTN_CHK   (POPUP_BTN|POPUP_CHECK)
                #define POPUP_CYCLE_CHK (POPUP_CYCLE|POPUP_CHECK)
                #define POPUP_RADIO     POPUP_BTN_CHK
                #define POPUP_SELECT    POPUP_BTN

            -> center: Position des Popups

                #define CENTER    1 /* in Bildschirm zentrieren */
                #define MOUSEPOS  2 /* um Mauszeiger zentrieren */
                #define XPOS      3 /* X-Koordinate x, vertikal
                                       um Mauszeiger zentrieren */
                #define YPOS      4 /* Horizontal um Mauszeiger zentrieren,
                                       Y-Koordinate y */
                #define XYPOS     5 /* Koordinaten (x,y) */
                #define OBJPOS    6 /* um aktuellen Eintrag zentrieren oder
                                       wie XYPOS */

            -> select: aktueller Eintrag oder negativer Wert

            -> zurÅckgegeben wird die Objektnummer des selektierten Eintrags
               (oder 0) sowie in '*index' (sofern index!=NULL) der Index
               des selektierten Eintrags. Ist Bit 15 (0x8000) des RÅckgabe-
               wertes gesetzt, so wurde das Objekt per Doppelklick oder bei
               gedrÅckter Shift-Taste ausgewÑhlt

    16. XAcc-2- und AV-Protokoll-Funktionen
        -----------------------------------

        Die Library verwaltet intern alle An- und Abmeldungen der Proto-
        kolle XAcc2 und AV selbstÑndig.
        Ebenso werden die Nachrichten AV_SENDKEY sowie ACC_KEY automatisch
        in Keyboard-Events umgewandelt bzw. nicht ausgewertete Keyboard-
        Events werden als AV_SENDKEY bzw. ACC_KEY an den AV-Server oder die
        Hauptapplikation geschickt.
        Die Nachricht AV_PATH_UPDATE wird u.a. automatisch beim Aufruf der
        Funktion scrp_changed verschickt und sollte ansonsten nicht ver-
        schickt werden. Die Nachrichten VA_START und VA_DRAGACCWIND werden
        automatisch ausgewertet und in eine ARGS_DRAG-Nachricht umgewandelt.
        Weiterhin werden nicht unterstÅtzte XAcc2-Nachrichten mit einer
        ACC_ACK-FALSE-Nachricht beantwortet und per ACC_TEXT empfangene
        Texte werden im das aktuelle Eingabefeld im obersten Dialog einge-
        fÅgt. Ist das oberste Fenster kein Dialog, so wird die Nachricht
        an die Applikation weitergeleitet, sofern diese Nachricht unter-
        stÅtzt wird.

        Alle Fensterdialoge sowie Fenster, die mit den Funktionen
        open_window() und close_window() geîffnet bzw. geschlossen werden
        (abgesehen von applikationsmodalen Alertboxen), werden bei einem
        eventuell vorhandenen AV-Server an- bzw. abgemeldet.

        #define XACC    1   /* XAcc-Protokoll */
        #define AV      2   /* AV-Protokoll */

        XAcc-Struktur:
        --------------
        typedef struct
        {
            /* unterstÅtzte Protokolle (Bit 0: XAcc, Bit 1: AV) */
            int     flag;       /* XACC/AV */

            /* Applikations-Identifikation */
            int     id;              /* XAcc/AV-Protokoll */

            /* Bitmap der unterstÅtzten AV/VA-Nachrichten (Format
               s. Funktion init_gem())
            int     av_msgs,va_msgs; /* nur AV-Protokoll */

            /* Highbyte: Programmversionsnummer
               Lowbyte:  unterstÅtzte Nachrichtengruppen */
            int     version;         /* nur XAcc-Protokoll */

            /* ID des MenÅeintrags im Accessory-MenÅ */
            int     menu_id;         /* nur XAcc-Protokoll */

            /* AV-Programmname (8 Zeichen) fÅr appl_find */
            char    name[];          /* nur AV-Protokoll */

            /* (erweiterter) XAcc2-Programmname oder NULL */
            char    *xname;          /* nur XAcc-Protokoll */

            /* Zeiger auf 'XDSC'-Informationen oder NULL */
            char    *xdsc;           /* nur XAcc-Protokoll */
        } XAcc;

        void XAccBroadCast(int msg[8])
            -> Nachrichtenpuffer 'msg' an alle erreichbaren Applikationen
               verschicken

        int XAccSendAck(int sendto, int answer)
            -> ACC_ACK-RÅckmeldung 'answer' an Applikation 'sendto' senden
               (OK: answer!=0, Fehler: answer==0)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        int XAccSendKey(int sendto, int scan, int state)
            -> Tasten-Druck (Scancode 'scan', Status der Umschalttasten
               'state') an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendText(int sendto, char *txt)
            -> Zeichenkette 'txt' an Applikation 'sendto' senden
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendMeta(int sendto, int last, char *data, long len)
            -> Metafile-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int XAccSendImg(int sendto, int last, char *data, long len)
            -> GEM-Image-Block 'data' der LÑnge 'len' an Applikation 'sendto'
               senden (last!=0 -> letzter Datenblock)
            -> RÅckgabewert:
                TRUE:   Okay
                FALSE:  Fehler
                FAIL:   Timeout (keine BestÑtigung des EmpfÑngers)

        int AvSendMsg(int sendto,int msg_id,int msg[8])
            -> (AV-) Nachricht 'msg_id' an Applikation 'sendto' senden
               (Message-Puffer msg[3]-msg[7] enthÑlt gegebenenfalls weitere
               Daten)
            -> RÅckgabewert:
                TRUE:  Okay
                FALSE: Fehler

        XAcc *find_xacc_xdsc(int app_id,char *xdsc)
            -> erweiterten XAcc-Programmnamen der Applikation 'app_id' nach
               Zeichenkette 'xdsc' durchsuchen (app<0 -> alle XAcc-Appli-
               kationen durchsuchen)
            -> RÅckgabewert enthÑlt Zeiger auf XAcc-Struktur der
               Applikation, deren XAcc-Programmname die Zeichenkette ent-
               hÑlt, oder NULL, wenn die Zeichenkette nicht gefunden wurde

        XAcc *find_id(int app_id)
            -> XAcc-Struktur der Applikation 'app_id' ermitteln oder NULL,
               wenn es sich um keine XAcc-Applikation handelt

        XAcc *find_app(int first)
            -> XAcc-Struktur der ersten (first!=0) oder der nÑchsten
               (first==0) angemeldeten Applikation ermitteln (RÅckgabewert
               gleich NULL, wenn keine weitere Applikation gefunden wurde)

        int AppLoaded(char *name)
            -> Ermittelt die Applikations-ID der Anwendung mit dem
               Dateinamen 'name', welcher auch Pfad- und Laufwerksangaben
               enthalten darf.
            -> RÅckgabewert: Applikations-ID oder negativer Wert

     17. Drag & Drop-Funktionen
         ----------------------

        DRAG_DROP-Struktur:
        -------------------

        typedef struct
        {
            /* Art der ParameterÅbergabe */
            int dd_type;

                #define AV_DRAG     0 /* AV/Gemini-Drag&Drop */
                #define AV_START    1 /* VA_START-Nachricht */
                #define MINT_DRAG   2 /* MTOS-Drag&Drop */

            /* Applikations-ID des Senders */
            int dd_originator;

            /* Mausposition (oder negative Werte, falls nicht vom
               Benutzer verursacht bzw. Hintergrundfenster betroffen) */
            int dd_mx,dd_my;

            /* Status der Umschalttasten */
            int dd_kstate;

            /* Zeiger auf (Datei-) Namen oder NULL */
            char *dd_name;

            /* Zeiger auf Argumente (z.B. Kommandozeile) oder NULL. Die
               einzelnen Argumente/Dateinamen sind durch Leerzeichen ge-
               trennt, wobei Argumente, die Leerzeichen enthalten, inner-
               halb von Hochkommatas stehen (z.B. 'meine Datei'). Doppelte
               Hochkommatas stehen dann fÅr ein einzelnes Hochkommata
               (z.B. 'Christian''s Datei') */
            char *dd_args;

            /* Zeiger auf Åbergebene Daten oder NULL (dieser Speicher-
               bereich darf NICHT zur weiteren Verwendung benutzt wer-
               den, d.h. wird wieder freigegeben!) */
            char *dd_mem;

            /* LÑnge der in 'dd_mem' Åbergebenen Daten oder Null */
            long dd_size;

            /* Extension der in 'dd_mem' Åbergebenen Daten oder Leer-
               string ""
            char dd_ext[4];

            /* Zeiger auf WIN-Struktur des Fensters, auf das die Daten
               gezogen wurden, oder NULL, falls Hintergrund bzw. nicht
               vom Benutzer verursacht */
            WIN *dd_win;
        } DRAG_DROP;

        WICHTIG:
        --------
        Per Drag&Drop kînnen nur dann Daten empfangen werden, wenn mit
        Hilfe der Funktion Event_Handler() ein Ereignis-Handler angemeldet
        wurde, der die Drag&Drop-Nachricht 'OBJC_DRAGGED' auswertet.

        void SetDragDrop(int any_extension,char *exts)
             -> gewÅnschte/bevorzugte Dateierweiterungen fÅr das Drag&Drop-
                Protokoll festlegen. Dabei zeigt 'exts' auf eine Zeichen-
                kette mit DD_EXTSIZE Zeichen (mit Nullbytes auffÅllen), die
                die gewÅnschten Erweiterungen (z.B. ".TXT.ASC.ARGS") ent-
                hÑlt, wobei die Erweiterungen jeweils 4 Zeichen umfassen
                mÅssen und 'ARGS' fÅr Argumente steht. Wird fÅr den
                Parameter 'any_extension' TRUE Åbergeben, so wird jede
                Erweiterung akzeptiert. (voreingestellt ist, daû nur Argu-
                mente entgegengenommen werden.)

        int SendDragDrop(int msx,int msy,int kstate,char *name,
                         char *ext,long size,char *data)
             -> Daten per Drag&Drop-Protokoll an die Applikation senden,
                der das Fenster unter dem Mauszeiger gehîrt
             -> Parameter:
                msx,msy:  Mauskoordinaten
                kstate:   Status der Umschalttasten
                name:     Zeiger auf (Datei-) Namen der Daten oder NULL
                ext[4]:   Zeiger auf Zeichenkette, die die Erweiterung
                          bzw. den Typ der Daten enthÑlt
                size:     LÑnge der Daten
                data:     Adresse der Daten
             -> RÅckgabewert:
                NO_RECEIVER: Fenster oder EmpfÑnger nicht gefunden bzw. 
                             applikationseigenes Fenster
                NO_DD:       Drag&Drop-Pipe konnte nicht angelegt werden
                             (Betriebssystem unterstÅtzt kein Drag&Drop!)
                DD_NAK:      EmpfÑnger unterstÅtzt kein Drag&Drop
                DD_EXT:      EmpfÑnger kann Daten nicht empfangen (z.B.
                             unbekanntes Format)
                DD_LEN:      Nicht alle Daten konnten Åbermittelt werden
                             oder zuwenig Speicher
                DD_OK:       Alles in Ordnung

    18. Auskunftsfunktionen
        -------------------

        int appl_xgetinfo(int type,int *out1,int *out2,int *out3,int *out4);
            -> erweiterte appl_getinfo()-Routine, welche die Existenz von
               appl_getinfo() selbstÑndig ermittelt
            -> RÅckgabewerte wie bei appl_getinfo()

        int appl_getfontinfo(int font_type,int *height,int *id,int *type)
            -> Informationen Åber groûen (font_type=0) oder kleinen
               System-Font (font_type=1) ermitteln
            -> RÅckgabewerte:
                height: Font-Hîhe in Punkt
                id:     Font-ID
                type:   0 - System-Font
                        1 - FSM-Font

        int wind_xget(int w_handle, int w_field, int *w1, int *w2,
                      int *w3,int *w4);
            -> korrigierte wind_get()-Funktion fÅr erweiterte Aufrufe unter
               Winx sowie MTOS und zukÅnftigen Erweiterungen (die in der
               Pure C-GEM-Library bis V1.1 enthaltene, optimierte Routine
               funktioniert nicht mit neueren Aufrufen)

        int get_dialog_info(int *fly_dials,int *win_dials,int *wins,
                            DIAINFO **top);
            -> Informationen Åber geîffnete Dialoge und Fenster ermitteln
            -> RÅckgabewert: TRUE:  Ausgabe in beliebiges Fenster mîglich
                             FALSE: Ausgabe nur in obersten Dialog 'top'
                             FAIL:  Keine Ausgabe mîglich (z.B. Drop-Down-
                                    MenÅ heruntergeklappt oder Popup ge-
                                    îffnet)
               *fly_dials: Anzahl der geîffneten (fliegenden) Dialoge
                           (sofern fly_dials!=NULL)
               *win_dials: Anzahl der geîffneten Fenster-Dialoge (sofern
                           win_dials!=NULL)
               *wins:      Anzahl der geîffneten Fenster (sofern wins!=NULL)
                           inklusive der Fensterdialoge
               *top:       Zeiger auf obersten Dialog, falls RÅckgabewert
                           gleich FALSE (sofern top!=NULL)

    19. Datei-/Pfadfunktionen
        ---------------------

        void drive_changed(int drive)
            -> Inhalt des Laufwerks 'drive' (0=A,1=B,2=C,...,-1=alle Lauf-
               werke) wurde verÑndert (SH_WDRAW-Nachricht wird (per
               XAccBroadCast) an alle Applikationen gesendet)

        char *GetFilename(char *path)
            -> Zeiger auf Dateiname des Pfades 'path' ermitteln. EnthÑlt
               der Pfad keinen Dateinamen, so zeigt der RÅckgabewert auf
               das Ende (Nullbyte) des Pfades

        char *GetExtension(char *path)
            -> Zeiger auf Erweiterungs des Dateinamens des Pfades 'path'
               ermitteln. EnthÑlt der Pfad keinen Dateinamen oder keine
               Erweiterung, so zeigt der RÅckgabewert auf das Ende
               (Nullbyte) des Pfades

        char *GetPath(char *path)
            -> Dateiname des Pfades 'path' wird entfernt und ein Zeiger
               auf das Ende des Pfades (Nullbyte) zurÅckgegeben

        int GetDrive(char *path)
            -> Laufwerk des Pfades 'path' ermitteln
            -> RÅckgabewert: 0=A,1=B,2=C,...

        void MakeFullpath(char *dest,char *path,char *file)
            -> kompletten Pfadnamen aus Pfad 'path' (sofern path!=NULL,
               wobei der Pfad keinen abschlieûenden Backslash enthalten
               muû) und Datei 'file' erstellen und im String 'dest' zurÅck-
               geben. Wird fÅr den Pfad 'path' NULL Åbergeben, so muû
               sich der Pfad bereits in 'dest' befinden!

        int FileSelect(char *title,char *path,char *fname,char *sel,
                       int no_insel)
            -> Dateiselector aufrufen, wobei diese Funktion automatisch
               erkennt, ob ein erweiterter Fileselector vorliegt.
            -> Parameter:
               title:    Titel des Fileselectors
               path:     Pfad (sowohl Ein- als auch Ausgabeparameter)
               fname:    vorgegebene Datei (Eingabe) bzw. ausgewÑhlte Datei
                         (Ausgabe)
               sel:      Dateimaske oder NULL (in diesem Fall wird "*.*"
                         genommen)
               no_insel: keine vorgegebene Datei (no_insel!=0)
            -> RÅckgabewert:
               TRUE:  Datei wurde ausgewÑhlt
               FALSE: Keine Datei ausgewÑhlt oder Fehler aufgetreten

    20. Verschiedene Funktionen
        -----------------------

        void MouseOn(void);
        void MouseOff(void);
            -> Mauszeiger an/-ausschalten. Diese Funktionen merken sich
               intern, ob der Mauszeiger bereits an- oder ausgeschaltet
               ist.

        void MouseArrow(void);
        void MouseCursor(void);
        void MouseBee(void);
        void MouseHourGlass(void);
        void MousePointHand(void);
        void MouseFlatHand(void);
        void MouseThinCross(void);
        void MouseThickCross(void);
        void MouseOutlineCross(void);
            -> Mausform einstellen

        int sl_key(int scan,int ascii)
            -> Aus Scan-Code 'scan' und ASCII-Code 'ascii' Tastencode
               fÅr SLKEY-Struktur berechnen (bisher reines Ersetzungs-
               Makro)

        int scan_2_ascii(int scan,int state);
            -> Groûbuchstabe eines Tastendrucks aus Scan-Code 'scan' und
               Status der Umschalttasten 'state' ermitteln

        int min(int val1,int val2);
            -> Minimum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        int max(int val1,int val2);
            -> Maximum der Werte 'val1' und 'val2' berechnen und zurÅck-
               geben

        void Min(int *var,int val);
            -> Minimum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void Max(int *var,int val);
            -> Maximum von der Variablen '*var' und dem Wert 'val'
               berechnen und in der Variablen '*var' speichern

        void mfdb(MFDB *mfdb,int *bitmap,int width,int height,
                  int standard,int planes)
            -> Memory form definition block 'mfdb' initialisieren
            -> bitmap:       Zeiger auf Start der Bitmap
               width,height: Breite/Hîhe der Bitmap in Pixeln
               standard:     Standardformat (1) oder gerÑteabhÑngiges
                             Format
               planes:       Anzahl der Farbebenen der Bitmap

        long mfdb_size(MFDB *mfdb);
            -> Speicherbedarf der Bitmap des Memory form definition
               block 'mfdb' berechnen

        char LowerChar(char ch)
        char UpperChar(char ch)
            -> Zeichen 'ch' in Klein-/Groûbuchstaben umwandeln, wobei
               auch Umlaute beachtet werden

        void *GetMsgBuffer(long size)
            -> globalen Speicher (u.a. fÅr XAcc-2/AV-Kommunikation) der
               Grîûe 'size' anfordern
            -> RÅckgabewert wie bei Malloc()

    21. Definitionen hÑufig benîtigter (Protokoll-) Konstanten
        ------------------------------------------------------

        XAcc-2-Protokoll:
        -----------------
        (genaue Bedeutung s. XAcc-2-Dokumentation)

        #define ACC_ID      0x400
        #define ACC_OPEN    0x401
        #define ACC_CLOSE   0x402
        #define ACC_ACC     0x403
        #define ACC_EXIT    0x404

        #define ACC_ACK     0x500
        #define ACC_TEXT    0x501
        #define ACC_KEY     0x502
        #define ACC_META    0x503
        #define ACC_IMG     0x504

        AV-Protokoll:
        -------------
        (genaue Bedeutung s. AV-Dokumentation 'VA_PROTO.H')

        #define AV_PROTOKOLL        0x4700
        #define AV_GETSTATUS        0x4703
        #define AV_STATUS           0x4704
        #define AV_SENDKEY          0x4710
        #define AV_ASKFILEFONT      0x4712
        #define AV_ASKCONFONT       0x4714
        #define AV_ASKOBJECT        0x4716
        #define AV_OPENCONSOLE      0x4718
        #define AV_OPENWIND         0x4720
        #define AV_STARTPROG        0x4722
        #define AV_ACCWINDOPEN      0x4724
        #define AV_ACCWINDCLOSED    0x4726
        #define AV_COPY_DRAGGED     0x4728
        #define AV_PATH_UPDATE      0x4730
        #define AV_WHAT_IZIT        0x4732
        #define AV_DRAG_ON_WINDOW   0x4734
        #define AV_EXIT             0x4736

        #define VA_PROTOSTATUS      0x4701
        #define VA_SETSTATUS        0x4705
        #define VA_START            0x4711
        #define VA_FILEFONT         0x4713
        #define VA_CONFONT          0x4715
        #define VA_OBJECT           0x4717
        #define VA_CONSOLEOPEN      0x4719
        #define VA_WINDOPEN         0x4721
        #define VA_PROGSTART        0x4723
        #define VA_DRAGACCWIND      0x4725
        #define VA_COPY_COMPLETE    0x4729
        #define VA_THAT_IZIT        0x4733
        #define VA_DRAG_COMPLETE    0x4735

        #define VA_OB_UNKNOWN       0
        #define VA_OB_TRASHCAN      1
        #define VA_OB_SHREDDER      2
        #define VA_OB_CLIPBOARD     3
        #define VA_OB_FILE          4
        #define VA_OB_FOLDER        5
        #define VA_OB_DRIVE         6
        #define VA_OB_WINDOW        7

        MTOS-Drag&Drop-Protokoll:
        -------------------------
        (genaue Bedeutung s. MTOS-Entwickler-Dokumentation)

        #define AP_DRAGDROP         63

        #define DD_OK               0
        #define DD_NAK              1
        #define DD_EXT              2
        #define DD_LEN              3
        #define DD_TRASH            4
        #define DD_PRINTER          5
        #define DD_CLIPBOARD        6

        #define DD_TIMEOUT          4000

        #define DD_NUMEXTS          8
        #define DD_EXTSIZE          32L
        #define DD_NAMEMAX          128

        #define DD_HDRMAX           (8+DD_NAMEMAX)

        MenÅ-Protokoll:
        ---------------

        #define WM_CLOSED           0x0016  ^U
        #define WM_FULLED           0x0017  ^#* ('*' auf Ziffernblock)
        #define WM_SAVE             0x1000  ^S
        #define WM_SAVEAS           0x1001  ^M
        #define WM_PRINT            0x1002  ^P
        #define WM_UNDO             0x1003  Undo
        #define WM_CUT              0x1004  ^X
        #define WM_COPY             0x1005  ^C
        #define WM_PASTE            0x1006  ^V
        #define WM_SELECTALL        0x1007  ^A
        #define WM_FIND             0x1008  ^F
        #define WM_REPLACE          0x1009  ^R
        #define WM_FINDNEXT         0x100a  ^G
        #define WM_HELP             0x100b  Help
        #define WM_DELETE           0x100c  Delete

        View-Protokoll:
        ---------------
        (genaue Bedeutung s. View-Dokumentation V1.04)

        #define VIEW_FILE       0x5600
        #define VIEW_FAILED     0x5601
        #define VIEW_OPEN       0x5602
        #define VIEW_CLOSED     0x5603
        #define VIEW_DATA       0x5604
        #define VIEW_GETMFDB    0x5610        #define VIEW_SETMFDB    0x5611        #define VIEW_MFDB       0x5612

        #define VIEWERR_ERROR   0
        #define VIEWERR_SIZE    1
        #define VIEWERR_COLOR   2
        #define VIEWERR_WID     3
        #define VIEWERR_MEM     4

        Clipboard-Protokoll:
        --------------------
        (s.a. Beschreibung der Funktion scrp_changed())

        Aufbau der Nachricht:
            msg[0]          = SC_CHANGED (80)
            msg[1]          = apID
            msg[2]          = 0
            msg[3]          = Bitmap des Dateiformats
                              (Parameter 'format' von scrp_changed())
            msg[4],msg[5]   = 4 Zeichen fÅr die "beste" der abgespeicherten
                              Dateien (z.B. ".RTF"), damit beim Lesen mîg-
                              lichst wenig Information verloren geht
                              (Parameter 'best_ext' von scrp_changed())
            msg[6],msg[7]   = reserviert (auf Null setzen!)


        Scan-Codes:
        -----------

        #define SCANESC     1       /* Esc */
        #define SCANTAB     15      /* Tab */
        #define SCANRET     28      /* Return */
        #define SCANDEL     83      /* Delete */
        #define SCANBS      14      /* Backspace */
        #define SCANENTER   114     /* Enter */

        #define SCANHELP    98      /* Help */
        #define SCANUNDO    97      /* Undo */
        #define SCANINS     82      /* Insert */
        #define SCANHOME    71      /* Clr/Home */

        #define SCANUP      72      /* Up */
        #define SCANDOWN    80      /* Down */

        #define SCANLEFT    75      /* Left */
        #define SCANRIGHT   77      /* Right */

        #define CTRLLEFT    115     /* Ctrl-Left */
        #define CTRLRIGHT   116     /* Ctrl-Right */

        #define SCANF1      59      /* F1 - F10 */
        ...
        #define SCANF10     68

        #define CTRLF1      84      /* CTRL-F1 - CTRL-F10 */
        ...
        #define CTRLF10     93
