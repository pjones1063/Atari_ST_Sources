Hinweise fÅr Programmierer:
===========================

Programme, die VMEM V1.1 verwenden, kînnen nur dann gestartet werden, wenn
VMEM.PRG installiert werden konnte. Andernfalls werden alle Funktionsaufrufe
mit einem Fehlercode zurÅckgewiesen. Deshalb sollte man unmittelbar nach der
Konfiguration den Fehlercode auf 0 abprÅfen und andernfalls das Programm mit
einer Fehlermeldung abbrechen.

Vor der Konfiguration des virtuellen Speichers sollten bestimmte Parameter
vom Anwender erfragt werden. Dies ist vor allem bei der Wahl der Partition
fÅr die temporÑre Datei, bei der Grîûe des Cache-Speichers sowie bei der
maximalen Grîûe des virtuellen Speichers sinnvoll. Nach der Konfiguration
sollte man es vermeiden, Dateien auf die Partition zu kopieren, auf der sich
die temporÑre Datei befindet, da man ansonsten wÑhrend der Laufzeit einen
_NULL-Zeiger bei einem VM_ALLOC-Aufruf erhalten kînnte, falls nicht mehr
genÅgend freier Platz zur VerfÅgung steht.

Der Speicherbedarf im Hauptspeicher berechnet sich nach folgender Formel:

    3 * maximale Anzahl Seiten im virtuellen Speicher
  + 4 * Anzahl Seiten im Cache
  + Grîûe des Caches in Bytes
  + Grîûe einer Seite des virtuellen Speichers
----------------------------------------------------
  = Grîûe des zusÑtzlichen Speicherbedarfs in Bytes

Dieser Speicher wird bei dem VM_CONFIG-Aufruf automatisch angefordert und
gehîrt somit zum aktuellen Programm hinzu. Es ist derzeit nicht mîglich,
aus dem laufenden Programm heraus ein anderes, VMEM-nutzendes Programm
aufzurufen. Wird dies nicht beachtet, so ist mit dem Verlust der gesamten
Daten im virtuellen Speicher zu rechnen!!

FÅr bestimmte Parameter sind nur die in der Datei VMEM.H definierten Werte
zulÑssig. Vor allem die Werte fÅr READ_MODE und WRITE_MODE fÅr die Funktion
VM_ADDRESS sind unbedingt beizubehalten, da andere Werte fÅr ein groûes
Chaos sorgen wÅrden.

Beim Zugriff auf die Daten des virtuellen Speichers ist folgendes zu beachten:
Wenn man mittels VM_ADDRESS einen Zeiger auf einen bestimmten Speicherbereich
erhalten hat, so ist nach Aufruf einer anderen VMEM-Funktion dieser Zeiger als
ungÅltig anzusehen, da sich der Inhalt des Caches verÑndert haben kînnte. Des-
halb sollte man vor dem nÑchsten Zugriff auf den Cache wieder VM_ADDRESS auf-
rufen. Wenn die Cache-Verwaltung feststellt, daû sich die betreffenden Seiten
immer noch im Cache befinden, so erfolgt kein Zugriff auf die Platte und man
hat nur eine geringe Verzîgerung. Man muû jedoch beachten, daû man einen ande-
ren Zeiger bekommen kann, da die Verwaltung den Cache reorganisieren kann.

Die maximale Grîûe des virtuellen Speichers betrÑgt 65536*32768 Bytes (oder
anders ausgedrÅckt: 2 Gigabyte !!) Da diese Datenmenge von keinem bisher er-
hÑltlichen Programm erzeugt wird und die brauchbarste Seitengrîûe 4 KByte
betrÑgt, ist die sinnvolle Obergrenze derzeit bei 256 MByte. Da eine DIN A4
Seite, die mit 256 Graustufen gescannt wurde, ca. 8 MByte (ungepackt) belegt,
ist eine virtuelle Speicherverwaltung trotz der langsameren Zugriffsgeschwin-
digkeit von enormen Vorteil, da sie auf jedem Atari ST und TT mit Festplatte
einsetzbar ist. Die einzige Voraussetzung ist etwas Platz auf der Platte, um
die temporÑre Datei, die den virtuellen Speicher beinhaltet, anlegen zu kînnen.

Die Wahl der Seitengrîûe ist abhÑngig von dem gewÅnschten Einsatzgebiet: soll
VMEM z.B. in einem Zeichenprogramm eingesetzt werden, so ist SIZE_32768 die
ideale Grîûe, da auf die Zeichnung selbst meistens linear zugegriffen wird.
Wenn man aber eine Datenbank mit VMEM aufbaut und ein Datensatz z.B. 300 Byte
belegt, sollte man SIZE_1024 wÑhlen.

Generell gilt: wenn auf Daten im virtuellen Speicher zusammenhÑngend zuge-
griffen wird, so sind groûe Seiten praktischer. FÅr einen wahlfreien Zugriff
eignen sich hingegen kleine Seiten, da besonders bei vielen Zugriffen viele
Seiten aus dem Cache ausgelagert werden mÅssen und die geringe Grîûe einer
Seite das Ein- und Auslagern beschleunigt.

******************************************************************************

FunktionsÅbersicht (Version 1.1):
=================================

Hinweis:    in der Datei VMEM.H finden sich sÑmtliche Definitionen


VM_CONFIG:      int vm_config (TAB *parameter)
----------

Mit dieser Funktion wird der virtuelle Speicher sowie der fÅr die Verwaltung
nîtige Hauptspeicher konfiguriert und initialisiert. Hierzu Åbergibt man die
folgenden Informationen mit Hilfe der Struktur TAB:

TAB
{
    WORD    version;
    WORD    count_page;
    WORD    cache_size;
    WORD    page_type;
    int     fill_value;
    int     drive_no;
};

version:    enthÑlt die Versionsnummer des TAB-Parameterblocks (derzeit 256
            bzw. 0x100). Auf diese Art und Weise ist es mîglich, auch in
            spÑteren Versionen von VMEM das Programm unverÑndert laufen zu
            lassen, da VMEM sich an der Versionsnummer orientiert. Diese
            Variable sollte deshalb vorerst immer den Wert 256 erhalten.

count_page: bestimmt die maximale Anzahl an Seiten im virtuellen Speicher.
            Je grîûer dieser Wert ist, desto grîûer kann auch der virtuelle
            Speicher werden. Jedoch erhîht sich damit auch der zusÑtzliche
            Speicherbedarf, da fÅr jede Seite ein Byte belegt wird.

cache_size: bestimmt die Anzahl der Seiten, die in den Cache passen. Man
            sollte diesen Wert nicht zu klein wÑhlen, da man ansonsten keine
            groûen Blîcke mittels VM_ADDRESS ansprechen kann. Der Cache
            sollte in der Lage sein, 10% des virtuellen Speichers aufnehmen
            zu kînnen. Das Minimum betrÑgt 4 Seiten.

page_type:  hiermit wÑhlt man die Grîûe einer Seite aus. Je grîûer eine Seite
            ist, desto grîûer kann man den virtuellen Speicher machen. Man
            muû aber beachten, daû eine Seite von 32 KByte mehr Zeit benîtigt
            zum Ein- und Auslagern als eine 4 KByte-Seite. Diese Variable
            sollte deshalb vorerst den Wert SIZE_4096 erhalten, da die anderen
            Werte nur in einigen bestimmten FÑllen Vorteile bieten.

fill_value: bestimmt den FÅllwert einer Seite, falls das erste Mal darauf zu-
            gegriffen wird. Man kann somit bestimmte Seiten mit einem FÅllwert
            belegen, ohne auf diese Seiten jemals einen Schreibzugriff gemacht
            zu haben (praktisch z.B. fÅr leere Stellen in einer Grafik).

drive_no:   legt das Laufwerk fest, auf dem die temporÑre Datei angelegt
            werden soll. Das Laufwerk A und B ungeeignet sind, beginnt die
            ZÑhlung bei 3 (= Laufwerk C). Auf diesem Laufwerk sollte noch
            soviel Platz sein, um die VM_ALLOC-Aufrufe erfÅllen zu kînnen.
            Man muû also nicht Platz fÅr den gesamten virtuellen Speicher
            haben, jedoch sollte man Dateien, die vom aktuellen Programm er-
            stellt werden, nicht unbedingt auf die gleiche Partition speichern.
            Wenn man jedoch alle VM_ALLOC-Aufrufe getÑtigt hat, so ist die
            temporÑre Datei in ihrer maximalen Grîûe vorhanden und der ver-
            bleibende Restspeicher der Partition kann genutzt werden. Deshalb
            sollte man, falls mîglich, direkt nach der Konfiguration den be-
            nîtigten virtuellen Speicher anfordern.

Ergebnis der Funktion:

= 0:        der virtuelle Speicher und die Verwaltungsinformation konnte
            konfiguriert und installiert werden, alles ist OK.

> 0:        das Programm kann nicht weitermachen, da VMEM.PRG nicht installiert
            worden ist. Alle folgenden Aufrufe liefern -1 zurÅck.

< 0:        Falls der Code zwischen -1 und -255 liegt, so ist ein TOS-Fehler
            aufgetreten. Andernfalls handelt es sich hierbei um einen in der
            Datei VMEM.H nÑher spezifizierten Fehler.

Es gibt leider keinen allgemeingÅltigen Tip, wie groû man den Cache und den
Hauptspeicher machen soll. So kann es sinnvoll sein, einen 1 MByte Haupt-
speicher und einen 512 Kbyte Cache anzulegen, um eine mîglichst geringe
Anzahl an Festplattenzugriffen zu erreichen. Aber auch ein Hauptspeicher mit
2 MByte kann mit einem Cache von nur 20 Kbyte genutzt werden. Je grîûer der
Cache ist, desto geringer wird i.A. die Anzahl der Plattenzugriffe.


VM_INFO:        V_INFO *vm_info (void)
--------

VM_INFO liefert nach einem VM_CONFIG-Aufruf einige Daten. Diese Daten stehen
in der Struktur V_INFO, die in der Datei VMEM.H wie folgt definiert ist:

V_INFO
{
    WORD    version;
    WORD    count_page;
    WORD    count_blocks;
    WORD    free_blocks;
    int     fill_value;
    long    cache_size;
    WORD    cache_count;
    long    page_size;
    long    max_size;       /* Maximalgrîûe des virtuellen Speichers */
    long    max_alloc;      /* Maximalgrîûe eines einzelnen Blocks */
    int     drive_no;
    long    drive_free;
};

version:        Versionsnummer des installierten VMEM-Steuerprogramms. Format:
                0x100 oder 256 entspricht V1.00, 0x101 oder 257 ist V1.1 usw.
                Diese Versionsnummer dient derzeit nur zur Information.

count_page:     ist der Parameter, der bei VM_CONFIG im Feld <count_page>
                Åbergeben wurde.

count_blocks:   enthÑlt die Anzahl der maximal mîglichen VM_ALLOC-Aufrufe.
                Falls nach <count_blocks> Aufrufen weitere VM_ALLOC folgen,
                so werden diese mit _NULL beantwortet.
                Derzeit sind maximal 256 Aufrufe mîglich, bevor mindestens
                ein VM_FREE-Aufruf erfolgen muû.

free_blocks:    gibt die Anzahl der noch mîglichen Aufrufe an. Falls der Wert
                gleich 0 ist, so muû vorher mindestens ein VM_FREE-Aufruf er-
                folgen.

fill_value:     ist der bei VM_CONFIG im Feld <fill_value> Åbergebene FÅllwert.

cache_size:     gibt die Grîûe des Caches in Bytes an. Man kann die Grîûe des
                Caches auch nach folgender Formel berechnen:
                Grîûe = Anzahl Cache-Seiten * Grîûe einer Seite in Bytes

cache_count:    ist die bei VM_CONFIG im Feld <cache_size> Åbergebene Anzahl
                an Seiten, die fÅr den Cache verwendet werden sollen.

page_size:      gibt die Grîûe einer Seite in Bytes an.

max_size:       gibt die maximale Grîûe des virtuellen Speichers in Bytes an.

max_alloc:      bestimmt die maximale Grîûe eines Blockes, der durch VM_ALLOC
                belegt werden kann.

drive_no:       ist die Nummer des Laufwerks, auf dem die temporÑre Datei an-
                gelegt wurde.

drive_free:     gibt den freien Speicher des Laufwerks in Bytes an, auf dem die
                temporÑre Datei angelegt wurde.

Ergebnis der Funktion:

                Zeiger auf eine Struktur vom Typ V_INFO

Alle in V_INFO aufgefÅhrten Werte haben rein informativen Charakter. Wichtig
fÅr den Programmierer sind eigentlich nur die Parameter <count_blocks>,
<free_blocks> und <max_alloc>.


VM_CLOSE:       void vm_close (void)
---------

Nach Beendigung aller Arbeiten sollte man die temporÑre Datei sowie den fÅr die
Verwaltungsinformation belegten Speicher freigeben. Dies erfolgt mit Aufruf der
Prozedur VM_CLOSE. Nach VM_CLOSE ist nur noch VM_CONFIG zulÑssig.


VM_CLRCACHE:     void vm_clrcache (void)
------------

Mit dieser Funktion wird der Cache neu initialisiert. Dabei werden Seiten, die
sich noch im Cache befinden, herausgeschrieben. Ein Aufruf dieser Funktion ist
dann sinnvoll, wenn z.B. in einem Zeichenprogramm ein neues Bild bearbeitet
werden soll, da somit die Daten des vorherigen Bildes aus dem Cache entfernt
werden. Wichtig: die im Cache befindlichen Daten werden nicht gelîscht, da sie
vorher in die temporÑre Datei gesichert werden. Diese Funktion sollte man nur
ab und zu verwenden, da sie die eigentliche Aufgabe des Caches (Vermeidung von
Plattenzugriffen) negativ beeinfluût.


VM_ALLOC:       V_ADR vm_alloc (long size)
---------

Wenn der Åbergebene Parameter <size> kleiner als 0 ist, so wird die Grîûe des
grîûten zusammenhÑngenden freien Speicherblocks bestimmt und zurÅckgegeben.

Ansonsten wird <size> auf volle Seiten aufgerundet. Dies bedeutet, daû eine
Anforderung von 10 Byte und eine Anforderung von 2 KByte bei einer Seitengrîûe
von 4 KByte immer eine volle Seite belegt. Danach wird versucht, einen Block
der neuen Grîûe <size> zu allokieren. Falls dies nicht mîglich ist (z.B. zu
wenig Speicher), dann wird _NULL zurÅckgeliefert. Andernfalls erhÑlt man eine
Adresse des virtuellen Speichers, wobei kein Zeiger, sondern ein LONG (genau
genommen: V_ADR) Åbergeben wird.


VM_FREE:        int vm_free (V_ADR address)
--------

Mit dieser Funktion kann man einen vorher mit VM_ALLOC belegten Speicherbereich
wieder freigeben. Als Ergebnis erhÑlt man OK, falls der Block freigegeben
werden konnte, und NOT_OK, falls ein Block mit dieser Adresse nicht existierte.


VM_ADDRESS:     char *vm_address (V_ADR address, long *window_size, int mode)
-----------

Um ein "Fenster" zu setzen, verwendet man die Funktion VM_ADDRESS. Dabei wird
versucht, einen aus <window_size> Bytes bestehenden Speicherbereich in den
Cache einzulagern. Falls dies nicht mîglich ist, weil entweder <address> zu
nah am Ende des Speicherblocks oder <window_size> grîûer als der Cache ist,
dann wird der Parameter <window_size> mit dem grîûtmîglichen Wert versorgt.
Deshalb sollte man nach Aufruf von VM_ADDRESS nicht mehr als die in
<window_size> Åbergebene Anzahl an Bytes adressieren, da ansonsten andere
Daten verÑndert werden kînnten. Normalerweise sollte der Wert von <window_size>
hîchstens halb so groû wie der Cache sein.

<address> gibt die Startadresse im virtuellen Speicher an, ab der man Bytes
lesen oder schreiben mîchte. Wenn man die Bytes nur lesen mîchte, so sollte
man <mode> auf READ_MODE setzen, da dies die Verwaltung des Caches informiert,
daû diese Seiten nicht verÑndert wurden. VerÑndert man dennoch den Inhalt, so
sind diese Seiten im weiteren Verlauf nicht mehr konsistent. Wenn man jedoch
Bytes schreiben mîchte, so muû man <mode> auf WRITE_MODE setzen.

Im Falle eines Fehler erhÑlt man ILLEGAL_ADDRESS, falls auf einen nicht vor-
handenen Speicherbereich zugegriffen wird, ILLEGAL_COUNT, falls die gewÅnschte
Grîûe des Fensters kleiner oder gleich 0 ist, und ILLEGAL_MODE, falls fÅr <mode>
ein anderer Wert als READ_MODE oder WRITE_MODE angegeben wurde.

Wenn die Seiten ohne Probleme in den Cache eingelagert werden konnten, so wird
als Ergebnis ein Zeiger auf das erste Byte im Cache, das man mit <address> spe-
zifiziert hat, zurÅckgeliefert.

Auf keinen Fall darf man Daten adressieren, die unterhalb des als Ergebnis er-
haltenen Zeigers liegen. Auch die Daten, die ab <Ergebnis> + <window_size> sich
befinden, sind tabu.


VM_FILL:        long vm_fill (V_ADR address, long count, int value)
--------

Um bestimmte Stellen des virtuellen Speichers schnell mit einem bestimmten Wert
zu fÅllen, sollte man VM_FILL verwenden. Hierzu Åbergibt man die Startadresse
im virtuellen Speicher sowie die Anzahl der Bytes und den gewÅnschten FÅllwert.
Wenn fÅr <count> -1 Åbergeben wird, so wird der Speicherbereich von <address>
bis zum Ende des Speicherblocks mit <value> gefÅllt. Ansonsten wird unter Be-
rÅcksichtigung von <count> gefÅllt. Sollte dabei das Ende des Speicherblocks
erreicht werden, so wird an dieser Stelle abgebrochen.

Als Ergebnis erhÑlt man entweder eine Fehlermeldung (ILLEGAL_ADDRESS fÅr eine
falsche Adresse bzw. ILLEGAL_COUNT falls <count> kleiner als -1 ist) oder man
erhÑlt die Anzahl der geschriebenen Bytes.


VM_LOAD:        long vm_load (V_ADR source, char *destination, long count)
--------

Mit der Funktion VM_LOAD kann man einen zusammenhÑngenden Speicherbereich aus
dem virtuellen Speicher in den physikalischen Speicher kopieren. Hierbei gelten
fÅr <source> und <count> die gleichen EinschrÑnkungen wie fÅr <address> und
<count> bei VM_FILL. Zu beachten ist noch, daû einen gÅltige Zieladresse Åber-
geben wird.


VM_SAVE:        long vm_save (char *source, V_ADR destination, long count)
--------

Die Funktion VM_SAVE ist das direkt GegenstÅck zu VM_LOAD. Hierbei wird ein zu-
sammenhÑngender Speicherbereich in den virtuellen Speicher kopiert. Auch hier
gelten fÅr <destination> und <count> die gleichen EinschrÑnkungen wie fÅr die
Parameter bei VM_FILL.

Die beiden Funktionen VM_LOAD und VM_SAVE sind besonders gut zum schnellen Aus-
tausch von Daten zwischen dem physikalischen und dem virtuellen Speicher ge-
eignet (z.B. beim Einsatz in einer UNDO-Funktion eines Zeichenprogrammes).


VM_READ:        long vm_read (int handle, long count, V_ADR dest)
--------

Das Einlesen von Daten aus einer Datei in den virtuellen Speicher erfolgt mit
VM_READ. Hierzu muû die Datei mit der GEMDOS-Funktion Fopen geîffnet worden
sein. Danach Åbergibt man das erhaltene Dateihandle, die Anzahl der zu lesen-
den Bytes sowie die Zieladresse im virtuellen Speicheran die Funktion.
FÅr die Parameter <count> und <dest> gelten die EinschrÑnkungen von VM_FILL.

Als Ergebnis erhÑlt man entweder eine VMEM-Fehlermeldung (ILLEGAL_ADDRESS oder
ILLEGAL_COUNT), eine TOS-Fehlermeldung (-1 bis -255) oder die Anzahl der ge-
lesenen Bytes.


VM_WRITE:       long vm_write (int handle, long count, V_ADR source)
---------

Um einen Bereich des virtuellen Speichers in eine Datei sichern zu kînnen, ver-
wendet man VM_WRITE. Die Parameter haben hier die gleiche Bedeutung wie bei
VM_READ. <handle> stammt entweder von einem Fopen oder Fcreate - Aufruf.

Als Ergebnis erhÑlt man entweder eine VMEM-Fehlermeldung (ILLEGAL_ADDRESS oder
ILLEGAL_COUNT), eine TOS-Fehlermeldung (-1 bis -255) oder die Anzahl der ge-
schriebenen Bytes.

******************************************************************************

Fehlermeldungen von VMEM:
=========================

ILLEGAL_FUNCTION:
Die gewÅnschte Funktion ist nicht vorhanden

WRONG_CACHE_SIZE:
Die angegebene Cache-Grîûe ist nicht sinnvoll

WRONG_PAGE_TYPE:
Der angegebene Seitentyp existiert nicht

OUT_OF_MEMORY:
Der physikalische Speicher ist nicht groû genug, um den Cache und die Verwal-
tungsinformationen aufzunehmen

FILE_ERROR:
Es ist ein Fehler beim Zugriff auf die Datei aufgetreten (= TOS-Fehler -1)

NOT_ENOUGH_SPACE  bzw.  _NULL:
Auf der Partition, auf der sich die temporÑre Datei befindet, ist nicht mehr
genÅgend Platz frei, um weitere VM_ALLOC-Aufrufe zu erfÅllen

NOT_OK:
Ein freizugebender Speicherblock mit dieser Adresse existiert nicht

ILLEGAL_ADDRESS:
Die virtuelle Adresse zeigt auf einen nicht vorhandenen Speicherbereich

ILLEGAL_COUNT:
Die angegebene Anzahl ist kleiner oder gleich 0

ILLEGAL_FATSIZE:
Das Ziellaufwerk fÅr die temporÑre Datei verwendet eine FAT, die nicht aus
16-Bit-EintrÑgen besteht

******************************************************************************

Benutzung von VMEM in eigenen Programmen:
=========================================

Ein Programm, das VMEM nutzen will, sollte ungefÑhr folgenden Aufbau haben:

        ...
        ...
 Abfrage der Anwenderspezifischen VMEM-Daten (Partition, Grîûe, usw.)
 Initialisierung des VM_CONFIG-Parameterblocks
 Aufruf von VM_CONFIG
 Falls der RÅckgabewert ungleich 0 ist, Fehler melden und Programm beenden
        ...
        ...
 Speicheranforderung(en) mittels VM_ALLOC
 Falls der Zeiger den Wert _NULL hat, Fehler melden und Programm beenden
        ...
        ...
 Zugriff(e) auf den virtuellen Speicher
 (VM_ADDRESS, VM_FILL, VM_LOAD, VM_SAVE, VM_READ, VM_WRITE)
 RÅckgabewerte der Funktionen auf Fehler abprÅfen und eventuell abbrechen
 (VM_CLOSE nicht vergessen !!)
        ...
        ...
 Freigeben des belegten Speichers mittels VM_FREE
 (unmittelbar vor VM_CLOSE ist dies nicht notwendig)
        ...
        ...
 Entfernen der temporÑren Datei sowie des belegten Hauptspeichers fÅr die
 Verwaltungsinformation mittels VM_CLOSE
        ...
        ...
 Ab jetzt darf kein Zugriff mehr auf VMEM-Funktionen mit Ausnahme von
 VM_CONFIG erfolgen !!!
        ...
        ...

******************************************************************************

Linken von Programmen mit VMEM-Funktionen:
==========================================

Beim Linken von Programmen, die VMEM benutzen, muû die Datei VMEM.LIB (Pure-
Format) verwendet werden. Man kann auch die Datei VMEM.S (Assembler-Source
der Bibliothek) verwenden. Diese Bibliothek beinhaltet die eigentlichen Auf-
rufe der VMEM-Funktionen fÅr den Pure C - Compiler. FÅr andere Compiler muû
man die Aufrufe wahrscheinlich umschreiben. Hinweise, was man dabei beachten
muû, stehen am Anfang der Datei VMEM.S.

