
/*  A Bison parser, made from a56.y with Bison version GNU Bison version 1.22
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	CHEX	258
#define	CDEC	259
#define	FRAC	260
#define	AREG	261
#define	BREG	262
#define	MREG	263
#define	NREG	264
#define	RREG	265
#define	XREG	266
#define	YREG	267
#define	OP	268
#define	OPA	269
#define	OPP	270
#define	OP_JCC	271
#define	OP_JSCC	272
#define	OP_TCC	273
#define	SYM	274
#define	STRING	275
#define	CHAR	276
#define	XMEM	277
#define	YMEM	278
#define	LMEM	279
#define	PMEM	280
#define	AAAA	281
#define	A10	282
#define	BBBB	283
#define	B10	284
#define	AABB	285
#define	BBAA	286
#define	XXXX	287
#define	YYYY	288
#define	SR	289
#define	MR	290
#define	CCR	291
#define	OMR	292
#define	SP	293
#define	SSH	294
#define	SSL	295
#define	LA	296
#define	LC	297
#define	EOL	298
#define	EOS	299
#define	LEXBAD	300
#define	OP_ABS	301
#define	OP_ADC	302
#define	OP_ADD	303
#define	OP_ADDL	304
#define	OP_ADDR	305
#define	OP_ASL	306
#define	OP_ASR	307
#define	OP_CLR	308
#define	OP_CMP	309
#define	OP_CMPM	310
#define	OP_DIV	311
#define	OP_MAC	312
#define	OP_MACR	313
#define	OP_MPY	314
#define	OP_MPYR	315
#define	OP_NEG	316
#define	OP_NORM	317
#define	OP_RND	318
#define	OP_SBC	319
#define	OP_SUB	320
#define	OP_SUBL	321
#define	OP_SUBR	322
#define	OP_TFR	323
#define	OP_TST	324
#define	OP_AND	325
#define	OP_ANDI	326
#define	OP_EOR	327
#define	OP_LSL	328
#define	OP_LSR	329
#define	OP_NOT	330
#define	OP_OR	331
#define	OP_ORI	332
#define	OP_ROL	333
#define	OP_ROR	334
#define	OP_BCLR	335
#define	OP_BSET	336
#define	OP_BCHG	337
#define	OP_BTST	338
#define	OP_DO	339
#define	OP_ENDDO	340
#define	OP_LUA	341
#define	OP_MOVE	342
#define	OP_MOVEC	343
#define	OP_MOVEM	344
#define	OP_MOVEP	345
#define	OP_ILLEGAL	346
#define	OP_INCLUDE	347
#define	OP_JMP	348
#define	OP_JCLR	349
#define	OP_JSET	350
#define	OP_JSR	351
#define	OP_JSCLR	352
#define	OP_JSSET	353
#define	OP_NOP	354
#define	OP_REP	355
#define	OP_RESET	356
#define	OP_RTI	357
#define	OP_RTS	358
#define	OP_STOP	359
#define	OP_SWI	360
#define	OP_WAIT	361
#define	OP_EQU	362
#define	OP_ORG	363
#define	OP_DC	364
#define	OP_DS	365
#define	OP_DSM	366
#define	OP_END	367
#define	OP_PAGE	368
#define	OP_PSECT	369
#define	OP_ALIGN	370
#define	OP_INT	371
#define	SHL	372
#define	SHR	373

#line 1 "a56.y"

/*******************************************************
 *
 *  a56 - a DSP56001 assembler
 *
 *  Written by Quinn C. Jensen
 *  July 1990
 *
 *******************************************************/

/*
 * Copyright (C) 1990-1994 Quinn C. Jensen
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  The author makes no representations
 * about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 */

/*
 *  a56.y - The YACC grammar for the assembler.
 *
 *  Note:  This module requires a "BIG" version of YACC.  I had to
 *  recompile YACC in the largest mode available.
 *
 *  Other notes:
 *
 *  MOVEC, MOVEM and MOVEP must be used explicitly--MOVE can't yet figure
 *  out which form to use.
 *
 */

#include "a56.h"

unsigned int w0, w1;			/* workspace for the actual generated code */
BOOL uses_w1;					/* says whether w1 is alive */
unsigned int pc;				/* current program counter */
int seg;						/* current segment P: X: Y: or L: */

int just_rep = 0;				/* keeps track of REP instruction */
int substatement = 0;			/* in a substatement */
BOOL long_symbolic_expr = FALSE; /* a parser flag */
char *new_include = NULL;		/* file to be included */

/* listing stuff */

char segs[] = "PXYL";
extern BOOL list_on_next;		/* listing to turn on or off */
BOOL list_on;					/* listing on at the moment */
extern char *cur_line;			/* points to line being lex'd */
char list_buf[1024 + 80];		/* listing buffer */
char list_buf2[1024 + 80];		/* listing buffer for two-line code */
BOOL uses_buf2 = FALSE;			/* list_buf2 is alive */
BOOL list_print_line = FALSE;	/* whether or not to print line in listing */
char *spaces(), *luntab();

struct n binary_op();
struct n unary_op();
struct n sym_ref();

#define R_R6				0x0001
#define R_R5				0x0002
#define R_R4				0x0004
#define R_DATA_ALU_ACCUM	0x0008
#define R_CTL_REG			0x0010
#define R_FUNKY_CTL_REG		0x0020
#define R_SDX				0x0040
#define R_SDY				0x0080
#define R_LSD				0x0100
#define R_AB				0x0200
#define R_XREG				0x0400
#define R_YREG				0x0800
/* registers to which short immediate move is an unsigned int */
#define R_UINT				0x1000
/* registers to which short immediate move is an signed frac */
#define R_SFRAC				0x2000

#line 83 "a56.y"
typedef union {
	int ival;			/* integer value */
	struct n n;			/* just like in struct sym */
	double dval;		/* floating point value */
	char *sval;			/* string */
	int cval;			/* character */
	char cond;			/* condition */
	struct regs {
		int r6, r5, r4, data_alu_accum, ctl_reg, funky_ctl_reg;
		int sdx, sdy, lsd, ab, xreg, yreg;
		int flags;
	} regs;
	struct ea {
		int mode;
		int ext;
		int pp;
	} ea;
} YYSTYPE;

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		539
#define	YYFLAG		-32768
#define	YYNTBASE	135

#define YYTRANSLATE(x) ((unsigned)(x) <= 373 ? yytranslate[x] : 208)

static const short yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,   128,     2,   126,   121,     2,   131,
   132,   124,   122,   130,   123,     2,   125,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,   129,     2,   133,
     2,   134,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,   120,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,   119,     2,   127,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
   116,   117,   118
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     4,     7,    10,    13,    14,    16,    18,    21,
    23,    27,    31,    34,    37,    44,    48,    55,    59,    63,
    67,    76,    79,    81,    85,    87,    89,    91,    93,    95,
    97,    99,   101,   102,   104,   105,   107,   109,   111,   114,
   117,   120,   123,   126,   129,   132,   134,   137,   140,   143,
   146,   149,   152,   155,   158,   161,   164,   167,   170,   173,
   176,   179,   182,   185,   188,   191,   194,   197,   200,   203,
   206,   211,   213,   215,   216,   220,   224,   228,   232,   236,
   240,   244,   248,   252,   256,   260,   264,   268,   272,   274,
   276,   280,   284,   286,   290,   294,   296,   298,   302,   306,
   308,   310,   312,   314,   316,   318,   323,   326,   331,   336,
   338,   340,   342,   344,   347,   350,   353,   356,   359,   362,
   365,   368,   371,   374,   376,   378,   380,   382,   384,   386,
   388,   390,   392,   396,   400,   405,   410,   415,   417,   419,
   422,   425,   428,   435,   441,   443,   445,   447,   449,   452,
   455,   458,   461,   466,   470,   472,   474,   476,   479,   482,
   485,   490,   493,   495,   500,   504,   508,   513,   518,   522,
   527,   532,   536,   542,   547,   553,   559,   564,   569,   571,
   573,   575,   580,   585,   587,   589,   591,   593,   595,   597,
   599,   601,   603,   605,   609,   615,   620,   626,   632,   637,
   642,   644,   646,   648,   650,   652,   654,   656,   658,   660,
   662,   664,   666,   668,   670,   672,   674,   676,   678,   680,
   682,   684,   686,   688,   690,   692,   694,   696,   698,   700,
   702,   704,   706,   708,   710,   714,   718,   720,   725,   730,
   735,   740,   744,   752,   759,   767,   775,   782,   790,   795,
   800,   805,   810,   819,   828,   837,   846,   848,   850,   852,
   855,   859,   863,   865,   868,   871,   873,   875,   877,   879,
   881,   883,   885,   890,   894,   898,   902,   906,   910,   914,
   918,   922,   926,   930,   933,   936,   940
};

static const short yyrhs[] = {    -1,
   135,   136,     0,   137,    43,     0,   137,    44,     0,     1,
    43,     0,     0,   138,     0,   139,     0,   143,   145,     0,
    19,     0,   128,   199,    20,     0,    19,   107,   207,     0,
   115,   207,     0,   114,    19,     0,   114,    19,   142,   207,
   129,   207,     0,   108,   142,   207,     0,   108,   142,   207,
   130,   142,   207,     0,   143,   109,   140,     0,   143,   110,
   207,     0,   144,   111,   207,     0,   113,   199,   130,   199,
   130,   199,   130,   199,     0,    92,    20,     0,   112,     0,
   140,   130,   141,     0,   141,     0,    20,     0,   207,     0,
    25,     0,    22,     0,    23,     0,    24,     0,    19,     0,
     0,    19,     0,     0,   146,     0,   160,     0,   147,     0,
   147,   190,     0,    59,   148,     0,    60,   148,     0,    57,
   148,     0,    58,   148,     0,    65,   151,     0,    48,   151,
     0,    87,     0,    68,   152,     0,    54,   152,     0,    55,
   152,     0,    63,   153,     0,    49,   153,     0,    53,   153,
     0,    66,   153,     0,    75,   153,     0,    50,   154,     0,
    69,   154,     0,    67,   154,     0,    70,   155,     0,    76,
   155,     0,    72,   155,     0,    52,   156,     0,    74,   156,
     0,    46,   156,     0,    79,   156,     0,    51,   157,     0,
    73,   157,     0,    61,   157,     0,    78,   157,     0,    47,
   158,     0,    64,   158,     0,   149,   150,   130,   159,     0,
   122,     0,   123,     0,     0,    11,   130,    11,     0,    12,
   130,    12,     0,    11,   130,    12,     0,    12,   130,    11,
     0,    28,   130,    26,     0,    26,   130,    28,     0,    32,
   130,   159,     0,    33,   130,   159,     0,    11,   130,   159,
     0,    12,   130,   159,     0,    28,   130,    26,     0,    26,
   130,    28,     0,    11,   130,   159,     0,    12,   130,   159,
     0,    26,     0,    28,     0,    28,   130,    26,     0,    26,
   130,    28,     0,   153,     0,    11,   130,   159,     0,    12,
   130,   159,     0,   159,     0,   159,     0,    32,   130,   159,
     0,    33,   130,   159,     0,    26,     0,    28,     0,   164,
     0,   169,     0,   172,     0,   161,     0,    62,    10,   130,
   159,     0,    56,   175,     0,   162,   200,   130,   189,     0,
   163,   200,   130,   189,     0,    76,     0,    77,     0,    70,
     0,    71,     0,    17,   183,     0,    16,   183,     0,    96,
   183,     0,    93,   183,     0,    98,   167,     0,    97,   167,
     0,    95,   167,     0,    94,   167,     0,   100,   166,     0,
    84,   165,     0,    85,     0,   104,     0,   106,     0,   101,
     0,   103,     0,   105,     0,    91,     0,   102,     0,    99,
     0,   200,   130,   202,     0,   187,   130,   202,     0,   181,
   185,   130,   202,     0,   181,   203,   130,   202,     0,   181,
   202,   130,   202,     0,   200,     0,   187,     0,   181,   185,
     0,   181,   202,     0,   181,   203,     0,   180,   130,   181,
   168,   130,   202,     0,   180,   130,   187,   130,   202,     0,
   202,     0,   203,     0,   204,     0,   185,     0,    83,   170,
     0,    82,   170,     0,    81,   170,     0,    80,   170,     0,
   180,   130,   181,   171,     0,   180,   130,   187,     0,   204,
     0,   203,     0,   184,     0,    90,   177,     0,    89,   179,
     0,    88,   176,     0,    86,   186,   130,   187,     0,    18,
   173,     0,   174,     0,   174,    10,   130,    10,     0,   187,
   130,   187,     0,   187,   130,   187,     0,   181,   184,   130,
   187,     0,   187,   130,   181,   184,     0,   200,   130,   187,
     0,   181,   203,   130,   187,     0,   187,   130,   181,   203,
     0,   187,   130,   187,     0,   181,   178,   130,   181,   178,
     0,   200,   130,   181,   205,     0,    25,   184,   130,   181,
   205,     0,   181,   178,   130,    25,   184,     0,   187,   130,
   181,   205,     0,   181,   178,   130,   187,     0,   202,     0,
   204,     0,   185,     0,   187,   130,    25,   182,     0,    25,
   182,   130,   187,     0,   200,     0,    22,     0,    23,     0,
   184,     0,   203,     0,   184,     0,   203,     0,   202,     0,
   185,     0,   186,     0,   131,    10,   132,     0,   131,    10,
   122,     9,   132,     0,   123,   131,    10,   132,     0,   131,
    10,   132,   123,     9,     0,   131,    10,   132,   122,     9,
     0,   131,    10,   132,   123,     0,   131,    10,   132,   122,
     0,    11,     0,    12,     0,     6,     0,     7,     0,    26,
     0,    28,     0,    10,     0,     9,     0,     8,     0,   188,
     0,    27,     0,    29,     0,    32,     0,    33,     0,    30,
     0,    31,     0,    34,     0,    37,     0,    38,     0,    39,
     0,    40,     0,    41,     0,    42,     0,    35,     0,    36,
     0,    37,     0,   191,     0,   193,     0,   194,     0,   195,
     0,   196,     0,   192,     0,   198,     0,   197,     0,   200,
   130,   187,     0,   187,   130,   187,     0,   186,     0,   181,
   184,   130,   187,     0,   181,   203,   130,   187,     0,   187,
   130,   181,   184,     0,   187,   130,   181,   203,     0,   201,
   130,   187,     0,   181,   184,   130,   187,   187,   130,    12,
     0,   200,   130,   187,   187,   130,    12,     0,   187,   130,
   181,   184,   187,   130,   187,     0,   187,   130,   187,    23,
   184,   130,   187,     0,   187,   130,   187,   200,   130,   187,
     0,   187,   130,   187,   187,   130,    23,   184,     0,    24,
   184,   130,   187,     0,   187,   130,    24,   184,     0,    24,
   203,   130,   187,     0,   187,   130,    24,   203,     0,   181,
   184,   130,   187,    23,   184,   130,   187,     0,   181,   184,
   130,   187,   187,   130,    23,   184,     0,   187,   130,   181,
   184,    23,   184,   130,   187,     0,   187,   130,   181,   184,
   187,   130,    23,   184,     0,     3,     0,     4,     0,     5,
     0,   128,   207,     0,   128,   133,   207,     0,   128,   134,
   207,     0,   207,     0,   133,   207,     0,   117,   207,     0,
   199,     0,    19,     0,   204,     0,   199,     0,    19,     0,
    21,     0,   124,     0,   116,   131,   207,   132,     0,   207,
   119,   207,     0,   207,   120,   207,     0,   207,   121,   207,
     0,   207,   118,   207,     0,   207,   117,   207,     0,   207,
   123,   207,     0,   207,   122,   207,     0,   207,   126,   207,
     0,   207,   125,   207,     0,   207,   124,   207,     0,   123,
   207,     0,   127,   207,     0,   131,   207,   132,     0,   206,
     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   242,   243,   247,   265,   285,   290,   292,   294,   296,   316,
   326,   335,   347,   361,   375,   381,   388,   395,   396,   399,
   413,   417,   425,   432,   433,   437,   454,   465,   467,   469,
   471,   476,   479,   483,   484,   488,   494,   495,   497,   503,
   506,   508,   510,   513,   515,   517,   520,   522,   524,   527,
   529,   531,   533,   535,   538,   540,   542,   545,   547,   549,
   552,   554,   556,   558,   561,   563,   565,   567,   570,   572,
   576,   581,   583,   585,   590,   599,   608,   615,   624,   626,
   628,   630,   632,   634,   638,   640,   642,   644,   648,   650,
   652,   654,   658,   662,   664,   668,   672,   676,   678,   682,
   684,   689,   692,   693,   694,   700,   702,   704,   706,   710,
   711,   714,   715,   721,   727,   733,   739,   746,   748,   750,
   752,   755,   757,   759,   761,   763,   765,   767,   769,   771,
   773,   775,   780,   787,   790,   793,   798,   806,   812,   814,
   816,   821,   829,   833,   840,   856,   862,   868,   875,   877,
   879,   881,   886,   888,   893,   899,   905,   912,   913,   914,
   915,   917,   922,   924,   928,   942,   951,   959,   967,   977,
   988,   999,  1014,  1043,  1049,  1052,  1057,  1061,  1069,  1081,
  1087,  1094,  1096,  1103,  1109,  1111,  1117,  1119,  1126,  1128,
  1135,  1140,  1146,  1148,  1150,  1153,  1158,  1161,  1164,  1166,
  1172,  1177,  1182,  1195,  1205,  1211,  1217,  1221,  1225,  1230,
  1235,  1238,  1241,  1244,  1247,  1250,  1256,  1258,  1260,  1262,
  1264,  1266,  1268,  1273,  1275,  1277,  1284,  1285,  1286,  1287,
  1288,  1289,  1290,  1291,  1294,  1331,  1344,  1349,  1356,  1365,
  1372,  1381,  1392,  1399,  1408,  1427,  1434,  1443,  1461,  1467,
  1473,  1482,  1493,  1509,  1521,  1533,  1549,  1551,  1553,  1557,
  1559,  1565,  1570,  1575,  1580,  1585,  1587,  1589,  1594,  1596,
  1598,  1600,  1605,  1612,  1614,  1616,  1618,  1620,  1622,  1624,
  1626,  1628,  1630,  1632,  1634,  1636,  1638
};

static const char * const yytname[] = {   "$","error","$illegal.","CHEX","CDEC",
"FRAC","AREG","BREG","MREG","NREG","RREG","XREG","YREG","OP","OPA","OPP","OP_JCC",
"OP_JSCC","OP_TCC","SYM","STRING","CHAR","XMEM","YMEM","LMEM","PMEM","AAAA",
"A10","BBBB","B10","AABB","BBAA","XXXX","YYYY","SR","MR","CCR","OMR","SP","SSH",
"SSL","LA","LC","EOL","EOS","LEXBAD","OP_ABS","OP_ADC","OP_ADD","OP_ADDL","OP_ADDR",
"OP_ASL","OP_ASR","OP_CLR","OP_CMP","OP_CMPM","OP_DIV","OP_MAC","OP_MACR","OP_MPY",
"OP_MPYR","OP_NEG","OP_NORM","OP_RND","OP_SBC","OP_SUB","OP_SUBL","OP_SUBR",
"OP_TFR","OP_TST","OP_AND","OP_ANDI","OP_EOR","OP_LSL","OP_LSR","OP_NOT","OP_OR",
"OP_ORI","OP_ROL","OP_ROR","OP_BCLR","OP_BSET","OP_BCHG","OP_BTST","OP_DO","OP_ENDDO",
"OP_LUA","OP_MOVE","OP_MOVEC","OP_MOVEM","OP_MOVEP","OP_ILLEGAL","OP_INCLUDE",
"OP_JMP","OP_JCLR","OP_JSET","OP_JSR","OP_JSCLR","OP_JSSET","OP_NOP","OP_REP",
"OP_RESET","OP_RTI","OP_RTS","OP_STOP","OP_SWI","OP_WAIT","OP_EQU","OP_ORG",
"OP_DC","OP_DS","OP_DSM","OP_END","OP_PAGE","OP_PSECT","OP_ALIGN","OP_INT","SHL",
"SHR","'|'","'^'","'&'","'+'","'-'","'*'","'/'","'%'","'~'","'#'","':'","','",
"'('","')'","'<'","'>'","input","statement","good_stuff","cpp_droppings","assembler_ops",
"dc_list","dc_stuff","space","label_field","opt_label","operation_field","operation",
"parallel_ok","mpy_arg","plus_minus","mpy_srcs","op8_1","op8_2","op8_3","op8_4",
"op8_5","op8_6","op8_7","op8_8","a_b","no_parallel","arith_inst","or_op","and_op",
"control_inst","do_args","rep_args","control_args","p6_ean_a6","bit_inst","bit_args",
"p6_ea_a6","move_inst","tcc_args","tcc_sd","sd3","movec_args","movep_args","movep_ea_pp",
"movem_args","b5_10111_max","x_or_y","ea_a6","ea_a12","ea","ea_no_ext","ea_short",
"regs","prog_ctl_reg","funky_ctl_reg","parallel_move","i_move","r_move","u_move",
"x_or_y_move","xr_move","ry_move","l_move","xy_move","num","ix","ix_long","abs_addr",
"abs_short_addr","io_short_addr","num_or_sym","num_or_sym_expr","expr",""
};
#endif

static const short yyr1[] = {     0,
   135,   135,   136,   136,   136,   137,   137,   137,   137,   137,
   138,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   140,   140,   141,   141,   142,   142,   142,
   142,   143,   143,   144,   144,   145,   146,   146,   146,   147,
   147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
   147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
   147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
   148,   149,   149,   149,   150,   150,   150,   150,   151,   151,
   151,   151,   151,   151,   152,   152,   152,   152,   153,   153,
   153,   153,   154,   155,   155,   156,   157,   158,   158,   159,
   159,   160,   160,   160,   160,   161,   161,   161,   161,   162,
   162,   163,   163,   164,   164,   164,   164,   164,   164,   164,
   164,   164,   164,   164,   164,   164,   164,   164,   164,   164,
   164,   164,   165,   165,   165,   165,   165,   166,   166,   166,
   166,   166,   167,   167,   168,   168,   168,   168,   169,   169,
   169,   169,   170,   170,   171,   171,   171,   172,   172,   172,
   172,   172,   173,   173,   174,   175,   176,   176,   176,   176,
   176,   176,   177,   177,   177,   177,   177,   177,   178,   178,
   178,   179,   179,   180,   181,   181,   182,   182,   183,   183,
   184,   184,   185,   185,   185,   185,   186,   186,   186,   186,
   187,   187,   187,   187,   187,   187,   187,   187,   187,   187,
   187,   187,   187,   187,   187,   187,   188,   188,   188,   188,
   188,   188,   188,   189,   189,   189,   190,   190,   190,   190,
   190,   190,   190,   190,   191,   192,   193,   194,   194,   194,
   194,   194,   195,   195,   195,   196,   196,   196,   197,   197,
   197,   197,   198,   198,   198,   198,   199,   199,   199,   200,
   200,   201,   202,   203,   204,   205,   205,   205,   206,   206,
   206,   206,   207,   207,   207,   207,   207,   207,   207,   207,
   207,   207,   207,   207,   207,   207,   207
};

static const short yyr2[] = {     0,
     0,     2,     2,     2,     2,     0,     1,     1,     2,     1,
     3,     3,     2,     2,     6,     3,     6,     3,     3,     3,
     8,     2,     1,     3,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     1,     0,     1,     1,     1,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     4,     1,     1,     0,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     1,     1,
     3,     3,     1,     3,     3,     1,     1,     3,     3,     1,
     1,     1,     1,     1,     1,     4,     2,     4,     4,     1,
     1,     1,     1,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     3,     3,     4,     4,     4,     1,     1,     2,
     2,     2,     6,     5,     1,     1,     1,     1,     2,     2,
     2,     2,     4,     3,     1,     1,     1,     2,     2,     2,
     4,     2,     1,     4,     3,     3,     4,     4,     3,     4,
     4,     3,     5,     4,     5,     5,     4,     4,     1,     1,
     1,     4,     4,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     3,     5,     4,     5,     5,     4,     4,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     3,     3,     1,     4,     4,     4,
     4,     3,     7,     6,     7,     7,     6,     7,     4,     4,
     4,     4,     8,     8,     8,     8,     1,     1,     1,     2,
     3,     3,     1,     2,     2,     1,     1,     1,     1,     1,
     1,     1,     4,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     2,     2,     3,     1
};

static const short yydefact[] = {     1,
     0,     0,    32,     0,     0,    23,     0,     0,     0,     0,
     2,     0,     7,     8,     0,     0,     5,     0,    22,    29,
    30,    31,    28,     0,   257,   258,   259,     0,    14,   270,
   271,     0,     0,   272,     0,     0,   269,   287,    13,     0,
     3,     4,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    74,    74,    74,    74,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   112,
   113,     0,     0,     0,     0,   110,   111,     0,     0,     0,
     0,     0,     0,     0,   124,     0,    46,     0,     0,     0,
   130,     0,     0,     0,     0,     0,     0,   132,     0,   127,
   131,   128,   125,   129,   126,     0,     0,     9,    36,    38,
    37,   105,     0,     0,   102,   103,   104,     0,    12,    16,
     0,     0,     0,   284,   285,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    11,     0,     0,     0,
   115,   189,   192,   193,   191,   190,   263,   114,   203,   204,
   209,   208,   207,   201,   202,   205,   211,   206,   212,   215,
   216,   213,   214,   217,   218,   219,   220,   221,   222,   223,
   162,   163,     0,   210,   100,   101,    63,    96,     0,     0,
    69,     0,     0,     0,     0,     0,     0,    45,    89,    90,
    51,    93,    55,    65,    97,    61,    52,     0,     0,     0,
     0,    48,    49,   107,     0,    72,    73,    42,     0,    43,
    40,    41,    67,     0,    50,    70,    44,    53,    57,    47,
    56,     0,     0,    58,    60,    66,    62,    54,    59,    68,
    64,     0,   152,     0,   184,   151,   150,   149,   185,   186,
   123,     0,     0,     0,     0,     0,   160,     0,     0,     0,
     0,   159,     0,     0,   158,     0,     0,     0,   117,   121,
     0,   120,   116,   119,   118,   122,     0,   139,   138,    26,
    18,    25,    27,    19,     0,     0,     0,   237,     0,    39,
   227,   232,   228,   229,   230,   231,   234,   233,     0,     0,
     0,     0,    20,     0,     0,     0,     0,   286,   278,   277,
   274,   275,   276,   280,   279,   283,   282,   281,     0,     0,
   264,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   260,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   187,
   188,     0,     0,     0,     0,   181,   179,   180,     0,     0,
     0,   140,   141,   142,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   273,     0,
     0,   194,     0,   165,    98,    99,    83,    84,    80,    79,
    81,    82,    92,    91,    87,    88,    86,    85,   166,     0,
     0,     0,   106,    94,    95,   261,     0,   154,     0,     0,
     0,   134,   133,     0,   161,     0,     0,     0,   172,   169,
     0,     0,     0,   265,     0,     0,     0,     0,     0,    24,
     0,     0,   262,     0,     0,     0,     0,   236,   235,   242,
   224,   225,   226,   108,   109,    17,     0,    15,   196,     0,
   200,   199,   164,    75,    77,    78,    76,    71,   153,   157,
   156,   155,   135,   137,   136,   167,   170,   168,   171,   183,
   182,     0,     0,     0,   178,   267,   266,   268,   177,   174,
     0,   148,   145,   146,   147,     0,   249,   251,   238,   239,
   250,   252,   240,   241,     0,     0,     0,     0,     0,   195,
   198,   197,   175,   176,   173,     0,   144,     0,     0,     0,
     0,     0,     0,     0,     0,    21,   143,     0,     0,     0,
     0,     0,     0,   247,   244,     0,   243,     0,     0,     0,
   245,   246,   248,   253,   254,   255,   256,     0,     0
};

static const short yydefgoto[] = {     1,
    11,    12,    13,    14,   271,   272,    24,    15,    16,   108,
   109,   110,   208,   209,   331,   188,   202,   192,   193,   224,
   177,   194,   181,   178,   111,   112,   113,   114,   115,   241,
   266,   260,   481,   116,   233,   459,   117,   171,   172,   204,
   247,   255,   355,   252,   234,   242,   349,   141,   142,   143,
   144,   173,   174,   444,   280,   281,   282,   283,   284,   285,
   286,   287,   288,    37,   235,   290,   145,   146,   478,   479,
    38,   147
};

static const short yypact[] = {-32768,
   461,   -39,   -24,    -5,    72,-32768,   138,    24,   607,   138,
-32768,    23,-32768,-32768,   900,   -63,-32768,   607,-32768,-32768,
-32768,-32768,-32768,   607,-32768,-32768,-32768,   -31,    72,-32768,
-32768,   -55,   607,-32768,   607,   607,-32768,-32768,   975,   118,
-32768,-32768,   105,   105,  1190,    74,    59,   158,    79,    79,
    74,    74,    79,    -2,    -2,  1190,   -11,   -11,   -11,   -11,
    74,   115,    79,    59,   158,    79,    79,    -2,    79,   104,
-32768,   104,    74,    74,    79,   104,-32768,    74,    74,    31,
    31,    31,    31,   780,-32768,    32,-32768,   780,   894,   743,
-32768,   105,    31,    31,   105,    31,    31,-32768,   780,-32768,
-32768,-32768,-32768,-32768,-32768,   221,   607,-32768,-32768,   633,
-32768,-32768,    31,    31,-32768,-32768,-32768,   607,   975,   559,
   138,   607,   607,-32768,-32768,   284,   607,   607,   607,   607,
   607,   607,   607,   607,   607,   607,-32768,   612,   478,   607,
-32768,-32768,-32768,-32768,-32768,-32768,   975,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   161,    48,-32768,-32768,-32768,-32768,-32768,    57,    73,
-32768,    77,    80,    92,    97,   100,   107,-32768,   109,   113,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,   128,   130,   131,
   134,-32768,-32768,-32768,   137,-32768,-32768,-32768,   163,-32768,
-32768,-32768,-32768,   141,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   143,   145,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   305,-32768,   146,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   105,   154,   167,   258,   170,-32768,   105,   172,   176,
   105,-32768,   181,   617,-32768,   574,   182,   183,-32768,-32768,
   184,-32768,-32768,-32768,-32768,-32768,   105,-32768,-32768,-32768,
   185,-32768,   975,   975,   105,    49,   105,-32768,   186,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   190,   192,
   193,   195,   975,    72,   197,   713,   326,-32768,    -3,    -3,
   271,    71,     9,    42,    42,-32768,-32768,-32768,   587,   -99,
   975,   198,  1190,    74,    74,    74,    74,   242,   303,    74,
    74,   302,   306,    74,    74,   307,   312,  1190,   203,   209,
   210,    74,    74,    74,   607,   975,  1042,   216,   217,   220,
   607,   607,   219,  1190,   223,   225,  1042,  1190,   228,-32768,
-32768,   317,   229,   607,   230,-32768,-32768,-32768,   212,   212,
  1042,-32768,-32768,-32768,   221,   231,   235,   607,   238,   239,
   854,  1190,  1190,   111,   111,   607,   138,   607,-32768,   232,
   363,   127,   364,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   234,
   240,    74,-32768,-32768,-32768,   975,    85,-32768,   607,   607,
   607,-32768,-32768,   127,-32768,  1190,  1190,   105,-32768,-32768,
  1190,   105,   212,   975,  1005,    60,    60,    85,   245,-32768,
  1190,  1190,   975,  1190,  1190,   105,   105,   817,  1190,-32768,
-32768,-32768,-32768,-32768,-32768,   975,   249,   975,-32768,   250,
   374,   377,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,    60,   617,   574,-32768,-32768,-32768,-32768,-32768,-32768,
   269,-32768,-32768,-32768,-32768,   607,-32768,-32768,  1079,-32768,
-32768,-32768,  1116,-32768,   617,   281,   283,   285,   138,-32768,
-32768,-32768,-32768,-32768,-32768,   607,-32768,   617,   287,   617,
   288,   292,   391,  1190,   412,-32768,-32768,   295,    63,   296,
  1153,  1190,   617,-32768,-32768,  1190,-32768,   617,  1190,   617,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,   430,-32768
};

static const short yypgoto[] = {-32768,
-32768,-32768,-32768,-32768,-32768,    66,   -28,-32768,-32768,-32768,
-32768,-32768,   140,-32768,-32768,   369,    -8,    64,   112,   -65,
    19,     0,   373,   -29,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   123,-32768,-32768,   132,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   -34,-32768,   -12,   -82,    33,   -23,  -174,  -217,
   -81,   -54,-32768,    78,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,    -7,   -72,-32768,  -205,     5,  -243,  -413,
-32768,    22
};


#define	YYLAST		1232


static const short yytable[] = {    28,
   122,   205,    40,    17,   246,   248,   225,   256,   198,   199,
   229,   244,   358,   480,    19,   250,   267,   258,   -10,   -10,
   148,   195,   381,   200,   338,   201,   269,   277,   278,   243,
    39,   195,   382,   249,   253,   257,   339,   289,   356,   119,
   291,   292,    29,   195,   268,   120,   203,   118,   195,   362,
   357,    25,    26,    27,   124,   279,   125,   126,   503,   220,
   213,   363,    25,    26,    27,    41,    42,    30,   259,    31,
   196,   263,   226,   345,   527,   123,   350,   230,   476,   353,
   261,   261,    18,   261,   261,   528,   -34,    25,    26,    27,
   179,   180,   227,    20,    21,    22,    23,   231,   121,   175,
   366,   176,   369,    30,   189,    31,   190,    25,    26,    27,
   206,   207,   191,   295,   222,   223,   197,   131,   132,   133,
   134,   135,   136,    30,   214,    31,   215,   273,   274,   218,
   132,   133,   134,   135,   136,   412,   413,   137,   228,   293,
    25,    26,    27,   296,   297,   441,   442,   443,   299,   300,
   301,   302,   303,   304,   305,   306,   307,   308,   232,   124,
   126,   311,   245,   462,    32,   134,   135,   136,   182,   183,
   312,    33,    34,   329,   330,    35,   354,   313,   219,    36,
   221,   335,   368,   184,   485,   185,   314,   127,   128,   186,
   187,   131,   132,   133,   134,   135,   136,   210,   211,   212,
    32,   354,   315,   463,   464,   465,   316,   138,    34,   317,
   482,    35,   236,   237,   238,   139,   262,   140,   264,   265,
    32,   318,   483,    25,    26,    27,   319,   138,    34,   320,
   358,    35,   460,   239,   240,   139,   321,   140,   322,    30,
   270,    31,   323,   468,   454,   455,   340,   350,   451,   452,
   456,   457,   346,   336,   407,   351,   356,   324,   384,   325,
   326,   491,   493,   327,   418,   376,   328,   343,   357,   389,
   332,   364,   333,   399,   334,   337,   426,   427,   428,   367,
   507,   370,   408,   341,   385,   386,   387,   388,   437,   415,
   391,   392,   419,   420,   395,   396,   342,   336,   504,   344,
   517,   347,   403,   404,   405,   348,   429,    25,    26,    27,
   352,   359,   360,   361,   365,   371,   438,   439,   440,   372,
   512,   373,   374,    30,   375,    31,   377,   383,   390,   393,
   126,   394,   400,   518,   397,   520,    32,   398,   401,   402,
   472,   422,   474,    33,    34,   409,   410,    35,   533,   411,
   414,    36,   416,   535,   417,   537,   406,   421,   423,   425,
   431,   466,   467,   449,   432,   497,   470,   434,   435,   447,
   475,   450,   458,   453,   486,   424,   487,   488,   499,   489,
   490,   500,   501,   496,   498,   502,   273,   127,   128,   433,
   130,   131,   132,   133,   134,   135,   136,   446,   506,   448,
   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,
   513,   461,   514,   523,   515,   298,   519,   521,   477,   477,
    32,   522,   469,   525,   526,   529,   351,    33,    34,   539,
   430,    35,   484,   217,   509,    36,   216,   335,   511,   505,
   492,   494,   127,   128,   129,   130,   131,   132,   133,   134,
   135,   136,   445,     0,   471,     0,     0,   379,     0,   524,
   538,     2,     0,     0,   477,     0,   531,   532,     0,     0,
     0,   534,     0,     0,   536,     0,   -33,   -33,   -33,     3,
    25,    26,    27,     0,     0,     0,     0,   310,     0,     0,
     0,   516,     0,     0,     0,     0,    30,     0,    31,     0,
     0,     0,     0,    -6,    -6,     0,   -33,   -33,   -33,   -33,
   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,
   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,
   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,
   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,   -33,
   -33,   -33,     4,   -33,   -33,   -33,   -33,   -33,   -33,   -33,
   -33,   -33,   -33,   -33,   -33,   -33,   -33,     0,     5,   -33,
   -33,   -35,     6,     7,     8,     9,    25,    26,    27,     0,
     0,     0,     0,     0,     0,     0,     0,     0,    10,    25,
    26,    27,    30,    32,    31,     0,   380,     0,     0,     0,
    33,    34,     0,     0,    35,    30,     0,    31,    36,    25,
    26,    27,     0,     0,    25,    26,    27,     0,     0,    25,
    26,    27,     0,     0,     0,    30,     0,    31,     0,     0,
    30,     0,    31,     0,     0,    30,     0,    31,   149,   150,
   151,   152,   153,   154,   155,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   239,   240,   275,     0,   156,   157,
   158,   159,   160,   161,   162,   163,   164,     0,     0,   165,
   166,   167,   168,   169,   170,   127,   128,   129,   130,   131,
   132,   133,   134,   135,   136,     0,     0,     0,   294,    32,
   354,     0,     0,     0,     0,     0,   138,    34,     0,     0,
    35,     0,    32,     0,   139,     0,     0,     0,     0,    33,
    34,     0,     0,    35,     0,     0,     0,    36,     0,     0,
     0,     0,    32,     0,     0,     0,     0,    32,     0,    33,
    34,     0,    32,    35,    33,    34,     0,    36,    35,   138,
    34,     0,   309,    35,     0,     0,     0,   139,   149,   150,
   151,   152,   153,   154,   155,     0,     0,     0,     0,     0,
   276,     0,     0,   245,   239,   240,     0,   254,   156,   157,
   158,   159,   160,   161,   162,   163,   164,     0,     0,   165,
   166,   167,   168,   169,   170,   149,   150,   151,   152,   153,
   154,   155,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   239,   240,     0,     0,   156,   157,   158,   159,   160,
   161,   162,   163,   164,     0,     0,   165,   166,   167,   168,
   169,   170,   149,   150,   151,   152,   153,   154,   155,   127,
   128,   129,   130,   131,   132,   133,   134,   135,   136,   495,
     0,   378,   156,   157,   158,   159,   160,   161,   162,   163,
   164,     0,     0,   165,   166,   167,   168,   169,   170,   149,
   150,   151,   152,   153,   154,   155,     0,     0,     0,     0,
   232,     0,     0,     0,     0,   239,   240,   436,     0,   156,
   157,   158,   159,   160,   161,   162,   163,   164,     0,     0,
   165,   166,   167,   168,   169,   170,     0,     0,     0,   149,
   150,   151,   152,   153,   154,   155,     0,   232,     0,     0,
     0,     0,     0,     0,     0,    43,    44,    45,   251,   156,
   157,   158,   159,   160,   161,   162,   163,   164,     0,     0,
   165,   166,   167,   168,   169,   170,     0,     0,     0,     0,
     0,     0,     0,     0,   232,    46,    47,    48,    49,    50,
    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
    91,     0,    92,    93,    94,    95,    96,    97,    98,    99,
   100,   101,   102,   103,   104,   105,     0,     0,   106,   107,
   149,   150,   151,   152,   153,   154,   155,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   239,   240,     0,   473,
   156,   157,   158,   159,   160,   161,   162,   163,   164,     0,
     0,   165,   166,   167,   168,   169,   170,   149,   150,   151,
   152,   153,   154,   155,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   239,   240,     0,     0,   156,   157,   158,
   159,   160,   161,   162,   163,   164,     0,     0,   165,   166,
   167,   168,   169,   170,   149,   150,   151,   152,   153,   154,
   155,   127,   128,   129,   130,   131,   132,   133,   134,   135,
   136,   508,     0,     0,   156,   157,   158,   159,   160,   161,
   162,   163,   164,     0,     0,   165,   166,   167,   168,   169,
   170,   149,   150,   151,   152,   153,   154,   155,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   510,     0,
     0,   156,   157,   158,   159,   160,   161,   162,   163,   164,
     0,     0,   165,   166,   167,   168,   169,   170,   149,   150,
   151,   152,   153,   154,   155,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   530,     0,     0,   156,   157,
   158,   159,   160,   161,   162,   163,   164,     0,     0,   165,
   166,   167,   168,   169,   170,   149,   150,   151,   152,   153,
   154,   155,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   156,   157,   158,   159,   160,
   161,   162,   163,   164,     0,     0,   165,   166,   167,   168,
   169,   170
};

static const short yycheck[] = {     7,
    29,    56,    10,    43,    86,    88,    72,    90,    11,    12,
    76,    84,   256,   427,    20,    88,    99,    90,    43,    44,
    44,    51,   122,    26,   242,    28,    99,   110,   110,    84,
     9,    61,   132,    88,    89,    90,   242,   110,   256,    18,
   113,   114,    19,    73,    99,    24,    55,   111,    78,   267,
   256,     3,     4,     5,    33,   110,    35,    36,   472,    68,
    61,   267,     3,     4,     5,    43,    44,    19,    92,    21,
    52,    95,    73,   248,    12,   131,   251,    78,    19,   254,
    93,    94,   107,    96,    97,    23,   111,     3,     4,     5,
    32,    33,    74,    22,    23,    24,    25,    79,   130,    26,
   275,    28,   277,    19,    26,    21,    28,     3,     4,     5,
   122,   123,    49,   121,    11,    12,    53,   121,   122,   123,
   124,   125,   126,    19,    10,    21,    63,   106,   107,    66,
   122,   123,   124,   125,   126,   341,   342,    20,    75,   118,
     3,     4,     5,   122,   123,    35,    36,    37,   127,   128,
   129,   130,   131,   132,   133,   134,   135,   136,   128,   138,
   139,   140,   131,   407,   116,   124,   125,   126,    11,    12,
    10,   123,   124,    11,    12,   127,   117,   130,    67,   131,
    69,   133,   134,    26,   428,    28,   130,   117,   118,    32,
    33,   121,   122,   123,   124,   125,   126,    58,    59,    60,
   116,   117,   130,   409,   410,   411,   130,   123,   124,   130,
   428,   127,    81,    82,    83,   131,    94,   133,    96,    97,
   116,   130,   428,     3,     4,     5,   130,   123,   124,   130,
   474,   127,   407,    22,    23,   131,   130,   133,   130,    19,
    20,    21,   130,   418,    11,    12,   242,   422,   122,   123,
    11,    12,   248,   232,   337,   251,   474,   130,   313,   130,
   130,   436,   437,   130,   347,   294,   130,    10,   474,    28,
   130,   267,   130,   328,   130,   130,   359,   360,   361,   275,
   486,   277,   337,   130,   314,   315,   316,   317,   371,   344,
   320,   321,   347,   348,   324,   325,   130,   276,   473,   130,
   506,   130,   332,   333,   334,   130,   361,     3,     4,     5,
   130,   130,   130,   130,   130,   130,   371,   372,   373,   130,
   495,   130,   130,    19,   130,    21,   130,   130,    26,    28,
   309,    26,   130,   508,    28,   510,   116,    26,   130,   130,
   423,    25,   425,   123,   124,   130,   130,   127,   523,   130,
   132,   131,   130,   528,   130,   530,   335,   130,   130,   130,
   130,   416,   417,   132,   130,   438,   421,   130,   130,   377,
   425,     9,   402,    10,   130,   354,   431,   432,   130,   434,
   435,   132,     9,   438,   439,     9,   365,   117,   118,   368,
   120,   121,   122,   123,   124,   125,   126,   376,   130,   378,
   117,   118,   119,   120,   121,   122,   123,   124,   125,   126,
   130,   407,   130,    23,   130,   132,   130,   130,   426,   427,
   116,   130,   418,    12,   130,   130,   422,   123,   124,     0,
   365,   127,   428,    65,   489,   131,    64,   133,   493,   474,
   436,   437,   117,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   375,    -1,   422,    -1,    -1,   132,    -1,   514,
     0,     1,    -1,    -1,   472,    -1,   521,   522,    -1,    -1,
    -1,   526,    -1,    -1,   529,    -1,    16,    17,    18,    19,
     3,     4,     5,    -1,    -1,    -1,    -1,    10,    -1,    -1,
    -1,   499,    -1,    -1,    -1,    -1,    19,    -1,    21,    -1,
    -1,    -1,    -1,    43,    44,    -1,    46,    47,    48,    49,
    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,
    60,    61,    62,    63,    64,    65,    66,    67,    68,    69,
    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,
    80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
   100,   101,   102,   103,   104,   105,   106,    -1,   108,   109,
   110,   111,   112,   113,   114,   115,     3,     4,     5,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   128,     3,
     4,     5,    19,   116,    21,    -1,    10,    -1,    -1,    -1,
   123,   124,    -1,    -1,   127,    19,    -1,    21,   131,     3,
     4,     5,    -1,    -1,     3,     4,     5,    -1,    -1,     3,
     4,     5,    -1,    -1,    -1,    19,    -1,    21,    -1,    -1,
    19,    -1,    21,    -1,    -1,    19,    -1,    21,     6,     7,
     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    22,    23,    24,    -1,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    -1,    -1,    37,
    38,    39,    40,    41,    42,   117,   118,   119,   120,   121,
   122,   123,   124,   125,   126,    -1,    -1,    -1,   130,   116,
   117,    -1,    -1,    -1,    -1,    -1,   123,   124,    -1,    -1,
   127,    -1,   116,    -1,   131,    -1,    -1,    -1,    -1,   123,
   124,    -1,    -1,   127,    -1,    -1,    -1,   131,    -1,    -1,
    -1,    -1,   116,    -1,    -1,    -1,    -1,   116,    -1,   123,
   124,    -1,   116,   127,   123,   124,    -1,   131,   127,   123,
   124,    -1,   131,   127,    -1,    -1,    -1,   131,     6,     7,
     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,
   128,    -1,    -1,   131,    22,    23,    -1,    25,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    -1,    -1,    37,
    38,    39,    40,    41,    42,     6,     7,     8,     9,    10,
    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    22,    23,    -1,    -1,    26,    27,    28,    29,    30,
    31,    32,    33,    34,    -1,    -1,    37,    38,    39,    40,
    41,    42,     6,     7,     8,     9,    10,    11,    12,   117,
   118,   119,   120,   121,   122,   123,   124,   125,   126,    23,
    -1,   129,    26,    27,    28,    29,    30,    31,    32,    33,
    34,    -1,    -1,    37,    38,    39,    40,    41,    42,     6,
     7,     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,
   128,    -1,    -1,    -1,    -1,    22,    23,    24,    -1,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
    37,    38,    39,    40,    41,    42,    -1,    -1,    -1,     6,
     7,     8,     9,    10,    11,    12,    -1,   128,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    16,    17,    18,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    -1,    -1,
    37,    38,    39,    40,    41,    42,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,   128,    46,    47,    48,    49,    50,
    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,
    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
    91,    -1,    93,    94,    95,    96,    97,    98,    99,   100,
   101,   102,   103,   104,   105,   106,    -1,    -1,   109,   110,
     6,     7,     8,     9,    10,    11,    12,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    22,    23,    -1,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    -1,
    -1,    37,    38,    39,    40,    41,    42,     6,     7,     8,
     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    22,    23,    -1,    -1,    26,    27,    28,
    29,    30,    31,    32,    33,    34,    -1,    -1,    37,    38,
    39,    40,    41,    42,     6,     7,     8,     9,    10,    11,
    12,   117,   118,   119,   120,   121,   122,   123,   124,   125,
   126,    23,    -1,    -1,    26,    27,    28,    29,    30,    31,
    32,    33,    34,    -1,    -1,    37,    38,    39,    40,    41,
    42,     6,     7,     8,     9,    10,    11,    12,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    23,    -1,
    -1,    26,    27,    28,    29,    30,    31,    32,    33,    34,
    -1,    -1,    37,    38,    39,    40,    41,    42,     6,     7,
     8,     9,    10,    11,    12,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    23,    -1,    -1,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    -1,    -1,    37,
    38,    39,    40,    41,    42,     6,     7,     8,     9,    10,
    11,    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    26,    27,    28,    29,    30,
    31,    32,    33,    34,    -1,    -1,    37,    38,    39,    40,
    41,    42
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/gnu/lib/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */


#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#define YYLEX		yylex(&yylval, &yylloc)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 184 "/usr/local/gnu/lib/bison.simple"
int
yyparse()
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 3:
#line 248 "a56.y"
{
			if(pass == 2 && list_on && list_print_line) {
				printf(ldebug ? "\n(%s|%s)\n" : "%s%s\n",
					list_buf, substatement == 0 ? luntab(cur_line) : "");
				if(uses_buf2)
					printf(ldebug ? "\n(%s|)\n" : "%s\n",
						list_buf2);
				list_buf[0] = list_buf2[0] = '\0';
			}
			curline++;
			uses_buf2 = FALSE;
			list_print_line = TRUE;
			list_on = list_on_next;
			substatement = 0;
			if(NOT check_psect(seg, pc) && pass == 2)
				yyerror("%04X: psect violation", pc);
			;
    break;}
case 4:
#line 266 "a56.y"
{
			if(pass == 2 && list_on && list_print_line) {
				printf(ldebug ? "\n(%s" : "%s", list_buf);
				if(substatement == 0)
					printf(ldebug ? "|%s)\n" : "%s\n", luntab(cur_line));
				else
					printf(ldebug ? ")\n" : "\n");
				if(uses_buf2)
					printf(ldebug ? "\n(%s|)\n" : "%s\n",
						list_buf2);
				list_buf[0] = list_buf2[0] = '\0';
			}
			substatement++;
			uses_buf2 = FALSE;
			list_print_line = TRUE;
			list_on = list_on_next;
			if(NOT check_psect(seg, pc) && pass == 2)
				yyerror("%04X: psect violation", pc);
			;
    break;}
case 5:
#line 286 "a56.y"
{curline++; substatement = 0;;
    break;}
case 6:
#line 291 "a56.y"
{sprintf(list_buf, "%s", spaces(0));;
    break;}
case 7:
#line 293 "a56.y"
{list_print_line = FALSE;;
    break;}
case 8:
#line 295 "a56.y"
{long_symbolic_expr = FALSE;;
    break;}
case 9:
#line 297 "a56.y"
{char *printcode();
			if(pass == 2) {
				gencode(seg, pc, w0);
				sprintf(list_buf, "%c:%04X %s ", segs[seg], pc, printcode(w0));
				pc++;
				if(uses_w1) {
					gencode(seg, pc, w1);
					sprintf(list_buf2, "%c:%04X %s", segs[seg], pc,
	       					printcode(w1 & 0xFFFFFF));
					uses_buf2++;
					pc++;
				}
			} else {
				pc++;
				if(uses_w1)
					pc++;
			}
			w0 = w1 = 0; uses_w1 = FALSE; 
			long_symbolic_expr = FALSE;;
    break;}
case 10:
#line 317 "a56.y"
{sym_def(yyvsp[0].sval, INT, pc);
			free(yyvsp[0].sval);
			if(pass == 2 && list_on) {
				sprintf(list_buf, "%c:%04X%s", segs[seg], pc, spaces(14-8));
			long_symbolic_expr = FALSE;
			};
    break;}
case 11:
#line 327 "a56.y"
{if(strlen(yyvsp[0].sval) > 0)
				curfile = yyvsp[0].sval;
			else
				curfile = "<stdin>";
			curline = yyvsp[-1].n.val.i - 1;;
    break;}
case 12:
#line 336 "a56.y"
{sym_def(yyvsp[-2].sval, yyvsp[0].n.type, yyvsp[0].n.val.i, yyvsp[0].n.val.f);
			free(yyvsp[-2].sval);
			if(pass == 2 && list_on) {
				if(yyvsp[0].n.type == INT)
					sprintf(list_buf, "%06X%s",
						yyvsp[0].n.val.i & 0xFFFFFF,
						spaces(14-8));
				else
					sprintf(list_buf, "%10g%s", yyvsp[0].n.val.f,
						spaces(14-4));
			};
    break;}
case 13:
#line 348 "a56.y"
{int ival = n2int(yyvsp[0].n);
			if(yyvsp[0].n.type == UNDEF) {
				yyerror("illegal forward reference");
			} else if (ival <= 1) {
				yyerror("%d: illegal alignment", ival);
			} else {
				if(pc % ival != 0)
					pc += ival - pc % ival;
			}
			if(pass == 2 && list_on)
				sprintf(list_buf, "%c:%04X%s", segs[seg], pc, 
					spaces(14-8));
			;
    break;}
case 14:
#line 362 "a56.y"
{struct psect *pp = find_psect(yyvsp[0].sval);
			if(NOT pp) {
				if(pass == 2)
					yyerror("%s: undefined psect", yyvsp[0].sval);
			} else {
				seg = pp->seg;
				pc = pp->pc;
				set_psect(pp);
				if(pass == 2 && list_on)
					sprintf(list_buf, "%c:%04X%s", segs[seg], pc,
						spaces(14-8));
			}
			free(yyvsp[0].sval);;
    break;}
case 15:
#line 376 "a56.y"
{new_psect(yyvsp[-4].sval, yyvsp[-3].ival, n2int(yyvsp[-2].n), n2int(yyvsp[0].n));
			if(pass == 2 && list_on)
				sprintf(list_buf, "%c:%04X %04X%s", 
					segs[yyvsp[-3].ival], n2int(yyvsp[-2].n), n2int(yyvsp[0].n), spaces(14-8+4+1));
			;
    break;}
case 16:
#line 382 "a56.y"
{pc = n2int(yyvsp[0].n);
			seg = yyvsp[-1].ival;
			if(pass == 2 && list_on)
				sprintf(list_buf, "%c:%04X%s", segs[seg], pc, 
					spaces(14-8));
			;
    break;}
case 17:
#line 389 "a56.y"
{pc = n2int(yyvsp[-3].n);
			seg = yyvsp[-4].ival;
			if(pass == 2 && list_on)
				sprintf(list_buf, "%c:%04X%s", segs[seg], pc, 
					spaces(14-8));
			;
    break;}
case 19:
#line 397 "a56.y"
{pc += n2int(yyvsp[0].n);
			;
    break;}
case 20:
#line 400 "a56.y"
{int size = n2int(yyvsp[0].n);
			if(size)
			{    int align = 1;
			     while(align < size)
				 align <<= 1;
			     pc += (align - (pc % align));
			}
			if(yyvsp[-2].sval)
			{   sym_def(yyvsp[-2].sval, INT, pc);
 			    free(yyvsp[-2].sval);
			}
			pc += size;
			;
    break;}
case 21:
#line 414 "a56.y"
{if(pass == 2 && list_on) {
				sprintf(list_buf, "%s", spaces(0));
			};
    break;}
case 22:
#line 418 "a56.y"
{if(pass == 2 && list_on) {
				printf(ldebug ? "\n(%s|%s)\n" : "%s%s\n",
					spaces(0), luntab(cur_line));
				list_print_line = FALSE;
			}
			include(yyvsp[0].sval); /* free($2); */
			;
    break;}
case 23:
#line 426 "a56.y"
{if(pass == 2 && list_on) {
				sprintf(list_buf, "%s", spaces(0));
			};
    break;}
case 26:
#line 438 "a56.y"
{int len = strlen(yyvsp[0].sval), i; char *cp; w0 = 0;
			if(len % 3 == 2)
				len++;	/* force empty word */
			for(i = 0, cp = yyvsp[0].sval; i < len; i++, cp++) {
				w0 |= (*cp & 0xFF) << (2 - (i % 3)) * 8;
				if(i % 3 == 2 || i == len - 1) {
					if(pass == 2) {
						if(list_on) sprintf(list_buf, "%c:%04X %06X%s",
							segs[seg], pc, w0, 
							spaces(14-6+5));
						gencode(seg, pc, w0);
					}
					pc++; w0 = 0;
				}
			}
			free(yyvsp[0].sval);;
    break;}
case 27:
#line 455 "a56.y"
{int frac = n2frac(yyvsp[0].n);
			if(pass == 2) {
				if(list_on) {
					sprintf(list_buf, "%c:%04X %06X%s", segs[seg], pc, 
						frac & 0xFFFFFF, spaces(14-6+5));
				}
				gencode(seg, pc, frac);
			}
			pc++;;
    break;}
case 28:
#line 466 "a56.y"
{yyval.ival = PROG;;
    break;}
case 29:
#line 468 "a56.y"
{yyval.ival = XDATA;;
    break;}
case 30:
#line 470 "a56.y"
{yyval.ival = YDATA;;
    break;}
case 31:
#line 472 "a56.y"
{yyval.ival = LDATA;;
    break;}
case 32:
#line 477 "a56.y"
{sym_def(yyvsp[0].sval, INT, pc);
			free(yyvsp[0].sval);;
    break;}
case 34:
#line 483 "a56.y"
{yyval.sval = yyvsp[0].sval;;
    break;}
case 35:
#line 484 "a56.y"
{yyval.sval = NULL;;
    break;}
case 36:
#line 489 "a56.y"
{if(just_rep) 
				just_rep--;;
    break;}
case 38:
#line 496 "a56.y"
{w0 |= 0x200000;;
    break;}
case 40:
#line 505 "a56.y"
{w0 |= 0x80 | yyvsp[0].ival << 2;;
    break;}
case 41:
#line 507 "a56.y"
{w0 |= 0x81 | yyvsp[0].ival << 2;;
    break;}
case 42:
#line 509 "a56.y"
{w0 |= 0x82 | yyvsp[0].ival << 2;;
    break;}
case 43:
#line 511 "a56.y"
{w0 |= 0x83 | yyvsp[0].ival << 2;;
    break;}
case 44:
#line 514 "a56.y"
{w0 |= 0x04 | yyvsp[0].ival << 3;;
    break;}
case 45:
#line 516 "a56.y"
{w0 |= 0x00 | yyvsp[0].ival << 3;;
    break;}
case 46:
#line 518 "a56.y"
{w0 |= 0x00;;
    break;}
case 47:
#line 521 "a56.y"
{w0 |= 0x01 | yyvsp[0].ival << 3;;
    break;}
case 48:
#line 523 "a56.y"
{w0 |= 0x05 | yyvsp[0].ival << 3;;
    break;}
case 49:
#line 525 "a56.y"
{w0 |= 0x07 | yyvsp[0].ival << 3;;
    break;}
case 50:
#line 528 "a56.y"
{w0 |= 0x11 | yyvsp[0].ival << 3;;
    break;}
case 51:
#line 530 "a56.y"
{w0 |= 0x12 | yyvsp[0].ival << 3;;
    break;}
case 52:
#line 532 "a56.y"
{w0 |= 0x13 | yyvsp[0].ival << 3;;
    break;}
case 53:
#line 534 "a56.y"
{w0 |= 0x16 | yyvsp[0].ival << 3;;
    break;}
case 54:
#line 536 "a56.y"
{w0 |= 0x17 | yyvsp[0].ival << 3;;
    break;}
case 55:
#line 539 "a56.y"
{w0 |= 0x02 | yyvsp[0].ival << 3;;
    break;}
case 56:
#line 541 "a56.y"
{w0 |= 0x03 | yyvsp[0].ival << 3;;
    break;}
case 57:
#line 543 "a56.y"
{w0 |= 0x06 | yyvsp[0].ival << 3;;
    break;}
case 58:
#line 546 "a56.y"
{w0 |= 0x46 | yyvsp[0].ival << 3;;
    break;}
case 59:
#line 548 "a56.y"
{w0 |= 0x42 | yyvsp[0].ival << 3;;
    break;}
case 60:
#line 550 "a56.y"
{w0 |= 0x43 | yyvsp[0].ival << 3;;
    break;}
case 61:
#line 553 "a56.y"
{w0 |= 0x22 | yyvsp[0].ival << 3;;
    break;}
case 62:
#line 555 "a56.y"
{w0 |= 0x23 | yyvsp[0].ival << 3;;
    break;}
case 63:
#line 557 "a56.y"
{w0 |= 0x26 | yyvsp[0].ival << 3;;
    break;}
case 64:
#line 559 "a56.y"
{w0 |= 0x27 | yyvsp[0].ival << 3;;
    break;}
case 65:
#line 562 "a56.y"
{w0 |= 0x32 | yyvsp[0].ival << 3;;
    break;}
case 66:
#line 564 "a56.y"
{w0 |= 0x33 | yyvsp[0].ival << 3;;
    break;}
case 67:
#line 566 "a56.y"
{w0 |= 0x36 | yyvsp[0].ival << 3;;
    break;}
case 68:
#line 568 "a56.y"
{w0 |= 0x37 | yyvsp[0].ival << 3;;
    break;}
case 69:
#line 571 "a56.y"
{w0 |= 0x21 | yyvsp[0].ival << 3;;
    break;}
case 70:
#line 573 "a56.y"
{w0 |= 0x25 | yyvsp[0].ival << 3;;
    break;}
case 71:
#line 577 "a56.y"
{yyval.ival = yyvsp[-3].ival | yyvsp[0].ival << 1 | yyvsp[-2].ival << 2;;
    break;}
case 72:
#line 582 "a56.y"
{yyval.ival = 0;;
    break;}
case 73:
#line 584 "a56.y"
{yyval.ival = 1;;
    break;}
case 74:
#line 586 "a56.y"
{yyval.ival = 0;;
    break;}
case 75:
#line 591 "a56.y"
{switch (yyvsp[-2].ival << 4 | yyvsp[0].ival) {
				case 0x00: yyval.ival = 0x0; break;
				case 0x01: 
				case 0x10: yyval.ival = 0x2; break;
				case 0x11: 
					yyerror("illegal source operands"); 
					break;
			};
    break;}
case 76:
#line 600 "a56.y"
{switch (yyvsp[-2].ival << 4 | yyvsp[0].ival) {
				case 0x00: yyval.ival = 0x1; break;
				case 0x01: 
				case 0x10: yyval.ival = 0x3; break;
				case 0x11: 
					yyerror("illegal source operands"); 
					break;
			};
    break;}
case 77:
#line 609 "a56.y"
{switch (yyvsp[-2].ival << 4 | yyvsp[0].ival) {
				case 0x00: yyval.ival = 0x5; break;
				case 0x01: yyval.ival = 0x4; break;
				case 0x10: yyval.ival = 0x6; break;
				case 0x11: yyval.ival = 0x7; break;
			};
    break;}
case 78:
#line 616 "a56.y"
{switch (yyvsp[-2].ival << 4 | yyvsp[0].ival) {
				case 0x00: yyval.ival = 0x5; break;
				case 0x01: yyval.ival = 0x6; break;
				case 0x10: yyval.ival = 0x4; break;
				case 0x11: yyval.ival = 0x7; break;
			};
    break;}
case 79:
#line 625 "a56.y"
{yyval.ival = 0x2;;
    break;}
case 80:
#line 627 "a56.y"
{yyval.ival = 0x3;;
    break;}
case 81:
#line 629 "a56.y"
{yyval.ival = 0x4 | yyvsp[0].ival;;
    break;}
case 82:
#line 631 "a56.y"
{yyval.ival = 0x6 | yyvsp[0].ival;;
    break;}
case 83:
#line 633 "a56.y"
{yyval.ival = 0x8 | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 84:
#line 635 "a56.y"
{yyval.ival = 0xA | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 85:
#line 639 "a56.y"
{yyval.ival = 0x0;;
    break;}
case 86:
#line 641 "a56.y"
{yyval.ival = 0x1;;
    break;}
case 87:
#line 643 "a56.y"
{yyval.ival = 0x8 | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 88:
#line 645 "a56.y"
{yyval.ival = 0xA | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 89:
#line 649 "a56.y"
{yyval.ival = 0x0;;
    break;}
case 90:
#line 651 "a56.y"
{yyval.ival = 0x1;;
    break;}
case 91:
#line 653 "a56.y"
{yyval.ival = 0x0;;
    break;}
case 92:
#line 655 "a56.y"
{yyval.ival = 0x1;;
    break;}
case 93:
#line 659 "a56.y"
{yyval.ival = yyvsp[0].ival;;
    break;}
case 94:
#line 663 "a56.y"
{yyval.ival = 0x0 | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 95:
#line 665 "a56.y"
{yyval.ival = 0x2 | yyvsp[-2].ival << 2 | yyvsp[0].ival;;
    break;}
case 96:
#line 669 "a56.y"
{yyval.ival = yyvsp[0].ival;;
    break;}
case 97:
#line 673 "a56.y"
{yyval.ival = yyvsp[0].ival;;
    break;}
case 98:
#line 677 "a56.y"
{yyval.ival = 0x0 | yyvsp[0].ival;;
    break;}
case 99:
#line 679 "a56.y"
{yyval.ival = 0x2 | yyvsp[0].ival;;
    break;}
case 100:
#line 683 "a56.y"
{yyval.ival = 0;;
    break;}
case 101:
#line 685 "a56.y"
{yyval.ival = 1;;
    break;}
case 102:
#line 690 "a56.y"
{if(just_rep == 1)
				yyerror("instruction not allowed after REP");;
    break;}
case 106:
#line 701 "a56.y"
{w0 |= 0x01D815 | yyvsp[-2].ival << 8 | yyvsp[0].ival << 3;;
    break;}
case 107:
#line 703 "a56.y"
{w0 |= 0x018040 | yyvsp[0].ival << 3;;
    break;}
case 108:
#line 705 "a56.y"
{w0 |= 0x0000F8 | (n2int(yyvsp[-2].n) & 0xFF) << 8 | yyvsp[0].ival;;
    break;}
case 109:
#line 707 "a56.y"
{w0 |= 0x0000B8 | (n2int(yyvsp[-2].n) & 0xFF) << 8 | yyvsp[0].ival;;
    break;}
case 114:
#line 722 "a56.y"
{if(yyvsp[0].ival) {
				w0 |= 0x0BC0A0 | yyvsp[-1].cond << 0;
			} else {
				w0 |= 0x0F0000 | yyvsp[-1].cond << 12;
			};
    break;}
case 115:
#line 728 "a56.y"
{if(yyvsp[0].ival) {
				w0 |= 0x0AC0A0 | yyvsp[-1].cond << 0;
			} else {
				w0 |= 0x0E0000 | yyvsp[-1].cond << 12;
			};
    break;}
case 116:
#line 734 "a56.y"
{if(yyvsp[0].ival) {
				w0 |= 0x0BC080;
			} else {
				w0 |= 0x0D0000;
			};
    break;}
case 117:
#line 740 "a56.y"
{if(yyvsp[0].ival) {
				w0 |= 0x0AC080;
			} else {
				w0 |= 0x0C0000;
			};
    break;}
case 118:
#line 747 "a56.y"
{w0 |= 0x0B0020;;
    break;}
case 119:
#line 749 "a56.y"
{w0 |= 0x0B0000;;
    break;}
case 120:
#line 751 "a56.y"
{w0 |= 0x0A0020;;
    break;}
case 121:
#line 753 "a56.y"
{w0 |= 0x0A0000;;
    break;}
case 122:
#line 756 "a56.y"
{just_rep = 2;;
    break;}
case 123:
#line 758 "a56.y"
{uses_w1++;;
    break;}
case 124:
#line 760 "a56.y"
{w0 |= 0x00008C;;
    break;}
case 125:
#line 762 "a56.y"
{w0 |= 0x000087;;
    break;}
case 126:
#line 764 "a56.y"
{w0 |= 0x000086;;
    break;}
case 127:
#line 766 "a56.y"
{w0 |= 0x000084;;
    break;}
case 128:
#line 768 "a56.y"
{w0 |= 0x00000C;;
    break;}
case 129:
#line 770 "a56.y"
{w0 |= 0x000006;;
    break;}
case 130:
#line 772 "a56.y"
{w0 |= 0x000005;;
    break;}
case 131:
#line 774 "a56.y"
{w0 |= 0x000004;;
    break;}
case 132:
#line 776 "a56.y"
{w0 |= 0x000000;
			just_rep = 0;;
    break;}
case 133:
#line 781 "a56.y"
{int ival = n2int(yyvsp[-2].n);
			w0 |= 0x060080 | (ival & 0xFF) << 8 | (ival & 0xF00)>> 8;
			if(ival > 0xFFF && pass == 2) {
				yyerror("warning: immediate operand truncated");
			}
			w1 |= yyvsp[0].ival-1;;
    break;}
case 134:
#line 788 "a56.y"
{w0 |= 0x06C000 | yyvsp[-2].regs.r6 << 8;
			w1 |= yyvsp[0].ival-1;;
    break;}
case 135:
#line 791 "a56.y"
{w0 |= 0x064000 | yyvsp[-2].ival << 8 | yyvsp[-3].ival << 6;
			w1 |= yyvsp[0].ival-1;;
    break;}
case 136:
#line 794 "a56.y"
{w0 |= 0x060000 | (yyvsp[-2].ival & 0x3F) << 8 | yyvsp[-3].ival << 6;
			if(yyvsp[-2].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w1 |= yyvsp[0].ival-1;;
    break;}
case 137:
#line 799 "a56.y"
{w0 |= 0x060000 | (yyvsp[-2].ival & 0x3F) << 8 | yyvsp[-3].ival << 6;
			if(yyvsp[-2].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w1 |= yyvsp[0].ival-1;;
    break;}
case 138:
#line 807 "a56.y"
{int ival = n2int(yyvsp[0].n);
			w0 |= 0x0600A0 | (ival & 0xFF) << 8 | (ival & 0xF00)>> 8;
			if(ival > 0xFFF && pass == 2) {
				yyerror("warning: immediate operand truncated");
			};
    break;}
case 139:
#line 813 "a56.y"
{w0 |= 0x06C020 | yyvsp[0].regs.r6 << 8;;
    break;}
case 140:
#line 815 "a56.y"
{w0 |= 0x064020 | yyvsp[-1].ival << 6 | yyvsp[0].ival << 8;;
    break;}
case 141:
#line 817 "a56.y"
{w0 |= 0x060020 | yyvsp[-1].ival << 6 | (yyvsp[0].ival & 0x3F) << 8;
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 142:
#line 822 "a56.y"
{w0 |= 0x060020 | yyvsp[-1].ival << 6 | (yyvsp[0].ival & 0x3F) << 8;
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 143:
#line 830 "a56.y"
{w0 |= yyvsp[-5].ival << 0 | yyvsp[-3].ival << 6;
			uses_w1++;
			w1 = yyvsp[0].ival;;
    break;}
case 144:
#line 834 "a56.y"
{w0 |= 0x00C000 | yyvsp[-4].ival << 0 | yyvsp[-2].regs.r6 << 8;
			uses_w1++;
			w1 = yyvsp[0].ival;;
    break;}
case 145:
#line 846 "a56.y"
{if(yyvsp[0].ival != -1) {	/* symbol defined */
				w0 |= (yyvsp[0].ival & 0x3F) << 8;
				if(yyvsp[0].ival >= 0xFFC0) {
					w0 |= 0x008080;
				} else {
					w0 |= 0x000080;
					if(yyvsp[0].ival > 0x003F && pass == 2)
						yyerror("warning: address operand truncated");
				}
			};
    break;}
case 146:
#line 857 "a56.y"
{if(yyvsp[0].ival != -1) {
				if(yyvsp[0].ival > 0x3F && pass == 2)
					yyerror("warning: address operand truncated");
				w0 |= 0x000080 | (yyvsp[0].ival & 0x3F) << 8;
			};
    break;}
case 147:
#line 863 "a56.y"
{if(yyvsp[0].ival != -1) {
				if(yyvsp[0].ival < 0xFFC0 && pass == 2)
					yyerror("warning: address operand truncated");
				w0 |= 0x008080 | (yyvsp[0].ival & 0x3F) << 8;
			};
    break;}
case 148:
#line 869 "a56.y"
{w0 |= 0x004080 | yyvsp[0].ival << 8;;
    break;}
case 149:
#line 876 "a56.y"
{w0 |= 0x0B0020;;
    break;}
case 150:
#line 878 "a56.y"
{w0 |= 0x0B0000;;
    break;}
case 151:
#line 880 "a56.y"
{w0 |= 0x0A0020;;
    break;}
case 152:
#line 882 "a56.y"
{w0 |= 0x0A0000;;
    break;}
case 153:
#line 887 "a56.y"
{w0 |= yyvsp[-3].ival << 0 | yyvsp[-1].ival << 6;;
    break;}
case 154:
#line 889 "a56.y"
{w0 |= 0x00C040 | yyvsp[-2].ival << 0 | yyvsp[0].regs.r6 << 8;;
    break;}
case 155:
#line 894 "a56.y"
{if(yyvsp[0].ival != -1) {
				w0 |= (yyvsp[0].ival & 0x3F) << 8 | 0x008000;
				if(yyvsp[0].ival < 0xFFC0 && pass == 2)
					yyerror("warning: address operand truncated");
			};
    break;}
case 156:
#line 900 "a56.y"
{if(yyvsp[0].ival != -1) {
				w0 |= (yyvsp[0].ival & 0x3F) << 8 | 0x000000;
				if(yyvsp[0].ival > 0x003F && pass == 2)
					yyerror("warning: address operand truncated");
			};
    break;}
case 157:
#line 906 "a56.y"
{w0 |= 0x004000;;
    break;}
case 161:
#line 916 "a56.y"
{w0 |= 0x044010 | yyvsp[-2].ival << 8 | yyvsp[0].regs.r4;;
    break;}
case 162:
#line 918 "a56.y"
{w0 |= yyvsp[-1].cond << 12;;
    break;}
case 163:
#line 923 "a56.y"
{w0 |= 0x020000 | yyvsp[0].ival << 3;;
    break;}
case 164:
#line 925 "a56.y"
{w0 |= 0x030000 | yyvsp[-3].ival << 3 | yyvsp[-2].ival << 8 | yyvsp[0].ival;;
    break;}
case 165:
#line 929 "a56.y"
{if(yyvsp[-2].regs.flags & R_AB && yyvsp[0].regs.flags & R_AB) {
				if(yyvsp[-2].regs.ab == yyvsp[0].regs.ab) 
					yyerror("source and dest must be different");
				yyval.ival = yyvsp[0].regs.ab;
			} else if(yyvsp[-2].regs.flags & R_XREG && yyvsp[0].regs.flags & R_AB) {
				yyval.ival = 0x8 | yyvsp[-2].regs.xreg << 2 | yyvsp[0].regs.ab;
			} else if(yyvsp[-2].regs.flags & R_YREG && yyvsp[0].regs.flags & R_AB) {
				yyval.ival = 0xA | yyvsp[-2].regs.yreg << 2 | yyvsp[0].regs.ab;
			} else 
				yyerror("illegal TCC operands");
			;
    break;}
case 166:
#line 943 "a56.y"
{if(yyvsp[-2].regs.flags & R_XREG && yyvsp[0].regs.flags & R_AB) {
				yyval.ival = yyvsp[-2].regs.xreg << 2 | yyvsp[0].regs.ab;
			} else if(yyvsp[-2].regs.flags & R_YREG && yyvsp[0].regs.flags & R_AB) {
				yyval.ival = yyvsp[-2].regs.yreg << 2 | 2 | yyvsp[0].regs.ab;
			};
    break;}
case 167:
#line 952 "a56.y"
{if(NOT (yyvsp[0].regs.flags & R_CTL_REG))
				yyerror("bad MOVEC target register");
			if(yyvsp[-3].ival == 0) {
				w0 |= 0x05C020 | yyvsp[0].regs.ctl_reg;
			} else {
				w0 |= 0x05C060 | yyvsp[0].regs.ctl_reg;
			};
    break;}
case 168:
#line 960 "a56.y"
{if(NOT (yyvsp[-3].regs.flags & R_CTL_REG))
				yyerror("bad MOVEC source register");
			if(yyvsp[-1].ival == 0) {
				w0 |= 0x054020 | yyvsp[-3].regs.ctl_reg;
			} else {
				w0 |= 0x054060 | yyvsp[-3].regs.ctl_reg;
			};
    break;}
case 169:
#line 968 "a56.y"
{int ival = n2int(yyvsp[-2].n);
			if(NOT (yyvsp[0].regs.flags & R_CTL_REG))
				yyerror("bad MOVEC target register");
			if(ival < 256 && NOT long_symbolic_expr) {
				w0 |= 0x0500A0 | (ival & 0xFF) << 8 | yyvsp[0].regs.ctl_reg; 
			} else {
				w0 |= 0x05C020 | 0x003400 | yyvsp[0].regs.ctl_reg;
				uses_w1++; w1 = ival & 0xFFFF;
			};
    break;}
case 170:
#line 978 "a56.y"
{if(yyvsp[-3].ival == 0) {
				w0 |= 0x058020 | (yyvsp[-2].ival & 0x3F) << 8 | yyvsp[0].regs.ctl_reg;
			} else {
				w0 |= 0x058060 | (yyvsp[-2].ival & 0x3F) << 8 | yyvsp[0].regs.ctl_reg;
			}
			if(NOT (yyvsp[0].regs.flags & R_CTL_REG))
				yyerror("bad MOVEC target register");
			if(yyvsp[-2].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 171:
#line 989 "a56.y"
{if(yyvsp[-1].ival == 0) {
				w0 |= 0x050020 | (yyvsp[0].ival & 0x3F) << 8 | yyvsp[-3].regs.ctl_reg;
			} else {
				w0 |= 0x050060 | (yyvsp[0].ival & 0x3F) << 8 | yyvsp[-3].regs.ctl_reg;
			}
			if(NOT (yyvsp[-3].regs.flags & R_CTL_REG))
				yyerror("bad MOVEC source register");
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 172:
#line 1000 "a56.y"
{if(yyvsp[-2].regs.flags & R_CTL_REG) {
				w0 |= 0x0440A0 | yyvsp[0].regs.r6 << 8 | yyvsp[-2].regs.ctl_reg;
			} else if(yyvsp[0].regs.flags & R_CTL_REG) {
				w0 |= 0x04C0A0 | yyvsp[-2].regs.r6 << 8 | yyvsp[0].regs.ctl_reg;
			} else if(yyvsp[-2].regs.flags & yyvsp[0].regs.flags & R_CTL_REG) {
				/* bogus? $$$ */
	       			w0 |= 0x04C0A0 | (yyvsp[-2].regs.ctl_reg | 0x20) << 8 | 
				yyvsp[0].regs.ctl_reg;
			} else {
				yyerror("MOVEC must reference a control reg");
			};
    break;}
case 173:
#line 1015 "a56.y"
{w0 |= 0x084080;
			switch(yyvsp[-3].ea.pp << 1 | yyvsp[0].ea.pp) {
				case 0:	case 3:
					yyerror("illegal MOVEP; can't move EA to EA or IO to IO");
					break;
				case 1:	/* ea, pp */
					w0 |= yyvsp[-1].ival << 16 | 1 << 15 | yyvsp[-4].ival << 6 |
						(yyvsp[0].ea.ext & 0x3F);
					if(yyvsp[-3].ea.mode == 0x003000) {
						w0 |= 0x003000;
						uses_w1++;
						w1 = yyvsp[-3].ea.ext;
					} else {
						w0 |= yyvsp[-3].ea.mode;
					}
					break;
				case 2:	/* pp, ea */
					w0 |= yyvsp[-4].ival << 16 | 0 << 15 | yyvsp[-1].ival << 6 |
						(yyvsp[-3].ea.ext & 0x3F);
					if(yyvsp[0].ea.mode == 0x003000) {
						w0 |= 0x003000;
						uses_w1++;
						w1 = yyvsp[0].ea.ext;
					} else {
						w0 |= yyvsp[0].ea.mode;
					}
					break;
			};
    break;}
case 174:
#line 1044 "a56.y"
{w0 |= 0x084080;
			w0 |= yyvsp[-1].ival << 16 | 1 << 15 | 0x34 << 8 | 
				(n2int(yyvsp[0].n) & 0x3F);
			uses_w1++;
			w1 = n2int(yyvsp[-3].n);;
    break;}
case 175:
#line 1050 "a56.y"
{w0 |= 0x084040;
			w0 |= yyvsp[-1].ival << 16 | 1 << 15 | (n2int(yyvsp[0].n) & 0x3F);;
    break;}
case 176:
#line 1053 "a56.y"
{w0 |= 0x084040;
			if(yyvsp[-3].ea.mode != 0x003000 && yyvsp[-3].ea.mode != 0)
				yyerror("illegal MOVEP");
			w0 |= yyvsp[-4].ival << 16 | 0 << 15 | (yyvsp[-3].ea.ext & 0x3F);;
    break;}
case 177:
#line 1058 "a56.y"
{w0 |= 0x084000;
			w0 |= yyvsp[-1].ival << 16 | 1 << 15 | yyvsp[-3].regs.r6 << 8 | 
				(n2int(yyvsp[0].n) & 0x3F);;
    break;}
case 178:
#line 1062 "a56.y"
{w0 |= 0x084000;
			if(!yyvsp[-2].ea.pp)
				yyerror("illegal MOVEP");
			w0 |= yyvsp[-3].ival << 16 | 0 << 15 | yyvsp[0].regs.r6 << 8 | (yyvsp[-2].ea.ext & 0x3F);;
    break;}
case 179:
#line 1070 "a56.y"
{if(yyvsp[0].ival != UNDEF && yyvsp[0].ival >= 0xFFC0) {
				/* defined symbol or constant, in i/o range */
				yyval.ea.pp = 1;
				yyval.ea.mode = 0;
			} else {
				/* either out of i/o range or symbol not */
				/* yet defined:  assume ea extension */
				yyval.ea.pp = 0;
				yyval.ea.mode = 0x003000;
			}
			yyval.ea.ext = yyvsp[0].ival;;
    break;}
case 180:
#line 1082 "a56.y"
{yyval.ea.pp = 1;
			yyval.ea.mode = 0;
			if(yyvsp[0].ival < 0xFFC0 && pass == 2)
				yyerror("warning: address operand truncated");
			yyval.ea.ext = yyvsp[0].ival;;
    break;}
case 181:
#line 1088 "a56.y"
{yyval.ea.pp = 0;
			yyval.ea.mode = yyvsp[0].ival << 8;
			yyval.ea.ext = yyvsp[0].ival;;
    break;}
case 182:
#line 1095 "a56.y"
{w0 |= 0x070000 | 0 << 15 | yyvsp[-3].regs.r6;;
    break;}
case 183:
#line 1097 "a56.y"
{w0 |= 0x070000 | 1 << 15 | yyvsp[0].regs.r6;;
    break;}
case 184:
#line 1104 "a56.y"
{int ival = n2int(yyvsp[0].n);
			yyval.ival = ival; if(ival > 0x17) 
				yyerror("%d: illegal bit number", ival);;
    break;}
case 185:
#line 1110 "a56.y"
{yyval.ival = 0;;
    break;}
case 186:
#line 1112 "a56.y"
{yyval.ival = 1;;
    break;}
case 187:
#line 1118 "a56.y"
{w0 |= 0x004080;;
    break;}
case 188:
#line 1120 "a56.y"
{w0 |= (yyvsp[0].ival & 0x3F) << 8;
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 189:
#line 1127 "a56.y"
{yyval.ival = 1;;
    break;}
case 190:
#line 1129 "a56.y"
{w0 |= yyvsp[0].ival & 0xFFF; yyval.ival = 0;
			if(yyvsp[0].ival > 0x0FFF && pass == 2)
				yyerror("warning: address operand truncated");
			;
    break;}
case 191:
#line 1136 "a56.y"
{w0 |= 0x003000;
			uses_w1++;
			w1 |= yyvsp[0].ival;
			yyval.ival = 0x003000;;
    break;}
case 192:
#line 1141 "a56.y"
{w0 |= yyvsp[0].ival << 8;
			yyval.ival = yyvsp[0].ival << 8;;
    break;}
case 193:
#line 1147 "a56.y"
{yyval.ival = yyvsp[0].ival;;
    break;}
case 194:
#line 1149 "a56.y"
{yyval.ival = 4 << 3 | yyvsp[-1].ival;;
    break;}
case 195:
#line 1151 "a56.y"
{yyval.ival = 5 << 3 | yyvsp[-3].ival;
			if(yyvsp[-3].ival != yyvsp[-1].ival) yyerror("Rn and Nn must be same number");;
    break;}
case 196:
#line 1154 "a56.y"
{yyval.ival = 7 << 3 | yyvsp[-1].ival;;
    break;}
case 197:
#line 1159 "a56.y"
{yyval.ival = 0 << 3 | yyvsp[-3].ival;
			if(yyvsp[-3].ival != yyvsp[0].ival) yyerror("Rn and Nn must be same number");;
    break;}
case 198:
#line 1162 "a56.y"
{yyval.ival = 1 << 3 | yyvsp[-3].ival;
			if(yyvsp[-3].ival != yyvsp[0].ival) yyerror("Rn and Nn must be same number");;
    break;}
case 199:
#line 1165 "a56.y"
{yyval.ival = 2 << 3 | yyvsp[-2].ival;;
    break;}
case 200:
#line 1167 "a56.y"
{yyval.ival = 3 << 3 | yyvsp[-2].ival;;
    break;}
case 201:
#line 1173 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x04 | yyvsp[0].ival;
			yyval.regs.sdx = yyvsp[0].ival;
			yyval.regs.xreg = yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_XREG|R_SDX|R_SFRAC;;
    break;}
case 202:
#line 1178 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x06 | yyvsp[0].ival;
			yyval.regs.sdy = yyvsp[0].ival;
			yyval.regs.yreg = yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_SDY|R_YREG|R_SFRAC;;
    break;}
case 203:
#line 1183 "a56.y"
{switch(yyvsp[0].ival) {
				case 0: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 0; 
					break;
				case 1: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 4; 
					break;
				case 2: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 2; 
					break;
			}
			yyval.regs.flags = R_R6|R_R5|R_UINT;;
    break;}
case 204:
#line 1196 "a56.y"
{switch(yyvsp[0].ival) {
				case 0: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 1; break;
				case 1: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 5; break;
				case 2: 
					yyval.regs.r6 = yyval.regs.r5 = 0x08 | 3; break;
			}
			yyval.regs.flags = R_R6|R_R5|R_UINT;;
    break;}
case 205:
#line 1206 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x0E;
			yyval.regs.sdx = yyval.regs.sdy = 0x2;
			yyval.regs.ab = 0;
			yyval.regs.lsd = 4;
			yyval.regs.flags = R_R6|R_R5|R_SDX|R_SDY|R_AB|R_LSD|R_SFRAC;;
    break;}
case 206:
#line 1212 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x0F;
			yyval.regs.sdx = yyval.regs.sdy = 0x3;
			yyval.regs.ab = 1;
			yyval.regs.lsd = 5;
			yyval.regs.flags = R_R6|R_R5|R_SDX|R_SDY|R_AB|R_LSD|R_SFRAC;;
    break;}
case 207:
#line 1218 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x10 | yyvsp[0].ival;
			yyval.regs.r4 = 0x00 | yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_R4|R_UINT;;
    break;}
case 208:
#line 1222 "a56.y"
{yyval.regs.r6 = yyval.regs.r5 = 0x18 | yyvsp[0].ival;
			yyval.regs.r4 = 0x08 | yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_R4|R_UINT;;
    break;}
case 209:
#line 1226 "a56.y"
{yyval.regs.r6 = 0x20 | yyvsp[0].ival;
			yyval.regs.r5 = -1;
			yyval.regs.ctl_reg = yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_CTL_REG|R_UINT;;
    break;}
case 210:
#line 1231 "a56.y"
{yyval.regs.r6 = 0x38 | yyvsp[0].ival;
			yyval.regs.r5 = -1;
			yyval.regs.ctl_reg = 0x18 | yyvsp[0].ival;
			yyval.regs.flags = R_R6|R_R5|R_CTL_REG|R_UINT;;
    break;}
case 211:
#line 1236 "a56.y"
{yyval.regs.lsd  = 0;
			yyval.regs.flags = R_LSD;;
    break;}
case 212:
#line 1239 "a56.y"
{yyval.regs.lsd = 1;
			yyval.regs.flags = R_LSD;;
    break;}
case 213:
#line 1242 "a56.y"
{yyval.regs.lsd = 2;
			yyval.regs.flags = R_LSD;;
    break;}
case 214:
#line 1245 "a56.y"
{yyval.regs.lsd = 3;
			yyval.regs.flags = R_LSD;;
    break;}
case 215:
#line 1248 "a56.y"
{yyval.regs.lsd = 6;
			yyval.regs.flags = R_LSD;;
    break;}
case 216:
#line 1251 "a56.y"
{yyval.regs.lsd = 7;
			yyval.regs.flags = R_LSD;;
    break;}
case 217:
#line 1257 "a56.y"
{yyval.ival = 1;;
    break;}
case 218:
#line 1259 "a56.y"
{yyval.ival = 2;;
    break;}
case 219:
#line 1261 "a56.y"
{yyval.ival = 3;;
    break;}
case 220:
#line 1263 "a56.y"
{yyval.ival = 4;;
    break;}
case 221:
#line 1265 "a56.y"
{yyval.ival = 5;;
    break;}
case 222:
#line 1267 "a56.y"
{yyval.ival = 6;;
    break;}
case 223:
#line 1269 "a56.y"
{yyval.ival = 7;;
    break;}
case 224:
#line 1274 "a56.y"
{yyval.ival = 0;;
    break;}
case 225:
#line 1276 "a56.y"
{yyval.ival = 1;;
    break;}
case 226:
#line 1278 "a56.y"
{yyval.ival = 2;;
    break;}
case 235:
#line 1295 "a56.y"
{int ival = n2int(yyvsp[-2].n);
			int frac = n2frac(yyvsp[-2].n);
			int value;
			BOOL shortform = FALSE;
			if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			if((yyvsp[0].regs.flags & R_SFRAC) && yyvsp[-2].n.type == FLT) {
				if((frac & 0xFFFF) == 0 && 
					NOT long_symbolic_expr) {
					value = frac >> 16;
					shortform++;
				} else {
					value = frac;
				}
			} else {
				if(ival <= 0xFF && ival >= -0xFF && NOT long_symbolic_expr) {
					value = ival;
					shortform++;
				} else {
					value = ival;
				}
			}

			if(shortform) {
				w0 |= 0x200000 | (value & 0xFF) << 8 |
					yyvsp[0].regs.r5 << 16;
			} else {
				w0 |= 0x400000 | 0x00F400 |
					(yyvsp[0].regs.r5 >> 3 & 3) << 20 | 
					(yyvsp[0].regs.r5 & 7) << 16;
				uses_w1++; w1 = value;
			};
    break;}
case 236:
#line 1332 "a56.y"
{
				if(yyvsp[0].regs.flags & R_CTL_REG) {
					yyerror("please use MOVEC for control register moves");
					break;
				}
				if(yyvsp[-2].regs.flags & R_R5 & yyvsp[0].regs.flags) 
					w0 |= 0x200000 | yyvsp[0].regs.r5 << 8 | yyvsp[-2].regs.r5 << 13;
				else
					yyerror("illegal R move");
			;
    break;}
case 237:
#line 1345 "a56.y"
{w0 |= 0x204000 | yyvsp[0].ival << 8;;
    break;}
case 238:
#line 1350 "a56.y"
{w0 |= 0x40C000 | yyvsp[-3].ival << 19;
			if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			w0 |= (yyvsp[0].regs.r5 >> 3 & 3) << 20 | (yyvsp[0].regs.r5 & 7) << 16;;
    break;}
case 239:
#line 1357 "a56.y"
{w0 |= 0x408000 | yyvsp[-3].ival << 19 | (yyvsp[-2].ival & 0x3F) << 8;
			if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			if(yyvsp[-2].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w0 |= (yyvsp[0].regs.r5>> 3 & 3) << 20 | (yyvsp[0].regs.r5 & 7) << 16;;
    break;}
case 240:
#line 1366 "a56.y"
{w0 |= 0x404000 | yyvsp[-1].ival << 19;
			if(yyvsp[-3].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			w0 |= (yyvsp[-3].regs.r5 >> 3 & 3) << 20 | (yyvsp[-3].regs.r5 & 7) << 16;;
    break;}
case 241:
#line 1373 "a56.y"
{w0 |= 0x400000 | yyvsp[-1].ival << 19 | (yyvsp[0].ival & 0x3F) << 8;
			if(yyvsp[-3].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w0 |= (yyvsp[-3].regs.r5 >> 3 & 3) << 20 | (yyvsp[-3].regs.r5 & 7) << 16;;
    break;}
case 242:
#line 1382 "a56.y"
{w0 |= 0x400000 | 0x00F400 | (yyvsp[0].regs.r5 >> 3 & 3) << 20 |
			    (yyvsp[0].regs.r5 & 7) << 16;
			if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			uses_w1++; w1 = n2frac(yyvsp[-2].n);
			;
    break;}
case 243:
#line 1393 "a56.y"
{if(yyvsp[-6].ival == 0 && yyvsp[-2].regs.flags & R_AB) {
				w0 |= 0x108000 | yyvsp[-3].regs.sdx << 18 | yyvsp[-2].regs.ab << 17 |
					yyvsp[0].ival << 16;
			} else {
				yyerror("illegal X:R move");
			};
    break;}
case 244:
#line 1400 "a56.y"
{if(yyvsp[-2].regs.flags & R_AB) {
				w0 |= 0x10B400 | yyvsp[-3].regs.sdx << 18 | yyvsp[-2].regs.ab << 17 |
					yyvsp[0].ival << 16;
				uses_w1++;
				w1 |= n2frac(yyvsp[-5].n) & 0xFFFFFF;
			} else {
				yyerror("illegal X:R move");
			};
    break;}
case 245:
#line 1409 "a56.y"
{if(yyvsp[-6].regs.flags & R_SDX && yyvsp[-4].ival == 0 && yyvsp[-2].regs.flags & R_AB &&
				yyvsp[0].regs.flags & R_YREG) {
				w0 |= 0x100000 | yyvsp[-6].regs.sdx << 18 | yyvsp[-2].regs.ab << 17 |
					yyvsp[0].regs.yreg << 16;
			} else if(yyvsp[-6].regs.flags & R_AB && yyvsp[-4].ival == 0 && 
				yyvsp[-2].regs.flags & R_XREG && yyvsp[0].regs.flags & R_AB) {
				if(yyvsp[-2].regs.xreg != 0) yyerror("must use X0");
				if(yyvsp[-6].regs.ab == 0 && yyvsp[0].regs.ab == 0)
					w0 |= 0x080000;
				else if(yyvsp[-6].regs.ab == 1 && yyvsp[0].regs.ab == 1)
					w0 |= 0x090000;
				else
					yyerror("illegal X:R move");
			} else {
				yyerror("illegal X:R move");
			};
    break;}
case 246:
#line 1428 "a56.y"
{if(yyvsp[-4].regs.flags & R_XREG && yyvsp[0].regs.flags & (R_YREG|R_AB)) {
				w0 |= 0x10C000 | yyvsp[-6].regs.ab << 19 | yyvsp[-4].regs.xreg << 18 |
					yyvsp[0].regs.sdy << 16;
			} else {
				yyerror("illegal R:Y move");
			};
    break;}
case 247:
#line 1435 "a56.y"
{if(yyvsp[-3].regs.flags & R_XREG && yyvsp[0].regs.flags & (R_YREG|R_AB)) {
				w0 |= 0x10F400 | yyvsp[-5].regs.ab << 19 | yyvsp[-3].regs.xreg << 18 |
					yyvsp[0].regs.sdy << 16;
				uses_w1++;
				w1 |= n2frac(yyvsp[-2].n) & 0xFFFFFF;
			} else {
				yyerror("illegal R:Y move");
			};
    break;}
case 248:
#line 1444 "a56.y"
{if(yyvsp[-6].regs.flags & R_AB && yyvsp[-4].regs.flags & R_XREG) {
				w0 |= 0x104000 | yyvsp[-6].regs.ab << 19 | yyvsp[-4].regs.xreg << 18 |
				yyvsp[-3].regs.sdy << 16;
			} else if (yyvsp[-6].regs.flags & R_YREG && yyvsp[-4].regs.flags & R_AB &&
				yyvsp[-3].regs.flags & R_AB) {
				if(yyvsp[-6].regs.yreg != 0) yyerror("must use Y0");
				if(yyvsp[-4].regs.ab == 0 && yyvsp[-3].regs.ab == 0)
					w0 |= 0x088000;
				else if(yyvsp[-4].regs.ab == 1 && yyvsp[-3].regs.ab == 1)
					w0 |= 0x098000;
				else
					yyerror("illegal R:Y move");
			} else {
				yyerror("illegal R:Y move");
			};
    break;}
case 249:
#line 1462 "a56.y"
{if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			w0 |= 0x40C000 | (yyvsp[0].regs.lsd & 3) << 16 | (yyvsp[0].regs.lsd >> 2) << 19;;
    break;}
case 250:
#line 1468 "a56.y"
{if(yyvsp[-3].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			w0 |= 0x404000 | (yyvsp[-3].regs.lsd & 3) << 16 | (yyvsp[-3].regs.lsd >> 2) << 19;;
    break;}
case 251:
#line 1474 "a56.y"
{w0 |= 0x408000 | (yyvsp[0].regs.lsd & 3) << 16 | (yyvsp[0].regs.lsd >> 2) << 19;
			if(yyvsp[0].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			if(yyvsp[-2].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w0 |= (yyvsp[-2].ival & 0x3F) << 8;;
    break;}
case 252:
#line 1483 "a56.y"
{w0 |= 0x400000 | (yyvsp[-3].regs.lsd & 3) << 16 | (yyvsp[-3].regs.lsd >> 2) << 19;
			if(yyvsp[-3].regs.flags & R_CTL_REG) {
				yyerror("please use MOVEC for control register moves");
				break;
			}
			if(yyvsp[0].ival > 0x003F && pass == 2)
				yyerror("warning: address operand truncated");
			w0 |= (yyvsp[0].ival & 0x3F) << 8;;
    break;}
case 253:
#line 1494 "a56.y"
{int eax = yyvsp[-6].ival, eay = yyvsp[-2].ival,
			     regx = (yyvsp[-4].regs.flags & R_AB) ? yyvsp[-4].regs.ab | 2 : yyvsp[-4].regs.xreg,
			     regy = (yyvsp[0].regs.flags & R_AB) ? yyvsp[0].regs.ab | 2 : yyvsp[0].regs.yreg;
			if((eax & 0x400) == (eay & 0x400))
				yyerror("registers must be in opposite halves");
			if(!(yyvsp[-4].regs.flags & (R_AB | R_XREG)))
				yyerror("invalid X move register");
			if(!(yyvsp[0].regs.flags & (R_AB | R_YREG)))
				yyerror("invalid Y move register");
			if(yyvsp[-4].regs.flags & R_AB &&
			   yyvsp[0].regs.flags & R_AB &&
			   yyvsp[-4].regs.ab == yyvsp[0].regs.ab)
				yyerror("duplicate destination register");
			w0 = w0 & 0xFF | 0xC08000;	/* both write */
			w0 |= eax & 0x1f00 | (eay & 0x300) << 5 | (eay & 0x1800) << 9 | regx << 18 | regy << 16;;
    break;}
case 254:
#line 1510 "a56.y"
{int eax = yyvsp[-6].ival, eay = yyvsp[0].ival,
			     regx = (yyvsp[-4].regs.flags & R_AB) ? yyvsp[-4].regs.ab | 2 : yyvsp[-4].regs.xreg,
			     regy = (yyvsp[-3].regs.flags & R_AB) ? yyvsp[-3].regs.ab | 2 : yyvsp[-3].regs.yreg;
			if((eax & 0x400) == (eay & 0x400))
				yyerror("registers must be in opposite halves");
			if(!(yyvsp[-4].regs.flags & (R_AB | R_XREG)))
				yyerror("invalid X move register");
			if(!(yyvsp[-3].regs.flags & (R_AB | R_YREG)))
				yyerror("invalid Y move register");
			w0 = w0 & 0xFF | 0x808000;	/* X:write, Y:read */
			w0 |= eax & 0x1f00 | (eay & 0x300) << 5 | (eay & 0x1800) << 9 | regx << 18 | regy << 16;;
    break;}
case 255:
#line 1522 "a56.y"
{int eax = yyvsp[-4].ival, eay = yyvsp[-2].ival,
			     regx = (yyvsp[-7].regs.flags & R_AB) ? yyvsp[-7].regs.ab | 2 : yyvsp[-7].regs.xreg,
			     regy = (yyvsp[0].regs.flags & R_AB) ? yyvsp[0].regs.ab | 2 : yyvsp[0].regs.yreg;
			if((eax & 0x400) == (eay & 0x400))
				yyerror("registers must be in opposite halves");
			if(!(yyvsp[-7].regs.flags & (R_AB | R_XREG)))
				yyerror("invalid X move register");
			if(!(yyvsp[0].regs.flags & (R_AB | R_YREG)))
				yyerror("invalid Y move register");
	      		w0 = w0 & 0xFF | 0xC00000;	/* X:read, Y:write */
			w0 |= eax & 0x1f00 | (eay & 0x300) << 5 | (eay & 0x1800) << 9 | regx << 18 | regy << 16;;
    break;}
case 256:
#line 1534 "a56.y"
{int eax = yyvsp[-4].ival, eay = yyvsp[0].ival,
			     regx = (yyvsp[-7].regs.flags & R_AB) ? yyvsp[-7].regs.ab | 2 : yyvsp[-7].regs.xreg,
			     regy = (yyvsp[-3].regs.flags & R_AB) ? yyvsp[-3].regs.ab | 2 : yyvsp[-3].regs.yreg;
			if((eax & 0x400) == (eay & 0x400))
				yyerror("registers must be in opposite halves");
			if(!(yyvsp[-7].regs.flags & (R_AB | R_XREG)))
				yyerror("invalid X move register");
			if(!(yyvsp[-3].regs.flags & (R_AB | R_YREG)))
				yyerror("invalid Y move register");
	      		w0 = w0 & 0xFF | 0x800000;	/* both read */
			w0 |= eax & 0x1f00 | (eay & 0x300) << 5 | (eay & 0x1800) << 9 | regx << 18 | regy << 16;;
    break;}
case 257:
#line 1550 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 258:
#line 1552 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 259:
#line 1554 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 260:
#line 1558 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 261:
#line 1560 "a56.y"
{yyval.n.val.i = n2int(yyvsp[0].n) & 0xFF;
			yyval.n.type = INT;
			long_symbolic_expr = FALSE;;
    break;}
case 262:
#line 1566 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 263:
#line 1571 "a56.y"
{yyval.ival = n2int(yyvsp[0].n);;
    break;}
case 264:
#line 1576 "a56.y"
{yyval.ival = n2int(yyvsp[0].n);;
    break;}
case 265:
#line 1581 "a56.y"
{yyval.ival = n2int(yyvsp[0].n);;
    break;}
case 266:
#line 1586 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 267:
#line 1588 "a56.y"
{yyval.n = sym_ref(yyvsp[0].sval); free(yyvsp[0].sval);;
    break;}
case 268:
#line 1590 "a56.y"
{yyval.n.type = INT; yyval.n.val.i = yyvsp[0].ival;;
    break;}
case 269:
#line 1595 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
case 270:
#line 1597 "a56.y"
{yyval.n = sym_ref(yyvsp[0].sval); free(yyvsp[0].sval); long_symbolic_expr++;;
    break;}
case 271:
#line 1599 "a56.y"
{yyval.n.type = INT; yyval.n.val.i = yyvsp[0].cval & 0xFFFFFF;;
    break;}
case 272:
#line 1601 "a56.y"
{yyval.n.type = INT; yyval.n.val.i = pc;;
    break;}
case 273:
#line 1606 "a56.y"
{yyval.n.type = INT; 
				if(yyvsp[-1].n.type == INT)
					yyval.n.val.i = yyvsp[-1].n.val.i;
				else
					yyval.n.val.i = yyvsp[-1].n.val.f;
			;
    break;}
case 274:
#line 1613 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '|', yyvsp[0].n);;
    break;}
case 275:
#line 1615 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '^', yyvsp[0].n);;
    break;}
case 276:
#line 1617 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '&', yyvsp[0].n);;
    break;}
case 277:
#line 1619 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, SHR, yyvsp[0].n);;
    break;}
case 278:
#line 1621 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, SHL, yyvsp[0].n);;
    break;}
case 279:
#line 1623 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '-', yyvsp[0].n);;
    break;}
case 280:
#line 1625 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '+', yyvsp[0].n);;
    break;}
case 281:
#line 1627 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '%', yyvsp[0].n);;
    break;}
case 282:
#line 1629 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '/', yyvsp[0].n);;
    break;}
case 283:
#line 1631 "a56.y"
{yyval.n = binary_op(yyvsp[-2].n, '*', yyvsp[0].n);;
    break;}
case 284:
#line 1633 "a56.y"
{yyval.n = unary_op('-', yyvsp[0].n);;
    break;}
case 285:
#line 1635 "a56.y"
{yyval.n = unary_op('~', yyvsp[0].n);;
    break;}
case 286:
#line 1637 "a56.y"
{yyval.n = yyvsp[-1].n;;
    break;}
case 287:
#line 1639 "a56.y"
{yyval.n = yyvsp[0].n;;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 465 "/usr/local/gnu/lib/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 1644 "a56.y"


#include <stdio.h>

int yydebug;

struct n binary_op(a1, op, a2)
struct n a1, a2;
int op;
{
	struct n result;

	if(a1.type == UNDEF || a2.type == UNDEF) {
		result.type = UNDEF;
		return result;
	}

	/* promote to float automatically */

	if(a1.type != a2.type) {
		if(a1.type == INT) {
			a1.val.f = a1.val.i;		/* truncate */
			a1.type = FLT;
		} else {
			a2.val.f = a2.val.i;		/* truncate */
		}
	}
	result.type = a1.type;

	/* do the op */

	if(result.type == INT) {
		switch(op) {
			case '+':		result.val.i = a1.val.i + a2.val.i; break;
			case '-':		result.val.i = a1.val.i - a2.val.i; break;
			case '*':		result.val.i = a1.val.i * a2.val.i; break;
			case '/':		result.val.i = a1.val.i / a2.val.i; break;
			case '%':		result.val.i = a1.val.i % a2.val.i; break;
			case SHL:		result.val.i = a1.val.i << a2.val.i; break;
			case SHR:		result.val.i = a1.val.i >> a2.val.i; break;
			case '|':		result.val.i = a1.val.i | a2.val.i; break;
			case '&':		result.val.i = a1.val.i & a2.val.i; break;
			case '^':		result.val.i = a1.val.i ^ a2.val.i; break;
		}
	} else {
		switch(op) {
			case '+':		result.val.f = a1.val.f + a2.val.f; break;
			case '-':		result.val.f = a1.val.f - a2.val.f; break;
			case '*':		result.val.f = a1.val.f * a2.val.f; break;
			case '/':		result.val.f = a1.val.f / a2.val.f; break;
			case '%':		result.val.f = (int)a1.val.f % (int)a2.val.f; break;
			case SHL:		result.val.f = (int)a1.val.f << (int)a2.val.f; break;
			case SHR:		result.val.f = (int)a1.val.f >> (int)a2.val.f; break;
			case '|':		result.val.f = (int)a1.val.f | (int)a2.val.f; break;
			case '&':		result.val.f = (int)a1.val.f & (int)a2.val.f; break;
			case '^':		result.val.f = (int)a1.val.f ^ (int)a2.val.f; break;
		}
	}

	return result;
}

struct n unary_op(op, a1)
int op;
struct n a1;
{
	struct n result;

	if(a1.type == UNDEF) {
		result.type = UNDEF;
		return result;
	}

	result.type = a1.type;

	/* do the op */

	if(result.type == INT) {
		switch(op) {
			case '-':		result.val.i = -a1.val.i; break;
			case '~':		result.val.i = ~a1.val.i; break;
		}
	} else {
		switch(op) {
			case '-':		result.val.f = -a1.val.f; break;
			case '~':		result.val.f = ~(int)a1.val.f; break;
		}
	}

	return result;
}

n2int(n)
struct n n;
{
	if(n.type == UNDEF)
		return UNDEF;
	else if(n.type == INT)
		return n.val.i;
	else
		return n.val.f;
}

n2frac(n)
struct n n;
{
	double adval = n.val.f >= 0.0 ? n.val.f : -n.val.f;

	if(n.type == UNDEF)
		return UNDEF;
	else if(n.type == INT)
		return n.val.i;
	else if(n.val.f == -1.0)
		return 0x800000;

	adval -= (double)(int)adval;
	adval *= (double)0x800000;
	adval += 0.5;

	if(n.val.f >= 0.0)
		return adval;
	else
		return -adval;
}

extern struct {int n; char *name;} tok_tab[];
extern int n_tok;

char *tok_print(tok)
int tok;
{
	int i;
	static char buf[32];

	if(tok < 256) {
		sprintf(buf, tok < ' ' ? "\\z%02X" : "%c", tok & 0xFF);
		return buf;
	} else {
		for(i = 0; i < n_tok; i++) {
			if(tok == tok_tab[i].n)
				return tok_tab[i].name;
		}
	}
	return "*bogus*";
}

yyerror(s, a0, a1, a2, a3)
char *s, *a0, *a1, *a2, *a3;
{
	extern int error;
	char buf[1024];

	error++;
	sprintf(buf, s, a0, a1, a2, a3);

	if(pass == 2) {
		fprintf(stderr, "%s: line %d: %s (tok=%s)\n", curfile, curline,
			buf, tok_print(yychar));
		fprintf(stderr, "%s\n", cur_line);
		printf("%s: line %d: %s (tok=%s)\n", curfile, curline,
			buf, tok_print(yychar));
	}
}

char *luntab(s)
char *s;
{
	static char buf[1024];
	int p;

	strcpy(buf, s);

	untab(buf);
	p = strlen(buf);

	if(buf[p - 1] == '\n')
		buf[p - 1] = '\0';

	return buf;
}
