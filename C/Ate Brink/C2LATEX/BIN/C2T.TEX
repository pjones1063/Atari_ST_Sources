%
% This file was automatically produced at Aug  2 1991, 12:10:30 by
% arg0 -o pipo.tex cc.c
%
\expandafter\ifx\csname indentation\endcsname\relax
\newlength{\indentation}\fi
\setlength{\indentation}{0.5em}
\begin{flushleft}
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ (c) copyright 1988 by the Vrije Universiteit, Amsterdam, The Netherlands.\mbox{}\\
\hspace*{1\indentation}$\ast$ See the copyright notice in the file "../Copyright".\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
\mbox{}\\
{$/\ast$\it{} Driver for Minix compilers.\mbox{}\\
\hspace*{3\indentation}Written june 1987 by Ceriel J.H. Jacobs, partly derived from old\mbox{}\\
\hspace*{3\indentation}cc-driver, written by Erik Baalbergen.\mbox{}\\
\hspace*{3\indentation}This driver is mostly table-driven, the table being in the form of\mbox{}\\
\hspace*{3\indentation}some global initialized structures.\mbox{}\\
$\ast/$}\mbox{}\\
\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{8\indentation}extensions added by Christoph van Wuellen (this work begun to\mbox{}\\
\hspace*{8\indentation}support my c68 68000 C-Compiler)\mbox{}\\
\hspace*{8\indentation}\mbox{}\\
\hspace*{8\indentation}- support of three alternate C compilers, selectable at runtime:\mbox{}\\
\hspace*{7\indentation}- the default is: ACK compiling system with 16-bit ints\mbox{}\\
\hspace*{7\indentation}- the -c68s option switches to c68 using 16-bit ints\mbox{}\\
\hspace*{7\indentation}- the -c68l option switches to c68 using 32-bit ints\mbox{}\\
\hspace*{7\indentation}- the -sozo option switches to the SOZOBON compiler with\mbox{}\\
\hspace*{14\indentation}16-bit ints. The postoptimizer is always applied.\mbox{}\\
\mbox{}\\
\hspace*{8\indentation}- two features selectable at compile time:\mbox{}\\
\hspace*{12\indentation}- support of ACK floating point stuff (inclusion of a fpp pass)\mbox{}\\
\hspace*{12\indentation}- support of the new MINIX linker posted to comp.os.minix\mbox{}\\
\mbox{}\\
$\ast/$}\mbox{}\\
\hspace*{3\indentation}\mbox{}\\
{\tt \#include} $<${\tt{}errno.h}$>$\mbox{}\\
{\tt \#include} $<${\tt{}signal.h}$>$\mbox{}\\
\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ For all program paths (so not the other files, like libraries) that\mbox{}\\
\hspace*{1\indentation}$\ast$ start with "/usr/" and are executable according to access(..., 1),\mbox{}\\
\hspace*{1\indentation}$\ast$ the leading "/usr" is stripped off.\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
\mbox{}\\
{\tt \#define} SHELL     {\tt"/bin/sh"}\mbox{}\\
\mbox{}\\
{\tt \#define} AS     {\tt"/usr/bin/as"}\mbox{}\\
{\tt \#define} CEM    {\tt"/usr/lib/cem"}\mbox{}\\
{\tt \#define} CG     {\tt"/usr/lib/cg"}\mbox{}\\
{\tt \#define} PP     {\tt"/usr/lib/cpp"}\mbox{}\\
{\tt \#define} CRT    {\tt"/usr/lib/crtso.o"}\mbox{}\\
{\tt \#define} CRT32           {\tt"/usr/lib/crtso32.o"}\mbox{}\\
{\tt \#define} CV     {\tt"/usr/lib/cv"}\mbox{}\\
{\tt \#define} PC     {\tt"/usr/lib/em\_pc"}\mbox{}\\
{\tt \#define} END    {\tt"/usr/lib/end.o"}\mbox{}\\
{\tt \#define} END32           {\tt"/usr/lib/end32.o"}\mbox{}\\
{\tt \#define} LD     {\tt"/usr/lib/ld"}\mbox{}\\
{\tt \#define} LIBC      {\tt"/usr/lib/liback.a"}\mbox{}\\
{\tt \#define} LIBC68    {\tt"/usr/lib/libc68.a"}\mbox{}\\
{\tt \#define} LIBC6832        {\tt"/usr/lib/libc68\_32.a"}\mbox{}\\
{\tt \#define} LIBSOZO      {\tt"/usr/lib/libsozo.a"}\mbox{}\\
{\tt \#define} LIBP      {\tt"/usr/lib/libp.a"}\mbox{}\\
{\tt \#define} OPT    {\tt"/usr/lib/opt"}\mbox{}\\
{\tt \#define} PRT    {\tt"/usr/lib/prtso.o"}\mbox{}\\
{\tt \#define} LIBPREFIX {\tt"/usr/lib/lib"}\mbox{}\\
\mbox{}\\
{\tt \#define} PEM    {\tt"-R/usr/lib/pem"}\mbox{}\\
{\tt \#define} PC\_ERR    {\tt"-r/usr/lib/pc\_errors"}\mbox{}\\
\mbox{}\\
{\tt \#define} C68    {\tt"/usr/lib/c68"}\mbox{}\\
{\tt \#define} FPP    {\tt"/usr/lib/fpp"}\mbox{}\\
{\tt \#define} HCC    {\tt"/usr/lib/hcc"}\mbox{}\\
{\tt \#define} TOP    {\tt"/usr/lib/top"}\mbox{}\\
{\tt \#define} NEW\_LD    {\tt"/usr/bin/ld"}\mbox{}\\
\mbox{}\\
\mbox{}\\
{$/\ast$\it{} every pass that this program knows about has associated with it\mbox{}\\
\hspace*{3\indentation}a structure, containing such information as its name, where it\mbox{}\\
\hspace*{3\indentation}resides, the flags it accepts, and the like.\mbox{}\\
$\ast/$}\mbox{}\\
{\bf struct} passinfo \{\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$p\_name;     {$/\ast$\it{} name of this pass $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$p\_path;     {$/\ast$\it{} where is it $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$p\_from;     {$/\ast$\it{} suffix of source (comma-separated list) $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$p\_to;    {$/\ast$\it{} suffix of destination $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$p\_acceptflags; {$/\ast$\it{} comma separated list; format:\mbox{}\\
\hspace*{18\indentation}flag\mbox{}\\
\hspace*{18\indentation}flag$\ast$\mbox{}\\
\hspace*{18\indentation}flag$=$xxx\mbox{}\\
\hspace*{15\indentation}flag$\ast$$=$xxx[$\ast$]\mbox{}\\
\hspace*{15\indentation}where a star matches a, possibly empty, \mbox{}\\
\hspace*{15\indentation}string\mbox{}\\
\hspace*{12\indentation}$\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf int}  p\_flags;\mbox{}\\
{\tt \#define} INPUT  01    {$/\ast$\it{} needs input file as argument $\ast/$}\mbox{}\\
{\tt \#define} OUTPUT 02    {$/\ast$\it{} needs output file as argument $\ast/$}\mbox{}\\
{\tt \#define} LOADER 04    {$/\ast$\it{} this pass is the loader $\ast/$}\mbox{}\\
{\tt \#define} STDIN  010      {$/\ast$\it{} reads from standard input $\ast/$}\mbox{}\\
{\tt \#define} STDOUT 020      {$/\ast$\it{} writes on standard output $\ast/$}\mbox{}\\
{\tt \#define} SOURCE 040      {$/\ast$\it{} give source file name as last argument\mbox{}\\
\hspace*{15\indentation}(hack for pc)\mbox{}\\
\hspace*{12\indentation}$\ast/$}\mbox{}\\
{\tt \#define} O\_OUTPUT 0100      {$/\ast$\it{} -o outputfile, hack for as $\ast/$}\mbox{}\\
{\tt \#define} PREPALWAYS   0200  {$/\ast$\it{} always to be preprocessed $\ast/$}\mbox{}\\
{\tt \#define} PREPCOND  0400  {$/\ast$\it{} preprocessed when starting with '\#' $\ast/$}\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\tt \#define} MAXHEAD   7\mbox{}\\
{\tt \#define} MAXTAIL   4\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ MAXPASS used to be 7, but with FPP possibly defined there is an\mbox{}\\
\hspace*{1\indentation}$\ast$ additional pass. If you choose the new linker, the number is again\mbox{}\\
\hspace*{1\indentation}$\ast$ smaller since the new linker does the 'cv' job, too.\mbox{}\\
\hspace*{1\indentation}$\ast$ A too high number does not matter, anyway.\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
{\tt \#define} MAXPASS   8\mbox{}\\
\mbox{}\\
{$/\ast$\it{} Every language handled by this program has a "compile" structure\mbox{}\\
\hspace*{3\indentation}associated with it, describing the start-suffix, how the driver for\mbox{}\\
\hspace*{3\indentation}this language is called, which passes must be called, which flags\mbox{}\\
\hspace*{3\indentation}and arguments must be passed to these passes, etc.\mbox{}\\
\hspace*{3\indentation}The language is determined by the suffix of the argument program.\mbox{}\\
\hspace*{3\indentation}However, if this suffix does not determine a language (DEFLANG),\mbox{}\\
\hspace*{3\indentation}the callname is used.\mbox{}\\
\hspace*{3\indentation}Notice that the 's' suffix does not determine a language, because\mbox{}\\
\hspace*{3\indentation}the input file could have been derived from f.i. a C-program.\mbox{}\\
\hspace*{3\indentation}So, if you use "cc x.s", the C-runtime system will be used, but if\mbox{}\\
\hspace*{3\indentation}you use "as x.s", it will not.\mbox{}\\
$\ast/$}\mbox{}\\
{\bf struct} compile \{\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$c\_suffix;      {$/\ast$\it{} starting suffix of this list of passes $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$c\_callname; {$/\ast$\it{} affects runtime system loaded with program $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf struct} pass \{\mbox{}\\
\hspace*{6\indentation}{\bf char} $\ast$pp\_name;    {$/\ast$\it{} name of the pass $\ast/$}\mbox{}\\
\hspace*{6\indentation}{\bf char} $\ast$pp\_head[MAXHEAD]; {$/\ast$\it{} args in front of filename $\ast/$}\mbox{}\\
\hspace*{6\indentation}{\bf char} $\ast$pp\_tail[MAXTAIL]; {$/\ast$\it{} args after filename $\ast/$}\mbox{}\\
\hspace*{3\indentation}\} c\_passes[MAXPASS];\mbox{}\\
\hspace*{3\indentation}{\bf int}  c\_flags;\mbox{}\\
{\tt \#define} DEFLANG      010   {$/\ast$\it{} this suffix determines a language $\ast/$}\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\bf struct} passinfo passinfo[] = \{\mbox{}\\
\hspace*{3\indentation}\{ {\tt"cpp"}, PP, 0, {\tt"i"}, {\tt"I$\ast$,D$\ast$,U$\ast$"}, INPUT$\mid$STDOUT \},\mbox{}\\
{\tt \#ifdef} C68\mbox{}\\
\hspace*{3\indentation}\{ {\tt"c68"}, C68, {\tt"i,c"}, {\tt"s"}, {\tt"Q$\ast$"}, INPUT$\mid$OUTPUT$\mid$PREPALWAYS \},\mbox{}\\
{\tt \#endif}\mbox{}\\
{\tt \#ifdef} FPP\mbox{}\\
\hspace*{3\indentation}\{ {\tt"fpp"}, FPP, {\tt"m"},   {\tt"n"}, {\tt""}, INPUT$\mid$OUTPUT \},\mbox{}\\
{\tt \#endif}\mbox{}\\
{\tt \#ifdef} HCC\mbox{}\\
\hspace*{3\indentation}\{ {\tt"hcc"}, HCC, {\tt"c"}, {\tt"x"}, {\tt"I$\ast$,D$\ast$,U$\ast$"}, STDIN$\mid$STDOUT \},\mbox{}\\
{\tt \#endif}\mbox{}\\
{\tt \#ifdef} TOP\mbox{}\\
\hspace*{3\indentation}\{ {\tt"top"}, TOP, {\tt"x"}, {\tt"s"}, {\tt""}, INPUT$\mid$OUTPUT \},\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\{ {\tt"cem"}, CEM, {\tt"i,c"}, {\tt"k"}, {\tt"R,p,w,T$\ast$,I$\ast$,D$\ast$,U$\ast$"}, INPUT$\mid$OUTPUT \},\mbox{}\\
\hspace*{3\indentation}\{ {\tt"pc"}, PC, {\tt"i,p"}, {\tt"k"}, {\tt"L,p,w,e,E,T$\ast$,\{$\ast$"}, INPUT$\mid$OUTPUT$\mid$SOURCE$\mid$PREPCOND \},\mbox{}\\
\hspace*{3\indentation}\{ {\tt"opt"}, OPT, {\tt"k"}, {\tt"m"}, {\tt"LIB$=$L"}, STDIN$\mid$STDOUT \},\mbox{}\\
{\tt \#ifdef} FPP\mbox{}\\
\hspace*{8\indentation}{$/\ast$\it{} cg processes fpp output $\ast/$}\mbox{}\\
\hspace*{3\indentation}\{ {\tt"cg"}, CG, {\tt"n"}, {\tt"s"}, {\tt"O$=$p4"}, INPUT$\mid$OUTPUT \},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{3\indentation}\{ {\tt"cg"}, CG, {\tt"m"}, {\tt"s"}, {\tt"O$=$p4"}, INPUT$\mid$OUTPUT \},\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\{ {\tt"as"}, AS, {\tt"i,s"}, {\tt"o"}, {\tt"T$\ast$"}, INPUT$\mid$O\_OUTPUT$\mid$PREPCOND \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{3\indentation}\{ {\tt"ld"}, NEW\_LD, {\tt"o"}, {\tt"out"}, {\tt"m$\ast$,r,s,u$\ast$,w"}, INPUT$\mid$O\_OUTPUT$\mid$LOADER \},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{3\indentation}\{ {\tt"ld"}, LD, {\tt"o"}, {\tt"out"}, {\tt"r,s"}, INPUT$\mid$LOADER \},\mbox{}\\
\hspace*{3\indentation}\{ {\tt"cv"}, CV, {\tt"out"}, 0, {\tt""}, INPUT$\mid$OUTPUT \}, {$/\ast$\it{} must come after loader $\ast/$}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\{ 0\}\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\bf struct} compile c68\_short\_pass =\mbox{}\\
\{  {\tt"c"}, {\tt"cc"},\mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"c68"}, \{{\tt"-Qshort"}\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"as"}, \{{\tt"-"}\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-X\_"},{\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\},\mbox{}\\
\hspace*{9\indentation}\{LIBC68, END\}\},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-c"}, {\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\}, \mbox{}\\
\hspace*{11\indentation}\{LIBC68, END\}\},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cv"}, \{0\}, \{0\} \}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\},\mbox{}\\
\hspace*{3\indentation}DEFLANG\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\bf struct} compile c68\_long\_pass =\mbox{}\\
\{  {\tt"c"}, {\tt"cc"},\mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"c68"}, \{{\tt"-Qnoshort"}\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"as"}, \{{\tt"-"}\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-X\_"},{\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT32\},\mbox{}\\
\hspace*{9\indentation}\{LIBC6832, END32\}\},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-c"}, {\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT32\}, \mbox{}\\
\hspace*{11\indentation}\{LIBC6832, END32\}\},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cv"}, \{0\}, \{0\} \}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\},\mbox{}\\
\hspace*{3\indentation}DEFLANG\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\bf struct} compile sozobon\_pass =\mbox{}\\
\{  {\tt"c"}, {\tt"cc"},\mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"hcc"}, \{0\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"top"}, \{0\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"as"}, \{{\tt"-"}\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-X\_"},{\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\},\mbox{}\\
\hspace*{9\indentation}\{LIBSOZO, END\}\},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-c"}, {\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\}, \mbox{}\\
\hspace*{11\indentation}\{LIBSOZO, END\}\},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cv"}, \{0\}, \{0\} \}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\},\mbox{}\\
\hspace*{3\indentation}DEFLANG\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ passes[C\_ACK\_PASS] has to be replaced by an alternate pass\mbox{}\\
\hspace*{1\indentation}$\ast$ if an alternate compiler is to be used\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
{\tt \#define} C\_ACK\_PASS 0 {$/\ast$\it{} look at the initialization of passes[] $\ast/$}\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}\mbox{}\\
{\bf struct} compile passes[] = \{\mbox{}\\
\{  {\tt"c"}, {\tt"cc"}, \mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"cem"}, \{{\tt"-L"}\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"opt"}, \{0\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} FPP\mbox{}\\
\hspace*{6\indentation}\{ {\tt"fpp"}, \{0\}, \{0\} \},\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cg"}, \{0\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"as"}, \{{\tt"-"}\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-X\_"},{\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\},\mbox{}\\
\hspace*{9\indentation}\{LIBC, END\}\},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-c"}, {\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, CRT\}, \mbox{}\\
\hspace*{11\indentation}\{LIBC, END\}\},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cv"}, \{0\}, \{0\} \}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\},\mbox{}\\
\hspace*{3\indentation}DEFLANG\mbox{}\\
\},\mbox{}\\
\{  {\tt"p"}, {\tt"pc"},\mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"pc"}, \{ PEM, PC\_ERR, {\tt"-Vw2i2j2p2f8l4"} \}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"opt"}, \{0\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cg"}, \{0\}, \{0\} \},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"as"}, \{{\tt"-"}\}, \{0\} \},\mbox{}\\
{\tt \#ifdef} NEW\_LD\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-X\_"},{\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, PRT\},\mbox{}\\
\hspace*{9\indentation}\{LIBP, LIBC, END\}\},\mbox{}\\
{\tt \#else}\mbox{}\\
\hspace*{6\indentation}\{ {\tt"ld"}, \{{\tt"-c"}, {\tt"-a0:2"}, {\tt"-a1:2"}, {\tt"-a2:2"}, {\tt"-a3:2"}, PRT\}, \mbox{}\\
\hspace*{11\indentation}\{LIBP, LIBC,\mbox{}\\
\hspace*{12\indentation}END\}\},\mbox{}\\
\hspace*{6\indentation}\{ {\tt"cv"}, \{0\}, \{0\} \}\mbox{}\\
{\tt \#endif}\mbox{}\\
\hspace*{3\indentation}\},\mbox{}\\
\hspace*{3\indentation}DEFLANG\mbox{}\\
\},\mbox{}\\
\{  {\tt"s"}, {\tt"as"},\mbox{}\\
\hspace*{3\indentation}\{  \{ {\tt"as"}, \{0\}, \{0\}\}\}, 0 \},\mbox{}\\
\{  0\}\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\tt \#define} MAXARGC   128   {$/\ast$\it{} maximum number of arguments allowed in a list $\ast/$}\mbox{}\\
{\tt \#define} USTR\_SIZE 64 {$/\ast$\it{} maximum length of string variable $\ast/$}\mbox{}\\
\mbox{}\\
{\bf typedef} {\bf char} USTRING[USTR\_SIZE];\mbox{}\\
\mbox{}\\
{\bf struct} arglist \{\mbox{}\\
\hspace*{3\indentation}{\bf int} al\_argc;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$al\_argv[MAXARGC];\mbox{}\\
\};\mbox{}\\
\mbox{}\\
{\bf struct} arglist CALLVEC[2];\mbox{}\\
\mbox{}\\
{\bf int} kids[] = \{-1, -1\};\mbox{}\\
\mbox{}\\
{\bf char} $\ast$o\_FILE = {\tt"a.out"}; {$/\ast$\it{} default name for executable file $\ast/$}\mbox{}\\
\mbox{}\\
{\tt \#define} init(a)      ((a)$\rightarrow$al\_argc = 1)\mbox{}\\
{\tt \#define} cleanup(str)    (str \&\& remove(str))\mbox{}\\
{\tt \#define} library(nm) \\mbox{}\\
\hspace*{3\indentation}mkstr(alloc(({\bf unsigned} {\bf int})strlen(nm) + strlen(LIBPREFIX) + 7), \\mbox{}\\
\hspace*{6\indentation}LIBPREFIX, nm, {\tt".a"})\mbox{}\\
\mbox{}\\
{\bf char} $\ast$ProgCall = 0;\mbox{}\\
\mbox{}\\
{\bf int} RET\_CODE = 0;\mbox{}\\
\mbox{}\\
{\bf char} $\ast$stopsuffix;\mbox{}\\
{\bf int} v\_flag = 0;\mbox{}\\
{\bf int} t\_flag = 0;\mbox{}\\
{\bf int} noexec = 0;\mbox{}\\
\mbox{}\\
{\bf char} $\ast$mkstr();\mbox{}\\
{\bf char} $\ast$alloc();\mbox{}\\
{\bf char} $\ast$process();\mbox{}\\
{\bf char} $\ast$strcpy(), $\ast$strcat();\mbox{}\\
\mbox{}\\
USTRING curfil;\mbox{}\\
USTRING newfil;\mbox{}\\
{\bf struct} arglist SRCFILES;\mbox{}\\
{\bf struct} arglist LDFILES;\mbox{}\\
{\bf struct} arglist GEN\_LDFILES;\mbox{}\\
{\bf struct} arglist FLAGS;\mbox{}\\
\mbox{}\\
{\bf char} $\ast$tmpdir = {\tt"/tmp"};\mbox{}\\
{\bf char} tmpname[64];\mbox{}\\
\mbox{}\\
{\bf struct} compile $\ast$compbase;\mbox{}\\
{\bf struct} pass $\ast$loader;\mbox{}\\
{\bf struct} passinfo $\ast$loaderinfo;\mbox{}\\
{\bf char} $\ast$source;\mbox{}\\
\mbox{}\\
trapcc(sig)\mbox{}\\
\hspace*{3\indentation}{\bf int} sig;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}signal(sig, SIG\_IGN);\mbox{}\\
\hspace*{3\indentation}{\bf if} (kids[0] $\neq$ -1) kill(kids[0], sig);\mbox{}\\
\hspace*{3\indentation}{\bf if} (kids[1] $\neq$ -1) kill(kids[1], sig);\mbox{}\\
\hspace*{3\indentation}cleanup(newfil);\mbox{}\\
\hspace*{3\indentation}cleanup(curfil);\mbox{}\\
\hspace*{3\indentation}exit(1);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ ck\_passes:\mbox{}\\
\hspace*{1\indentation}$\ast$ ensure that the different C compilers are not called at the same time\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
ck\_passes()\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf static} {\bf int}  pass\_changed = 0;\mbox{}\\
\hspace*{3\indentation}{\bf char}  $\ast$err = \mbox{}\\
\hspace*{6\indentation}{\tt"cc: the -ack, -sozo, -c68s and -c68l flags are exclusive$\backslash$n"};\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} (pass\_changed)\mbox{}\\
\hspace*{3\indentation}\{\mbox{}\\
\hspace*{6\indentation}write(2,err,strlen(err));\mbox{}\\
\hspace*{6\indentation}exit(1);\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}pass\_changed = 1;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
main(argc, argv)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$argv[];\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$str;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$$\ast$argvec;\mbox{}\\
\hspace*{3\indentation}{\bf int} count;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$file;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}ProgCall = $\ast$argv++;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}signal(SIGHUP, trapcc);\mbox{}\\
\hspace*{3\indentation}signal(SIGINT, trapcc);\mbox{}\\
\hspace*{3\indentation}signal(SIGQUIT, trapcc);\mbox{}\\
\hspace*{3\indentation}{\bf while} (-{}-argc $>$ 0) \{\mbox{}\\
\hspace*{6\indentation}{\bf if} ($\ast$(str = $\ast$argv++) $\neq$ '-') \{\mbox{}\\
\hspace*{9\indentation}append(\&SRCFILES, str);\mbox{}\\
\hspace*{9\indentation}{\bf continue};\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf switch} (str[1]) \{\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf case} 'a':\mbox{}\\
\hspace*{9\indentation}{\bf if} (!strcmp(str,{\tt"-ack"})) \{\mbox{}\\
\hspace*{13\indentation}ck\_passes();\mbox{}\\
\hspace*{13\indentation}{$/\ast$\it{} is default, so no action is needed $\ast/$}\mbox{}\\
\hspace*{9\indentation}\} {\bf else} \{\mbox{}\\
\hspace*{13\indentation}append(\&FLAGS, str);\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{6\indentation}{\bf case} 'c':\mbox{}\\
\hspace*{9\indentation}{\bf if} (!strcmp(str,{\tt"-c68s"})) \{\mbox{}\\
\hspace*{13\indentation}ck\_passes();\mbox{}\\
\hspace*{13\indentation}passes[C\_ACK\_PASS] = c68\_short\_pass;\mbox{}\\
\hspace*{9\indentation}\} {\bf else} {\bf if} (!strcmp(str,{\tt"-c68l"})) \{\mbox{}\\
\hspace*{13\indentation}ck\_passes();\mbox{}\\
\hspace*{13\indentation}passes[C\_ACK\_PASS] = c68\_long\_pass;\mbox{}\\
\hspace*{9\indentation}\} {\bf else} \{\mbox{}\\
\hspace*{13\indentation}stopsuffix = {\tt"o"};\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'F':\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'l':\mbox{}\\
\hspace*{9\indentation}append(\&SRCFILES, library(\&str[2]));\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'o':\mbox{}\\
\hspace*{9\indentation}{\bf if} (argc-{}- $\geq$ 0)\mbox{}\\
\hspace*{12\indentation}o\_FILE = $\ast$argv++;\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'S':\mbox{}\\
\hspace*{9\indentation}stopsuffix = {\tt"s"};\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'v':\mbox{}\\
\hspace*{9\indentation}v\_flag++;\mbox{}\\
\hspace*{9\indentation}{\bf if} (str[2] == 'n')\mbox{}\\
\hspace*{12\indentation}noexec = 1;\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 't':\mbox{}\\
\hspace*{9\indentation}{$/\ast$\it{} save temporaries $\ast/$}\mbox{}\\
\hspace*{9\indentation}t\_flag++;\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 's':\mbox{}\\
\hspace*{9\indentation}{\bf if} (!strcmp(str,{\tt"-sozo"})) \{\mbox{}\\
\hspace*{13\indentation}ck\_passes();\mbox{}\\
\hspace*{13\indentation}passes[C\_ACK\_PASS] = sozobon\_pass;\mbox{}\\
\hspace*{9\indentation}\} {\bf else} \{\mbox{}\\
\hspace*{13\indentation}append(\&FLAGS, str);\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}{\bf case} 'T':\mbox{}\\
\hspace*{9\indentation}tmpdir = \&str[2];\mbox{}\\
\hspace*{9\indentation}{$/\ast$\it{}FALLTHROUGH$\ast/$}\mbox{}\\
\hspace*{6\indentation}{\bf default}:\mbox{}\\
\hspace*{9\indentation}append(\&FLAGS, str);\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\mbox{}\\
{$/\ast$\it{}\mbox{}\\
\hspace*{1\indentation}$\ast$ The call to mkbase has to be delayed until now since passes[]\mbox{}\\
\hspace*{1\indentation}$\ast$ is not initialized till now.\mbox{}\\
\hspace*{1\indentation}$\ast/$}\mbox{}\\
\hspace*{8\indentation}mkbase();\mbox{}\\
\hspace*{3\indentation}mktempname(tmpname);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}count = SRCFILES.al\_argc;\mbox{}\\
\hspace*{3\indentation}argvec = \&(SRCFILES.al\_argv[0]);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf while} (count-{}- $>$ 0) \{\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}file = $\ast$argvec++;\mbox{}\\
\hspace*{6\indentation}source = file;\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf if} (SRCFILES.al\_argc $>$ 1) \{\mbox{}\\
\hspace*{9\indentation}write(1, file, strlen(file));\mbox{}\\
\hspace*{9\indentation}write(1, {\tt":$\backslash$n"}, 2);\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}file = process(file, 1);\mbox{}\\
\hspace*{3\indentation}\mbox{}\\
\hspace*{6\indentation}{\bf if} (file \&\& ! stopsuffix) append(\&LDFILES, file);\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}clean(\&SRCFILES);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{$/\ast$\it{} loader ... $\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf if} (RET\_CODE == 0 \&\& LDFILES.al\_argc $>$ 0) \{\mbox{}\\
\hspace*{6\indentation}{\bf register} {\bf struct} passinfo $\ast$pp = passinfo;\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf while} (!(pp$\rightarrow$p\_flags \& LOADER)) pp++;\mbox{}\\
\hspace*{6\indentation}mkstr(newfil, tmpname, pp$\rightarrow$p\_to, {\tt""});\mbox{}\\
\hspace*{6\indentation}callld(\&LDFILES, !((pp+1)$\rightarrow$p\_name) ? o\_FILE : newfil, loader, pp);\mbox{}\\
\hspace*{6\indentation}{\bf if} (RET\_CODE == 0) \{\mbox{}\\
\hspace*{9\indentation}{\bf register} {\bf int} i = GEN\_LDFILES.al\_argc;\mbox{}\\
\mbox{}\\
\hspace*{9\indentation}{\bf while} (i-{}- $>$ 0) \{\mbox{}\\
\hspace*{12\indentation}remove(GEN\_LDFILES.al\_argv[i]);\mbox{}\\
\hspace*{12\indentation}free(GEN\_LDFILES.al\_argv[i]);\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf if} ((++pp)$\rightarrow$p\_name) \{\mbox{}\\
\hspace*{12\indentation}process(newfil, 0);\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}exit(RET\_CODE);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
remove(str)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$str;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf if} (t\_flag)\mbox{}\\
\hspace*{6\indentation}{\bf return};\mbox{}\\
\hspace*{3\indentation}{\bf if} (v\_flag) \{\mbox{}\\
\hspace*{6\indentation}prs({\tt"rm "});\mbox{}\\
\hspace*{6\indentation}prs(str);\mbox{}\\
\hspace*{6\indentation}prs({\tt"$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (noexec)\mbox{}\\
\hspace*{6\indentation}{\bf return};\mbox{}\\
\hspace*{3\indentation}unlink(str);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{\bf char} $\ast$\mbox{}\\
alloc(u)\mbox{}\\
\hspace*{3\indentation}{\bf unsigned} u;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$malloc();\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$p = malloc(u);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} (p == 0) panic({\tt"no space$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}{\bf return} p;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
append(al, arg)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$al;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$arg;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$a = alloc(({\bf unsigned}) (strlen(arg) + 1));\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}strcpy(a, arg);\mbox{}\\
\hspace*{3\indentation}{\bf if} (al$\rightarrow$al\_argc $\geq$ MAXARGC)\mbox{}\\
\hspace*{6\indentation}panic({\tt"argument list overflow$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}al$\rightarrow$al\_argv[(al$\rightarrow$al\_argc)++] = a;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
concat(al1, al2)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$al1, $\ast$al2;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} i = al2$\rightarrow$al\_argc;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$$\ast$p = \&(al1$\rightarrow$al\_argv[al1$\rightarrow$al\_argc]);\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$$\ast$q = \&(al2$\rightarrow$al\_argv[0]);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} ((al1$\rightarrow$al\_argc += i) $\geq$ MAXARGC)\mbox{}\\
\hspace*{6\indentation}panic({\tt"argument list overflow$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}{\bf while} (i-{}- $>$ 0)\mbox{}\\
\hspace*{6\indentation}$\ast$p++ = $\ast$q++;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{\bf char} $\ast$\mbox{}\\
mkstr(dst, arg1, arg2, arg3)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$dst, $\ast$arg1, $\ast$arg2, $\ast$arg3;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$p;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$q = dst;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}p = arg1;\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$q++ = $\ast$p++);\mbox{}\\
\hspace*{3\indentation}q-{}-;\mbox{}\\
\hspace*{3\indentation}p = arg2;\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$q++ = $\ast$p++);\mbox{}\\
\hspace*{3\indentation}q-{}-;\mbox{}\\
\hspace*{3\indentation}p = arg3;\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$q++ = $\ast$p++);\mbox{}\\
\hspace*{3\indentation}q-{}-;\mbox{}\\
\hspace*{3\indentation}{\bf return} dst;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
basename(str, dst)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$str;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$dst;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$p1 = str;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$p2 = p1;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$p1)\mbox{}\\
\hspace*{6\indentation}{\bf if} ($\ast$p1++ == '/')\mbox{}\\
\hspace*{9\indentation}p2 = p1;\mbox{}\\
\hspace*{3\indentation}p1-{}-;\mbox{}\\
\hspace*{3\indentation}{\bf if} ($\ast$-{}-p1 == '.') \{\mbox{}\\
\hspace*{6\indentation}$\ast$p1 = '\0';\mbox{}\\
\hspace*{6\indentation}{\bf while} ($\ast$dst++ = $\ast$p2++);\mbox{}\\
\hspace*{6\indentation}$\ast$p1 = '.';\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf else}\mbox{}\\
\hspace*{6\indentation}{\bf while} ($\ast$dst++ = $\ast$p2++);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{\bf char} $\ast$\mbox{}\\
extension(fln)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$fln;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$fn = fln;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$fn) fn++;\mbox{}\\
\hspace*{3\indentation}{\bf while} (fn $>$ fln \&\& $\ast$fn $\neq$ '.') fn-{}-;\mbox{}\\
\hspace*{3\indentation}{\bf if} (fn $\neq$ fln) {\bf return} fn+1;\mbox{}\\
\hspace*{3\indentation}{\bf return} ({\bf char} $\ast$)0;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
runvec(vec, pass, in, out)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$vec;\mbox{}\\
\hspace*{3\indentation}{\bf struct} passinfo $\ast$pass;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$in, $\ast$out;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf int} pid, status;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} (\mbox{}\\
\hspace*{6\indentation}strncmp(vec$\rightarrow$al\_argv[1], {\tt"/usr/"}, 5) == 0\mbox{}\\
\hspace*{6\indentation}\&\&\mbox{}\\
\hspace*{6\indentation}access(vec$\rightarrow$al\_argv[1] + 4, 1) == 0\mbox{}\\
\hspace*{3\indentation})\mbox{}\\
\hspace*{6\indentation}strcpy(vec$\rightarrow$al\_argv[1], vec$\rightarrow$al\_argv[1] + 4);\mbox{}\\
\hspace*{3\indentation}{\bf if} (v\_flag) \{\mbox{}\\
\hspace*{6\indentation}pr\_vec(vec);\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$p\_flags \& STDIN) \{\mbox{}\\
\hspace*{9\indentation}prs({\tt" $<$"});\mbox{}\\
\hspace*{9\indentation}prs(in);\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$p\_flags \& STDOUT) \{\mbox{}\\
\hspace*{9\indentation}prs({\tt" $>$"});\mbox{}\\
\hspace*{9\indentation}prs(out);\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}prs({\tt"$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (noexec)\mbox{}\\
\hspace*{6\indentation}{\bf return} 1;\mbox{}\\
\hspace*{3\indentation}{\bf if} ((pid = fork()) == 0) \{ {$/\ast$\it{} start up the process $\ast/$}\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$p\_flags \& STDIN) \{ {$/\ast$\it{} redirect standard input $\ast/$}\mbox{}\\
\hspace*{9\indentation}close(0);\mbox{}\\
\hspace*{9\indentation}{\bf if} (open(in, 0) $\neq$ 0)\mbox{}\\
\hspace*{12\indentation}panic({\tt"cannot open input file$\backslash$n"});\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$p\_flags \& STDOUT) \{ {$/\ast$\it{} redirect standard output $\ast/$}\mbox{}\\
\hspace*{9\indentation}close(1);\mbox{}\\
\hspace*{9\indentation}{\bf if} (creat(out, 0666) $\neq$ 1)\mbox{}\\
\hspace*{12\indentation}panic({\tt"cannot create output file$\backslash$n"});\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}ex\_vec(vec);\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (pid == -1)\mbox{}\\
\hspace*{6\indentation}panic({\tt"no more processes$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}kids[0] = pid;\mbox{}\\
\hspace*{3\indentation}clean(vec);\mbox{}\\
\hspace*{3\indentation}wait(\&status);\mbox{}\\
\hspace*{3\indentation}kids[0] = -1;\mbox{}\\
\hspace*{3\indentation}{\bf return} status ? ((RET\_CODE = 1), 0) : 1;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
prs(str)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$str;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf if} (str \&\& $\ast$str)\mbox{}\\
\hspace*{6\indentation}write(2, str, strlen(str));\mbox{}\\
\}\mbox{}\\
\mbox{}\\
panic(str)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$str;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}prs(str);\mbox{}\\
\hspace*{3\indentation}trapcc(SIGINT);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
pr\_vec(vec)\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} arglist $\ast$vec;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$$\ast$ap = \&vec$\rightarrow$al\_argv[1];\mbox{}\\
\hspace*{3\indentation}\mbox{}\\
\hspace*{3\indentation}vec$\rightarrow$al\_argv[vec$\rightarrow$al\_argc] = 0;\mbox{}\\
\hspace*{3\indentation}prs($\ast$ap);\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$++ap) \{\mbox{}\\
\hspace*{6\indentation}prs({\tt" "});\mbox{}\\
\hspace*{6\indentation}{\bf if} (strlen($\ast$ap))\mbox{}\\
\hspace*{9\indentation}prs($\ast$ap);\mbox{}\\
\hspace*{6\indentation}{\bf else}\mbox{}\\
\hspace*{9\indentation}prs({\tt"(empty)"});\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\}\mbox{}\\
\mbox{}\\
ex\_vec(vec)\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} arglist $\ast$vec;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf extern} {\bf int} errno;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}vec$\rightarrow$al\_argv[vec$\rightarrow$al\_argc] = 0;\mbox{}\\
\hspace*{3\indentation}execv(vec$\rightarrow$al\_argv[1], \&(vec$\rightarrow$al\_argv[1]));\mbox{}\\
\hspace*{3\indentation}{\bf if} (errno == ENOEXEC) \{ {$/\ast$\it{} not an a.out, try it with the SHELL $\ast/$}\mbox{}\\
\hspace*{6\indentation}vec$\rightarrow$al\_argv[0] = SHELL;\mbox{}\\
\hspace*{6\indentation}execv(SHELL, \&(vec$\rightarrow$al\_argv[0]));\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (access(vec$\rightarrow$al\_argv[1], 1) == 0) \{\mbox{}\\
\hspace*{6\indentation}{$/\ast$\it{} File is executable. $\ast/$}\mbox{}\\
\hspace*{6\indentation}prs({\tt"Cannot execute "});\mbox{}\\
\hspace*{6\indentation}prs(vec$\rightarrow$al\_argv[1]);\mbox{}\\
\hspace*{6\indentation}prs({\tt". Not enough memory.$\backslash$n"});\mbox{}\\
\hspace*{6\indentation}prs({\tt"Use chmem to reduce its stack allocation$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}\} {\bf else} \{\mbox{}\\
\hspace*{6\indentation}prs(vec$\rightarrow$al\_argv[1]);\mbox{}\\
\hspace*{6\indentation}prs({\tt" is not executable$\backslash$n"});\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}exit(1);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
mktempname(nm)\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$nm;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} i;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} pid = getpid();\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}strcpy(nm, tmpdir);\mbox{}\\
\hspace*{3\indentation}strcat(nm, {\tt"/"});\mbox{}\\
\hspace*{3\indentation}strcat(nm, compbase$\rightarrow$c\_callname);\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$nm) nm++;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf for} (i = 9; i $>$ 3; i-{}-) \{\mbox{}\\
\hspace*{6\indentation}$\ast$nm++ = (pid \% 10) + '0';\mbox{}\\
\hspace*{6\indentation}pid /= 10;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}$\ast$nm++ = '.';\mbox{}\\
\hspace*{3\indentation}$\ast$nm++ = '\0'; {$/\ast$\it{} null termination $\ast/$}\mbox{}\\
\}\mbox{}\\
\mbox{}\\
mkbase()\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} compile $\ast$p = passes;\mbox{}\\
\hspace*{3\indentation}USTRING callname;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}basename(ProgCall, callname);\mbox{}\\
\hspace*{3\indentation}{\bf while} (p$\rightarrow$c\_suffix) \{\mbox{}\\
\hspace*{6\indentation}{\bf if} (strcmp(p$\rightarrow$c\_callname, callname) == 0) \{\mbox{}\\
\hspace*{9\indentation}compbase = p;\mbox{}\\
\hspace*{9\indentation}mkloader();\mbox{}\\
\hspace*{9\indentation}{\bf return};\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}p++;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{$/\ast$\it{} we should not get here $\ast/$}\mbox{}\\
\hspace*{3\indentation}panic({\tt"internal error$\backslash$n"});\mbox{}\\
\}\mbox{}\\
\mbox{}\\
mkloader()\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} passinfo $\ast$p = passinfo;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} pass $\ast$pass;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf while} (!(p$\rightarrow$p\_flags \& LOADER)) p++;\mbox{}\\
\hspace*{3\indentation}loaderinfo = p;\mbox{}\\
\hspace*{3\indentation}pass = \&(compbase$\rightarrow$c\_passes[0]);\mbox{}\\
\hspace*{3\indentation}{\bf while} (strcmp(pass$\rightarrow$pp\_name, p$\rightarrow$p\_name)) pass++;\mbox{}\\
\hspace*{3\indentation}loader = pass;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
needsprep(name)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$name;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf int} file;\mbox{}\\
\hspace*{3\indentation}{\bf char} fc;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}file = open(name,0);\mbox{}\\
\hspace*{3\indentation}{\bf if} (file $<$0) {\bf return} 0;\mbox{}\\
\hspace*{3\indentation}{\bf if} (read(file, \&fc, 1) $\neq$ 1) fc = 0;\mbox{}\\
\hspace*{3\indentation}close(file);\mbox{}\\
\hspace*{3\indentation}{\bf return} fc == '\#';\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{\bf char} $\ast$\mbox{}\\
apply(pinf, cp, name, passindex, noremove, first, resultname)\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} passinfo $\ast$pinf;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} compile $\ast$cp;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$name, $\ast$resultname;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{$/\ast$\it{} Apply a pass, indicated by "pinf", with args in \mbox{}\\
\hspace*{6\indentation}cp-$>$c\_passes[passindex], to name "name", leaving the result\mbox{}\\
\hspace*{6\indentation}in a file with name "resultname", concatenated with result\mbox{}\\
\hspace*{6\indentation}suffix.\mbox{}\\
\hspace*{6\indentation}When neccessary, the preprocessor is run first.\mbox{}\\
\hspace*{6\indentation}If "noremove" is NOT set, the file "name" is removed.\mbox{}\\
\hspace*{3\indentation}$\ast/$}\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$call = \&CALLVEC[0];\mbox{}\\
\hspace*{3\indentation}{\bf struct} pass $\ast$pass = \&(cp$\rightarrow$c\_passes[passindex]);\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$outname;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} ( {$/\ast$\it{} this pass is the first pass $\ast/$}\mbox{}\\
\hspace*{8\indentation}first\mbox{}\\
\hspace*{6\indentation}\&\&\mbox{}\\
\hspace*{8\indentation}( {$/\ast$\it{} preprocessor always needed $\ast/$}\mbox{}\\
\hspace*{10\indentation}(pinf$\rightarrow$p\_flags \& PREPALWAYS)\mbox{}\\
\hspace*{8\indentation}$\mid\mid${$/\ast$\it{} or only when "needsprep" says so $\ast/$}\mbox{}\\
\hspace*{10\indentation}( (pinf$\rightarrow$p\_flags \& PREPCOND) \&\& needsprep(name))\mbox{}\\
\hspace*{8\indentation})\mbox{}\\
\hspace*{6\indentation}) \{\mbox{}\\
\hspace*{6\indentation}mkstr(newfil, tmpname, passinfo[0].p\_to, {\tt""});\mbox{}\\
\hspace*{6\indentation}mkvec(call, name, newfil, ({\bf struct} pass $\ast$) 0, \&passinfo[0]);\mbox{}\\
\hspace*{6\indentation}{\bf if} (! runvec(call, \&passinfo[0], name, newfil)) \{\mbox{}\\
\hspace*{9\indentation}cleanup(newfil);\mbox{}\\
\hspace*{9\indentation}{\bf return} 0;\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}strcpy(curfil, newfil);\mbox{}\\
\hspace*{6\indentation}newfil[0] = '\0';\mbox{}\\
\hspace*{6\indentation}name = curfil;\mbox{}\\
\hspace*{6\indentation}noremove = 0;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_to) outname = mkstr(newfil, resultname, pinf$\rightarrow$p\_to, {\tt""});\mbox{}\\
\hspace*{3\indentation}{\bf else} outname = o\_FILE;\mbox{}\\
\hspace*{3\indentation}mkvec(call, name, outname, pass, pinf);\mbox{}\\
\hspace*{3\indentation}{\bf if} (! runvec(call, pinf, name, outname)) \{\mbox{}\\
\hspace*{6\indentation}cleanup(outname);\mbox{}\\
\hspace*{6\indentation}{\bf if} (! noremove) cleanup(name);\mbox{}\\
\hspace*{6\indentation}{\bf return} 0;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (! noremove) cleanup(name);\mbox{}\\
\hspace*{3\indentation}strcpy(curfil, newfil);\mbox{}\\
\hspace*{3\indentation}newfil[0] = '\0';\mbox{}\\
\hspace*{3\indentation}{\bf return} curfil;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
{\bf int}\mbox{}\\
applicable(pinf, suffix)\mbox{}\\
\hspace*{3\indentation}{\bf struct} passinfo $\ast$pinf;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$suffix;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{$/\ast$\it{} Return one if the pass indicated by "pinfo" is applicable to\mbox{}\\
\hspace*{6\indentation}a file with suffix "suffix".\mbox{}\\
\hspace*{3\indentation}$\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf char} $\ast$sfx = pinf$\rightarrow$p\_from;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} (! suffix) {\bf return} 0;\mbox{}\\
\hspace*{3\indentation}{\bf while} ($\ast$sfx) \{\mbox{}\\
\hspace*{6\indentation}{\bf char} c;\mbox{}\\
\hspace*{6\indentation}{\bf register} {\bf char} $\ast$p = sfx;\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf while} ($\ast$p \&\& $\ast$p $\neq$ ',') p++;\mbox{}\\
\hspace*{6\indentation}c = $\ast$p; $\ast$p = 0;\mbox{}\\
\hspace*{6\indentation}{\bf if} (strcmp(sfx, suffix) == 0) \{\mbox{}\\
\hspace*{9\indentation}$\ast$p = c;\mbox{}\\
\hspace*{9\indentation}{\bf return} 1;\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}$\ast$p = c;\mbox{}\\
\hspace*{6\indentation}{\bf if} ($\ast$p == ',') sfx = p+1;\mbox{}\\
\hspace*{6\indentation}{\bf else} sfx = p;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf return} 0;\mbox{}\\
\}\mbox{}\\
\hspace*{6\indentation}\mbox{}\\
{\bf char} $\ast$\mbox{}\\
process(name, noremove)\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$name;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} compile $\ast$cp = passes;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$suffix = extension(name);\mbox{}\\
\hspace*{3\indentation}USTRING base;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} pass $\ast$pass;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} passinfo $\ast$pinf;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf if} (! suffix) {\bf return} name;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}basename(name, base);\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf while} (cp$\rightarrow$c\_suffix) \{\mbox{}\\
\hspace*{6\indentation}{\bf if} ((cp$\rightarrow$c\_flags \& DEFLANG) \&\&\mbox{}\\
\hspace*{10\indentation}strcmp(cp$\rightarrow$c\_suffix, suffix) == 0)\mbox{}\\
\hspace*{9\indentation}{\bf break};\mbox{}\\
\hspace*{6\indentation}cp++;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (! cp$\rightarrow$c\_suffix) cp = compbase;\mbox{}\\
\hspace*{3\indentation}pass = cp$\rightarrow$c\_passes;\mbox{}\\
\hspace*{3\indentation}{\bf while} (pass$\rightarrow$pp\_name) \{\mbox{}\\
\hspace*{6\indentation}{\bf int} first = 1;\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf for} (pinf=passinfo; strcmp(pass$\rightarrow$pp\_name,pinf$\rightarrow$p\_name);pinf++)\mbox{}\\
\hspace*{9\indentation};\mbox{}\\
\hspace*{6\indentation}{\bf if} (! (pinf$\rightarrow$p\_flags \& LOADER) \&\& applicable(pinf, suffix)) \{\mbox{}\\
\hspace*{9\indentation}{\bf int} cont = ! stopsuffix $\mid\mid$ ! pinf$\rightarrow$p\_to $\mid\mid$\mbox{}\\
\hspace*{15\indentation}strcmp(stopsuffix, pinf$\rightarrow$p\_to) $\neq$ 0;\mbox{}\\
\hspace*{9\indentation}name = apply(pinf,\mbox{}\\
\hspace*{17\indentation}cp,\mbox{}\\
\hspace*{17\indentation}name,\mbox{}\\
\hspace*{17\indentation}({\bf int})(pass - cp$\rightarrow$c\_passes),\mbox{}\\
\hspace*{17\indentation}noremove,\mbox{}\\
\hspace*{17\indentation}first,\mbox{}\\
\hspace*{17\indentation}applicable(loaderinfo, pinf$\rightarrow$p\_to) $\mid\mid$\mbox{}\\
\hspace*{18\indentation}!cont ?\mbox{}\\
\hspace*{15\indentation}strcat(base, {\tt"."}) :\mbox{}\\
\hspace*{15\indentation}tmpname);\mbox{}\\
\hspace*{9\indentation}first = noremove = 0;\mbox{}\\
\hspace*{9\indentation}suffix = pinf$\rightarrow$p\_to;\mbox{}\\
\hspace*{9\indentation}{\bf if} (!cont $\mid\mid$ !name) {\bf break};\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{6\indentation}pass++;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (!noremove \&\& name)\mbox{}\\
\hspace*{6\indentation}append(\&GEN\_LDFILES, name);\mbox{}\\
\hspace*{3\indentation}{\bf return} name;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
mkvec(call, in, out, pass, pinf)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$call;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$in, $\ast$out;\mbox{}\\
\hspace*{3\indentation}{\bf struct} pass $\ast$pass;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} passinfo $\ast$pinf;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} i;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}init(call);\mbox{}\\
\hspace*{3\indentation}append(call, pinf$\rightarrow$p\_path);\mbox{}\\
\hspace*{3\indentation}scanflags(call, pinf);\mbox{}\\
\hspace*{3\indentation}{\bf if} (pass) {\bf for} (i = 0; i $<$ MAXHEAD; i++)\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$pp\_head[i])\mbox{}\\
\hspace*{9\indentation}append(call, pass$\rightarrow$pp\_head[i]);\mbox{}\\
\hspace*{6\indentation}{\bf else}  {\bf break};\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& INPUT)\mbox{}\\
\hspace*{6\indentation}append(call, in);\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& OUTPUT)\mbox{}\\
\hspace*{6\indentation}append(call, out);\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& O\_OUTPUT) \{\mbox{}\\
\hspace*{6\indentation}append(call, {\tt"-o"});\mbox{}\\
\hspace*{6\indentation}append(call, out);\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}{\bf if} (pass) {\bf for} (i = 0; i $<$ MAXTAIL; i++)\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$pp\_tail[i])\mbox{}\\
\hspace*{9\indentation}append(call, pass$\rightarrow$pp\_tail[i]);\mbox{}\\
\hspace*{6\indentation}{\bf else}  {\bf break};\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& SOURCE)\mbox{}\\
\hspace*{6\indentation}append(call, source);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
callld(in, out, pass, pinf)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$in;\mbox{}\\
\hspace*{3\indentation}{\bf char} $\ast$out;\mbox{}\\
\hspace*{3\indentation}{\bf struct} pass $\ast$pass;\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} passinfo $\ast$pinf;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$call = \&CALLVEC[0];\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} i;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}init(call);\mbox{}\\
\hspace*{3\indentation}append(call, pinf$\rightarrow$p\_path);\mbox{}\\
\hspace*{3\indentation}scanflags(call, pinf);\mbox{}\\
\hspace*{3\indentation}append(call, {\tt"-o"});\mbox{}\\
\hspace*{3\indentation}append(call, out);\mbox{}\\
\hspace*{3\indentation}{\bf for} (i = 0; i $<$ MAXHEAD; i++)\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$pp\_head[i])\mbox{}\\
\hspace*{9\indentation}append(call, pass$\rightarrow$pp\_head[i]);\mbox{}\\
\hspace*{6\indentation}{\bf else}  {\bf break};\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& INPUT)\mbox{}\\
\hspace*{6\indentation}concat(call, in);\mbox{}\\
\hspace*{3\indentation}{\bf if} (pinf$\rightarrow$p\_flags \& OUTPUT)\mbox{}\\
\hspace*{6\indentation}append(call, out);\mbox{}\\
\hspace*{3\indentation}{\bf for} (i = 0; i $<$ MAXTAIL; i++)\mbox{}\\
\hspace*{6\indentation}{\bf if} (pass$\rightarrow$pp\_tail[i])\mbox{}\\
\hspace*{9\indentation}append(call, pass$\rightarrow$pp\_tail[i]);\mbox{}\\
\hspace*{6\indentation}{\bf else}  {\bf break};\mbox{}\\
\hspace*{3\indentation}{\bf if} (! runvec(call, pinf, ({\bf char} $\ast$) 0, out)) \{\mbox{}\\
\hspace*{6\indentation}cleanup(out);\mbox{}\\
\hspace*{6\indentation}RET\_CODE = 1;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}clean(call);\mbox{}\\
\}\mbox{}\\
\mbox{}\\
clean(c)\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf struct} arglist $\ast$c;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} i;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf for} (i = 1; i $<$ c$\rightarrow$al\_argc; i++) \{\mbox{}\\
\hspace*{6\indentation}free(c$\rightarrow$al\_argv[i]);\mbox{}\\
\hspace*{6\indentation}c$\rightarrow$al\_argv[i] = 0;\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\hspace*{3\indentation}c$\rightarrow$al\_argc = 0;\mbox{}\\
\}\mbox{}\\
\mbox{}\\
scanflags(call, pinf)\mbox{}\\
\hspace*{3\indentation}{\bf struct} arglist $\ast$call;\mbox{}\\
\hspace*{3\indentation}{\bf struct} passinfo $\ast$pinf;\mbox{}\\
\{\mbox{}\\
\hspace*{3\indentation}{$/\ast$\it{} Find out which flags from FLAGS must be passed to pass "pinf",\mbox{}\\
\hspace*{6\indentation}and how. \mbox{}\\
\hspace*{6\indentation}Append them to "call"\mbox{}\\
\hspace*{3\indentation}$\ast/$}\mbox{}\\
\hspace*{3\indentation}{\bf register} {\bf int} i;\mbox{}\\
\hspace*{3\indentation}USTRING flg;\mbox{}\\
\mbox{}\\
\hspace*{3\indentation}{\bf for} (i = 0; i $<$ FLAGS.al\_argc; i++) \{\mbox{}\\
\hspace*{6\indentation}{\bf register} {\bf char} $\ast$q = pinf$\rightarrow$p\_acceptflags;\mbox{}\\
\mbox{}\\
\hspace*{6\indentation}{\bf while} ($\ast$q)  \{\mbox{}\\
\hspace*{9\indentation}{\bf register} {\bf char} $\ast$p = FLAGS.al\_argv[i] + 1;\mbox{}\\
\mbox{}\\
\hspace*{9\indentation}{\bf while} (($\ast$q == $\ast$p) \&\& $\ast$q) \{\mbox{}\\
\hspace*{12\indentation}q++; p++;\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf if} ($\ast$q == ',' $\mid\mid$ !$\ast$q) \{\mbox{}\\
\hspace*{12\indentation}{\bf if} (! $\ast$p) \{\mbox{}\\
\hspace*{15\indentation}{$/\ast$\it{} append literally $\ast/$}\mbox{}\\
\hspace*{15\indentation}append(call, FLAGS.al\_argv[i]);\mbox{}\\
\hspace*{12\indentation}\}\mbox{}\\
\hspace*{12\indentation}{\bf break};\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf if} ($\ast$q == '$\ast$') \{\mbox{}\\
\hspace*{12\indentation}{\bf register} {\bf char} $\ast$s = flg;\mbox{}\\
\mbox{}\\
\hspace*{12\indentation}{\bf if} ($\ast$++q $\neq$ '$=$') \{\mbox{}\\
\hspace*{15\indentation}{$/\ast$\it{} append literally $\ast/$}\mbox{}\\
\hspace*{15\indentation}append(call, FLAGS.al\_argv[i]);\mbox{}\\
\hspace*{15\indentation}{\bf break};\mbox{}\\
\hspace*{12\indentation}\}\mbox{}\\
\hspace*{12\indentation}$\ast$s++ = '-';\mbox{}\\
\hspace*{12\indentation}{\bf if} ($\ast$q) q++;   {$/\ast$\it{} skip ',' $\ast/$}\mbox{}\\
\hspace*{12\indentation}{\bf while} ($\ast$q \&\& $\ast$q $\neq$ ',' \&\& $\ast$q $\neq$ '$\ast$') \{\mbox{}\\
\hspace*{15\indentation}{$/\ast$\it{} copy replacement flag $\ast/$}\mbox{}\\
\hspace*{15\indentation}$\ast$s++ = $\ast$q++;\mbox{}\\
\hspace*{12\indentation}\}\mbox{}\\
\hspace*{12\indentation}{\bf if} ($\ast$q == '$\ast$') \{\mbox{}\\
\hspace*{15\indentation}{$/\ast$\it{} copy rest $\ast/$}\mbox{}\\
\hspace*{15\indentation}{\bf while} ($\ast$p) $\ast$s++ = $\ast$p++;\mbox{}\\
\hspace*{12\indentation}\}\mbox{}\\
\hspace*{12\indentation}$\ast$s = 0;\mbox{}\\
\hspace*{12\indentation}append(call, flg);\mbox{}\\
\hspace*{12\indentation}{\bf break};\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf if} ($\ast$q == '$=$') \{\mbox{}\\
\hspace*{12\indentation}{$/\ast$\it{} copy replacement $\ast/$}\mbox{}\\
\hspace*{12\indentation}{\bf register} {\bf char} $\ast$s = flg;\mbox{}\\
\mbox{}\\
\hspace*{12\indentation}$\ast$s++ = '-';\mbox{}\\
\hspace*{12\indentation}q++;\mbox{}\\
\hspace*{12\indentation}{\bf while} ($\ast$q \&\& $\ast$q $\neq$ ',') $\ast$s++ = $\ast$q++;\mbox{}\\
\hspace*{12\indentation}$\ast$s = 0;\mbox{}\\
\hspace*{12\indentation}append(call, flg);\mbox{}\\
\hspace*{12\indentation}{\bf break};\mbox{}\\
\hspace*{9\indentation}\}\mbox{}\\
\hspace*{9\indentation}{\bf while} ($\ast$q \&\& $\ast$q++ $\neq$ ',')\mbox{}\\
\hspace*{12\indentation};\mbox{}\\
\hspace*{6\indentation}\}\mbox{}\\
\hspace*{3\indentation}\}\mbox{}\\
\}\mbox{}\\
\end{flushleft}
