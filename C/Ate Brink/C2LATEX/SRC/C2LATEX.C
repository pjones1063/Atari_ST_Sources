/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $Header: /usr/fsys/odin/a/vern/flex/RCS/flex.skel,v 2.10 90/03/27 12:03:55 vern Exp $
 */

#define FLEX_SCANNER

#include <stdio.h>


#ifdef __cplusplus
#include <stdlib.h>
#include <osfcn.h>

#define index strchr

/* use prototypes in function declarations */
#define YY_USE_PROTOS

/* the "const" storage-class-modifier is valid */
#define YY_USE_CONST

#endif

#ifdef __STDC__
#define YY_USE_PROTOS
#define YY_USE_CONST
#endif

#ifdef __TURBOC__
#define YY_USE_CONST
#endif


#ifndef YY_USE_CONST
#define const
#endif

#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
/*
char *malloc( unsigned size );
int free( char * );
*/
#else
#define YY_PROTO(proto) ()
/* there's no standard place to get these definitions */
char *malloc();
int free();
int read();
#endif

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#define YY_INPUT(buf,result,max_size) \
        if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
            YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0

/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate() return ( YY_NULL )

/* report a fatal error */
#define YY_FATAL_ERROR(msg) \
        { \
        (void) fputs( msg, stderr ); \
        (void) putc( '\n', stderr ); \
        exit( 1 ); \
        }

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define YY_NEW_FILE { \
        yy_init_buffer( yy_current_buffer, yyin ); \
        yy_load_buffer_state(); \
        }

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex YY_PROTO(( void )) 

/* code executed at the end of each rule */
#define YY_BREAK break;

#define YY_END_OF_BUFFER_CHAR 0

#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;

#define YY_CHAR char
#define INITIAL 0
#define STRING 1
#define BCOMMENT 2
#define INCLUDE 3
#define CPLUSPLUS 4
#define KEY     printf ("{\\%s %s}", keyword_font, yytext)
#define CPP     printf ("{\\%s \\%s}", cpp_font, yytext)
#define SYM(x)  printf ("$\\%s$", x)
#define OUT(x)  printf ("%s", x)
#define SUB(x)  substitute(x)
#define IND     indent(yytext)

#include <stdio.h>

int cplusplus_mode = 0;

int complete_file = 0;
int header = 0;
int tabtotab = 8;
int piped = 0;
char * font_size = "11";
char * indentation = "0.5em";
char * comment_font = "it";
char * keyword_font = "bf";
char * header_font = "sl";
char * cpp_font = "tt";
char * string_font = "tt";
void substitute(const char *);
void indent(const char *); 
void newpage(int);
void usage(const char *);

/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
        yytext = yy_bp; \
        yyleng = yy_cp - yy_bp; \
        yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
        { \
        /* undo effects of setting up yytext */ \
        *yy_cp = yy_hold_char; \
        yy_c_buf_p = yy_cp = yy_bp + n; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        }

#define unput(c) yyunput( c, yytext )


struct yy_buffer_state
    {
    FILE *yy_input_file;

    YY_CHAR *yy_ch_buf;         /* input buffer */
    YY_CHAR *yy_buf_pos;        /* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters*/
    int yy_buf_size;    

    /* number of characters read into yy_ch_buf, not including EOB characters */
    int yy_n_chars;

    int yy_eof_status;          /* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /* "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

static YY_BUFFER_STATE yy_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed */
static YY_CHAR yy_hold_char;

static int yy_n_chars;          /* number of characters read into yy_ch_buf */



#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

extern YY_CHAR *yytext;
extern int yyleng;
extern FILE *yyin, *yyout;

YY_CHAR *yytext;
int yyleng;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

#define YY_END_OF_BUFFER 139
typedef int yy_state_type;
static const short int yy_accept[535] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
      139,  138,  135,  137,  136,   95,  115,  138,   86,   85,
      138,  103,  104,   73,   97,   92,   96,   93,   77,  126,
      126,   90,   94,   78,   91,   79,   89,  109,  109,  105,
      138,  106,   74,  109,  109,  109,  109,  109,  109,  109,
      109,  109,  109,  109,  109,  109,  109,  109,   83,   75,
       84,   72,  134,  121,  119,  118,  121,  120,  114,  112,
      114,  113,   14,   12,   13,   14,   14,  108,   96,   93,
       90,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,

      108,  135,  136,   64,    0,    0,    0,    0,    0,   81,
       80,   82,    0,    0,   67,  100,  101,   87,  102,   59,
        0,  122,  110,   98,  123,  126,  126,    0,  126,    0,
       60,   62,   99,   63,   61,  109,  115,    0,  133,   70,
      109,  109,  109,  109,  109,  109,   43,  109,  109,  109,
      109,  109,  109,   44,  109,  109,  109,  109,  109,  109,
      109,  109,  109,  109,  109,   71,   65,  134,  117,  116,
      120,  111,  113,   12,    0,   11,    0,   10,  108,   59,
       88,  107,  108,  108,  108,  108,  108,  108,  108,  108,
       43,  108,  108,  108,  108,  108,  108,  108,   44,  108,

      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,    0,    0,    0,
        4,    0,    0,  127,    0,  127,    0,    0,   66,    0,
      122,  122,    0,  123,  126,    0,  124,  132,   68,   69,
      109,  109,  109,  109,  109,  109,  109,  109,  109,  109,
      109,   36,  109,   17,  109,  109,  109,  109,  109,  109,
      109,  109,  109,  109,  109,  109,  109,  109,  109,   76,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,  108,  108,   36,  108,  108,  108,   17,  108,   47,
      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,

      108,  108,  108,  108,  108,  108,  108,  108,  108,  108,
      108,    0,    0,    0,    0,    0,    0,    0,    0,  128,
      129,    0,    0,    0,  124,  122,    0,  125,  132,   15,
      109,   23,   27,  109,  109,  109,  109,   20,   24,  109,
      109,   40,   21,  109,  109,  109,  109,  109,  109,  109,
      109,  109,  109,  109,   38,  109,  109,   15,  108,   23,
       27,  108,  108,  108,  108,  108,  108,   20,   24,  108,
      108,  108,   40,  108,   21,  108,  108,  108,  108,  108,
      108,  108,  108,  108,  108,  108,  108,  108,   49,  108,
      108,  108,  108,   38,  108,  108,    0,    7,    8,    0,

        0,    0,    0,    0,    0,  130,    0,   19,   31,  109,
      109,  109,  109,   32,  109,  109,   33,  109,  109,  109,
      109,  109,  109,   30,  109,  109,   46,   19,   51,   31,
      108,  108,  108,  108,  108,   32,  108,  108,  108,  108,
      108,  108,  108,  108,  108,   33,  108,  108,  108,  108,
      108,  108,   30,  108,  108,  108,   46,    0,    9,    5,
        0,    0,    3,  109,  109,   16,   28,  109,   29,   37,
       41,   45,   18,   22,  109,  109,  109,  108,  108,   48,
       16,   28,   56,   57,  108,  108,  108,  108,   52,  108,
       29,   37,   41,   45,   18,   22,  108,  108,  108,  108,

        2,    6,    0,  109,   39,  109,   26,  109,  109,  108,
       39,  108,  108,   54,  108,  108,   26,  108,   55,  108,
        1,   35,   25,   34,   42,   35,   50,   58,  108,   25,
       34,   42,   53,    0
    } ;

static const YY_CHAR yy_ec[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    6,    7,    8,    9,   10,   11,   12,   13,
       14,   15,   16,   17,   18,   19,   20,   21,   22,   22,
       22,   22,   22,   22,   22,   23,   23,   24,   25,   26,
       27,   28,   29,   30,   31,   31,   31,   31,   32,   33,
       34,   34,   34,   34,   34,   35,   34,   34,   34,   34,
       34,   34,   34,   34,   36,   34,   34,   34,   34,   34,
       37,   38,   39,   40,   34,   30,   41,   42,   43,   44,

       45,   46,   47,   48,   49,   34,   50,   51,   52,   53,
       54,   55,   34,   56,   57,   58,   59,   60,   61,   62,
       63,   64,   65,   66,   67,   68,    1
    } ;

static const YY_CHAR yy_meta[69] =
    {   0,
        1,    1,    1,    1,    2,    2,    3,    2,    4,    2,
        2,    5,    2,    2,    2,    2,    2,    2,    2,    2,
        6,    6,    7,    2,    2,    2,    2,    2,    3,    2,
        7,    7,    7,    8,    8,    8,    2,    3,    2,    2,
        6,    6,    7,    7,    7,    6,    8,    8,    8,    8,
        8,    8,    9,    8,    8,    9,    8,    9,    8,    9,
        8,    9,    8,    8,    2,    2,    2,    2
    } ;

static const short int yy_base[548] =
    {   0,
        0,   67,   67,   73,   68,   79,   83,   90,  108,   94,
      972,  973,   96,  973,  968,  943,  973,  129,  942,   62,
      930,  973,  973,  940,   75,  973,   85,   85,   95,  170,
      163,  973,  973,   88,  939,   91,  973,    0,  113,  973,
      962,  973,  937,  904,  906,   82,   79,   84,   94,  907,
       75,  906,  914,  152,  895,  904,  902,  907,  973,  111,
      973,  973,  174,  973,  973,  973,  197,  178,  973,  973,
      934,  185,  973,  192,  973,  946,  924,    0,  189,  204,
      927,  941,  221,   70,   91,  211,  202,  187,  215,  194,
      222,  209,  225,  227,  232,  228,  235,  237,  233,  245,

      203,  256,  973,  973,  262,  904,  221,  244,  895,  973,
      973,  973,  935,  280,  973,  973,  973,  973,  973,  973,
      927,  282,  973,  973,  302,  322,  340,  348,  973,    0,
      918,  973,  973,  973,  917,    0,  973,  905,  973,  973,
      884,  896,  883,  898,  885,  891,  877,  878,  875,  875,
      878,  875,  872,    0,  871,  875,  231,  873,  213,  239,
      877,  870,  259,  230,  875,  973,  973,  307,  973,  973,
      308,  973,  317,  324,  916,  973,  894,  973,    0,  906,
      973,  973,  911,  321,  311,  289,  309,  327,  329,  342,
      330,  323,  331,  340,  343,  322,  346,  351,  910,  356,

      365,  368,  374,  375,  377,  383,  385,  387,  391,  392,
      378,  393,  394,  395,  397,  396,  401,  872,  359,  873,
      368,  873,  871,  973,  902,  901,  401,    0,  973,  438,
      973,  441,  449,  973,  973,  413,  456,  445,  973,  973,
      858,  870,  865,  853,  382,  867,  865,  861,  853,  859,
      862,    0,  848,    0,  854,  851,  840,  842,  844,  851,
      837,  835,  835,  847,  837,  841,  845,  847,  836,  973,
      415,  442,  421,  402,  428,  437,  448,  466,  459,  473,
      475,  479,  481,  877,  484,  482,  488,  876,  491,  875,
      489,  490,  493,  494,  496,  499,  497,  498,  504,  505,

      500,  501,  503,  506,  510,  508,  516,  511,  507,  523,
      517,  834,  836,  836,  831,  834,  834,  826,  831,  973,
      973,  509,  863,  512,  518,  973,  521,  549,  973,    0,
      824,    0,    0,  815,  823,  812,  819,    0,    0,  813,
      810,    0,    0,  810,  810,  807,  819,  809,  813,  818,
      817,  815,  805,  810,    0,  798,  810,  845,  540,  844,
      843,  519,  550,  557,  514,  558,  566,  842,  841,  565,
      568,  569,  840,  570,  839,  571,  573,  572,  574,  576,
      575,  577,  578,  582,  580,  579,  586,  587,  838,  591,
      584,  592,  583,  837,  585,  593,  792,  973,  973,  798,

      797,  797,  782,  794,  827,  973,  826,    0,    0,  784,
      785,  790,  781,    0,  775,  779,    0,  787,  784,  786,
      770,  779,  781,    0,  772,  775,    0,  814,  813,  812,
      588,  589,  600,  601,  594,  811,  605,  606,  590,  596,
      595,  609,  611,  598,  602,  810,  622,  635,  648,  649,
      650,  651,  809,  652,  653,  654,  808,  771,  973,  973,
      769,  770,  973,  754,  754,    0,    0,  766,    0,    0,
        0,    0,    0,    0,  764,  764,  749,  655,  658,  790,
      787,  781,  775,  712,  656,  659,  661,  660,  695,  663,
      693,  692,  690,  688,  686,  684,  665,  664,  662,  666,

      973,  973,  647,  645,    0,  633,    0,  643,  639,  667,
      673,  668,  671,  670,  674,  669,  419,  676,  408,  677,
      973,    0,    0,    0,    0,  406,  267,  236,  679,  172,
      166,   78,   68,  973,  725,  734,  743,  751,  755,  764,
      773,  779,  785,  792,  796,  798,  801
    } ;

static const short int yy_def[548] =
    {   0,
      534,    1,  535,  535,  536,  536,  537,  537,    1,    9,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      538,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  539,  539,  534,
      534,  534,  534,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  540,  541,  542,  534,  534,
      534,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,

      543,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  544,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  545,
      534,  534,  534,  534,  534,  539,  534,  538,  534,  534,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  540,  534,  541,  534,  542,  534,
      534,  534,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,

      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  546,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  545,  534,  534,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  534,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,

      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  547,  534,  534,  534,  534,  534,  534,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  534,  534,  534,  534,

      534,  534,  534,  534,  534,  534,  534,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  534,  534,  534,
      534,  534,  534,  539,  539,  539,  539,  539,  539,  539,
      539,  539,  539,  539,  539,  539,  539,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,

      534,  534,  534,  539,  539,  539,  539,  539,  539,  543,
      543,  543,  543,  543,  543,  543,  543,  543,  543,  543,
      534,  539,  539,  539,  539,  543,  543,  543,  543,  543,
      543,  543,  543,    0,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534
    } ;

static const short int yy_nxt[1042] =
    {   0,
       12,   13,   14,   15,   13,   16,   17,   18,   12,   19,
       20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
       30,   31,   31,   32,   33,   34,   35,   36,   37,   12,
       38,   38,   38,   38,   39,   38,   40,   41,   42,   43,
       44,   45,   46,   47,   48,   49,   50,   38,   51,   38,
       52,   38,   38,   38,   38,   53,   54,   55,   56,   57,
       58,   38,   38,   38,   59,   60,   61,   62,   63,   65,
       70,   63,  111,   66,   68,   65,  179,   68,  179,   66,
       72,   70,   71,   72,   74,   75,  179,   74,  112,   76,
      116,   74,   75,   71,   74,   63,   76,  102,   63,  179,

      102,  117,  118,  121,   67,  122,  122,  122,   77,  123,
       67,  119,  120,  131,  132,   77,   78,  134,  135,  137,
      154,  124,  143,  146,  138,   79,   80,  155,  184,  144,
      105,   81,  147,  105,  148,  145,  149,  166,   82,   82,
       82,   82,   83,   82,  151,  150,  185,  152,   84,   85,
       86,   87,   88,   89,   90,   82,   91,   82,   92,   82,
       93,   94,   95,   96,   97,   98,   99,  100,  101,   82,
       82,   82,  106,  107,  179,  168,  167,  108,  168,  171,
      179,  125,  171,  127,  127,  127,  173,  109,  125,  173,
      126,  126,  127,  174,  128,  179,  174,  129,  129,  158,

      159,  128,  179,  169,  129,  129,  118,  128,  169,  160,
      179,  179,  161,  129,  128,  119,  180,  179,  181,  179,
      129,  129,  121,  179,  122,  122,  122,  137,  129,  179,
      179,  130,  138,  179,  170,  179,  179,  192,  169,  193,
      179,  179,  169,  179,  179,  179,  190,  198,  194,  169,
      217,  186,  169,  179,  169,  191,  169,  102,  187,  259,
      102,  188,  201,  105,  189,  195,  105,  199,  196,  202,
      197,  219,  207,  220,  200,  179,  260,  256,  267,  261,
      268,  203,  208,  209,  212,  214,  204,  205,  257,  221,
      206,  226,  210,  215,  262,  211,  222,  179,  216,  213,

      227,  227,  122,  122,  122,  106,  107,  265,  168,  171,
      108,  168,  171,  230,  231,  266,  231,  179,  173,  179,
      109,  173,  232,  232,  232,  174,  230,  231,  174,  179,
      179,  179,  231,  233,  234,  179,  234,  179,  179,  179,
      125,  228,  126,  126,  127,  273,  233,  234,  179,  274,
      179,  179,  234,  128,  179,  272,  235,  235,  125,  179,
      127,  127,  127,  236,  179,  236,  128,  275,  237,  237,
      237,  128,  235,  179,  129,  129,  179,  284,  271,  280,
      235,  276,  179,  179,  128,  179,  179,  277,  279,  281,
      129,  179,  278,  179,  285,  179,  283,  282,  129,  179,

      179,  179,  179,  179,  179,  179,  287,  313,  286,  179,
      179,  316,  321,  288,  179,  314,  179,  289,  291,  292,
      317,  322,  322,  179,  295,  293,  303,  179,  290,  179,
      294,  296,  301,  237,  237,  237,  179,  299,  334,  335,
      298,  304,  297,  306,  309,  179,  310,  302,  305,  311,
      179,  307,  308,  324,  300,  324,  179,  361,  325,  325,
      325,  232,  232,  232,  327,  360,  327,  179,  358,  328,
      328,  328,  128,  326,  179,  326,  237,  237,  237,  329,
      329,  179,  359,  179,  362,  128,  326,  179,  365,  179,
      179,  326,  179,  363,  364,  329,  179,  179,  179,  179,

      367,  179,  179,  329,  179,  179,  179,  179,  179,  179,
      366,  179,  179,  179,  179,  179,  179,  368,  179,  179,
      321,  371,  179,  370,  179,  179,  369,  179,  372,  405,
      405,  179,  325,  325,  325,  373,  374,  375,  325,  325,
      325,  328,  328,  328,  376,  377,  380,  381,  179,  385,
      394,  379,  378,  383,  390,  382,  384,  386,  179,  387,
      388,  391,  389,  395,  392,  179,  179,  396,  393,  328,
      328,  328,  432,  179,  179,  429,  179,  179,  179,  179,
      179,  179,  179,  179,  179,  179,  179,  179,  179,  428,
      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,

      179,  179,  179,  179,  179,  431,  179,  430,  179,  179,
      179,  439,  441,  179,  179,  433,  434,  179,  442,  179,
      435,  437,  438,  440,  443,  436,  447,  449,  450,  451,
      179,  444,  445,  448,  452,  446,  453,  457,  454,  479,
      478,  455,  456,  179,  480,  481,  482,  485,  483,  486,
      484,  488,  487,  489,  491,  490,  179,  179,  179,  179,
      179,  179,  179,  179,  179,  492,  179,  179,  179,  179,
      179,  179,  179,  179,  179,  179,  179,  179,  179,  179,
      493,  179,  179,  525,  179,  179,  524,  179,  523,  522,
      494,  521,  179,  499,  179,  497,  179,  496,  179,  513,

      179,  179,  500,  179,  498,  514,  495,  516,  518,  512,
      517,  526,  519,  510,  528,  511,  520,  515,  529,  531,
      179,  532,  533,  527,  530,   64,   64,   64,   64,   64,
       64,   64,   64,   64,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   73,   73,   73,   73,   73,   73,   73,
       73,   73,  113,  113,  113,  113,  113,  113,  113,  113,
      136,  136,  136,  136,  175,  175,  175,  175,  175,  175,
      175,  175,  175,  177,  177,  177,  177,  177,  177,  177,
      177,  177,  179,  179,  179,  179,  179,  179,  183,  179,
      183,  183,  183,  183,  225,  179,  225,  225,  179,  509,

      225,  238,  238,  323,  323,  407,  407,  407,  508,  507,
      506,  505,  504,  503,  502,  501,  179,  179,  179,  179,
      179,  179,  179,  477,  476,  475,  474,  473,  472,  471,
      470,  469,  468,  467,  466,  465,  464,  406,  321,  463,
      462,  461,  460,  459,  458,  179,  179,  179,  179,  179,
      179,  179,  179,  179,  427,  426,  425,  424,  423,  422,
      421,  420,  419,  418,  417,  416,  415,  414,  413,  412,
      411,  410,  409,  408,  406,  404,  403,  402,  401,  400,
      399,  398,  397,  179,  179,  179,  357,  356,  355,  354,
      353,  352,  351,  350,  349,  348,  347,  346,  345,  344,

      343,  342,  341,  340,  339,  338,  337,  336,  333,  332,
      331,  330,  320,  320,  319,  318,  315,  312,  179,  179,
      270,  178,  176,  269,  264,  263,  258,  255,  254,  253,
      252,  251,  250,  249,  248,  247,  246,  245,  244,  243,
      242,  241,  114,  240,  239,  229,  224,  223,  218,  179,
      182,  178,  176,  172,  165,  164,  163,  162,  157,  156,
      153,  142,  141,  140,  139,  133,  115,  114,  110,  104,
      103,  534,   11,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,

      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534
    } ;

static const short int yy_chk[1042] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        5,    2,   20,    3,    4,    4,  533,    4,   84,    4,
        6,    6,    5,    6,    7,    7,  532,    7,   20,    7,
       25,    8,    8,    6,    8,   10,    8,   13,   10,   85,

       13,   25,   27,   28,    3,   28,   28,   28,    7,   29,
        4,   27,   27,   34,   34,    8,    9,   36,   36,   39,
       51,   29,   46,   47,   39,    9,    9,   51,   84,   46,
       18,    9,   47,   18,   48,   46,   48,   60,    9,    9,
        9,    9,    9,    9,   49,   48,   85,   49,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,   18,   18,  531,   63,   60,   18,   63,   68,
      530,   31,   68,   31,   31,   31,   72,   18,   30,   72,
       30,   30,   30,   74,   31,   88,   74,   31,   31,   54,

       54,   30,   90,   67,   30,   30,   79,   31,   67,   54,
       87,  101,   54,   31,   30,   79,   79,   92,   80,   86,
       30,   31,   80,   89,   80,   80,   80,   83,   30,   83,
       91,   30,   83,   93,   67,   94,   96,   88,   67,   88,
       95,   99,   67,   97,  528,   98,   87,   90,   88,   67,
      101,   86,   67,  100,   67,   87,   67,  102,   86,  159,
      102,   86,   92,  105,   86,   89,  105,   91,   89,   93,
       89,  107,   96,  107,   91,  527,  159,  157,  164,  160,
      164,   94,   97,   97,   98,   99,   94,   95,  157,  108,
       95,  114,   97,  100,  160,   97,  108,  186,  100,   98,

      114,  114,  122,  122,  122,  105,  105,  163,  168,  171,
      105,  168,  171,  122,  122,  163,  122,  187,  173,  185,
      105,  173,  125,  125,  125,  174,  122,  122,  174,  184,
      196,  192,  122,  125,  125,  188,  125,  189,  191,  193,
      126,  114,  126,  126,  126,  186,  125,  125,  194,  187,
      190,  195,  125,  126,  197,  185,  126,  126,  127,  198,
      127,  127,  127,  128,  200,  128,  126,  188,  128,  128,
      128,  127,  126,  201,  127,  127,  202,  196,  184,  192,
      126,  189,  203,  204,  127,  205,  211,  190,  191,  193,
      127,  206,  190,  207,  197,  208,  195,  194,  127,  209,

      210,  212,  213,  214,  216,  215,  200,  219,  198,  217,
      274,  221,  227,  200,  526,  219,  519,  201,  203,  204,
      221,  227,  227,  271,  206,  205,  211,  517,  202,  273,
      205,  207,  210,  236,  236,  236,  275,  209,  245,  245,
      208,  212,  207,  214,  216,  276,  216,  210,  213,  217,
      272,  214,  215,  230,  209,  230,  277,  274,  230,  230,
      230,  232,  232,  232,  233,  273,  233,  279,  271,  233,
      233,  233,  232,  232,  278,  232,  237,  237,  237,  238,
      238,  280,  272,  281,  275,  232,  232,  282,  277,  283,
      286,  232,  285,  276,  276,  238,  287,  291,  292,  289,

      279,  293,  294,  238,  295,  297,  298,  296,  301,  302,
      278,  303,  299,  300,  304,  309,  306,  280,  305,  308,
      322,  283,  365,  282,  307,  311,  281,  362,  285,  322,
      322,  310,  324,  324,  324,  286,  287,  289,  325,  325,
      325,  327,  327,  327,  291,  292,  295,  296,  359,  300,
      309,  294,  293,  298,  305,  297,  299,  301,  363,  302,
      303,  306,  304,  310,  307,  364,  366,  311,  308,  328,
      328,  328,  365,  370,  367,  362,  371,  372,  374,  376,
      378,  377,  379,  381,  380,  382,  383,  386,  385,  359,
      384,  393,  391,  395,  387,  388,  431,  432,  439,  390,

      392,  396,  435,  441,  440,  364,  444,  363,  433,  434,
      445,  376,  378,  437,  438,  366,  367,  442,  379,  443,
      370,  372,  374,  377,  380,  371,  384,  386,  387,  388,
      447,  381,  382,  385,  390,  383,  391,  396,  392,  432,
      431,  393,  395,  448,  433,  434,  435,  439,  437,  440,
      438,  442,  441,  443,  445,  444,  449,  450,  451,  452,
      454,  455,  456,  478,  485,  447,  479,  486,  488,  487,
      499,  490,  498,  497,  500,  510,  512,  516,  514,  513,
      448,  511,  515,  509,  518,  520,  508,  529,  506,  504,
      449,  503,  496,  455,  495,  452,  494,  451,  493,  486,

      492,  491,  456,  489,  454,  487,  450,  490,  498,  485,
      497,  510,  499,  478,  513,  479,  500,  488,  515,  518,
      484,  520,  529,  512,  516,  535,  535,  535,  535,  535,
      535,  535,  535,  535,  536,  536,  536,  536,  536,  536,
      536,  536,  536,  537,  537,  537,  537,  537,  537,  537,
      537,  537,  538,  538,  538,  538,  538,  538,  538,  538,
      539,  539,  539,  539,  540,  540,  540,  540,  540,  540,
      540,  540,  540,  541,  541,  541,  541,  541,  541,  541,
      541,  541,  542,  483,  542,  542,  542,  542,  543,  482,
      543,  543,  543,  543,  544,  481,  544,  544,  480,  477,

      544,  545,  545,  546,  546,  547,  547,  547,  476,  475,
      468,  465,  464,  462,  461,  458,  457,  453,  446,  436,
      430,  429,  428,  426,  425,  423,  422,  421,  420,  419,
      418,  416,  415,  413,  412,  411,  410,  407,  405,  404,
      403,  402,  401,  400,  397,  394,  389,  375,  373,  369,
      368,  361,  360,  358,  357,  356,  354,  353,  352,  351,
      350,  349,  348,  347,  346,  345,  344,  341,  340,  337,
      336,  335,  334,  331,  323,  319,  318,  317,  316,  315,
      314,  313,  312,  290,  288,  284,  269,  268,  267,  266,
      265,  264,  263,  262,  261,  260,  259,  258,  257,  256,

      255,  253,  251,  250,  249,  248,  247,  246,  244,  243,
      242,  241,  226,  225,  223,  222,  220,  218,  199,  183,
      180,  177,  175,  165,  162,  161,  158,  156,  155,  153,
      152,  151,  150,  149,  148,  147,  146,  145,  144,  143,
      142,  141,  138,  135,  131,  121,  113,  109,  106,   82,
       81,   77,   76,   71,   58,   57,   56,   55,   53,   52,
       50,   45,   44,   43,   41,   35,   24,   21,   19,   16,
       15,   11,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,

      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534,  534,  534,  534,  534,  534,  534,  534,  534,  534,
      534
    } ;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
static int yy_init = 1;         /* whether we need to initialize */
static int yy_start = 0;        /* start state number */

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yyunput YY_PROTO(( YY_CHAR c, YY_CHAR *buf_ptr ));
void yyrestart YY_PROTO(( FILE *input_file ));
void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));

#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif

YY_DECL
    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp, *yy_bp;
    register int yy_act;



        if (cplusplus_mode)
          BEGIN (CPLUSPLUS);



    if ( yy_init )
        {
        if ( ! yy_start )
            yy_start = 1;       /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( yy_current_buffer )
            yy_init_buffer( yy_current_buffer, yyin );
        else
            yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

        yy_load_buffer_state();

        yy_init = 0;
        }

    while ( 1 )         /* loops until end-of-file is reached */
        {
        yy_cp = yy_c_buf_p;

        /* support of yytext */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of the
         * current run.
         */
        yy_bp = yy_cp;

        yy_current_state = yy_start;
        if ( yy_bp[-1] == '\n' )
            ++yy_current_state;
yy_match:
        do
            {
            register YY_CHAR yy_c = yy_ec[*yy_cp];
            if ( yy_accept[yy_current_state] )
                {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos = yy_cp;
                }
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = yy_def[yy_current_state];
                if ( yy_current_state >= 535 )
                    yy_c = yy_meta[yy_c];
                }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
            ++yy_cp;
            }
        while ( yy_current_state != 534 );
        yy_cp = yy_last_accepting_cpos;
        yy_current_state = yy_last_accepting_state;

yy_find_action:
        yy_act = yy_accept[yy_current_state];

        YY_DO_BEFORE_ACTION;
        YY_USER_ACTION;

do_action:      /* this label is used only to access EOF actions */


        switch ( yy_act )
            {
            case 0: /* must backtrack */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

case 1:
{ CPP; BEGIN (INCLUDE); }
        YY_BREAK
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
CPP;
        YY_BREAK
case 10:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
{ OUT ("$<${\\"); OUT (string_font);
                          OUT ("{}"); SUB (yytext+1); OUT ("}$>$");
                          input(); BEGIN (INITIAL); }
        YY_BREAK
case 11:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
{ OUT ("\"{\\"); OUT (string_font);
                          OUT ("{}"); SUB (yytext+1); OUT ("}\"");
                          input(); BEGIN (INITIAL); }
        YY_BREAK
case 12:
ECHO;
        YY_BREAK
case 13:
OUT ("\\mbox{}\\\\\n");
        YY_BREAK
case 14:
{ yyless (0); BEGIN (INITIAL); }
        YY_BREAK
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
case 25:
case 26:
case 27:
case 28:
case 29:
case 30:
case 31:
case 32:
case 33:
case 34:
case 35:
case 36:
case 37:
case 38:
case 39:
case 40:
case 41:
case 42:
case 43:
case 44:
case 45:
case 46:
case 47:
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
case 58:
KEY;
        YY_BREAK
case 59:
SYM ("rightarrow");
        YY_BREAK
case 60:
SYM ("ll");
        YY_BREAK
case 61:
SYM ("gg");
        YY_BREAK
case 62:
SYM ("leq");
        YY_BREAK
case 63:
SYM ("geq");
        YY_BREAK
case 64:
SYM ("neq");
        YY_BREAK
case 65:
SYM ("mid\\mid");
        YY_BREAK
case 66:
SYM ("ldots");
        YY_BREAK
case 67:
SYM ("ast=");
        YY_BREAK
case 68:
SYM ("ll=");
        YY_BREAK
case 69:
SYM ("gg=");
        YY_BREAK
case 70:
SYM ("vee=");
        YY_BREAK
case 71:
SYM ("mid=");
        YY_BREAK
case 72:
SYM ("sim");
        YY_BREAK
case 73:
SYM ("ast");
        YY_BREAK
case 74:
SYM ("wedge");
        YY_BREAK
case 75:
SYM ("mid");
        YY_BREAK
case 76:
SYM ("rightarrow\\ast");
        YY_BREAK
case 77:
OUT ("$/$");
        YY_BREAK
case 78:
OUT ("$<$");
        YY_BREAK
case 79:
OUT ("$>$");
        YY_BREAK
case 80:
OUT ("\\&\\&");
        YY_BREAK
case 81:
OUT ("\\%=");
        YY_BREAK
case 82:
OUT ("\\&=");
        YY_BREAK
case 83:
OUT ("\\{");
        YY_BREAK
case 84:
OUT ("\\}");
        YY_BREAK
case 85:
OUT ("\\&");
        YY_BREAK
case 86:
OUT ("\\%");
        YY_BREAK
case 87:
OUT ("-{}-");
        YY_BREAK
case 88:
OUT (".$\\ast$");
        YY_BREAK
case 89:
case 90:
case 91:
case 92:
case 93:
case 94:
case 95:
case 96:
case 97:
case 98:
case 99:
case 100:
case 101:
case 102:
case 103:
case 104:
case 105:
case 106:
case 107:
ECHO;
        YY_BREAK
case 108:
case 109:
SUB (yytext);
        YY_BREAK
case 110:
{ BEGIN (BCOMMENT); OUT ("{$/\\ast$\\");
                                  OUT (comment_font); OUT ("{}"); }
        YY_BREAK
case 111:
{ BEGIN (INITIAL); OUT ("$\\ast/$}"); }
        YY_BREAK
case 112:
OUT ("\\mbox{}\\\\\n");
        YY_BREAK
case 113:
IND;
        YY_BREAK
case 114:
SUB (yytext);
        YY_BREAK
case 115:
{ BEGIN (STRING); OUT ("{\\");
                                  OUT (string_font); OUT ("\""); }
        YY_BREAK
case 116:
OUT ("$\\backslash\\backslash$");
        YY_BREAK
case 117:
{ OUT ("$\\backslash$"); SUB (yytext+1); }
        YY_BREAK
case 118:
{ BEGIN (INITIAL); OUT ("\"}"); }
        YY_BREAK
case 119:
OUT ("\\mbox{}\\\\\n");
        YY_BREAK
case 120:
IND;
        YY_BREAK
case 121:
SUB (yytext);
        YY_BREAK
case 122:
case 123:
case 124:
case 125:
ECHO;
        YY_BREAK
case 126:
ECHO;
        YY_BREAK
case 127:
SUB (yytext);
        YY_BREAK
case 128:
case 129:
case 130:
ECHO;
        YY_BREAK
case 131:
ECHO;
        YY_BREAK
case 132:
ECHO;
        YY_BREAK
case 133:
OUT ("$\\backslash$\\\\\n");
        YY_BREAK
case 134:
IND;
        YY_BREAK
case 135:
ECHO;
        YY_BREAK
case 136:
OUT ("\\newpage\n");
        YY_BREAK
case 137:
OUT ("\\mbox{}\\\\\n");
        YY_BREAK
case 138:
ECHO;
        YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(STRING):
case YY_STATE_EOF(BCOMMENT):
case YY_STATE_EOF(INCLUDE):
case YY_STATE_EOF(CPLUSPLUS):
    yyterminate();

            case YY_END_OF_BUFFER:
                {
                /* amount of text matched not including the EOB char */
                int yy_amount_of_matched_text = yy_cp - yytext - 1;

                /* undo the effects of YY_DO_BEFORE_ACTION */
                *yy_cp = yy_hold_char;

                /* note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the end-
                 * of-buffer state).  Contrast this with the test in yyinput().
                 */
                if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
                    /* this was really a NUL */
                    {
                    yy_state_type yy_next_state;

                    yy_c_buf_p = yytext + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state();

                    /* okay, we're now positioned to make the
                     * NUL transition.  We couldn't have
                     * yy_get_previous_state() go ahead and do it
                     * for us because it doesn't know how to deal
                     * with the possibility of jamming (and we
                     * don't want to build jamming into it because
                     * then it will run more slowly)
                     */

                    yy_next_state = yy_try_NUL_trans( yy_current_state );

                    yy_bp = yytext + YY_MORE_ADJ;

                    if ( yy_next_state )
                        {
                        /* consume the NUL */
                        yy_cp = ++yy_c_buf_p;
                        yy_current_state = yy_next_state;
                        goto yy_match;
                        }

                    else
                        {
                            yy_cp = yy_last_accepting_cpos;
                            yy_current_state = yy_last_accepting_state;
                        goto yy_find_action;
                        }
                    }

                else switch ( yy_get_next_buffer() )
                    {
                    case EOB_ACT_END_OF_FILE:
                        {
                        if ( yywrap() )
                            {
                            /* note: because we've taken care in
                             * yy_get_next_buffer() to have set up yytext,
                             * we can now set up yy_c_buf_p so that if some
                             * total hoser (like flex itself) wants
                             * to call the scanner after we return the
                             * YY_NULL, it'll still work - another YY_NULL
                             * will get returned.
                             */
                            yy_c_buf_p = yytext + YY_MORE_ADJ;

                            yy_act = YY_STATE_EOF((yy_start - 1) / 2);
                            goto do_action;
                            }

                        else
                            YY_NEW_FILE;
                        }
                        break;

                    case EOB_ACT_CONTINUE_SCAN:
                        yy_c_buf_p = yytext + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        yy_cp = yy_c_buf_p;
                        yy_bp = yytext + YY_MORE_ADJ;
                        goto yy_match;

                    case EOB_ACT_LAST_MATCH:
                        yy_c_buf_p =
                            &yy_current_buffer->yy_ch_buf[yy_n_chars];

                        yy_current_state = yy_get_previous_state();

                        yy_cp = yy_c_buf_p;
                        yy_bp = yytext + YY_MORE_ADJ;
                        goto yy_find_action;
                    }
                break;
                }

            default:
#ifdef FLEX_DEBUG
                printf( "action # %d\n", yy_act );
#endif
                YY_FATAL_ERROR(
                        "fatal flex scanner internal error--no action found" );
            }
        }
    }


/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()

    {
    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        YY_FATAL_ERROR(
                "fatal flex scanner internal error--end of buffer missed" );

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yytext;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_n_chars = 0;

    else
        {
        int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        else if ( num_to_read <= 0 )
            YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

        /* read in more data */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
                  yy_n_chars, num_to_read );
        }

    if ( yy_n_chars == 0 )
        {
        if ( number_to_move == 1 )
            {
            ret_val = EOB_ACT_END_OF_FILE;
            yy_current_buffer->yy_eof_status = EOF_DONE;
            }

        else
            {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_eof_status = EOF_PENDING;
            }
        }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yytext begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yytext = &yy_current_buffer->yy_ch_buf[1];

    return ( ret_val );
    }


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

static yy_state_type yy_get_previous_state()

    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp;

    register YY_CHAR *yy_bp = yytext;

    yy_current_state = yy_start;
    if ( yy_bp[-1] == '\n' )
        ++yy_current_state;

    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        {
        register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
        if ( yy_accept[yy_current_state] )
            {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
            }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            {
            yy_current_state = yy_def[yy_current_state];
            if ( yy_current_state >= 535 )
                yy_c = yy_meta[yy_c];
            }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        }

    return ( yy_current_state );
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
register yy_state_type yy_current_state;
#endif

    {
    register int yy_is_jam;
    register YY_CHAR *yy_cp = yy_c_buf_p;

    register YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
        {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
        }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = yy_def[yy_current_state];
        if ( yy_current_state >= 535 )
            yy_c = yy_meta[yy_c];
        }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_current_state == 534);

    return ( yy_is_jam ? 0 : yy_current_state );
    }


#ifdef YY_USE_PROTOS
static void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
#else
static void yyunput( c, yy_bp )
YY_CHAR c;
register YY_CHAR *yy_bp;
#endif

    {
    register YY_CHAR *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        { /* need to shift things up to make room */
        register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
        register YY_CHAR *dest =
            &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
        register YY_CHAR *source =
            &yy_current_buffer->yy_ch_buf[number_to_move];

        while ( source > yy_current_buffer->yy_ch_buf )
            *--dest = *--source;

        yy_cp += dest - source;
        yy_bp += dest - source;
        yy_n_chars = yy_current_buffer->yy_buf_size;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
            YY_FATAL_ERROR( "flex scanner push-back overflow" );
        }

    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
        yy_cp[-2] = '\n';

    *--yy_cp = c;

    /* note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif

    {
    int c;
    YY_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* this was really a NUL */
            *yy_c_buf_p = '\0';

        else
            { /* need more input */
            yytext = yy_c_buf_p;
            ++yy_c_buf_p;

            switch ( yy_get_next_buffer() )
                {
                case EOB_ACT_END_OF_FILE:
                    {
                    if ( yywrap() )
                        {
                        yy_c_buf_p = yytext + YY_MORE_ADJ;
                        return ( EOF );
                        }

                    YY_NEW_FILE;

#ifdef __cplusplus
                    return ( yyinput() );
#else
                    return ( input() );
#endif
                    }
                    break;

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext + YY_MORE_ADJ;
                    break;

                case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
                    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
                    YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
                }
            }
        }

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return ( c );
    }


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif

    {
    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif

    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
        {
        /* flush out information for old buffer */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif

    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif

    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );

    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );

    if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    yy_init_buffer( b, file );

    return ( b );
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    if ( b == yy_current_buffer )
        yy_current_buffer = (YY_BUFFER_STATE) 0;

    free( (char *) b->yy_ch_buf );
    free( (char *) b );
    }


#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif

    {
    b->yy_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
    }


void substitute (const char * input)
{
  while (*input)
    {
      switch (*input)
        {
        case '_':
        case '&':
        case '#':
        case '$':
        case '%':
        case '{':
        case '}':
          printf ("\\%c", *input);
          break;
        case '+':
        case '=':
        case '<':
        case '>':
          printf ("$%c$", *input);
          break;
        case '*':
          printf ("$\\ast$");
          break;
        case '|':
          printf ("$\\mid$");
          break;
        case '\\':
          printf ("$\\backslash$");
          break;
        case '^':
          printf ("$\\wedge$");
          break;
        case '~':
          printf ("$\\sim$");
          break;
        default:
          printf ("%c", *input);
          break;
        }
      input++;
    }
}

void
indent(const char * blanks)
{
  int i;
  
  i = 0;
  while (*blanks)
    {
      if (*blanks == ' ')
        {
          i++;
        }
      else                      /* *blanks == '\t' */
        {
          while (++i % tabtotab) ;
        }
      blanks++;
    }
  printf ("\\hspace*{%d\\indentation}", i);
}

#include "getopt.h"
#include <string.h>
#include <fcntl.h>
#ifndef ATARI
#include <malloc.h>      /* Not needed for GCC on Atari ST (14-2-92 AB) */
#endif

extern char * version_string;

static struct option opts[] =
{
  {"ansi-c", 0, 0, 'a'},
  {"c-plusplus", 0, 0, 'p'},
  {"complete-file", 0, 0, 'c'},
  {"font-size", 1, 0, 's'},
  {"indentation", 1, 0, 'i'},
  {"header", 0, 0, 'h'},
  {"piped", 0, 0, 't'},
  {"output", 1, 0, 'o'},
  {"tabstop", 1, 0, 'T'},
  {"comment-font", 1, 0, 'C'},
  {"string-font", 1, 0, 'S'},
  {"keyword-font", 1, 0, 'K'},
  {"header-font", 1, 0, 'H'},
  {"cpp-font", 1, 0, 'P'},
  {"version", 0, 0, 'V'},
  {0, 0, 0, 0}
};


main (int argc, char** argv)
{
  int c;
  int index;
  int i;
  int has_filename;
  char * input_name;
  char * output_name;
  char * program_name;

  input_name = "Standard Input";
  output_name = 0;

  program_name = strrchr (argv[0], '/');
  if (program_name == NULL)     /* no pathname */
    {
      program_name = argv[0];
    }
  else
    {
      program_name++;
    }
  
  
  while ((c = getopt_long (argc, argv,
                           "acpo:s:i:thT:C:H:S:K:P:V", opts, &index))
         != EOF)
    {
      if (c == 0)               /* Long option */
        {
          c = opts[index].val;
        }
      switch (c)
        {
        case 'a':
          cplusplus_mode = 0;
          break;
        case 'p':
          cplusplus_mode = 1;
          break;
        case 'c':
          complete_file = 1;
          break;
        case 'o':
          if (piped)
            {
              fprintf (stderr,
                       "%s: Can't use {-t,+pipe} and {-o,+output} together\n",
                       program_name);
              exit(5);
            }
          output_name = optarg;
          break;
        case 's':
          font_size = optarg;
          break;
        case 'i':
          indentation = optarg;
          break;
        case 'T':
          tabtotab = atoi(optarg);
          break;
            case 't':
              if (output_name != 0)
            {
              fprintf (stderr,
                       "%s: Can't use {-t,+pipe} and {-o,+output} together\n",
                       program_name);
              exit(5);
            }
          piped = 1;
          break;
        case 'h':
          header = 1;
          complete_file = 1;    /* header implies complete-file */
          break;
        case 'C':
          comment_font = optarg;
          break;
        case 'H':
          header_font = optarg;
          break;
        case 'P':
          cpp_font = optarg;
          break;
        case 'S':
          string_font = optarg;
          break;
        case 'K':
          keyword_font = optarg;
          break;
        case 'V':
          fprintf (stderr, "%s\n", version_string);
          break;
        default:
          usage(program_name);
        }
    }
  has_filename = (argc - optind == 1);
  if (has_filename)             /* last argument is input file name */
    {
      input_name = argv[optind];
      if (freopen (input_name, "r", stdin) == NULL)
        {
          fprintf (stderr, "%s: Can't open `%s' for reading\n",
                   program_name, input_name);
          exit (2);
        }
    }
  if ((output_name == 0) && !piped)
    {
      char * tmp;
      if (has_filename)
        {
          char * point;
          
          point = strrchr (input_name, '/');
          if (point == 0)       /* plain filename */
            {
              point = input_name;
            }
          else
            {
              point++;
            }
          tmp = malloc (strlen (point) + 1);
          if (tmp == 0)
            {
              fprintf (stderr, "%s: Virtual memory exhausted\n", program_name);
              exit (3);
            }
          strcpy (tmp, point);
          point = strrchr (tmp, '.');
          if (point != 0)
            {
              *point = '\0';
            }
        }
      else
        {
          tmp = program_name;
        }
      output_name = malloc (strlen (tmp) + 4);
      if (output_name == 0)
        {
          fprintf (stderr, "%s: Virtual memory exhausted\n", program_name);
          exit (3);
        }
      strcpy (output_name, tmp);
      strcat (output_name, ".tex");
    }
  if (!piped)
    {
      if (freopen (output_name, "w", stdout) == NULL)
        {
          fprintf (stderr, "%s: Can't open `%s' for writing\n",
                   program_name, output_name);
          exit (4);
        }
    }
  printf ("\
%%\n\
%% This file was automatically produced at " __DATE__ ", " __TIME__" by\n\
%% %s", program_name);
  for (i = 1; i < argc; i++)
    {
      printf(" %s", argv[i]);
    }
  if (!has_filename)
    {
      printf(" (from Standard Input)");
    }
  printf("\n%%\n");
  if (complete_file)
    {
      if (header)
        {
          if (strcmp (font_size, "10") == 0)
            {
              printf ("\\documentstyle[fancyheadings]{article}\n");
            }
          else
            {
              printf ("\\documentstyle[%spt,fancyheadings]{article}\n",
                      font_size);
            }
        }
      else
        {
          if (strcmp (font_size, "10") == 0)
            {
              printf ("\\documentstyle{article}\n");
            }
          else
            {
              printf ("\\documentstyle[%spt]{article}\n", font_size);
            }
        }
      printf ("\\setlength{\\textwidth}{15cm}\n");
      printf ("\\setlength{\\textheight}{22.5cm}\n");
      printf ("\\setlength{\\hoffset}{-2cm}\n");
      printf ("\\setlength{\\voffset}{-2cm}\n");
      if (header)
        {
          printf ("\\chead{\\%s Produced from ", header_font);
          substitute(input_name);
          printf (" at " __DATE__ ", " __TIME__"}\n");
          printf ("\\cfoot{\\rm\\thepage}\n");
          printf ("\\addtolength{\\headheight}{14pt}\n");
          printf ("\\pagestyle{fancy}\n");
        }
      printf ("\\begin{document}\n");
    }
  printf ("\\expandafter\\ifx\\csname indentation\\endcsname\\relax%\n");
  printf ("\\newlength{\\indentation}\\fi\n");
  printf ("\\setlength{\\indentation}{%s}\n", indentation);
  printf ("\\begin{flushleft}\n");
  yylex();
  printf ("\\end{flushleft}\n");
  if (complete_file)
    {
      printf ("\\end{document}\n");
    }
}

void
usage(const char * name)
{
  fprintf (stderr, "%s\n", version_string);
  fprintf (stderr, "\
Usage: %s [-a] [-c] [-h] [-i length] [-o path] [-p] [-s size] [-t]\n\
       [-C font][-H font] [-K font] [-P font] [-S font] [-T wide] [-V]\n\
       [+ansi-c] [+complete-file] [+header] [+indentation length]\n\
       [+output path] [+c-plusplus] [+font-size size] [+pipe]\n\
       [+comment-font font] [+keyword-font font] [+cpp-font font]\n\
       [+header-font font] [+string-font font] [+tabstop wide]\n\
       [+version] [path]\n", name);
  exit (1);
}
