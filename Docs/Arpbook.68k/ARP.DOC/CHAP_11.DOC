   Atari ST Machine Specific Programming In Assembly

Chapter 11: Reconstructing Source Files

     There are four legitimate sources for software.  You can 
purchase it, you can find it in magazines and books, you can 
obtain it free as public domain or you can write it yourself.  
Rarely will you be satisfied with any of it.  Software that you 
write is easy to alter because you have the source program.  
Magazines and books usually provide source programs also.  But 
commercial and public domain software rarely, if ever, provide 
that convenience.  Altering programs for which you do not have 
the source program is difficult, but not impossible.  The task is 
addressed in this chapter.

Learning From Other Programmers

     If you are a new programmer, you may not realize the extent 
to which experienced programmers study code produced by other 
programmers.  Of course, you will read in your references that 
the only way to become a programmer is to write programs.  To the 
extent that writing programs is the only way in which you can 
test your accumulation of knowledge about programming, that 
statement is true.  But it is not the whole story.  I don't think 
that I can be contradicted in the least when I say that you will 
learn more about programming by studying programs produced by 
other programmers than you ever will by working alone.

     I am convinced of that because I am convinced that the 
accumulation of knowledge and ability is regenerative, in the 
electronic sense; that is, you learn a little from someone, apply 
that to what you already know and use that combined knowledge to 
generate new knowledge by your own initiative.  Then you initiate 
the cycle again by learning a little from someone else.  I am not 
striving to impress you with some radical new concept here; I am 
constructing an argument concerning our debt to each other.  The 
conclusion of that argument is this: no one has ever learned 
anything in solitude.  We all learn from each other; therefore, 
no one owns knowledge.

     To the extent that every idea we can possibly conceive is 
based on knowledge contributed by others, no idea, however 
original can stand isolated; therefore, every item of work that 
we produce is inherently public domain to some degree, whether we 
admit the fact and regardless of our feelings about the matter.  
But, because I want to illustrate the alteration of programs 
produced by third party programmers; that is, programs not 
produced by you nor me; I am forced to consider the feelings and 
opinions of those programmers.  I want to assure those 
programmers and you that my intent is not to provide you with 
assistance in pirating or plagiarizing their works.  With no 
malice intended, I only suggest that after you have purchased 
software you have the right to study and alter it for your own 
use if you choose to do so.

     Furthermore, I suggest that, unless you attempt to 
unethically exploit that right by selling or giving away copies 
of either the original works or altered versions, the authors and 
distributors of those works lose nothing by your study and 
alterations, and, in fact, invite such activities merely by 
making the material available.  If I design a program or write a 
book that I don't want you to study or alter, then I would be 
foolish to publish either.  Imagine the difficulties that 
publishers would encounter if they were to try to prevent readers 
from revealing the contents of magazines and books to those who 
had not purchased and read them.

     One final point, then we'll get down to the business at 
hand.  Software producers have asked that purchasers help to 
protect them against piracy.  I would be more sympathetic to that 
plea if software developers, in turn, would help to protect 
purchasers from software that does not perform as specified and 
from expensive upgrades that introduce more errors than are 
corrected; would write manuals for their products which actually 
explained their use; and, finally, would provide the source code 
so that users could correct the errors that seem beyond the 
ability of the developers.

From Machine Language to Source Program

     As a first example, I will step you through the process of 
converting the machine language of PRG_8AR.ACC, introduced in 
chapter 10, to a source program that may be altered and 
assembled.  The process involves the use of the AssemPro debugger 
to provide disassembly and reassembly listings of the object 
program.  A few things to remember are:

     1. The disassembly and reassembly AssemPro functions are 
        rather unforgiving.  Any errors in usage are apt to cause 
        system crashes.

     2. The listings provided by these functions are saved to the 
        directory from which the object program is loaded; 
        therefore, make sure that there is room before you begin.

     3. Tiny programs produce large listings; large programs 
        produce extremely large listings.  Examples will be 
        given.

     4. The listings provided may contain characters that are not 
        printer compatible.  These must be removed before 
        hardcopy is feasible.

     During the machine language to assembly language conversion 
process you may find it necessary to reload the object program in 
order to single step through a portion of the program or to 
obtain a fresh disassembly or reassembly listing.  To insure that 
the initial disassembly will be reproducible, you must be able to 
load and reload the object program into a reproducible 
environment.  This means that all accessories and auto executed 
programs contained in the system environment during initial 
disassembly and/or reassembly must reside within the environment 
during subsequent disassemblies and/or reassemblies.  
Furthermore, no other programs should be executed before using 
AssemPro to disassemble your object code.  In fact, you may find 
it necessary to cold boot the system between subsequent 
disassemblies of one object program.  The point is that you will 
want the addresses shown on all listings to be identical; 
therefore, you must insure that the object program will be loaded 
into the same area of memory each time.

     Begin by executing AssemPro.  From the debugger, click on 
the Execute program button.  When the dialog box appears, click 
on the OK button.  From the file selector choose PRG_8AR.ACC.  
Remember that the disassembly and reassembly listings will be 
saved to the directory from which the program is loaded into the 
debugger.  Always allow sufficient room for the listings.  For 
example, PRG_8AR.ACC occupies only 1082 bytes of disk space, but 
the disassembly listing requires 15,881 bytes and the reassembly 
listing requires 17,074 bytes.  At those ratios, a program that 
requires 30K to 40K bytes of disk space may produce listings that 
require as much as 500K bytes of space.

     After the program has been loaded into the debugger, record 
the program's start address.  I will be using the values obtained 
on my machine so that you will be able to observe the addresses 
and calculations involved.  The starting address for my example 
is $B20F0.  Click on the from address button.  On the line which 
appears at the bottom of the debugger screen, type the address of 
the program's basepage.  That address is Start address minus 
$100; for this example it is $B20F0 - $100 = $B1FF0.  Refer to 
page 97 of the COMPUTE! TOS book and figure 11.1 during the 
discussion to follow.

  Figure 11.1. PRG_8AR.ACC's basepage as it appears in the 
  AssemPro debugger output window.

























     The longword stored at the first address of the basepage is 
just the first address of the basepage itself; that is, $000B1FF0 
is stored at $0B1FF0.  The longword stored at basepage address + 
8 ($0B1FF8) is the program's start address, $000B20F0.  This 
address is also called the text segment address.  The longword 
stored at basepage address + 12 ($0B1FFC) is the length of the 
program's text segment, $000001E8.  The longword stored at 
basepage address + 16 ($0B2000) is the address of the program's 
data segment, $000B22D8.  The longword stored at basepage address 
+ 20 ($0B2004) is the length of the program's data segment, 
$0000021C.  The longword stored at basepage address + 24 
($0B2008) is the address of the program's bss segment, $000B24F4.  
The longword stored at basepage address + 28 ($0B200C) is the 
length of the program's bss segment, $00000552.

     We want disassembly and reassembly listings that begin at 
the program's start address, called the "from address" by 
AssemPro, and terminate at the end of the longword following the 
end of the program, called the "to address" by AssemPro.  The 
from address is given; it is $B20F0.  The to address must be 
calculated; it is the sum of the program's bss address plus the 
length of the bss segment plus 4; that is, $B24F4 + $552 + $4 = 
$B2A4A.  Figure 11.2 illustrates the appearance of the 
Disassembling dialog box just before the OK button is pressed; 
figure 11.3 is the disassembly listing.

     Note: there will be times when you will want to exclude a 
program's bss section from a disassembly listing because of its 
extreme length.  In fact, the bss section reveals little 
information beyond the amount of memory reserved for the data to 
be stored there.  Here I have simply omitted a large repetitious 
segment of the listing.

Figure 11.2. Preparing the Disassembling dialog box.



















        From the Debugger menu, click on the Disassembling 
  option.  Type the from address and the to address on the 
  appropriate lines.  Click on File: and type the name to be 
  assigned to the listing file.  On the heading line, type an 
  appropriate heading for the listing.  Click on the continuous 
  button, and make sure that the hexadecimal button is 
  highlighted; click on the button if it is not.  Finally, click 
  on the OK button.  A flag will appear in place of the mouse 
  arrow, and it will remain until the disassembly is complete.

  Figure 11.3. The disassembly listing.

PRG_8AR.ACC Disassembly

0B20F0 4FFA0954             LEA $B2A46(PC),A7
0B20F4 3F3C0000             MOVE.W #0,-(A7)
0B20F8 487A03E5             PEA $B24DF(PC)
0B20FC 3F3C003C             MOVE.W #$3C,-(A7)
0B2100 4E41                 TRAP #1
0B2102 508F                 ADDQ.L #8,A7
0B2104 33C0000B2530         MOVE.W D0,$B2530
0B210A 3F3A0424             MOVE.W $B2530(PC),-(A7)
0B210E 3F3C0001             MOVE.W #1,-(A7)
0B2112 3F3C0046             MOVE.W #$46,-(A7)
0B2116 4E41                 TRAP #1
0B2118 5C8F                 ADDQ.L #6,A7
0B211A 363C00C8             MOVE.W #$C8,D3
0B211E 4BFA01B8             LEA $B22D8(PC),A5
0B2122 49FA03D0             LEA $B24F4(PC),A4
0B2126 47FA02E3             LEA $B240B(PC),A3
0B212A 610000DE             BSR $B220A
0B212E 38BC000A             MOVE.W #$A,(A4)
0B2132 397C00000002         MOVE.W #0,2(A4)
0B2138 397C00010004         MOVE.W #1,4(A4)
0B213E 397C00000006         MOVE.W #0,6(A4)
0B2144 397C00000008         MOVE.W #0,8(A4)
0B214A 61000178             BSR $B22C4
0B214E 610000BA             BSR $B220A
0B2152 38BC0023             MOVE.W #$23,(A4)
0B2156 397C00010002         MOVE.W #1,2(A4)
0B215C 397C00010004         MOVE.W #1,4(A4)
0B2162 397C00010006         MOVE.W #1,6(A4)
0B2168 397C00000008         MOVE.W #0,8(A4)
0B216E 41FA038E             LEA $B24FE(PC),A0
0B2172 33E80004000B2508     MOVE.W 4(A0),$B2508
0B217A 23FC000B24CB000B251C MOVE.L #$B24CB,$B251C
0B2184 6100013E             BSR $B22C4
0B2188 33FA0388000B2544     MOVE.W $B2512(PC),$B2544
0B2190 61000078             BSR $B220A
0B2194 23FC000B2534000B251C MOVE.L #$B2534,$B251C
0B219E 38BC0017             MOVE.W #$17,(A4)
0B21A2 397C00000002         MOVE.W #0,2(A4)
0B21A8 397C00010004         MOVE.W #1,4(A4)
0B21AE 397C00010006         MOVE.W #1,6(A4)
0B21B4 397C00000008         MOVE.W #0,8(A4)
0B21BA 61000108             BSR $B22C4
0B21BE 41FA0374             LEA $B2534(PC),A0
0B21C2 0C500028             CMPI.W #$28,(A0)
0B21C6 66D6                 BNE.S $B219E
0B21C8 30280008             MOVE.W 8(A0),D0
0B21CC B07A0376             CMP.W $B2544(PC),D0
0B21D0 66CC                 BNE.S $B219E
0B21D2 0C790005000B2532     CMPI.W #5,$B2532
0B21DA 67C2                 BEQ.S $B219E
0B21DC 6100002C             BSR $B220A
0B21E0 0C790005000B2532     CMPI.W #5,$B2532
0B21E8 6702                 BEQ.S $B21EC
0B21EA 60B2                 BRA.S $B219E
0B21EC 3F3A0342             MOVE.W $B2530(PC),-(A7)
0B21F0 3F3C003E             MOVE.W #$3E,-(A7)
0B21F4 4E41                 TRAP #1
0B21F6 588F                 ADDQ.L #4,A7
0B21F8 3F3C0001             MOVE.W #1,-(A7)
0B21FC 3F3A0332             MOVE.W $B2530(PC),-(A7)
0B2200 3F3C0046             MOVE.W #$46,-(A7)
0B2204 4E41                 TRAP #1
0B2206 5C8F                 ADDQ.L #6,A7
0B2208 6094                 BRA.S $B219E
0B220A 41FA020F             LEA $B241B(PC),A0
0B220E 610000BC             BSR $B22CC
0B2212 41FA00DC             LEA $B22F0(PC),A0
0B2216 303A031A             MOVE.W $B2532(PC),D0
0B221A E548                 LSL.W #2,D0
0B221C 20700000             MOVEA.L 0(A0,D0.W),A0
0B2220 610000AA             BSR $B22CC
0B2224 41FA0295             LEA $B24BB(PC),A0
0B2228 610000A2             BSR $B22CC
0B222C 41FA021D             LEA $B244B(PC),A0
0B2230 6100009A             BSR $B22CC
0B2234 41FA0285             LEA $B24BB(PC),A0
0B2238 61000092             BSR $B22CC
0B223C 41FA0245             LEA $B2483(PC),A0
0B2240 6100008A             BSR $B22CC
0B2244 7E00                 MOVEQ #0,D7
0B2246 7C04                 MOVEQ #4,D6
0B2248 41FA02FC             LEA $B2546(PC),A0
0B224C 2C4D                 MOVEA.L A5,A6
0B224E 3A3C0005             MOVE.W #5,D5
0B2252 303C000B             MOVE.W #$B,D0
0B2256 10FC0020             MOVE.B #$20,(A0)+
0B225A 51C8FFFA             DBRA D0,$B2256
0B225E 3007                 MOVE.W D7,D0
0B2260 0200000F             ANDI.B #$F,D0
0B2264 10330000             MOVE.B 0(A3,D0.W),D0
0B2268 10C0                 MOVE.B D0,(A0)+
0B226A 10FC003A             MOVE.B #$3A,(A0)+
0B226E 10FC0020             MOVE.B #$20,(A0)+
0B2272 3007                 MOVE.W D7,D0
0B2274 E348                 LSL.W #1,D0
0B2276 225E                 MOVEA.L (A6)+,A1
0B2278 30310000             MOVE.W 0(A1,D0.W),D0
0B227C 7403                 MOVEQ #3,D2
0B227E E958                 ROL.W #4,D0
0B2280 1200                 MOVE.B D0,D1
0B2282 0201000F             ANDI.B #$F,D1
0B2286 4881                 EXT.W D1
0B2288 12331000             MOVE.B 0(A3,D1.W),D1
0B228C 10C1                 MOVE.B D1,(A0)+
0B228E 51CAFFEE             DBRA D2,$B227E
0B2292 10FC0020             MOVE.B #$20,(A0)+
0B2296 10FC0020             MOVE.B #$20,(A0)+
0B229A 51CDFFC2             DBRA D5,$B225E
0B229E 10BC0000             MOVE.B #0,(A0)
0B22A2 41FA02A2             LEA $B2546(PC),A0
0B22A6 61000024             BSR $B22CC
0B22AA 41FA016F             LEA $B241B(PC),A0
0B22AE 6100001C             BSR $B22CC
0B22B2 06470001             ADDI.W #1,D7
0B22B6 51CEFF90             DBRA D6,$B2248
0B22BA 06790001000B2532     ADDI.W #1,$B2532
0B22C2 4E75                 RTS
0B22C4 220D                 MOVE.L A5,D1
0B22C6 3003                 MOVE.W D3,D0
0B22C8 4E42                 TRAP #2
0B22CA 4E75                 RTS
0B22CC 2F08                 MOVE.L A0,-(A7)
0B22CE 3F3C0009             MOVE.W #9,-(A7)
0B22D2 4E41                 TRAP #1
0B22D4 5C8F                 ADDQ.L #6,A7
0B22D6 4E75                 RTS
0B22D8 000B                 DC.W $B  
0B22DA 24F4000B             MOVE.L $B(A4,D0.W),(A2)+
0B22DE 24FE                 MOVE.L SR,(A2)+
0B22E0 000B                 DC.W $B  
0B22E2 2508                 MOVE.L A0,-(A2)
0B22E4 000B                 DC.W $B  
0B22E6 2512                 MOVE.L (A2),-(A2)
0B22E8 000B                 DC.W $B  
0B22EA 251C                 MOVE.L (A4)+,-(A2)
0B22EC 000B                 DC.W $B  
0B22EE 2526                 MOVE.L -(A6),-(A2)
0B22F0 000B                 DC.W $B  
0B22F2 2304                 MOVE.L D4,-(A1)
0B22F4 000B                 DC.W $B  
0B22F6 2329000B             MOVE.L $B(A1),-(A1)
0B22FA 2363000B             MOVE.L -(A3),$B(A1)
0B22FE 239E000B             MOVE.L (A6)+,$B(A1,D0.W)
0B2302 23D80D0A5445         MOVE.L (A0)+,$A5445
0B2308 5354                 SUBQ.W #1,(A4)
0B230A 2050                 MOVEA.L (A0),A0
0B230C 4F49                 DC.W $4F49 ;"OI"
0B230E 4E542030             LINK A4,#$2030
0B2312 3A20                 MOVE.W -(A0),D5
0B2314 4265                 CLR.W -(A5)
0B2316 666F                 BNE.S $B2387
0B2318 7265                 MOVEQ #$65,D1
0B231A 2061                 MOVEA.L -(A1),A0
0B231C 7070                 MOVEQ #$70,D0
0B231E 6C5F                 BGE.S $B237F
0B2320 696E                 BVS.S $B2390
0B2322 6974                 BVS.S $B2398
0B2324 0D0A0D0A             MOVEP.W $D0A(A2),D6
0B2328 000D                 DC.W $D  
0B232A 0A544553             EORI.W #$4553,(A4)
0B232E 5420                 ADDQ.B #2,-(A0)
0B2330 504F                 ADDQ.W #8,A7
0B2332 494E                 DC.W $494E ;"IN"
0B2334 5420                 ADDQ.B #2,-(A0)
0B2336 313A2041             MOVE.W $B4379(PC),-(A0)
0B233A 6674                 BNE.S $B23B0
0B233C 6572                 BCS.S $B23B0
0B233E 2061                 MOVEA.L -(A1),A0
0B2340 7070                 MOVEQ #$70,D0
0B2342 6C5F                 BGE.S $B23A3
0B2344 696E                 BVS.S $B23B4
0B2346 6974                 BVS.S $B23BC
0B2348 2C20                 MOVE.L -(A0),D6
0B234A 6265                 BHI.S $B23B1
0B234C 666F                 BNE.S $B23BD
0B234E 7265                 MOVEQ #$65,D1
0B2350 206D656E             MOVEA.L $656E(A5),A0
0B2354 755F                 DC.W $755F ;"u_"
0B2356 7265                 MOVEQ #$65,D1
0B2358 6769                 BEQ.S $B23C3
0B235A 7374                 DC.W $7374 ;"st"
0B235C 6572                 BCS.S $B23D0
0B235E 0D0A0D0A             MOVEP.W $D0A(A2),D6
0B2362 000D                 DC.W $D  
0B2364 0A544553             EORI.W #$4553,(A4)
0B2368 5420                 ADDQ.B #2,-(A0)
0B236A 504F                 ADDQ.W #8,A7
0B236C 494E                 DC.W $494E ;"IN"
0B236E 5420                 ADDQ.B #2,-(A0)
0B2370 323A2041             MOVE.W $B43B3(PC),D1
0B2374 6674                 BNE.S $B23EA
0B2376 6572                 BCS.S $B23EA
0B2378 206D656E             MOVEA.L $656E(A5),A0
0B237C 755F                 DC.W $755F ;"u_"
0B237E 7265                 MOVEQ #$65,D1
0B2380 6769                 BEQ.S $B23EB
0B2382 7374                 DC.W $7374 ;"st"
0B2384 6572                 BCS.S $B23F8
0B2386 2C20                 MOVE.L -(A0),D6
0B2388 6265                 BHI.S $B23EF
0B238A 666F                 BNE.S $B23FB
0B238C 7265                 MOVEQ #$65,D1
0B238E 2065                 MOVEA.L -(A5),A0
0B2390 766E                 MOVEQ #$6E,D3
0B2392 745F                 MOVEQ #$5F,D2
0B2394 6D65                 BLT.S $B23FB
0B2396 7361                 DC.W $7361 ;"sa"
0B2398 670D                 BEQ.S $B23A7
0B239A 0A0D                 DC.W $A0D  
0B239C 0A000D0A             EORI.B #$A,D0
0B23A0 5445                 ADDQ.W #2,D5
0B23A2 5354                 SUBQ.W #1,(A4)
0B23A4 2050                 MOVEA.L (A0),A0
0B23A6 4F49                 DC.W $4F49 ;"OI"
0B23A8 4E542033             LINK A4,#$2033
0B23AC 3A20                 MOVE.W -(A0),D5
0B23AE 496E                 DC.W $496E ;"In"
0B23B0 206D6573             MOVEA.L $6573(A5),A0
0B23B4 7361                 DC.W $7361 ;"sa"
0B23B6 6765                 BEQ.S $B241D
0B23B8 2068616E             MOVEA.L $616E(A0),A0
0B23BC 646C                 BCC.S $B242A
0B23BE 6572                 BCS.S $B2432
0B23C0 2C20                 MOVE.L -(A0),D6
0B23C2 6265                 BHI.S $B2429
0B23C4 666F                 BNE.S $B2435
0B23C6 7265                 MOVEQ #$65,D1
0B23C8 2065                 MOVEA.L -(A5),A0
0B23CA 766E                 MOVEQ #$6E,D3
0B23CC 745F                 MOVEQ #$5F,D2
0B23CE 6D65                 BLT.S $B2435
0B23D0 7361                 DC.W $7361 ;"sa"
0B23D2 670D                 BEQ.S $B23E1
0B23D4 0A0D                 DC.W $A0D  
0B23D6 0A000D0A             EORI.B #$A,D0
0B23DA 5445                 ADDQ.W #2,D5
0B23DC 5354                 SUBQ.W #1,(A4)
0B23DE 2050                 MOVEA.L (A0),A0
0B23E0 4F49                 DC.W $4F49 ;"OI"
0B23E2 4E542034             LINK A4,#$2034
0B23E6 3A20                 MOVE.W -(A0),D5
0B23E8 496E                 DC.W $496E ;"In"
0B23EA 206D6573             MOVEA.L $6573(A5),A0
0B23EE 7361                 DC.W $7361 ;"sa"
0B23F0 6765                 BEQ.S $B2457
0B23F2 2068616E             MOVEA.L $616E(A0),A0
0B23F6 646C                 BCC.S $B2464
0B23F8 6572                 BCS.S $B246C
0B23FA 2073                 DC.W $2073 ;" s"
0B23FC 6563                 BCS.S $B2461
0B23FE 6F6E                 BLE.S $B246E
0B2400 6420                 BCC.S $B2422
0B2402 7469                 MOVEQ #$69,D2
0B2404 6D65                 BLT.S $B246B
0B2406 0D0A0D0A             MOVEP.W $D0A(A2),D6
0B240A 0030                 DC.W $30  
0B240C 3132                 DC.W $3132 ;"12"
0B240E 3334                 DC.W $3334 ;"34"
0B2410 3536                 DC.W $3536 ;"56"
0B2412 37383941             MOVE.W $3941,-(A3)
0B2416 4243                 CLR.W D3
0B2418 4445                 NEG.W D5
0B241A 460D                 DC.W $460D  
0B241C 0A002020             EORI.B #$20,D0
0B2420 2020                 MOVE.L -(A0),D0
0B2422 2020                 MOVE.L -(A0),D0
0B2424 2020                 MOVE.L -(A0),D0
0B2426 2020                 MOVE.L -(A0),D0
0B2428 2020                 MOVE.L -(A0),D0
0B242A 2020                 MOVE.L -(A0),D0
0B242C 2020                 MOVE.L -(A0),D0
0B242E 2020                 MOVE.L -(A0),D0
0B2430 2020                 MOVE.L -(A0),D0
0B2432 2020                 MOVE.L -(A0),D0
0B2434 2020                 MOVE.L -(A0),D0
0B2436 2020                 MOVE.L -(A0),D0
0B2438 2020                 MOVE.L -(A0),D0
0B243A 2020                 MOVE.L -(A0),D0
0B243C 2020                 MOVE.L -(A0),D0
0B243E 4145                 DC.W $4145 ;"AE"
0B2440 5320                 SUBQ.B #1,-(A0)
0B2442 4152                 DC.W $4152 ;"AR"
0B2444 5241                 ADDQ.W #1,D1
0B2446 5953                 SUBQ.W #4,(A3)
0B2448 0D0A0043             MOVEP.W $43(A2),D6
0B244C 4F4E                 DC.W $4F4E ;"ON"
0B244E 5452                 ADDQ.W #2,(A2)
0B2450 4F4C                 DC.W $4F4C ;"OL"
0B2452 2020                 MOVE.L -(A0),D0
0B2454 474C                 DC.W $474C ;"GL"
0B2456 4F42                 DC.W $4F42 ;"OB"
0B2458 414C                 DC.W $414C ;"AL"
0B245A 2020                 MOVE.L -(A0),D0
0B245C 2049                 MOVEA.L A1,A0
0B245E 4E545F49             LINK A4,#$5F49
0B2462 4E20                 DC.W $4E20 ;"N "
0B2464 2020                 MOVE.L -(A0),D0
0B2466 494E                 DC.W $494E ;"IN"
0B2468 545F                 ADDQ.W #2,(A7)+
0B246A 4F55                 DC.W $4F55 ;"OU"
0B246C 5420                 ADDQ.B #2,-(A0)
0B246E 2041                 MOVEA.L D1,A0
0B2470 4444                 NEG.W D4
0B2472 525F                 ADDQ.W #1,(A7)+
0B2474 494E                 DC.W $494E ;"IN"
0B2476 2020                 MOVE.L -(A0),D0
0B2478 4144                 DC.W $4144 ;"AD"
0B247A 4452                 NEG.W (A2)
0B247C 5F4F                 SUBQ.W #7,A7
0B247E 5554                 SUBQ.W #2,(A4)
0B2480 0D0A002D             MOVEP.W $2D(A2),D6
0B2484 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B2488 2D2D2020             MOVE.L $2020(A5),-(A6)
0B248C 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B2490 2D2D2D20             MOVE.L $2D20(A5),-(A6)
0B2494 202D2D2D             MOVE.L $2D2D(A5),D0
0B2498 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B249C 2020                 MOVE.L -(A0),D0
0B249E 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B24A2 2D2D2D20             MOVE.L $2D20(A5),-(A6)
0B24A6 202D2D2D             MOVE.L $2D2D(A5),D0
0B24AA 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B24AE 2020                 MOVE.L -(A0),D0
0B24B0 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B24B4 2D2D2D2D             MOVE.L $2D2D(A5),-(A6)
0B24B8 0D0A0020             MOVEP.W $20(A2),D6
0B24BC 2020                 MOVE.L -(A0),D0
0B24BE 2020                 MOVE.L -(A0),D0
0B24C0 2020                 MOVE.L -(A0),D0
0B24C2 2020                 MOVE.L -(A0),D0
0B24C4 2020                 MOVE.L -(A0),D0
0B24C6 2000                 MOVE.L D0,D0
0B24C8 2020                 MOVE.L -(A0),D0
0B24CA 00202041             ORI.B #$41,-(A0)
0B24CE 6363                 BLS.S $B2533
0B24D0 6573                 BCS.S $B2545
0B24D2 736F                 DC.W $736F ;"so"
0B24D4 7279                 MOVEQ #$79,D1
0B24D6 2041                 MOVEA.L D1,A0
0B24D8 7272                 MOVEQ #$72,D1
0B24DA 6179                 BSR.S $B2555
0B24DC 7320                 DC.W $7320 ;"s "
0B24DE 00453A5C             ORI.W #$3A5C,D5
0B24E2 5052                 ADDQ.W #8,(A2)
0B24E4 475F                 DC.W $475F ;"G_"
0B24E6 385C                 MOVEA.W (A4)+,A4
0B24E8 5052                 ADDQ.W #8,(A2)
0B24EA 475F                 DC.W $475F ;"G_"
0B24EC 3841                 MOVEA.W D1,A4
0B24EE 522E4441             ADDQ.B #1,$4441(A6)
0B24F2 5400                 ADDQ.B #2,D0
0B24F4 00000000             ORI.B #0,D0

The section containing addresses 0B24F8 - 0B2A40 omitted.

0B2A44 00000000             ORI.B #0,D0
0B2A48 00000000             ORI.B #0,D0
  

     When the mouse arrow appears following disassembly, choose 
the Reassembling option from the debugger menu.  Click on File: 
and change the extension from DSM to ASM.  Click on the OK 
button.  When the More Start Addresses dialog box appears, click 
on the Quit button.  A flag will appear in place of the mouse 
arrow until the reassembly is complete.  Figure 11.4 illustrates 
the appearance of the Reassembling dialog box just before you 
press the OK button; figure 11.5 is the reassembly listing, 
somewhat abbreviated, with the repetitious portion omitted.
Figure 11.4. Preparing the reassembling dialog box.

















Preparing the File for Printing

     Before I place the reassembly listing in this document, I 
must remove certain characters that are not compatible with my 
printer.  These are the characters following the semicolons on 
the lines 148 through 169.  With TEMPUS, I remove the unwanted 
character groups by typing ;* on the Search below string: line, 
and by typing a blank space on the ... and replace by following 
line.  I choose the whole text for the search region; start 
search at cursor, with the cursor at the semicolon of the first 
group; and selectable for the quantity option.  When the START 
button is pressed, the cursor advances to each semicolon in turn, 
stopping to permit a selection from the Search & Replace 
selection dialog box.  I can then choose YES, NO or CANCEL as 
desired.

Figure 11.5. The reassembly listing.

   1: K00001=0
   2: K00003=$3C
   3: K00004=1
   4: K00006=$46
   5: K00007=$C8
   6: K0000C=$A
   7: K0000D=2
   8: K0000E=4
   9: K0000F=6
  10: K00010=8
  11: K00012=$23
  12: K0001A=$17
  13: K0001B=$28
  14: K0001D=5
  15: K00020=$3E
  16: K00028=$B
  17: K00029=$20
  18: K0002B=$F
  19: K0002C=$3A
  20: K0002D=3
  21: K00031=9
  22:  LEA L00000(PC),A7
  23:  MOVE.W #K00001,-(A7)
  24:  PEA L00002+1(PC)
  25:  MOVE.W #K00003,-(A7)
  26:  TRAP #K00004
  27:  ADDQ.L #8,A7
  28:  MOVE.W D0,L00005
  29:  MOVE.W L00005(PC),-(A7)
  30:  MOVE.W #K00004,-(A7)
  31:  MOVE.W #K00006,-(A7)
  32:  TRAP #K00004
  33:  ADDQ.L #6,A7
  34:  MOVE.W #K00007,D3
  35:  LEA L00008(PC),A5
  36:  LEA L00009(PC),A4
  37:  LEA L0000A+1(PC),A3
  38:  BSR L0000B
  39:  MOVE.W #K0000C,(A4)
  40:  MOVE.W #K00001,K0000D(A4)
  41:  MOVE.W #K00004,K0000E(A4)
  42:  MOVE.W #K00001,K0000F(A4)
  43:  MOVE.W #K00001,K00010(A4)
  44:  BSR L00011
  45:  BSR L0000B
  46:  MOVE.W #K00012,(A4)
  47:  MOVE.W #K00004,K0000D(A4)
  48:  MOVE.W #K00004,K0000E(A4)
  49:  MOVE.W #K00004,K0000F(A4)
  50:  MOVE.W #K00001,K00010(A4)
  51:  LEA L00013(PC),A0
  52:  MOVE.W K0000E(A0),L00014
  53:  MOVE.L #L00015+1,L00016
  54:  BSR L00011
  55:  MOVE.W L00017(PC),L00018
  56:  BSR L0000B
  57:  MOVE.L #L00019,L00016
  58: L0001C:MOVE.W #K0001A,(A4)
  59:  MOVE.W #K00001,K0000D(A4)
  60:  MOVE.W #K00004,K0000E(A4)
  61:  MOVE.W #K00004,K0000F(A4)
  62:  MOVE.W #K00001,K00010(A4)
  63:  BSR L00011
  64:  LEA L00019(PC),A0
  65:  CMPI.W #K0001B,(A0)
  66:  BNE.S L0001C
  67:  MOVE.W K00010(A0),D0
  68:  CMP.W L00018(PC),D0
  69:  BNE.S L0001C
  70:  CMPI.W #K0001D,L0001E
  71:  BEQ.S L0001C
  72:  BSR L0000B
  73:  CMPI.W #K0001D,L0001E
  74:  BEQ.S L0001F
  75:  BRA.S L0001C
  76: L0001F:MOVE.W L00005(PC),-(A7)
  77:  MOVE.W #K00020,-(A7)
  78:  TRAP #K00004
  79:  ADDQ.L #4,A7
  80:  MOVE.W #K00004,-(A7)
  81:  MOVE.W L00005(PC),-(A7)
  82:  MOVE.W #K00006,-(A7)
  83:  TRAP #K00004
  84:  ADDQ.L #6,A7
  85:  BRA.S L0001C
  86: L0000B:LEA L00021+1(PC),A0
  87:  BSR L00022
  88:  LEA L00023(PC),A0
  89:  MOVE.W L0001E(PC),D0
  90:  LSL.W #K0000D,D0
  91:  MOVEA.L K00001(A0,D0.W),A0
  92:  BSR L00022
  93:  LEA L00024+1(PC),A0
  94:  BSR L00022
  95:  LEA L00025+1(PC),A0
  96:  BSR L00022
  97:  LEA L00024+1(PC),A0
  98:  BSR L00022
  99:  LEA L00026+1(PC),A0
 100:  BSR L00022
 101:  MOVEQ #K00001,D7
 102:  MOVEQ #K0000E,D6
 103: L00030:LEA L00027(PC),A0
 104:  MOVEA.L A5,A6
 105:  MOVE.W #K0001D,D5
 106:  MOVE.W #K00028,D0
 107: L0002A:MOVE.B #K00029,(A0)+
 108:  DBRA D0,L0002A
 109: L0002F:MOVE.W D7,D0
 110:  ANDI.B #K0002B,D0
 111:  MOVE.B K00001(A3,D0.W),D0
 112:  MOVE.B D0,(A0)+
 113:  MOVE.B #K0002C,(A0)+
 114:  MOVE.B #K00029,(A0)+
 115:  MOVE.W D7,D0
 116:  LSL.W #K00004,D0
 117:  MOVEA.L (A6)+,A1
 118:  MOVE.W K00001(A1,D0.W),D0
 119:  MOVEQ #K0002D,D2
 120: L0002E:ROL.W #K0000E,D0
 121:  MOVE.B D0,D1
 122:  ANDI.B #K0002B,D1
 123:  EXT.W D1
 124:  MOVE.B K00001(A3,D1.W),D1
 125:  MOVE.B D1,(A0)+
 126:  DBRA D2,L0002E
 127:  MOVE.B #K00029,(A0)+
 128:  MOVE.B #K00029,(A0)+
 129:  DBRA D5,L0002F
 130:  MOVE.B #K00001,(A0)
 131:  LEA L00027(PC),A0
 132:  BSR L00022
 133:  LEA L00021+1(PC),A0
 134:  BSR L00022
 135:  ADDI.W #K00004,D7
 136:  DBRA D6,L00030
 137:  ADDI.W #K00004,L0001E
 138:  RTS
 139: L00011:MOVE.L A5,D1
 140:  MOVE.W D3,D0
 141:  TRAP #K0000D
 142:  RTS
 143: L00022:MOVE.L A0,-(A7)
 144:  MOVE.W #K00031,-(A7)
 145:  TRAP #K00004
 146:  ADDQ.L #6,A7
 147:  RTS
 148: L00008:DC.W K00028  
 149:  DC.W $24F4  
 150:  DC.W K00028  
 151:  DC.W $24FE  
 152:  DC.W K00028  
 153:  DC.W $2508  
 154:  DC.W K00028  
 155:  DC.W $2512  
 156:  DC.W K00028  
 157:  DC.W $251C  
 158:  DC.W K00028  
 159:  DC.W $2526  
 160: L00023:DC.W K00028  
 161:  DC.W $2304  
 162:  DC.W K00028  
 163:  DC.W $2329  
 164:  DC.W K00028  
 165:  DC.W $2363  
 166:  DC.W K00028  
 167:  DC.W $239E  
 168:  DC.W K00028  
 169:  DC.W $23D8  
 170:  DC.W $D0A ;">CR<>LF<"
 171:  DC.W $5445 ;"TE"
 172:  DC.W $5354 ;"ST"
 173:  DC.W $2050 ;" P"
 174:  DC.W $4F49 ;"OI"
 175:  DC.W $4E54 ;"NT"
 176:  DC.W $2030 ;" 0"
 177:  DC.W $3A20 ;": "
 178:  DC.W $4265 ;"Be"
 179:  DC.W $666F ;"fo"
 180:  DC.W $7265 ;"re"
 181:  DC.W $2061 ;" a"
 182:  DC.W $7070 ;"pp"
 183:  DC.W $6C5F ;"l_"
 184:  DC.W $696E ;"in"
 185:  DC.W $6974 ;"it"
 186:  DC.W $D0A ;">CR<>LF<"
 187:  DC.W $D0A ;">CR<>LF<"
 188:  DC.W $D ;">0<>CR<"
 189:  DC.W $A54 ;">LF<T"
 190:  DC.W $4553 ;"ES"
 191:  DC.W $5420 ;"T "
 192:  DC.W $504F ;"PO"
 193:  DC.W $494E ;"IN"
 194:  DC.W $5420 ;"T "
 195:  DC.W $313A ;"1:"
 196:  DC.W $2041 ;" A"
 197:  DC.W $6674 ;"ft"
 198:  DC.W $6572 ;"er"
 199:  DC.W $2061 ;" a"
 200:  DC.W $7070 ;"pp"
 201:  DC.W $6C5F ;"l_"
 202:  DC.W $696E ;"in"
 203:  DC.W $6974 ;"it"
 204:  DC.W $2C20 ;", "
 205:  DC.W $6265 ;"be"
 206:  DC.W $666F ;"fo"
 207:  DC.W $7265 ;"re"
 208:  DC.W $206D ;" m"
 209:  DC.W $656E ;"en"
 210:  DC.W $755F ;"u_"
 211:  DC.W $7265 ;"re"
 212:  DC.W $6769 ;"gi"
 213:  DC.W $7374 ;"st"
 214:  DC.W $6572 ;"er"
 215:  DC.W $D0A ;">CR<>LF<"
 216:  DC.W $D0A ;">CR<>LF<"
 217:  DC.W $D ;">0<>CR<"
 218:  DC.W $A54 ;">LF<T"
 219:  DC.W $4553 ;"ES"
 220:  DC.W $5420 ;"T "
 221:  DC.W $504F ;"PO"
 222:  DC.W $494E ;"IN"
 223:  DC.W $5420 ;"T "
 224:  DC.W $323A ;"2:"
 225:  DC.W $2041 ;" A"
 226:  DC.W $6674 ;"ft"
 227:  DC.W $6572 ;"er"
 228:  DC.W $206D ;" m"
 229:  DC.W $656E ;"en"
 230:  DC.W $755F ;"u_"
 231:  DC.W $7265 ;"re"
 232:  DC.W $6769 ;"gi"
 233:  DC.W $7374 ;"st"
 234:  DC.W $6572 ;"er"
 235:  DC.W $2C20 ;", "
 236:  DC.W $6265 ;"be"
 237:  DC.W $666F ;"fo"
 238:  DC.W $7265 ;"re"
 239:  DC.W $2065 ;" e"
 240:  DC.W $766E ;"vn"
 241:  DC.W $745F ;"t_"
 242:  DC.W $6D65 ;"me"
 243:  DC.W $7361 ;"sa"
 244:  DC.W $670D ;"g>CR<"
 245:  DC.W $A0D ;">LF<>CR<"
 246:  DC.W $A00 ;">LF<>0<"
 247:  DC.W $D0A ;">CR<>LF<"
 248:  DC.W $5445 ;"TE"
 249:  DC.W $5354 ;"ST"
 250:  DC.W $2050 ;" P"
 251:  DC.W $4F49 ;"OI"
 252:  DC.W $4E54 ;"NT"
 253:  DC.W $2033 ;" 3"
 254:  DC.W $3A20 ;": "
 255:  DC.W $496E ;"In"
 256:  DC.W $206D ;" m"
 257:  DC.W $6573 ;"es"
 258:  DC.W $7361 ;"sa"
 259:  DC.W $6765 ;"ge"
 260:  DC.W $2068 ;" h"
 261:  DC.W $616E ;"an"
 262:  DC.W $646C ;"dl"
 263:  DC.W $6572 ;"er"
 264:  DC.W $2C20 ;", "
 265:  DC.W $6265 ;"be"
 266:  DC.W $666F ;"fo"
 267:  DC.W $7265 ;"re"
 268:  DC.W $2065 ;" e"
 269:  DC.W $766E ;"vn"
 270:  DC.W $745F ;"t_"
 271:  DC.W $6D65 ;"me"
 272:  DC.W $7361 ;"sa"
 273:  DC.W $670D ;"g>CR<"
 274:  DC.W $A0D ;">LF<>CR<"
 275:  DC.W $A00 ;">LF<>0<"
 276:  DC.W $D0A ;">CR<>LF<"
 277:  DC.W $5445 ;"TE"
 278:  DC.W $5354 ;"ST"
 279:  DC.W $2050 ;" P"
 280:  DC.W $4F49 ;"OI"
 281:  DC.W $4E54 ;"NT"
 282:  DC.W $2034 ;" 4"
 283:  DC.W $3A20 ;": "
 284:  DC.W $496E ;"In"
 285:  DC.W $206D ;" m"
 286:  DC.W $6573 ;"es"
 287:  DC.W $7361 ;"sa"
 288:  DC.W $6765 ;"ge"
 289:  DC.W $2068 ;" h"
 290:  DC.W $616E ;"an"
 291:  DC.W $646C ;"dl"
 292:  DC.W $6572 ;"er"
 293:  DC.W $2073 ;" s"
 294:  DC.W $6563 ;"ec"
 295:  DC.W $6F6E ;"on"
 296:  DC.W $6420 ;"d "
 297:  DC.W $7469 ;"ti"
 298:  DC.W $6D65 ;"me"
 299:  DC.W $D0A ;">CR<>LF<"
 300:  DC.W $D0A ;">CR<>LF<"
 301: L0000A:DC.W $30 ;">0<0"
 302:  DC.W $3132 ;"12"
 303:  DC.W $3334 ;"34"
 304:  DC.W $3536 ;"56"
 305:  DC.W $3738 ;"78"
 306:  DC.W $3941 ;"9A"
 307:  DC.W $4243 ;"BC"
 308:  DC.W $4445 ;"DE"
 309: L00021:DC.W $460D ;"F>CR<"
 310:  DC.W $A00 ;">LF<>0<"
 311:  DC.W $2020 ;"  "
 312:  DC.W $2020 ;"  "
 313:  DC.W $2020 ;"  "
 314:  DC.W $2020 ;"  "
 315:  DC.W $2020 ;"  "
 316:  DC.W $2020 ;"  "
 317:  DC.W $2020 ;"  "
 318:  DC.W $2020 ;"  "
 319:  DC.W $2020 ;"  "
 320:  DC.W $2020 ;"  "
 321:  DC.W $2020 ;"  "
 322:  DC.W $2020 ;"  "
 323:  DC.W $2020 ;"  "
 324:  DC.W $2020 ;"  "
 325:  DC.W $2020 ;"  "
 326:  DC.W $2020 ;"  "
 327:  DC.W $4145 ;"AE"
 328:  DC.W $5320 ;"S "
 329:  DC.W $4152 ;"AR"
 330:  DC.W $5241 ;"RA"
 331:  DC.W $5953 ;"YS"
 332:  DC.W $D0A ;">CR<>LF<"
 333: L00025:DC.W $43 ;">0<C"
 334:  DC.W $4F4E ;"ON"
 335:  DC.W $5452 ;"TR"
 336:  DC.W $4F4C ;"OL"
 337:  DC.W $2020 ;"  "
 338:  DC.W $474C ;"GL"
 339:  DC.W $4F42 ;"OB"
 340:  DC.W $414C ;"AL"
 341:  DC.W $2020 ;"  "
 342:  DC.W $2049 ;" I"
 343:  DC.W $4E54 ;"NT"
 344:  DC.W $5F49 ;"_I"
 345:  DC.W $4E20 ;"N "
 346:  DC.W $2020 ;"  "
 347:  DC.W $494E ;"IN"
 348:  DC.W $545F ;"T_"
 349:  DC.W $4F55 ;"OU"
 350:  DC.W $5420 ;"T "
 351:  DC.W $2041 ;" A"
 352:  DC.W $4444 ;"DD"
 353:  DC.W $525F ;"R_"
 354:  DC.W $494E ;"IN"
 355:  DC.W $2020 ;"  "
 356:  DC.W $4144 ;"AD"
 357:  DC.W $4452 ;"DR"
 358:  DC.W $5F4F ;"_O"
 359:  DC.W $5554 ;"UT"
 360:  DC.W $D0A ;">CR<>LF<"
 361: L00026:DC.W $2D ;">0<-"
 362:  DC.W $2D2D ;"--"
 363:  DC.W $2D2D ;"--"
 364:  DC.W $2D2D ;"--"
 365:  DC.W $2020 ;"  "
 366:  DC.W $2D2D ;"--"
 367:  DC.W $2D2D ;"--"
 368:  DC.W $2D2D ;"--"
 369:  DC.W $2D20 ;"- "
 370:  DC.W $202D ;" -"
 371:  DC.W $2D2D ;"--"
 372:  DC.W $2D2D ;"--"
 373:  DC.W $2D2D ;"--"
 374:  DC.W $2020 ;"  "
 375:  DC.W $2D2D ;"--"
 376:  DC.W $2D2D ;"--"
 377:  DC.W $2D2D ;"--"
 378:  DC.W $2D20 ;"- "
 379:  DC.W $202D ;" -"
 380:  DC.W $2D2D ;"--"
 381:  DC.W $2D2D ;"--"
 382:  DC.W $2D2D ;"--"
 383:  DC.W $2020 ;"  "
 384:  DC.W $2D2D ;"--"
 385:  DC.W $2D2D ;"--"
 386:  DC.W $2D2D ;"--"
 387:  DC.W $2D2D ;"--"
 388:  DC.W $D0A ;">CR<>LF<"
 389: L00024:DC.W K00029 ;">0< "
 390:  DC.W $2020 ;"  "
 391:  DC.W $2020 ;"  "
 392:  DC.W $2020 ;"  "
 393:  DC.W $2020 ;"  "
 394:  DC.W $2020 ;"  "
 395:  DC.W $2000 ;" >0<"
 396:  DC.W $2020 ;"  "
 397: L00015:DC.W K00029 ;">0< "
 398:  DC.W $2041 ;" A"
 399:  DC.W $6363 ;"cc"
 400:  DC.W $6573 ;"es"
 401:  DC.W $736F ;"so"
 402:  DC.W $7279 ;"ry"
 403:  DC.W $2041 ;" A"
 404:  DC.W $7272 ;"rr"
 405:  DC.W $6179 ;"ay"
 406:  DC.W $7320 ;"s "
 407: L00002:DC.W $45 ;">0<E"
 408:  DC.W $3A5C ;":\"
 409:  DC.W $5052 ;"PR"
 410:  DC.W $475F ;"G_"
 411:  DC.W $385C ;"8\"
 412:  DC.W $5052 ;"PR"
 413:  DC.W $475F ;"G_"
 414:  DC.W $3841 ;"8A"
 415:  DC.W $522E ;"R."
 416:  DC.W $4441 ;"DA"
 417:  DC.W $5400 ;"T>0<"
 418: L00009:DC.W K00001
 419:  DC.W K00001
 420:  DC.W K00001
 421:  DC.W K00001
 422:  DC.W K00001
 423: L00013:DC.W K00001
 424:  DC.W K00001
 425:  DC.W K00001
 426:  DC.W K00001
 427:  DC.W K00001
 428: L00014:DC.W K00001
 429:  DC.W K00001
 430:  DC.W K00001
 431:  DC.W K00001
 432:  DC.W K00001
 433: L00017:DC.W K00001
 434:  DC.W K00001
 435:  DC.W K00001
 436:  DC.W K00001
 437:  DC.W K00001
 438: L00016:DC.W K00001
 439:  DC.W K00001
 440:  DC.W K00001
 441:  DC.W K00001
 442:  DC.W K00001
 443:  DC.W K00001
 444:  DC.W K00001
 445:  DC.W K00001
 446:  DC.W K00001
 447:  DC.W K00001
 448: L00005:DC.W K00001
 449: L0001E:DC.W K00001
 450: L00019:DC.W K00001
 451:  DC.W K00001
 452:  DC.W K00001
 453:  DC.W K00001
 454:  DC.W K00001
 455:  DC.W K00001
 456:  DC.W K00001
 457:  DC.W K00001
 458: L00018:DC.W K00001
 459: L00027:DC.W K00001
 460:  DC.W K00001

       Lines 461 - 1097 omitted to conserve space. 

1098:  DC.W K00001
1099: L00000:DC.W K00001
1100:  DC.W K00001
1101:  END


     If you have the TEMPUS editor, you should exit AssemPro and 
load the disassembly file into one window, then load the 
reassembly file into another.  Then you can choose the underneath 
option to observe both files simultaneously.  Alternately, you 
can use a word processor such as 1st Word Plus; otherwise, you 
will have to work with the files individually, but I intend to 
proceed with the discussion as if you are able to view both files 
simultaneously.  Do not attempt to print either of the files on 
your printer yet.

Compressing the Reassembly Listing

     The particular example that I am using provides a reassembly 
listing that is easily reworked.  Other programs do not.  
Regardless of the its condition, the reassembly listing is 
usually the one that is altered so that it becomes a source 
program; however, the disassembly listing provides visual 
information that is sometimes obscured in the reassembly listing.  
As an example of the difference in information content of the 
listings, notice that virtually every number in the reassembly 
listing has been replaced by a constant identifier.  We must 
change every one of those back to the original numbers so that we 
can see what it is that the program does.  We can do that as we 
go along, or we can replace them all at once with the editor's 
replace function.  Initially, I prefer to make changes 
individually until I know it is safe to perform a mass replace.  
Notice also that most of the addresses in the reassembly listing 
have been converted to labels.  There is a list of the constant 
identifiers and their values at the beginning of the reassembly 
listing, but it is sometimes easier to refer to the disassembly 
listing to obtain those values.

     As the first instruction in the reassembly listing, you can 
see that the address of label L00000 is being loaded into 
register A7.  That means, of course, that L00000 is the AssemPro 
generated label for the stack.  If you run down the listing to 
L00000, you will see that it is the last label in the program, 
and you will see that it is preceded by a long list of DC.W 
K00001 pseudo ops.  If you now run up to the K00001 declaration 
at the top of the listing, you will see that K00001 is the 
identifier for the quantity 0.

     Now run back down to L00000, then carefully run back up to 
the next label, which is L00027.  All of the DC.W 0 pseudo ops 
between L00027 and L00000 are bss declarations in the original 
program.  Unfortunately, AssemPro does not differentiate between 
data and bss declarations when it generates the reassembly 
listing.  But that's ok; we can find out where we are by 
referring to the disassembly listing and the information in the 
basepage.  Now, what we don't know is how many of those DC.W 0 
declarations belong to L00027 and how many belong to L00000.  
That's ok too, because it doesn't matter; in the source program, 
the space reserved was only cosmetically separated.  The 
declarations in the original program would have had to have been 
similar to that shown below.

                    L00027: ds.l xxx
                            ds.l yyy
                    L00000: ds.l zzz

where the space reserved by xxx and that reserved by yyy would 
have been inseparable anyway.

     All that we need is the total space reserved in the original 
program.  That can be calculated thus: L00027 is at line number 
459 in the listing, and there is a DC.W 0 declared there; L00000 
is at line number 1099 in the listing, and there is a DC.W 0 
declared there also, but we don't count that one--we only want 
those declared from L00027 to L00000 (Refer to the model above.  
We desire the sum of xxx and yyy.).  Subtracting 459 from 1099 
yields 640 (that's declared words), which is 320 longwords.

     Since we don't know what portion of this declaration to 
allocate to each label, and since it doesn't matter anyway, we 
can just split the amount between them, and we can delete all of 
the DC.W K00001 declarations from L00027 to L00000.  And since we 
can determine that there are no other references to the label 
L00000 within the program simply by searching for that label, we 
can change the reference in the first instruction and the label 
itself to stack.  After the alteration, the declarations would 
appear as shown below.

                   L00027: ds.l 160          ds.l 160
                   stack:  ds.l   1

Notice that I use lower case letters to indicate items which have 
been altered.  Notice also that I have declared a single longword 
at the stack label, as is indicated in the reassembly listing, 
even though we know that in the original program ds.l 0 was used.  
That can always be changed later if to do so is desirable.  
Finally, notice that we have reduced the number of lines in the 
listing from 1101 to 462.

     If we had no hint about the output of the program, we could 
simply return to the top of the listing and begin to decipher 
instructions linearly.  But we are able to execute the program 
and obtain output in a file.  Furthermore, we know that the 
program is a desk accessory, so we know a great deal about the 
types of instructions within the text segment and something about 
the declarations in the data segment.  With all of this 
knowledge, and with the help of the ASCII characters that are 
present, we can begin to reconstruct the data segment of the 
program.  That activity will permit the most rapid reduction in 
listing size.

     As you run up the listing from L00027, past L0000A, to label 
L00023, notice that there are no labels at locations we might 
expect them to be if we refer to the original listing in chapter 
10.  That's because the labels zero, one, two, three and four 
were referenced indirectly within the program.  Their locations 
were stored in pointer array test_header, and the address of 
test_header was stored in an address register.  Without knowledge 
of the original listing, we would discover that as we work 
through the conversion.  Still, we can work with the data 
declarations and insert the labels as we discover their 
locations.

     Starting at line 170 of the listing and continuing through 
line 417, referring to the program's output and to an ASCII table 
when necessary, we reconstruct the data section as shown in the 
listing in figure 11.6.  We can assume that the carriage 
return/linefeed declared at line 170 is part of the declaration 
at line 171 because there is no null character between the two 
lines.  At line 188, you can see how the null character would be 
declared; there, note the ">0<>CR<" following the semicolon.  The 
>0< indicates the null character.  The $D for the carriage return 
follows the null character at that location.  The CR, LF and T 
mark the beginning of a new declaration.

Figure 11.6. Partially reconstructed data section.

 dc.b $D,$A,'TEST POINT 0: Before appl_init',$D,$A,$D,$A,0
 dc.b $D,$A,'TEST POINT 1: After appl_init, before menu_register',$D,$A,$D,$A,0
 dc.b $D,$A,'TEST POINT 2: After menu_register, before evnt_mesag',$D,$A,$D,$A,0
 dc.b $D,$A,'TEST POINT 3: In message handler, before evnt_mesag',$D,$A,$D,$A,0
 dc.b $D,$A,'TEST POINT 4: In message handler second time',$D,$A,$D,$A,0

L0000A:   dc.b '0123456789ABCDEF' 
L00021+1: dc.b $D,$A,0 
 dc.b '                                AES ARRAYS',$D,$A,0
  
L00025+1:
 dc.b 'CONTROL  GLOBAL  INT_IN  INT_OUT  ADDR_IN  ADDR_OUT',$D,$A,0
L00026+1
 dc.b '_______  ______  ______  _______  _______  ________',$D,$A,0  
L00024+1:
 dc.b '            ',$D,$A,0
 dc.b '  ',$D,$A,0
L00015+1:
 dc.b '  Accessory Arrays ',0
L00002+1:
 dc.b 'E:\PRG_8\PRG_8AR.DAT',0

  
     As we reconstruct the data segment of the program, we use 
dc.b pseudo ops to declare strings, not the dc.w pseudo ops.  At 
line 309, note that the character F, which is part of the 
declaration above L00021, has been combined with the declaration 
at L00021.  This occurred because a null character was not placed 
after the hex_table string in the original program (Remember the 
assumption made in the paragraph above--it could be wrong.).  
This fact would become evident as we work through the reassembly 
listing because there are no references to L00021 within the 
listing, but L00021+1 is referenced.  You can verify this by 
searching through the listing for references to L00021.  An 
explanation is provided in the last paragraph on page 105 of the 
AssemPro manual.  The Label+1  phenomenon occurs whenever 
AssemPro must create a label at an odd address.  We can handle 
this by changing L00021 to L00021+1 at line 309 and by placing 
the F character in the string to which it belongs.

     Concerning the hex string declaration, the pseudo op at line 
301 is L0000A:DC.W $30 ;">0<0".  This declares a null character 
followed by a 0.  If we take the time to search for references to 
L0000A within the listing, we find that there are none.  But 
L0000A+1 is referenced at line 37.  There, the address of the 
table is loaded into A3.  We can easily infer that an adjustment 
is in order.  We can change the L0000A+1 to L0000A and declare 
the table as it should be.

     As it is with L00021, there is no direct reference to 
L00025, but L00025+1 is referenced, so we handle line 333 as we 
did line 309.  L00026 at line 361 is changed to L00026+1.  At 
line 389, L00024 is changed to L00024+1; and note that the 
constant K00029 at that location is just $20, the ASCII code for 
a space.  Note also that a null character precedes the space.  At 
line 396 two spaces are declared, following the null on line 395, 
and preceding the null on line 396.  The space following the null 
on line 396 is part of the L00015+1 declaration "  Accessory 
Arrays ".  L00002 at line 407 must be changed to L00002+1, and we 
readily observe a file name and directory path at that location.

     We can now begin converting statements from the top of the 
listing, using the disassembly listing and the list of constant 
identifiers to fill in numeric values, and referring to the 
appropriate reference books to identify functions.  The most 
prominent candidates for immediate conversion are the trap 
numbers.  At each TRAP word, simply exchange the constant 
identifier for the constant itself.  Then, at each location of a 
trap invocation, replace all constant identifiers with constants.  
As each function is identified, replace the appropriate label 
references within the invocation and at their site if possible.  
Above each function invocation, place a suitable label to 
describe the function.  After doing this for the first two 
functions, they would appear as shown in figure 11.7.

  Figure 11.7. First two functions of the listing.

              create_file:
               lea        stack(pc), sp
               move.w     #0, -(sp)
               pea        filename(pc)
               move.w     #$3C, -(sp)
               trap       #1
               addq.l     #8, sp
               move.w     d0, file_handle

              redirect_output:
               move.w     file_handle(pc), -(sp)
               move.w     #1, -(sp)
               move.w     #$46, -(sp)
               trap       #1
               addq.l     #6, sp
  
       
     As the alterations shown in figure 11.7 are made, L00002+1 
must be changed to filename at the label's site, as must L00005 
be changed to file_handle.  As we are making the file_handle 
exchange for L00005, we should notice that the program can be 
improved by pushing d0 onto the stack in the redirect_output 
function instead of pushing the variable file_handle, as was done 
in the original program; but, at this time, we should simply 
place a note in the listing to which attention can be directed 
later.  We want to suppress improvements until we have confirmed 
the accuracy of the machine language to assembly language 
conversion.  Don't forget to declare the ds.w 1 at the 
file_handle label site.

     As the first two functions are being transformed, the labels 
that are replaced there and at the label sites must also be 
replaced at all referencing locations.  That activity would lead 
to the transformation of the two functions that exist at the 
L0001F label site.  Those two transformed functions are shown in 
figure 11.8.  Don't forget to alter all references to L0001F when 
it is changed to close_file.

Figure 11.8. Two more functions disclosed.

           beq.s      close_file
           BRA.S L0001C

          close_file:
           move.w     file_handle(pc), -(sp)
           move.w     #$3E, -(sp)
           trap       #1
           addq.l     #4, sp

          _redirect_output:
           move.w     #1, -(sp)
           move.w     file_handle(pc), -(sp)
           move.w     #$46, -(sp)
           trap       #1
           addq.l     #6, sp

     The two program statements following the functions shown in 
figure 11.8 will lead us to a trap #2 subroutine.  The first 
statement stores $C8, the AES call number in register D3; the 
second statement stores the address of a label in A5.  Searching 
for all references to A5, eventually leads us to L00011 at which 
the trap #2 invocation resides.  The very structure of the 
subroutine identifies it as the AES call.  Thus we are able to 
identify L00008 as the label for the aes_pb.  And, when all of 
the constant identifiers residing just below the BSR L0000B 
statement are replaced by the respective constants; and after 
observing the BSR L00011 statement just below those replaced 
constants, we can be sure that the address of the label being 
loaded into register A4 must be that of the array control.  
Therefore, each BSR L00011 can be changed to bsr aes, each 
reference to L00008 can be changed to a reference to aes_pb and 
each reference to L00009 can be changed to a reference to 
control.  Control can be declared as a five word array thus: ds.w 
5.

     At this point, we are unable to clearly identify references 
to the other five AES structures within the reassembly listing; 
but we do know the order in which their addresses must be stored 
in the aes_pb structure; therefore, using the disassembly listing 
as a guide, we can obtain the address of aes_pb as that which is 
being loaded into A5 at line 16, and at that location we can 
obtain the addresses of the other structures.  At those addresses 
we will be able to determine both the amount of space reserved 
for each array and the relative positions of those declarations 
within the program.  We then possess the required information to 
declare the structures within the reassembly listing.  See figure 
11.9, which shows the relevant parts of the disassembly listing.  
At address $B22D8, we can see the disassembly listing address of 
each of the structures in question.

Figure 11.9. Relevant portions of the disassembly 
listing.

0B211A 363C00C8             MOVE.W #$C8,D3

0B211E 4BFA01B8             LEA $B22D8(PC),A5

0B2122 49FA03D0             LEA $B24F4(PC),A4

0B22D6 4E75                 RTS

0B22D8 000B                 DC.W $B  
0B22DA 24F4000B             MOVE.L $B(A4,D0.W),(A2)+
0B22DE 24FE                 MOVE.L SR,(A2)+
0B22E0 000B                 DC.W $B  
0B22E2 2508                 MOVE.L A0,-(A2)
0B22E4 000B                 DC.W $B  
0B22E6 2512                 MOVE.L (A2),-(A2)
0B22E8 000B                 DC.W $B  
0B22EA 251C                 MOVE.L (A4)+,-(A2)
0B22EC 000B                 DC.W $B  
0B22EE 2526                 MOVE.L -(A6),-(A2)

0B22F0 000B                 DC.W $B  
0B22F2 2304                 MOVE.L D4,-(A1)
0B22F4 000B                 DC.W $B  
0B22F6 2329000B             MOVE.L $B(A1),-(A1)
0B22FA 2363000B             MOVE.L -(A3),$B(A1)
0B22FE 239E000B             MOVE.L (A6)+,$B(A1,D0.W)
0B2302 23D80D0A5445         MOVE.L (A0)+,$A5445

 Section omitted as unnecessary.

0B24F4 00000000             ORI.B #0,D0
0B24F8 00000000             ORI.B #0,D0
0B24FC 00000000             ORI.B #0,D0
0B2500 00000000             ORI.B #0,D0
0B2504 00000000             ORI.B #0,D0
0B2508 00000000             ORI.B #0,D0
0B250C 00000000             ORI.B #0,D0
0B2510 00000000             ORI.B #0,D0
0B2514 00000000             ORI.B #0,D0
0B2518 00000000             ORI.B #0,D0
0B251C 00000000             ORI.B #0,D0
0B2520 00000000             ORI.B #0,D0
0B2524 00000000             ORI.B #0,D0
0B2528 00000000             ORI.B #0,D0
0B252C 00000000             ORI.B #0,D0

0B2530 00000000             ORI.B #0,D0
0B2534 00000000             ORI.B #0,D0
0B2538 00000000             ORI.B #0,D0
0B253C 00000000             ORI.B #0,D0
0B2540 00000000             ORI.B #0,D0
0B2544 00000000             ORI.B #0,D0
0B2548 00000000             ORI.B #0,D0


     Using the information in figure 11.9 we easily confirm that 
L00013 marks the declaration of the array global; and that 
L00014, L00017 and L00016 mark the declarations for int_in, 
int_out and addr_in.  Notice that no label for addr_out appears 
in the reassembly listing.  That's because the other structures 
were directly referenced within the program, but addr_out was 
not.  As the labels for the referenced structures are altered, 
don't forget to change the label identifiers in the instructions 
which reference them.  From figure 11.1, the image of a portion 
of the program's basepage, we can obtain the information needed 
to mark the data and bss seqments of the program.  But that 
information is also pretty obvious from the layout of the 
reassembly and disassembly listings.  Don't forget that the align 
statement is needed after those dc.b declarations.  With the 
other AES structures identified, we are able to seek out the 
other AES function invocations, and with a knowledge of the input 
requirements for those functions and their returns, we are able 
to identify the location of the menu text string, the message 
array and the variable menu_id.

     From the top of the listing again, the BSR L0000B 
instruction sends us to the statement which loads L00021+1 into 
A0.  The BSR L00022 statement just below that sends us to a trap 
#1 invocation.  Replacing the constant identifier there, K00031, 
with 9 readily identifies the function as GEMDOS c_conws, the 
print line function, and thereby, we realize that the contents of 
A0 must be the address of a string.  We have, of course, already 
noted that the string declared at L00021+1 is a carriage 
return/linefeed combination; we can now choose to replace 
references to L00021+1 as references to the label newline, and 
references to L00022 as references to print_line.

     The five instructions below the branch to the print_line 
subroutine accomplish the following:

     1. An address is loaded into A0.

     2. A value is stored in D0; then the contents of D0 are 
        multiplied by 4.

     3. D0 is used as an index register in an address register 
        indirect with index instruction to load a new address 
        into A0.

     4. The print_line subroutine is invoked to print a string.

     We conclude that L00023, the label identifying the address 
which is loaded into A0 in item 1, must be that of a pointer 
array that contains the addresses of the strings that are to be 
processed by the five instructions.  Referring to the disassembly 
listing, where we see that the address loaded into A0 is $B22F0, 
then by observing the data stored at that address, we confirm 
that such is the case.

     Figure 11.10 contains a section of the disassembly listing 
that is relevant to the identification of each address stored in 
the pointer array, and just enough of the beginning of each 
string.  You could easily confirm that the strings stored at 
those locations match those of the reassembly listing simply by 
converting each of the ASCII codes in the disassembly listing to 
characters.

Figure 11.10. The section of the disassembly listing 
containing the addresses referenced in the pointer 
array at $B22F0.

0B2302 23D80D0A5445         MOVE.L (A0)+,$A5445
0B2308 5354                 SUBQ.W #1,(A4)

0B2328 000D                 DC.W $D  
0B232A 0A544553             EORI.W #$4553,(A4)

0B2362 000D                 DC.W $D  
0B2364 0A544553             EORI.W #$4553,(A4)

0B2392 745F                 MOVEQ #$5F,D2
0B2394 6D65                 BLT.S $B23FB

0B23D6 0A000D0A             EORI.B #$A,D0
0B23DA 5445                 ADDQ.W #2,D5


     We need not be concerned with the actual names used for the 
labels of the strings; we need only realize that we must place 
labels at their declarations and store those labels in the 
pointer array in place of the addresses that are present in the 
reassembly listing.  Let us chose to use "string_zero" for the 
first, to match the "TEST POINT 0" reference within the string 
itself, and continue with the rest of them through "string_four".  
Remember that the pseudo op for the pointer array declaration at 
L00023 must be dc.l, for two reasons.  The first is that 32-bit 
addresses are being stored in the array; the second is that the 
run time addresses would not be stored if a ds pseudo op were 
used.

     Still within the same subroutine, after the five 
instructions which lead us to the pointer array, there are a 
series of loads into A0 followed by branches to the print_line 
subroutine.  The labels referenced in that area are those that we 
left with the "+1" excess baggage.  We can now alter those labels 
and the references to them to L00024, L00025 and L00026.  In 
addition we can replace the two constant identifiers, K00001 and 
K0000E by the actual values that are stored in registers D7 and 
D6.  At the conclusion of that activity, we will have arrived at 
label L00030.

     At this point, it would be advantageous to exchange each of 
the constant identifiers remaining in the subroutine for the 
actual constants.  Simultaneously, we can convert upper case 
statements which require no alterations to lower case as an 
indication that we need not be concerned about the format of 
those statements.  Figure 11.11 shows the reassembly listing at 
its current stage of reconstruction.

Figure 11.11.  The partially reconstructed reassembly 
listing.

K00001=0    K00003=$3C  K00004=1    K00006=$46  K00007=$C8  K0000C=$A
K0000D=2    K0000E=4    K0000F=6    K00010=8    K00012=$23  K0001A=$17
K0001B=$28  K0001D=5    K00020=$3E  K00028=$B   K00029=$20  K0002B=$F
K0002C=$3A  K0002D=3    K00031=9

create_file:
 lea        stack(pc), sp
 move.w     #0, -(sp)
 pea        filename(pc)
 move.w     #$3C, -(sp)
 trap       #1
 addq.l     #8, sp
 move.w     d0, file_handle

redirect_output:
 move.w     file_handle(pc), -(sp) ; CAN USE D0 FOR IMPROVEMENT.
 move.w     #1, -(sp)
 move.w     #$46, -(sp)
 trap       #1
 addq.l     #6, sp

 move.w     #$C8, d3
 lea        aes_pb(pc), a5
 lea        control(pc)
 lea        L0000A(PC), a3
 BSR L0000B

initialize_application:
 move.w     #$A, (a4)
 move.w     #0, 2(a4)
 move.w     #1, 4(a4)
 move.w     #0, 6(a4)
 move.w     #0, 8(a4)
 bsr        aes
 BSR L0000B

menu_register:
 move.w     #$23, (a4)
 move.w     #1, 2(a4)
 move.w     #1, 4(a4)
 move.w     #1, 6(a4)
 move.w     #0, 8(a4)
 lea        global(pc), a0
 move.w     4(a0), int_in
 move.l     #menu_text, addr_in
 bsr        aes
 move.w     int_out(pc), menu_id
 BSR L0000B

 move.l     #message, addr_in
evnt_mesag:
 move.w     #$17, (a4)
 move.w     #0, 2(a4)
 move.w     #1, 4(a4)
 move.w     #1, 6(a4)
 move.w     #0, 8(a4)
 bsr        aes
 lea        message(pc), a0
 cmpi.w     #$28, (a0)
 bne.s      evnt_mesag
 move.w     8(a0), d0
 cmp.w      menu_id(pc), d0
 bne.s      evnt_mesag
 cmpi.w     #5, L0001E
 beq.s      evnt_mesag
 BSR L0000B

 cmpi.w     #5, L0001E
 beq.s      close_file
 bra.s      evnt_mesag

close_file:
 move.w     file_handle(pc), -(sp)
 move.w     #$3E, -(sp)
 trap       #1
 addq.l     #4, sp

_redirect_output:
 move.w     #1, -(sp)
 move.w     file_handle(pc), -(sp)
 move.w     #$46, -(sp)
 trap       #1
 addq.l     #6, sp
 bra.s      evnt_mesag

L0000B:
 lea newline(pc), a0
 bsr        print_line
 LEA L00023(PC),A0
 MOVE.W L0001E(PC),D0
 lsl.w      #2, d0               ; Multiply by 4.
 movea.l    0(a0,d0.w), a0
 bsr        print_line
 lea        L00024(pc), a0
 bsr        print_line
 lea        L00025(pc), a0
 bsr        print_line
 lea        L00024(pc), a0
 bsr        print_line
 lea        L00026(pc), a0
 bsr        print_line
 moveq      #0, d7
 moveq      #4, d6
L00030:
 lea        L00027(pc), a0
 movea.l    a5, a6
 move.w     #5, d5
 move.w     #11, d0
L0002A:
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 dbra       d0, L0002A
L0002F:
 move.w     d7, d0
 andi.b     #$F, d0
 move.b     0(a3,d0.w), d0
 move.b     d0, (a0)+
 move.b     #$3A, (a0)+          ; $3A = ASCII for colon.
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 move.b     d7, d0
 lsl.w      #1, d0
 movea.l    (a6)+, a1
 move.w     0(a1,d0.w), d0
 moveq      #3, d2
L0002E:
 rol.w      #4, d0
 move.b     d0, d1
 andi.b     #$F, d1
 ext.w      d1
 move.b     0(a3,d1.w), d1
 move.b     d1, (a0)+
 dbra       d2, L0002E
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 move.b     #$20, (a0)+
 dbra       d5, L0002F
 move.b     #0, (a0)
 lea        L00027(pc), a0
 bsr        print_line
 lea        newline(pc), a0
 bsr        print_line
 addi.w     #1, d7
 dbra       d6, L00030
 addi.w     #1, L0001E
 rts

aes:
 move.l     a5, d1
 move.w     d3, d0
 trap       #2
 rts

print_line:
 move.l     a0, -(sp)
 move.w     #9, -(sp)
 trap       #1
 addq.l     #6, sp
 rts

 data
aes_pb: dc.l  control,global,int_in,int_out,addr_in,addr_out
  
L00023:
        dc.l string_zero,string_one,string_two,string_three,string_four
string_zero:  
 dc.b $D,$A,'TEST POINT 0: Before appl_init',$D,$A,$D,$A,0
string_one:
 dc.b $D,$A,'TEST POINT 1: After appl_init, before menu_register',$D,$A,$D,$A,0
string_two:
 dc.b $D,$A,'TEST POINT 2: After menu_register, before evnt_mesag',$D,$A,$D,$A,0
string_three:
 dc.b $D,$A,'TEST POINT 3: In message handler, before evnt_mesag',$D,$A,$D,$A,0
string_four:
 dc.b $D,$A,'TEST POINT 4: In message handler second time',$D,$A,$D,$A,0

L0000A:   dc.b '0123456789ABCDEF' 
newline:  dc.b $D,$A,0
 
 dc.b '                                AES ARRAYS',$D,$A,0  ; Label is unknown.
  
L00025:
 dc.b 'CONTROL  GLOBAL  INT_IN  INT_OUT  ADDR_IN  ADDR_OUT',$D,$A,0
L00026:
 dc.b '_______  ______  ______  _______  _______  ________',$D,$A,0  
L00024:
 dc.b '            ',$D,$A,0
 dc.b '  ',$D,$A,0                   ; Label is unknown.
menu_text:
 dc.b '  Accessory Arrays ',0
filename:
 dc.b 'E:\PRG_8\PRG_8AR.DAT',0

 bss
 align

control:       ds.w   5
global:        ds.w   5
int_in:        ds.w   5
int_out:       ds.w   5
addr_in:       ds.w   5
addr_out:      ds.w   5

file_handle:   ds.w   1
L0001E:DC.W K00001
message:       ds.w   8
menu_id:       ds.w   1
L00027:        ds.l 160
               ds.l 160
stack:         ds.l   1
 end
  
  
     I would now like to draw your attention to two particular 
declarations within the listing.  I have marked them with the 
comment Label is unknown.  The first declaration is just below 
the newline label; the second is just above L00015+1.  In the 
original program, the label at the first declaration was 
"aes_header"; the label at the second was "spaces".  There is no 
reference to these labels in the reassembly listing because they 
were never referenced in the original program.  You can confirm 
the omission of the first just by looking at the program's 
output.  The header does not appear.  I had intended that it 
should, therefore, its omission is an error.  The second 
declaration should have been removed from the original program 
because I replaced the function that was to be performed with the 
"spaces" declaration with in-line code.

     You can be sure that you will observe similar errors and 
superfluous statements in other programs that you reconstruct.  
In fact, you can be sure that you will sometimes see superflous 
statements that have been deliberately inserted in a program to 
hinder a reconstruction of the source program.  Other ploys 
include self-modifying code and hardware devices which provide 
signals for the program.  Examples will be investigated later.

Concluding the Reconstruction

     We can choose to continue with the source program 
reconstruction by returning to the top of the program and resolve 
any further label references, or we can immerse ourselves in the 
subroutine which seems to accomplish most of the work in the 
program.  One activity that can be immediately identified is that 
which follows the evnt_mesag function invocation.  The 
comparisons performed there; comparing #$28 to message[0], and 
menu_id to message[4]; clearly marks this as the message handler 
algorithm; therefore, we can designate it as such.  Then, let us 
turn our attention to the program's major subroutine.

     The third instruction of the subroutine loads the address of 
the pointer array declared at L00023 into A0; the fourth moves 
the contents of the variable declared at L0001E into D0; the 
fifth multiplies the value of that variable by 4; and in the 
sixth instruction, D0 is used as an index register to load a new 
address into A0.  We already know that the pointer array contains 
the addresses of the strings declared just below the pointer 
array declaration.

     The series of instructions which setup D0 and A0 so that a 
selection from that group of strings depends on the value stored 
at L0001E tend to indicate that the value at that location is 
dynamic.  Indeed, if we search the reassembly listing for other 
references to L0001E, we see that the value stored there is 
compared to the value 5 in two instructions, and it is 
incremented as the last instruction in the subroutine.  Since the 
value stored at L0001E is used in an index register that 
determines the choice from a group of strings which identify 
themselves as TEST POINTS, we need little imagination to rename 
the variable test_number or some other name that is indicative of 
its function, and then to properly perform a bss declaration.  
Remember to alter all references to L0001E.  Figure 11.12 shows 
the reconstructed, but untested, listing.

Figure 11.12. Reconstructed source listing.

 ; PRG_8AR.ASM

 ; MAJOR NOTE:

 ;      THIS PROGRAM MAY NOT FUNCTION CORRECTLY IF TURBO ST IS INSTALLED.

 ;      This program has been reconstructed from PRG_8AR.ACC.

create_file:
 lea        stack(pc), sp
 move.w     #0, -(sp)
 pea        filename(pc)
 move.w     #$3C, -(sp)
 trap       #1
 addq.l     #8, sp
 move.w     d0, file_handle

redirect_output:
 move.w     file_handle(pc), -(sp) ; CAN USE D0 FOR IMPROVEMENT.
 move.w     #1, -(sp)
 move.w     #$46, -(sp)
 trap       #1
 addq.l     #6, sp

 move.w     #$C8, d3
 lea        aes_pb(pc), a5
 lea        control(pc), a4
 lea        L0000A(PC), a3
 BSR L0000B

initialize_application:
 move.w     #$A, (a4)
 move.w     #0, 2(a4)
 move.w     #1, 4(a4)
 move.w     #0, 6(a4)
 move.w     #0, 8(a4)
 bsr        aes
 BSR L0000B

menu_register:
 move.w     #$23, (a4)
 move.w     #1, 2(a4)
 move.w     #1, 4(a4)
 move.w     #1, 6(a4)
 move.w     #0, 8(a4)
 lea        global(pc), a0
 move.w     4(a0), int_in
 move.l     #menu_text, addr_in
 bsr        aes
 move.w     int_out(pc), menu_id
 BSR L0000B

 move.l     #message, addr_in
evnt_mesag:
 move.w     #$17, (a4)
 move.w     #0, 2(a4)
 move.w     #1, 4(a4)
 move.w     #1, 6(a4)
 move.w     #0, 8(a4)
 bsr        aes

message_handler:
 lea        message(pc), a0
 cmpi.w     #$28, (a0)
 bne.s      evnt_mesag
 move.w     8(a0), d0
 cmp.w      menu_id(pc), d0
 bne.s      evnt_mesag
 cmpi.w     #5, test_number
 beq.s      evnt_mesag
 BSR L0000B
 cmpi.w     #5, test_number
 beq.s      close_file
 bra.s      evnt_mesag

close_file:
 move.w     file_handle(pc), -(sp)
 move.w     #$3E, -(sp)
 trap       #1
 addq.l     #4, sp

_redirect_output:
 move.w     #1, -(sp)
 move.w     file_handle(pc), -(sp)
 move.w     #$46, -(sp)
 trap       #1
 addq.l     #6, sp
 bra.s      evnt_mesag

L0000B:
 lea newline(pc), a0
 bsr        print_line
 LEA L00023(PC),A0
 move.w     test_number(pc), d0
 lsl.w      #2, d0               ; Multiply by 4.
 movea.l    0(a0,d0.w), a0
 bsr        print_line
 lea        L00024(pc), a0
 bsr        print_line
 lea        L00025(pc), a0
 bsr        print_line
 lea        L00024(pc), a0
 bsr        print_line
 lea        L00026(pc), a0
 bsr        print_line
 moveq      #0, d7
 moveq      #4, d6
L00030:
 lea        L00027(pc), a0
 movea.l    a5, a6
 move.w     #5, d5
 move.w     #11, d0
L0002A:
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 dbra       d0, L0002A
L0002F:
 move.w     d7, d0
 andi.b     #$F, d0
 move.b     0(a3,d0.w), d0
 move.b     d0, (a0)+
 move.b     #$3A, (a0)+          ; $3A = ASCII for colon.
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 move.b     d7, d0
 lsl.w      #1, d0
 movea.l    (a6)+, a1
 move.w     0(a1,d0.w), d0
 moveq      #3, d2
L0002E:
 rol.w      #4, d0
 move.b     d0, d1
 andi.b     #$F, d1
 ext.w      d1
 move.b     0(a3,d1.w), d1
 move.b     d1, (a0)+
 dbra       d2, L0002E
 move.b     #$20, (a0)+          ; $20 = ASCII for space.
 move.b     #$20, (a0)+
 dbra       d5, L0002F
 move.b     #0, (a0)
 lea        L00027(pc), a0
 bsr        print_line
 lea        newline(pc), a0
 bsr        print_line
 addi.w     #1, d7
 dbra       d6, L00030
 addi.w     #1, test_number
 rts

aes:
 move.l     a5, d1
 move.w     d3, d0
 trap       #2
 rts

print_line:
 move.l     a0, -(sp)
 move.w     #9, -(sp)
 trap       #1
 addq.l     #6, sp
 rts

 data
aes_pb: dc.l  control,global,int_in,int_out,addr_in,addr_out
  
L00023:
        dc.l string_zero,string_one,string_two,string_three,string_four
string_zero:  
 dc.b $D,$A,'TEST POINT 0: Before appl_init',$D,$A,$D,$A,0
string_one:
 dc.b $D,$A,'TEST POINT 1: After appl_init, before menu_register',$D,$A,$D,$A,0
string_two:
 dc.b $D,$A,'TEST POINT 2: After menu_register, before evnt_mesag',$D,$A,$D,$A,0
string_three:
 dc.b $D,$A,'TEST POINT 3: In message handler, before evnt_mesag',$D,$A,$D,$A,0
string_four:
 dc.b $D,$A,'TEST POINT 4: In message handler second time',$D,$A,$D,$A,0

L0000A:   dc.b '0123456789ABCDEF' 
newline:  dc.b $D,$A,0 
 dc.b '                                AES ARRAYS',$D,$A,0
  
L00025:
 dc.b 'CONTROL  GLOBAL  INT_IN  INT_OUT  ADDR_IN  ADDR_OUT',$D,$A,0
L00026:
 dc.b '_______  ______  ______  _______  _______  ________',$D,$A,0  
L00024:
 dc.b '            ',0
 dc.b '  ',$D,$A,0
menu_text:
 dc.b '  Accessory Arrays ',0
filename:
 dc.b 'E:\PRG_8\PRG_8AR.DAT',0

 bss
 align

control:       ds.w   5
global:        ds.w   5
int_in:        ds.w   5
int_out:       ds.w   5
addr_in:       ds.w   5
addr_out:      ds.w   5

file_handle:   ds.w   1
test_number:   ds.w   1
message:       ds.w   8
menu_id:       ds.w   1
L00027:        ds.l 160
               ds.l 160
stack:         ds.l   1
 end

  
     Actually, I have assembled the program and tested it.  
That's why I know that it will not function correctly if my 
version of TURBO ST is installed.  And there are other problems.  
That's why I was forced to write a program to assist with the 
corrections that are necessary to make the reconstructed listing 
produce object code that is identical to the object code from 
which we have generated the source.

