AES-Funktionen von MagiC 3
--------------------------

Andreas Kromke
27.4.95

- wind_create blendet bei aktivierter KompatibilitÑt keine Bits mehr aus.

- WM_BACKDROPPED (Mag!X) wird nicht mehr verschickt, stattdessen wird
  WM_BOTTOMED (AES 4.1) verschickt.
  Alle Programme, die Fenster mit explizitem Backdrop-Element nach Mag!X-
  Konvention erstellen, mÅssen leider fÅr MagiC 3.0 geÑndert werden bzw.
  nicht geÑndert werden, wenn sie das nicht vorhandene MultiTOS unterstÅtzen.

- AES beherrscht das Ikonifizieren von Fenstern. Folgendes ist zu beachten:
  - wind_get/set liefern Fehlercodes, wenn versucht wird, ikonisierte Fenster
    nochmal zu ikonisieren usw.
  - Der Button liegt rechts, also hat man im Extremfall 3 Buttons am rechten
    Fensterrand. Vielleicht wÑre es sinnvoll, den Backdrop- Button nach links
    zu verbannen ?
  - Der Algorithmus zum Festlegen der Position des ikonifizierten Fensters
    funktioniert anders als bei MultiTOS. MagiC durchsucht die aktuellen
    Positionen der bereits ikonisierten Fenster und setzt das neue Fenster
    auf einen freien Platz. Ein Platz ist nur dann frei, wenn der Schnitt
    mit der neuen Position leer ist.
  - Das Programm Adresse 1.81 hat Probleme und zeichnet das Icon versetzt
    auf, vielleicht wegen der dicken MultiTOS- Fensterrahmen.
  - INTRFACE und GEMVIEW merken nicht, daû das System Ikonisierung
    unterstÅtzt. Wird kein appl_getinfo gemacht ?

- AES kennt einen neuen Objekttyp, den Gruppenrahmen. Erzeugt wird er durch
  Setzen von WHITEBAK sowie durch Setzen des Highbytes von ob_state auf -2.
  Zusammenfassend gibt es jetzt folgende Sondertypen:

  G_STRING:
  ---------
  WHITEBAK=0:  TOS-String, nicht unterstrichen
  WHITEBAK=1,Highbyte!=-1: String, unterstrichen
                           (Highbyte&0xf) ist Unterstreichpos.
  WHITEBAK=1,Highbyte==-1: String, komplett unterstrichen

  G_BUTTON:
  ---------
  WHITEBAK=0:  TOS-Buttons, nicht unterstrichen
  WHITEBAK=1,Bit15=0:    TOS-Buttons,unterstrichen
                           (Highbyte&0xf) ist Unterstreichpos.
  WHITEBAK=1,Bit15=1:    Sonderbuttons (rund oder Kreuzchen)
   Highbyte=-2:     Gruppenrahmen
   Highbyte=-1:     Sonderbutton, nicht unterstrichen
   Highbyte!=-1/-2  Sonderbutton, unterstrichen
                           (Highbyte&0xf) ist Unterstreichpos.

- AES unterstÅtzt jetzt 3D-Objekte nach AES 4.0-Norm. Die Typen "Background",
  "Activator" und "Indicator" werden verarbeitet.
  Unterschiede zu AES 4.0:

  - In TOS 4.0 kann man per objc_sysvar das Verhalten von "Indicator" und
    "Activator" sowie die Farben beeinflussen, in MagiC kann man die Daten
    zwar abrufen, aber nicht verÑndern. "Activator" werden bei SELECTED immer
    eingedrÅckt, "Indicator" oder "Background" werden verfÑrbt.
  - MagiC UNTERSTöTZT DEFINITIV KEINE 3D-EFFEKTE, WENN WENIGER ALS 16 FARBEN
    GLEICHZEITIG MôGLICH SIND. DIE ENTSPRECHENDEN OBJEKTE SEHEN DANN EINFACH
    "FLACH" AUS.
    appl_getinfo() liefert bei weniger als 16 Farben oder bei explizit
    deaktivierten 3D-Objekten die Information: Keine 3D-Objekte vorhanden.
  - FÅr alle Objekttypen kînnen 3D-Effekte angefordert werden. D.h. auch
    fÅr Texteingabefelder, öberschriften, Gruppenrahmen usw.
  - 3D-Objekte bekommen keinen zusÑtzlichen Rahmen und Ñndern sich daher
    nicht in der Grîûe. Je nach Rahmenbreite stehen sie weiter heraus und
    haben ggf. auch noch einen zusÑtzlichen Rand und Schatten.
    öberschriften sollten statt bisher 1+2 die Hîhe 1+3 haben, damit es
    ordentlich aussieht.
  - Bei 3D-Objekte vom Typ G_USERDEF werden die 3D-Effekte nicht vom System
    gezeichnet, wie dies bei MTOS der Fall ist (?). Dies darf auch nicht sein,
    weil bei MagiC die 3D-RÑnder innerhalb des Objekts liegen und dieses
    nicht Åberschrieben werden darf.
  - Damit die FensterrÑnder nicht verbreitert zu werden brauchten, werden
    jetzt innerhalb von Buttons oder Boxchars die Zeichen auch dann
    ausgegeben, wenn die Box zu klein ist. Das Problem ergab sich bei den
    Fensterelementen, die die Hîhe (text+3) haben, aber eigentlich mindestens
    (text+4) benîtigen.
  - Das Namensfeld der Fenster ist nicht 3D. Dies kann mit der nÑchsten
    Version des Programms "wincolor.cpx" von Martin Osieka aber beeinfluût
    werden. Dann lÑût sich fÅr jedes Fensterelement angeben, ob es 3D sein
    soll oder nicht.
  - Die "SchmuckrÑnder" fÅr Dialogboxen werden genau dann erzeugt, wenn ein
    Rahmen von 2 innen und OUTLINED angewÑhlt wurde.

- Die gesamte 3D-UnterstÅtzung kann abgeschaltet werden, indem das Bit 1 des
  Flags in magx.inf gesetzt wird (Bit 0 ist fÅr die Position des Logos
  zustÑndig. Bei laufendem Betrieb kann dann immer noch per objc_sysvar()
  umgeschaltet werden.
- AES unterstÅtzt jetzt objc_sysvar mit folgenden Unterfunktionen. Die
  Parameter:

     #define LK3DIND      1
     #define LK3DACT      2
     #define INDBUTCOL    3
     #define ACTBUTCOL    4
     #define BACKGRCOL    5
     #define AD3DVALUE    6
     #define MX_ENABLE3D  10

  Mit MX_ENABLE3D kann man in MagiC komplett und global alle 3D-Objekte
  deaktivieren, d.h. auch Fensterrahmen, Dateiauswahl, Fensterrand usw.
  Ferner kann man abfragen, ob z.Zt. 3D unterstÅtzt wird. Der Versuch, 3D
  zu aktivieren, wenn weniger als 16 Farben zur VerfÅgung stehen, fÅhrt zu
  einer Fehlermeldung durch objc_sysvar().
  MagiC UNTERSTöTZT DEFINITIV KEINE 3D-EFFEKTE, WENN WENIGER ALS 16 FARBEN
  GLEICHZEITIG MôGLICH SIND. DIE ENTSPRECHENDEN OBJEKTE SEHEN DANN EINFACH
  "FLACH" AUS.
  AD3DVALUE liefert immer 0, weil MagiC die Objektgrîûen nicht antastet.
  Als Farben werden immer 8 (hellgrau) und 9 (dunkelgrau) verwendet.
- objc_sysvar liefert Fehlercode, wenn keine 3D-Effekte aktiviert sind.

- Auch Objekte ohne Rand werden im Fall 3D in grau statt weiû gezeichnet

- F_TEXT und F_BOXTEXT haben nur dann den eingedrÅckten Rand um das Eingabe-
  feld, wenn ein Rand von mindestens 2 Pixeln auûerhalb angegeben ist. Damit
  stimmen die Objektausmaûe wieder.
- Im Fall G_FBOXTEXT und 3D-Modus "Activator" wird eine Art Button wie unter
  MTOS gezeichnet, der Eingabebereich wird dabei nicht hervorgehoben.

- AES schickt beim (De-)Ikonifizieren explizit eine Redraw-Nachricht, auch
  wenn sich die Grîûe nicht geÑndert hat.

- Der "Crossbutton" hat immer eine ungerade Hîhe, damit im Kreuzungspunkt
  der Linien kein dicker Punkt entsteht.

- Nicht benîtigte FensterrÑnder (links oder unten) werden wie bei AES 4.x
  weggelassen. Derartige Fenster sehen zwar bescheiden aus, aber bringen
  immerhin ein paar Pixel mehr an nutzbarer FlÑche.

- Bit 2 des Flags von MAGX.INF schaltet den expliziten Backdrop-Button aus
  und bewirkt, daû ein kurzer Klick auf das Namensfeld eines aktiven Fensters
  ein Backdrop bewirkt. Das ist fast die Vorgehensweise von AES 4.x, bis auf
  die Tatsache, daû MagiC nach wie vor den Backdrop selbst erledigt, wenn die
  Applikation dazu selbst nicht in der Lage ist.

- Bei 3D-Dialogen wird eine passende Flugecke gezeichnet.

- Das ARGV-Verfahren wird unterstÅtzt. Hiermit kînnen beliebig lange
  Kommandozeilen Åbergeben werden, die auûerdem Leerstellen und alle
  mîglichen anderen Zeichen enthalten dÅrfen.
  Als LÑngenbyte in der Kommandozeile der Basepage wird dabei $7f
  eingetragen, die Argumente (einschlieûlich argv[0] als Kommando, d.h. als
  Programmdatei) werden im Environment Åbergeben. Das Environment enthÑlt
  dazu folgende Variablen hinter allen anderen:

     "ARGV=irgendwas\0"
     "arg0\0"
     "arg1\0"
     ...
     "argn\0\0"

  Die Argumente folgen also der Variablen ARGV, sind durch Nullbytes getrennt
  und durch zwei Nullbytes abgeschlossen.
  Beispielprogramme zur Auswertung von ARGV gibt es von Atari. Ob es
  Åberhaupt ein Programm gibt, das ARGV auswertet, weiû ich nicht und
  bezweifle ich auch.

  MultiTOS implementiert das Verfahren im AES. Man muû den Parameter iscr,
  der in MagiC anderweitig belegt ist und "isover" heiût, auf 1 setzen, dann
  erstellt MultiTOS das ARGV im Environment.

  MagiC implementiert ARGV auf einem tieferen Level. Das ARGV- Verfahren wird
  auf drei Arten bereits von Pexec unterstÅtzt:

     1. Ist das LÑngenbyte der Kommandozeile $7f, geht Pexec davon aus, daû
        das aufrufende Programm ARGV unterstÅtzt und das Environment
        entsprechend manipuliert ist.
        Pexec Ñndert daher nicht das Environment.
     2. Ist das LÑngenbyte $fe, erwartet MagiC direkt dahinter die
        Zeichenkette "ARGV=", gefolgt von einem Nullbyte und von einer durch
        zwei Nullbytes abgeschlossenen Liste von Parametern. Durch öbergaben
        von "ARGV=NULL..." usw. kann man auch das erweiterte ARGV-Verfahren
        verwenden, das die öbergabe von leeren Parametern ermîglicht.
        Pexec lîscht ein evntl. vorhandenes ARGV und trÑgt das neue ins
        Environment ein. Die Kommandozeile besteht nur aus $7f als Indikator,
        daû die Parameter im Environment liegen.
        Das Verfahren ist geeignet, wenn das aufgerufene Programm mit
        Sicherheit das ARGV-Verfahren beherrscht.
     3. Ist das LÑngenbyte $ff, erwartet MagiC direkt dahinter eine durch
        Leerstellen getrennte und durch ein Nullbyte abgeschlossene Liste von
        Parametern (wie i.a. als Kommandozeile Åbergeben wird).
        Pexec lîscht ein evntl. vorhandenes ARGV, erstellt aus der
        Kommandozeile eine Argumentliste und trÑgt diese als ARGV ins
        Environment ein. Als argv[0] wird der Programmdatei-Pfad genommen,
        der Pexec Åbergeben wurde. Ist dieser Pfad ungÅltig, gibt es MÅll,
        deshalb sollte man auch bei Modus 5 (Basepage erstellen) einen
        sinnvollen Programmnamen Åbergeben. Bei Modus 7 heiût argv[0] dann
        einfach "NONAME", weil hier kein Name Åbergeben wird.
        Die Kommandozeile hat als LÑngenbyte $7f als Indikator fÅr das
        Vorhandensein von ARGV. Ist die LÑnge der Kommandozeile < 127, wird
        diese auûerdem in die Basepage kopiert, ansonsten besteht die
        Kommandozeile nur aus $7f.
        Das Verfahren ist geeignet, wenn das aufrufende Programm nicht sicher
        ist, daû das aufgerufene Programm ARGV versteht.

  Warum lege ich nicht grundsÑtzlich immer ARGV an ? Klar! Weil es nÑmlich
  garantiert Programme gibt, die Åber ARGV stolpern. Nehmen wir nÑmlich mal
  an, ein Parameter laute "VAR=wert", dann wird jedes Programm
  dies fÅr eine Environment-Variable halten. Werden neue Variablen angehÑngt,
  etwa durch einen Kommandoprozessor, sind diese sofort verloren, wenn sie
  hinter "ARGV=" liegen.
- ARGV- Verfahren geÑndert. Die Zeichenkette "ARGV=blubber" muû jetzt
  Åbergeben werden, damit ist die öbergabe von leeren Parametern mîglich.

- shel_write wurde folgendermaûen erweitert:

 1. Wird als "tail" eine Zeichenkette Åbergeben, die mit $ff beginnt und mit
    '\0' abgeschlossen ist, wird die tatsÑchliche LÑnge der Kommandozeile vom
    AES bestimmt und in ganzer LÑnge ans DOS weitergereicht. Das DOS
    konstruiert hieraus einen ARGV-Parameter im Environment (s.o.).
    Ist die Kommandozeile kÅrzer als 127 Bytes, wird sie Åber Basepage und
    shel_read Åbergeben, ansonsten besteht sie nur aus dem Byte $7f.
 2. Wird als tail eine Zeichenkette Åbergeben, die mit $fe beginnt, erwartet
    das AES dahinter die Zeichenkette "ARGV=irgendwas" und eine durch '\0'
    getrennte und durch "\0\0" abgeschlossene Liste von Parametern.
    Diese wird vollstÑndig dem DOS Åbergeben, das daraus einen ARGV-Parameter
    konstruiert (s.o.).
    Ist die Kommandozeile kÅrzer als 127 Bytes, wird sie Åber Basepage und
    shel_read Åbergeben, wobei die Nullbytes durch Leerstellen ersetzt
    werden, ansonsten besteht sie nur aus dem Byte $7f.
 3. Nach MultiTOS-Konvention kînnen jetzt erweiterte Parameter Åbergeben
    werden. Werden im Parameter "doex" Bits im Hibyte gesetzt, wird statt
    "command" ein Zeiger auf eine Tabelle von Langworten Åbergeben:

     tab[0]         ist ein Zeiger auf "command"
     tab[1]         Wert fÅr Psetlimit, wird seit 25.9.95 unterstÅtzt
     tab[2]         Wert fÅr Prenice, wird z.Zt. ignoriert
     tab[3]         Zeiger auf Default-Verzeichnis, z.Zt. ignoriert
     tab[4]         Zeiger auf das Environment

    Das Default-Verzeichnis wird unter MagiC viel einfacher gesetzt, das neue
    Programm erbt nÑmlich alle Pfade auf allen Laufwerken vom aufrufenden
    Programm. Wichtig ist hier hauptsÑchlich die Mîglichkeit, ein Environment
    vorzugeben.

- wind_set(WF_UNICONIFY) geÑndert, anstelle der gespeicherten werden nun die
  Åbergebenen Parameter berÅcksichtigt.

- shel_find korrigiert fÅr PATH-Variable ohne abschlieûenden '\'.

- MGFORMAT benutzt nicht mehr Protobt, um den Bootsektor zu erstellen.
  Bei 720k-Disketten wird jetzt ein MSDOS-Format mit 730.112 freien Bytes
  erzeugt.

- wind_get(WF_BOTTOM) korrigiert.

- wind_get(WF_TOP) den Hack fÅr Tempus entfernt.
  Tempus KANN JETZT NICHT MEHR LAUFEN!!!!!!!! Bei Problemen bitte an Wilfried
  wenden.

- appl_getinfo() liefert zu shel_write() die Information:
  Nur Modi 0 und 1 vorhanden.
  TatsÑchlich sind vorhanden: 0/1/4/5/9/10

- wind_set() mit ungÅltigem Modus liefert 0.

- wind_get(WF_KIND) unterstÅtzt.

- Das Programm XMEN_MGR (am besten in den APPS-Ordner legen) installiert
  folgende Funktionen:

     menu_popup()
     menu_attach()
     menu_istart()
     menu_settings()

  appl_getinfo() liefert bei den entsprechenden Unterfunktionen eine "1",
  wenn XMEN_MGR installiert ist.
  Intelligenterweise hat menu_popup() dieselbe AES-Funktionsnummer wie
  menu_unregister(), und menu_attach() hat dieselbe wie menu_click(). Die
  Funktionen werden durch die Art und Anzahl der Åbergebenen Parameter
  unterschieden.

- appl_find("?AGI") => 0 statt bisher (-1)

- Auf besonderen Wunsch zweier einzelner Herrn, die immer paarweise genannt
  werden, wird der Kreuzchenbutton im 2D- Modus nicht mehr im Modus XOR,
  sondern REPLACE gezeichnet.
  Es ist daher darauf zu achten, daû im 2D-Modus der Hintergrund weiû ist,
  sonst gibt es GrÅtze.

- MAGXDESK kann Fenster ikonisieren. "Iconify all" wird bisher allerdings
  geflissentlich ignoriert.
  MAGXDESK 3 unterstÅtzt Iconify voll.

- Ich habe versuchsweise die AES-Versionsnummer auf 4.0 gesetzt. Leider zeigt
  GEMVIEW immer noch keinen Iconifier. Ein neues Sorgenkind ist XCONTROL, das
  zwar angeblich AP_TERM versteht, aber die Nachricht geflissentlich
  ignoriert.
  SHUTDOWN meldet daher eine ZeitÅberschreitung.

- ikonifizierte Fenster haben keinen Backdrop-Button mehr. Die Grîûe wurde
  MultiTOS angeglichen und betrÑgt 72 Pixel brutto Hîhe und Breite.

- Ist die Auflîsung ungeeignet, um Fenster mit 3D-Rahmen darzustellen, wird
  die Breite des 3D-Rahmens verkleinert. Vorher waren sÑmtliche 3D-Buttons
  leer.
  Es wird dringend empfohlen, in TT low auf 2D-Darstellung zu schalten.

- Bei wind_set(WF_ICONIFY) kann man fÅr das GRECT {-1,-1,-1,-1} Åbergeben. In
  diesem Fall wird die Icon-Position berechnet. Das funktioniert auch in der
  Beta-Version von MultiTOS, aber dort muû man das Fenster vorher schlieûen.

- menu_register wird nicht ausgefÅhrt und liefert -1, wenn es nicht von einem
  ACC ausgefÅhrt wurde.

- Farbicons unterstÅtzt.

- G_F(BOX)TEXT mit 3D-Flags "Indicator" oder "Background" fÅr kleine Schrift
  implementiert. Bisher war nur groûe Schrift mîglich, wer benutzt auch
  Eingabefelder mit kleiner Schrift ?
  Wenn man kein Eingabefeld machen will, sollte man auf keinen Fall ein
  3D-Flag setzen, wenn das Aussehen dem eines 2D-Objekts mit Modus
  "transparent" entsprechen soll.
  D.h.: HÑnde weg von den 3D-Flags, es sei denn, man weiû, was man tut.

- Internen MenÅmanager erweitert. Das erweiterte MN_SELECTED Format wird
  jetzt auch vom internen MenÅmanager unterstÅtzt (appl_getinfo entsprechend
  abgeÑndert). Man erhÑlt in buf[5,6] den MenÅbaum (OBJECT *), d.h. den an
  menu_bar() Åbergebenen Baum. Der Fall, daû ein anderer Baum angewÑhlt wurde,
  wie in MultiTOS das linke MenÅ, tritt in MagiC bisher nicht auf. In buf[7]
  erhÑlt man den parent des angewÑhlten MenÅeintrags, d.h. die Objektnummer
  der "heruntergefallenen" Box, die den angewÑhlten MenÅeintrag enthÑlt.

- Kînnen Farbicons aufgrund eines nicht unterstÅtzten Bildschirmspeicher-
  Formats nicht angezeigt werden, werden Monochrom-Icons angezeigt.
  Will man keinen Text, muû man
  - entweder Textbreite auf 0 setzen (besser!)
  - oder den Text dorthin positionieren, wo er vom Icon ÅbergebÅgelt wird.

- wind_set(WF_DCOLOR) ist folgendermaûen erweitert:

  W_FULLER:    Ñndert wegen KompatibilitÑt zu alten Versionen den Iconifier
               und den Backdrop-Button mit.
  W_SMALLER:   Wie in AES 4.1 kann damit der Iconifier modifiziert werden.
               Andere Objekte werden nicht mit verÑndert. Man muû also erst
               den FULLER und dann den ICONIFIER Ñndern.
  W_BOTTOMER:  FÅr den Backdrop-Button. Geht nur in MagiC, nicht in MultiTOS.
               Auch hier wird kein anderes Objekt beeinfluût.

- wind_set(WF_ICONIFY) legt bei g = {-1,-1,-1,-1} das Fenster an die nÑchste
  freie Position fÅr ikonifizierte Fenster.
- wind_open() legt bei g = {-1,-1,-1,-1} das Fenster an die nÑchste
  freie Position fÅr ikonifizierte Fenster.


ERWEITERUNGEN ab der ersten Release-Version:
============================================

ab 15.4.95:

- Erweiterte Version von appl_write() eingefÅhrt. Ist die ap_id der Ziel-
  Applikation -2, zeigt "msgbuf" auf folgende Struktur (->MAGX.H):

     typedef struct {
          int  dst_apid;
          int  unique_flg;
          void *attached_mem;
          int  *msgbuf;
          } XAESMSG;

  Dabei enthalten <dst_apid> und <msgbuf> die Åblichen Nachrichten-
  Informationen.
  <unique_flg> gibt an, ob gleichartige Nachrichten (d.h. solche mit gleichem
  Nachrichtentyp msgbuf[0]) von der neuen Nachricht Åberschrieben werden
  sollen.
  Wenn <attached_mem> != NULL ist, wird damit ein per Malloc() allozierter
  Speicherblock angegeben, der die erweiterten Nachrichten-Informationen
  enthÑlt. Die LÑnge dieses Blocks ist beliebig und fÅr das System
  uninteressant, sie kînnte z.B. als erstes Langwort des Blocks oder in
  msgbuf[4,5] Åbergeben werden. Das System weist den Speicherblock der
  Zielapplikation zu und Åbermittelt dessen Adresse in msgbuf[6,7]. Die
  aufrufende Applikation muû davon ausgehen, daû msgbuf[6,7] nach dem Aufruf
  von appl_write() zerstîrt sind. Das System behÑlt sich vor, den Inhalt des
  Speicherblocks umzukopieren und den Åbergebenen Block freizugeben. Der
  Aufrufer darf nach dem appl_write() NICHT MEHR AUF DEN BLOCK ZUGREIFEN UND
  IHN AUF GAR KEINEN FALL FREIGEBEN !!!

  Gibt appl_write() einen Fehlercode zurÅck, ist der Block nicht Åbergeben
  worden und gehîrt nach wie vor der aufrufenden Applikation. Ein Fehler
  tritt dann auf, wenn:

     a) die Zielapplikation ungÅltig (nicht existent oder eingefroren) ist
     b) der Nachrichtenpuffer der Zielapplikation voll ist
     c) die Zielapplikation kein Prozeû ist (z.B. der SCRENMGR) und ein
        "attached memory block" angegeben worden ist.

- Versuchsweise: Backdrop-Button schaltet ggf. die MenÅleiste um. Es kînnte
  noch Probleme geben, falls jemand die Backdrop-Meldung selbst bearbeitet,
  dann wird nÑmlich die MenÅleiste nicht umgeschaltet. Aber wer macht das ?
- Inaktive MenÅs lassen sich zeichnen, indem das Flag RBUTTON des Objekts #0
  gesetzt wird (fÅr Tear-Off-MenÅs).
- AES: objc_draw() an MultiTOS angepaût. Nach einer Reihe von Versuchen hat
  sich jetzt folgendes ergeben:

 1. G_BOXTEXT DECKEND 3D wird in G_BOXTEXT TRANSPARENT 3D gewandelt
 2. G_TEXT DECKEND 3D wird ebenfalls in G_BOXTEXT TRANSPARENT 3D gewandelt

  Schwachsinnig ist, daû im Fall 2. das gesamte Objekt mit einer grauen Box
  unterlegt wird, nicht nur die Zeichenkette. Diese Umwandlungen sind
  weiterhin eigentlich vîllig ÅberflÅssig, weil man auch gleich G_BOXTEXT
  nehmen kînnte. Tut man aber nicht, weshalb einige Objekte unter MagiC nicht
  wie gewÅnscht aussahen.
- AES: objc_draw() zeichnet die selektierten 3D-Objekte, die nicht dunkelgrau
  werden und die nicht "reingedrÅckt" werden, wie im 2D-Fall mit einer
  schwarzen XOR-Box. Das macht MultiTOS auch so (wenn ich das nicht sage,
  gibt es Protest). Betroffen: G_TEXT, G_IBOX und der MagiC- Gruppenrahmen.
- 3D/FTEXT/DECKEND wird zwar mit einer Box hinterlegt (wie BOXTEXT), aber
  jetzt wie in MultiTOS ohne Rahmen gezeichnet.
- Neue Regel:

     FL3DBAK:       Objekt immer mit XOR-Maske selektieren
                    und objc_change immer durch XOR-Maske
     andere 3D:     Objekt nie mit XOR-Maske
                    und objc_change zeichnet das Objekt immer neu

- Neue Regel:
  Selektieren verwandelt die Boxfarbe nur noch dann von hellgrau in
  dunkelgrau, wenn FL3DIND gesetzt ist.
- In MultiTOS werden Objekte mit den Flags INDICATOR durch grauen Hinter-
  grund und eine énderung der Textfarbe selektiert.
  Das funktioniert NICHT bei G_BUTTON, G_TITLE und G_STRING !!!!
  Die énderung der Textfarbe berechnet sich in MultiTOS folgendermaûen:

     0    <=>  1
     2    <=>  13
     3    <=>  15
     4    <=>  14
     5    <=>  10
     6    <=>  12
     7    <=>  11
     8    <=>  9

  Eine Systematik kann ich darin nicht erkennen, auûer daû hellgrau und
  dunkelgrau und schwarz und weiû vertauscht werden.
  MagiC hat daher folgende Umsetzung:

     0    <=>  1
     8    <=>  9
     sonst: Bit 3 toggeln, d.h. Farbe abdunkeln/aufhellen

  Eine IBOX mit Typ Indicator und ohne Rand ist dann allerdings nicht mehr
  als selektiert zu erkennen, weil sie weder Text noch Box enthÑlt.
  Im Gegensatz zu MultiTOS funktioniert das Umschalten der Textfarben auch
  bei G_BUTTON, G_TITLE und G_STRING.
- AES: Bei shel_write() den Modus mit doex=7 eingebaut (SHW_BROADCAST).
  Unglaublich wichtig, besonders deshalb, weil sowieso jede Applikation einen
  Workaround mittels appl_search() besitzt.
- AES: shel_write() mit Modus 8 fÅhrt zu Fehlercode 0 statt zum Start eines
  Programms.

