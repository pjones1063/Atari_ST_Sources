Richtlinien zum UnterstÅtzen von langen Dateinamen
--------------------------------------------------

Andreas Kromke
22.10.95


1. Hier bin ich
---------------

Mit

	Pdomain( PDOM_MINT /* 1 */ );

teilt man dem DOS mit, daû man lange Dateinamen mag.
Das DOS verhÑlt sich nicht wesentlich anders (->MiNT-Doku), aber
MagiC kann fÅr die Dateiauswahl feststellen, ob lange Dateinamen
mîglich sind.


2. To do and not to do
----------------------

Die Aufrufe Fsfirst/-next() sind tabu.
Ein Verzeichnis wird eingelesen mit

{
	XATTR xattr;
	LONG dirhandle;
	LONG err,xr;

	dirhandle = Dopendir(path, DOPEN_NORMAL /* 0 */ );
	if	(dirhandle >= 0)
		{
		do	{
			err = Dxreaddir(fnamebuflen, dirhandle, fnamebuf,
					&xattr, &xr);
			if	(xr)
				.. Fehler bei Fxattr ..
			if	(err)
				.. Fehler bei Dreaddir ..
			}
		while(!err);
		Dclosedir(dirhandle);
		}	
}


fnamebuf enthÑlt dabei in den ersten 4 Bytes die Inode-Nummer, die man
normalerweise nicht braucht (Fehldesign von Dxreaddir) und die in der
XATTR-Struktur sowieso nochmal drinsteht.
Nach Dateitypmustern wie "*.prg" kann dabei nicht gesucht werden,
stattessen muû man selbst auf regulÑre AusdrÅcke abtesten.
Erwischt man einen Symlink, muû man ihn ggf. manuell dereferenzieren,
und zwar mit:

		if	((xattr.mode & S_IFMT) == S_IFLNK)
			{
			XATTR xa2;

			err = Fxattr(0, path_mit_aliasname, &xa2);
			if	(!err)
				xa = xa2;
			err = E_OK;
			}


3. Hau matsch
-------------

Mit 

		err = Dpathconf(path, DP_NAMEMAX);
		if	(err > 0L)
			{
			maxnamelen = (int) err;
			dos_mode = (Dpathconf(path, DP_TRUNC) == DP_DOSTRUNC);
			}
		else	{
			dos_mode = TRUE;
			maxnamelen = 12;
			}

erhÑlt man Informationen Åber die maximale DateinamenlÑnge in einem
Verzeichnis. Man kann die Puffer entsprechend anlegen.


4. Gimme Info
-------------

Mit

		Fxattr(0, path, &xattr);

erhÑlt man Informationen Åber eine Datei oder einen Pfad, wobei
Aliase dereferenziert werden.

Mit

		Fxattr(1, path, &xattr);

erhÑlt man im Fall eines Alias Informationen Åber diesen selbst. Genau
wie bei Dxreaddir().

Dieselbe Info bekommt man auch Åber ein Datei-Handle, und zwar mit

		Fcntl(fd, &xattr, FSTAT);

Also nix mit DateilÑngenermittlung Åber Fseek() und Ñhnlichem Schrott!


5. Ferner liefen
----------------

GrundsÑtzlich sind keine Platzhalter ('?' oder '*') bei Systemaufrufen
erlaubt, d.h. auch nicht bei Fdelete(), Pexec() usw.
Fxattr() ist Fattrib() unbedingt vorzuziehen.
Dgetcwd() ist Dgetpath() vorzuziehen.
Dreadlabel() und Dwritelabel() sind statt irgendwelcher Tricks mit
Fcreate(quark, F_VOLUME) zu verwenden.


6. Dxreaddir-Binding fÅr PureC
------------------------------

/*********************************************************************
*
* Dxreaddir()
*
* Beim Fxattr werden Symlinks nicht verfolgt.
* <xr> enthÑlt nach dem Aufruf den Fehlercode von Fxattr.
*
*********************************************************************/

long Dxreaddir(int len, long dirhandle,
			char *buf, XATTR *xattr, long *xr)
{
	return(gemdos(0x142, len, dirhandle, buf, xattr, xr));
}
