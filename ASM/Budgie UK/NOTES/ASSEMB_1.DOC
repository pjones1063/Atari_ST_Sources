Assembly language for games programmers
---------------------------------------
Introduction

1. VIDEO CHIP and VIDEO RAM

No matter what sort of program one might wish to write, the result
will eventually have to appear on the SCREEN.
How the screen is organised and how bytes of data become pixels
of colour must therefore be understood.

Whatever you see in front of you is a collection of pixels
(64000 of them in low res color mode)
Each pixel is coloured by the electron guns which get their
information from the video chip (shifter)
The video chip's job is to find out what colour the pixel ought to
be, and notify the electron guns accordingly.
It does this 50 times a second when runing at 50hz.

The video  chip (shifter) has to get that information from somewhere.
That somewhere is a place in your ST's memory called video ram.

That can be anywhere in user ram, so long as you tell shifter about it.

When the machine is powered up, the operating system in rom
tells video shifter that it intends to use a 32k block of memory
starting at $78000 (or $f8000 on a 1040) as its video ram.

Whatever then gets put in that ram area will be the basis of the
image that will appear on screen.

Fill that 32k with nothing but noughts and you'll get a
blank picture.  Put 32000 random values (0 to 255), and you'll get
64000 random dots on the screen.

The way video shifter interprets the bytes stored in video ram and
converts that into actual coloured pixels is described in many books.
It is based on the interleaved principle. A pain if ever there was one.

Let's recap.  The picture on screen is there courtesy of video chip
It actually draws it (refreshes it), 50 times a second.
It is a mistake to believe the 68000 chip draws the screen.
The screen is drawn by the video chip. All the 68000 chip does
is to tell the video chip where the relevant data is in ram.
TOS usually puts video data at $78000 which happens to be the
last 32k of free user ram.  If you want your screen memory to be
somewhere else, you must notify video shifter.

Why do we need various screen memory locations:
1. to store spare pictures that will be recalled later
2. to construct sprites on a work screen while another is being displayed
3. to simulate animation
4. to simulate vertical scrolling
5. to display messages that must not overwrite existing scenery

There are several ways to tell shifter where to get its screen data from.
The easiest one is to ask the vertical blank interrupt routine
to do it for us: 
Suppose you've got a picture starting at location $60000 (currently
not on view), that you would like displayed.
Right now, the picture you're looking at on screen comes from data
held at $78000.  The instruction is: move.l #$60000,$45e
That's all you've got to do.  Within 1/50th sec, the vb interrupt
routine will spot your request and notify video shifter to display,
until further notice, a screen starting at $60000
That screen will now be drawn, over and over again, (50 times a second)
by video shifter (who must be the hardest working chip in the ST)

The old picture at $78000 is still in memory. We're just not seeing it.
Move.l #$78000,$45e and there it shows up again!

You've guessed by now that $45e is a systems variable where TOS goes
each vertical blank to see if you need a different screen to show.
Move.l #78000,$45 means 'put the number $78000 inside location $45'


-------------------------------------------------------------------

2. SCREEN MEMORY IN LOW RES

The most sensible way to construct a screen picture would be
one byte  one pixel. This way we would need 64k to define 64000 pixels
They would all be stored sequentially. Each would be any of 256 colors.

Atari (like Commodore) have chosen the plane system. Atari's four planes
need 32k and yield 16 possible colors. The Amiga has five planes and
32 possible colors.

It is not possible to address a single individual pixel on the ST.
Instead 16 consecutive pixels are addressed together. And furthermore,
they must start on a boundary of 16. 
In other words, we may address pixels 0 thru 15, or 32 thru 47,
or 16016 thru 16031, and so on.

Say you want to change pixel number 3 (currently yellow), and make it red.
You'll have to redraw ALL pixels from 0 thru 15, making sure that only
number 3 is different.

On an ST, the cardinal rule is: EVERYTHING revolves around the number 16.
If you need a sprite, make it 16 pixels wide (or 32, or 64).
NO sprite is 15 pixels wide. If you want to position something on screen,
put it on a 16 boundary. If you need a large character set, make it
16 pixels wide. If you want to split the screen in 19 columns, forget it.
Make it 20 columns instead. (320 divided by 20 is SIXTEEN).
Remember, ignore sixteen at your peril.

Before we start describing the interleave system (known as 'planes'),
observe that a screen memory block is made up of 32000 bytes.
There are 200 visible scanlines per screen. That's 160 bytes required
to draw a single line. 

Say our video ram is at $78000.
The first four words will be analysed by shifter to light up the
first 16 pixels.
There is the first rule; FOUR words (ie 8 bytes) are required to
draw a block of 16 pixels.
So, word $78000-78001, and word $78002-$78003, and word $78004-$78005
and word $78006-$78007 will ALL be needed for shifter to DRAW 
pixels 0 thru 15.

The next 4 words ($78008...$7800e) will draw pixels 16 thru 31
The next 4 words will draw pixels 32 thru 47 and so on

This system is so awkward that programmers (Budgie's included)
hurry writing routines and macros that will insulate them from
such punishment.

It is therefore indispensible that all graphic related macros
supplied by Budgie are promptly read and put to good use.

From this harrowing discovery, we will remember the fundamental facts:
160 bytes per scanline
32000 bytes per screen
4 consecutive words required to draw 16 consecutive pixels,
with above words starting on strict boundaries:
a set of 4 words ought to start on a multiple of 8 address
yielding a set a pixels which will start on a 16 boundary

It is ESSENTIAL therefore that any screen held in memory
should start on a clean boundary. Budgie programmers ensure their
screens are stored at an address which is a multiple of 256 or
even a multiple of 1280.
1280 is one of those magic numbers which is divisible by 8,
by 256 and by 160.

Any block from that screen that needs moving somewhere else
should preferrably start on a clean boundary, have a clean width,
and travel to a clean location.  By clean, we mean multiples of ..16

The purists amongst machine language programmers will scorn our
quest for simplicity and efficiency.
However, if a task has some latitude, there is no point in deliberately
chosing complicated methods to execute it.
One might argue why machine language needs being used at all.
What's wrong with good old basic?
The problem is that while games programs spend 99% of their time
doing nothing, waiting for an input from the player, when they do
spring to life, blindingly fast speed is required if jerky
graphics are not to marr the effect. No high level language
can provide that guarantee.  Only a direct link with the machine's
main and auxilliary processors can achieve total control and the
required speed.

Back to the screen. If you're interested in how those famous 16 pixels
are converted from data  into colour dots, here is an example:

First word in screen memory, at $78000 contains %00000000 00000010
Say second word (at $78002) contains 		%00000000 00000001
Third             				%00000000 00000000
Fourth						%00000000 00000101

From this arrangement, we will obtain the following 16 pixels
starting from left to right:
pixels  0 thru 12  will be color 0  (bits 0,0,0,0)
pixel 13 will be color 8  (bits 1,0,0,0) that's 8 in binary
pixel 14 will be color 1  (bits 0,0,0,1) that's 1 in binary
pixel 15 will be color 10 (bits 1,0,1,0) that's 10 in binary

weird arrangement indeed... 

As a practical illustration, in order to clear a screen
(ie make all pixels color 0), all we have to do is to place
in screen memory (at $78000 onwards, or wherever screen is),
16000 words each containing %00000000 00000000 (code for color 0)

here is the actual m/l code:

	move.w	#16000-1,d0	set up a loop counter
	move.l	#$78000,a0	start of screen address
.lp	move.w	#0,(a0)+	put a nought in that location, then increment
	dbra	d0,.lp		repeat 16000 times

(Those 'move' and 'dbra' will be explained later)

---------------------------------------------------------

3. 68000 CHIP : DATA REGISTERS

There are 8 data registers (accumulators  d0-d7) used for
storing data and performing calculations upon them

There are 8 address registers, (of which one, a7, is used as
a stack pointer). Address registers point to locations
in memory. They are extensively used in arrays.

Because data registers are 32 bit long, large numbers can be
placed in them without problem. You are allowed to place
32 bits in them in one go, or just 16 bits, or just 8 bits
Examples are the best explanation as to how data registers work:


MOVE.W #8000,D0		means put 8000 in register (accumulator) D0
MOVE.W  8000,D0		means put the CONTENTS of location 8000 in D0
MOVE.W $8000,D0		put CONTENTS of $8000 in register D0

It is essential that the hash # should not be forgotten if an
immediate value is to be handled. Failure will almost certainly
result in bombs.

ADD.W #100,D0		add 100 to whatever is in D0
ADD.W 100,d0		get the contents of location 100, and
			add it to whatever is in D0
Note. Memory locations from 0 to $800 are in protected area.
They must be accessed in supervisor mode. Otherwise: bombs.
All Budgie programs operate in continuous supervisor mode.

this is a byte:   255
another way of putting it: $FF     or %11111111

this is a word:	  8192
another way of putting it: $2000

this is a long word: 491520
another way of putting it: $78000



now D0 is a 32 bit data register (like an accumulator or a calculator).
Say it contains               11111111 11111111 11111111 11111111
 
MOVE.B #5,d0 makes it         11111111 11111111 11111111 00000101
notice ONLY the last 8 bits were affected, as we specified BYTE
MOVE.W #5,D0 makes it         11111111 11111111 00000000 00000101
now, the last 16 bits were affected, as we specified WORD
MOVE.L #5,D0 makes it         00000000 00000000 00000000 00000101
now, all 32 are affected, because we put a LONG in it

As this is absolutely important, we'll have some more examples:
This time, say D0 starts with 00000000 00000000 00000000 00000000
as it would do after this instruction MOVE.L #0,D0
In other words we have cleared D0.
Another way of clearing D0 is  CLR.L D0

now, let's put a few things in D0:
MOVE.B #5,d0 makes it	00000000 00000000 00000000 00000101 ie 5
MOVE.W #5,D0 makes it	00000000 00000000 00000000 00000101 still 5 
MOVE.L #5,D0 makes it	00000000 00000000 00000000 00000101 still 5

CLR.L D0		00000000 00000000 00000000 00000000
MOVE.B #257,D0			not allowed (255 maximum)
MOVE.W #257,D0		00000000 00000000 00000001 00000001
MOVE.L #257,D0		00000000 00000000 00000001 00000001

now, let's add a few things
CLR.L D0		00000000 00000000 00000000 00000000 ie 0
ADD.B #5,D0		00000000 00000000 00000000 00000101 ie 5
ADD.W #1,D0  		00000000 00000000 00000000 00000110 ie 6
ADD.L #1,D0		00000000 00000000 00000000 00000111 ie 7
ADD.W D0,D0		00000000 00000000 00000000 00001110 ie 14
ADD.W #-1,D0		00000000 00000000 00000000 00001101 ie 13
SUB.B #1,D0		00000000 00000000 00000000 00001100 ie 12

MOVE.W #$FFFF,D0	00000000 00000000 11111111 11111111 ie 65535
MOVE.B #0,D0		00000000 00000000 11111111 00000000
notice that this last instruction didn't quite clear the entire register

MOVE.W #2,D0		00000000 00000000 00000000 00000010 ie 2
notice this one did clear the 3rd byte
LSL.W #1,D0		00000000 00000000 00000000 00000100 ie 4
logical shift left is used for sprite shifting and plain multiplying
LSL.W #1 means multiply by 2   LSL.L #2 multiply by 4
LSL.W #3 multiply by 8         LSL.W #4 multiply by 16

LSR.W #2,D0		00000000 00000000 00000000 00000001 ie 1
LSR.W #1 divide by 2           LSR.W #2 divide by 4	

MOVE.W #$FFFF,D0	00000000 00000000 11111111 11111111
AND.W #255,D0		00000000 00000000 00000000 11111111
AND.B #%00001111,D0	00000000 00000000 00000000 00001111
AND.B #%11110010,D0	00000000 00000000 00000000 00000010
OR.B  #%11110000,D0	00000000 00000000 00000000 11110010

CLR.B D0		00000000 00000000 00000000 00000000
NOT.W D0		00000000 00000000 11111111 11111111
NOT.B D0		00000000 00000000 11111111 00000000
(NOT reverses the specified bits)
CLR.W D0		00000000 00000000 00000000 00000000
NOT.L D0		11111111 11111111 11111111 11111111
CLR.W D0		11111111 11111111 00000000 00000000
SWAP D0			00000000 00000000 11111111 11111111
SWAP D0			11111111 11111111 00000000 00000000
MOVE.W #2080,D0		11111111 11111111 00001000 00100000
notice high word has remained intact: if one were to PEEK 
D0 as a byte, the answer would be 32.
Peek D0 as a word, and the answer is 2080
Peek it as a Long, and the answer is 4294903840
This multiple capability of registers makes it important
to adopt certain rules of discipline:
In doubt, clear all registers before using them,
and try to stick to a common size (words).
Once you've started putting a word number in a data register,
don't switch to longs or bytes. Start with words, and stay with words.

Ex: MOVE.W #400,D0   ADD.W #20,D0
don't: MOVE.W #400,D0   ADD.B #20,D0  (asking for trouble)

MOVE.W #2081,D0		11111111 11111111 00001000 00100001
CLR.B D0		11111111 11111111 11111111 00000000
the above doesn't completely clear a data register,
but it is handy if you want to make the value divisible by 256
CLR.W.D0		11111111 11111111 00000000 00000000
the above still hasn't cleared the entire register.
it is safe as long as you don't use anything larger than words
CLR.L D0		00000000 00000000 00000000 00000000
this was the only truly safe way of clearing a register

MOVE.W #2081,D0		11111111 11111111 00001000 00100001
BCLR #0,D0		11111111 11111111 00001000 00100000
the above meant bit-clear bit zero
(useful to make numbers even)

BSET #2,D0		11111111 11111111 00001000 00100100
above instruct set bit 2 (useful as on/off flags)



4. 68000 CHIP : ADDRESS REGISTERS

Now let's see what an address register is.
Address registers are very partial to byte operations.
MOVE.B	#75,A0 for instance is not allowed
ADD.B	#1,A0 not allowed
ADD.W	#1,A0 is allowed

Use W or better still L, and keep those addresses EVEN !!

An address register is a POINTER. It points to a memory location.
There are 8 address registers A0-A7  but A7 is used as a stack pointer
We'll therefore use A0 to A6


MOVE.L #$ff8240,A0    A0 now POINTS to location $ff8240 (video palette)
MOVE.L #$78000,A0     A0 now POINTS to location $78000 (ie physbase on 520)

MOVE.l $44E,A0		means put the CONTENTS of $44e in A0
as it happens, $44e contains the current screen address, say $78000
therefore MOVE.L $44E,A0 had the same effect as MOVE.L #$78000,A0
Notice the hash before $78000
Had we not put a hash before $78000, we probably would have put ZERO
inside A0, with disastrous effects.

If we want to blank the first screen location, we would do it like this
MOVE.L $44e,A0		/A0 now points to say $78000
MOVE.B #0,(A0)		/location $78000 now contains a nought!
Notice we can access a BYTE in memory with above instruction.
It is known as INDIRECT addressing. 
Whenever the address register is between parenthesis (A0),
you're in INDIRECT mode.

MOVE.B #0,(A0) means 'find out where A0 POINTS TO, and wherever that is,
put a nought in that location'

MOVE.L #$78000,A0
MOVE.B #0,(A0)
The above instruction puts a zero byte inside location $78000

MOVE.B (A0),D0
The above did the opposite. It extracted a byte FROM location $78000
(for instance to have a look at it, and change it, or copy it somewhere else)

Of course address registers are not always necessary.
We can peek and poke memory cells DIRECT, without using address registers

Instead of: MOVE.L #$78000,A0  MOVE.B (A0),D0
we could have said: MOVE.B $78000,D0  (put the byte at $78000 in D0)

Equally: MOVE.L #$78000,A0  MOVE.B #0,(A0)  (put a nought inside $78000)
could have been: MOVE.B #0, $78000 

But address registers are indispensible, when successive locations
have to be addressed, and in arrays.

Say we want to blank the first 10 bytes of screen memory:
MOVE.L $44e,A0		/put contents of $44e inside A0
			/A0 now points to say $78000
MOVE.L #0,(A0)		/$78000-1-2-3 now cleared
MOVE.L #0,4(A0)		/$78004-5-6-7 now cleared
MOVE.W #0,8(A0)		/$78008-9     now cleared

Notice MOVE.L #0 cleared FOUR bytes in one go,
MOVE.W #0 only cleared TWO bytes, and MOVE.B #0 would clear only one.

Also 4(A0) meant 4 bytes past whatever A0 points to

Say A0 points to $78000
MOVE.B #255,$1000(A0) will slot a 255 inside location $79000 


More examples:

MOVE.B #5,(A0)        a 5 (00000101) is slotted in location $78000
MOVE.W #5,(A0)        00000000 is slotted in $78000 and
                      00000101 is slotted in $78001
MOVE.L #5,(A0)        00000000 is slotted in $78000,$78001,$78002 and
                      00000101 is slotted in $78003

MOVE.B #5,8(A0)       00000101 is slotted in $78008

say D0 contains 2
MOVE.W #5,0(A0,D0)    00000000 is slotted in $78002
                      00000101 is slotted in $78003
The last instruction is often used with arrays:
We know A0 points to $78000,
We know D0 holds a 2,
(A0,D0) therefore POINTS to $78002
0(A0,D0) is the same. It too points to $78002
4(A0,D0) would point to $78006
MOVE.W #5,4(A0,D0) will therefore slot 2 bytes (move.w is 2 bytes)
starting at location $78006
(ie a nought will go in $78006, and a 5 will go in $78007)

MOVE.W #5,$20(A0,D0) a 5 will be slotted in the WORD starting at $78022

The trick when you see once of those composite instructions,
is to add ALL the components to reach the final address


Remember: MOVE.W #5,0(A0,D0) is NOT the same as MOVE.L #5,0(A0,D0) !!
They will both POINT to location $78002,   BUT
the first one will put a nought in $78002, and a 5 in $78003
the second will put a nought in $78002, $78003, $78004 and 5 in $78005


Now let's see how to increment address registers (ie to make them point
further and further along...)

MOVE.L #60000,A2	A2 points to memory location $60000
ADD.L #2,A2		A2 now points to location $60002
MOVE.L #$100,D0		D0 contains $100
ADD.L D0,A2		A2 now points to location $60102
MOVE.B #0,(A2)		a BYTE zero has just been slotted inside
			memory location $60102 overwriting anything
			that was there
MOVE.B #0,(A2)+		Same thing again, but, having slotted the byte
			inside $60102, A2 is THEN incremented by ONE
			and now POINTS to $60103 !   A2 was incremented
			by one because of the Byte instruction
MOVE.B #7,(A2)+		same thing again (except that this time we put
			a 7 inside $60103). A2 now points to $60104
MOVE.W #0,(A2)+		A word zero is slotted inside $60104-60105,
			A2 now points to $60106 (TWO bytes further along)
MOVE.L #0,(A2)+		A2 now points to $6010A (FOUR bytes further)

  
A practical example is called for.
Suppose we have a picture showing on screen at $78000.
Suppose we want to make a REPLICA of that picture (in order
to do some work on it, or prevent it from being erased by
a text message, or whatever)

	MOVE.L	#$78000,A0	that's where picture is (origin) 
	MOVE.L	A0,A1		duplicate A0
	SUB.L	#32768,A1	A1 now points to $70000 (destination)
	MOVE.W	#32000-1,D0	data register used as loop counter
loop	MOVE.B	(A0)+,(A1)+	copy one byte from origin to destination
				THEN, increment BOTH pointers
	DBRA	D0,loop		repeat until counter reaches nought	

We now have TWO pictures in memory!
Having safely tucked that picture away at $70000, 
we now decide to erase the original one, (at $78000).
This is how it's done:
	MOVE.L	#$78000,A0	that's where picture is 
	MOVE.W	#32000-1,D0	data register used as loop counter
loop	MOVE.B	#0,(A0)+	erase one byte at a time
	DBRA	D0,loop		32000 times
The original picture has now disappeared. The screen is blank.

	
Now some more examples to be absolutely clear about it:

	MOVE.W	#255,D0		use D0 as an offset
	LEA $78000,A0		same as MOVE.L #$78000,A0
	MOVE.B #5,0(A0,D0)	will slot a 5 in location $780FF
(LEA means load effective address: same as MOVE.W #.....,A0)
Please note $FF is same as 255, and $8000 is same as 32000. 

How to clear the screen. (A bit faster this time)
       MOVE.W   #16000-1,D7 set up a counter. Use D7 or any D register
       MOVE.W   #0,D0       zero means blank (no pixel lit up)
       MOVE.L   $44E,A0	    tell A0 to point to current screen
loop   MOVE.W	D0,(A0)+    put nought in loc, then increment by TWO
       DBRA D0,loop         deduct 1 from loop counter,
                            check if zero reached,
                            if not go back to loop       
because we blanked 16 bits at a time (one word), only 16000 
iterations were necessary


Now, let's be quicker still
       MOVE.W   #8000-1,D7  loop counter
       MOVE.L   $44E,A0     location $44E holds current screen address
loop   MOVE.L   #0,(A0)+    put a long word (that's 4 bytes in one go)
                            into that location  then tell A0 to
                            point FOUR bytes further along
       DBRA     D0,loop     until loop reaches zero

Here's yet another way, without using a loop 
       MOVE.W   #16000,D0   counter: 16000 times
       MOVE.L   $44E,A0     addresses are Long words
again  MOVE.W   #0,(A0)     blank first 2 bytes
       ADD.W    #2,A0       move pointer 2 bytes along
       SUB.W    #1,D0       deduct 1 from counter
       CMP.W    #0,D0       is it zero? ( TST.W D0  is same)
       BNE      again       No. Then do it again

Here's another faster way
	MOVE.W	#2000-1,D0 loop (getting shorter)
	MOVE.L	$44E,A0	   destination 
loop	MOVE.L	#0,(A0)+   4 bytes in one go
	MOVE.L	#0,(A0)+   and again
	MOVE.L	#0,(A0)+   and again
	MOVE.L	#0,(A0)+   and again
	DBRA	D0,loop   




Once again, how to copy a screen from physbase to somewhere else in memory
	MOVE.W	#8000-1,D0	set up a loop: 8000 times 4 bytes = 32K
	MOVE.L	$44E,A0		origin screen (say current screen)
	MOVE.L	A0,A1		A1 now same as A0
	SUB.L	#32000,A1	A1 now points 32000 bytes BELOW screen
loop	MOVE.L	(A0)+,(a1)+ 	copy FOUR bytes in one go!
	DBRA	D0,loop
All done in a flash!

The actual time taken was as follows:
MOVE.L (A0)+,(A1)+     takes 20 cycles
DBRA                   takes 10 cycles
                        --------------
                             30 cycles times 8000 = 240000 cycles

8 million cycles divided by 240000 = 1/33 of a second
Not quite fast enough to do the job within one video refresh (1/50th)
To speed up this operation, we could have TYPED
the line 'MOVE.L (a0)+,(A1)+'  8000 times (!) and done away with the loop
or used the MOVEM.L instruction (multiple move)

A final point about byte operations with address registers.
We've already seen that address registers may be incremented
by ANY number, even 1, as long as the instruction is W or better still L
MOVE.L #$78333,A0 is acceptable
ADD.L #1,A0 is still acceptable  (A0 now points to $78334)
ADD.B #1,A0 is not allowed

However, if we want to EXTRACT information from an UNEVEN pointer,
(say A0 contains $78333), only a BYTE may be reached.
Anything else will result in an address error and bomb.
ex: MOVE.L #$78333,A0  MOVE.B (A0),D0 is OK
    MOVE.L #$78333,A0  MOVE.W (A0),D0 will bomb
    MOVE.L #$78333,A0  MOVE.L (A0),D0 will bomb

    MOVE.L #$78332,A0  MOVE.W (A0),D0 is perfectly OK (all even)

Same rule applies if we INSERT values where the register POINTS:
    MOVE.L #$78332,A0  MOVE.W D0,(A0) is OK
    MOVE.L #$78332,A0  MOVE.L #1,(A0) is still OK
    MOVE.L #$78332,A0  MOVE.B #1,(A0) is still OK
    MOVE.L #$78333,A0  MOVE.L #1,(A0) will bomb!

In doubt, keep those addresses EVEN, and only put words in them.


5. 68000 INSTRUCTIONS

Now some elementary comparisons between assembly language and Basic 

BASIC                ASSEMBLY LANGUAGE
----------------------------------------------------------------
GOTO bill		BRA bill 	/if bill is within 32K
		or	JMP bill 	/no matter where bill is

GOSUB bill		BSR bill
		or	JSR bill

score=score+1		ADD.W #1,score
			/unlike 6502 code, where we say add to score,1 
			in 68000, we say add 1 to score
		or	LEA score,A0  /load effective address of score in A0
			ADD.W #1,(A0) /add one to score
			
score=10		MOVE.W #10,score  /again, we say: put a 10 in score

score=result		MOVE.W result,score 	/put 'result' inside 'score'
		or	LEA result,A0  		/get address of result
			LEA score,A1   		/get address of score
			MOVE.W (A0),(A1)	/put one inside the other   
		or	MOVE.W result,D0       
			LEA score,A1
			MOVE.W D0,(A1)

PRINT "hello"		PRINT message		/this is a macro
			message DC.B "hello",10,13,0

CLS			CLS		/this is another macro

BLOAD "degas.pi1",physbase   LOAD degas,degas_ptr
			/disk operations are all covered by macros;
			/in many ways, far easier than in basic!

POKE $45e,255		MOVE.W #255,$45e	/notice the 68000
			convention: poke 255 inside $45e
POKE physbase,33	MOVE.W #33,physbase	/notice the hash
			meaning an ACTUAL number, as opposed
			to a location CONTENTS
POKE 20000,0		MOVE.W #0,20000

POKE bill,10		MOVE.W #10,bill	
POKE bill+4,10		MOVE.W #10,bill+4
		or	LEA bill,A0		/get bill's address
			ADD.W #4,A0		/go 4 BYTES further one
			MOVE.W #10,(A0)		/at that point, slot a 10 in

		or	MOVE.L #bill,A0		/same as LEA bill,A0
			MOVE.W #10,4(A0)	/put a 10 in bill+4 
			/note: addresses are usually referred to as 
			/Long words, hence  MOVE.L #bill,A0
			/data on the other hand is very often word:
			/hence MOVE.W #10,4(A0)

FOR loop=1 TO 32000	MOVE.W #32000-1,D0	/set up a counter
do something 		loop  do something
NEXT			DBRA D0,loop		/fantastic instruction
			/meaning: deduct one from counter, check if
			/zero is reached and if not, go back to loop

PEEK bill		MOVE.W bill,D0		/contents of bill
			/now inside D0 register

IF score>result THEN	MOVE.W score,D1 
GOTO bill		MOVE.W result,D0     
			CMP.W D0,D1
			BGT bill		/branch if greater than
			/note comparisions are again the opposite
			/way to 6502: ex: CMP.W #5,D0  means
			compare with 5, D0
			BGT fred   /means: if D0 is greater than 5,
			/then branch to fred


IF score<result	THEN	CMP.W D0,D1	/compare with D0, D1
			BMI		/if D1 is smallest, then...
			/means Branch if MInus

IF A=0 THEN		MOVE.W A,D0	/get value of a in register D0
			TST.W D0	/test the flags
GOTO bill		BEQ bill	/branch if equal

			/note the tst.w instruction was not
			/absolutely necessary as flags are automatically
			/checked after a MOVE instruction
			/we could have said:
			MOVE.W A, D0
			BEQ bill

			/ we could have tested A directly, without
			/putting it first in a data register
			/we could have said:
			TST.W A
			BEQ bill

REM			*
END			JMP quit  	/or wherever
--------------------------------------------------------

6. THE BUDGIE SHELL.

The Budgie 'shell' is a programming environment.
It is intended for programmers, particularly beginners,
who want to write games in 68000 machine language.
It is also perfectly suitable for producing serious utilities,
but because it 'includes' dozens of graphics and sound
sub-routines which are probably seldom needed, it will produce
a less than compact object code.
Even so, it compares favourably with high level languages who
also use run-time, or included, libraries.

A typical game produced within the Budgie shell will assemble
to about 70K.  A one-line program, if there can be such a thing,
will assemble to about 30K. Games like Damonoid, Blitz, Moneyspinner,
Operation Angelica, Speculator, Sea King, Final Lap were written
using the Budgie shell. So was The Virus Guardian, etc...

The Budgie shell can best be described as a main loop, running
at 50 hz, during which the keyboard and joystick (or mouse) are
scanned. Any key or joystick message triggers an immediate action
which is the basis of all games. 

There are two versions of the Budgie shell.
The first one (shell_1.s) is very small. It merely reads the
keyboard and the joystick. Even so, the entire library of
routines and macros is included, and instantly available.
Because it is intended for absolute beginners, every single line,
every single instruction is commented!

The full version (shell_41.s) initializes various sprites, 
supports hardware and software vertical scrolling, and has
a timing and debugging system.
Let'as examine it in more detail.

Shell_41.s needs Devpac 2 (GenST2) to operate.
Open shell folder. Double click on shell_41.s 
Click on 'assemble'. Choose 'disk assembly'
rather than 'memory' unless you have 1 meg RAM. Name the object code
T.PRG or whatever. The source code will take about 25 seconds to 
assemble to hard disk. More to floppy. The resulting object code
can be run like a normal Gem program by double clicking over it.

During assembly. 'shell_41.s' automatically appends a few libraries
which must be stored on the disk you are working from.

A typical working disk should be Double Sided and have on it:

<folder>SHELL
<folder>INCLUDES
<folder>COMMON
<folder>FONTS
GenST2.PRG
GenST2.INF
Desktop.INF

Inside <folder>SHELL is: SHELL_41.S  or whatever version is current
                         HISCORES.ASC
                         TEXT.S
			 TITLE.PI1
			 SPRITES.PIC
			 and other degas pictures
Inside <folder>INCLUDES is : INCLUDE1.S
                             INCLUDE2.S
                             INCLUDE3.S
                             INCLUDE4.S
                             INCLUDE5.S
                             INCLUDE6.S  not essential
                             INCLUDE7.S  not essential
                             SOUNDS.S
                             MACROS.S
Inside <folder>COMMON is:    BUDGIE.TIT  a small degas picture
                             GAMES.S
                             DRUM1.SPL  some unimportant sampling
                             PENNY.PI1  introduction picture
                             WRITER.UK  another binary file (incbin)
                             etc...
Inside <folder>FONTS         are 8 and 16 pixel fonts

When SHELL.S is being assembled, it will expect to find
the INCLUDE files.
INCLUDE1.S contains such things as file reading routines,
bios trap calls, supervisor mode, quit, reveal,joystick,
mouse, from_to, sort, vbi, bindec, etc..
INCLUDE2.S contains h/blank, pic_dump, view array etc..
INCLUDE3.S contains pixel plot, sprite, boot sectors, etc..
INCLUDE4.S contains fonts, scroll, etc..
INCLUDE5.S contains replay 
SOUNDS.S contains mainly sound effects 
TEXT.S contains ascii messages, hi-scores tables, etc..
GAMES.S contains an ascii list of all Budgie games

Presently 'shell_41.s' expects to find these files and folders
on DRIVE A.  Do change if required.


So, what does shell_41.s do anyway?
The shell is an ENVIRONMENT from which to control a game
and call any macros and subroutines that may be required.
Let's be more specific:

1.  It 'includes' a macros file (approx 75 macros)
2.  It then goes into supervisor mode
3.  It gives back to gem (m_shrink) any memory it doesn't need to
    start with.
4.  It finds out where ram top is
5.  It asks gem to reserve some space (malloc) for work areas
    which will be needed later on (spare screens, buffers,..)
    I also asks gem to reserve space for files to be loaded soon
    (sprites for instance)
6.  It initializes the A-line so that we may change the fonts later on.
7.  It hides the mouse, the cursor, etc..
8.  It goes into low res, unless monochrome is detected
9.  It loads the new fonts from disk, and some tunes.
10. It installs the horizontal blank interrupt routine, if any
11. It resets the bombs vectors
12. It installs the vertical blank interrupt routine, if any
13. It does the same with the mfp interrupts
14. It checks whether ascii files have been interfered with...
15. It checks whether the boot sector is still clean (virus)
16. It executes the opening sequence (title page, music, etc..)
17. It initializes the sprites (sizes, locations, etc..)
18. It installs the joystick handler routine
19. It installs the mouse handler routine (optional)
20. It declares some of the main initial variables
21. It declares logical_screen and physical_screen
22. It builds up the required scenery
23. It goes on the the MAIN LOOP, called 'main'

Fine, the prolog is over.
Now for the MAIN LOOP.
This is the conductor of the orchestra.
The program counter comes back to this LOOP 50 times a second,
even if there is nothing to do (if PAUSED for instance).
Our program is therefore said to be running at 50 frames.
50 frames means smooth graphics.

What does this MAIN LOOP do?

1.  It reads the JOYSTICK (or mouse).
    If there is a request, a BRAnch is made to this appropriate routine
2.  It reads the KEYBOARD. If a key has been hit, again
    a suitable BRAnch is made.  Approx 33 keys are currently detected.
    With the exception of ESC, P, and Functions, most of them
    are for de-bugging purposes.
    A BRAnch to one of these routines is terminated with
    a BRAnch back to main (and not with RTS)
3.  It then swaps the 2 video pointers so that at the next 
    vertical blank, graphic operations will be directed
    to the screen NOT being displayed
4.  It now waits for the vertical blank. At this point, the video
    chip redraws the screen (which is the one we were working on
    during the LAST cycle)
5.  The coordinates for all 'automatic' sprites are now being updated
6.  Software vertical scroll is executed if asked for
6.  The clock is updated. So is the score, etc..
7.  It checks whether the level or the game is finished
8.  All sprites are RESTORED. The background is temporarily spriteless
9.  Individual PIXELS are read and drawn (if required)
10. All targeted backgrounds are SAVED unless unnecessary
11. Finally, all sprites are DRAWN in their new positions.
    All this restoring/saving/drawing takes place on the screen
    which is NOT BEING SHOWN (logical_screen)
12. it now checks whether such minor things as Pause or
    Slow Motion are required.
13. at this point, a 1/50th of a second has almost elapsed
    and it's time to go back to MAIN !


The main KEYS which are possibly implemented are:
H	toggle 50/60 Hz
	60hz looks tremendous on the Atari SC1224 color monitor.
	But most television sets won't be able to handle it.
	In 60 hz, the picture is much steadier, because it is
	redrawn sixty times a second, rather than fifty times.
	On the other hand, the programmer has less time to complete
	his sprite operations, and may, in critical cases, miss 
	a frame altogether.  Default option is therefore 50 hz.	
*	debug
	the programmer needs to know the state of important variables
	and data registers. Pressing * at any time will do just that.
	Of course, you have to define your variables first.
	An important programming variable, used for timing, is the
	before/after combination. If you want to know how long a
	routine takes, place a 'before' macro at the start of it,
	place an 'after' at the end of it, and press *. You will see
	how many horizontal blanks have elapsed during the routine.
	During a frame lasting 1/50th sec, approx 312 h/blanks are
	drawn, including top and bottom borders. 312 h/b's is
	therefore the time allowed to conduct an entire 'main' loop.
	If a standard, ready-made, library routine takes too long,
	it will have to be re-written. In Final Lap, all sprite
	routines are re-written, using hundreds of consecutive MOVE.L
	and thereby avoiding time-consuming loops and DBRA instructions.
	The 'before/after' timing system works on the horizontal blank
	interrupt. Therefore it has to be enabled by toggling the J key.
	Once the program is finished, such h/b interrupts should be
	removed as they themselves account for huge processor time.

Z	Pople's scroller
	Gareth Pople's vertical scroller is an ideal 'credits type'
	advertisement. This routine is included in the shell, not
	only to advertise Budgie's backlist, but to illustrate how
	your program can chain another one, and regain control afterwards.

F	font loader
	Two fonts are loaded as standard right at the beginning of the
	introduction.  Pressing F will load one more.  Fonts are
	standard GEM fonts, as used by Jeremy Hughes in his fantastic
	fontsel.acc. They are compatible with all well-behaved gem
	applications. 8*8 and 16*8 are included.

F1	restart game
	games variables are reset and a jump is made to the intro
	of the program
F2-F3	copyright notice and credits
	function keys are mainly used for messages, adverts, etc..
F4-F8	Budgie ads
	being in ascii format, the text can be changed at will
F9	reset hi-score table
	there are two ways of resetting the high score table.
	one is pressing F9, the other is deleting highsco.asc
	from disk
F10	display Options screen
	this display is activated in 8*16 font mode
HELP	load Help screen
	currently a most convincing degas picture
ENTER	similar thing
	but different picture
X	clear current screen
	debugging only
M	a selection of sounds

C	single step
	pressing C repeatedly will activate slow motion mode.
	ideal for debugging
V	vertical scroll
	a section of the screen is scrolled up or down.
	The size of the scrolling window and the speed may be 
	changed by modifying the actual routine in
	include4.s  (ask for Sea King source code)
	This routine accounts for 80% of all processing time.
	Therefore, all but the smallest sprites have to be
	disabled if the game is to run at 50 frames/sec
P 	Pause
	continuously loops back to 'main'
L	Load a file  (ex. spr*.pi1)
	any pi1 file (or any file for that matter) will be loaded
	at current screen address.  To load a screen in a different
	memory location: press P (Pause), hit UP/DOWN cursors,
	press L (Load), and type file name.
D	Dump current screen to disk
	Again, a specific memory screen may be dumped to disk,
	under the name apic.pi1, by following the
	Pause, Cursors, Dump sequence
1-2-3-4-5-6 display these screens (first press P)
	there are several sprite screens, utility screens,
	video screens, etc.. in memory. They may all be view
	by pressing 1 thru 6 on the main keyboard
UP/DOWN scroll through ram
	this is a most useful way of viewing your own memory,
	and checking that things that ought to be there, really
	are there, and at the right place.
	Going backwards from high memory, you will see the two
	video screens (screen_0 and screen_1) also known as
	physical and logical screens, then empty space (known as
	'the heap' ie free available memory). The less free heap,
	the closer you are to 'out of memory' error.
	Then comes some digitized music, recognizable by its
	totally random pattern.. then a 2k 8*8 font, then a 4k 8*16,
	then two spare 32k screens, then the background screen, 
	then the sprites, then the utility screen, then the end of your
	program, showing the stack, and an everchanging random variable,
	then after a while, more changing variables, this time
	belonging to gem and the operating system. Loading a pi1 picture
	here will cause a gigantic crash...
keypad	0-5 sprites on/off
	these keys toggle sprites on and off.
	Too many sprites at any one time can cause a frame to be
	missed, and a jerk will occur.
	notice that sprites take  much longer to draw if they are not
	on a 16 boundary. A 15 boundary is the worst, as 15 bits have
	to be shifted along, at a massive processor cost. If only 
	we had a hardware sprite co-processor..
FIRE	reveal horizontal raster
	Providing sprite 0 is active, (that's the joystick one),
	the exact location of the horizontal raster will be revealed.
	The lower, the more time elapsed.  It may be so long as not
	being visible any longer, ie past the bottom border.
	That's the critical point. That's when the code has to be
	re-examined to make things more efficient, or certain sprites
	disabled to retain the whole game within a frame.
	Notice how the line varies according to the sprite shift
	position.
	Press J to disable the h/b interrupt and notice the big
	improvement. See the effect of switching to 60 hz.
	Disable one sprite and notice the improvement.
	Even the vertical blank music routine has an effect.
	In the end, it boils down to 312 rasters. Everything, from
	reading the keyboard, working out new positions, checking
	for collisions, drawing and erasing sprites, to scrolling
	the background has to be done in 312 rasters, if your game
	is to run, super-smooth, at 50 frames a second.
	Of course you may elect to run your game at 25 frames a second.
	Providing your sprites travel fairly small distances at a time,
	(like 1 or 2 pixels), this may not be too terrible.
	If your sprites are animated, ie are made up of two or more
	physical shapes, the inherent jerkiness of a 25 frame display
	will not be so obvious.
	Nearly all commercial games run at 25 frames a second.
	Flight simulators may run at only 8 frames a second.
	STOS games run at an irregular speed, depending on the
	pixel location of the sprite, the size and number of said
	sprites, and interrupt interference like moving the joystick.




more to follow...

Camy Maertens
Budgie UK
January 4, 1990
*--------------------------------------------------------




