********************
* VIDEO FALCON 030 *
********************

Les modes 1,2,4 et 8 bits par pixels sont organis‚s comme sur le
ST, le STE ou le TT. Dans le mode 16 bits par pixel, il n'y a plus de
palette, chaque pixel est organis‚ ainsi : RRRRRGGGGGGBBBBB. Il existe
‚galement un mode overlay o— les 16 bits sont organis‚s ainsi :
RRRRRGGGGXBBBBB. Le bit X est utilis‚ comme bit d'overlay.

NDT :Notez que les fonctions video du TT ont ‚t‚ enlev‚es et aboutissent
     sur un RTS. 

Le cookie video (_VDO) vaut 0x00000300.

FONCTIONS XBIOS
---------------

Les descriptions des fonctions sont donn‚es en C. Les fichiers
d'en-tˆte correspondants sont dans le dossier BINDINGS.
Le num‚ro des fonctions est donn‚ en d‚cimal.

Fonction 5 : Setscreen
----------------------
int Setscreen (long log,long phys,int rez,int mode)

Setscreen() a ‚t‚ ‚tendue pour supporter les nouveaux modes vid‚o du
Falcon. Si vous passez 3 pour le paramŠtre rez et un mode vid‚o pour
le paramŠtre mode, Setscreen r‚allouera la ram n‚cessaire … l'‚cran
et r‚initialisera le VDI.
Les d‚veloppeurs devraient pr‚ferer l'utilisation de Setscreen() …
celle de VsetMode car contrairement … Setscreen, VsetMode ne r‚alloue
pas la ram et ne r‚initialise pas le VDI.

Fonction 88 : Vsetmode
----------------------
int Vsetmode (int mode)

La fonction Vsetmode place le Falcon dans un mode vid‚o sp‚cifique.
Mode est un mot de 16 bits o— chaque bit a sa signification :

Octet de poids faible :    S O P V 8 N N N

      N  Bits par pixels : 4 -> 16 bits
			   3 -> 8  bits
			   2 -> 4  bits
			   1 -> 2  bits
			   0 -> 1  bit

      8 Flag 80 colonnes : 1 -> mode 80 colonnes
			   0 -> mode 40 colonnes

      V Flag VGA	 : 1 -> mode moniteur VGA
			   0 -> mode TV

      P Flag PAL	 : 1 -> mode PAL
			   0 -> mode NTSC

      O Flag Overscan	 : 1 -> Overscan ON (impossible en VGA)
			   0 -> Overscan OFF

Octet de poids fort : X X X X X X X F

      F Flag Vertical	 : 1 -> Entrelac‚ (TV) / Double ligne (VGA) ON
			   0 -> OFF

      X R‚serv‚

En retour de fonction on obtient l'ancien mode vid‚o. Si on passe
-1 en paramŠtre, on r‚cup‚re le mode video courant.
Quelques modes ne sont pas permis. 40 colonnes 1 bit par pixel ou
80 colonnes VGA 16 bits par pixels ne sont pas possibles.

Fonction 89 : mon_type
----------------------
int mon_type(void)

Cette fonction renvoie le type de moniteur utilis‚. Les valeurs 
possibles sont :

0 -> Moniteur monochrome ST
1 -> Moniteur couleur ST
2 -> Moniteur VGA
3 -> Television

Fonction 90 : VsetSync
----------------------
void VsetSync(int external)

Indique au systˆme quel type de synchronisation vid‚o va ˆtre
utilis‚. External est un mot dont les 3 premiers bits ont une
signification : 0 0 0 0 0 H V C

C -> Synchronisation externe
V -> Synchronisation verticale externe
H -> Synchronisation horizontale externe

Fonction 91 : VgetSize
----------------------
long VgetSize(int mode)

Renvoie la taille de l'‚cran en octets. 

Fonction 93 : VsetRGB
---------------------
void VsetRGB(int index,int count,long *array)

Initialise les couleurs avec des valeurs RGB. L'initialisation de
la palette commence … la couleur index et est faite "count" fois.
Les valeurs RGB a placer dans la palette sont dans le tableau "array"
dont l'adresse est pass‚e en paramŠtre. Cette fonction est appel‚e par
la fonction VDI vs_color(). Le format du tableau est xRGB o— x n'est
pas utilis‚. Pour initialiser une couleur seule, il vaut mieux utiliser
la fonction VDI vs_color().

Fonction 94 : VgetRGB
---------------------
void VgetRGB(int index,int count,long *array)

R‚cup‚re la valeur des couleurs de la palette en commen‡ant … la
couleur "index" pour "count" couleurs. Les valeurs sont plac‚es dans
le tableau "array" dont l'adresse est pass‚e en paramŠtre. Le format
du tableau est le mˆme que pour VsetRGB : xRGB o— x est inutilis‚.
Pour lire la valeur d'une seule couleur, il vaut mieux utiliser la
fonction VDI vq_color().

Fonction 150 : VsetMask
-----------------------
void VsetMask(int andmask,int ormask)

VsetMask est utilis‚ pour initialiser les masques AND et OR utilis‚s
par le VDI pour modifier les valeurs utilis‚es pour vs_color().
Les valeurs des couleurs renvoy‚es par vs_color() sont "AND"‚es puis
"OR"‚es avec les masques pass‚s en paramŠtre. Les valeurs des masques
par d‚faut sont pour AND=0xFFFF et pour OR=0x0000, cette combinaison
ne produit aucun effet. Ceci permet a une application de mettre 
n'importe quelle couleur en transparent (ou pas) dans le mode 15
bits par pixel avec overlay. L'appel … cette fonction place automati-
quement le systˆme en mode overlay true color (15 bits/pixels). Cette
fonction ne peut ˆtre utilis‚e qu'en mode true color. 

*****************************
* SYSTEME SONORE FALCON 030 *
*****************************

L'Atari Falcon 030 a un cookie (_SND) qui indique la configuration
du systˆme sonore :

Bit 0 : PSG Yamaha
Bit 1 : DMA 8 bits
Bit 2 : CODEC 16 bits
Bit 3 : DSP
Bit 4 : Matrice de connexion.

Les trois exemples suivant illustrent les diff‚rentes fa‡ons d'organiser
les donn‚es sonores en m‚moire (G: voie gauche, D: voie droite) :

Une piste st‚r‚o 16 bits :  G	D   G	D  ...
			    mot mot mot mot

Une piste st‚r‚o 8 bits  :  G	D   G	D   G	D  ...
			    oct oct oct oct oct oct

4 pistes st‚r‚o 16 bits  :  G0	D0  G1	D1  G2	D2  G3	D3  G0	D0 ...
			    int int int int int int int int int int

Fonction 128 : locksnd
----------------------
long locksnd(void);

Cette fonction est utilis‚e comme s‚maphore pour locker le systˆme
sonore. Elle renvoie 1 si le systˆme a ‚t‚ lock‚.

Fonction 129 : unlocksnd
------------------------
long unlocksnd(void)

Cette fonction est utilis‚e pour lib‚rer le systˆme sonore pour les
autres applications. Elle renvoie 0 si il n'y a pas eu d'erreur.

Fonction 130 : soundcmd
-----------------------
long soundcmd(int mode,int data)

Cette fonction est utilis‚e pour fixer ou lire des paramŠtres du
systˆme sonore. Si un nombre n‚gatif est pass‚ en paramŠtre, la
configuration courante est renvoy‚e.

Mode : 0 (LTATTEN) -> Fixe l'attenuation en sortie de la voie gauche.
		      L'attenuation est mesur‚e en pas de -1.5 dB.
		      data = xxxx xxxx LLLL xxxx o— LLLL est l'att‚nuation.

       1 (RTATTEN) -> Idem mais pour la voie droite.

       2 (LTGAIN)  -> Fixe le gain en entr‚e de la voie gauche. Le gain
		      est mesur‚ en pas de 1.5 dB.
		      data = xxxx xxxx LLLL xxxx o— LLLL est le gain.

       3 (RTGAIN)  -> Idem mais pour la voie gauche.

       4 (ADDERIN) -> Indique a l'additionneur 16 bits d'o— il doit
		      recevoir ses entr‚es, soit l'ADC, soit la matrice
		      soit les deux. Data est un champ de bits :
		      data = xxxx xxxx xxxx xxMA
		      M : Matrice
		      A : ADC

       5 (ADCINPUT)-> Fixe l'entr‚e de l'ADC. L'entr‚e peut ˆtre les
		      voies gauche et droite du PSG ou les voies gauche
		      et droite du micro. L'entr‚e est un champ de bit
		      o— un bit … 0 indique une entr‚e venant du micro et
		      un bit … 1 indique une entr‚e venant du PSG.
		      data = xxxx xxxx xxxx xxLR
		      L : voie gauche
		      R : voie droite

       6 SETPRESCALE  Utilis‚ pour la compatibilit‚. Cette valeur de
		      pr‚division est utilis‚e quand la valeur de
		      pr‚division interne de DEVCONNECT est … z‚ro.
		      data = 0 -> invalide (6.25 KHz)
			     1 -> divis‚ par 640 (12.5 KHz)
			     2 -> divis‚ par 320 (25 KHz)
			     3 -> divis‚ par 160 (50 KHz)
		      Renvoie la valeur de division courante.

Fonction 131 : setbuffer
------------------------
long setbuffer(int reg,long begaddr,long endaddr)

Cette fonction est utilis‚e pour jouer ou enregistrer des ‚chantillons.
reg indique si il s'agit d'enregistrement ou un playback et begaddr
et endaddr fixent l'adresse de d‚but de fin du buffer. (L'adresse de
fin n'est pas comprise dans le buffer).

reg : 0 -> playback
      1 -> enregistrement

Fonction 132 : setmode
----------------------
long setmode(int mode)

Cette fonction est utilis‚e pour fixer le mode d'enregistrement ou de
playback. Les modes sont les suivants :

mode : 0 -> 8 bits st‚r‚o
       1 -> 16 bits st‚r‚o
       2 -> 8 bits mono

Fonction 133 : settracks
------------------------
long settracks(int playtracks,int rectracks)

Cette fonction est utilis‚e pour fixer le nombre de pistes en 
enregistrement ou en playback. Notez que ce sont des pistes
st‚r‚o. En 8 bits mono, le mˆme echantillon sera rejou‚ en mˆme
temps sur les deux voies.

playtracks : 0 … 3
rectracks  : 0 … 3

Fonction 134 : setmontracks 
---------------------------
long setmontracks(int montrack)

Cette fonction (monitoring) est utilis‚e pour fixer la sortie du haut 
parleur interne sur l'une des 4 voies. Le haut parleur interne ne peut
rejouer qu'une voie … la fois.

montrack : 0 … 3

Fonction 135 : setinterrupt
---------------------------
long setinterrupt(int src_inter,int cause)

Cette fonction est utilis‚e pour fixer quel type d'interruption va
se d‚clancher lors de la fin d'un ‚chantillon. L'interruption
peut venir soit du Timer A mis en mode event_count ou de l'interruption 7
du MFP.

scr_inter : 0 -> timer A
	    1 -> MFP i7
cause	  : 0 -> pas d'interruption
	    1 -> Playback
	    2 -> Enregistrement
	    3 -> Playback ou Enregistrement

Fonction 136 : buffoper
-----------------------
long buffoper(int mode)

Cette fonction est utilis‚e pour contr“ler la restitution ou l'enregis-
trement d'‚chantillons. Le paramŠtre mode est un champ de bits. Si
on passe -1 en paramŠtre, le statut actuel est renvoy‚.

mode : 0 0 0 0 RR RE PR PE
       RR -> Record Repeat (1 : ON, 0 : OFF)
       RE -> Record Enable (1 : ON, 0 : OFF)
       PR -> Play Repeat   (1 : ON, 0 : OFF)
       PE -> Play Enable   (1 : ON, 0 : OFF)

Note: Le systeme sonore possŠde une file FIFO de 32 octets. Lors du
      transfert de donn‚es dans le buffer, l'application doit v‚rifier
      que le bit record enable (RE) a ‚t‚ mis … z‚ro. Si le bit a ‚t‚
      mis … z‚ro, la file FIFO a ‚t‚ vid‚e, dans le cas contraire,
      l'application doit vider la file en mettant le bit RE … z‚ro.

Fonction 137 : dsptristate
--------------------------
long dsptristate(int dspxmit,int dsprec)

Cette fonction est utilis‚e pour placer le DSP en tristate … partir
de la matrice.

dspxmit : 0 -> Tristate
	  1 -> Enable
dsprec :  0 -> Tristate
	  1 -> Enable

Fonction 138 : gpio
-------------------
long gpio(int mode,int data)

Cette fonction est utilis‚e pour communiquer par la biais des broches
d'entr‚es/sorties … usage g‚n‚ral (General Purpose I/O) du connecteur
DSP. Seuls les 3 bits les plus faibles sont utilis‚s, les autres sont
r‚serv‚s. Cet appel, d‚pendant du mode, peut ˆtre utilis‚ pour fixer la
direction des bits d'E/S, pour lire ou ‚crire des bits. Lors d'un
RESET, ces trois lignes sont fix‚es en sortie.

mode  : 0 -> direction E/S   data : 1 -> sortie
				    0 -> entr‚e
	1 -> lecture	     data : etat du port GPIO
			     la valeur lue est renvoy‚e par la fonction
	2 -> ecriture	     data : valeur ‚crite

Fonction 139 : devconnect
-------------------------
long devconnect(int src,int dst,int srcclk,int prescale,int protocol)

Cette fonction est utilis‚e pour connecter un circuit source … un
circuit destination dans la matrice. Cette fonction est aussi utilis‚e
pour fixer la pr‚division de l'horloge et le protocole de transmission.

src: circuit source … connecter … une ou plusieurs destinations.
     0 -> DMA playback (DMAPLAY)
     1 -> Emission DSP (DSPXMIT)
     2 -> Entr‚e externe (EXTINP)
     3 -> Micro/PSG (ADC)

dst: Destination … connecter … la source. Ce mot est un champ de bits :
     Bit 0 -> Enregistrement DMA (DMAREC)
     Bit 1 -> Reception DSP (DSPRECV)
     Bit 2 -> Sortie externe (EXTOUT)
     Bit 3 -> Casque ou haut-parleur interne (DAC)

srcclk: L'horloge que le circuit source va utiliser.
	0 -> Horloge interne 25.175 MHz (Pour son DMA STE)
	1 -> Horloge externe (pour CD ou DAT)
	2 -> Horloge interne 32 MHz

prescale: pr‚division de l'horloge. Le taux d'‚chantillonage est la valeur
	  de l'horloge divis‚e par 256 et redivis‚e par la valeur de
	  prescale. La valeur doit ˆtre comprise entre 1 et 12. 
	  Si prescale=0, le systˆme sonore utilisera alors la valeur
	  de SETPRESCALE fix‚e grƒce … la fonction soundcmd().
	  
Fonction 140 : sndstatus
------------------------
long sndstatus(int reset)

Cette fonction renvoie l'‚tat courant du CODEC. L'‚tat est renvoy‚ dans
les 4 bits de poids faible. Le clipping gauche droite est indiqu‚ si il
a eu lieu durant la conversion Analogique->Digital et le filtrage.

reset : 1 -> reinitialise le systˆme sonore.

AprŠs cet appel, le circuit sonore est initialis‚ ainsi :

- DSP en mode tristate
- Gain et Attenuation … z‚ro
- Connexions dans la matrice coup‚es
- ADDERIN enable
- Mode 8 bits st‚r‚o
- Piste Playback et Enregistrement sur piste 0
- Monitoring sur piste 0
- Interruptions interdites
- Op‚rations avec buffer interdites

Retour : 0 0 L R S S S S 

S -> etat codec : 0 -> Pas d'erreur
		  1 -> Champ de contr“le invalide
		  2 -> Format Sync invalide (coupe le son)
		  3 -> Valeurs invalides pour l'horloge (coupe le son)

L -> clipping gauche
R -> clipping droit

Fonction 141 : buffptr
----------------------
long buffptr(struct *pointer)

Cette fonction renvoie la position courante des pointeurs dans les
buffers d'enregistrement et de playback. Ces pointeurs indiquent
o— la donn‚e est lue/‚crite dans les buffers.

struct *pointer : Un pointeur sur une structure de 4 longs.

structure : pointeur sur buffer lecture (long)
	    pointeur sur buffer ecriture (long)
	    r‚serv‚ (long)
	    r‚serv‚ (long)

**********************
* DSP MOTOROLA 56001 *
**********************

La m‚moire du DSP
-----------------

La RAM que le DSP utilise pour stocker des donn‚es ou des programmes
est une RAM statique de 32 Kmots (soit 96 Ko). Cette m‚moire est
constitu‚e comme suit : l'espace programme est un bloc continu de 32 K mots.
Les espaces de stockage des donn‚es X et Y sont deux blocs s‚par‚s de
16 K chacun. X et Y peuvent ˆtre acc‚d‚s comme des blocs commen‡ant
… 0 ou 16K. L'espace programme recouvre physiquement … la fois les 
m‚moires X et Y donc, un programme DSP devra en tenir compte afin d'‚viter
d'avoir des donn‚es ou des programmes qui entrent en conflit. Notez que
X:0, X:16K et P:16K repr‚sentent le mˆme emplacement physique en m‚moire
(NDT: X: signifie accŠs … la m‚moire X et P: accŠs … la m‚moire programme),
de mˆme, Y:0, Y:16K et P:0 repr‚sentent le mˆme emplacement physique.

Les programmes DSP
------------------

Certaines ‚tapes doivent ˆtre suivies pour le d‚veloppement de programmes
DSP sur Atari. Une partie des 32 Kmots de la m‚moire DSP est allou‚e
pour le systˆme et pour les routines r‚sidentes et ne sont donc pas
utilisables pour les programmes DSP. Une application doit utiliser la
fonction Dsp_Available pour d‚terminer la m‚moire disponible pour son
programme DSP. Si la taille est satisfaisante, l'application doit
reserver cet emplacement m‚moire avec la fonction Dsp_Reserve. Cette
fonction empˆchera la m‚moire programme d'ˆtre corrompue par le systˆme.
Il est aussi n‚cessaire … l'application d'empˆcher l'accŠs au DSP par
une autre application grƒce … la fonction Dsp_Lock. Cet appel doit ˆtre
fait avant tout autre appel qui va utiliser le DSP. Faire ceci vous
assurera que l'‚tat du DSP ne sera pas modifi‚ par quelqu'un d'autre
pendant que votre application l'utilisera. Quand l'application n'utilise
plus le DSP, elle doit appeler la fonction Dsp_Unlock pour permettre
aux autres applications de l'utiliser. Si la fonction Dsp_Lock retourne
une valeur "DSP occup‚", l'application doit attendre et faire des
Dsp_Lock jusqu'… ce que le DSP ne soit plus occup‚. Si vous ne suivez
pas ces ‚tapes, des situations impr‚vues peuvent se produire. Avant
de faire un appel … Dsp_Unlock, l'application doit ˆtre sure que son
programme DSP a restaur‚ l'IPR (X:$FFFF) et MR a son ‚tat original.

Sous-programmes DSP
-------------------

L'existence de sous-programmes DSP permet au systˆme d'avoir plusieurs
processus DSP r‚sident au mˆme moment. Ceci permet un gain de temps
et ‚vite d'avoir … recharger le programme dans la m‚moire DSP … chaque
utilisation. Ces sous-programmes resteront r‚sidents jusqu'a ce qu'ils
soient effac‚s par un autre sous-programme ou par un programme DSP 
qui a besoin de m‚moire. Les sous-programmes DSP sont soumis … plus de
contraintes et de restrictions que les programmes DSP. Le code du sous
programme doit ˆtre entiŠrement relogeable. Lors de l'‚criture du code
d'un sous-programme, il faut veiller … ce que le code d‚bute … l'adresse
0. Quand un sous-programme est appel‚ par une commande h“te, le sous
programme peut obtenir son PC de d‚part … travers le port h“te. Cet
emplacement de d‚part qui est envoy‚ par le TOS doit ˆtre lu par le
sous-programme, qu'il l'utilise ou pas pour sa relocation. La taille
d'un sous-programme ne peut pas d‚passer 1024 Kmots. Un sous-programme
de taille plus grande devrait plutot ˆtre ex‚cut‚ en tant que programme.
Le code sera relog‚ quelque part dans la ram externe du DSP. Veillez
… ce que toutes les adresses utilis‚es dans le programme (adresses de
fin pour les do loop par exemple) soient relogeables par rapport au PC.
Toute donn‚e initialis‚e doit ˆtre d‚clar‚e dans l'espace programme. Un
bloc de m‚moire X et Y a ‚t‚ pr‚vu pour les variables non d‚clar‚es.
Cet espace est situ‚ dans les 256 plus haut mots dans les deux m‚moires
X et Y (X:3F00 - X:3FFF). Cet espace peut ˆtre utilis‚ librement par
les sous-programmes mais comme cet espace est utilis‚ par tous les
sous-programmes, il n'est pas sur que la m‚moire sera pr‚serv‚e la fois
suivante que le sous-programme sera ex‚cut‚. Les programmes h“tes doivent
utiliser la fonction Dsp_Lock avant d'ex‚cuter un sous-programme DSP.
Comme les sous-programmes DSP sont ex‚cut‚s comme des interruptions, ils
doivent ˆtre termin‚s par l'instruction RTI. Le sous-programme ne doit
pas pr‚sumer de l'‚tat du DSP car son ‚tat est d‚termin‚ par d'autres
programmes pr‚c‚demment ex‚cut‚s et non pas par le boot. Une s‚quence
type d'appels pour ex‚cuter un sous-programme se pr‚sente ainsi :

   if (!Dsp_Lock())
      {
      ability=Dsp_RequestUniqueAbility();
      handle=Dsp_LoadSubroutine(ptr,size,ability);
      status=Dsp_RunSubroutine(handle);
      Dsp_DoBlock(data_in,size_in,data_out,size_out);
      Dsp_Unlock();
      }

Une fa‡on plus efficace d'executer un sous-programme peut ˆtre de v‚rifier
d'abord si le sous_programme existe d‚j… dans la m‚moire du DSP.

   if (!Dsp_Lock())
      {
      handle=Dsp_InqSubrAbility(ability);
      if (handle)
	 {
	 status=Dsp_RunSubroutine(handle);
	 Dsp_DoBlock(data_in,size_in,data_out,size_out);
	 Dsp_Unlock();
	 }
      }

Identification des programmes (ability)
---------------------------------------

L'identification d'un programme (et d'un sous-programme) doit ˆtre
fournie au systˆme lors du chargement d'un process dans la m‚moire DSP.
Cette identification est soit une identification pr‚d‚finie et qui a 
‚t‚ enregistr‚e auprŠs d'Atari ou une identification unique qui a ‚t‚
r‚cup‚r‚e lors d'un appel … la fonction Dsp_RequestUniqueAbility.
Cette identification peut ˆtre utilis‚e pour d‚terminer si l'application
doit recharger le process DSP ou s'il existe d‚j… dans la m‚moire DSP.
Une fois charg‚s, les programmes DSP sont accessibles … toutes les
applications qui veulent les utiliser.


Fonctions de transfert
~~~~~~~~~~~~~~~~~~~~~~

Fonction 96 : Dsp_DoBlock
-------------------------
Dsp_DoBlock(char *data_in,long size_in,char *data_out,long size_out)

Dsp_DoBlock transfert un bloc de donn‚es entre l'application et le
processus dans le DSP. Les donn‚es point‚es par data_in vont ˆtre 
transf‚r‚es … raison de "size_in" mots DSP (le nombre d'octets contenus
dans un mot DSP est retourn‚ par la fonction Dsp_GetWordSize). Il est
important de noter qu'aucun handchecking ne sera effectu‚ durant le
transfert, il est suppos‚ que le DSP est capable d'accepter les donn‚es
… la vitesse o— elles sont envoy‚es. La fonction va attendre que le 
1er mot soit accept‚ par le DSP avant de commencer le transfert. AprŠs
que toutes les donn‚es aient ‚t‚ transf‚r‚es au DSP, la fonction va
attendre jusqu'… ce que le DSP ait fini de traiter les donn‚es et soit
prˆt … en renvoyer … l'application (quand le bit RXDF du registre ISR
est mis). A ce moment, "size_out" mots sont lus du DSP et stock‚s dans
le buffer point‚ par "data_out". Une fois encore, aucun handchecking
n'est effectu‚. Si aucune donn‚e n'est attendue de la part du DSP,
un z‚ro doit ˆtre plac‚ dans size_out. De mˆme, si aucune donn‚e ne
doit ˆtre envoy‚e, un z‚ro doit ˆtre plac‚ dans size_in. Size_in et
size_out sont des longs mots qui indiquent la taille du tableau, en
aucun cas, ils ne doivent d‚passer 64 Ko.

Fonction 97 : Dsp_BlkHandShake
------------------------------
Dsp_BlkHanShake (char *data_in,long size_in,char *data_out,long size_out)

Cette fonction est identique … la pr‚c‚dente, … cette diff‚rence prŠs
qu'une phase de handchecking a lieu durant le transfert du bloc. Cette
fonction est plus lente que Dsp_DoBlock et doit seulement ˆtre utilis‚
lorsque la routine doit emettre/recevoie des donn‚es plus rapidement
que le processus DSP peut le faire. Size_in et size_out sont deux
long mots qui indiquent la taille du tableau. Ils ne peuvent d‚passer 64Ko.

Fonction 98 : Dsp_BlkUnpacked
-----------------------------
Dsp_Unpacked(long *data_in,long size_in,long *data_out,long size_out)

Dsp_BlkUnpacked est une autre fonction de transfert de bloc qui travaille
de maniŠre similaire … Dsp_DoBlock. Cette routine fonctionne seulement
sur les versions de TOS dont la fonction Dsp_GetWordSize renvoie une
valeur inf‚rieure ou ‚gale … 4. Data_in et data_out sont des tableaux de
longs mots de 32 bits. Size_in et size_out sont le nombre de longs
mots des tableaux et le nombre de mots DSP … transferer. Les donn‚es
sont cadr‚es sur les octets de poids faible et envoy‚s au DSP, de mˆme
les donn‚es venant du DSP sont plac‚es dans les octets de poids faible
du tableau size_out. Par exemple, si Dsp_GetWordSize renvoie 3 (24 bits),
les 24 bits les plus faibles de chaque long mot contiendront les donn‚es
DSP tandis que les 8 bits les plus forts contiendront des valeurs sans
importance. (Note: Ces 8 bits ne contiendront pas n‚cessairement z‚ro).
Size_in et size_out sont des longs mots qui indiquent la taille des
tableaux qui ne doit pas d‚passer 64 Ko.

Fonction 123 : Dsp_BlkWords
---------------------------
Dsp_BlkWords(int *data_in,long size_in,int *data_out,long size_out)

Dsp_BlkWords envoie ou re‡oit des blocs de mots sign‚s sur 16 bits.
Les mots ont leur signe ‚tendu avant d'ˆtre transf‚r‚s. Data_in et
data_out sont des tableaux de mots de 16 bits. Size_in et size_out
indiquent la taille des tableaux qui sont limit‚s … 64 Ko.

Fonction 124 : Dsp_BlkBytes
---------------------------
Dsp_BlkBytes(char *data_in,long size_in,char *data_out,long size_out)

Dsp_Blkbytes envoit ou re‡oit des octets. Le signe des octets n'est
pas ‚tendu avant le transfert. Data_in et data_out sont des tableaux
d'octets et size_in et size_out indiquent la taille des tableaux
limit‚s … 64 Ko.

Fonction 127 : Dsp_MultBlocks
-----------------------------
Dsp_MultBlocks(long numsend,long numreceive,struct dspblock sendblocks[],
	       struct dspblock receiveblocks[]);

struct dspblock
  {
  int	blocktype;    
  long	blocksize;
  long	blocaddr;
  }

Dsp_MultBlocks peut ˆtre utilis‚ pour envoyer et recevoir plusieurs blocs
de donn‚es au DSP en utilisant un seul appel Trap. Les paramŠtres
numsend et numreceive repr‚sentent le nombre d'‚l‚ments dspblock …
lire ou … ‚crire. Sendblocks et receiveblocks sont les adresses de deux
tableaux de dspblock qui contiennent les donn‚es … envoyer ou recevoir
du DSP. Un bloc dspblock est compos‚ du type de bloc, de sa taille et
de l'adresse du bloc. Le type de bloc indique au systˆme quel type de
donn‚e va ˆtre contenu dans le bloc. (0 = long, 1 = entier 16 bits sign‚s,
2 = octets non sign‚s). Blocksize est le nombre de blocs … transmettre
ou recevoir. Blocaddr est un pointeur sur le buffer de reception / emission.

Fonction 99 : Dsp_InStream
--------------------------
Dsp_InStream(char *data_in,long block_size,long num_blocks,long *blocks_done);

Dsp_InStream va transmettre des donn‚es d'un buffer vers le DSP via une
interruption. Chaque fois que l'interruption se produit en indiquant …
la routine que le DSP est prˆt pour recevoir d'autres donn‚es, block_size
mots seront transmis au DSP. Durant le transfert, aucun handchecking
ne sera effectu‚. La routine continuera … g‚n‚rer des interruptions
jusqu'… ce que "num_blocks" blocs soient effectivement transferr‚s vers
le DSP. A ce moment la routine d'interruption avertira le DSP pour
qu'il stoppe d'attendre la reception. Dsp_InStream actualise un pointeur
(blocks_done) pour que la routine d'appel puisse savoir combien de
blocs ont ‚t‚ transferr‚s. La routine d'appel peut v‚rifier p‚riodiquement
cette valeur pour voir si la transmission est termin‚e. Lorsqu'une trans-
mission est faite de fa‡on continue, il vaut mieux pr‚f‚rer cette fonction
… la fonction Dsp_DoBlock, cette derniŠre sera utilis‚e si un gros bloc
de donn‚es est … transmettre de fa‡on ponctuelle.

Fonction 100 : Dsp_OutStream
----------------------------
Dsp_OutStream(char *data_out,long block_size,long num_blocks,long *blocks_done);

Dsp_OutStream va remplir un buffer point‚ par data_out via une interruption
DSP. L'appel est similaire … Dsp_InStream except‚ que les donn‚es sont
transferr‚es du DSP vers le buffer … chaque interruption.
 
Fonction 101 : Dsp_IOStream
---------------------------
Dsp_IOStream(char *data_in,char *data_out,long block_insize,
	     long block_outsize,long num_blocks,long *blocks_done)

Dsp_IOStream est une forme sp‚cialis‚e des deux fonctions pr‚c‚dentes.
Elle combine les deux pr‚c‚dentes et permet ainsi d'‚conomiser une
interruption. Lorsque cette fonction est appel‚e la premiŠre fois, un
premier bloc est envoy‚ vers le DSP, puis … chaque interruption, 
un bloc est lu du DSP puis un lui est envoy‚. Les paramŠtres pass‚s
sont les mˆmes que dans les fonctions pr‚c‚dentes. Data_in et Data_out
indiquent les buffers d'entr‚e et de sortie. Bloc_insize et bloc_outsize
indiquent la taille des blocs en mots DSP. Num_blocks est le nombre de
blocs … transferrer et blocks_done pointe sur une valeur qui indique
de maniŠre continue le nombre de blocs qui ont ‚t‚ transferr‚es.

Fonction 126 : Dsp_SetVectors
-----------------------------
Dsp_SetVectors(void (*receiver),long (*transmitter))

Dsp_SetVectors permet … l'application d'installer une fonction qui va
ˆtre appel‚e quand une interruption est re‡ue du DSP. Receiver doit
pointer sur une fonction qui va ˆtre appel‚e quand le DSP aura envoy‚
des donn‚es vers l'application. Transmitter doit pointer vers une
routine qui sera appel‚ en interruption lorsque le DSP demandera des
donn‚es. Si transmitter renvoie une valeur diff‚rente de z‚ro, les trois
octets de poids faible du mot long seront envoy‚s au DSP (comme vu
pr‚c‚demment), aucune donn‚e ne sera transmise si le mot de 32 bits
retourn‚ vaut 0. (Pour envoyer un 0 au DSP, placez une valeur diff‚rente
de 0 dans l'octet sup‚rieur). Si receiver ou transmitter valent 0L,
l'interruption correspondante sera inhib‚e. L'application doit enlever
ses interruptions en utilisant la fonction Dsp_RemoveInterrupts.

Fonction 102 : Dsp_RemoveInterrupts
-----------------------------------
Dsp_RemoveInterrupts(int mask)

Dsp_RemoveInterrupts va avertir le DSP d'arrˆter de g‚n‚rer des
interruptions lors de l'emission ou de la reception. Mask est un masque
de 8 bits qui repr‚sente l'interruption … stopper. 

1 -> Pas d'interruption quand le DSP est prˆt … ‚mettre.
2 -> Pas d'interruption quand le DSP est prˆt … recevoir.
3 -> Supprime les deux types d'interruptions.

Fonction 103 : Dsp_GetWordSize
------------------------------
int Dsp_GetWordSize(void)

Dsp_GetWordSize renvoie le nombre d'octets contenus dans un mot DSP.
Il est important pour les applications d'utiliser cette fonction pour
d‚terminer certaines valeurs comme la taille des buffers et la taille
des blocs. La valeur retourn‚e par cette routine pourrait changer dans
des versions futures du Falcon.
			      
Fonctions de controle des programmes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fonction 104 : Dsp_Lock
-----------------------
int Dsp_Lock(void)

Dsp_Lock doit ˆtre appel‚ avant tout autre appel … l'une des fonctions
de la librairie DSP. Cette fonction est utilis‚e par les applications
pour locker le DSP et pour savoir si il l'est d‚j… ou non. Si la fonction
retourne -1, le DSP est d‚j… lock‚, si elle retourne 0, le DSP est libre,
vous pouvez donc effectuer une autre fonction DSP. Le DSP sera lock‚
jusque ce que la fonction Dsp_Unlock soit appel‚e.

Fonction 105 : Dsp_Unlock
-------------------------
void Dsp_Unlock(void)

Dsp_Unlock doit ˆtre utilis‚ en conjonction avec Dsp_Lock (d‚crit 
pr‚c‚demment). Un appel … cette fonction indique au systˆme que vous
avez fini d'utiliser le DSP et qu'une autre application peut en disposer.

Fonction 106 : Dsp_Available
----------------------------
void Dsp_Available(long *xavailable,long *yavailable)

Dsp_Available renvoie la m‚moire disponible dans le DSP (voir le para-
graphe sur l'organisation de la m‚moire). xavailable contient la
m‚moire disponible X et yavailable la m‚moire disponible Y. L'espace
m‚moire disponible commence toujours pour X et Y … l'adresse 0.
Souvenez vous que l'espace programme recouvre les espaces m‚moires X et Y,
les 64 mots les plus bas de la m‚moire Y sont utilis‚s pour les vecteurs
d'interruption.

Fonction 107 : Dsp_Reserve
--------------------------		       
int Dsp_Reserve(long xreserve,long yreserve)

Dsp_Reserve r‚serve de la m‚moire pour un programme DSP. L'espace
m‚moire demand‚ ne doit pas d‚passer la taille renvoy‚e par
Dsp_Available. Cette fonction doit ˆtre appel‚e pour ˆtre sur que
votre programme DSP ne sera pas ‚cras‚ par un sous-programme DSP.
Cette m‚moire r‚serv‚e le sera tant qu'un autre appel Dsp_Reserve ne
sera pas fait. Cela permet … un programme DSP de rester r‚sident.
Xreserve indique l'espace … reserver dans la m‚moire X et yreserve
dans la m‚moire Y. Si la fonction renvoie 0, il n'y a pas eu d'erreur.
Si elle renvoie -1, une erreur s'est produite dans la r‚servation.

Note : Les fonctions Dsp_Available et Dsp_Reserve sont impl‚ment‚s
       uniquement pour r‚soudre les conflits entre les programmes et
       les sous-programmes. La pr‚sence de ces fonctions dans le
       systˆme d'exploitation ne signifie pas qu'il existe un systˆme
       de gestion de la m‚moire dans le DSP. La fonction Dsp_Available
       renvoie la m‚moire disponible pour les programmes qui n'est
       pas actuellement occup‚e par des sous-programmes. La valeur
       retourn‚e par cette fonction ne tient pas compte de la m‚moire
       pr‚cedemment r‚serv‚e par Dsp_Reserve. Cette espace m‚moire
       est susceptible d'ˆtre modifi‚ si un sous-programme est charg‚
       dans la m‚moire DSP. La fonction Dsp_Reserve est utilis‚e 
       uniquement pour savoir si il y a assez de m‚moire disponible
       pour charger le programme. La quantit‚ de m‚moire reserv‚e pour
       les programmes peut simplement ˆtre chang‚e par un autre appel
       Dsp_Reserve avec plus ou moins de m‚moire.

Fonction 108 : Dsp_LoadProg
---------------------------
int Dsp_LoadProg(char *file,int ability,char *buffer)

Dsp_LoadProg va charger … partir du disque un programme … executer par
le DSP. Le programme doit ˆtre au format ascii ".LOD" et ne peut exc‚der
l'espace m‚moire retourn‚ par la fonction Dsp_Reserve. File est un
pointeur sur le nom du fichier. Ability est un code sur 16 bits qui
d‚crit le programme (identificateur). Buffer pointe sur un bloc de
m‚moire o— le loader va pouvoir placer le code DSP qu'il va g‚n‚rer. La
taille du buffer peut ˆtre calcul‚ par la formule :
3*(3*(Nbre+1 de blocs dans le programme) + Nbre de mots programme&donn‚es).
Si la fonction retourne 0, aucune erreur ne s'est produite, si la
fonction renvoie -1, une erreur s'est produite avant que le programme
puisse ˆtre execut‚.

Fonction 109 : Dsp_ExecProg
---------------------------
Dsp_ExecProg(char *codeptr,long codesize,int ability)

Dsp_ExecProg execute un programme DSP qui se trouve en m‚moire au
format binaire. Cette fonction est plus rapide que Dsp_LoadProg puisqu'elle
n'a pas … lire le fichier sur disque et n'a pas … le convertir au format
binaire. Codeptr doit pointer sur un bloc de code DSP binaire. Codesize
indique le nombre d'octets … transf‚rer depuis ce bloc vers le DSP.
Le paramŠtre ability identifie le programme. Codesize ne doit pas 
d‚passer la taille m‚moire r‚serv‚e avec Dsp_Reserve.

Fonction 110 : Dsp_ExecBoot
---------------------------
Dsp_ExecBoot(char *codeptr,long codesize,int ability)

Dsp_Execboot va charger dans les 512 mots de la m‚moire interne du DSP
un programme de boot. Un reset du DSP doit ˆtre fait avant de charger
ce programme. Ce programme doit fonctionner soit comme un programme …
part entiŠre soit ˆtre utilis‚ pour charger un programme plus grand.
Notez que cette fonction existe uniquement pour des tests lors du
d‚veloppement. SEULS LES DEBUGGERS OU LES PROGRAMMES SIMILAIRES QUI
VEULENT PRENDRE LE CONTROLE TOTAL DU DSP DOIVENT UTILISER CETTE
FONCTION. Les applications doivent utiliser Dsp_LoadProg et Dsp_ExecProg.
Codeptr pointe sur un bloc de code binaire DSP. Codesize indique
le nombre d'octets … transf‚rer depuis ce bloc vers le DSP. Seuls les
512 premiers mots de ce code vont ˆtre transf‚r‚s.

Fonction 111 : Dsp_LodToBinary
------------------------------
long Dsp_LodToBinary(char *file,char *codeptr)

Dsp_LodToBinary lit le fichier ".LOD" point‚ par file. La fonction
convertit ensuite le fichier au format binaire pour ˆtre utilis‚ par
les fonctions Dsp_ExecBoot ou Dsp_ExecProg. Codeptr pointe sur un
bloc de m‚moire qui est assez large pour que la fonction y place le
code binaire. La fonction renvoie la taille du programme en mots DSP.
Un nombre n‚gatif indique qu'une erreur s'est produite durant la
conversion.

Fonction 112 : Dsp_TriggerHC
----------------------------
Dsp_TriggerHC(int vector)

Seuls deux vecteurs HC sont disponibles par les programmes DSP. (Ce
sont les vecteurs $13 et $14). Tous les autres vecteurs sont utilis‚s
par le systˆme et les sous-programmes DSP. Notez que lorsqu'un programme
est charg‚ pour ˆtre ex‚cut‚, la table des vecteurs est automatiquement
recharg‚e. Tous les vecteurs except‚s les vecteurs $13 et $14 vont ˆtre
r‚‚crits par le systˆme.

Fonction 113 : Dsp_RequestUniqueAbility
---------------------------------------
int Dsp_RequestUniqueAbility(void)

Dsp_RequestUniqueAbility permet … une application d'identifier de
fa‡on unique leur programme DSP. La valeur renvoy‚e par la fonction
est un identificateur qui est unique pour la session courante. L'utilisation
de cette valeur avec des fonctions comme Dsp_InqSubrAbility permet
… l'application de d‚terminer si le code est d‚j… r‚sident dans la DSP
et ‚vite ainsi … le recharger.

Fonction 114 : Dsp_GetProgAbility
---------------------------------
int Dst_GetProgAbility(void)

Dsp_GetProgAbility renvoie l'identificateur du programme actuellement
r‚sident dans le DSP. Cet identificateur permet de d‚terminer si un
autre programme va devoir ˆtre charg‚ dans le DSP ou si celui qui s'y
trouve d‚j… pourra effectuer la tƒche demand‚e.

Fonction 115 : Dsp_FlushSubroutines
-----------------------------------
void Dsp_FlushSubroutines(void)

Dsp_VoidFlushSubroutines doit ˆtre appel‚ si l'application a besoin
de plus de m‚moire que celle renvoy‚e par Dsp_Available. Quand cet
appel est fait, tous les sous programmes actuellement r‚sidents dans
le DSP seront effac‚s et la m‚moire qui leur ‚tait allou‚e sera lib‚r‚e.
Dsp_Available peut alors ˆtre appel‚ de nouveau pour d‚terminer la
m‚moire totale disponible. Dans la mesure du possible, les applications
devront tenter d'utiliser la m‚moire disponible et ‚viter d'utiliser
cette fonction. Les performances g‚n‚rales du systˆme seront meilleures
si les programmes DSP utilis‚s fr‚quement restent dans le DSP au lieu
d'y ˆtre souvent charg‚s.

Fonction 116 : Dsp_LoadSubroutine
---------------------------------
int Dsp_LoadSubroutine(char *ptr,long size,int ability)

Dsp_LoadSubroutine va installer un sous-programme DSP en m‚moire DSP
pour ˆtre utilis‚ plus tard. Ptr doit pointer sur un bloc de code DSP.
Ce code doit respecter les indications sp‚cifi‚es dans le paragraphe
"sous-programme DSP". La taille de ce sous-programme ainsi que son
identificateur sont pass‚s respectivement dans les paramŠtres size
et ability. La fonction renvoie un handle positif si le sous programme
a ‚t‚ correctement install‚. Un handle ‚gal … z‚ro sera renvoy‚ si
la fonction n'a pas r‚ussi l'installation. Le sous-programme restera
r‚sident dans le DSP jusqu'… ce que tous les emplacements disponibles
pour les sous-programmes soient occup‚s et qu'ils soient remplac‚s par
d'autres sous-programmes. Il peut aussi ˆtre effac‚ par la fonction
Dsp_FlushSubroutines.

Fonction 117 : Dsp_InqSubrAbility
---------------------------------
int Dsp_InqSubrAbility(int ability)

Dsp_InqSubrAbility renvoie le handle d'un sous-programme install‚
si l'identificateur du sous-programme correspond … l'identificateur
pass‚ en paramŠtre. Rechercher un sous-programme qui existe d‚j… en
m‚moire permet d'‚viter … l'y charger … nouveau d'o— un gain de temps.
Si le systˆme ne trouve pas le sous-programme DSP, la fonction retourne
un z‚ro. Dans ce cas, il faut utiliser la fonction Dsp_LoadSubroutine
pour installer ce sous-programme.

Fonction 118 : Dsp_RunSubroutine
--------------------------------
int Dsp_RunSubroutine(int handle)

Dsp_RunSubroutine ex‚cute un sous-programme DSP r‚sident identifi‚ par
un handle. Avant que cet appel soit fait, le sous-programme aura du ˆtre
identifi‚ grƒce aux fonctions Dsp_iInqSubrAbility ou Dsp_LoadSubroutine.
La valeur renvoy‚e permet de savoir si le sous-programme a ‚t‚ correctement
lanc‚. Une valeur n‚gative signifie une erreur. Un z‚ro signifie que
l'ex‚cution a ‚t‚ correctement r‚alis‚e.

Fonction 119 : Dsp_Hf0
----------------------
int Dsp_Hf0(int flag)

Dsp_Hf0 va lire ou ‚crire le bit 3 du HSR. Si flag est soit un z‚ro soit
un 1, la valeur de flag sera ‚crite dans le bit HSR. Si flag contient
0xFFFF, la fonction va renvoyer la valeur du bit 3 du HSR (soit 1 soit 0)
sans changer sa valeur.

Fonction 120 : Dsp_Hf1
----------------------
int Dsp_Hf1(int)

Dsp_Hf1 est identique … la fonction pr‚c‚dente mais agit sur le bit 4.

Fonction 121 : Dsp_Hf2
----------------------
int Dsp_Hf2(void)

Renvoie la valeur du bit 3 du HCR. Notez que ce bit peut seulement ˆtre
lu par l'application et pas ‚crit.

Fonction 122 : Dsp_Hf3
----------------------
int Dsp_Hf3(void)

Idem … la fonction pr‚c‚dente mais renvoie la valeur du bit 4 du HCR.

Fonction 125 : Dsp_Hstat
------------------------
char Dsp_HStat(void)

Dsp_HStat renvoie la valeur du port DSP ISR. Cette fonction permet
… l'application de savoir si le port h“te est prˆt … transmettre
ou … recevoir. R‚f‚rez vous au manuel du DSP56000 pour avoir une
description du registre ISR.

***********
* ANNEXES *
***********


Interruptions
~~~~~~~~~~~~~

Niveau	      Priorit‚
7 (+ haute)   Bus
6	      Interruptions MFP et DSP
5	      IC r‚seau 85C30
4	      Signal VSYNC (VBL)
3	      Bus
2	      Signal HSYNC (HBL)
1	      Bus

Matrix coupling
~~~~~~~~~~~~~~~

To make the system performance in the audio part as good as possible Atari
designed a miniature 'telephone exchange' that can easily connect the
source devices to the receiving devices. Also it is possible to make more
than one connection at a time.


    Source devices

	EXT INPUT ---*-------*------*------*
	 CHANNEL     |	     |	    |	   |
		     |	     |	    |	   |
	   DSP	  ---*-------*------*------*
	TRANSMIT     |	     |	    |	   |
		     |	     |	    |	   |
	   ADC	  ---*-------*------*------*
		     |	     |	    |	   |
		     |	     |	    |	   |
	   DMA	  ---*-------*------*------*
	PLAYBACK     |	     |	    |	   |
		    DMA     DAC    DSP	   EXT OUTPUT
		   RECORD	 RECEIVE     CHANNEL

			Receiving Devices


Ports and interfacing
~~~~~~~~~~~~~~~~~~~~~~

DSP CONNECTOR (DB26 Female)
---------------------------

Pin   Signal			       Pin   Signal

1     GP0			       14    GND
2     GP1			       15    SRD
3     GP2			       16    GND
4     P_DATA			       17    +12V
5     P_CLK			       18    GND
6     P_SYNC			       19    R_DATA
7     n/c			       20    R_CLK
8     GND			       21    R_SYNC
9     +12V			       22    EXT_INT
10    GND			       23    STD
11    SC0			       24    SCK
12    SC1			       25    GND
13    SC2			       26    EXCLK			   


SCSI CONNECTOR (flat 50 pins SCSI II Female)
--------------------------------------------

Pin   Signal			       Pin   Signal

1-10  GND			       37    Not Connected
11    +5V			       38    +5V
12-14 Not Connected		       39    Not Connected
15-25 GND			       40    GND
26    SCSI 0			       41    ATN
27    SCSI 1			       42    GND
28    SCSI 2			       43    BSY
29    SCSI 3			       44    ACK
30    SCSI 4			       45    RST
31    SCSI 5			       46    MSG
32    SCSI 6			       47    SEL
33    SCSI 7			       48    C/D
34    Parity			       49    REQ
35-36 GND			       50    I/O


SERIAL PORT (DB9 MALE)							       
----------------------

Pin   Signal

1     Carrier Detect		       5     GND
2     Receive			       6     Data set ready
3     Transmit			       7     Request to Send
4     Data Terminal Ready	       8     Clear to Send
				       9     Ring Indicator

PARALLEL PORT (DB25 Female)
---------------------------

The parallel port has extra signal to ease the connection of scanners.

Pin   Signal

1     Strobe	      8     Data 6
2     Data 0	      9     Data 7
3     Data 1	     10     Acknowledge
4     Data 2	     11     Busy
5     Data 3	     12-16  Not Connected
6     Data 4	     17     Select
7     Data 5	     18-25  GND


MONITOR CONNECTOR (DB19 Male)
-----------------------------

Pin   Signal			       Pin   Signal

1     Red			       11    GND
2     Green			       12    Composite Sync/Video
3     Blue			       13    Horizontal Sync
4     Mono/Overlay		       14    Vertical Sync
5     GND			       15    External Clock Input
6     Red GND			       16    External SYNC Enable
7     Green GND 		       17    +12V
8     Blue GND			       18    M1
9     Audio out 		       19    M0
10    GND


SCC LAN-port CONNECTOR (8-pin Mini DIN Female RS-422)
-----------------------------------------------------

Pin   Signal

1     Handshake Output (DTR RS 423)	      5     - Received Data
2     Handshake Input or External Clock       6     + Transmitted Data
3     - Transmit Data			      7     General-purpose Input
4     GND				      8     + Receive


ENHANCED JOYSTICK (DB15 Male)
-----------------------------

Port A				       Port B
------				       ------

Pin   Signal			       Pin   Signal

1     UP 0			       1     UP 1
2     DOWN 0			       2     DOWN 1
3     LT 0			       3     LT 1
4     RT 0			       4     RT 1
5     PAD0Y			       5     PAD1Y
6     FIRE 0 / LIGHT GUN	       6     FIRE 1
7     VCC (+5 VDC)		       7     VCC
8     Not Connected		       8     Not Connected
9     GND			       9     GND
10    FIRE 2			       10    FIRE 3
11    UP 2			       11    UP 3
12    DOWN 2			       12    DOWN 3
13    LT 2			       13    LT 3
14    RT 2			       14    RT 3
15    PAD0X			       15    PAD1X		      


MIDI PORT (DIN 5 Female)
------------------------

MIDI OUT			       MIDI  IN
--------			       --------

Pin   Signal			       Pin   Signal

1     Thru Transmit		       1     Not Connected
2     GND			       2     Not Connected
3     Thru Loop Return		       3     Not Connected
4     Out Transmit		       4     In Receive
5     Out Loop Return		       5     In Loop Return
