
   NKCC - NORMALIZED KEY CODE CONVERTER
   =============================================================================
   Version 2.93

   von Harald Siegmund                                  Copyright (c) 1989-1995

   Die NKCC Library ist Freeware. Das Archiv darf nur in unverÑnderter Form
   weitergegeben werden. Wird NKCC in einer Applikation eingebaut, so bitte
   ich um einen kurzen Vermerk im Info-Dialog (z.B. "NKCC Tastaturroutinen
   von Harald Siegmund" oder Ñhnliches). Vielen Dank!

   -----------------------------------------------------------------------------
   History:

   1989:
      14. Mai: erste Version (NKCC 1.00)

      ... (ich hatte keine Lust, die englischsprachige History zu Åbersetzen;
           wen's interessiert, kann die fehlenden EintrÑge in ENGLISH.DOC
           nachlesen)

   1995:
      31. Okt: öbersetzung der Dokumentation ins Deutsche.
               Korrektur in der Beschreibung des Tastenformats: die Bit-Nummern
                von NKF_LSH und NKF_RSH waren falsch angegeben.
       9. Nov: Version 2.93:
               Die zusÑtzlichen Tasten auf der Mac-Tastatur werden nun
               unterstÅtzt.

   -----------------------------------------------------------------------------
   Entwickleradresse:

   adequate systems
   Gesellschaft fÅr angemessene Systemlîsungen mbH
   z.Hd. Harald Siegmund
   Brauereistr. 2
   D-67549 Worms

   E-mail : Harald_Siegmund@kl.maus.de (Internet-Adresse)
   Mausnet: Harald Siegmund@KL
   -----------------------------------------------------------------------------
   Neue Versionen von NKCC werden immer abgelegt in:

   Maus KL (0631-17901)       !! Programmteil fÅr Nichtzahler gesperrt !!
   Archiv NKCC.LZH            !! von 7 - 9 und 17 - 19 Uhr             !!

   FTP server  ftp.uni-kl.de  [131.246.94.94]
         File  pub/atari/programming/nkcc.lzh

   =============================================================================
   Inhalt:

   1. Was ist eigentlich NKCC?
   2. Dateien, die zum Paket gehîren
   3. Das normalisierte Tastenformat
   4. Wie wird NKCC aufgerufen?
   5. NKCC in TOS-Applikationen
   6. NKCC in GEM-Applikationen
   7. Der Button Event Handler
   8. Sonstige Funktionen
   9. Symboltabelle



   1. Was ist eigentlich NKCC?
   =============================================================================
   NKCC ist ein NME-Produkt (Not macht erfinderisch), daû bei dem verzweifelten
   Versuch entstanden ist, eine flexible und lÑnderunabhÑngige Tastenmakro-
   verwaltung zu schreiben. Vorgabe war, mîglichst *alle* Kombinationen von
   Shift (links/rechts), Control und Alternate mit einer anderen Taste
   erfassen zu kînnen, unabhÑngig davon, ob die Applikation auf einem
   deutschen, saudi-arabischen, islÑndischen oder wasauchimmer-TOS mit
   entsprechender Tastenbelegung lÑuft.

   Kein Problem? Von wegen! Wenn man sich die von TOS/GEM zurÅckgelieferten
   Tastencodes anschaut, kann einem das kalte Grauen kommen:

   a) Alternate plus eine Buchstabentaste liefert lediglich den Scancode des
      Taste zurÅck, der von der Belegung der Tastatur (Landessprache!)
      abhÑngt. Als ASCII-Code meldet das OS immer eine 0.

   b) Bei einigen Tasten variiert der Scancode abhÑngig davon, welche
      Zusatztasten gedrÅckt sind! Ein Beispiel: auf der deutschen
      Tastatur hat die Taste "1 !" den Scancode 2. Wird zusÑtzlich Alternate
      gedrÅckt, Ñndert sich der Scancode zu $78 und als ASCII-Code erhÑlt
      man eine Null.

   c) Der Cursortastenblock ist eine einzige Katastrophe. Hier kann man nur
      darauf hoffen, daû auf allen Tastaturen die gleichen Scancodes
      geliefert werden. Bei einigen Tasten - nicht allen - Ñndert sich der
      Scancode, wenn zusÑtzlich Control gedrÅckt wird! Der ASCII-Code hÑngt
      vom Zustand der Zusatztasten (Shift, Control) sowie der aktuellen
      Mondphase ab und spottet jeder Regel.

   d) Einige Tastenkombinationen lassen sich so ohne weiteres gar nicht
      auseinanderhalten, da sie den gleichen Tastencode produzieren.
      So sind in den meisten FÑllen die Tastencodes fÅr Alternate+irgendeine
      Taste identisch mit Alternate+Shift+irgendeine Taste.

   Die Lîsung fÅr all diese Probleme heiût NKCC.

   Ok, nicht ganz so dramatisch:
   *Eine* Lîsung fÅr all diese Probleme heiût NKCC. ;-)

   Die Hauptaufgabe von NKCC liegt in der Konvertierung von Tastencodes in
   ein sinnvolles, scancode- und damit landesspracheunabhÑngiges Format.
   Mit NKCC kînnen praktisch alle Tastenkombinationen unterschieden werden.
   Ausnahmen bilden lediglich jene Kombinationen, die zu Sonderzwecken
   im Betriebssystem eingesetzt werden (zum Bleistift das altbekannte
   Alternate+Help, das die Hardcopy-Routine des Systems anwirft).

   So nebenbei hat NKCC noch einige Zusatzfunktionen in petto:

   a) Deadkeys

      Mit diesem Mechanismus ist es mîglich, defekte Tasten wiederzubeleben.
      Scherz beiseite: Deadkeys braucht man, um akzentuierte Zeichen einzugeben,
      die nicht auf der Tastatur anzutreffen sind. Der Mechanismus funktioniert
      so: als erstes wird die Akzent-Taste gedrÅckt. NKCC liefert diese nicht
      sofort an die Applikation, sondern wartet erst einmal auf die nÑchste
      Taste. Das heiût, bei der Eingabe der Akzent-Taste passiert erst einmal
      gar nichts, deshalb der Name "Deadkey" ("tote Taste"). Wenn der nÑchste
      Tastencode ankommt, versucht NKCC die Akzent-Taste damit zu verbinden
      und einen einzigen Tastencode zu erzeugen, der dann an die Applikation
      gemeldet wird. Ist eine Kombination nicht mîglich, so werden beide
      Codes nacheinander unverÑndert zurÅckgegeben. Hier ein Beispiel:

      ~   danach   A   wird verschmolzen zu   ∑
      ~   danach   X   kommen als   ~   und   X   aus NKCC heraus, da es kein
                                                  X mit Akzent Tilde gibt

      NKCC unterstÅtzt folgende Deadkeys:

      ^   +   aeiou      =  Éàåìñ            Akzent Circumflex
      ~   +   nNaoAo     =  §•∞±∑∏           Akzent Tilde
      '   +   eEaiou     =  Çê†°¢£           Akzent Akut
      `   +   aeiouA     =  Öäçïó∂           Akzent Gravis
      π   +   aeiouyAOU  =  ÑâãîÅòéôö        Akzent Umlaut
      "   +   aeiouyAOU  =  ÑâãîÅòéôö        Akzent Umlaut (*)
      ¯   +   aA         =  Üè               Akzent Angstrîm
      ,   +   cC         =  áÄ               Akzent Cedille
      /   +   oO24       =  ≥≤´¨             kein Akzent, trotzdem nÅtzlich

      (*) Das AnfÅhrungszeichen (") wird als Synonym fÅr die Umlautpunkte (π)
          verwendet. So gibt es z.B. auf einer hollÑndischen Tastatur weder
          das Umlautzeichen noch Umlaute.

   b) Direkte Eingabe von ASCII-Codes

      Das funktioniert folgendermaûen: Alternate-Taste drÅcken und halten,
      dann auf der Zehnertastatur den ASCII-Code eingeben. Nach Eingabe von
      drei Ziffern oder Loslassen der Alternate-Taste wird ein Tastencode
      produziert, der den eingegebenen ASCII-Code enthÑlt. Bei Werten Åber
      255 werden die oberen Bits abgeschnitten (bei Eingabe von 260 = $104
      erhÑlt man als ASCII-Code $04).

   c) Control Key Emulation

      Tastenkombinationen wie z.B. Control+A kommen normalerweise genauso
      aus NKCC heraus, d.h.: ASCII-Code = 65 ("A"), Control-Flag ist gesetzt.
      Mit der Control Key Emulation kann dieser Teil des Formatkonverters
      umgeschaltet werden. Anstelle von "Control + Taste" erhÑlt man dann
      einen ASCII-Code von 0 bis 31 *ohne* Control-Flag.

      Folgende Kombinationen werden von der Emulation beeinfluût:

      Control + @       ->    $00
      Control + A...Z   ->    $01...$1A
      Control + [       ->    $1B
      Control + \       ->    $1C
      Control + ]       ->    $1D
      Control + ^       ->    $1E
      Control + _       ->    $1F

      Achtung:

      Nicht alle Kombinationen sind auf allen Tastaturen verfÅgbar. Zum
      Beispiel ist es auf der deutschen Tastatur nicht mîglich, die
      Zeichen @ [ \ ] zusammen mit Control einzugeben. Das hat folgenden
      Grund: sobald die Control-Taste bei der Eingabe gedrÅckt wird,
      wird ein geschrotteter ASCII-Code vom Betriebssystem an NKCC Åbermittelt.
      Da diese Zeichen nur durch DrÅcken von Alternate erzeugt werden kînnen,
      steht ihr ASCII-Code aber auch nicht in einer der TOS-Tastaturtabellen.
      NKCC bleibt nichts anderes Åbrig, auf den ASCII-Code der Normalbelegung
      zurÅckzugreifen, d.h. einen der Umlaute. Dadurch spricht die Control
      Key Emulation natÅrlich nicht an.


   Jeder einzelne Deadkey sowie die anderen speziellen Features kînnen
   separat ein- und ausgeschaltet werden.


   Neugierig geworden? Das Programm DEMO.TOS zeigt, was NKCC aus
   TastendrÅcken so machen kann. Einfach starten und ein wenig auf
   der Tastatur klimpern.



   2. Dateien, die zum Paket gehîren
   =============================================================================
   Im NKCC-Archiv sollten folgende Files enthalten sein:

   READ_ME.TXT       die Datei, die eh niemand liest

   SOURCE\NKCC.S     der Quellcode von NKCC

   HEADERS\NKCC.I    ein Assembler Include-File mit globalen Definitionen
   HEADERS\NKCC.H    ein C Header-File mit globalen Definitionen

   LIB\NKCC.O        NKCC als linkfertiges Object File (DRI-Format)
   LIB\NKCC_TOS.O    NKCC ohne die GEM-Routinen und -Symbole als Object File

   DOC\NKCC.TXT      Auzug aus NKCC.S mit Dokumentation der Routinen
   DOC\GERMAN.DOC    die Datei, die Sie gerade lesen
   DOC\ENGLISH.DOC   die Doku in englischer Sprache
   DOC\NEWS.TXT      hier sind alle énderungen am NKCC-Paket dokumentiert

   DEMO\DEMO.C       Quellcode des Demo-Programms
   DEMO\DEMO.TOS     Demo-Programm



   3. Das normalisierte Tastenformat
   =============================================================================
   Tastencodes werden von NKCC als 16 Bit Integer zurÅckgeliefert. Im nieder-
   wertigen Byte steckt der ASCII-Teil des Tastencodes, das hîherwertige Byte
   enthÑlt eine Reihe von Flags. Die genaue Belegung sieht so aus:

   Bit         Symbolischer Name    Inhalt
   ------------------------------------------------------------
    0... 7                          ASCII-Code/Funktionscode
    8          NKF_RSH              Flag fÅr rechte Shift-Taste
    9          NKF_LSH              Flag fÅr linke Shift-Taste
   10          NKF_CTRL             Flag fÅr Control-Taste
   11          NKF_ALT              Flag fÅr Alternate-Taste
   12          NKF_CAPS             CapsLock-Status
   13          NKF_NUM              Flag: Zehnerblock
   14          NKF_RESVD            reserviert, muû ignoriert werden!
   15          NKF_FUNC             Funktionsflag

   Bit 8...11 geben an, ob die jeweilige Taste gedrÅckt war. In Bit 12 steht,
   ob CapsLock zur Zeit aktiv ist oder nicht. Ist Bit 13 gesetzt, befindet
   sich die Taste auf dem Zehnerblock. Bit 14 wird fÅr interne Zwecke
   verwendet und muû auf jeden Fall ignoriert werden. Achtung: im ersten
   Parameter der Funktion nkc_cmp() hat dieses Bit eine spezielle Bedeutung
   (siehe entsprechendes Kapitel).

   Schlieûlich gibt es noch Bit 15, daû angibt, ob es sich um eine
   funktionsbezogene Taste (Bit gesetzt) oder ein druckbares Zeichen (Bit
   gelîscht) handelt. Das Bit wird in folgenden FÑllen gesetzt:

   a) eine der folgenden "Funktionstasten" wurde gedrÅckt:

      Esc, Tab, Backspace, Delete, Return,
      Help, Undo, Insert, ClrHome, Cursor hoch, Cursor runter, Cursor links,
      Cursor rechts,
      Enter,
      F1, F2, F3, F4, F5, F6, F7, F8, F9, F10
      Page up, Page down, End, F11, F12, F14  (nur auf der Mac-Tastatur!)

      Der ASCII-Code solcher Tasten ist immer kleiner als 32 und als NK_...
      in den Header Files definiert (z.B. NK_ESC fÅr die Escape-Taste).

   b) irgendeine Taste wird zusammen mit Alternate und/oder Control gedrÅckt

      In diesem Fall wird immer die CapsLock-Version der Taste als ASCII-Teil
      zurÅckgeliefert. Zum Beispiel erhÑlt man bei Control+A als ASCII-Code
      ein "A" zurÅck, niemals ein "a".


   Das Funktionsflag steckt absichtlich in Bit 15, damit sich Tastencodes (die
   als signed 16 Bit Integer definiert sind) sehr einfach in die beiden
   Kategorien einordnen lassen:

   wenn Tastencode < 0
      dann handelt es sich um eine Funktion
   sonst
      handelt es sich um ein druckbares Zeichen

   Der ASCII-Code eines druckbaren Zeichens kann Åbrigens alle Werte von
   0 bis 255 enthalten.


   Einige Tastenkombinationen kînnen niemals von NKCC zurÅckgeliefert werden:

   a) Tasten, die vom System zurÅckgehalten werden. Dazu gehîren zum Beispiel:
      - Alternate + Cursortasten (dienen zur Maussteuerung)
      - Alternate + Help (startet den Hardcopy-Mechanismus)
      - Alternate + Control + Tab (schaltet unter MagiC den Task um)
      usw.

   b) Tasten, die beim Halten von Alternate andere Zeichen liefern. Dazu gehîren
      z.B. Alternate @ \ [ { ] } auf der deutschen Tastatur, die man durch
      DrÅcken von Alternate und/oder Shift sowie einer Umlauttaste erhÑlt.
      Der ASCII-Code wird korrekt zurÅckgeliefert, das Alternate-Flag wird aber
      nie gesetzt. So kann es z.B. die Tastenkombination "Alternate + @" auf
      der deutschen Tastatur nicht geben.

   Werden vom Deadkey-Handler oder durch Eingabe des ASCII-Codes auf der
   Zehnertastatur Zeichen erzeugt, dann kînnen nur das CapsLock- sowie das
   reservierte Flag in dem resultierenden Tastencode gesetzt sein. Alle anderen
   Flags sind immer 0. Analog dazu ist das Control-Flag immer gelîscht, wenn
   durch das Einschalten der Control Key Emulation ein druckbares Zeichen
   (z.B. Control A) erzeugt wird.



   Verarbeitung ungÅltiger Scancodes

   éltere Versionen von NKCC produzierten schlicht und ergreifend MÅll,
   wenn eine Taste mit einem ungÅltigen bzw. unbekannten Scancode vom
   Betriebssystem zurÅckgeliefert wurde. Ab Version 2.92 kommt NKCC auch
   mit solchen Tastencodes klar und konvertiert sie korrekt in das
   normalisierte Format. Dabei wird folgende Variation des Formats benutzt:

   Funktionsflag  = 1
   Alternate Flag = 0
   Control Flag   = 0
   ASCII code     >= 32

   Diese Kombinationen kînnen Åber die regulÑre Tastatur niemals produziert
   werden: es handelt sich um ein druckbares Zeichen, das als funktionelle
   Taste markiert ist, aber ohne Alternate und Control.

   Und wozu braucht man das? Nun, einerseits reagiert NKCC damit auf eine
   vernÅnftige Art und Weise auf unbekannte Scancodes. Andererseits lieûen
   sich damit sehr einfach die Makrotasten des Graphiktabletts einbinden,
   fÅr das ich im FrÅhjar '94 einen Treiber schrieb. :-) Dieser Treiber
   speist in den BIOS Tastaturpuffer Makrotasten ein, die folgendes
   Format haben:

   Scancode   = $84...$FF (Empfehlung: $FF benutzen)
   ASCII Code = $20...$FF (ASCII Codes < $20 werden von NKCC auf $20 gesetzt)

   Die Flags fÅr CapsLock und die Shift-Tasten Åbernimmt der Treiber direkt
   vom System. Alternate und Control werden ebenfalls verarbeitet. Da beide
   Flags aber nicht gesetzt sein dÅrfen, werden ihre Inhalte zum
   Zehnerblock-Flag zusammengeodert.

   Das hat alles nicht direkt mit NKCC zu tun, kann aber als Anregung
   verstanden werden, falls man selbst etwas Ñhnliches vorhat. Auûerdem
   verhalten sich die RÅckkonverter-Funktionen in NKCC passend dazu:

   Wird solch ein normalisierter Tastencode mit nkc_n2gem() oder nkc_n2tos()
   wieder zurÅckkonvertiert, erhÑlt man als Scancode immer $FF. War das
   Zehnerblock-Flag gesetzt, sind im Ergebnis sowohl das Alternate- als auch
   das Control-Flag gesetzt.



   4. Wie wird NKCC aufgerufen?
   =============================================================================
   Der Umgang mit NKCC ist eigentlich sehr einfach. Es mÅssen nur ein paar
   Funktionen aufgerufen werden:

   a) Initialisierung

   Ganz am Anfang muû ein Aufruf von nkc_init() erfolgen. Die Funktion
   bekommt drei Parameter Åbergeben:

   - ein Langwort mit Flags (definiert als NKI_... in den Header Files)

     NKI_BUTHND      aktiviert den Button Event Handler
     NKI_BHTOS       zusÑtzlich: nur bei bestimmten TOS-Versionen
                     (siehe Kapitel "Der Button Event Handler")
                     Beide Flags werden von der TOS-Version von NKCC (die
                     bereits assembliert als NKCC_TOS.O vorliegt) ignoriert.

     NKI_NO200HZ     hÑlt NKCC davon ab, sich in den 200 Hz Timer fÅr die
                     Funktion nkc_timer() einzuklinken. Hinweis: wird der
                     Button Event Handler eingeschaltet, so ignoriert NKCC
                     dieses Flag, da die Timer Interrupt-Routine fÅr den
                     Handler benîtigt wird.

   Die beiden folgenden Parameter von nkc_init() werden nur bei eingeschaltetem
   Button Event Handler ausgewertet und sollten ansonsten 0 sein:

   - das Handle einer geîffneten virtuellen VDI Screen Workstation

   - ein Zeiger auf das AES global-Array der Applikation
     unter Pure C ist dies:  _GemParBlk.global  (definiert in AES.H)


   nkc_init() liefert ein 16 bit Integer mit der Versionsnummer von NKCC
   als 4 Ziffer BCD zurÅck (z.B. $0292 = Version 2.92).

   Beispiele:

   nkc_init(0,0,NULL);              Default, ohne Button Event Handler

   nkc_init(NKI_NO200HZ,0,NULL);    jetzt klinkt sich NKCC nirgendswo mehr ein

                                    <handle> wurde von v_opnvwk zurÅckgeliefert
   nkc_init(NKI_BUTHND,handle,_GemParBlk.global);


   b) NKCC abmelden

   Mit der Funktion nkc_exit() klinkt sich NKCC wieder aus dem System aus.
   Der Aufruf muû auch dann erfolgen, wenn weder 200 Hz Timer noch Button
   Event Handler installiert waren! Die Funktion liefert einen Fehlerstatus
   zurÅck, wenn eine andere Applikation die XBRA-Kette der im System
   eingeklinkten Routinen zerstîrt hat. Ist dieser Status < 0, dann darf
   die Applikation auf keinem Fall beendet werden, da NKCC sich nicht mehr
   aus den Vektoren aushÑngen kann.


   c) Konfigurieren

   Mit der Funktion nkc_set() lassen sich bestimmte Einstellungen vornehmen.
   Die Funktion erhÑlt als Parameter ein Langwort mit Flags. Ein gesetztes
   Flag aktiviert die jeweilige Funktion, ein gelîschtes Flag schaltet sie ab.

   NKS_ALTNUM        direkte ASCII-Code Eingabe per Alternate+Ziffernblock
   NKS_CTRL          Control Key Emulation (liefert z.B. "ASCII 1" anstelle von
                     "Control-Taste + ASCII 'A'")
   NKS_D_...         schaltet den jeweiligen Deadkey ein


   d) Vergleicher

   Zum Vergleichen von Tastencodes kann die Funktion nkc_cmp() verwendet
   werden. Die Routine erhÑlt zwei Parameter: den Referenz-Tastencode sowie
   den Test-Tastencode (der vom Benutzer eingegeben wurde). Einige Bits
   des Referenz-Tastencodes haben eine spezielle Bedeutung:

   NKF_IGNUM (entspricht NKF_RESVD)
      Wenn gesetzt, dann wird das Zehnerblock-Flag ignoriert (d.h. es spielt
      keine Rolle, ob z.B. eine Zahlentaste auf der Haupttastatur oder auf
      dem Zehnerblock gedrÅckt wurde).

   NKF_CAPS
      Wenn gesetzt, wird keine Unterscheidung zwischen Groû- und Kleinbuchstaben
      vorgenommen.

   NKF_SHIFT ( *beide* Shift-Tasten; entspricht NKF_LSH|NKF_RSH)
      Wenn *beide* Shift-Tastenflags im Referenz-Tastencode gesetzt sind, wird
      lediglich ÅberprÅft, ob im Test-Tastencode *irgendein* Shift-Tastenflag
      gesetzt ist.



   In den nÑchsten beiden Kapiteln steht, welche Funktionen zur Abfrage
   von Tastenereignissen existieren und wie sie verwendet werden. Im
   Kapitel "Sonstige Funktionen" sind weitere Routinen beschrieben, die bei
   der Entwicklung von NKCC als Nebenprodukt entstanden sind, aber unter
   UmstÑnden sehr nÅtzlich sein kînnen.



   5. NKCC in TOS-Applikationen
   =============================================================================
   FÅr reine textorientierte Konsole-Applikationen sollte die TOS-Version
   von NKCC verwendet werden (NKCC_TOS.O), da der inaktive GEM-Teil in
   diesem Fall nur Ballast darstellen wÅrde. Folgende Funktionen existieren:

   nkc_conin()
      basiert auf der GEMDOS-Funktion Crawcin() und arbeitet genau wie diese,
      mit der Ausnahme daû Tastencodes im normalisierten Format zurÅckgeliefert
      werden. Durch eine geringfÅgige Modifikation des NKCC-Quellcodes kann
      die Funktion auch auf Cconin() (Eingabe mit Echo) oder Bconin()
      (BIOS-Funktion) abgebildet werden.

   nkc_cstat()
      wird anstelle der GEMDOS-Funktion Cconis() (Tastaturstatus abfragen)
      verwendet. Die Routine prÅft, ob der Tastaturpuffer leer ist (Status 0)
      oder nicht (Status -1).



   6. NKCC in GEM-Applikationen
   =============================================================================
   FÅr GEM-Applikationen stellt NKCC ein komplettes Binding zur AES-Funktion
   evnt_multi() zur VerfÅgung. Die Routine trÑgt den Namen nkc_multi() und
   unterscheidet sich vom Original in folgenden Punkten:

   a) Tastencodes werden im normalisierten Format zurÅckgeliefert

   b) die Tastenflags fÅr Shift/Control/Alternate/CapsLock ("ev_mmokstate")
      werden so geschoben, daû sie mit den NKF_...-Konstanten maskiert
      werden kînnen

   FÅr evnt_keybd() gibt es in NKCC keine Entsprechung.



   Erweiterung fÅr Assembler-Programmierer - von Gerd Knops

   Das NKCC evnt_multi-Binding kann auch von Assemblerroutinen leicht
   aufgerufen werden:

   - die AES Parameter-Arrays werden geladen (hierzu mÅssen die Arrays
     von NKCC benutzt werden! -> siehe Kapitel "Symboltabelle")

   - nkc_amulti() wird aufgerufen. Die Funktion entspricht folgendem Code:

      move.l   #aespb,d1      ; Zeiger auf Parameterblock laden
      move     #200,d0        ; opcode: AES
      trap     #2             ; AES aufrufen
      rts                     ; und wieder zurÅck



   7. Der Button Event Handler
   =============================================================================
   Lang lang ist's her...

   ... da verîffentlichte Atari die langerwartete Version 1.04 des ST-
   Betriebssystems TOS. Dummerweise bauten die Jungs aus Sunnyvale einen
   Fehler in den AES Multi Event Handler ein, der sich beim Warten auf
   Timer-Events mit sehr kurzen Zeiten bemerkbar macht. Ist der Timer
   nÑmlich genau dann abgelaufen, wenn der Benutzer gerade mitten in einem
   Mausklick ist, behauptet evnt_multi(), daû ein Timer-Event UND ein
   Button-Event aufgetreten sind. Unter UmstÑnden ist es so niemals
   mîglich, einen Doppelklick in die Applikation hineinzubekommen, da
   der Multi Event Handler die halbfertigen Mausklicks bereits an
   die Applikation meldet (als Einfachklicks).

   Nach langem Herumexperimentieren habe ich mich schlieûlich dazu
   durchgerungen, einen eigenen Button Event Handler zu schreiben und
   in NKCC einzubauen.

   Der NKCC Button Event Handler wird beim Aufruf von nkc_init() durch
   das Flag NKI_BUTHND aktiviert. ZusÑtzlich gibt es noch das Flag
   NKI_BHTOS: wenn gesetzt, erfolgt die Installation nur dann, wenn
   eine fehlerhafte TOS-Version erkannt wurde.

   Zum Betrieb des Button Event Handlers wird auûerdem das Handle einer
   geîffneten virtuellen VDI Screen Workstation benîtigt, da NKCC
   die VDI-Funktion vex_butv() aufruft. Die Workstation darf nicht vor
   dem Aufruf von nkc_exit() geschlossen werden!

   Wenn schon einen eigenen Button Event Handler, dann gleich mit ein paar
   Zusatzfunktionen:

   - MU_XTIMER Flag (wird mit den anderen MU_... Flags als Ereignis-Maske
     an nkc_multi() Åbergeben)
     Ist dieses Flag (zusÑtzlich zu MU_TIMER) gesetzt, werden keine
     Timer-Events geliefert, wenn der Screen Manager vom System zur
     Zeit die Kontrolle Åber den Bildschirm hat (z.B. beim Ausklappen
     von Drown Down MenÅs oder Schieben eines Fensters).

   - Negations-Flag ($100 der Button-Maske)
     In der c't Ausgabe 3/90 oder 4/90 stand ein Artikel Åber dieses
     Flag, das bereits in der ersten TOS-Version eingebaut war aber nie
     dokumentiert wurde - sehr zum érger vieler Programmierer. Denn mit
     diesem Flag lassen sich beide Maustasten ohne groûen Aufwand
     simultan abfragen. Wenn gesetzt, wird die "wahr"-Bedingung fÅr
     Button-Events invertiert. Das lÑût sich am einfachsten an einem
     Beispiel erklÑren:


     mask = evnt_multi(MU_BUTTON,2,3,3,...

     Soll maximal Doppelklicks (2) abfragen fÅr beide Buttons (3), die Buttons
     mÅssen gedrÅckt sein (3). Funktioniert aber nicht, denn es wird getestet:
     Knopf #0 gedrÅckt UND Knopf #1 gedrÅckt.


     Mit Negations-Flag sieht das dann so aus:

     mask = evnt_multi(MU_BUTTON,0x102,3,0,...

     Hiermit werden wiederum Doppelklicks abgefragt (2) fÅr beide
     Buttons (3). Diesmal wird jedoch auf Loslassen (0) getestet und
     das Ergebnis invertiert (0x1..). Also:

     Nicht ( Knopf #0 losgelassen UND Knopf #1 losgelassen )

      oder in anderen Worten:

     Knopf #0 gedrÅckt ODER Knopf #1 gedrÅckt

     Ist doch nett, oder? :-)



   8. Sonstige Funktionen
   =============================================================================
   Bei der Entwicklung von NKCC entstanden einige Funktionen, die nÅtzlich
   genug waren, um exportiert zu werden. Es handelt sich hierbei um:

   nkc_timer()
      liefert den aktuellen Wert des 200 Hz Timers zurÅck. Die Funktion ist
      sehr schnell, da sie nur eine Variable laden muû und dann sofort zurÅck-
      kehrt.

      Hinweis: bei ausgeschaltetem Timer (NKI_NO200HZ bei nkc_init()) erhÑlt
               man als Ergebnis immer 0.

   nkc_kstate()
      liefert den aktuellen Wert der Shift-Tasten, Control, Alternate und
      CapsLock als NKF_... Flags. Ebenfalls sehr schnell.

   nkc_tconv()
      Das KernstÅck von NKCC: der Tastencode-Konverter, der 32 Bit BIOS
      Tastencodes in das normalisierte Format umwandelt. Die Spezialfunktionen
      (Deadkeys etc.) werden von dieser Routine nicht gehandhabt (sondern
      von nkc_conin() und nkc_multi()/nkc_amulti()).

   nkc_gconv()
      Eine Variation von nkc_tconv(). Anstelle des BIOS Tastencodes wird dieser
      Routine ein 16 Bit GEM-Tastencode Åbergeben. ACHTUNG!! Aufgrund der
      fehlenden Flags (Shift/Control/Alternate/CapsLock) kînnen nicht alle
      Tastencodes eindeutig konvertiert werden. Es handelt sich hierbei
      um ein Problem von GEM, das fÅr verschiedene Kombinationen ein und
      denselben Tastencode vorsieht (Åber das Problem habe ich mich im ersten
      Kapitel ja schon ausgelassen). Die Funktion wurde nur fÅr den "Notfall"
      eingebaut, wenn die Flags nicht mehr zur VerfÅgung stehen. Wann immer
      mîglich sollte nkc_tconv() verwendet werden.

   nkc_n2tos()
      konvertiert normalisierte Tastencodes zurÅck in's 32 Bit BIOS Format.

   nkc_n2gem()
      konvertiert normalisierte Tastencodes zurÅck in's 16 Bit GEM Format.

   nkc_vlink()
      Hiermit lÑût sich eine Routine mit XBRA Header in einen Vektor einklinken.
      Der Vektor kann entweder als Adresse (z.B. $502 fÅr die Hardcopy-
      Routine) oder als Nummer angegeben werden (z.B. 2 fÅr den Busfehler-
      Vektor).

   nkc_vunlink()
      Das GegenstÅck zu nkc_vlink(): eine XBRA-Funktion wird aus einem Vektor
      wieder ausgeklinkt.

   nkc_toupper()
      konvertiert Zeichen Åber eine Tabelle von Klein- nach Groûbuchstaben.
      Sonderzeichen wie "Ñ" oder "Ç" werden korrekt behandelt.

   nkc_tolower()
      konvertiert Zeichen von Groû- nach Kleinbuchstaben.


   Genaueres zu den einzelnen Routinen steht in NKCC.TXT.



   9. Symboltabelle
   =============================================================================
   Folgende Symbole werden von NKCC exportiert:
   (Klammern hinter dem Namen identifizieren diesen als Funktion)

      nkc_init()     Initialisierung, optional Button Event Handler installieren
      nkc_exit()     Deinitialisierung; NKCC klinkt sich aus dem System aus
      nkc_set()      Sonderfunktionen einstellen
      nkc_conin()    raw console character input (basierend auf Crawcin())
      nkc_cstat()    sample console input status (basierend auf Cconis())
   *  nkc_multi()    Binding zur GEM-Funktion evnt_multi()
   *  nkc_amulti()   dito fÅr in Assembler geschriebene Programme
      nkc_tconv()    Tastencodekonverter (32 Bit BIOS -> normalisiert)
      nkc_gconv()    Tastencodekonverter (16 Bit GEM -> normalisiert)
      nkc_n2tos()    Tastencodekonverter (normalisiert -> 32 Bit BIOS)
      nkc_n2gem()    Tastencodekonverter (normalisiert -> 16 Bit GEM)
      nkc_kstate()   Status von Shift/Control/Alternate/CapsLock erfragen
      nkc_timer()    aktuellen Wert des 200 Hz Timers erfragen
      nkc_cmp()      Tastencodes vergleichen
      nkc_vlink()    XBRA-Funktion in Vektor einklinken
      nkc_vunlink()  XBRA-Funktion aus Vektor ausklinken
      nkc_toupper()  Konvertierung Klein- nach Groûbuchstaben
      nkc_tolower()  Konvertierung Groû- nach Kleinbuchstaben

   *  nkc_contrl     AES/VDI control array
   *  nkc_intin      AES/VDI integer input array
   *  nkc_intout     AES/VDI integer output array
   *  nkc_adrin      AES address input array
   *  nkc_adrout     AES address output array
   *  nkc_ptsin      VDI pointers input array
   *  nkc_ptsout     VDI pointers output array
                     (nkc_amulti() wertet diese Arrays aus)


   *  nur in der GEM-Version von NKCC (NKCC.O).

   =============================================================================
   Dateiende
