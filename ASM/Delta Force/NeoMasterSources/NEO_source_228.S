
;************************************************************************
;*
;* NEOchrome V1.0 - Ω by Dave Staugas
;*           V2.x - Ω by Chaos, Inc. - member of the Delta Force
;*
;*       Achtung! Keine Optimierungen vornehmen....
;*
;************************************************************************

module_version          EQU 0   ;0=Keine Modulversion, 1=Modultestversion

                        IF module_version=0
disk_version            SET 1   ;0=Diskversion, 1=Assemblerversion
                        ELSE
disk_version            SET 1
                        ENDC

release_1               EQU 2   ;Neochrome Versionsnummer
release_2               EQU 2
release_3               EQU 8   ;=v2.28

;weitere Ideen:
;--------------
; mehrere Workscreens mit verschiedenen Farbpaletten
; komplette Tastatursteuerung (auch Hintergrundfarbe)
; beschleunigtes Zeichnen des Boards
; FarbÅbergÑnge berechnen lassen
; benÅtzen der Fileselectbox bei Laden UND Speichern
; Laderoutine fÅr *.NEO, *.PI1, *.PC1, *.IFF, *.DOO
; Speicherroutine fÅr *.NEO, *.PI1, *.PC1, *.IFF, *.DOO
; Achtung! Bei CommandlineÅbergabe auf Extension achten!
; Formatieren von Disketten (MS-DOS kompatibel auch bei TOS 1.0 bzw. TOS 1.2)
; Lîschen von Files
; Laufschrift zwecks Copyright-Angabe bzw. Aufruf zu Donations
; Rotieren um beliebige Grad-Schritte
; Cutter-Werkzeug, anschliessendes Re-cut, bzw. Vergrîûern und Verkleinern
; Automatisches Rahmensuchen mit variabler Grîûe beim Cutter.
; Tastatursteuerung beim Cutter (Undo(!))
; Abspeichern der Raster/Farbpalette bei den Objekten
; abspeichern der Copybox im Image-Format
; Copybox abspeichern auch mit Angabe des Filenames
; funktionierendes Animationstool
; Tastatursteuerung beim Animationstool
; Abspeichern der Farbpalette (auch als Defaultpalette)
; Beim Rechtsklick im FÅllen wird mit Hintergrundfarbe gefÅllt
; Beide Mausknîpfe beim FÅllen fÅllen mit Farbe #0
; ggf. Blitter anschalten
; Arbeitsbildschirmnummer anzeigen
; Beim Umschalten der Bildschirme mit Palette Undo Palette kopieren
; Beim Umschalten wird eine offene Copybox Åbernommen.
; Beim Umschalten wird grab_y Åbergeben
; Abspeichern der Palette sowohl in Ass, wie auch in C
; Repeat-Funktion auf allen Buttons.
; Beim Laden von Objekt-Files hinzufÅgen, nicht ersetzen
; Sicherheitsabfrage bei NEW-Cutter
; Beim Verlassen werden alle 4 Screens auf énderungen ÅberprÅft und ggf. gemeldet
; Blitter an/abschalten
; Lupe im unteren Rand bei Fullscreen
; rechter Knopf auf Undo = Palette Undo
; Palettenumschaltung in bestimmter Scanline (auch Åber 200 Scanlines)
; Sortieren der Raster
; Abschalten der Raster bei rechenintensiven Prozessen
; STE UnterstÅtzung
; TT UnterstÅtzung
; STE UnterstÅtzung abschaltbar
; beim STE 'calculate colors'
; Tastatursteuerung bei Rasters (Cursor rechts/Links)
; Alte Rotate-Funktion bei 90¯ Drehungen
;- Fehler in Rotate: Linie: 1 Pixel hoch, 9 Pixel breit, nachher nur 8 Pix. hoch
; Beim Bildschirmwechsel Color-Marks Åbergeben
; Rasterfunktion rechter Klick, Paletten setzen
; CopyBx.xxx speichert jetzt immer in den aktuellen Ladepfad
; Fileselectbox bei Rechtsklick auf 'Save CopyBx.xxx'
; nur benÅtzte Raster speichern bei Rechtsklick auf 'Save Raster'
; Raster sortieren bei Rechtsklick auf 'Put'/'Get'.
; Warnung, wenn bei den Objekten ein Rasterobjekt ohne Raster gechangt wird.
; Beim Pencil Hintergrundfarbe einstellen
; Beide Tasten im Pencil zeichnet mit Farbe #0
; STE abschalten
; Rasterbuffer beschriften
; NOPs der Randaufklapproutine einstellbar
; Animation mit Background
; Linkvirencheck
; Kleines 'R' bei Objekten mit Rastern
; Druckerausgabe in Grauwerten des Jack Knifes
; Bei Recut der Objekte, Raster ggf. neu ausschneiden
; Rechtsklick auf Show zeigt Objekt physikalisch an
; Palette im unteren Rand
; IFF-Format soll auch STE-Farben speichern/laden kînnen.
; Remap-Funktion bzw. Farbreduzierung
; Color/Palette Undo wieder vorhanden
; Copybox bei Paste wahlweise an die Position des Ausschneidens zurÅck
; Overscan Abfrage und ggf. Overscan abschalten
; Antialias (noch nicht auf Rastern)
; arbeitet jetzt auch mit MACCEL3.PRG
; Mausachsen werden beim Klick auf den Versionspunkt (16/199) vertauscht.
; Doppelklick rechts auf Farbkasten holt aktuelle Farbe runter
; Screensaver
; neue Icons
; Anzeige der Arbeitsweise bei Box (Fill oder nicht)
; IFF-Palette speichert jetzt auch Raster
; Laden von 5 Plane IFF-Bildern (Fehlerhaft!)
; Anzeigen der Breite/Hîhe der Copybox
;  einstellbare Grid-Schrittweite
;  beschrÑnken auf 1,2 oder 4 Planes
;  STE in der Farbauswahlbox alle Farben darstellen. (siehe STE_COLR.SRC)
;  best. Farben schÅtzen (nur bei Draw)
;  grîûerer Bildschirm (z.B. 1024x1024), Verschieben mit Grabber
;  Laden und Bearbeiten von Monochrom-Bilder
;     dabei jedes Bildschirmviertel in einem Arbeitsscreen
;  Abspeichern der Copybox mit best. Planes
;  Beim Zeichnen mit Spray und Brush Rahmen in Lupe zeichnen
; Fixieren der Lupe und Arbeiten in dieser (Tanis and Spaz)
; Groûe Lupe (4x, 8x, 16x)
; Jack Knife <-> Copybox Transfer
; Segmentierung der Lupe an/abschaltbar
; neue Tastaturauswertroutine
;- Fehler in Save Palette (IFF) (kein CMAP-Chunk)
; Modultechnik

                        TEXT
                        OPT X+,F+
                        DEFAULT 1

                        IF disk_version=0
                        OPT X-,F+ ;Keine Symboltabelle
                        DEFAULT 8
                        OUTPUT 'C:\NEOCHROM\NEOCHROM.PRG'
                        ENDC

header_len              EQU 20  ;So groû ist der Header von Objekten
seq_max                 EQU 20  ;Max. Zahl der Sequenzen im Animate
version                 EQU 'BJ'<<16+$0101
hippel_len              EQU 16000 ;LÑnge des Music_Buffers

anz_raster              EQU 200 ;max. 200 Raster

line_editx              EQU 214 ;Position des Linien-editors
line_edity              EQU 151

Begin:          bra     drÅber

neo_kennung:            DC.B 'NEO!' ;NEOchrome Kennung
                        DC.L scrolltext-Begin ;FÅr NEOchrome Modul zum VerschlÅsseln
                        DC.L scrollend-Begin
neo_laenge:             DC.L 0  ;LÑnge des Programms

scrolltext:
;                        DC.B 'Attention, Attention: Since version v2.26 is NEOchrome Master'
;                       DC.B ' Shareware! That means, that you can copy this program, BUT'
;                      DC.B ' if you sometimes use it, you have to pay DM 30 to the author'
;                     DC.B ' (adress is following), otherwise you use this program'
;                    DC.B " without licence and this is illegal!!"
;                   DC.B "    If you've got registered as an authorised user, you'll get"
;                  DC.B " a better explanation of all NEOchrome (Master) functions, and an"
;                 DC.B ' explanation of the new module technique.'
;                DC.B ' This enables you to put own functions into NEOchrome Master...'
;                   DC.B "     So think about it, NEOchrome Master is worth the price."
                        DC.B '        NEOchrome Master'
                        DC.B ' released on '
                        DC.B ((^^DATE>>5)&15)/10+'0',((^^DATE>>5)&15)%10+'0'
                        DC.B '/'
                        DC.B (^^DATE&31)/10+'0',(^^DATE&31)%10+'0'
                        DC.B '/'
                        DC.B '19',((^^DATE>>9)+80)/10+'0',((^^DATE>>9)+80)%10+'0'
                        DC.B ' at '
                        DC.B ((^^TIME>>11)&31)/10+'0',((^^TIME>>11)&31)%10+'0'
                        DC.B ':'
                        DC.B ((^^TIME>>5)&63)/10+'0',((^^TIME>>5)&63)%10+'0','.'

                        DC.B ' This version of NEOchrome was improved by Chaos Inc. of the'
                        DC.B " DELTA FORCE (member of the still ruling UNION).  There's no reason anymore to use"
                        DC.B ' Degas Elite, coz NEOchrome beats the shit out off this crap.'

                        DC.B ' Send donations to: '
                        DC.B "  PLK 136681E   -   7050 Waiblingen    -    West-Germany          If you've"
                        DC.B ' found a bug and you can exactly describe how you can reproduce it, please'
                        DC.B ' write me too. But please tell me your configuration (which ST (or TT), TOS-version,'
                        DC.B ' etc.).            Let me tell you a little story about NEOchrome...  In the first days'
                        DC.B ' of the ST, there were just two painting-programs:  NEOchrome and Degas.'
                        DC.B ' NEOchrome had, and still has, many functions, but some of them were not'
                        DC.B " recognized by the software-reviewers. They've just always seen some features"
                        DC.B ' Degas had (and nobody needs, e.g. loading Koala-pictures or distorting pictures).'
                        DC.B ' NEOchrome offers many functions which (serious) painters really need (e.g.'
                        DC.B ' swap colors and the realtime-magnify).   Because (nearly) all reviewers are'
                        DC.B " neither painters nor programmers (in other words: LAMERS), they can't distinguish"
                        DC.B ' between functions you NEVER need (like mirror drawing)'
                        DC.B ' and functions you BADLY need (see above), NEOchrome always got bad reviews.'
                        DC.B " That meant that nobody bought NEOchrome and Dave Staugas hasn't earned"
                        DC.B ' lotsa money with it.   But enough stories here...      Now follows what'
                        DC.B ' nobody wants to read but all readers wait for....       The greetings'
                        DC.B ' (in no special order, just as I can remember)....    They go to:'
                        DC.B '   first of all to another Delta Force member: Thanks to New Mode for'
                        DC.B ' writing some useful functions of NEOchrome Master.  '
                        DC.B '     Second to Slime for testing NEOchrome Master'
                        DC.B ' again and again. He found many bugs which I never thought'
                        DC.B ' of. Thanx!'
                        DC.B '   And last, but really not least, to THOR, who changed to Delta Force.'
                        DC.B " He's one of these guys, who never stop testing NEOchrome"
                        DC.B " Master. He did a lot to make NEOchrome the way it is."
                        DC.B '      Then to all my comrades in THE UNION (TEX, TCB (special HI! to Tanis, also one'
                        DC.B ' of the NEOchrome fanatics), Level 16, TNT-Crew, XXX-International and'
                        DC.B ' the Replicants), THE LOST BOYS (special HI! to SPAZ (still using Degas?'
                        DC.B ' What a shame!!!)), GIGABYTE-CREW, UNLIMITED MATRICKS, THE ALLIANCE,'
                        DC.B ' SYNC, OMEGA'
                        DC.B ' and to you using this program and reading these greetings...'
                        DC.B "     and always remember:  NEOchrome - you can't beat the feeling!"
                        DC.B "     May the (DELTA) FORCE be with you - always!    Let's wraaaazzzz!"
                        DC.B "                                         "
                        DC.B '                        And again...   '

scrollend:              DC.B 0

drÅber:         lea     Begin-256(PC),A5

                movea.l $0018(A5),A0    ;BSS-Start
                move.l  $001C(A5),D7    ;BSS-Len
                lsr.l   #3,D7           ;/8
                moveq   #0,D0
clear_bss:      move.l  D0,(A0)+
                move.l  D0,(A0)+        ;BSS lîschen
                subq.l  #1,D7
                bne.s   clear_bss

                movea.l SP,A5
                lea     stackp,SP

                move.w  #4200,-(SP)     ;Overscan vorhanden?
                trap    #14
                addq.l  #2,SP
                cmp.w   #4200,D0
                beq.s   no_overscan

                clr.w   overscan        ;Overscan ist da
                move.w  #-1,-(SP)
                move.w  #4206,-(SP)
                trap    #14             ;Overscan Modus abfragen
                addq.l  #4,SP
                move.w  D0,overmode

                clr.w   -(SP)           ;Overscan aus
                move.w  #4206,-(SP)
                trap    #14
                addq.l  #4,SP

no_overscan:    movea.l 4(A5),A5
                lea     128(A5),A4

                        IF disk_version=1
                clr.b   (A4)
                lea     1(A4),A1
                lea     fn,A3           ;Leiste.neo in Commandline kopieren
cpy_it:         addq.b  #1,(A4)
                move.b  (A3)+,(A1)+     ;(Nur fÅr Testzwecke)
                bne.s   cpy_it
                subq.b  #1,(A4)

                clr.b   (A4)
                        ENDC

drb:            move.l  12(A5),D0
                add.l   20(A5),D0
                add.l   28(A5),D0
                add.l   #$00000100,D0
                move.l  A4,-(SP)
                move.l  D0,-(SP)
                move.l  A5,-(SP)
                move.w  D0,-(SP)
                move.w  #$004A,-(SP)
                trap    #1
                lea     12(SP),SP

                move.w  #4,-(SP)
                trap    #$0E            ;GetRez
                addq.l  #2,SP
                move.w  D0,old_rez
                cmpi.w  #2,D0           ;monochrom?
                bne.s   kein_monochrom  ;nein, weiter
                move.l  #L00CE,D0
                jsr     alert           ;Application doesn't support monochrome
                clr.w   -(SP)
                trap    #1

kein_monochrom: pea     dta
                move.w  #$001A,-(SP)    ;DTA setzen
                trap    #1
                addq.l  #6,SP

                jsr     check_ste       ;Testet, ob ein STE vorliegt
                move.w  D0,ste_machine  ;und hardware auch merken

                jsr     check_blitter   ;Blitter suchen und ggf. anschalten

                linea   #0 [ Init ]
                move.l  A0,linea_base   ;Basis der Linea-Variablen

                jsr     preshift_lupe   ;Lupe vorbereiten

                move.l  #screen_mem,D1
                addi.l  #$000000FF,D1
                clr.b   D1              ;Auf Pagestart bringen
                move.l  #$00007D00,D0   ;Screengrîûe

                move.l  D1,D2           ;Startadresse des 1. Screens
                add.l   D0,D2           ;+LÑnge=Startadresse 2. Screen in D2
                add.l   #7424,D2        ;+Rand (auf Pagestart)
                move.l  D2,D3           ;Startadresse 2. Screen
                add.l   D0,D3           ;+LÑnge=Startadresse Buffer in D3
                add.l   #7424,D3        ;+Rand (auf Pagestart)
                move.l  D3,D4           ;Startadresse Buffer
                addi.l  #160*24,D4      ;+ <- =Startadresse 3. Screen
                add.l   D0,D4
;D1=32K, D2=32K, D3=32K+24*160,D4=Ende von D3
                swap    D1
                swap    D2
                swap    D3
;                cmp.w   D2,D1           ;Liegen D2 und D1 im gleichen 64K?
;                beq.s   L0000           ;ja->Weiter
;                exg     D3,D1
;                exg     D2,D1           ;Sonst mit D3 tauschen
L0000:          swap    D1
                swap    D2
                swap    D3
                move.l  D1,scr1
                move.l  D2,scr2
                cmp.l   D2,D3
                blt.s   L0001
                addi.l  #$00000F00,D3
L0001:          move.l  D3,komplettbild
                move.l  D4,cut_buff
                addi.l  #17920,D4
                move.l  D4,irgend_copy

                move.l  #platz_screen,D1
                addi.l  #$000000FF,D1
                clr.b   D1
                move.l  D1,rotate_buffer

                move.w  #1,anz_screens  ;Es gibt nur einen Arbeitsscreen
                move.l  D3,work_tab     ;Adresse des 1. Workscreens

                clr.l   user_prg1       ;Bisher keine Userprogramme
                clr.l   user_prg2
                clr.l   user_prg_len

                jsr     get_free_mem    ;Wieviel Speicher ist noch frei?
                move.l  user_prg_wished,D1
                add.l   D1,D1           ;2 Userprogramme
                sub.l   D1,D0           ;dieser Platz wird auch benîtigt
                sub.l   #100000,D0      ;100KByte freilassen
                bmi     no_more_screens
                divu    #32000+anz_raster*34,D0 ;Anzahl der mîglichen weiteren Screens
                cmp.w   #9,D0           ;mehr als 9 weitere Screens?
                ble.s   ok9
                moveq   #9,D0           ;max. 9 Screens
ok9:            tst.w   D0              ;Åberhaupt noch Platz?
                beq     no_more_screens ;Nein->Weiter

                add.w   D0,anz_screens  ;soviel Screens sind es mehr
                mulu    #32000+anz_raster*34,D0 ;Screen+HBL-Palette
                add.l   #256+anz_raster*34,D0 ;+HBL_System des Arbeitsscreens
                add.l   D1,D0           ;+Grîûe der beiden Userprogramme

                move.l  D0,-(SP)
                move.w  #$0048,-(SP)
                trap    #1              ;Speicher anfordern
                addq.l  #6,SP
                tst.l   D0
                bmi.s   no_more_screens

                move.l  D0,user_prg1
                add.l   user_prg_wished,D0
                move.l  D0,user_prg2
                add.l   user_prg_wished,D0
                move.l  user_prg_wished,user_prg_len ;TatsÑchliche LÑnge merken

                move.l  D0,start_screens ;Startadresse der Screens
                add.l   #$000000FF,D0
                clr.b   D0              ;Auf Pagestart bringen
                movea.l D0,A1
                move.w  anz_screens,D7
                subq.w  #2,D7           ;Anzahl der neuen Screens-1
                lea     work_tab+4,A0
screen_loop:    move.l  A1,(A0)+
                move.w  #3999,D6
clear_screen:   clr.l   (A1)+           ;Bildschirm lîschen
                clr.l   (A1)+
                dbra    D6,clear_screen
                dbra    D7,screen_loop

                move.l  A1,hbls         ;und die HBL-Paletten starten hier

                        IF module_version=0
                jsr     load_user1      ;Laden der Userprogramme
                jsr     load_user2
                        ELSE
                move.l  #demo1,user_prg1
                move.l  #demo2,user_prg2
                        ENDC

                jsr     switch_user
                bra.s   more_screens

no_more_screens:move.w  #1,anz_screens  ;nur ein Screen mîglich
more_screens:   bsr     build_pathes    ;Baut die Pfade fÅr die Fileselecter auf

                jsr     preshift_plot_data ; preshiftet Punkte fÅr Remapper, etc.

                linea   #0 [ Init ]
                move.l  (A1),font6x6    ;Pointer auf die Fonts holen
                move.l  4(A1),font8x8

                lea     sequenzen,A0
                moveq   #seq_max-1,D7   ;Alle Sequenzen lîschen
loop87:         move.l  #$00010001,(A0)+ ;Linker Rand+Rechter Rand
                move.w  #1,(A0)+        ;Akt_objekt
                move.w  #9,(A0)+        ;Speed
                dbra    D7,loop87

                jsr     get_free_mem    ;Freien Speicher bestimmen
                cmpi.l  #65536,D0       ;65K Frei?
                bcs.s   L0002

                move.b  #-1,less_memory ;GenÅgend Speicher

                clr.w   L0577
                move.w  #3,L0573        ;Tastaturtexte an
                move.w  #88,copy_icon

                move.l  #35840,-(SP)
                move.w  #$0048,-(SP)
                trap    #1              ;zusÑtzlichen Speicher fÅr Copybox
                addq.l  #6,SP
                move.l  D0,irgend_copy
                bra.s   drÅber24

L0002:          pea     low_mem
                move.w  #9,-(SP)
                trap    #1
                addq.l  #6,SP

drÅber24:       clr.w   -(SP)
                pea     NEO_MCP
                move.w  #$003D,-(SP)
                        IF disk_version=0
                trap    #1              ;Nur bei Diskversion Neo.mcp suchen
                        ELSE
                moveq   #-1,D0          ;sonst Fehler
                        ENDC
                addq.w  #8,SP
                move.w  D0,fhandle
                bmi.s   L0004
                pea     color512
                move.l  #$00000400,-(SP)
                move.w  fhandle,-(SP)
                move.w  #$003F,-(SP)
                trap    #1
                lea     $000C(SP),SP
                tst.l   D0
                bmi.s   L0003
                cmpi.w  #$0400,D0
                beq.s   L0004
L0003:          move.l  #L00CB,D0       ;Picture not correct format...
                jsr     alert

L0004:          move.l  #appl_init,D0
                jsr     _aes            ;Programm als GEM-Applikation anmelden
                move.w  D0,ap_id

                move.l  #graf_handle,D0
                jsr     _aes            ;Handle der Bildschirm-Workstation ermitteln
                move.w  D0,vdi_handle   ;Handle fÅr VDI-Aufrufe merken

                lea     int_in,A0
                moveq   #10,D0
_gem_init2:     move.w  #1,(A0)+        ;1,1,1,1,1,1,1,1,1,1,2
                dbra    D0,_gem_init2
                addq.w  #1,-(A0)
                move.l  #v_opnvwk,D0
                jsr     _vdi            ;Workstation îffnen
                move.w  12+control,vdi_handle

                lea     control,A0
                move.l  #ms_move_irq,14(A0)
                move.l  #vex_motv,D0
                jsr     _vdi
                move.l  18(A0),old_ms_move

                move.l  #ms_button_irq,14(A0)
                move.l  #vex_butv,D0
                jsr     _vdi
                move.l  18(A0),old_button_irq

                lea     addr_in,A0
                move.l  #pfadname,(A0)+ ;Hier kommt kompletter Pfadname hin
                move.l  #neo_prg,(A0)   ;Zu suchendes File
                move.l  #shel_read,D0
                jsr     _aes            ;und holen

                        IF disk_version=1 ;Bei Assemblerversion
                bra     no_param_save
                        ENDC

                clr.w   -(SP)
                pea     pfadname
                move.w  #$004E,-(SP)
                trap    #1
                addq.l  #8,SP
                tst.w   D0
                bmi.s   kein_virus
                move.l  dta_size,D0
                cmp.l   neo_laenge(PC),D0 ;NEOchrome.prg lÑnger als normal?
                ble.s   kein_virus      ;nein, Falscher Alarm

                move.l  #virus,D0       ;Alarm!
                jsr     alert

kein_virus:     move.w  #0,-(SP)        ;Nur Lesen
                pea     pfadname
                move.w  #$003D,-(SP)    ;NEOCHROM.PRG îffnen
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                bmi.s   no_param_save   ;Keine Parameter saven

                clr.w   -(SP)           ;Vom Dateistart
                move.w  fhandle,-(SP)
                move.l  #28+4,-(SP)     ;Header + Branch
                move.w  #$0042,-(SP)    ;Lseek
                trap    #1
                lea     10(SP),SP
                tst.w   D0
                bmi.s   no_param_close

                lea     scroll_save,A6
                moveq   #4,D6           ;Ist es NEOchrome?
                jsr     read
                cmp.l   D6,D0           ;4 Bytes gelesen?
                bne.s   no_param_close

                move.l  neo_kennung(PC),D0
                cmp.l   scroll_save,D0  ;Ist es Neochrome?
                bne.s   no_param_close

                clr.w   param_save

no_param_close: jsr     fclose
no_param_save:  jsr     init_neochrome  ;HBL-System hochfahren
                move.w  #14,-(SP)
                move.w  #0,-(SP)
                move.w  #28,-(SP)
                trap    #14
                addq.l  #6,SP
                lsr.b   #7,D0           ;PortA #7 holen
                bchg    #0,D0           ;und umdrehen
                move.b  D0,old_porta

                jsr     set_porta

                move.w  magtyp,D0
                add.w   #'0',D0         ;Lupentyp eintragen
                move.b  D0,mag_str+5

                move.b  synchronisation,D7
                jsr     set_sync
                jsr     ascii_syncs     ;Synchronisation in ASCII wandeln
                move.w  lupe_y_60,D0
                move.w  nop_60,D1
                tst.b   synchronisation ;60Hz?
                beq.s   hz603
                move.w  lupe_y_50,D0
                move.w  nop_50,D1
hz603:          move.w  D0,lupe_y       ;Neues Lupe_y setzen
                move.w  D1,nop_zahl
                jsr     compile_nops    ;und Routine aufbauen

                move.w  anz_screens,D7
                lea     col_tab,A0
                bra.s   make_dbra
make_left:      move.b  hintergrundfarbe+1,(A0)+
                move.b  zeichenfarbe+1,(A0)+
                move.b  left_col_mark+1,(A0)+
                move.b  right_col_mark+1,(A0)+
make_dbra:      dbra    D7,make_left

                jsr     set_box_icon    ;Setzt das Icon der Boxfunktion je nach FÅll

                lea     winkel_ascii,A0 ;Rotate-Winkel in Ascii wandeln
                move.w  rotate_winkel,D0
                jsr     wandel_fest_dez ;Winkel einsetzen
                move.b  #'¯',-(A0)

                move.w  lupe_y,D7
                add.w   #'0',D7         ;Hîhe der Lupe eintragen
                move.b  D7,yyy+3

                move.w  nop_zahl,D0
                lea     nop_str+4,A0    ;Anzahl der NOPs eintragen
                jsr     wandel_fest_dez

                lea     music_path,A0
                lea     music_fn,A1
                jsr     build_pathfn    ;Kompletten Pfad zusammenbauen

                tst.b   music
                bne.s   keine3
                jsr     load_music      ;ggf. Musik laden
                move.w  music_nr,D0     ;Nummer der Musik
                jsr     turn_music_on
keine3:         jsr     haken_aus

                jsr     init_haken      ;Haken bei Load und Save eintragen

                move.w  rotate_direct,rotate_richtung ;Richtung eintragen

                tst.w   just_rahmen     ;Sollen Boxen nur Umrahmt werden?
                bne.s   okok
                lea     boxicons,A0
                moveq   #4,D7           ;Counter=5 Icons
Ñndern:         subq.w  #5,(A0)         ;Icons anpassen
                addq.l  #6,A0
                dbra    D7,Ñndern

okok:           move.w  #2,-(SP)
                trap    #$0E            ;Physbase
                addq.l  #2,SP           ;ein Bildschirm
                move.l  D0,copybox_screen

                linea   #0 [ Init ]
                move.w  -$02B4(A0),mid_width ;Bildschirmbreite
                move.w  -$02B2(A0),mid_height ;Bildschirmhîhe
                move.w  -$029A(A0),mid_#_colors ;Anzahl der Farben
                jsr     Hm
                moveq   #0,D0           ;Low-Res bitte
                bsr     set_resolution  ;und setzen

                linea   #0 [ Init ]
                move.w  #319,-$02B4(A0)
                move.w  #199,-$02B2(A0)
                move.w  #16,-$029A(A0)
                move.w  #163,-$025A(A0) ;Mausx setzen
                move.w  #106,-$0258(A0) ;Mausy setzen

                move.w  #-1,-(SP)
                move.l  scr1,-(SP)
                move.l  scr1,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     12(SP),SP
                move.b  #-1,tos_screen  ;Jetzt ist NEO da

                jsr     init_text       ;Textfunktion vorbereiten (Stirb BUG!)

                movea.l (SP)+,A4

                move.l  SP,stackpointer ;Normaler Stand

                clr.w   no_pic_load     ;nichts nachgeladen
                move.b  (A4)+,D0        ;Commandline auswerten
                beq.s   L000C
                ext.w   D0
                bra.s   L0009
L0008:          cmpi.b  #'!',(A4)
                bcc.s   L000A           ;Grîûer, gleich->beenden
                addq.l  #1,A4
L0009:          dbra    D0,L0008
                bra.s   L000C
L000A:          lea     picture_neo,A3
L000B:          move.b  (A4)+,(A3)+
                dbra    D0,L000B
                clr.b   (A3)

                move.b  #1,no_pic_load  ;In Commandline ist was drin..

                moveq   #3,D0
such_punkt2:    cmpi.b  #'.',-(A3)
                beq.s   punkt_found3
                dbra    D0,such_punkt2
                bra.s   L000C           ;Kein Punkt gefunden

punkt_found3:   lea     extensions+1,A0
                moveq   #0,D7           ;Typ 0

nxt_ext:        movea.l A0,A1
                movea.l A3,A4
                moveq   #3,D0           ;4 Zeichen mÅssen Åbereinstimmen
vergleich:      cmpm.b  (A1)+,(A4)+
                bne.s   nxt_extension
                dbra    D0,vergleich
                move.w  D7,D1
                jsr     chg_save_typ    ;und Ñndern
                jsr     chg_load_typ    ;und in Anzeige Ñndern
                bra.s   L000C           ;und laden

nxt_extension:  addq.l  #6,A0
                addq.w  #1,D7           ;ein Typ weiter
                cmp.w   #5,D7           ;alle durch?
                blt.s   nxt_ext         ;nein, weiter

L000C:          tst.w   no_pic_load     ;in Commandoline nichts drin?
                beq.s   ok_load         ;Ja->weiter

                clr.w   -(SP)
                pea     picture_neo
                move.w  #$003D,-(SP)    ;Bild laden...
                trap    #1
                addq.l  #8,SP
                move.l  #picture_neo,filenamen

laden_bild:     bsr     load_pic        ;Bild laden
                tst.w   D0
                bpl.s   ok_load

                neg.w   D0
                subq.w  #1,D0
                lea     error_alerts(PC),A0
                lsl.w   #2,D0
                move.l  0(A0,D0.w),-(SP) ;Alert retten

                bsr     switch2tos
                move.l  (SP)+,D0        ;Alert wieder holen
                jsr     alert
                bsr     switch2neo
                clr.w   no_pic_load     ;Es wurde kein Bild geladen....
                bra.s   drÅber_88

ok_load:        tst.b   just_palette    ;Wurde nur eine Palette geladen?
                bne.s   drÅber_88       ;Nein, weiter

                lea     picture_neo,A1
                lea     picture_old,A0
copy_it68:      move.b  (A0)+,(A1)+     ;Alten Filenamen wieder hin
                bne.s   copy_it68

drÅber_88:      move.w  #-1,evt_timer_aus ;Timer ausschalten
                move.w  #$2500,acia_irq_sr ;IRQ-Maske fÅr Timer C und ACIA
                move.b  #2,mouse_pos
                jsr     get_maus        ;Mausposition holen

                tst.w   effektflag
                bne.s   drueberspringen

                movea.l rotate_buffer,A0
                jsr     clear_neo

                movea.l scr1,A0
                movea.l rotate_buffer,A1
                move.w  #3999,D0
fuckcopy:       move.l  (A0)+,(A1)+
                dbra    D0,fuckcopy

                move.w  #-1,-(SP)
                move.l  rotate_buffer,-(SP)
                pea     -1.w
                move.w  #5,-(SP)
                trap    #14             ;Rotate Buffer anzeigen
                lea     12(SP),SP

drueberspringen:tst.w   board_da
                bne.s   no_bo89
                jsr     draw_board      ;Leiste zeichnen
no_bo89:        bsr     check_lupe
                jsr     schieb_board    ;Board rein schieben

                move.w  #-1,-(SP)
                move.l  scr1,-(SP)
                pea     -1.w
                move.w  #5,-(SP)
                trap    #14             ;Scr1 anzeigen
                lea     12(SP),SP

                jsr     Sm
                lea     fun_init(PC),A0
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0   ;Aktuelle Funktion reaktivieren
                clr.b   L076B
                jsr     (A0)

mainloop:       movea.l stackpointer,SP ;und normaler Stand setzen
                move.b  #-1,fernsteuerung ;Im Moment wird nichts ferngesteuert
                bsr     switch_copyr    ;Copyrights durchschalten
                move.l  taste,D0        ;Taste
                beq     no_taste_da     ;nichts da->weiter
                clr.l   taste           ;Taste ist ausgewertet
                jsr     get_shift       ;Shift_Status holen
                move.w  D1,-(SP)        ;d1 retten
                moveq   #0,D1
                move.b  right_shift,D1  ;irgendeine Shift gedrÅckt?
                or.b    any_shift,D1
                add.w   D1,D1           ;in 8.Bit
                swap    D0              ;Scancode holen
                or.w    D1,D0           ;in Scancode odern
                move.w  (SP)+,D1        ;d1 wieder holen
                cmpi.b  #$61,D0         ;Undo-gedrÅckt?
                bne.s   no_undo         ;Nein, kein Undo
                bsr     L0016           ;Tastendruck gÅltig?
                bne     L001C           ;Nein->weiter

                bsr     do_undo
                bra     L001A
no_undo:        cmp.b   #103,D0         ;Zehnerblock '0'
                blt.s   no_switch
                cmp.b   #112,D0         ;Zehnerblock '9'
                bgt.s   no_switch

                move.w  D0,scancode     ;Scancode retten
                bsr     L0016           ;Tastendruck gÅltig(?)
                bne     L001C           ;Nein, weiter

                move.w  scancode,D0
                sub.w   #103,D0
                lea     zehnerblock,A0
                move.b  0(A0,D0.w),D0

                bsr     rette_palette   ;Vor Umschalten alte Palette komplett retten
                bsr     show_workscreen
                bra     L001A

no_switch:      cmpi.w  #1,D0           ;Escape ohne Shift etc..
                bne.s   no_escape       ;nein
                move.w  sondertasten,D3
                and.w   #%0000000000001111,D3 ;Irgendeine Sondertaste?
                bne.s   no_escape       ;Nein->Weiter
                bsr     L0016           ;Tastendruck gÅltig?
                bne     L001C           ;Nein->weiter
                jsr     Hm
                tst.w   board_da
                beq     fullscreen
                move.l  #-1,maus_lupex  ;Keine fixierte Lupe
                moveq   #%00000011,D5   ;Solange warten, bis diese Bits 0 in d2
                bra     board_an        ;Sonst Board anschalten...

no_escape:      movem.l D0/D2-A6,-(SP)
                move.w  sondertasten,D0
                and.w   #%0000000000001111,D0 ;CAPSLOCK etc. abschalten
                move.w  D0,D1
                movem.l (SP)+,D0/D2-A6

                lea     taste_func,A0
nxt_check2:     cmp.b   1(A0),D0        ;Dieser Scancode?
                bne.s   no_scan_found   ;tatsÑchlich..
                btst    #7,(A0)         ;irgendeine Shift?
                beq.s   nein_genau
                btst    #0,D1           ;rechte Shift?
                bne.s   scan_found
                btst    #1,D1           ;Linke Shift?
                bne.s   scan_found
nein_genau:     cmp.b   (A0),D1         ;Sondertastenstatus gleich?
                beq.s   scan_found
no_scan_found:  lea     12(A0),A0       ;nÑchster Eintrag
                cmpi.w  #-1,(A0)        ;noch gÅltig?
                bne.s   nxt_check2
                bra     no_taste_da

scan_found:     move.l  A0,-(SP)        ;a0+2 retten
                bsr.s   L0016           ;Taste gÅltig?
                movea.l (SP)+,A0
                bne     L001C           ;Taste war nicht gÅltig

                jsr     Hm              ;Maus hau ab!
                addq.l  #2,A0           ;Scancode Åberspringen
                clr.b   fernsteuerung   ;Hier wird ein Mausklick simuliert
                move.w  D0,old_mx       ;Alte Mausposition merken
                move.w  D1,old_my
                move.w  D2,old_mkey
                move.w  (A0)+,D2        ;Maustastenstatus holen
                move.w  (A0)+,D0        ;neue mx holen
                move.w  (A0)+,D1        ;neue my
                movea.l (A0),A0         ;Init-Routine
                movem.l D0-A6,-(SP)     ;Register retten
                jsr     (A0)            ;und starten
                movem.l (SP)+,D0-A6     ;und wieder holen
                bra     such_function   ;entsprechende Funktion ausfÅhren

L0016:          clr.l   taste           ;Keine Taste mehr da...
                bsr     get_maus
                move.w  D2,D5           ;Maustaste holen
                andi.w  #3,D5
                beq.s   L0017           ;nichts gedrÅckt->Undo
                rts                     ;Sonst raus

L0017:          cmpi.b  #12,function    ;Rechtecke, Kreise...
                bne.s   L0018           ;nein okay...
                cmpi.w  #4,box_typ
                bne.s   L0018
                tst.w   L0826           ;vermutlich Shift-Auswertung
                bne.s   L0019
L0018:          moveq   #0,D5
L0019:          rts

L001A:          clr.l   taste           ;keine Taste mehr da
no_taste_da:    jsr     animier_objekte ;Copybox, Farbpalette animieren..
                bsr     get_maus
L001C:          move.w  D2,D5
                andi.w  #%1100000011111100,D5 ;geklickt worden?
                bne     klick_auswert   ;ja
                tst.w   board_da
                beq.s   show_them
                tst.b   magnify         ;Lupe im unteren Rand?
                bne     mainloop        ;Nein, -> weiter
show_them:      cmp.w   maus_print_x,D0 ;öberhaupt bewegt?
                bne.s   L001D
                cmp.w   maus_print_y,D1
                beq     mainloop        ;Nein, weiter warten...
L001D:          move.w  D0,maus_print_x
                move.w  D1,maus_print_y ;Neue Koordinaten merken
                tst.w   board_da
                bne.s   show_koord      ;Lupe im Rand, immer printen

                cmpi.w  #100,D1
                        IF disk_version=0 ;Disketten-Version
                bcs.s   show_koord      ;oberhalb des Boards->printen mx/my
                        ELSE
                bra.s   show_koord      ;Achtung zu Testzwecken
                        ENDC
                bclr    #0,print_koord_stat ;Nicht mehr printen
                beq     mainloop        ;war vorher geprintet?
                jsr     Hm              ;Ja
                lea     L0785,A0        ;'       ' weglîschen
                bsr.s   L0020           ;an Koordinatenstelle ausgeben
                jsr     Sm
                bra     mainloop        ;und weiter warten

dez_tab:                DC.B '0123456789'

;Wandelt die Mauskoordinaten in Ascii
show_koord:     bset    #0,print_koord_stat ;es wurde geprintet
                tst.w   board_da
                bne.s   no_add
                add.w   grab_y,D1
no_add:         lea     L0782,A0        ;x: 000
                ext.l   D0
                divu    #100,D0
                move.b  dez_tab(PC,D0.w),(A0)+
                swap    D0
                ext.l   D0
                divu    #10,D0
                move.b  dez_tab(PC,D0.w),(A0)+
                swap    D0
                move.b  dez_tab(PC,D0.w),(A0)
                addq.l  #4,A0           ;y: 000
                ext.l   D1
                divu    #100,D1
                move.b  dez_tab(PC,D1.w),(A0)+
                swap    D1
                ext.l   D1
                divu    #10,D1
                move.b  dez_tab(PC,D1.w),(A0)+
                swap    D1
                move.b  dez_tab(PC,D1.w),(A0)
                suba.w  #10,A0          ;An Beginn der Message gehen
                bsr.s   L0020           ;ausgeben
                bra     mainloop        ;und weiter warten

L0020:          moveq   #56,D0          ;x/y ausgeben
                move.w  #194,D1
                tst.w   board_da
                beq.s   ok746
                jsr     Hm
                bsr     into_border     ;Ausgabe in Rahmen leiten
                moveq   #3,D1           ;in Rand printen
                tst.b   pal_flag
                bne.s   ok746
                moveq   #5,D1           ;Bei Palette im Rand auf 6 gehen
ok746:          moveq   #0,D2
                jsr     print6x6        ;und ausgeben
                movea.l scr1,A0
                movea.l scr2,A1         ;hier hin Åbertragen
                tst.w   board_da
                beq.s   ok747
                adda.l  #32000+5*160+24,A0 ;Position im Border
                adda.l  #32000+5*160+24,A1
                bsr     into_screen     ;und zurÅckschalten
                jsr     Sm
                bra.s   copy_it2
ok747:          lea     31064(A0),A0    ;Position auf dem Screen
                lea     31064(A1),A1
copy_it2:       moveq   #5,D0
L0021:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                lea     120(A0),A0
                lea     120(A1),A1
                dbra    D0,L0021
;                jsr     Sm
                rts



klick_auswert:  jsr     Hm              ;es wurde geklickt....
                tst.w   board_da
                beq     check_board
                move.w  #199,D6
                move.w  #319,D7
                tst.b   grid_on
                beq.s   L0023
                subq.w  #7,D6
                subq.w  #7,D7
L0023:          tst.w   D0              ;x=0?
                beq.s   L0024
                cmp.w   D7,D0           ;x=319?
                bne.s   L0025           ;Nein, Funktion ausfÅhren
                tst.w   D1              ;y=0?
                beq.s   L0026
L0024:          cmp.w   D6,D1           ;Linke untere Ecke?
                beq.s   L0026           ;ja, Board anschalten
L0025:          bra     L0093           ;Funktion ausfÅhren
L0026:          andi.w  #4,D5
                beq.s   L0025
                tst.b   L062A
                bne.s   L0025
                lsr.w   #2,D5
board_an:       tst.w   blitter_an      ;Ist Blitter an?
                bne.s   wt673           ;nein->Weiter
                jsr     blitter_on      ;Blitter richtig einschalten
wt673:          move.w  D5,-(SP)        ;Board wieder anschalten
                cmpi.b  #7,function     ;Cutter?
                bne.s   no_restore
                bsr     delete_cut_rahm ;Rahmen wieder weg
                bsr     calc_grab       ;Y-Wert berechnen
no_restore:     clr.w   board_da        ;Flag setzen
                move.w  #100,board_y    ;Board liegt auf Koordinate 100
                btst    #0,jack_status  ;Ist was mit dem Jack Knife selektiert?
                beq.s   L0028           ;Nein
                jsr     scr12scr2
L0028:          movea.l scr1,A0
                movea.l scr2,A1
                move.l  A1,scr1         ;Scr1 liegt jetzt bei scr2
                movem.l A0-A1,-(SP)

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                pea     -1.w
                move.l  A1,-(SP)        ;und physikalisch anzeigen
                move.w  #5,-(SP)
                trap    #$0E
                lea     12(SP),SP

                bsr     get_maus        ;Mausposition holen
                jsr     draw_board      ;Zeichnet auf scr2
                movem.l (SP)+,A0-A1
                move.l  A0,scr1
                move.l  A1,scr2

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                move.l  #-1,-(SP)
                move.l  A0,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     12(SP),SP

                move.b  function,D7
                cmpi.b  #3,D7           ;Text?
                bne.s   L002E
                tst.w   L07F2
                bmi.s   L002E
                move.w  grab_y,D0
                move.w  L07F3,D1
                cmp.w   D0,D1
                bcc.s   L002A
                subq.w  #5,D1
                bpl.s   L0029
                moveq   #0,D1
L0029:          bra.s   L002C
L002A:          move.w  L0807,D2
                add.w   L0796,D2
                subi.w  #99,D2
                cmp.w   D2,D0
                bge.s   L002D
                subq.w  #5,D1
                bpl.s   L002B
                moveq   #0,D1
L002B:          cmpi.w  #101,D1
                bcs.s   L002C
                move.w  #100,D1
L002C:          move.w  D1,grab_y
L002D:          move.w  grab_y,D0
                sub.w   D0,L07F3
                bsr     L0189
                bsr     copy_board
                bra.s   L0042

L002E:          tst.b   D7              ;Jack Knife?
                bne.s   L002F
                btst    #0,jack_status  ;Ist was selektiert?
                beq.s   L003F           ;Nein, weiter
                bsr     set_box
                bra     L0044
L002F:          cmpi.b  #2,D7           ;Copybox?
                bne.s   L003F           ;Nein, weiter
cut1:           btst    #0,copy_status  ;Ist was selektiert?
                beq.s   L003F           ;Nein, weiter
                bsr     set_box
                bra.s   L0044
L003F:          movea.l scr1,A0
                movea.l komplettbild,A1
                move.w  #1999,D0
L0040:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;scr1->Komplettbild
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0040
                movea.l komplettbild,A0
                movea.l scr2,A1
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A0
                move.w  #999,D0
L0041:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Oberen 100 Zeilen auf Komplettbild
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0041
L0042:          move.w  (SP)+,D5
L0043:          move.w  D5,-(SP)
                bsr     get_maus
                move.w  (SP)+,D5
                move.w  D2,D6
                and.w   D5,D6
                bne.s   L0043
                movem.w D0-D2,-(SP)
                bsr     switch_screens
                movem.w (SP)+,D0-D2
                cmpi.b  #11,function    ;Animate?
                bne.s   L0044
                bsr     draw_objekt
L0044:          jsr     L0332
                move.b  #-$80,L07A1
                move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                bsr     neue_raster
                bra     endboard

set_box:        move.l  (SP)+,rÅcksprungadr ;RÅcksprungadr retten, da Stackmanip.
                move.w  hîhe,D2
                tst.b   less_memory
                bne.s   L0031           ;genug Speicher
                cmpi.w  #100,D2
                bcs.s   L0031           ;weniger als 100 Zeilen->okay
                move.w  #100,D2
                move.w  D2,hîhe         ;Sonst Hîhe=100
L0031:          move.w  D2,D0
                sub.w   #100,D0         ;Hîhe-100
                bpl.s   L0032           ;Positiv->Objekt zu sehen
                neg.w   D0              ;positiv machen
L0032:          lsr.w   #1,D0
                move.w  ani_y1,D1
                sub.w   D0,D1
                bpl.s   L0033
                moveq   #0,D1
                bra.s   L0034
L0033:          cmpi.w  #101,D1
                bcs.s   L0034
                move.w  #100,D1
L0034:          move.w  D1,grab_y
                sub.w   D1,ani_y1
                move.w  ani_y1,D0
                move.w  D0,objekt_y1
                add.w   D2,D0
                subq.w  #1,D0
                move.w  D0,ani_y4
                movea.l komplettbild,A0
                cmpa.l  objekt_pointer,A0
                bne.s   L0039
                movea.l A0,A2
                movea.l irgend_copy,A1
                move.l  A1,objekt_pointer
                move.w  objekt_y2,D0
                move.w  D0,D2
                mulu    #160,D0
                adda.w  D0,A0
                clr.w   objekt_y2
                move.w  hîhe,D0
                mulu    #10,D0
                bra.s   L0036
L0035:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
L0036:          dbra    D0,L0035
                movea.l A2,A0
                lea     mask_buff,A2
                movea.l A2,A1
                mulu    #40,D2
                beq.s   L0039
                adda.w  D2,A1
                move.w  hîhe,D0
                bra.s   L0038
L0037:          move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
L0038:          dbra    D0,L0037
L0039:          movea.l copybox_screen,A0
                movea.l komplettbild,A1
                movea.l A0,A2
                movea.l A1,A3
                move.w  #1999,D0
L003A:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L003A
                movea.l scr2,A0
                mulu    #160,D1
                adda.w  D1,A3
                move.w  #999,D0
L003B:          move.l  (A3),(A0)+
                move.l  (A3)+,(A2)+
                move.l  (A3),(A0)+
                move.l  (A3)+,(A2)+
                move.l  (A3),(A0)+
                move.l  (A3)+,(A2)+
                move.l  (A3),(A0)+
                move.l  (A3)+,(A2)+
                dbra    D0,L003B
                move.w  (SP)+,D5
L003C:          move.w  D5,-(SP)
                bsr     get_maus
                move.w  (SP)+,D5
                move.w  D2,D6
                and.w   D5,D6
                bne.s   L003C
                tst.b   function        ;Jack Knife?
                bne.s   L003D
                movem.w D0-D4,-(SP)
                bsr     L0063
                jsr     L0408
                movem.w (SP)+,D0-D4
                bsr     copy_board
                bra.s   raus_44

L003D:          movem.w D0-D4,-(SP)     ;hier ist Copybox
                bsr     L0061
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                bsr     draw_box
                movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #999,D0
L003E:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L003E
                bsr     copy_board
                movem.w (SP)+,D0-D4

raus_44:        move.l  rÅcksprungadr,-(SP)
                rts

;Spieler hat geklickt, und Board ist da...
check_board:    move.w  board_y,D7      ;oberhalb Board?
                cmp.w   D7,D1
                bcs     L0093           ;Dann Funktion ausfÅhren....
such_function:  btst    #2,D2           ;Links geklickt?
                beq.s   no_cheat
                cmp.w   #16,D0
                bne.s   no_cheat
                cmp.w   #199,D1         ;ein biûchen spielen...
                bne.s   no_cheat
                not.b   cheat_modus
no_cheat:       moveq   #114,D7         ;Untere Kante der Farbpalette
                cmp.w   D7,D1
                bcc     check_fun
                btst    #2,D2           ;Links neu gedrÅckt?
                bne     set_new_color   ;Dann will Spieler neue Zeichenfarbe
                btst    #3,D2           ;rechts neu gedrÅckt?
                beq     endboard        ;nein, dann raus

                move.w  D0,D5           ;Spieler will Farbpfeile verschieben
                ext.l   D5
                move.w  left_col_mark,D6
                move.w  right_col_mark,D7
                divu    #20,D5
                btst    #7,D2           ;Rechter Doppelklick?
                bne.s   farbe_setzen
                moveq   #0,D2
                cmp.w   D6,D5           ;Linke Color Mark?
                beq.s   L0046
                moveq   #1,D2
                cmp.w   D7,D5           ;Rechte Color Mark?
                beq.s   L0046
farbe_setzen:   jsr     del_farb_ecke
                move.w  D5,hintergrundfarbe
                jsr     set_farb_ecke
                bra     endboard
L0046:          cmp.w   D6,D7
                bne.s   L0048
                moveq   #0,D2
                swap    D5
                cmpi.w  #$000A,D5
                bcs.s   L0047
                moveq   #1,D2
L0047:          swap    D5
L0048:          move.w  D2,D7
                bne.s   L0049
                moveq   #0,D1
                move.w  right_col_mark,D3
                mulu    #$0014,D3
                bra.s   L004A
L0049:          move.w  left_col_mark,D1
                mulu    #$0014,D1
                move.w  #$012C,D3
L004A:          swap    D1
                swap    D3
                swap    D7
                move.w  D5,D0
                mulu    #$0014,D0       ;x1
                move.w  #$0065,D1       ;y1
                move.w  D0,D2
                add.w   #$0012,D2       ;x2
                move.w  #$006E,D3       ;y2
                move.w  #$000F,D4       ;Farbe
                moveq   #2,D5           ;Schreibmodus
                moveq   #-1,D6          ;linientyp
                bsr     rahmen
                jsr     Sm
                movem.l D0-D6,-(SP)
L004B:          move.l  D7,-(SP)
                bsr     get_maus
                move.l  (SP)+,D7
                andi.w  #%1000000000100000,D2 ;Rechts losgelassen oder verÑndert?
                beq.s   L004B
                btst    #5,D2           ;Rechts losgelassen?
                bne.s   L004F           ;ja, beenden
                sub.w   D3,D0
                move.w  D0,D7
                movem.l (SP)+,D0-D6
                jsr     Hm
                bsr     rahmen
                swap    D1
                swap    D3
                add.w   D7,D2
                add.w   D7,D0
                bmi.s   L004C
                cmp.w   D1,D0
                bcc.s   L004D
L004C:          move.w  D1,D0
                move.w  D1,D2
                addi.w  #$0012,D2
L004D:          cmp.w   D0,D3
                bcc.s   L004E
                move.w  D3,D0
                move.w  D3,D2
                addi.w  #$0012,D2
L004E:          swap    D1
                swap    D3
                bsr     rahmen
                jsr     Sm
                movem.l D0-D6,-(SP)
                bra.s   L004B
L004F:          movem.l (SP)+,D0-D6
                bsr     rahmen
                swap    D7
                add.w   #$000A,D0
                ext.l   D0
                divu    #$0014,D0
                tst.w   D7
                bne.s   L0050
                jsr     del_left_col_mark
                move.w  D0,left_col_mark
                jsr     draw_left_col_mark
                bra.s   L0051
L0050:          jsr     del_right_col_mark
                move.w  D0,right_col_mark
                jsr     draw_right_col_mark
L0051:          bsr     copy_board
                bsr     get_maus        ;Mauskoordinate holen
                moveq   #0,D7
                cmp.w   board_y,D1
                bcc.s   L0052
                moveq   #3,D7
L0052:          move.b  D7,mouse_pos
                bra     endboard

check_fun:      move.w  D2,D3           ;Mausstatus holen
                andi.w  #%0000000011111100,D3 ;Buttons lîschen
                beq     endboard        ;nichts gedrÅckt...
                cmpi.w  #114,D1         ;im Y-Bereich Full-Screen, Grid?
                bcs     L006C           ;nein->Raus
                cmpi.w  #178,D1
                bcc     L006C           ;nein->Raus
                cmpi.w  #114,D0         ;kein Grid, vielleicht Full-Screen
                bcs.s   check_fullscreen
                cmpi.w  #123,D0         ;zu Groû->Raus
                bcc     L006C
                andi.w  #%0000000000001100,D3 ;neu gedrÅckt muss es schon sein
                beq     endboard        ;sonst raus hier...

                not.b   grid_on         ;Flag umdrehen
                tst.w   board_da        ;Ist Board da?
                bne     endboard        ;Nein, nichts zeichnen

                movem.w D0-D2,-(SP)
                moveq   #$72,D0         ;X
                move.w  #$0073,D1       ;Y
                moveq   #$10,D2         ;Iconnummer
                moveq   #$0F,D3         ;Farbe
                move.l  #$FFFF0008,D5
                move.l  #$FFFE0001,D6
                tst.b   grid_on
                bne.s   L0054
                jsr     L032B           ;entsprechend an oder aus zeichnen
                bra.s   L0055
L0054:          jsr     L032A
L0055:          movem.w (SP)+,D0-D2
                bra     endboard        ;und weiter

check_fullscreen:cmpi.w #9,D0           ;FullScreen?
                bcc     L006C           ;zu groû->Raus
                move.w  D2,D3
                andi.w  #%0000000000110000,D3 ;Irgendwas losgelassen?
                beq     L006C           ;ja->Raus
fullscreen:     move.w  #666,maus_print_x ;Koordinaten auf jeden Fall printen!
                tst.b   magnify         ;Ist Lupe da?
                bne.s   wt674           ;Nein, weiter
                tst.w   blitter_an      ;Ist Blitter an?
                bne.s   wt674           ;Nein, okay...

                move.w  #%0000000000000000,-(SP)
                move.w  #64,-(SP)
                trap    #14             ;sonst Blitter ausschalten
                addq.l  #4,SP

wt674:          bsr     scroller_aus    ;schaltet ggf. den Scroller aus!
                move.b  function,D7
                cmp.b   #7,D7           ;Cutter?
                bne.s   no_cutter
                bsr     box_anpass      ;Koordinaten der Cutterbox anpassen
no_cutter:      tst.b   less_memory     ;Genug Speicher da?
                bne.s   L0059
                tst.b   D7              ;Jack Knife?
                beq.s   less_mem_4_jack ;ja->Less memory...
                cmpi.b  #2,D7           ;Copybox?
                bne.s   L0059           ;nein, okay
less_mem_4_jack:jsr     Hm              ;zu Wenige Speicher fÅr Copy und Jack
                lea     fun_exit(PC),A0 ;Tabelle
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0
                jsr     (A0)            ;Funktion abschalten...
                bsr     alle_irqs_aus
                bsr     switch2tos
                jsr     Sm
                moveq   #$0F,D0         ;15=Arrow
                bsr     set_mouse_d0
                move.l  #L00D2,D0       ;Not enough RAM for Jack or Copy
                jsr     alert
                bra     back2neo

L0059:          move.b  #-1,copyr_work  ;Keine Copyright-Spielereien mehr
                move.w  #-1,board_da    ;Flag setzen
                move.w  #200,board_y    ;Jetzt ist kein Board da...
                cmpi.b  #3,D7           ;Text?
                bne.s   L005A           ;Nein
                tst.w   L07F2
                bmi.s   L005A
                move.w  grab_y,D0
                add.w   D0,L07F3
                bsr     L0189
                bra     L006B

L005A:          movea.l komplettbild,A0
                movea.l scr2,A1         ;Auf Screen2 aufbauen
                move.w  #1999,D1
L005B:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Komplettbild->scr2
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D1,L005B
                tst.b   D7              ;Jack Knife?
                bne.s   L005C
                btst    #0,jack_status  ;Bereits was ausgeschnitten?
                beq     L0069           ;Nein, weiter
                bra.s   L005D
L005C:          cmpi.b  #2,D7           ;Copybox?
                bne     L0069           ;Nein

                btst    #0,copy_status  ;Bereits was ausgeschnitten?
                beq     L0069           ;Nein, weiter

;Es wurde Fullscreen gewÅnscht, Jack Knife, Copybox oder Cutter sind bereits aktiv
L005D:          movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  grab_y,D0
                mulu    #$00A0,D0
                adda.w  D0,A1
                move.w  #999,D0
L005E:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Dann von Physbase (0..99)->scr2
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L005E
                movea.l scr2,A0
                movea.l copybox_screen,A1
                move.w  #1999,D0
L005F:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;und kompletten scr2->physbase
                move.l  (A0)+,(A1)+
                dbra    D0,L005F

                move.w  grab_y,D0
                add.w   D0,ani_y1
                add.w   D0,objekt_y1
                add.w   D0,ani_y4
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
;               bsr     alle_irqs_aus   ;Event_Timer an, Raster aus (war nach 222)
                cmp.b   #7,D7           ;Cutter?
                beq.s   no_copyscreen2  ;ja, nichts kopieren
                bsr     draw_box
                movea.l scr2,A1
                movea.l copybox_screen,A0
                move.w  #1999,D0
L0060:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0060
no_copyscreen2: jsr     L0332
                tst.b   function        ;Jack Knife
                bne.s   L0068           ;Nein
                bsr.s   L0063
                jsr     L0408
                bra     endboard

L0061:          bsr     check_in_box
                bne.s   L0062
                bset    #3,copy_status  ;Jetzt ist Maus in der Box
                bra.s   L0064
L0062:          bclr    #3,copy_status  ;Maus ist nicht in Box
                bra.s   L0066
L0063:          bsr     L0100
                bne.s   L0065
                bset    #3,jack_status
L0064:          move.w  D0,-(SP)
                moveq   #$0F,D0         ;Arrow
                bsr     set_mouse_d0
                move.w  (SP)+,D0
                bra.s   L0067
L0065:          bclr    #3,jack_status
L0066:          bsr     set_mouse       ;setzt den entsprechenden Mauszeiger
L0067:          bsr     neue_raster
                rts

L0068:          bsr.s   L0061
                bra     endboard

L0069:          movea.l scr1,A0
                movea.l scr2,A1
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A1
                move.w  #999,D0
L006A:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Arbeitsbereich von scr1->scr2
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L006A
                bsr     switch_screens  ;Jetzt scr2 anzeigen
                cmpi.b  #11,function    ;Animate?
                bne.s   L006B
                bsr     draw_objekt     ;Objekt neu zeichnen
L006B:          jsr     L0332
;                bsr     alle_irqs_aus   ;Timer an, Raster aus
                bsr     set_mouse
                bsr     neue_raster     ;Bitte die Raster neu berechnen
                bsr     get_maus
                jsr     Hm
                bsr     check_lupe      ;und Lupe neu aufbauen
                jsr     Hm
                bra     endboard

L006C:          move.w  D2,D3
                andi.w  #%0000000011001100,D3 ;Taste neu gedrÅckt oder losgelassen?
                beq     endboard        ;Nein, raus
                move.w  D2,D4
                andi.w  #%0000000000001100,D4 ;Taste neu gedrÅckt?
                beq     L0070           ;Nein, also neu losgelassen

                move.w  D0,D3
                move.w  D1,D4
                subi.w  #212,D3         ;In RGB-Wert?
                bcs     L0070
                lsr.w   #3,D3           ;/8
                cmpi.w  #3,D3           ;mehr als 3 Werte gibt es nicht..
                bcc     L006F
                subi.w  #118,D4         ;Y-Wert richtig?
                bcs     L006F           ;Nein, weitertesten
                cmpi.w  #8,D4
                bcc     L006F
                move.w  color,D6        ;Alten Farbwert holen
                moveq   #2,D4
                sub.w   D3,D4           ;D4=2..0
                lsl.w   #2,D4           ;mal 4=8,4,0
                lsr.w   D4,D6           ;und Nibble runterschieben
                moveq   #%00001111,D3   ;Maske
                and.w   D3,D6           ;entsprechendes Nibble selektiern
                lea     ste_add(PC),A0
                tst.w   ste_support
                beq.s   ste2
                and.w   #%0000000000000111,D6 ;ausmaskieren
                lea     st_add(PC),A0
ste2:           cmp.b   (A0)+,D6        ;Dieses Nibble suchen
                bne.s   ste2

                btst    #2,D2           ;Links neu gedrÅckt?
                bne.s   L006D           ;ja, weiter

                move.b  -2(A0),D6       ;vorherige Farbe holen
                bra.s   L006E
L006D:          move.b  (A0),D6         ;nÑchste Farbe holen
L006E:          lsl.w   D4,D6           ;und wieder hoch schieben
                lsl.w   D4,D3           ;Maske hochschieben
                not.w   D3              ;invertieren
                move.w  color,D5        ;Farbe holen
                and.w   D3,D5           ;Nibble lîschen
                or.w    D6,D5           ;und einodern

                movem.w D0-D2,-(SP)
                bsr     neue_chg_color  ;Farbe setzen
                movem.w (SP)+,D0-D2
                bsr     copy_board
                bra     endboard

;rechnet STE-Color in normale Darstellung um: (rol.n #1,Dx)
ste2normal:             DC.B %00000000,%00000010,%00000100,%00000110
                        DC.B %00001000,%00001010,%00001100,%00001110
                        DC.B %00000001,%00000011,%00000101,%00000111
                        DC.B %00001001,%00001011,%00001101,%00001111

;Tabelle, wie beim STE im Farbregister addiert wird:
                        DC.B %00001111
ste_add:
normal2ste:             DC.B %00000000,%00001000,%00000001,%00001001
                        DC.B %00000010,%00001010,%00000011,%00001011
                        DC.B %00000100,%00001100,%00000101,%00001101
                        DC.B %00000110,%00001110,%00000111,%00001111
                        DC.B %00000000

                        DC.B %00001111
st_add:                 DC.B %00000000,%00000001,%00000010,%00000011
                        DC.B %00000100,%00000101,%00000110,%00000111
                        DC.B %00000000,%00000001,%00000010,%00000011
                        DC.B %00000100,%00000101,%00000110,%00000111
                        DC.B %00000000

L006F:          move.w  D0,D3
                move.w  D1,D4
                sub.w   #238,D3
                bcs.s   L0070
                cmpi.w  #25,D3
                bcc.s   L0070
                sub.w   #115,D4
                bcs.s   L0070
                cmpi.w  #13,D4
                bcs     L008C

L0070:          move.w  rot_col_direct,D6 ;in welche Richtung animieren?
                move.w  D2,D7
                move.w  D0,D3
                move.w  D1,D4
                sub.w   #197,D3
                bcs     L007C
                sub.w   #114,D4
                bcs     L007C
                cmpi.w  #15,D4          ;Wurde in den rechten Color-Pfeil geklickt?
                bcc     L007C
                cmpi.w  #13,D3
                bcs     L0074
                cmpi.w  #67,D3
                bcs     L007C
                cmpi.w  #80,D3
                bcc     L007C

                eori.w  #$000C,D7       ;Animationspfeil rechts
                btst    #1,D6           ;Wird nach rechts color animiert?
                bne     L007A           ;ja, animation links
                btst    #0,D6           ;Wird nach rechts color animiert?
                beq.s   L0071           ;Nein, weiter
                clr.w   rot_col_direct  ;Animation stop!
                move.w  rot_col_counter,L0756
                movem.w D0-D4,-(SP)
                move.w  #200,D0         ;Koordinaten
                move.w  #116,D1
                moveq   #$17,D2         ;Nummer des Icons (Pfeil rechts)
                moveq   #15,D3          ;Farbe
                jsr     draw_icon       ;ausschalten
                movem.w (SP)+,D0-D4
                bsr     copy_board
                bra     endboard

L0071:          movem.w D0-D4,-(SP)
                move.w  #$010A,D0
                move.w  #$0074,D1
                moveq   #$18,D2
                moveq   #$0F,D3
                jsr     draw_icon_inv
                movem.w (SP)+,D0-D4
                btst    #3,D2           ;Rechts neu gedrÅckt?
                beq.s   L0072           ;Nein, also links
                bsr     rette_palette
                move.w  #2,rot_col_direct ;Richtung der Animation rechts
                clr.w   rot_col_counter
                bra     endboard

L0072:          bsr     rette_palette   ;Alte Palette retten
                bsr     rot_col_rechts  ;Color Animation nach rechts
L0073:          bsr     get_maus
                btst    #4,D2           ;Links neu losgelassen?
                beq.s   L0073           ;Nein, weiter warten
                movem.w D0-D4,-(SP)
                move.w  #$010A,D0
                move.w  #$0074,D1
                moveq   #$18,D2
                moveq   #$0F,D3
                jsr     draw_icon       ;Und Pfeil wieder normal zeichnen
                movem.w (SP)+,D0-D4
                bra     endboard

L0074:          btst    #0,D6
                bne     L007A
                btst    #1,D6
                beq.s   L0075
                clr.w   rot_col_direct
                move.w  rot_col_counter,L0756
                movem.w D0-D4,-(SP)
                move.w  #$010A,D0
                move.w  #$0074,D1
                moveq   #$18,D2
                moveq   #$0F,D3
                jsr     draw_icon
                movem.w (SP)+,D0-D4
                bsr     copy_board
                bra     endboard

L0075:          movem.w D0-D4,-(SP)
                move.w  #$00C8,D0
                move.w  #$0074,D1
                moveq   #$17,D2
                moveq   #$0F,D3
                jsr     draw_icon_inv
                movem.w (SP)+,D0-D4
                btst    #3,D2           ;Rechts neu gedrÅckt?
                beq.s   L0076           ;Nein, also links
                bsr.s   rette_palette
                move.w  #1,rot_col_direct ;Richtung der Animation ist links
                clr.w   rot_col_counter
                bra     endboard

L0076:          bsr.s   rette_palette
                bsr     rot_col_links   ;Color Animation links rum
L0077:          bsr     get_maus        ;warten bis links losgelassen
                btst    #4,D2
                beq.s   L0077
                movem.w D0-D4,-(SP)
                move.w  #$00C8,D0
                move.w  #$0074,D1
                moveq   #$17,D2
                moveq   #$0F,D3
                jsr     draw_icon       ;Und Pfeil links wieder normal zeichnen
                movem.w (SP)+,D0-D4
                bra     endboard

;Palette vor VerÑnderung sichern
rette_palette:  movem.l D0-D1/A0-A2,-(SP)
                lea     hbl_system+2,A0
                move.w  rst_akt,D0
                mulu    #34,D0
                adda.l  D0,A0           ;=Adresse der aktuelle Palette
                lea     palette_undo,A1
                lea     palette_all_undo,A2
                move.w  #$000F,D0
L0079:          move.w  (A0)+,D1
                move.w  D1,(A1)+
                move.w  D1,(A2)+
                dbra    D0,L0079
                movem.l (SP)+,D0-D1/A0-A2
                rts

;nur gesamte Palette vor VerÑnderung sichern
rette_all_palette:movem.l D0/A0-A1,-(SP)
                lea     hbl_system+2,A0
                move.w  rst_akt,D0
                mulu    #34,D0
                adda.l  D0,A0           ;=Adresse der aktuelle Palette
                lea     palette_all_undo,A1
                move.w  #$000F,D0
L00793:         move.w  (A0)+,(A1)+
                dbra    D0,L00793
                movem.l (SP)+,D0/A0-A1
                rts

;FÅhrt einen UNDO bei der gesamten Farbpalette aus
undo_palette:   movem.l D0-A6,-(SP)
                lea     hbl_system+2,A0
                move.w  rst_akt,D0
                mulu    #34,D0
                adda.l  D0,A0
                lea     palette_all_undo,A1
                moveq   #15,D7
L00792:         move.w  (A0),D0
                move.w  (A1),(A0)+      ;Farbpaletten vertauschen
                move.w  D0,(A1)+
                dbra    D7,L00792
                bsr     palette_changed
                movem.l (SP)+,D0-A6
                rts

;FÅhrt bei einer einzelnen Farbe einen Color-Undo aus
; D0.W: Farbnummer
undo_color:     movem.l D0-A6,-(SP)
                lea     hbl_system+2,A0
                move.w  rst_akt,D1
                mulu    #34,D1
                adda.l  D1,A0
                lea     palette_undo,A1
                add.w   D0,D0
                adda.w  D0,A0
                adda.w  D0,A1
                move.w  (A0),D0
                move.w  (A1),(A0)       ;Farben vertauschen
                move.w  D0,(A1)
                bsr     palette_changed
                movem.l (SP)+,D0-A6
                rts

L007A:          btst    #2,D7           ;Links neu gedrÅckt?
                bne.s   L007B           ;Ja, testen
                addq.w  #1,rot_col_speed ;eins weiter (?)
                bra     endboard
L007B:          subq.w  #1,rot_col_speed
                cmpi.w  #1,rot_col_speed
                bcc     endboard
                move.w  #1,rot_col_speed
                bra     endboard

L007C:          cmpi.w  #279,D0
                bcs.s   kein_undo
                cmpi.w  #312,D0
                bcc.s   kein_undo       ;Koordinaten richtig?
                cmpi.w  #115,D1
                bcs.s   kein_undo
                cmpi.w  #121,D1
                bcc.s   maybe_color
                bsr     do_undo
                bra.s   kein_undo

maybe_color:    cmp.w   #128,D1
                bgt.s   kein_undo

                btst    #2,D2           ;Linker Knopf gedrÅckt?
                bne.s   undo_pal
                btst    #3,D2           ;Rechter Knopf gedrÅckt?
                beq.s   kein_undo       ;Nein->Kein Undo

                move.w  zeichenfarbe,D0
                bsr     undo_color      ;Color Undo
                bra     endboard

undo_pal:       bsr     undo_palette
                bra     endboard

zeichen_undo:   bsr     do_undo
                bra     endboard

kein_undo:      cmp.w   #11,D0
                bge.s   L007D2
                cmp.w   #180,D1
                blt.s   L007D2          ;Koordinaten der Bildschirmnummer
                cmp.w   #190,D1
                bgt.s   L007D2

                btst    #0,D2           ;Links gedrÅckt?
                bne.s   erhîhe
                btst    #1,D2           ;Rechts gedrÅckt?
                beq.s   L007D2          ;Nein->Weiter

                tst.w   akt_work
                beq.s   L007D2

                move.w  D0,-(SP)
                move.w  akt_work,D0
                subq.w  #1,D0           ;vorigen Arbeitsbildschirm
                bsr     show_workscreen
                move.w  (SP)+,D0
                bra.s   L007D2

erhîhe:         move.w  anz_screens,D3
                cmp.w   akt_work,D3
                ble.s   L007D2

                move.w  D0,-(SP)
                move.w  akt_work,D0
                addq.w  #1,D0           ;NÑchsten Arbeitsbildschirm
                bsr     show_workscreen
                move.w  (SP)+,D0

L007D2:         move.w  D0,D3
                sub.w   #198,D3         ;X
                bcs.s   turn_func_on
                move.w  D1,D4           ;Y
                sub.w   #130,D4
                bcs.s   turn_func_on    ;rechtes Board
                jsr     bedien_options  ;in Routinen springen...
                bra     endboard

turn_func_on:   move.w  D0,D3           ;mx
                move.w  D1,D4           ;my
L007F:          subi.w  #9,D3           ;kleiner 9, vielleicht Fullscreen...
                bcs     L0083
                move.w  D3,D5           ;mx
                ext.l   D5
                divu    #21,D5          ;Funktionsx berechnen
                cmpi.w  #5,D5           ;Nur 5 pro Zeile
                bcc     L0083
                subi.w  #115,D4         ;Hier beginnen die Funktionen
                bcs     L0083           ;zu weit oben
                move.w  D4,D6
                ext.l   D6
                divu    #$0015,D6
                cmpi.w  #3,D6           ;3 Funktionszeilen
                bcc     L0083
                lea     icon_func,A0    ;welche Funktion hat welches Icon?
                move.w  D6,D7
                mulu    #5,D7
                add.w   D5,D7           ;Neue Funktionsnummer berechnen
                tst.b   0(A0,D7.w)      ;Funktion verfÅgbar?
                beq     endboard        ;nein....
                cmp.b   #10,D7          ;jetzt Disk?
                beq.s   drÅber90        ;ja, in jedem Fall auswerten
                cmp.b   #13,D7          ;jetzt Eraser?
                beq.s   drÅber90        ;ja, in jedem Fall auswerten
                cmp.b   #9,D7           ;jetzt Brush/Nozzle?
                bne.s   no_brush_nozzle
                clr.w   brush           ;Jetzt ist Brush aktiv
                btst    #0,D2           ;Links geklickt?
                bne.s   drÅber90
                move.w  #1,brush        ;Jetzt ist Nozzle aktiv
                bra.s   drÅber90
no_brush_nozzle:cmp.b   function,D7     ;Selbe Funktion wie vorher?
                beq     endboard        ;ja, nicht ausfÅhren
drÅber90:       tst.b   function        ;Alte Funktion Jack Knife?
                bne.s   kein_jack8
                cmp.b   #2,D7           ;Neue Function Copybox?
                bne.s   kein_jack8
                bsr     transfer2copybox
kein_jack8:     cmpi.b  #2,function     ;Alte Funktion Copybox?
                bne.s   kein_copy2
                tst.b   D7              ;Neue Funktion Jack Knife?
                bne.s   kein_copy2
                bsr     transfer2jack
kein_copy2:     swap    D5
                swap    D6
                sub.w   D5,D3
                sub.w   D6,D4
                addi.w  #$000A,D3
                addi.w  #$0074,D4
                move.w  D3,D5
                move.w  D4,D6
                movem.w D0-D2,-(SP)
                jsr     Hm
                movem.l D0-A0,-(SP)
                lea     fun_exit(PC),A0 ;alte Funktion abschalten
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0
                jsr     (A0)            ;alte-Funktion-aus-Routine starten
                movem.l (SP)+,D0-A0
                cmp.b   #13,D7          ;Eraser?
                bne.s   no_eraser       ;Nein, weiter
                move.w  D2,D3
                and.w   #%0000000011000000,D3 ;Doppelklick?
                bne.s   auswerten3
                cmpi.b  #13,function    ;vorher auch Eraser?
                bne.s   no_eraser       ;Nein, weiter
auswerten3:     btst    #1,D2           ;Rechts neu gedrÅckt?
                bne     quit_from_board ;und tschÅss...
                btst    #0,D2           ;links neu gedrÅckt?
                bne     erase_all       ;ja, alles lîschen, geht dann nach no_eraser
no_eraser:      cmpi.w  #10,D7          ;Jetzt wieder Disk-Funktion?
                bne.s   L0080           ;Nein, weiter
                move.w  D2,D3
                and.w   #%0000000011000000,D3 ;Doppelklick?
                bne.s   auswerten2
                cmpi.b  #10,function    ;vorher Disk-Funktion?
                bne.s   L0080           ;Nein, also alles normal
                move.w  D2,D3           ;Button-Status
                and.w   #%0000000000001100,D3 ;irgendwas NEU gedrÅckt?
                beq.s   L0080           ;Nein, weiter
auswerten2:     movem.w (SP)+,D0-D2
                btst    #0,D2           ;Links gedrÅckt?
                bne     save_neo        ;ja->Save-Routine
                bra     load_neo        ;Sonst Laderoutine

L0080:          move.w  #$000F,D3
                move.b  function,D1     ;Alte Funktion holen
                andi.w  #$00FF,D1
                move.b  0(A0,D1.w),D2   ;Iconnummer holen
                ext.w   D2
                ext.l   D1
                divu    #5,D1           ;Reihe bestimmen
                swap    D1
                move.w  D1,D0
                swap    D1
                mulu    #$0015,D0
                mulu    #$0015,D1       ;Koordinate berechnen
                addi.w  #$000A,D0
                addi.w  #$0074,D1       ;Feste Offsets
                cmpi.b  #18,D2          ;Eraser?
                beq.s   L0081           ;ja, weiter
                move.w  D0,L07CC        ;Koordinaten merken
                move.w  D1,stack
L0081:          tst.w   board_da        ;Ist das Board Åberhaupt da?
                bne.s   no_board1       ;Nein! Kein Icon malen
                jsr     draw_func       ;alte Function normal zeichnen
no_board1:      move.w  D5,D0
                move.w  D6,D1
                move.b  0(A0,D7.w),D2   ;neue Iconnummer holen
                ext.w   D2
                tst.w   board_da        ;öberhaupt ein Board da?
                bne.s   no_board2       ;NEIN! kein Icon
                jsr     draw_func_inv   ;Neue Funktion invertieren
no_board2:      move.b  function,old_function ;Alte Funktion merken
                move.b  D7,function     ;und Funktion anschalten....
                move.w  4(SP),D2        ;Alten Button vom Stack
                lea     fun_init(PC),A0 ;Neue-Funktion-an-Routine...
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0
                clr.b   L076B
                jsr     (A0)
                tst.w   copycut         ;Wurde von Jack<->Copybox transferiert?
                bne.s   kein_transfer3
                bsr     jack_copy_paste
kein_transfer3: tst.w   board_da        ;öberhaupt ein Board da?
                bne.s   no_board3
                bsr     scroller_aus    ;ggf. den Scroller ausschalten
                jsr     draw_options    ;Board da->Options zeichnen
                btst    #0,mouse_pos    ;Maus im Boardbereich?
                beq.s   board_da1       ;ja, nichts, sonst Mausform setzen
no_board3:      bsr     set_mouse       ;Entsprechenden Mauscursor anschalten
board_da1:      tst.b   copyr_work      ;Werden noch Copyrights durchgeschaltet?
                bmi.s   L0082           ;Nein, weiter
                move.b  #-1,copyr_work  ;ausschalten
                bsr     show_fn         ;Filenamen ausgeben
L0082:          bsr     copy_board
                bra     L008D
L0083:          move.w  D0,D3
                move.w  D1,D4
                subi.w  #$007E,D3
                bcs     endboard
                move.w  D3,D5
                ext.l   D5
                divu    #5,D5
                cmpi.w  #$000D,D5
                bcc     endboard
                subi.w  #$0072,D4
                bcs     endboard
                move.w  D4,D6
                ext.l   D6
                divu    #5,D6
                cmpi.w  #$0010,D6
                bcc     endboard
                btst    #2,D2
                bne     L0089
                move.w  #1,D0
                bsr     set_mouse_d0
                clr.w   L07CB
                jsr     Sm
L0084:          bsr     get_maus
                btst    #5,D2           ;Rechts losgelassen?
                bne     L0088           ;ja, weiter testen
                move.w  L07CB,D5
                move.b  pos_color512,D4
                ext.w   D4
                sub.w   D0,D3
                bcc.s   L0085
                eori.w  #-1,D3
                addq.w  #1,D3
                add.w   D3,D5
                ext.l   D5
                divu    #5,D5
                sub.w   D5,D4
                bcs.s   L0084
                bra.s   L0086
L0085:          add.w   D3,D5
                ext.l   D5
                divu    #5,D5
                add.w   D5,D4
                cmpi.b  #$14,D4
                bcc.s   L0084
L0086:          swap    D5
                move.w  D5,L07CB
                cmp.b   pos_color512,D4
                beq.s   L0084
                bsr     L0279
                move.b  D4,pos_color512
                bsr     L02A0
                move.b  colorx,D0
                sub.b   pos_color512,D0
                bcs.s   L0087
                cmpi.b  #$0D,D0
                bcc.s   L0087
                ext.w   D0
                move.b  colory,D1
                ext.w   D1
                bsr     draw_hot_spot
L0087:          bsr     copy_board
                jsr     Sm
                bra     L0084

L0088:          movem.w D0-D1,-(SP)
                jsr     Hm
                bsr     copy_board
                moveq   #$0F,D0
                bsr     set_mouse_d0
                movem.w (SP)+,D0-D1
                bra     endboard
L0089:          movem.w D0-D1,-(SP)
                move.b  D5,D0
                add.b   pos_color512,D0
                cmp.b   colorx,D0
                bne.s   L008A
                cmp.b   colory,D6
                beq.s   L008B
L008A:          bclr    #6,D2
                bsr     L0279
                move.b  D0,colorx
                move.b  D6,colory
                move.w  D5,D0
                move.w  D6,D1
                bsr     draw_hot_spot
L008B:          movem.w (SP)+,D0-D1
                bsr     print_rgb
                bsr     copy_board
L008C:          btst    #6,D2           ;Doppelklick links
                beq     maybe_right     ;Nein
                clr.b   changed         ;Jetzt wurde was verÑndert
                bsr     rette_all_palette ;Alte Palette retten
                lea     hbl_system+2,A0 ;d.h. Kasten_Farbe in Palette Åbernehmen
                move.w  rst_akt,D5
                mulu    #34,D5
                adda.l  D5,A0           ;=Adresse der aktuellen Palette
                lea     palette_undo,A1
                move.w  zeichenfarbe,D5 ;Index der Zeichenfarbe
                add.w   D5,D5
                move.w  color,0(A0,D5.w) ;Neue Farbe in Farbpalette
                bsr     palette_changed ;und Palette Åbernehmen
                tst.w   D5              ;Hintergrundfarbe?
                bne     endboard        ;Nein, raus
                bsr     clear_bottom_lupe
                bra     endboard
L008D:          jsr     Sm
                movem.w (SP)+,D0-D2
                bra     endboard

maybe_right:    btst    #7,D2           ;Doppelklick rechts?
                beq     endboard        ;Nein
                lea     hbl_system+2,A0
                move.w  rst_akt,D5
                mulu    #34,D5
                adda.l  D5,A0
                move.w  zeichenfarbe,D5
                add.w   D5,D5
                move.w  0(A0,D5.w),D5   ;aktuelle Farbe runterholen
                move.w  D5,color

                movem.w D0-D2,-(SP)
                bsr     neue_chg_color  ;Farbe setzen
                movem.w (SP)+,D0-D2
                bsr     copy_board

                bra     endboard

;User will neue Farbe setzen
set_new_color:  movem.w D0-D2,-(SP)
                moveq   #0,D3
                move.w  D0,D3
                divu    #20,D3          ;Farbregister bestimmen
                bsr     del_farb_ecke
                move.w  D3,zeichenfarbe
                jsr     init_text
                bsr     set_farb_ecke
                move.b  function,D5
                cmpi.b  #3,D5           ;Text?
                bne.s   L0090           ;Nein, weiter
                bsr     copy_board
                bsr     L0189           ;Re-print in neuer Farbe
L0090:          btst    #6,5(SP)        ;Doppelklick links?
                beq.s   L0091           ;Nein, weiter
                lea     hbl_system+2,A0
                move.w  rst_akt,D5
                mulu    #34,D5
                adda.l  D5,A0           ;=Adresse der aktuellen Palette
                move.w  zeichenfarbe,D5 ;d.h. Doppelklick auf Palette->Kastenfarbe
                add.w   D5,D5
                move.w  0(A0,D5.w),D5   ;Farbe aus Palette holen
                bsr     neue_chg_color  ;Diese Farbe in 512'er suchen
L0091:          movem.w (SP)+,D0-D2
                bsr     copy_board
endboard:       tst.b   fernsteuerung   ;Wird hier ein Mausklick emuliert?
                beq     mainloop        ;ja, dann keine Lupe mehr aufbauen etc.
                bsr.s   check_tastatur
                beq.s   L0095
                bra.s   L0094

L0093:          bsr.s   check_tastatur
L0094:          lea     fun_do(PC),A0
                lsl.w   #2,D5
                movea.l 0(A0,D5.w),A0
                movem.w D0-D1,-(SP)
                jsr     (A0)            ;jeweilige Funktion im Zeichenfeld ausfÅhren
                movem.w (SP)+,D0-D1
L0095:          bsr     check_lupe
                bra     mainloop

;Parameter:
;D0: X
;D1: Y
;Ausgabe in D3
get_pixel:      movem.l D0-D2/A0,-(SP)  ;Register retten

                movea.l scr1,A0         ;von scr1 holen
                bsr.s   get_pixel_scr

                movem.l (SP)+,D0-D2/A0  ;Register her
                rts

;Holt Pixel von Screen (CHS):
;Parameter:
;D0: x
;D1: y
;A0: screenadresse
;RÅckgabe in D3
get_pixel_scr:  movem.l D0-D2/A0,-(SP)
                mulu    #160,D1         ;y
                move.w  D0,D2
                lsr.w   #1,D0           ;/2
                andi.w  #%1111111111111000,D0
                add.w   D0,D1
                adda.w  D1,A0
                not.w   D2
                andi.w  #$000F,D2
                bclr    #3,D2
                bne.s   L0097
                addq.l  #1,A0
L0097:          moveq   #0,D3
                move.w  #3,D1
L0098:          lsr.w   #1,D3
                btst    D2,(A0)
                beq.s   L0099
                ori.w   #8,D3
L0099:          addq.l  #2,A0
                dbra    D1,L0098
                movem.l (SP)+,D0-D2/A0
                rts

check_tastatur: move.b  function,D5
                ext.w   D5
                btst    #14,D2          ;Taste gekommen?
                beq     L009B           ;Nein...
                cmpi.b  #3,D5           ;Text?
                bne.s   no_text         ;Nein, weiter
                btst    #1,text_status  ;Cursor zu sehen?
                bne.s   L009C           ;Ja, an textroutine Åbergeben
no_text:        move.w  taste,D6        ;Scancode holen
                cmpi.b  #$61,D6         ;Undo?
                beq.s   L009B           ;ja, weiter
                cmpi.b  #1,D6           ;Escape ohne Shift etc..
                beq.s   L009B           ;ja, weiter
                cmp.b   #103,D6         ;Zehnerblock '0'?
                blt.s   no_scr
                cmp.b   #112,D6         ;Zehnerblock '9'?
                ble.s   L009B
no_scr:         lea     taste_func,A0
nxt_check:      cmp.b   1(A0),D6        ;Dieser Scancode?
                beq.s   L009B           ;ja, gÅltig...
                lea     12(A0),A0       ;nÑchster Eintrag
                cmpi.w  #-1,(A0)        ;noch gÅltig?
                bne.s   nxt_check
                clr.l   taste           ;Keine Taste da, dafÅr ectl. F-Taste
                cmp.b   #84,D6          ;Shift-F1?
                bcs.s   kein_fkey
                cmp.b   #93,D6          ;Shift-F10?
                bhi.s   kein_fkey
                sub.w   #83,D6
                bra.s   set_fkey
kein_fkey:      subi.b  #59,D6          ;F1
                bcs.s   L009B
                addq.w  #1,D6
                cmpi.b  #$0B,D6         ;F10
                bcc.s   L009B           ;Grîûer -> Raus
set_fkey:       tst.b   less_memory     ;zuwenig Speicher
                beq.s   L009B           ;Dann keine Tastaturabfrage
                move.b  D6,fun_key
                cmpi.b  #2,D5           ;Copybox?
                beq.s   L009C           ;ja...
                tst.w   D5              ;Jack Knife?
                beq.s   L009C           ;ja
L009B:          moveq   #0,D6           ;keine Funktion ausfÅhren...
                rts
L009C:          moveq   #1,D6           ;Funktion gleich ausfÅhren...
                rts

;User hat neue Farbe (D5) gewÑhlt, diese muû in 512'er gefunden werden,
;und in Kastenfarbe kopiert werden
neue_chg_color: bsr     L0279           ;Alten Rahmen weglîschen (?)
                move.w  #511,D6
                lea     color512,A0
                and.w   #$0FFF,D5       ;STE maskieren
                move.w  D5,-(SP)        ;Farbe retten
                tst.w   ste_support
                beq.s   L009E
                and.w   #$0777,D5       ;bei normalem ST maskieren
L009E:          cmp.w   (A0)+,D5        ;Nach dieser Farbe suchen
                beq.s   L009F           ;gefunden
                dbra    D6,L009E
                move.w  (SP),D5         ;Farbe wieder holen
                move.w  D5,(A0)
                moveq   #32,D7          ;Neuer Colorx
                moveq   #0,D6           ;bzw. colory
                bra.s   L00A0
L009F:          move.w  #511,D7
                sub.w   D6,D7
                move.w  D7,D6
                lsr.w   #4,D7
                andi.w  #$000F,D6
L00A0:          move.w  (SP)+,D5        ;Farbe wieder holen
                move.b  D7,colorx
                move.b  D6,colory
                bsr     print_rgb
                move.b  D7,D0
                sub.b   pos_color512,D0
                bcs.s   L00A1
                cmpi.b  #$0D,D0
                bcc.s   L00A1
                ext.w   D0
                move.b  D6,D1
                ext.w   D1
                bsr     draw_hot_spot
L00A1:          rts

quit_from_board:bsr     alle_irqs_aus
                bsr     switch2tos
                jsr     Sm
                move.w  D0,-(SP)
                moveq   #$0F,D0         ;Pfeil
                bsr     set_mouse_d0
                move.w  (SP)+,D0
                bra     quit_neo

L00A2:          move.b  #1,aktion_nach_save ;Save_changed before proceeding?...
                bra.s   save_neo

L00A3:          move.b  #-1,aktion_nach_save ;save changed before quitting?

save_neo:       lea     picture_neo,A0
                lea     old_fn,A1
copy_it71:      move.b  (A0)+,(A1)+     ;Alten Filenamen retten
                bne.s   copy_it71

                lea     picture_neo,A1
                move.w  save_typ,D1     ;Neuer Typ
                jsr     change_file     ;und an Filenamen anhÑngen

                lea     save_path,A0
                lea     picture_neo,A1
                lea     save_ext,A2
                moveq   #1,D0           ;Speichern
                jsr     fileselect
                bne     back2neo        ;Abbruch angeklickt

                tst.w   board_da        ;Nur wenn Board da->Bild zurÅckschreiben
                bne.s   retry
                movea.l scr1,A0
                movea.l komplettbild,A1
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A1
                move.w  #999,D0         ;Bild zurÅckschreiben
L00AE:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L00AE

retry:          move.w  #0,-(SP)
                pea     fsel_path       ;Pfad+Filename auf Stack
                move.w  #$003C,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                bpl.s   L00B5

                move.l  #write_protect,D0 ;Disk may be writeprotected...
                jsr     alert
                cmpi.w  #1,int_out
                beq.s   retry
                bra     back2neo        ;Cancel

L00B5:          move.w  left_col_mark,D0
                lsl.w   #4,D0
                or.w    right_col_mark,D0
                bset    #15,D0
                move.w  D0,L0754
                move.w  rot_col_direct,D1 ;Wird gerade Color animiert?
                beq.s   L00B7           ;Nein, weiter
                move.w  rot_col_speed,D0
                btst    #0,D1
                beq.s   L00B6
                neg.b   D0
L00B6:          andi.w  #$00FF,D0       ;merken
                bset    #15,D0
                move.w  D0,L0755
L00B7:          lea     hbl_system+2,A0
                lea     palette,A1
                moveq   #15,D7          ;16 Farben Åbertragen
trans_color:    move.w  (A0)+,(A1)+
                dbra    D7,trans_color

                move.w  save_typ,D0
                lsl.w   #2,D0           ;mal 4
                lea     save_table(PC),A0
                movea.l 0(A0,D0.w),A0
                jmp     (A0)            ;entsprechende Speicherroutine

save_table:             DC.L save_neo_img,save_degas,save_pkd_degas
                        DC.L save_iff,save_doodle

;Achtung! Aus KompatibilitÑtgrÅnden mit anderen Zeichenprogrammen muû die Reihenfolge der Chunks
;BMHD -> CMAP -> BODY sein.

iff_header:             DC.B 'FORM'
iff_len:                DC.L 0
                        DC.B 'ILBM'

                        DC.L 'BMHD'
                        DC.L 20 ;20 Bytes folgen
                        DC.W 320,200
                        DC.W 0,0
                        DC.B 4,0
compress:               DC.B 0
                        DC.B 0
                        DC.W 0
                        DC.B 0,0
                        DC.W 320,200

iff_pal:                DC.B 'CMAP'
                        DC.L 16*3
iff_palette:            DS.B 16*3

iff_header_end:

body_chunk:             DC.B 'BODY'
body_len:               DC.L 0

raster_header:          DC.B 'RAST'
                        DC.L 2*anz_raster*(16+1)

save_iff:       move.l  #pkd_unpkd,D0   ;gepackt oder ungepackt?
                jsr     alert

                bsr     palette2iff     ;Palette ins IFF-Format wandeln

                movea.l komplettbild,A0
                movea.l scr2,A1

                cmpi.w  #1,int_out
                beq.s   pack_iff
                cmpi.w  #3,int_out      ;Palette?
                beq     palette_iff

                clr.b   compress        ;nicht gepackt
                move.w  #199,D7         ;200 Scanlines
scan_loop3:     moveq   #3,D6           ;4 Planes
plane_loop3:    moveq   #19,D5          ;20 BB's
kopy1:          move.w  (A0),(A1)+
                addq.l  #8,A0
                dbra    D5,kopy1
                lea     -158(A0),A0
                dbra    D6,plane_loop3  ;umsortieren
                lea     152(A0),A0
                dbra    D7,scan_loop3
                move.l  #32000,D7       ;LÑnge
                bra.s   save_iff_img

pack_iff:       move.b  #1,compress     ;Bild ist gepackt!
                bsr     pack_pic

save_iff_img:   move.l  D7,body_len
                addq.l  #8,D7           ;+8 Byte Bodyheader
                move.l  D7,iff_len      ;LÑnge des Bodychunks
                move.l  #iff_header_end-iff_header-8,D6 ;LÑnge des Headers
                add.l   D6,iff_len
                bsr     count_rasters   ;Wieviele Raster sind es?
                cmp.w   #1,D0
                ble.s   kein_raster_chunk
                mulu    #34,D0
                addq.l  #8,D0           ;+Header Rasterchunk
                add.l   D0,iff_len      ;und auch noch den Rasterheader
kein_raster_chunk:

                lea     iff_header(PC),A6
                move.l  #iff_header_end-iff_header,D6
                jsr     write           ;IFF-Header schreiben
                bne     save_error

                lea     body_chunk(PC),A6
                moveq   #8,D6
                jsr     write           ;Body-Chunk Header speichern
                bne     save_error

                movea.l scr2,A6
                move.l  body_len,D6
                jsr     write           ;und Body schreiben
                bne     save_error

save_ggf_raster:bsr     count_rasters   ;ZÑhlt wieviel Raster da sind.

                cmp.w   #1,D0           ;Mehr als 1 Raster (VBL)?
                ble     save_end

                lea     raster_header(PC),A6
                mulu    #34,D0
                move.l  D0,4(A6)        ;LÑnge eintragen
                moveq   #8,D6
                jsr     write           ;und Header speichern
                bne     save_error

                bsr     save_used       ;und alle Raster abspeichern
                bne     save_error

                bra     save_end

palette_iff:    clr.l   iff_len
                bsr     count_rasters
                cmp.w   #1,D0           ;nur der VBL-Raster?
                ble.s   kein_raster_chun
                mulu    #34,D0
                addq.l  #8,D0           ;+Header Rasterchunk
                move.l  D0,iff_len

kein_raster_chun:addi.l #12+16*3,iff_len ;LÑnge Header + LÑnge Color Chunk

                moveq   #12,D6
                lea     iff_header(PC),A6
                jsr     write           ;und Header schreiben
                bne     save_error

                moveq   #8+16*3,D6
                lea     iff_pal(PC),A6
                jsr     write
                bne     save_error

                lea     old_fn,A0
                lea     picture_neo,A1
copy_it72:      move.b  (A0)+,(A1)+     ;Alten Filenamen wieder hin
                bne.s   copy_it72

                bra     save_ggf_raster ;und ggf. die Raster abspeichern


;Wandelt Palette ins IFF-Format (CHS)
palette2iff:    lea     hbl_system+2,A0
                lea     iff_palette(PC),A1
                moveq   #15,D1          ;16 Register
                tst.w   ste_support
                beq.s   pal2iffste
col_trans:      move.w  (A0)+,D0        ;Farbe holen
                and.w   #%0000011101110111,D0 ;Maskieren
                move.w  D0,D2
                lsr.w   #3,D2           ;Rot-Wert
                and.b   #%11100000,D2   ;und ausmaskieren
                move.b  D2,(A1)+        ;speichern
                move.w  D0,D2
                lsr.w   #4,D2           ;GrÅn
                lsl.w   #5,D2
                move.b  D2,(A1)+
                and.w   #%0000000000000111,D0 ;Blau
                lsl.w   #5,D0
                move.b  D0,(A1)+
                dbra    D1,col_trans
                rts

pal2iffste:     move.w  (A0)+,D0        ;Farbe STE
                bsr.s   umsort_ste      ;Stellt die Bits um
                move.w  D0,D2
                lsr.w   #4,D2
                and.w   #%0000000011110000,D2 ;und ausmaskieren des B-Werts
                move.b  D2,(A1)+
                move.w  D0,D2
                and.w   #%0000000011110000,D2 ;Nur G-Wert
                move.b  D2,(A1)+
                lsl.w   #4,D0
                move.b  D0,(A1)+
                dbra    D1,pal2iffste
                rts

;Sortiert die verdrehten STE-Bits wieder richtig, d.h. rol.n d0 (Nibble)
; A0.L: Adresse der STE-Palette
umsort_ste_pal: movem.l D0-A6,-(SP)

                moveq   #15,D7
umsort_loop:    move.w  (A0),D0
                bsr.s   umsort_ste
                move.w  D0,(A0)+
                dbra    D7,umsort_loop

                movem.l (SP)+,D0-A6
                rts

;Sortiert die verdrehten STE-Bits wieder richtig, d.h. rol.n d0 (Nibble)
; D0.W: STE-Farbwert
umsort_ste:     movem.l D1-D4,-(SP)
                move.w  D0,D1
                moveq   #0,D1           ;hier aufbauen
                moveq   #2,D3           ;3 Farbwerte
                moveq   #8,D4           ;Schiebewert
rgb_loop:       move.w  D0,D2
                lsr.w   D4,D2           ;Wert isolieren
                and.w   #%0000000000001111,D2 ;isolieren
                add.w   D2,D2           ;nach oben schieben
                bclr    #4,D2           ;Oberes Bit lîschen
                beq.s   nicht_setzen    ;war gesetzt->unten setzen
                bset    #0,D2
nicht_setzen:   lsl.w   D4,D2           ;An Rot-Wert setzen
                or.w    D2,D1           ;und einmasken
                subq.w  #4,D4           ;Schiebewert verringern
                dbra    D3,rgb_loop
                move.w  D1,D0
                movem.l (SP)+,D1-D4
                rts

;Sortiert die richtigen Bits in die verdrehte STE-Darstellung.
;d.h. ror.n d0 (Nibble)
; A0.L: STE-Farbpalette
resort_ste_pal: movem.l D0-A6,-(SP)

                moveq   #15,D7
resort_loop:    move.w  (A0),D0
                bsr.s   resort_ste
                move.w  D0,(A0)+
                dbra    D7,resort_loop

                movem.l (SP)+,D0-A6
                rts

;Sortiert die richtigen Bits in die verdrehte STE-Darstellung.
;d.h. ror.n d0 (Nibble)
; D0.W: STE-Farbwert
resort_ste:     movem.l D1-D4,-(SP)
                move.w  D0,D1
                moveq   #0,D1           ;hier aufbauen
                moveq   #2,D3           ;3 Farbwerte
                moveq   #8,D4           ;Schiebewert
rgb_loop2:      move.w  D0,D2
                lsr.w   D4,D2           ;Wert isolieren
                and.w   #%0000000000001111,D2 ;isolieren
                lsr.w   #1,D2           ;nach unten schieben
                bcc.s   nicht_setzen2   ;war gesetzt->unten setzen
                bset    #3,D2
nicht_setzen2:  lsl.w   D4,D2           ;An Rot-Wert setzen
                or.w    D2,D1           ;und einmasken
                subq.w  #4,D4           ;Schiebewert verringern
                dbra    D3,rgb_loop2
                move.w  D1,D0
                movem.l (SP)+,D1-D4
                rts

;Entpackt ein Bild im IFF- bzw. Degas Format: (CHS)
;Parameter:
;A0: gepackte Daten
;A1: Zieladresse
entpack_pic:    move.w  #199,D7         ;200 Scanlines zu sortieren
scan_loop:      moveq   #3,D6           ;mit 4 Planes
plane_loop:     moveq   #40,D5          ;40 Bytes pro Scanline und Plane
                lea     umsort_buff,A2
load_pkd_loop:  move.b  (A0)+,D0        ;gepackt/ungepackt?
                blt.s   gepackt
                addq.b  #1,D0
                ext.w   D0
                sub.w   D0,D5           ;soviel sind weniger
                bra.s   hinter3
trans_loop9:    move.b  (A0)+,(A2)+     ;ungepackte Bytes Åbertragen
hinter3:        dbra    D0,trans_loop9
                bra.s   packed_loop
gepackt:        cmp.b   #$80,D0         ;(?)
                beq.s   packed_loop
                ext.w   D0
                neg.w   D0
                addq.w  #1,D0
                sub.w   D0,D5
                move.b  (A0)+,D1        ;Wert
                bra.s   hinter4
trans_loop10:   move.b  D1,(A2)+        ;Wert schreiben
hinter4:        dbra    D0,trans_loop10
packed_loop:    tst.w   D5              ;Alle Bytes da?
                bne.s   load_pkd_loop

                lea     umsort_buff,A2
                moveq   #19,D5          ;20 Worte kopieren
trans_loop11:   move.w  (A2)+,(A1)
                addq.l  #8,A1           ;Ein BB weiter
                dbra    D5,trans_loop11
                lea     -158(A1),A1     ;zurÅck zum Start+2
                dbra    D6,plane_loop
                lea     152(A1),A1      ;zur nÑchsten Scanline
                dbra    D7,scan_loop    ;und alle Scanlines
                rts

;Packt Bild im IFF bzw. Degas-Format (CHS)
;Packt von Komplettbild nach scr2
pack_pic:       movea.l komplettbild,A0
                movea.l scr2,A1

                move.w  #199,D7         ;200 Scanlines
scan_loop2:     moveq   #3,D6           ;4 Planes
plane_loop2:    lea     umsort_buff,A2
                moveq   #19,D5          ;20 BBs holen
trans_78:       move.w  (A0),(A2)+
                addq.l  #8,A0
                dbra    D5,trans_78
                lea     -158(A0),A0     ;zurÅck
                move.b  -1(A2),D0       ;letztes Byte holen
                addq.b  #1,D0           ;verÑndern
                move.b  D0,(A2)+        ;und anhÑngen
                move.b  D0,(A2)         ;und doppelt

                lea     umsort_buff,A2
                lea     umsort_buff+40,A5 ;Ende des Buffers
pack_loop:      movea.l A2,A3
no_pack:        move.b  (A3)+,D1
                cmpa.l  A3,A5           ;Bufferende erreicht?
                beq.s   ungepackt
                cmp.b   (A3),D1         ;2 gleiche Bytes?
                bne.s   no_pack         ;nein, weiter suchen

                subq.l  #1,A3           ;eins wieder abziehen
                cmpa.l  A3,A2           ;vor gleichen Bytes noch was?
                beq.s   noch_gleich     ;Nein, gleich packen

                move.l  A3,-(SP)
                suba.l  A2,A3           ;anzahl berechnen
                move.w  A3,D0
                subq.w  #1,D0           ;eins abziehen
                move.b  D0,(A1)+        ;Kommandowort
                addq.w  #1,D0           ;Anzahl+1
                bra.s   hinter6
trans_12:       move.b  (A2)+,(A1)+     ;ungepackte Bytes Åbertragen
hinter6:        dbra    D0,trans_12
                movea.l (SP)+,A3

noch_gleich:    cmp.b   (A3)+,D1        ;immer noch gleich?
                beq.s   noch_gleich
                subq.l  #1,A3           ;letztes wieder weg
                movea.l A3,A4           ;neue Position merken
                suba.l  A2,A3           ;Anzahl berechnen
                subq.l  #1,A3           ;-1
                move.w  A3,D0
                neg.w   D0
                move.b  D0,(A1)+        ;Kommandobyte
                move.b  D1,(A1)+        ;und Wert
                movea.l A4,A2           ;und neue Position merken
                bra.s   end_packen
ungepackt:      suba.l  A2,A3           ;Anzahl berechnen
                subq.l  #1,A3           ;-1
                move.w  A3,D0           ;merken
                move.b  D0,(A1)+        ;Kommandowort
                ext.w   D0              ;erweitern
                addq.w  #1,D0           ;+1
                bra.s   hinter5
loop90:         move.b  (A2)+,(A1)+     ;ungepackte Werte
hinter5:        dbra    D0,loop90
end_packen:     cmpa.l  A5,A2           ;alle 40 Bytes geschafft?
                bne.s   pack_loop

                dbra    D6,plane_loop2
                lea     152(A0),A0      ;nÑchste Scanline
                dbra    D7,scan_loop2

                move.l  A1,D6
                sub.l   scr2,D6         ;Anzahl berechnen
                move.l  D6,D7           ;und zurÅckgeben
                rts

degas_header:           DC.W $8000 ;Header eines gepackten Degas-Bildes

save_pkd_degas: lea     degas_header(PC),A6
                moveq   #2,D6
                jsr     write
                bne.s   save_error
                lea     hbl_system+2,A6
                moveq   #32,D6
                jsr     write           ;VBL-Palette abspeichern
                bne.s   save_error
                bsr     pack_pic        ;Bild packen

                move.l  D7,D6           ;LÑnge der Daten
                movea.l scr2,A6         ;Adresse
                jsr     write           ;und schreiben
                bne.s   save_error
                bra.s   save_end

save_degas:     lea     zeros,A6
                moveq   #2,D6           ;2 Nuller am Start
                jsr     write
                bne.s   save_error
                lea     hbl_system+2,A6 ;VBL-Palette abspeichern
                moveq   #32,D6          ;Dann Farbpalette
                jsr     write
                bne.s   save_error
                bra.s   save_doodle

save_neo_img:   lea     lade_adresse,A6
                move.l  #'NEO!',124(A6) ;NEO-Kennung eintragen
                move.l  #128,D6
                jsr     write
save_doodle:    movea.l komplettbild,A6
                move.l  #32000,D6
                jsr     write
                beq.s   save_end

save_error:     move.l  #disk_full,D0   ;Disk full...
                bsr     alert
                pea     fsel_path
                move.w  #$0041,-(SP)
                trap    #1              ;Datei wieder lîschen
                addq.l  #6,SP
                bra     back2neo

save_end:       jsr     fclose
                tst.w   D0
                bne.s   save_error
                move.b  #-1,changed     ;nichts ist geÑndert
                tst.b   aktion_nach_save
                beq     back2neo        ;zurÅck in Neochrom...
                bpl     L01C5           ;zurÅck zur Laderoutine

ende:           move.w  akt_work,D0
                lea     changes,A0      ;Alten Change-Wert merken
                move.b  changed,0(A0,D0.w)

                moveq   #0,D0           ;Screencounter
check_loop:     cmp.w   akt_work,D0     ;Aktiver Screen?
                beq.s   no_check1
                tst.b   (A0)            ;Screen verÑndert?
                beq     there_r_changes
no_check1:      addq.w  #1,D0           ;nÑchster Screen testen
                addq.l  #1,A0           ;nÑchsten Screen
                cmp.w   anz_screens,D0  ;schon alle Screens?
                blt.s   check_loop

really_raus:    bsr.s   abmelden

                clr.w   -(SP)
                move.w  #$004C,-(SP)    ;und schultz...
                trap    #1
                rts

abmelden:       jsr     Hm              ;zurÅck ins TOS

                st      music           ;Musik aus
                jsr     turn_music_on   ;und abschalten

                lea     control,A0
                move.l  old_ms_move(PC),14(A0)
                move.l  #vex_motv,D0
                jsr     _vdi

                move.l  old_button_irq(PC),14(A0)
                move.l  #vex_butv,D0
                jsr     _vdi

                move.b  old_porta,porta
                jsr     set_porta       ;und zurÅckschalten

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor an
                addq.l  #6,SP
                move.l  D0,old_ssp

                moveq   #$14,D0         ;Joystick an
                jsr     send_ikbd
                moveq   #$08,D0
                jsr     send_ikbd       ;rel. Maus an

                        IF disk_version<>0
                clr.l   $0000040C.w     ;Kein spezial Ende bitte
                        ENDC

                linea   #0 [ Init ]
                move.w  mid_width,-$02B4(A0)
                move.w  mid_height,-$02B2(A0) ;ZurÅck in alte Resolution...
                move.w  mid_#_colors,-$029A(A0)
                move.l  old_critic,$00000404.w
                move.l  old_timer,$00000400.w ;ganze Vektoren restaurieren
                move.l  old_118,$00000118.w
                move.l  old_timer_c,$00000114.w
                move.l  old_vbl,$00000070.w
                bsr     vsync
                move.b  old_sync,neue_sync ;Alte Sync wieder setzen
                bsr     sync_mcode      ;und setzen
                bsr     vsync
                andi.b  #%11111110,$FFFFFA07.w ;Timer B aus
                andi.b  #%11111110,$FFFFFA13.w ;Timer B maskieren
                move.l  old_timer_b,$0020(A0)

                move.b  old_conterm,$00000484.w ;ALte Attribute setzen

                tst.l   old_tastatur    ;Neuer Tastaturreiber?
                beq.s   kein_neuer      ;nein

                move.w  #34,-(SP)
                trap    #14             ;Kbdvbase
                addq.l  #2,SP

                move    SR,-(SP)
wait_leer2:     move    #$2300,SR
wait_leer1:     cmpi.l  #tastatur_buffer,tastatur_write.w ;Buffer leer?
                bne.s   wait_leer1
                move    #$2700,SR
                cmpi.l  #tastatur_buffer,tastatur_write.w
                bne.s   wait_leer2

                movea.l D0,A0
                move.l  old_tastatur,32(A0) ;Alte Tastaturroutine einhÑngen
                move    (SP)+,SR

kein_neuer:     move.l  old_ssp,-(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor aus
                addq.l  #6,SP

                tst.w   overscan        ;Autoswitch-Overscan vorhanden?
                bne.s   no_over2

                move.w  overmode,-(SP)
                move.w  #4206,-(SP)     ;Overscan modus setzen
                trap    #14
                addq.l  #4,SP

no_over2:       move.w  old_rez,-(SP)
                move.l  copybox_screen,-(SP)
                move.l  copybox_screen,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     12(SP),SP

                tst.l   start_screens   ;Speicher angefordert?
                beq.s   no_free_mem     ;Nein->Weiter

                move.l  start_screens,-(SP)
                move.w  #$0049,-(SP)
                trap    #1              ;Speicher fÅr zusÑtzliche Screens freigeben
                addq.l  #6,SP

no_free_mem:    pea     tos_pal
                move.w  #6,-(SP)        ;Originalpalette setzen
                trap    #$0E
                addq.l  #6,SP

                move.l  #v_clsvwk,D0
                jsr     _vdi            ;Workstation schliessen

_do_pterm:      move.l  #appl_exit,D0
                jmp     _aes            ;Applikation wieder abmelden


                        IF disk_version<>0
ende_error:     movem.l D0-A6,-(SP)

                move.l  SP,stack_p
                move    SR,D0
                move.w  D0,status_r

                move    #$0300,SR       ;und Usermode bitte
                lea     stackp,SP       ;NEochrome Stackpointer setzen

                bsr     abmelden

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor an
                addq.l  #6,SP

                move.l  status_r(PC),D0 ;Statusregister wieder holen
                move    D0,SR
                movea.l stack_p(PC),SP  ;und Stackpointer setzen

                illegal

stack_p:                DS.L 1
status_r:               DS.W 1

                        ENDC


;Es gab verÑnderte Screens, aber nicht den aktiven....
there_r_changes:jsr     Hm
                bsr     switch2tos
                jsr     Sm
                move.l  #really_quit,D0 ;Save changes before quitting?
                bsr     alert
                move.w  int_out,D1
                cmp.w   #1,D1           ;Cancel?
                beq.s   back2neo        ;ja, zurÅck
                bra     really_raus     ;und dann schluû

quit_neo:       tst.b   changed         ;wurde noch was geÑndert?
                bne.s   no_chg_this     ;nein
                jsr     Hm
                bsr     switch2tos
                jsr     Sm
                move.l  #L00CF,D0       ;Save changes before quitting?
                bsr     alert
                move.w  int_out,D1
                cmp.w   #3,D1           ;Cancel?
                beq.s   back2neo        ;ja, zurÅck
                cmpi.w  #1,D1
                beq     L00A3           ;Erst noch saven, dann nach L00AB
                bra     ende            ;und dann schluû

no_chg_this:    move.w  akt_work,D0
                lea     changes,A0      ;Alten Change-Status merken
                move.b  changed,0(A0,D0.w)
                bra     ende            ;und noch ÅberprÅfen

back2neo:       bsr.s   screen2neo
                bra     mainloop

screen2neo:     movem.l D0-A6,-(SP)

                jsr     Hm
                bsr     switch2neo
                jsr     Sm
                bsr     get_maus
                cmp.w   board_y,D1
                bcc.s   L00AC
                bsr     set_mouse       ;User ist jetzt im Zeichenfeld
L00AC:          move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                bsr     show_fn
                lea     fun_init(PC),A0 ;verschiedene Routinen fÅr Zeichenfeld
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0
                clr.b   L076B
                jsr     (A0)            ;Zeichenfunktion reaktivieren...
                movem.l (SP)+,D0-A6
                rts

vsync:          movem.l D0-D2/A0-A2,-(SP)
                move.w  #37,-(SP)       ;Vsync
                trap    #14
                addq.l  #2,SP
                movem.l (SP)+,D0-D2/A0-A2
                rts

scroller_aus:   tst.b   scroll_aktiv    ;Ist Scroller noch an?
                bne.s   scroller_aus_end ;Nein, nichts machen

                movem.l D7-A1,-(SP)
                move.b  #-1,scroll_aktiv ;Scroller ist jetzt aus!

                movea.l scr1,A1
                lea     192*160(A1),A1
                lea     scroll_save,A0
                move.w  #(160*8/4)/2-1,D7
restore:        move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,restore
                movem.l (SP)+,D7-A1
scroller_aus_end:rts

do_scroller:    movem.l D0-A6,-(SP)
                movea.l scrollpos,A0
                subq.w  #1,scrollshift
                bne.s   noch_nicht
                move.w  #8,scrollshift
                addq.l  #1,A0           ;nÑchstes Zeichen aus Scrolltext
                tst.b   (A0)            ;Ende der Scrollline?
                bne.s   noch_nicht      ;nein
                lea     scrolltext(PC),A0 ;sonst wieder von vorne anfangen!
noch_nicht:     move.l  A0,scrollpos    ;und hier geht's weiter

                lea     scrollfont,A2   ;Pointer auf den Font
                moveq   #0,D0
                move.b  (A0),D0         ;Zeichen holen
                        IF disk_version=0
                eori.b  #$DF,D0         ;entschlÅsseln
                        ENDC
                sub.w   #' ',D0         ;Zeichensatz fÑngt bei ' ' an
                divu    #32,D0
                move.w  D0,D1
                mulu    #32*9,D1
                adda.w  D1,A2
                swap    D0
                adda.w  D0,A2           ;Zeichen, welches nachgeschoben wird
                lea     scrollspace,A3  ;Platz fÅr den Scroller

                moveq   #7,D7           ;Hîhe des Fonts in Scanlines
scroll_scanline:moveq   #0,D0
                move.b  (A2),D0         ;Zeichenmatrix oberste Scanline holen
                move.w  scrollshift,D1
                lsr.w   D1,D0           ;schieben
                and.w   #1,D0           ;und nur ein Bit lassen

                moveq   #20,D6          ;scrollen Åber 21 BBs
shift_left:     moveq   #0,D1
                move.w  (A3),D1         ;alten Scroller holen
                add.l   D1,D1           ;um eins nach links
                or.w    D0,D1           ;Neue Information einodern
                move.w  D1,(A3)+        ;und im Space merken
                swap    D1
                move.w  D1,D0           ; neuer Rest
                dbra    D6,shift_left
                lea     32(A2),A2       ; Font nÑchste Scanline
                dbra    D7,scroll_scanline


                lea     scrollspace,A1
                lea     scrollwabbel,A2
                moveq   #7,D0           ; 8 Scanlines hoch
dowabbel1:      moveq   #20,D1          ; 21 Bitblocks wabbeln
                move.b  (A0)+,D2        ; Scrollwert
                moveq   #0,D2           ;Kein Wabbeln mehr
                moveq   #0,D4
dowabbel2:      moveq   #0,D3
                move.w  (A1)+,D3        ; Grafik holen
                rol.l   D2,D3
                or.w    D4,D3
                move.w  D3,(A2)+        ; und abspeichern
                swap    D3
                move.w  D3,D4
                dbra    D1,dowabbel2
                dbra    D0,dowabbel1

                moveq   #7,D7           ; Scanlines
                lea     scrollwabbel+2,A3 ; Scrollbuffer
                movea.l scr1,A4         ;Bildschirm
                lea     193*160(A4),A4  ;Zeile, in der Scroller erscheint
                moveq   #2,D5           ;Anzahl der Scanlines mit Clipping (Lupe)
wuchtloop0:     moveq   #19,D6          ; nur! 20 Bitblocks
wuchtloop:      move.w  (A3)+,D1
                tst.w   D5              ;noch Clippen?
                bmi.s   no_clip
                cmp.w   #11,D6          ;Lupe?
                bgt.s   no_clip         ;nein, rein damit
                cmp.w   #7,D6
                blt.s   no_clip         ;Kleiner -> nicht clippen
                bne.s   no_spezial      ;Gleich -> nein, normal clippen
                and.w   #%1111111111111100,D1
                moveq   #3,D4
lp:             move.w  -(A4),D3
                and.w   #%0000000000000011,D3 ;lîschen
                or.w    D1,D3
                move.w  D3,(A4)
                dbra    D4,lp
                bra.s   no_clip2
no_spezial:     subq.l  #8,A4           ;Nichts verÑndern, wegen Lupe
                bra.s   no_clip2
no_clip:        move.w  D1,-(A4)        ;und auf Screen
                move.w  D1,-(A4)
                move.w  D1,-(A4)        ;Alle 4 Planes=Farbe 15
                move.w  D1,-(A4)
no_clip2:       dbra    D6,wuchtloop
                subq.w  #1,D5           ;Eine Zeile weniger clippen
                addq.l  #2,A3           ; 1 Wort Åberspringen
                lea     160+20*8(A4),A4 ;eine Zeile tiefer
                dbra    D7,wuchtloop0

scroll_end:     movem.l (SP)+,D0-A6
                rts

switch_copyr:   tst.b   copyr_work      ;noch in Copyright-Demo?
                bmi.s   L00BD           ;nein -> Raus
                movem.l D0-D2/A0,-(SP)
                move.b  copyr_work,D2
                ext.w   D2
                move.w  L00BE(PC,D2.w),D0
                cmp.w   vblcounter,D0
                bcc.s   L00BC
                subq.b  #2,copyr_work   ;Nachher nÑchstes bitte
                jsr     Hm
                clr.w   logo_typ        ;im Moment kein Logo...
                add.w   D2,D2           ;mal 2
                tst.b   lupe_an         ;Ist groûe Lupe zu sehen?
                beq.s   kein_copyright  ;ja->Kein Copyright ausgeben
                jsr     L00BF(PC,D2.w)  ;nÑchstes Copyright ausgeben
kein_copyright: jsr     Sm
L00BC:          movem.l (SP)+,D0-D2/A0
L00BD:          rts

;VBL-Counter Stand zum Umschalten der Copyrights...
L00BE:                  DC.W 1500,1080,720,360,0

;Sprungtabelle zum Anzeigen der Copyrights:
L00BF:          bra     show_filename
                bra     L00C0
                bra     print_atari
                bra     show_df
                bra     start_copyr

show_df:        btst    #0,mouse_pos    ;Im Moment im Zeichenfeld?
                bne     raus2           ;ja, kein Logo
                move.w  #1,logo_typ     ;Jetzt ist DF-Logo da
                lea     df_logo,A0      ;Neochrom Logo zeichnen
                movea.l scr1,A1
                lea     $52E0(A1),A1
                moveq   #59,D0          ;Hîhe
L03104:         moveq   #15,D1          ;Breite
L03114:         move.l  (A0)+,(A1)+
                dbra    D1,L03114
                lea     96(A1),A1
                dbra    D0,L03104
                rts

start_copyr:    move.w  #1,logo_typ     ;Jetzt ist BIG-Logo da...
                rts

print_atari:    lea     copyr_atari,A0
                moveq   #0,D0
                move.w  #$00B6,D1
                jsr     print8x8
                move.b  function,D0     ;wirkliche Funktion retten
                move.b  #15,function    ;Funktion 15=Staugas
                move.w  D0,-(SP)
                jsr     draw_options    ;anzeigen
                move.w  (SP)+,D0
                move.b  D0,function     ;Alte Funktion wiederherstellen
                btst    #0,mouse_pos    ;Im Moment im Zeichenfeld?
                bne.s   raus2           ;ja, kein Logo
                move.w  #2,logo_typ     ;Jetzt ist kleines Logo da
                lea     neo_logo,A0     ;Neochrom Logo zeichnen
                movea.l scr1,A1
                lea     $52E0(A1),A1
                moveq   #28,D0          ;Hîhe
L03103:         moveq   #15,D1          ;Breite
L03113:         move.l  (A0)+,(A1)+
                dbra    D1,L03113
                lea     96(A1),A1
                dbra    D0,L03103
raus2:          rts

L00C0:          lea     neochrome,A0    ;NEOchrome v2.0
                moveq   #0,D0
                move.w  #$00B6,D1
                jsr     print8x8        ;ausgeben
                jsr     clear_options
                lea     L049A,A4        ;Smoke and Mirrors by...
                jmp     write_options   ;ausgeben

show_filename:  bsr.s   show_fn
draw_big_logo:  jsr     clear_options
                btst    #0,mouse_pos    ;Im Moment im Zeichenfeld?
                bne.s   raus3           ;Ja, kein Logo
                move.w  #1,logo_typ     ;Jetzt ist groûes Logo da
                lea     neo_logo,A0     ;groûes Neochrom Logo zeichnen
                movea.l scr1,A1
                lea     $52E0(A1),A1
                moveq   #59,D0          ;Hîhe
L03102:         moveq   #15,D1          ;Breite
L03112:         move.l  (A0)+,(A1)+
                dbra    D1,L03112
                lea     96(A1),A1
                dbra    D0,L03102
raus3:          rts

;Zeigt den Filenamen im Board und Border an:
show_fn:        tst.w   board_da        ;öberhaupt ein Board da?
                bne     show_fn_border  ;nein, nichts ins Board printen

                movem.l D0-A6,-(SP)
                movea.l scr1,A0
                lea     182*160(A0),A0  ;Platz fÅr PICTURE.NEO
                move.w  #7,D0
                moveq   #0,D1
L00C3:          moveq   #13,D2
L00C4:          move.l  D1,(A0)+
                dbra    D2,L00C4        ;lîschen
                move.l  #$00FF00FF,D2
                and.l   D2,(A0)+
                and.l   D2,(A0)+
                lea     96(A0),A0
                dbra    D0,L00C3

                move.l  #picture_neo,D1 ;PICTURE.NEO
                movea.l D1,A0
                moveq   #64+8,D0        ;zentriert
L00C5:          subq.w  #4,D0
                tst.b   (A0)+           ;Ende suchen
                bne.s   L00C5
                movea.l D1,A0
                move.w  #182,D1         ;Y-Wert
                jsr     print8x8

                tst.b   copyr_work      ;Copyrights noch aktiv?
                bpl.s   ja_weiter       ;ja, kein Rahmen um Zahl

                move.w  #0,D0
                move.w  #180,D1
                moveq   #11,D2
                move.w  #190,D3
                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                bsr     rahmen

ja_weiter:      lea     akt_str,A0
                move.w  akt_work,D0     ;Aktueller Screen
                add.b   #'0',D0         ;+'0'
                move.b  D0,(A0)
                moveq   #2,D0           ;X
                move.w  #182,D1         ;Y
                jsr     print8x8        ;und ausgeben

                movem.l (SP)+,D0-A6

;Zeigt den Filenamen im Rand an:
show_fn_border: movem.l D0-A6,-(SP)

                bsr     into_border     ;Ausgabe in Rahmen umleiten

                movea.l scr1,A1
                adda.l  #32008+12*160,A1
                tst.b   pal_flag        ;Palette im Fullscreen?
                bne.s   zeichne5
                lea     3*160(A1),A1    ;3 Zeilen tiefer
zeichne5:       move.w  #7,D0
                moveq   #0,D1
L00C32:         moveq   #11,D2
L00C42:         move.l  D1,(A1)+
                dbra    D2,L00C42       ;lîschen
                move.l  #$00FF00FF,D2
                and.l   D2,(A1)+
                and.l   D2,(A1)+
                lea     104(A1),A1
                dbra    D0,L00C32

                move.l  #picture_neo,D1 ;PICTURE.NEO
                movea.l D1,A0
                moveq   #64+8,D0        ;zentriert
L00C52:         subq.w  #4,D0
                tst.b   (A0)+           ;Ende suchen
                bne.s   L00C52
                movea.l D1,A0
                moveq   #12,D1          ;Y-Wert = unterer Rand
                tst.b   pal_flag        ;Palette im Fullscreen?
                bne.s   zeichne6
                addq.w  #3,D1           ;3 Zeilen tiefer
zeichne6:       jsr     print8x8

                move.w  #3,D0
                moveq   #10,D1
                moveq   #14,D2
                moveq   #20,D3
                moveq   #15,D4          ;Rahmen im Border
                moveq   #0,D5           ;um aktuelle Screennummer
                moveq   #-1,D6
                tst.b   pal_flag
                bne.s   zeichne7
                addq.w  #3,D1
                addq.w  #3,D3
zeichne7:       bsr     rahmen

                lea     akt_str,A0
                move.w  akt_work,D0     ;Aktueller Screen
                add.b   #'0',D0         ;+'0'
                move.b  D0,(A0)
                moveq   #5,D0           ;X
                moveq   #12,D1          ;Y
                tst.b   pal_flag
                bne.s   zeichne8
                addq.w  #3,D1
zeichne8:       jsr     print8x8        ;und ausgeben

                bsr     into_screen     ;Ausgabe wieder auf normalen Screen

                movem.l (SP)+,D0-A6
                bra     copy_lupen      ;und auf 2. Screen schreiben

evt_critic:     rts

filenotfound:           DC.B '[3][ |Di'
                        DC.B 'sk file '
                        DC.B 'not foun'
                        DC.B 'd.][OK]',$00
L00CB:                  DC.B '[3][ |Pi'
                        DC.B 'cture fi'
                        DC.B 'le read '
                        DC.B 'is not|c'
                        DC.B 'orrect f'
                        DC.B 'ormat..]'
                        DC.B '[OK]',$00

cant_show_obj:          DC.B "[3][ |Can't show this object,|because you haven't enough"
                        DC.B '|screens.][Shit]',0
cant_recut_obj:         DC.B "[3][ |Can't recut object #xxx,|"
                        DC.B "because you haven't enough|screens.][Skip|Cancel]"

pkd_unpkd:              DC.B '[2][ |Save picture...               ][packed|unpacked|palette]',0

header_yes_no:          DC.B '[2][ |Save CUTTER Object File|with headers?][Yes|No]',0

sure_new:               DC.B '[2][ |Clear all objects?][No|Yes]',0
sure_new2:              DC.B '[2][ |Clear all rasters?][No|Yes]',0

sure:                   DC.B '[2][ |Format Drive A:?|'
                        DC.B "Choose type of floppy    |you're using:]"
                        DC.B '[cancel|single|double]',0

sure_del:               DC.B '[3][ |Sure that you want|to delete this file?][Cancel|Okay]',0

load_used:              DC.B '[2][ |Load all used pictures?][Yes|No]',0

error_screen:           DC.B "[3][ |Can't load:|    "
error_screen_fn:        DC.B "12345678.12345|because you haven't enough|screens.][Ok]",0

error_load:             DC.B '[3][ |Error, while reading:|    '
error_load_fn:          DC.B '12345678.12345][Ok]',0

cant_save_opt:          DC.B "[3][ |Can't save the options.|(Disk write-protected?)]"
                        DC.B '[Retry|Cancel]',0

attention_raster:       DC.B "[1][Wrong TOS or unusual mouse-|driver. Don't use more"
                        DC.B " than|15 rasters following each|other!|Otherwise the"
                        DC.B " system crashs!][ Ok ]",0

switch2ste:             DC.B "[2][Switching to ST converts all|colors to normal ST colors.|"
                        DC.B "The STE colors will be lost.| |Really switch to ST?][Yes|No]",0

virus:                  DC.B '[3][NEOchrome Master may be|infected by an ugly linkvirus.|'
                        DC.B "(PRGsize to large.)][Fuck the damn'shit]",0

del_raster:             DC.B '[2][This object was stored|with rasters.|'
                        DC.B "Do you want to delete them?][No|Yes]",0

wake_up:                DC.B '[3][Turn your printer on, or switch|to online.]'
                        DC.B '[Okay|Cancel]',0

save_error_msg:         DC.B '[3][Error occured during disk-|operation!][ Shit ]',0

user_zu_groû_alert:     DC.B '[3][Usermodule is too large!][ Shit ]',0
user_not_found_alert:   DC.B '[1][Usermodule not found.][ Okay ]',0

disk_full:              DC.B '[3][ |Dis'
                        DC.B 'k full e'
                        DC.B 'rror.|Us'
                        DC.B 'e a disk'
                        DC.B ' with mo'
                        DC.B 're space'
                        DC.B '.][OK]',$00
write_protect:          DC.B '[1][ |Dis'
                        DC.B 'k may be'
                        DC.B '|write-p'
                        DC.B 'rotected'
                        DC.B '.][Retry'
                        DC.B '|Cancel]'
                        DC.B $00
L00CE:                  DC.B '[3][Appli'
                        DC.B 'cation d'
                        DC.B 'oes not|'
                        DC.B 'support '
                        DC.B 'Monochro'
                        DC.B 'me monit'
                        DC.B 'or...|Us'
                        DC.B 'e color '
                        DC.B 'monitor]'
                        DC.B '[Exit]',$00

really_quit:            DC.B '[2][There are some more|screens, which are|not yet saved.| |Really quit now?]'
                        DC.B '[NO|Yes]',0

L00CF:                  DC.B '[2][ |Sav'
                        DC.B 'e change'
                        DC.B 's|before'
                        DC.B ' Quittin'
                        DC.B 'g?         ][Yes|'
                        DC.B 'No|Cancel]',$00
L00D0:                  DC.B '[2][ |Ov'
                        DC.B 'erwrite '
                        DC.B 'existing'
                        DC.B '|   ',$27
L00D1:                  DC.B 'xxxxxxxx.'
                        DC.B 'NEO',$27,' ?]['
                        DC.B 'Yes|No]',$00
L00D2:                  DC.B '[3][ |No'
                        DC.B 't enough'
                        DC.B ' RAM for'
                        DC.B '|Jack Kn'
                        DC.B 'ife or C'
                        DC.B 'opybox..'
                        DC.B '.|Get TO'
                        DC.B 'S in ROM'
                        DC.B ' at your'
                        DC.B ' dealer!'
                        DC.B '][Exit]',$00

;Einsprung, wenn andere Funktion angewÑhlt wird...
;d.h. wird eine Funktion neu angewÑhlt, wird Åber ihren Vektor gesprungen
fun_init:               DC.L jack_init ;Jack Knife
                        DC.L grabber_init ;Grabber
                        DC.L copybox_init ;Copybox
                        DC.L text_init ;Text
                        DC.L draw_init
                        DC.L line_init
                        DC.L fill_init
                        DC.L cutter_init ;Cutter
                        DC.L return ;Achtung! Muû wegen rplc_akt auf retrn bleiben
                        DC.L brush_init
                        DC.L return ;Disk+Eraser
                        DC.L animate_init
                        DC.L box_init
                        DC.L user1_init
                        DC.L user2_init

return:         rts

;Abmelderoutinen nach dem Aktivieren einer anderen Funktion
;d.h. hierÅber wird, je nach alter aktiver Funktion gesprungen,
;um sie abzumelden.
fun_exit:               DC.L jack_exit ;Jack Knife
                        DC.L grabber_exit ;Grabber
                        DC.L copybox_exit ;Copybox
                        DC.L text_exit
                        DC.L draw_exit
                        DC.L line_exit
                        DC.L fill_exit
                        DC.L cutter_exit ;Cutter
                        DC.L return ;Achtung, muû wegen Rplc_akt auf return bleiben
                        DC.L brush_exit
                        DC.L return ;Disk+Eraser_exit
                        DC.L animate_exit
                        DC.L box_exit
                        DC.L user1_exit
                        DC.L user2_exit

;Tabelle der einzelnen Funktionen, die User im Zeichenfeld ausfÅhren kann:
;die Routinen werden nur angesprungen, wenn Mauszeiger bewegt wurde,
;Maus geklickt wurde, oder eine Aktion gerade ausgefÅhrt wird
;z.B. Verschieben
fun_do:                 DC.L do_jack ;Jack Knife
                        DC.L do_grabber ;Grabber
                        DC.L do_copybox
                        DC.L do_text
                        DC.L do_draw
                        DC.L do_line ;Line
                        DC.L do_fill ;Fill
                        DC.L do_cutter ;Cutter
                        DC.L do_raster ;&
                        DC.L do_brush_nozzle ;Brush & Nozzle
                        DC.L do_eraser ;Disc
                        DC.L do_animate ;Camera
                        DC.L do_box ;Box
                        DC.L do_user1 ;Eraser
                        DC.L do_user2 ;Nozzle

L00D6:          rts
L00D7:          rts
L00D8:          rts

;Holt sich die Koordinaten des momenatenen Clipping-Rechecks. (CHS)
;Achtung! Basiert auf einem undokumentierten Feature des VDI!
;Ausgabe:
;D0: Clipping Flag
;D1-D4: Clipping-Koordinaten
get_clip:       movem.l D5-A6,-(SP)

                move.w  #1,int_in       ;Erweiterte Paramter erfragen
                move.l  #vq_extnd,D0
                bsr     _vdi

                move.w  int_out+19*2,D0 ;Clipping Flag
                lea     ptsout,A0
                move.w  (A0)+,D1
                move.w  (A0)+,D2
                move.w  (A0)+,D3        ;Clipping-Koordinaten holen
                move.w  (A0)+,D4

                movem.l (SP)+,D5-A6
                rts

;Schaltet das Clipping aus (CHS)
clipping_aus:   move.l  D0,-(SP)
                moveq   #0,D0           ;Clipping abschalten
                bsr.s   set_clipping
                move.l  (SP)+,D0
                rts

;Schaltet das Clippping fÅr den Arbeitsbereich ein (CHS)
clipping_ein:   movem.l D0-D4,-(SP)
                moveq   #1,D0           ;Clipping einschalten
                moveq   #0,D1
                moveq   #0,D2           ;von 0/0
                move.w  #319,D3
                move.w  board_y,D4      ;bis 319/board_y
                subq.w  #1,D4
                bsr.s   set_clipping
                movem.l (SP)+,D0-D4
                rts

;Setzt das Clipping (CHS)
;Parameter:
;D0: Clipping Flag
;D1-D4: Clipping-Koordinaten
set_clipping:   movem.l D5-A6,-(SP)

                move.w  D0,int_in
                lea     ptsin,A0
                move.w  D1,(A0)+
                move.w  D2,(A0)+
                move.w  D3,(A0)+
                move.w  D4,(A0)+
                move.l  #vs_clip,D0
                bsr     _vdi

                movem.l (SP)+,D5-A6
                rts

;Kopiert den Bildschirm zurÅck auf Komplettbild unter BerÅcksichtigung des Boards
;und grab_y
put_work_back:  bset    #0,L076B
                bne.s   L00DE
put_work_sure:  movem.l D0-D1/A0-A1,-(SP)
                movea.l komplettbild,A1
                movea.l scr1,A0         ;ab scr1
                move.b  function,D1
                cmpi.b  #2,D1           ;Copybox?
                bne.s   L00DC           ;nein
cut2:           movea.l copybox_screen,A0 ;Bei Copybox ab Physbase
L00DC:          move.w  #1999,D0
                tst.w   board_da
                bne.s   L00DD
                move.w  grab_y,D1
                mulu    #160,D1
                adda.l  D1,A1
                move.w  #999,D0
L00DD:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;ZurÅck in Bild kopieren
                move.l  (A0)+,(A1)+
                dbra    D0,L00DD
                movem.l (SP)+,D0-D1/A0-A1
L00DE:          rts

;Kopiert den Bildschirm von Komplettbild -> scr1 unter BerÅcksichtigung des Boards
;und grab_y
;Dient zum Lîschen des Rahmens bei Cutter
delete_cut_rahm:movem.l D0-A6,-(SP)
                movea.l komplettbild,A0
                movea.l scr1,A1         ;ab scr1
                move.w  #199,D0
                tst.w   board_da
                bne.s   kein_board45
                move.w  grab_y,D1
                mulu    #160,D1
                adda.w  D1,A0
                move.w  #99,D0
kein_board45:   movem.l (A0)+,D1-D7/A2-A4 ;40 Bytes
                movem.l D1-D7/A2-A4,(A1)
                movem.l (A0)+,D1-D7/A2-A4 ;40 Bytes
                movem.l D1-D7/A2-A4,40(A1)
                movem.l (A0)+,D1-D7/A2-A4 ;40 Bytes
                movem.l D1-D7/A2-A4,80(A1)
                movem.l (A0)+,D1-D7/A2-A4 ;40 Bytes
                movem.l D1-D7/A2-A4,120(A1)
                lea     160(A1),A1
                dbra    D0,kein_board45

                movem.l (SP)+,D0-A6
                rts

jack_init:      clr.b   jack_status
                move.w  copy_mode,L07E6
                move.w  #-1,copy_mode
                clr.b   fun_key
                rts
jack_exit:      moveq   #0,D7
                move.w  L07E6,D7
                bra.s   L00E2
L00E1:          moveq   #-1,D7
                move.w  copy_mode,D7
L00E2:          tst.b   jack_status
                beq.s   L00E3
                bsr     restore_screen
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                move.l  D7,-(SP)
                bsr     draw_box
                move.l  (SP)+,D7
                clr.b   jack_status
                jsr     on_off_buttons
                tst.l   D7
                bpl.s   L00E3
                jsr     redraw_copy_opt
L00E3:          move.w  D7,copy_mode
                rts

do_jack:        tst.b   D2              ;Maustaste gedrÅckt?
                bne.s   L00E5           ;Ja->Jack Knife Mausroutine
                tst.b   fun_key         ;Funktionstaste gedrÅckt?
                beq.s   L00E5           ;Nein->Jack Knife
                jmp     L0419           ;zur Funktionstastenauswertung
L00E5:          move.b  jack_status,D5
                btst    #0,D5           ;Ist fertig geschnitten?
                bne     L00F5           ;ja, evtl. verschieben
                btst    #1,D5           ;Ist Rahmen zu sehen?
                bne.s   L00E7           ;Ja,
                move.w  D2,D7
                andi.w  #$000C,D7
                beq     L00F4
                move.b  #2,jack_status
                movea.l scr2,A0
                movea.l scr1,A1
                move.w  #1999,D6
L00E6:          move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                dbra    D6,L00E6
                clr.b   L076B
                move.w  #500,D7
                move.w  D7,L0828
                move.w  D7,L0829
                movea.l copybox_screen,A0
                move.w  D3,(A0)+
                move.w  D4,(A0)+
                move.l  A0,L0824
                move.w  #1,L0826
                bra     L00ED
L00E7:          move.w  D2,D7
                andi.w  #$0030,D7
                beq     L00EC
                addq.w  #1,L0826
L00E8:          cmpi.w  #2,L0826
                bcs.s   L00E9
                movea.l L0824,A0
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.w  #$000F,D2
                moveq   #0,D5
                bsr     draw_line
                move.w  D0,D3
                move.w  D1,D4
                movea.l copybox_screen,A1
                move.w  (A1)+,D0
                move.w  (A1)+,D1
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                bsr     draw_line
L00E9:          move.b  #1,jack_status
                movea.l scr2,A0
                movea.l irgend_copy,A1
                move.l  A1,objekt_pointer
                move.w  #160,breite_bytes
                lea     mask_buff,A2
                movea.l copybox_screen,A3
                move.w  L0826,D0
                jsr     L0728
                bsr     L0102
                beq     switch_screens
                move.w  D4,ani_x1
                move.w  D4,objekt_x2
                move.w  D4,objekt_x1
                move.w  D4,ani_x3
                move.w  D5,ani_y1
                move.w  D5,ani_y2
                move.w  D5,objekt_y2
                move.w  D5,objekt_y1
                move.w  D6,ani_x4
                move.w  D6,ani_x2
                move.w  D7,ani_y4
                move.w  D7,ani_y3
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,breite
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,hîhe
                bset    #0,L076B
                movea.l copybox_screen,A0
                movea.l scr2,A1
                lea     mask_buff,A2
                movea.l komplettbild,A3
                move.w  #3999,D6
                jsr     on_off_buttons
                tst.w   board_da
                bne.s   L00EA
                jsr     redraw_copy_opt
                move.w  grab_y,D7
                mulu    #$00A0,D7
                adda.w  D7,A3
                move.w  #$07CF,D6
L00EA:          move.w  (A2)+,D7
                move.w  (A1)+,D5
                move.w  D5,(A3)+
                and.w   D7,D5
                move.w  D5,(A0)+
                move.w  (A1)+,D5
                move.w  D5,(A3)+
                and.w   D7,D5
                move.w  D5,(A0)+
                move.w  (A1)+,D5
                move.w  D5,(A3)+
                and.w   D7,D5
                move.w  D5,(A0)+
                move.w  (A1)+,D5
                move.w  D5,(A3)+
                and.w   D7,D5
                move.w  D5,(A0)+
                dbra    D6,L00EA
                bsr     switch_screens
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #$07CF,D6
L00EB:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D6,L00EB
                clr.w   L0826
                clr.b   L076B
                bra     L00FC
L00EC:          move.w  D2,D7
                andi.w  #3,D7
                beq     L00F4
                tst.w   L0826
                beq     L00F4
L00ED:          addq.w  #1,L0826
                cmpi.w  #$0200,L0826
                bcc     L00E8
                movea.l L0824,A0
                move.w  -2(A0),D6
                move.w  -4(A0),D5
                sub.w   D0,D5
                bne.s   L00EE
                tst.w   L0828
                bne.s   L00EE
                sub.w   D1,D6
                move.w  L0829,D7
                move.w  D6,L0829
                eor.w   D6,D7
                bpl.s   L00EF
                bra.s   L00F2
L00EE:          sub.w   D1,D6
                bne.s   L00F0
                tst.w   L0829
                bne.s   L00F0
                move.w  L0828,D7
                move.w  D5,L0828
                eor.w   D5,D7
                bmi.s   L00F2
L00EF:          subq.w  #1,L0826
                move.w  D0,-4(A0)
                move.w  D1,-2(A0)
                bra.s   L00F3
L00F0:          movea.l D5,A1
                movea.l D6,A2
                tst.w   D5
                beq.s   L00F1
                ext.l   D6
                divs    D5,D6
                move.w  L0828,D5
                beq.s   L00F1
                move.w  L0829,D7
                ext.l   D7
                divs    D5,D7
                cmp.l   D7,D6
                beq.s   L00EF
L00F1:          move.w  A1,L0828
                move.w  A2,L0829
L00F2:          move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.l  A0,L0824
L00F3:          move.w  #$000F,D2
                moveq   #0,D5
                bra     draw_line
L00F4:          rts

L00F5:          btst    #2,jack_status  ;wird verschoben?
                bne.s   L00F7           ;Ja, verschieben
                bsr     L0100
                bne.s   L00F6
                bset    #3,jack_status
                bne.s   L00F7
                move.w  D0,-(SP)
                moveq   #$0F,D0
                bsr     set_mouse_d0
                move.w  (SP)+,D0
                bra.s   L00F7
L00F6:          bclr    #3,jack_status
                beq.s   L00F7
                bsr     set_mouse
L00F7:          move.w  D2,D7
                andi.w  #%0000000000111100,D7 ;Neu gedrÅckt/losgelassen?
                beq     L011C           ;Nein
                btst    #2,D2
                beq.s   L00FB
                clr.b   changed
                btst    #3,jack_status
                bne.s   L00F8
                bra     L00E1
L00F8:          bsr     get_shift
                bset    #2,jack_status
                bclr    #4,jack_status
                beq.s   restore_screen
                bsr.s   restore_screen
                bra     L011A

;Restauriert einen Screen nach einer Kopieraktion:
restore_screen: movea.l scr2,A1
restore_a1:     movea.l copybox_screen,A0
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L00FA
                move.w  #999,D0
L00FA:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L00FA
                rts

L00FB:          btst    #4,D2
                beq     L0115
                btst    #1,D2
                bne     L0115
                clr.b   any_shift
                bclr    #2,jack_status
L00FC:          lea     L0778,A6
                move.w  #1,4(A6)
                movea.l scr2,A1
                move.l  A1,32(A6)
                move.w  breite_bytes,D0
                lsr.w   #2,D0
                move.w  D0,24(A6)
                move.w  objekt_x2,14(A6)
                move.w  objekt_y2,16(A6)
                move.w  breite,D0
                move.w  D0,0(A6)
                move.w  hîhe,D1
                move.w  D1,2(A6)
                moveq   #$0F,D4
                move.w  ani_x1,D2
                move.w  D2,D3
                and.w   D4,D3
                ori.w   #$0010,D3
                move.w  D3,28(A6)
                add.w   D2,D0
                subq.w  #1,D0
                not.w   D4
                and.w   D4,D0
                and.w   D4,D2
                sub.w   D2,D0
                lsr.w   #3,D0
                addq.w  #6,D0
                move.w  D0,L07E5
                move.w  D0,38(A6)
                move.w  D0,D7
                movea.l A1,A0
                lsr.w   #1,D0
                subq.w  #1,D0
                moveq   #0,D2
                moveq   #-1,D3
                move.w  D0,D4
L00FD:          move.w  D2,(A1)+
                dbra    D4,L00FD
                addq.w  #1,D1
                move.w  D1,D6
                addq.w  #1,D6
L00FE:          move.w  D0,D4
L00FF:          move.w  D3,(A1)+
                dbra    D4,L00FF
                dbra    D1,L00FE
                movem.l D6-A0,-(SP)
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D6-A0
                movea.w D7,A3
                jsr     L047C
                rts

L0100:          move.w  breite_bytes,D5
                add.w   D5,D5
                move.w  objekt_x2,D6
                sub.w   ani_x1,D6
                add.w   D0,D6
                bmi.s   L0101
                cmp.w   D5,D6
                bge.s   L0101
                lsr.w   #3,D5
                move.w  objekt_y2,D7
                sub.w   ani_y1,D7
                add.w   D1,D7
                bmi.s   L0101
                mulu    D5,D7
                move.w  D6,-(SP)
                lsr.w   #4,D6
                add.w   D6,D6
                add.w   D6,D7
                move.w  (SP)+,D6
                cmpi.w  #$2080,D7
                bge.s   L0101
                not.w   D6
                andi.w  #$000F,D6
                lea     mask_buff,A0
                move.w  0(A0,D7.w),D7
                btst    D6,D7
                bne.s   L0101
                rts
L0101:          moveq   #-1,D6
                rts
L0102:          move.w  breite_bytes,D2
                lsr.w   #2,D2
                move.w  D5,D0
                mulu    D2,D0
                lea     mask_buff,A0
                movea.l A0,A1
                adda.w  D0,A0
                move.w  D7,D0
                addq.w  #1,D0
                mulu    D2,D0
                adda.w  D0,A1
                move.w  D2,D3
                lsr.w   #1,D3
L0103:          move.w  D3,D0
                moveq   #-1,D1
                bra.s   L0105
L0104:          and.w   (A0)+,D1
L0105:          dbra    D0,L0104
                addq.l  #1,D1
                bne.s   L0106
                addq.w  #1,D5
                cmp.w   D7,D5
                ble.s   L0103
                clr.b   jack_status
                clr.b   any_shift
                rts
L0106:          move.w  D3,D0
                moveq   #-1,D1
                bra.s   L0108
L0107:          and.w   -(A1),D1
L0108:          dbra    D0,L0107
                addq.l  #1,D1
                bne.s   L0109
                subq.w  #1,D7
                cmp.w   D7,D5
                bcs.s   L0106
                suba.w  D2,A1
L0109:          suba.w  D2,A0
                andi.w  #-$0010,D4
                move.w  D4,D0
                lsr.w   #3,D0
                adda.w  D0,A0
                andi.w  #-$0020,D6
                move.w  D6,D1
                lsr.w   #3,D1
                movea.l A1,A2
                adda.w  D1,A2
L010A:          moveq   #-1,D0
                movea.l A0,A3
L010B:          and.l   (A3),D0
                adda.w  D2,A3
                cmpa.l  A3,A2
                bge.s   L010B
                addq.l  #1,D0
                bne.s   L010C
                addq.l  #4,A0
                add.w   #$0020,D4
                cmp.w   D4,D6
                bge.s   L010A
L010C:          subq.l  #1,D0
                swap    D0
                cmpi.w  #-1,D0
                bne.s   L010D
                swap    D0
                add.w   #$0010,D4
L010D:          add.w   D0,D0
                bcc.s   L010E
                addq.w  #1,D4
                bra.s   L010D
L010E:          add.w   #$001F,D6
                lsl.w   #3,D2
                cmp.w   D2,D6
                blt.s   L010F
                sub.w   #$0010,D6
                subq.l  #2,A2
L010F:          lsr.w   #3,D2
L0110:          moveq   #-1,D0
                movea.l A2,A3
L0111:          and.l   (A3),D0
                suba.w  D2,A3
                cmpa.l  A3,A0
                ble.s   L0111
                addq.l  #1,D0
                bne.s   L0112
                subq.l  #4,A2
                sub.w   #$0020,D6
                cmp.w   D4,D6
                bge.s   L0110
L0112:          subq.l  #1,D0
                cmpi.w  #-1,D0
                bne.s   L0113
                swap    D0
                sub.w   #$0010,D6
L0113:          lsr.w   #1,D0
                bcc.s   L0114
                subq.w  #1,D6
                bra.s   L0113
L0114:          moveq   #-1,D0
                rts
L0115:          btst    #3,D2
                beq.s   L011B
                clr.b   changed
                btst    #3,jack_status
                beq.s   L0116
                bsr.s   L0119
                bra     L00F8
L0116:          btst    #2,jack_status
                beq.s   L0119
                tst.w   D2
                bpl.s   L0117
                movem.w D0-D1,-(SP)
                bsr     chg_koord_shift
                bsr     draw_box
                movem.w (SP)+,D0-D1
L0117:          bsr     L0237
L0118:          rts
L0119:          bset    #4,jack_status
                rts
L011A:          movem.w D0-D7,-(SP)
                lea     bitblit,A6
                move.w  breite,0(A6)
                move.w  hîhe,2(A6)
                move.l  #$03030303,10(A6)
                move.w  #8,36(A6)
                move.w  #$00A0,38(A6)
                move.w  #2,40(A6)
                bra     L0238
L011B:          btst    #5,D2
                beq.s   L011C
                btst    #0,D2
                bne.s   L011C
                clr.b   any_shift
                bclr    #2,jack_status
                bne     L00FC
L011C:          btst    #1,D2           ;Rechts immer noch gedrÅckt?
                bne     L0116           ;Ja
                btst    #2,jack_status  ;Wird verschoben?
                beq.s   L0118           ;Nein
                movem.w D0-D1,-(SP)
                bsr     chg_koord_shift
                bsr     draw_box
                movem.w (SP)+,D0-D1
                rts
draw_init:      rts
draw_exit:      rts

do_draw:        move.w  D2,D7
                andi.w  #%0000000000111100,D7 ;Taste neu gedrÅckt oder neu losgelassen?
                beq.s   L0121           ;Nein
                andi.w  #%0000000000110000,D7 ;Neu losgelassen?
                beq.s   L0120           ;Nein, also gedrÅckt
                clr.b   any_shift       ;es wurde losgelassen->Shift lîschen
                clr.b   L076B
                bra.s   L0124           ;->RTS
L0120:          bsr     get_shift       ;Es wurde neu gedrÅckt...
                clr.b   changed
                bsr     put_work_back
L0121:          move.w  D2,D7
                and.w   #%0000000000000011,D7
                cmp.w   #%0000000000000011,D7 ;Beide gedrÅckt?
                beq.s   beide
                btst    #0,D2           ;Links gedrÅckt?
                bne.s   L0122           ;ja
                btst    #1,D2           ;Rechts gedrÅckt?
                beq.s   L0124           ;Nein->RTS
                move.w  hintergrundfarbe,D2 ;Hintergrundfarbe nehmen
                bra.s   L0123
beide:          moveq   #0,D2           ;Zeichenfarbe schwarz
                bra.s   L0123
L0122:          move.w  zeichenfarbe,D2
L0123:          movem.w D0-D1,-(SP)
                bsr     chg_koord_shift ;Ist Shift gedrÅckt, Koordinaten anpassen
                move.w  #0,D5
                bsr     draw_line
                movem.w (SP)+,D0-D1
L0124:          rts

line_init:      move.w  #-1,L07E8
                bsr     L0136
line_exit:      rts

do_line:        move.w  D2,D5
                andi.w  #%0000000000001100,D5 ;Links oder rechts neu gedrÅckt?
                beq     L012C           ;Nein->evtl. aufziehen
                tst.w   L07E8
                bmi.s   L0128
                movem.w D0-D1,-(SP)     ;Mauskoordinaten retten
                clr.b   any_shift
                move.w  L07E8,D0
                move.w  L07E9,D1
                move.w  D3,D2
                move.w  D4,D3
                movea.l scr1,A5
                bsr     get_komplett
                bsr     switch_screens
                movem.w (SP)+,D0-D1
                move.w  #-1,L07E8
                clr.b   L076B
                rts

L0128:          movea.l scr1,A0
                movea.l scr2,A1
                move.w  #1999,D7
L0129:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,L0129
                bsr     get_shift
                clr.b   changed
                move.w  D5,L07EF
                btst    #3,D5           ;Rechts gedrÅckt?
                bne.s   L012A           ;ja, also Regenbogen
                move.w  zeichenfarbe,D5
                move.w  D5,left_line_color
                move.w  D5,right_line_color ;Zeichenfarbe als linken und rechten Rand
                bra.s   L012B
L012A:          move.w  right_col_mark,right_line_color
                move.w  left_col_mark,left_line_color
L012B:          bsr     put_work_back
                move.w  D0,L07E8
                move.w  D1,L07E9
                move.w  D0,D2
                move.w  D1,D3
                bsr     do_draw_line
                movem.l D0-D1,-(SP)
                bsr     switch_screens
                movem.l (SP)+,D0-D1
                rts

L012C:          tst.w   L07E8
                bmi     L012E
                move.w  D2,D5
                andi.w  #%0000000000110000,D5 ;Links oder rechts losgelassen?
                beq.s   L012D           ;Nein->weiter
                lsr.w   #2,D5
                cmp.w   L07EF,D5
                bne.s   L012D
                movem.w D0-D1,-(SP)
                move.w  L07E8,D0
                move.w  L07E9,D1
                move.w  D3,D2
                move.w  D4,D3
                movea.l scr1,A5
                bsr     get_komplett
                movem.w (SP)+,D0-D1
                movem.l D0-D4,-(SP)
                bsr     L02D4
                clr.b   any_shift
                move.w  D0,D2
                move.w  D1,D3
                move.w  L07E8,D0
                move.w  L07E9,D1
                bsr     do_draw_line
                bsr     switch_screens
                movem.l (SP)+,D0-D4
                move.w  #-1,L07E8
                clr.b   L076B
                rts

L012D:          move.w  D2,D5
                andi.w  #3,D5
                beq.s   L012E
                lsl.w   #2,D5
                cmp.w   L07EF,D5
                bne.s   L012E
                tst.w   D2
                bpl.s   L012E
                movem.w D0-D2,-(SP)
                move.w  L07E8,D0
                move.w  L07E9,D1
                move.w  D3,D2
                move.w  D4,D3
                movea.l scr1,A5
                bsr     get_komplett
                movem.w (SP)+,D0-D2
                movem.w D0-D2,-(SP)
                bsr     L02D4
                move.w  D0,D2
                move.w  D1,D3
                move.w  L07E8,D0
                move.w  L07E9,D1
                bsr     do_draw_line
                bsr     switch_screens
                movem.w (SP)+,D0-D2
L012E:          rts
fill_init:      rts
fill_exit:      rts

;Tabelle zum Umrechnen der Registerfarbe in VDI-Farbnummer:
tos2vdi:                DC.B 0,2,3,6,4,7,5,8
                        DC.B 9,10,11,14,12,15,13,1

;                movem.l D0-a6,-(SP)
;                move.w  #17,D2          ;Set Polyline color
;                bra.s   L0133

set_fill_color: movem.l D0-A6,-(SP)
L0133:          move.w  zeichenfarbe,D2
                move.b  tos2vdi(PC,D2.w),D2
                ext.w   D2
                move.w  D2,int_in
                move.l  #vsf_color,D0
                bsr     _vdi
                movem.l (SP)+,D0-A6
                rts

do_fill:        movem.l D0-A6,-(SP)

                move.w  zeichenfarbe,old_zeichenfarbe ;Farbe merken

                move.w  D2,D7
                and.w   #%0000000000001100,D7 ;Buttons isolieren
                beq.s   no_fill         ;Nichts gedrÅckt

                bsr     raster_ggf_aus

                bsr     put_work_back
                bsr     vsync_neo
                bsr     vsync_neo
                bsr     get_maus        ;Nochmal Maustasten holen
                move.w  D2,D7           ;Maustasten retten
                bsr     get_pixel

                moveq   #0,D2           ;Beide Tasten->Farbe 0
                and.w   #%0000000000000011,D7
                cmp.w   #%0000000000000011,D7 ;Beide gedrÅckt?
                beq.s   fÅll_farbe      ;ja
                move.w  zeichenfarbe,D2
                btst    #0,D7           ;Links gedrÅckt?
                bne.s   fÅll_farbe      ;ja, in Zeichenfarbe fÅllen
                move.w  hintergrundfarbe,D2 ;Sonst in Hintergrundfarbe fÅllen
fÅll_farbe:     cmp.w   D3,D2           ;FÅllfarbe unter Cursor?
                beq.s   no_fill         ;ja->nicht fÅllen
                move.w  D2,zeichenfarbe
                bsr.s   set_fill_color
                bsr     clipping_ein

                move.w  #-1,int_in      ;Farbindex des Randes
                movem.w D0-D1,ptsin     ;Koordinaten eintragen
                move.l  #v_contourfill,D0
                bsr     _vdi

                clr.b   changed         ;es wurde was verÑndert
                bsr     clipping_aus
                clr.b   L076B
no_fill:        move.w  old_zeichenfarbe,zeichenfarbe ;Farbe wieder zurÅcksetzen
                bsr     raster_ggf_an
                movem.l (SP)+,D0-A6
                rts

old_zeichenfarbe:       DC.W 0

L0136:          moveq   #0,D4
                move.w  linestÑrke,D4
                bra.s   L013A
box_init:       move.w  #-1,L07EA
L0138:          moveq   #0,D4
                move.w  randstÑrke,D4
                bne.s   L013A
                cmpi.w  #3,box_typ
                bcc.s   L0139
                tst.w   just_rahmen
                bne.s   L013A
L0139:          moveq   #1,D4
L013A:          moveq   #0,D5
                lea     build_path,A0
                lea     514(A0),A2
                move.l  A2,akt_shape
                move.w  D4,(A2)+
                move.w  D4,(A2)+
                move.w  D4,(A0)+
                lsl.w   #4,D4
                lea     L013D(PC,D4.w),A1
                moveq   #7,D6
L013B:          moveq   #0,D5
                move.w  (A1)+,D5
                move.w  D5,(A2)+
                movea.l A0,A3
                move.w  #$000F,D4
L013C:          add.l   D5,D5
                move.l  D5,(A0)
                lea     $0020(A0),A0
                dbra    D4,L013C
                movea.l A3,A0
                addq.l  #4,A0
                dbra    D6,L013B
                rts

L013D:                  DS.W 8
                        DC.B $80,$00,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $C0,$00,$C0,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B '@',$00,$E0,$00,'@',$00,$00,$00
                        DS.W 4
                        DC.B '`',$00,$F0,$00,$F0,$00,'`',$00
                        DS.W 4
                        DC.B 'p',$00,$F8,$00,$F8,$00,$F8,$00
                        DC.B 'p',$00,$00,$00,$00,$00,$00,$00
                        DC.B '0',$00,'x',$00,$FC,$00,$FC,$00
                        DC.B 'x',$00,'0',$00,$00,$00,$00,$00
                        DC.B '8',$00,'|',$00,$FE,$00,$FE,$00
                        DC.B $FE,$00,'|',$00,'8',$00,$00,$00
                        DC.B '<',$00,'~',$00,$FF,$00,$FF,$00
                        DC.B $FF,$00,$FF,$00
                moveq   #0,D7
                move.w  D0,D6
box_exit:       rts

do_box:         move.w  box_typ,D5      ;Mausbewegung bei Box...:
                subq.w  #3,D5
                bne.s   glaub2
                jmp     L05C9           ;Sprung zu groû!
glaub2:         bmi.s   glaub_ich_nicht
                jmp     L05E0           ;Sprung zu Groû!
glaub_ich_nicht:move.w  D2,D5
                andi.w  #%0000000000001100,D5 ;Wurde was neu gedrÅckt?
                beq.s   L0141           ;Nein, weiter aufziehen
                bsr     get_shift
                clr.b   changed
                clr.b   L076B
                bsr     put_work_back
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #1999,D7
L0140:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,L0140
                move.w  D0,L07EA
                move.w  D1,L07EB
                move.w  D1,L07EC
                move.w  D1,L07E8
                clr.w   L07ED
                clr.w   L07E9
                move.w  D0,D3
                move.w  D1,D4
                move.w  D0,D5
                move.w  D1,D6
                bra     L0149
L0141:          tst.w   L07EA
                bmi     L014B
                move.w  D2,D7
                andi.w  #$0030,D7
                beq.s   L0142
                clr.b   any_shift
                clr.b   L076B
                move.w  #-1,L07EA
                rts

L0142:          move.w  D2,D7
                andi.w  #3,D7
                beq     L014B           ;->RTS
                bsr     L02CE
                move.w  D0,D3
                move.w  D1,D4
                move.w  L07EA,D5
                move.w  L07EB,D6
                cmp.w   D3,D5
                bcc.s   L0143
                exg     D5,D3
L0143:          cmp.w   D4,D6
                bcc.s   L0144
                exg     D6,D4
L0144:          movea.l scr2,A0
                movea.l komplettbild,A1
                move.w  L07EC,D7
                mulu    #$00A0,D7
                adda.w  D7,A0
                adda.w  D7,A1
                tst.w   board_da
                bne.s   L0145
                move.w  grab_y,D7
                mulu    #$00A0,D7
                adda.w  D7,A1
L0145:          move.w  old_vblcount,D7
L0146:          cmp.w   vblcounter,D7
                beq.s   L0146
                move.w  L07ED,D7
                addq.w  #1,D7
                lsl.w   #3,D7
                bra.s   L0148
L0147:          move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
L0148:          dbra    D7,L0147
                move.w  D6,D7
                sub.w   D4,D7
                move.w  L07E9,L07ED
                move.w  L07E8,L07EC
                move.w  D7,L07E9
                move.w  D4,L07E8
L0149:          move.w  D3,D0
                move.w  D4,D1
                move.w  D5,D2
                move.w  D6,D3
                move.w  box_typ,D4
                add.w   D4,D4
                add.w   D4,D4
                pea     L014A(PC)       ;Hier geht's nachher weiter
                move.l  L014C(PC,D4.w),-(SP) ;Entsprechende Routine
                rts

L014A:          bsr     switch_screens
                move.w  vblcounter,old_vblcount
L014B:          rts

;Routinenstart fÅr versch. Box-Routinen:
L014C:                  DC.L L05BB ;Rechteck
                        DC.L L05BE ;rounded rectangle
                        DC.L L05ED ;Kreis

erase_all:      bsr     clear_it        ;ggf. lîschen
                bra     no_eraser       ;und zurÅck

                lea     $000A(SP),SP
                move.w  L07CC,D3        ;Alte Funktion, vor Eraser...
                move.w  stack,D4        ;holen
                bra     L007F           ;und Funktion anwÑhlen

L0154:          rts

eraser_exit:    rts
do_eraser:      move.w  zeichenfarbe,-(SP)
                clr.w   zeichenfarbe
                move.w  D2,D7
                lsr.w   #1,D7
                or.w    D7,D2
                andi.w  #-$00AB,D2
                bsr.s   do_brush
                move.w  (SP)+,zeichenfarbe
                rts
brush_init:     rts
brush_exit:     rts

do_brush_nozzle:tst.w   brush           ;Ist auch Brush aktiv?
                bne     do_nozzle       ;Nein->dann Nozzle

do_brush:       move.w  D2,D7
                andi.w  #$003C,D7
                beq.s   L015B
                andi.w  #$0030,D7
                beq.s   L015A
                clr.b   any_shift
                clr.b   L076B
                bra.s   L015B
L015A:          move.w  right_col_mark,L07F2
                bsr     get_shift
                clr.b   changed
                bsr     put_work_back
L015B:          btst    #0,D2
                bne.s   L015C
                btst    #1,D2
                beq.s   L0161
L015C:          movem.w D0-D1,-(SP)
                cmpi.b  #12,function    ;Rechtecke, Kreise...
                bne.s   L015D           ;Nein, weiter
                bsr     L02D4
                bsr     draw_brush
                addq.l  #4,SP
                rts
L015D:          bsr     chg_koord_shift
                btst    #1,D2
                beq.s   L015F
                move.w  zeichenfarbe,-(SP)
                move.w  L07F2,D7
                addq.w  #1,D7
                cmp.w   right_col_mark,D7
                ble.s   L015E
                move.w  left_col_mark,D7
L015E:          move.w  D7,L07F2
                move.w  D7,zeichenfarbe
                bsr     draw_brush
                move.w  (SP)+,zeichenfarbe
                bra.s   L0160
L015F:          bsr     draw_brush
L0160:          movem.w (SP)+,D0-D1
L0161:          rts
nozzle_init:    rts
nozzle_exit:    rts

do_nozzle:      move.w  D2,D7
                andi.w  #$003C,D7
                beq.s   L0166
                andi.w  #$0030,D7
                beq.s   L0165
                clr.b   any_shift
                clr.b   L076B
                bra     L016A
L0165:          bsr     get_shift
                clr.b   changed
                bsr     put_work_back
                move.w  right_col_mark,L07F2
                bra.s   L0167
L0166:          andi.w  #3,D2
                beq.s   L016A
                move.w  vblcounter,D5
                sub.w   L07F0,D5
                cmpi.w  #3,D5
                bcs.s   L016A
L0167:          move.w  vblcounter,L07F0
                move.w  D0,D3
                move.w  D1,D4
                move.w  zeichenfarbe,-(SP)
                btst    #1,D2
                beq.s   L0169
                move.w  L07F2,D7
                addq.w  #1,D7
                cmp.w   right_col_mark,D7
                ble.s   L0168
                move.w  left_col_mark,D7
L0168:          move.w  D7,L07F2
                move.w  D7,zeichenfarbe
L0169:          movem.w D0-D1,-(SP)
                bsr     chg_koord_shift
                bsr     draw_brush
                movem.w (SP)+,D0-D1
                move.w  (SP)+,zeichenfarbe
L016A:          rts

;Zeichnet eine Linie auf den Bildschirm (CHS)
;-> D0.W: X1_Start
;   D1.W: Y1-STart
;   D3.W: X2
;   D4.W: X4
;   D2.W: Color
draw_line:      movem.l D0-A0,-(SP)
                movem.w D0-D4,-(SP)
                linea   #0 [ Init ]
                movem.w (SP)+,D0-D4
                move.w  D0,$0026(A0)    ;Koordinaten eintragen
                move.w  D1,$0028(A0)
                move.w  D3,$002A(A0)
                move.w  D4,$002C(A0)
                move.w  #-1,$0022(A0)   ;Linienmuster
                move.w  D5,$0024(A0)    ;VDI-Schreibmodus
                move.w  #3,D4
L016C:          moveq   #0,D3
                lsr.w   #1,D2
                bcc.s   L016D
                moveq   #1,D3
L016D:          move.w  D3,$0018(A0)    ;Farbwerte eintragen
                addq.l  #2,A0           ;nÑchste Plane
                dbra    D4,L016C
                linea   #3 [ Line ]
                movem.l (SP)+,D0-A0
                rts

grabber_init:   rts
grabber_exit:   rts

;Setzt ein User-Line-typ der Line (CHS)
;Parameter:
;D0: pattern
set_user_type:  move.w  D0,int_in
                move.l  #vsl_udsty,D0
                bra     _vdi

;Setzt den Typ der Line (CHS)
;Parameter:
;D0: Typ der Linie
set_line_type:  move.w  D0,int_in
                move.l  #vsl_type,D0
                bra     _vdi

;Setzt die Farbe der Line (CHS)
;Parameter:
;D0: Farbe der Linie
set_line_color: move.w  D0,int_in
                move.l  #vsl_color,D0
                bra     _vdi

;Setzt die Breite der Line (CHS)
;Parameter:
;D0: Breite der Linie
set_line_breite:move.w  D0,ptsin
                clr.w   ptsin+2
                move.l  #vsl_width,D0
                bra     _vdi

;Setzt den Linienendtyp (CHS)
;Parameter:
;D0: Linienanfang
;D1: Linienende
set_line_ends:  movem.w D0-D1,int_in    ;Linienenden eintragen
                move.l  #vsl_ends,D0
                bra     _vdi

;Dies ist die Grabber-Routine:
do_grabber:     btst    #3,D2           ;rechts neu gedrÅckt?
                beq.s   L0171           ;Nein->Bild verschieben

color_pickup:   movem.l D0-A6,-(SP)
                bsr     get_maus
                bsr     get_pixel       ;Farbe des Pixels holen
                bsr     del_farb_ecke   ;Altes Eck wegmachen
                move.w  D3,zeichenfarbe ;Neue Farbe setzen
                bsr     set_farb_ecke   ;Neue Farbe setzen
                tst.w   board_da
                bne.s   no_copy
                bsr     copy_board      ;und Board auf Screen2 kopieren
no_copy:        movem.l (SP)+,D0-A6
                rts                     ;und fertig

L0171:          tst.w   board_da        ;kein Board da? -> nichts zu grabben
                bne.s   L0175           ;->Raus
                andi.w  #3,D2           ;Irgendeine Taste gedrÅckt?
                beq.s   L0175           ;Nein,->Raus
                move.w  D1,D5           ;y
                sub.w   D4,D5           ;Alte Y=Neue Y?
                beq.s   L0175           ;Ja->RTS
                move.w  grab_y,D4
                sub.w   D5,D4
                bpl.s   L0172
                moveq   #0,D4           ;minimal 0
L0172:          cmpi.w  #101,D4         ;101 ist zu groû!
                bcs.s   L0173           ;kleiner ok
                move.w  #100,D4         ;max. 100
L0173:          bsr     put_work_back
                move.w  D4,grab_y       ;wieder abspeichern
                movea.l komplettbild,A0
                movea.l scr1,A1
                mulu    #160,D4
                adda.w  D4,A0
                move.w  #999,D3
L0174:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Bild auf Screen kopieren
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D3,L0174
                bsr     neue_raster     ;und die Raster angleichen
L0175:          rts

text_init:      move.w  #-1,L07F2
                rts
text_exit:      tst.w   L07F2
                bmi.s   L0178
                bsr     L025B
                move.w  #-1,L07F2
L0178:          rts

do_text:        btst    #2,D2
                beq.s   L017D
                tst.w   L07F2
                bmi.s   L017A
                bsr     L025B
L017A:          clr.b   changed
                bsr     put_work_back
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #$07CF,D5
L017B:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D5,L017B
                move.w  D0,L07F2
                move.w  D0,L0806
                move.w  D1,D4
                sub.w   L081C,D4
                bpl.s   L017C
                moveq   #0,D4
L017C:          move.w  D4,L07F3
                move.l  #build_path,L07F1
                move.w  D4,L0807
                bsr     L0257
L017D:          movem.w D0-D2,-(SP)
                move.w  L0806,D0
                move.w  L0807,D1
                move.l  taste,D5
                beq     L0188
                swap    D5
                cmpi.b  #$61,D5
                beq     L0188
                cmpi.b  #1,D5
                beq     L0188
                swap    D5
                tst.w   D5
                beq     L0187
                tst.w   L07F2
                bmi     L0187
                bsr     L025B
                movea.l L07F1,A0
                cmpi.b  #8,D5
                bne.s   L017F
                cmpi.b  #$0D,-(A0)
                bne.s   L017E
                bsr     L0267
                move.w  L0796,D5
                sub.w   D5,L0807
                bra.s   L0181
L017E:          cmpa.l  #build_path,A0
                bcs     L0185
                bne.s   L0181
                move.l  A0,L07F1
                move.w  L07F2,D2
                bsr     L0261
                bra     L0184
L017F:          move.b  D5,(A0)+
                cmpi.b  #$0D,D5
                bne.s   L0180
                bsr     L0267
                move.w  L07F2,L0806
                move.w  L0796,D5
                add.w   D5,L0807
                bra.s   L0181
L0180:          move.b  L0599,D6
                or.b    D6,-1(A0)
L0181:          move.l  A0,L07F1
                clr.b   (A0)
L0182:          cmpi.b  #$0D,-(A0)
                beq.s   L0183
                cmpa.l  #build_path,A0
                bcc.s   L0182
L0183:          addq.l  #1,A0
                bsr     L0261
                move.l  A0,-(SP)

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                move.l  #-1,-(SP)
                move.l  scr2,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                movea.l (SP)+,A0
                bsr     clipping_ein
                move.w  L07F2,D0
                move.w  L0807,D1
                bsr     L03F6
                move.w  D0,D2
L0184:          bsr     clipping_aus
                move.w  D2,L0806
                bsr     switch_screens
L0185:          btst    #2,L0799
                beq.s   L0186
                movea.l L07F1,A0
                cmpa.l  #build_path,A0
                beq.s   L0186
                cmpi.b  #$0D,-1(A0)
                beq.s   L0186
                move.w  L081A,D0
                add.w   L081B,D0
                add.w   D0,L0806
L0186:          bsr     L0257
                clr.b   L076B
                move.b  #-$80,L07A1
L0187:          clr.l   taste
L0188:          movem.w (SP)+,D0-D2
                rts

L0189:          movem.w D0-D2,-(SP)
                tst.w   L07F2
                bmi     L0191
                movea.l komplettbild,A0
                movea.l scr2,A1
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L018A
                move.w  grab_y,D1
                mulu    #$00A0,D1
                adda.w  D1,A0
                move.w  #999,D0
L018A:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L018A

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                pea     -1.w
                move.l  scr2,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                bsr     clipping_ein
                move.w  L07F3,L0807
                movea.l L07F1,A2
                lea     build_path,A0
L018B:          movea.l A0,A1
L018C:          cmpa.l  A1,A2
                beq.s   L018D
                cmpi.b  #$0D,(A1)+
                bne.s   L018C
                clr.b   -(A1)
                move.w  L07F2,D0
                move.w  L0807,D1
                move.l  A2,-(SP)
                bsr     L03F6
                movea.l (SP)+,A2
                move.b  #$0D,-1(A0)
                move.w  L0796,D0
                add.w   D0,L0807
                bra.s   L018B
L018D:          cmpi.b  #$0D,(A1)
                bne.s   L018E
                move.w  L0796,D0
                add.w   D0,L0807
                move.w  L07F2,L0806
                bra.s   L018F
L018E:          clr.b   (A1)
                move.w  L07F2,D0
                move.w  L0807,D1
                bsr     L03F6
                move.w  D0,L0806
L018F:          bsr     switch_screens
                bsr     clipping_aus
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L0190
                move.w  #999,D0
L0190:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0190
                bra     L0185
L0191:          movem.w (SP)+,D0-D2
                rts

animate_init:   movem.l D0-A6,-(SP)

                bsr     put_work_sure   ;Kopiert den Bildschirm zurÅck

                movea.l komplettbild,A0
                movea.l rotate_buffer,A1
                move.w  #7999,D7
copy_scr:       move.l  (A0)+,(A1)+     ;Komplettbild in rotate_buffer speichern
                dbra    D7,copy_scr

                bsr.s   komplett2scr    ;und anzeigen

                movem.l (SP)+,D0-A6
                rts

animate_exit:   movem.l D0-A6,-(SP)     ;Register retten

                movea.l rotate_buffer,A0
                movea.l komplettbild,A1
                move.w  #7999,D7
copy_scr34:     move.l  (A0)+,(A1)+     ;Rotate_buffer -> komplettbild
                dbra    D7,copy_scr34

                bsr.s   komplett2scr    ;Bringt Komplettbild auf Screen

                movem.l (SP)+,D0-A6
                rts

;Kopiert komplettbild auf scr1 und scr2 (!) unter BerÅcksichtung von Grab_y (CHS)
komplett2scr:   movem.l D0-A6,-(SP)

                movea.l scr1,A1
                movea.l komplettbild,A0
                move.w  #1999,D7
                tst.w   board_da
                bne.s   L038F2
                move.w  grab_y,D1
                mulu    #160,D1
                adda.l  D1,A0
                move.w  #999,D7
L038F2:         movem.l (A0)+,D0-D3     ;Komplettbild auf Scr1
                movem.l D0-D3,(A1)
                lea     16(A1),A1
                dbra    D7,L038F2

                movea.l scr1,A1
                movea.l scr2,A2
                move.w  #1999,D7
L038F3:         movem.l (A1)+,D0-D3     ;scr1 -> scr2 kopieren
                movem.l D0-D3,(A2)
                lea     16(A2),A2
                dbra    D7,L038F3

                movem.l (SP)+,D0-A6
                rts

                tst.w   board_da
                move.w  grab_y,D3
                mulu    #160,D3
                movea.l scr1,A0
                movea.l komplettbild,A1
                adda.w  D3,A0
                adda.w  D3,A1
                move.w  grab_y,D3
                mulu    #$00A0,D3
                adda.w  D3,A1
                move.w  L0687,D4
                addq.w  #2,D4
                mulu    #$000A,D4
                bra.s   L0197
L0196:          move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
L0197:          dbra    D4,L0196
                movem.l (SP)+,D3-D4/A0-A1
L0198:          rts



                        IF 1=2
                tst.b   L0787           ;Alles mit Camera, daû ausgeklammert
                beq.s   L019A           ;wurde, wurde mit ANI im Kommentar
                clr.b   L0787           ;versehen.
                bsr     copy_board
L019A:          btst    #2,D2
                bne     L01BD
                btst    #4,D2
                beq     L01A3
                bclr    #6,L0784
                beq.s   L019B
                bsr     set_mouse
                bra     L01C1
L019B:          btst    #1,L0784
                beq     L01C1
                bsr     L0286
                move.w  D0,D3
                andi.w  #-$0010,D3
                addi.w  #$0010,D3
                cmpi.w  #$0140,D3
                bne.s   L019C
                move.w  #$0130,D3
L019C:          move.w  D3,L07D2
                move.w  D1,L07D3
                bsr     L0286
                move.b  #1,L0784
                lea     L082D,A0
                moveq   #5,D4
                moveq   #0,D5
L019D:          move.l  D5,(A0)+
                dbra    D4,L019D
                movea.l copybox_screen,A0
                move.w  #$07CF,D4
                moveq   #0,D5
L019E:          move.l  D5,(A0)+
                move.l  D5,(A0)+
                move.l  D5,(A0)+
                move.l  D5,(A0)+
                dbra    D4,L019E
                movem.w D1/D3,-(SP)
                bsr     get_free_mem
                movem.w (SP)+,D1/D3
                move.w  L07D0,D4
                addq.w  #1,D4
                move.w  D4,L07D4
                sub.w   D4,D3
                move.w  L07D1,D4
                addq.w  #1,D4
                sub.w   D4,D1
                tst.w   board_da
                bne.s   L019F
                add.w   grab_y,D4
L019F:          move.w  D4,L07D5
                lsr.w   #1,D3
                move.w  D3,L0686
                move.w  D1,L0687
                mulu    D1,D3
                add.w   #$000A,D3
                move.w  D3,L0688
                subi.l  #$00000A00,D0
                bpl.s   L01A0
                moveq   #0,D0
L01A0:          divu    D3,D0
                cmpi.w  #$0064,D0
                bcs.s   L01A1
                move.w  #$0063,D0
L01A1:          mulu    D0,D3
                movem.l D0/D3,-(SP)
                move.l  D3,-(SP)
                move.w  #$0048,-(SP)
                trap    #1              ;Speicher holen!
                addq.l  #6,SP
                move.l  D0,D1
                movem.l (SP)+,D0/D3
                move.l  D1,L0830
                move.l  D1,L0831
                add.l   D3,D1
                move.l  D1,L0832
                ext.l   D0
                divu    #$000A,D0
                lea     L01BC(PC),A0
                lea     L058F,A1
                move.b  0(A0,D0.w),(A1)+
                swap    D0
                ext.l   D0
                move.b  0(A0,D0.w),(A1)
                bsr     L04AB
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #$07CF,D0
L01A2:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L01A2
                bra     L01C1
L01A3:          btst    #3,D2
                beq     L01AB
                btst    #0,L0784
                beq     L01C1
                bset    #3,L0784
                move.w  #1,D0
                bsr     set_mouse_d0
L01A4:          bsr.s   L01A8
                bra     L01C1
L01A5:          move.w  L07D6,D3
                move.w  L07D7,D4
                movea.l copybox_screen,A0
                bra.s   L01A9

L01A6:          move.w  L07D0,D0
                addq.w  #1,D0
                move.w  D0,L07D4
                move.w  L07D1,D0
                addq.w  #1,D0
                tst.w   board_da
                bne.s   L01A7
                add.w   grab_y,D0
L01A7:          move.w  D0,L07D5
L01A8:          movea.l komplettbild,A0
                move.w  L07D4,D3
                move.w  L07D5,D4

L01A9:          lea     bitblit,A6
                move.w  L0686,D0
                add.w   D0,D0
                move.w  D0,0(A6)        ;Breite in Pixeln
                move.w  L0687,2(A6)     ;Hîhe in Pixeln
                move.l  A0,18(A6)       ;Anfangsadresse Source
                move.l  scr2,32(A6)     ;Zieladresse
                move.w  D3,14(A6)       ;X-Source
                move.w  L07D0,D0
                addq.w  #1,D0
                move.w  D0,28(A6)       ;Dest-X
                move.w  D4,16(A6)       ;Source-y
                move.w  L07D1,D0
                addq.w  #1,D0
                move.w  D0,30(A6)       ;Dest-Y
                move.w  #4,4(A6)        ;Planes
                move.l  #$03030303,10(A6) ;copy....
                move.w  #8,22(A6)       ;Offset zur selben Plane
                move.w  #160,24(A6)     ;Breite in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  #8,36(A6)       ;Offset zur selben Plane
                move.w  #160,38(A6)     ;Breite in Bytes
                move.w  #2,40(A6)       ;Offset zur nÑchsten Plane
                move.w  old_vblcount,D7
L01AA:          cmp.w   vblcounter,D7   ;Vsync
                beq.s   L01AA
                linea   #7 [ Bitblk ]
                move.w  vblcounter,old_vblcount
                bsr     switch_screens  ;umschalten

L01AB:          btst    #0,D2
                beq.s   L01B0
                btst    #6,L0784
                beq.s   L01B0
                sub.w   D0,D3
                add.w   D3,L07D6
                bpl.s   L01AC
                clr.w   L07D6
L01AC:          move.w  L0686,D3
                add.w   D3,D3
                add.w   L07D6,D3
                sub.w   #$0140,D3
                bcs.s   L01AD
                sub.w   D3,L07D6
L01AD:          sub.w   D1,D4
                add.w   D4,L07D7
                bpl.s   L01AE
                clr.w   L07D7
L01AE:          move.w  L0687,D4
                add.w   L07D7,D4
                sub.w   #$00C7,D4
                bcs.s   L01AF
                sub.w   D4,L07D7
L01AF:          bsr     L01A5
                bra     L01C1
L01B0:          btst    #1,D2
                beq.s   L01B5
                btst    #3,L0784
                beq.s   L01B5
                sub.w   D0,D3
                add.w   D3,L07D4
                bpl.s   L01B1
                clr.w   L07D4
L01B1:          move.w  L0686,D3
                add.w   D3,D3
                add.w   L07D4,D3
                sub.w   #$0140,D3
                bcs.s   L01B2
                sub.w   D3,L07D4
L01B2:          sub.w   D1,D4
                add.w   D4,L07D5
                bpl.s   L01B3
                clr.w   L07D5
L01B3:          move.w  L0687,D4
                add.w   L07D5,D4
                sub.w   #$00C7,D4
                bcs.s   L01B4
                sub.w   D4,L07D5
L01B4:          bra     L01A4
L01B5:          btst    #5,D2
                beq.s   L01B6
                bclr    #3,L0784
                beq.s   L01B6
                bsr     set_mouse
                bra     L01C1
L01B6:          btst    #0,D2
                beq     L01C1
                btst    #1,L0784
                beq     L01C1
                bsr     L0286
                move.w  D0,D3
                andi.w  #-$0010,D3
                addi.w  #$0010,D3
                cmpi.w  #$0140,D3
                bne.s   L01B7
                move.w  #$0130,D3
L01B7:          move.w  D3,L07D2
                move.w  D1,L07D3
                bsr     L0286
L01B8:          move.w  L07D2,D3
                move.w  L07D3,D1
                sub.w   L07D0,D3
                subq.w  #1,D3
                cmpi.w  #$0140,D3
                bcs.s   L01B9
                move.w  #$03E7,D3
L01B9:          move.w  D1,D4
                sub.w   L07D1,D4
                subq.w  #1,D4
                cmpi.w  #$0140,D4
                bcs.s   L01BA
                move.w  #$03E7,D4
L01BA:          tst.w   board_da
                bne     L01C1
                lea     L0782,A0
                ext.l   D3
                divu    #$0064,D3
                move.b  L01BC(PC,D3.w),(A0)+
                swap    D3
                ext.l   D3
                divu    #$000A,D3
                move.b  L01BC(PC,D3.w),(A0)+
                swap    D3
                move.b  L01BC(PC,D3.w),(A0)
                lea     L0783,A0
                ext.l   D4
                divu    #$0064,D4
                move.b  L01BC(PC,D4.w),(A0)+
                swap    D4
                ext.l   D4
                divu    #$000A,D4
                move.b  L01BC(PC,D4.w),(A0)+
                swap    D4
                move.b  L01BC(PC,D4.w),(A0)
                lea     L0781,A0        ;x:000 y:000
L01BB:          move.w  #$00CA,D0
                move.w  #$00C0,D1
                moveq   #0,D2
                bsr     print6x6
                bra     L01C1

L01BC:                  DC.B '0123456789'

L01BD:          btst    #0,L0784
                beq     L01BF
                btst    #2,L0784
                beq.s   L01BE
                move.w  #1,D0
                bsr     set_mouse_d0
                bset    #6,L0784
                jsr     L0671
                move.w  L07D0,D3
                addq.w  #1,D3
                move.w  D3,L07D6
                move.w  L07D1,D3
                addq.w  #1,D3
                move.w  D3,L07D7
                bsr     L01A5
                bra     L01C1
L01BE:          move.l  L0830,-(SP)
                move.w  #$0049,-(SP)
                trap    #1
                addq.l  #6,SP
                clr.l   L0830
                clr.l   L0831
                clr.l   L0832
                clr.l   L082D
                bsr     L0286
                clr.b   L0784
                move.b  #$20,D0
                move.b  D0,L058F
                move.b  D0,L0590
                lea     L0786,A0
                move.w  #288,D0
                move.w  #$00C0,D1
                moveq   #0,D2
                bsr     print6x6
                lea     L0785,A0
                bra     L01BB
L01BF:          move.w  D0,D3
                andi.w  #-$0010,D3
                subi.w  #$0010,D3
                bpl.s   L01C0
                moveq   #0,D3
L01C0:          addi.w  #$000F,D3
                move.w  D3,L07D0
                move.w  D1,L07D1
                addq.w  #1,D3
                move.w  D3,L07D2
                move.w  D1,L07D3
                move.b  #2,L0784
                bsr     L0286
L01C1:          rts

                        ENDC


;Baut sÑmtliche Pfade fÅr die Fileselectoren auf
build_pathes:   move.w  #$0019,-(SP)    ;Laufwerk holen
                trap    #1
                addq.l  #2,SP
                lea     cut_path,A0
                move.b  D0,(A0)
                addi.b  #'A',(A0)+      ;Pfad aufbauen
                move.b  #':',(A0)+
                addq.b  #1,D0
                ext.w   D0
                move.w  D0,-(SP)
                move.l  A0,-(SP)
                move.w  #$0047,-(SP)    ;Getpath
                trap    #1
                addq.l  #8,SP

                lea     cut_path,A0
such_end88:     tst.b   (A0)+
                bne.s   such_end88

                move.b  #'\',-1(A0)
                clr.b   (A0)

                lea     cut_path,A0
                lea     save_path,A1
                lea     load_path,A2
copy_pathes:    move.b  (A0)+,D0        ;Pfad kopieren
                move.b  D0,(A1)+
                move.b  D0,(A2)+
                bne.s   copy_pathes

                move.b  #'*',-1(A0)
                move.b  #'.',(A0)+
                move.b  #'O',(A0)+      ;Cutter-Pfad
                move.b  #'B',(A0)+
                move.b  #'J',(A0)+
                clr.b   (A0)

                move.w  save_typ,D1
                lea     save_path,A0
                jsr     change_path

                move.w  load_typ,D1
                lea     load_path,A0
                jsr     change_path

                jsr     set_load_ext    ;im Fileselektor Ñndern
                jsr     set_save_ext    ;-'-

                clr.b   cut_file
                rts


;Routine zum Laden eines Bildes:
load_neo:       lea     picture_neo,A0
                lea     picture_old,A1
copy_it67:      move.b  (A0)+,(A1)+     ;Alten Filenamen retten
                bne.s   copy_it67

                lea     load_path,A0
                lea     picture_neo,A1
                lea     load_ext,A2
                moveq   #0,D0           ;Laden
                jsr     fileselect
                bne     raus_hier254    ;und ganz raus hier

                lea     picture_neo,A0
                lea     picture_neu,A1
copy83:         move.b  (A0)+,(A1)+     ;Neuen Filenamen retten
                bne.s   copy83

                tst.b   changed         ;wurden énderungen vorgenommen?
                bne.s   L01C5           ;Nein
                bsr     Hm
                bsr     switch2tos
                move.l  #L077F,D0       ;Save changes before proceeding...
                bsr     alert
                move.w  int_out,D1
                cmpi.w  #1,D1           ;1. Button betÑtigt?
                bne.s   L01C5           ;Nein->Weiter

                lea     picture_old,A0
                lea     picture_neo,A1
copy84:         move.b  (A0)+,(A1)+     ;Alten Filenamen zum Saven verwenden
                bne.s   copy84
                bra     L00A2           ;und abspeichern->L01C5

L01C5:          lea     picture_neu,A0
                lea     picture_neo,A1
copy85:         move.b  (A0)+,(A1)+     ;Neuen Filenamen zum Laden verwenden
                bne.s   copy85

                clr.w   grab_y
                move.w  #-1,no_pic_load ;Es wird was Åber Commandline geladen..
                move.w  #1999,D0
                movea.l komplettbild,A0
                movea.l scr1,A1
L01C6:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Bild->scr1 kopieren
                move.l  (A0)+,(A1)+     ;wegen UNDO?
                move.l  (A0)+,(A1)+
                dbra    D0,L01C6
                bsr     switch2neo

                jsr     fopen

                move.l  #fsel_path,filenamen

                bra     laden_bild      ;Bild laden

raus_hier254:   lea     picture_neo,A1
                lea     picture_old,A0
copy_it678:     move.b  (A0)+,(A1)+     ;Alten Filenamen restaurieren
                bne.s   copy_it678

                bra     back2neo

;Adressen der Error-Alerts (CHS)
error_alerts:           DC.L filenotfound ;File not found
                        DC.L L00CB ;Wrong Format

;LÑdt ein Bild (CHS)
;Parameter:
;D0: fhandle
;lade_typ
;RÅckgabe: 0=Okay, -2..-1
load_pic:       move.b  #1,just_palette ;mit Bild!

                clr.w   grab_y          ;von oben herein laden
                move.b  #-1,changed     ;Nichts wurde verÑndert am Bild
                clr.w   rot_col_direct  ;Jetzt wird nichts animiert
                move.w  D0,fhandle
                bpl.s   L000E
                moveq   #-1,D0          ;File not found...
                rts

L000E:          movem.l D1-A6,-(SP)     ;Register retten

                bsr     Hm              ;Maus weg
                movea.l komplettbild,A0
                movea.l scr1,A1         ;in Ladebildschirm Åbertragen, falls
                jsr     copy_screen     ;Bild kÅrzer als 32K

                clr.w   -(SP)           ;Suchtyp
                move.l  filenamen,-(SP)
                move.w  #$004E,-(SP)
                trap    #1
                addq.l  #8,SP

                clr.w   -(SP)           ;Relativ zum Dateistart
                move.w  fhandle,-(SP)
                move.l  #124,-(SP)      ;124 Bytes nach Start
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP

                movea.l rotate_buffer,A6
                clr.l   (A6)            ;Lîschen
                moveq   #4,D6
                jsr     read            ;ggf. NEO-Kennung lesen

                clr.w   -(SP)           ;Relativ zum Dateistart
                move.w  fhandle,-(SP)
                clr.l   -(SP)           ;An Dateistart gehen
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP

                lea     bytes_4,A6
                clr.l   (A6)
                moveq   #4,D6           ;4 Bytes laden
                jsr     read

                clr.w   -(SP)           ;Relativ zum Dateistart
                move.w  fhandle,-(SP)
                clr.l   -(SP)           ;An Dateistart gehen
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP

                cmpi.w  #4,load_typ     ;*.DOO?
                beq.s   load_sofort     ;ja->Keine TypenÅberprÅfung

                cmpi.l  #'FORM',(A6)    ;IFF-Bild?
                beq     load_iff        ;ja
                cmpi.b  #$80,(A6)       ;PCx?
                beq     load_pkd_degas
                movea.l rotate_buffer,A5
                cmpi.l  #'NEO!',(A5)    ;Neochrome-Flag?
                beq     load_neo_img    ;ja!
                cmpi.l  #32128,dta_size
                beq     load_neo_img
                cmpi.l  #32034,dta_size
                beq     load_degas
                cmpi.l  #32066,dta_size
                beq     load_degas
load_sofort:    move.w  load_typ,D0
                lsl.w   #2,D0           ;mal 4
                lea     load_table(PC),A0
                movea.l 0(A0,D0.w),A0
                jmp     (A0)            ;entsprechende Laderoutine

load_table:             DC.L load_neo_img,load_degas,load_pkd_degas
                        DC.L load_iff,load_doodle

bytes_4:                DS.L 1  ;Die ersten 4 Byte des Files

                        >PART 'Load Doodle-Picture'
load_doodle:    moveq   #4,D1           ;ab jetzt wird DOODLE
                jsr     change_load_typ

                movea.l scr1,A6
                move.l  #32000,D6
                jsr     read
                bra     ende_load
                        ENDPART

                        >PART 'Load IFF-Picture'

load_iff:       moveq   #3,D1           ;ab jetzt wird IFF geladen!
                jsr     change_load_typ

                clr.b   just_palette    ;Bisher nur Palette

                movea.l rotate_buffer,A6
                moveq   #12,D6          ;12 Bytes laden
                jsr     read            ;und lesen
                cmpi.l  #'FORM',(A6)    ;IFF?
                bne     wrong_format
                cmpi.l  #'ILBM',8(A6)   ;Grafik?
                bne     wrong_format

                bsr     rette_palette   ;Farbpalette retten
                bsr     clear_rasters   ;Alle Raster wegmachen

iffloop:        bsr.s   chunkread
                cmp.l   D6,D0           ;Kam der Chunk ganz an?
                bne     ende_load       ;Nein, iff komplett
                bsr.s   chunkint        ;Sonst Chunk auswerten
                tst.w   D0              ;Alle ok?
                beq.s   iffloop         ;Ja, Weiter
                bra     iff_load_part_2 ;Nein, Fehler -> Zweite Routine versuchen

;Liest einen Chunk aus der Datei
chunkread:      lea     chunk_header,A6
                moveq   #8,D6           ;8 Bytes lesen
                jsr     read            ;und lesen
                cmp.l   D6,D0           ;ganz gelesen?
                bne.s   end_chunkread   ;nein->RTS

                movea.l scr2,A6         ;Leseadresse
                move.l  chunk_len,D6    ;LÑnge des Restchunks holen
                cmp.l   #32000+7424,D6  ;Nur solange ist mein Ladebuffer
                ble.s   kurz_genug
                move.l  #'xxxx',chunk_header ;hier kommt ein ungÅltiger Chunk!
                move.w  #1,-(SP)        ;relativ von hier
                move.w  fhandle,-(SP)
                move.l  D6,-(SP)        ;Chunk Åberspringen
                move.w  #$0042,-(SP)    ;Lseek
                trap    #1
                lea     10(SP),SP
                move.l  D6,D0           ;Chunk wurde korrekt gelesen!
                bra.s   end_chunkread
kurz_genug:     jsr     read
end_chunkread:  rts

chunkint:       moveq   #0,D0           ;Kein Fehler...
                lea     chunk_id,A6     ;Hier steht der Chunk-Header
                cmpi.l  #'BMHD',(A6)
                beq     bmhdchunk
                cmpi.l  #'BODY',(A6)
                beq     bodychunk
                cmpi.l  #'CMAP',(A6)
                beq.s   colorchunk
                cmpi.l  #'RAST',(A6)    ;Kommen hier etwa Raster?
                beq     rasterchunk
                rts

colorchunk:     move.l  4(A6),D7        ;LÑnge des Farbchunks
                movea.l scr2,A0         ;Quelladresse (Start der Farbwerte)
                divu    #3,D7
iff_color:      cmp.w   #16,D7          ;Mehr als 16 Farbregister haben wir nicht
                blt.s   ok1
                moveq   #16,D7
ok1:            lea     hbl_system+2,A1 ;Hier kommen die Farben hin
                moveq   #0,D1           ;und wieder lîschen
                moveq   #0,D2
                bra.s   hardy
colloop:        move.b  (A0)+,D1        ;Rot-Wert holen
                lsr.w   #4,D1
                move.b  D1,(A1)+
                move.b  (A0)+,D1        ;GrÅn-Wert holen
                and.b   #%11110000,D1
                move.b  (A0)+,D2        ;Blau-Wert holen
                lsr.w   #4,D2
                or.b    D2,D1
                move.b  D1,(A1)+
                move.w  -2(A1),D0       ;Farbwert holen
                bsr     resort_ste      ;in STE-Format wandeln
                move.w  D0,-2(A1)       ;und wieder speichern
hardy:          dbra    D7,colloop

                tst.w   ste_machine
                bne.s   no_con5
                tst.w   ste_support
                beq.s   no_con5
                lea     hbl_system+2,A0
                jsr     convert2st

no_con5:        bsr     neue_raster     ;und anzeigen bitte
                clr.w   rst_akt         ;Jetzt ist Raster #0 aktiv
                bsr     neue_palette    ;und anzeigen

                moveq   #0,D0           ;ok-Flag
                rts

bmhdchunk:      movea.l scr2,A6         ;Hier steht der Chunk
                cmpi.w  #320,(A6)
                bne.s   wrong_iff
                cmpi.w  #200,2(A6)
                bne.s   wrong_iff
                move.b  10(A6),compress ;Compress-Flag
                moveq   #0,D0           ;ok
                rts
wrong_iff:      moveq   #-1,D0          ;nicht 320x200
                rts

bodychunk:      move.b  #1,just_palette ;Es kam auch Grafik
                cmpi.b  #1,compress     ;gepacktes IFF?
                beq.s   entpack_pkd     ;ja, entpacken

                movea.l scr2,A0         ;Quelldaten
                movea.l scr1,A1         ;Zielscreen
                move.w  #199,D7         ;ZeilenzÑhler
nxt_scanline:   moveq   #3,D6           ;Plane-ZÑhler
nxt_plane:      moveq   #19,D5          ;Word-ZÑhler
nxt_long:       move.w  (A0)+,(A1)      ;40 Bytes Åbertragen
                addq.l  #8,A1
                dbra    D5,nxt_long
                lea     -158(A1),A1     ;zurÅcksetzen
                dbra    D6,nxt_plane
                lea     152(A1),A1      ;vorsetzen auf nÑchste Zeile
                dbra    D7,nxt_scanline

                moveq   #0,D0           ;Alles Okay
                rts

entpack_pkd:    movea.l scr2,A0         ;Quelldaten
                movea.l scr1,A1         ;Ziel
                bsr     entpack_pic
                moveq   #0,D0           ;ok
                rts

rasterchunk:    move.l  4(A6),D6        ;LÑnge des Chunks
                lsr.w   #2,D6
                subq.w  #1,D6
                movea.l scr2,A6
                lea     hbl_system,A1
copy_t:         move.l  (A6)+,(A1)+
                dbra    D6,copy_t
                tst.w   ste_machine
                bne.s   no_con4
                tst.w   ste_support
                beq.s   no_con4
                lea     hbl_system+2,A0
                jsr     convert_rasters ;Alle STE -> ST
no_con4:        clr.w   rst_akt         ;Jetzt ist Raster #0 aktiv
                bsr     palette_changed ;und ins Board
                tst.w   blitter_an
                bne.s   no_blit
                bsr     blitter_off
no_blit:        moveq   #0,D0
                rts


iff_load_part_2:clr.w   -(SP)           ;Relativ zum Dateistart
                move.w  fhandle,-(SP)
                clr.l   -(SP)           ;An Dateistart gehen
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP

                move.w  fhandle,D6      ;Filehandle Åbergeben
                movea.l scr1,A1         ;Zielbuffer
                bsr     load_iff_2
                tst.w   D0              ;Fehler aufgetreten?
                bmi     wrong_format    ;ja->Fehlermeldung

                bsr     palette_changed
                bra     ende_load


*******************
** IFF Loader    **
*******************
** LÑdt Bilder mit bis zu 5 Planes
** und rechnet diese entsprechend ins Atari-Format um
** (C) 1990 by Jîrg Seebohn

* ----- Schnittstelle -----

* d6 = filehandle
* a1 = Zielpuffer

* D0 = Fehlermeldung :  0  = Alles Ok
*                       -1 = Lesefehler
*                       -2 = File not found (openerror)
*                       -3 = Kein IFF-Format
*                       -4 = unbekanntes IFF-Format

* Alle Register werden verÑndert , auûer sp
* auf dem Stack werden maximal 20 Bytes belegt (also Stack mind. so groû)

* ----- Ende Schnittstelle -----


* Flags fÅr Fehlermeldungen

iff_allok               EQU 0
iff_readerror           EQU -1
iff_openerror           EQU -2
iff_noiff               EQU -3
iff_unknown             EQU -4


load_iff_2:     movea.l SP,A6           ;Stackzeiger sichern

                pea     (A1)            ; Zielpuffer sichern

* Ist es ein Iff-Bild?

                moveq   #12,D0
                suba.l  D0,SP           ;12 Bytes reservieren
                movea.l SP,A0
                bsr     iff_read        ;Lese 12 Bytes
                movem.l (SP)+,D1-D3
                cmp.l   #12,D0
                bne     iff_ladefehler
                cmp.l   #'FORM',D1
                bne     iff_keinifformat
                cmp.l   #'ILBM',D3
                bne     iff_keinifformat

* Suche BMHDchunk
                move.l  #'BMHD',D0
                bsr     iff_searchchunk

*               d0 = ChunklÑnge (=20 Bytes normalerweise)
                move.l  D0,D3           ;LÑnge merken
                suba.l  D3,SP           ;Platz machen
                movea.l SP,A0           ;Zielpuffer
                bsr     iff_read

*               Informationen Åbernehmen
                movea.l SP,A0
                move.w  (A0)+,iff_breite
                move.w  (A0)+,iff_hoehe
                addq.w  #4,A0
                move.b  (A0)+,iff_planes
                move.b  (A0)+,D0
                cmp.b   #1,D0
                beq.s   iff_hatmaske
                moveq   #0,D0
iff_hatmaske:   move.b  D0,iff_mask

                move.b  (A0)+,iff_compression
*               Rest unwichtig !

                adda.l  D3,SP           ;und ausgleichen

* Suche Farbchunk
                move.l  #'CMAP',D0
                bsr     iff_searchchunk
*               d0 = ChunklÑnge
                move.l  D0,-(SP)
                pea     iff_colormap    ;Zielpuffer
iff_nextrgb:
                moveq   #3,D0
                movea.l (SP),A0         ;3 Bytes lesen
                bsr     iff_read
                movea.l (SP),A0
                move.l  (A0),D0         ;alle Farbwerte runterschieben
                lsr.l   #4,D0
                move.l  D0,(A0)
                addq.l  #4,(SP)
                subq.l  #3,4(SP)
                bgt     iff_nextrgb
                addq.l  #8,SP

* Suche Bodychunk

                move.l  #'BODY',D0
                bsr     iff_searchchunk

* ZÑhle die Anzahl der einzelnen Punkte

                move.l  D0,D7           ;LÑnge der Bodystruktur

                move.w  #200,D0
                cmp.w   iff_hoehe,D0    ;Originalhîhe kleiner als 200 ?
                ble     iff_normal
                move.w  iff_hoehe,D0
iff_normal:
                move.w  D0,-(SP)        ;Anzahl zeilen zum testen

*               Lîsche Farbcounttabelle
                lea     iff_countcolor,A0
                moveq   #0,D0
                moveq   #31,D1          ;Maximal 32 Farben
iff_clear1:     move.l  D0,(A0)+
                dbra    D1,iff_clear1


iff_countnextzeile:
                bsr     iff_lade_zeile  ;Lade eine Zeile
*               A0 = Adresse der geladenen Zeile

                move.w  iff_breite,D0
                addq.w  #7,D0
                lsr.w   #3,D0
                move.w  D0,D5           ;Anzahl Bytes pro zeile
                lea     iff_countcolor,A2

iff_countnextbyte:
                moveq   #7,D3           ;8 Bits pro Byte
iff_nextbit:    moveq   #0,D4           ;Farbnummer
                moveq   #0,D2
                move.b  iff_planes,D2
                subq.w  #1,D2
                move.w  D2,-(SP)
                mulu    D0,D2
                lea     0(A0,D2.l),A1
                move.w  (SP)+,D2
iff_nextplane:  move.b  (A1),D1
                add.b   D1,D1
                addx.w  D4,D4
                move.b  D1,(A1)
                suba.w  D0,A1
                dbra    D2,iff_nextplane ;NÑchste Plane
                lsl.w   #2,D4           ;Farbnummer * 4
                addq.l  #1,0(A2,D4.l)   ;1 Punkt dieser Farbe mehr
                dbra    D3,iff_nextbit  ;NÑchstes Bit in Byte

                addq.l  #1,A0
                subq.w  #1,D5
                bgt     iff_countnextbyte

                subq.w  #1,(SP)
                bgt     iff_countnextzeile

                addq.l  #2,SP


*               Alle Farben gezÑhlt

*               Konvertiere 16 HÑufigste in Atari-Format

                lea     iff_ataricolor,A0
                lea     iff_colormap,A1
                move.l  #$0E0E0E00,D0
                and.l   (A1),D0
                move.l  D0,(A0)+        ;color 0 konvertiert !
                clr.b   iff_converttab  ;Color 0 zu color 0 konvertieren



*               ZÑhle vorkommende Farben
                moveq   #0,D7
                lea     iff_countcolor+4,A1
                moveq   #30,D0
iff_loop3:      tst.l   (A1)+
                beq.s   iff_nocount1
                addq.l  #1,D7
iff_nocount1:   dbra    D0,iff_loop3



                moveq   #14,D4          ;Maximal 15 Farben
iff_convert1:   tst.w   D7
*               Sind keine Amiga-Farben mehr vorhanden ?
                ble.s   iff_convert1ready
                lea     iff_countcolor+4,A1 ;Color 0 Åberspringen
*               Suche   HÑufigste Farbe
                moveq   #30,D2
                moveq   #4,D1
                moveq   #0,D0           ;Anzahl des vorkommens
iff_search1:    cmp.l   (A1),D0
                bge.s   iff_notf1
                movea.l A1,A2
                move.l  (A1),D0
                move.w  D1,D3           ;Welche Farbe ?
iff_notf1:      addq.w  #4,D1
                lea     4(A1),A1
                dbra    D2,iff_search1
                subq.w  #1,D7           ;Eine Amigafarbe weniger
                clr.l   (A2)            ;Anzahl = 0
*               Konvertieren

                lea     iff_colormap,A1
                adda.w  D3,A1           ;zeigt auf RGB Amigafarbe
                move.l  #$0E0E0E00,D0
                and.l   (A1)+,D0
                lea     iff_ataricolor,A1

iff_colorvorhanden:
                cmp.l   (A1)+,D0
                bne.s   iff_next2
*               Wenn Farbe schon in ataricolor vorhanden, dann
*               noch eine weitere Amigafarbe konvertieren
                suba.l  #iff_ataricolor,A1
                move.l  A1,D0
                lsr.w   #2,D0           ;Atari-Farbnummer
                lea     iff_converttab,A1
                lsr.w   #2,D3           ;Amiga-Farbnummer
                adda.w  D3,A1
                move.b  D0,(A1)
                bra     iff_convert1
iff_next2:
                cmpa.l  A0,A1
                bne.s   iff_colorvorhanden
                move.l  A0,D1
                sub.l   #iff_ataricolor,D1
                lsr.w   #2,D1           ;Atari-Farbnummer
                lea     iff_converttab,A1
                lsr.w   #2,D3           ;Amiga-Farbnummer
                adda.w  D3,A1
                move.b  D1,(A1)
                move.l  D0,(A0)+        ;noch nicht vorhanden

                dbra    D4,iff_convert1
iff_convert1ready:

*               Ataricolor liegt vor
*               A0 zeigt auf Ende der Ataricolor-Tabelle

                pea     (A0)
iff_init_nextcolor:
                subq.l  #4,(SP)
                move.l  (SP),D0
                movea.l D0,A0
                sub.l   #iff_ataricolor,D0
                blt     iff_next4
                lsr.w   #2,D0           ;Farbnummerindex
                moveq   #0,D2
                move.b  (A0),D1
                lsr.b   #1,D1
                move.w  D1,D2
                lsl.w   #4,D2
                move.b  1(A0),D1
                lsr.b   #1,D1
                or.b    D1,D2
                lsl.w   #4,D2
                move.b  2(A0),D1
                lsr.b   #1,D1
                or.b    D1,D2
                lea     hbl_system+2,A0
                add.w   D0,D0
                move.w  D2,0(A0,D0.w)   ;Farbwert abspeichern
                bra     iff_init_nextcolor
iff_next4:      addq.l  #4,SP


* Restliche Farben auf vorliegende Farben konvertieren

                lea     iff_countcolor+4,A0
                lea     iff_colormap+4,A1
                moveq   #30,D0

iff_restcolor:  tst.l   (A0)+
                beq.s   iff_next5
                moveq   #100,D3
                lea     iff_ataricolor+4,A2
*               suche Farbe , die am nÑchsten liegt
                moveq   #0,D1
                moveq   #2,D2           ;3 Werte (RBG)
iff_getdiff:    move.b  (A1),D0
                sub.b   (A2)+,D0
                bpl.s   iff_next6
                neg.b   D0
iff_next6:      add.w   D0,D1
                dbra    D2,iff_getdiff
                addq.l  #1,A2
                cmp.w   D3,D1
                bge     iff_next7
                move.w  D1,D3
                move.l  A2,D4
                sub.l   #iff_ataricolor,D4
                lsr.w   #2,D4           ;d4 = gefundene farbnummer
iff_next7:      moveq   #0,D1
                moveq   #2,D2
                cmpa.l  #iff_ataricolor+16*4,A2
                blt     iff_getdiff
                move.l  A1,D2
                sub.l   #iff_colormap,D2
                lsr.w   #2,D2
                lea     iff_converttab,A2
                adda.w  D2,A2
                move.b  D4,(A2)
iff_next5:      lea     4(A1),A1
                dbra    D0,iff_restcolor

* Suche Bodychunk (zum zweitenmal)


                move.l  #'BODY',D0
                bsr     iff_searchchunk



* Konvertiere einzelne Punkte



                move.l  D0,D7           ;LÑnge der Bodystruktur

                move.w  #200,D0
                cmp.w   iff_hoehe,D0    ;Originalhîhe kleiner als 200 ?
                ble     iff_normal1
                move.w  iff_hoehe,D0
iff_normal1:
                move.w  D0,-(SP)        ;Anzahl zeilen zum konvertieren

iff_convertzeile:
                bsr     iff_lade_zeile
*               A0 = Zeiger auf Zeilenbeginn

                move.w  iff_breite,D0
                addq.w  #7,D0
                lsr.w   #3,D0
                move.w  D0,D5           ;Anzahl Bytes pro zeile
                lea     iff_converttab,A2

                movea.l 2(SP),A3
                addi.l  #160,2(SP)

iff_convnextbyte:
                moveq   #7,D3           ;8 Bits pro Byte
iff_nextbit1:   moveq   #0,D4           ;Farbnummer
                moveq   #0,D2
                move.b  iff_planes,D2
                subq.w  #1,D2
                move.w  D2,-(SP)
                mulu    D0,D2
                lea     0(A0,D2.l),A1
                move.w  (SP)+,D2
iff_getnumber:  move.b  (A1),D1
                add.b   D1,D1
                addx.w  D4,D4
                move.b  D1,(A1)
                suba.w  D0,A1
                dbra    D2,iff_getnumber ;NÑchste Plane
                move.b  0(A2,D4.l),D4   ;1 Punkt konvertieren

                move.b  (A3),D2
                lsr.b   #1,D4
                addx.b  D2,D2
                move.b  D2,(A3)
                move.b  2(A3),D2
                lsr.b   #1,D4
                addx.b  D2,D2
                move.b  D2,2(A3)
                move.b  4(A3),D2
                lsr.b   #1,D4
                addx.b  D2,D2
                move.b  D2,4(A3)
                move.b  6(A3),D2
                lsr.b   #1,D4
                addx.b  D2,D2
                move.b  D2,6(A3)
                dbra    D3,iff_nextbit1 ;NÑchstes Bit in Byte
                addq.l  #1,A3
                move.l  A3,D3
                btst    #0,D3
                bne.s   iff_nnextplane
                addq.l  #6,A3
iff_nnextplane: addq.l  #1,A0
                cmpa.l  2(SP),A3
                beq.s   iff_nextzeile1
                subq.w  #1,D5
                bgt     iff_convnextbyte
iff_nextzeile1:
                move.w  (SP),D0
                subq.w  #1,(SP)
                bgt     iff_convertzeile
                addq.l  #2,SP

                moveq   #iff_allok,D0
                movea.l A6,SP
                rts


* D7 = Verbleibende LÑnge               des Bodystruktur
* A0 = Zeigt auf geladene (entpackte) Zeile

iff_lade_zeile: moveq   #0,D0
                move.b  iff_planes,D0
                add.b   iff_mask,D0
                move.w  iff_breite,D1
                addq.w  #7,D1
                lsr.w   #3,D1           ;Anzahl Bytes pro zeile
                mulu    D1,D0


* d0 = Anzahl der Bytes fÅr alle Planes
                move.l  D0,D5
                movea.l scr2,A0
                bsr     iff_read

                cmp.l   D0,D7           ;Ist Fehler beim laden aufgetreten ?
                beq.s   iff_rest
                cmp.l   D0,D5
                bne.s   iff_ladefehler

iff_rest:

                movea.l scr2,A0
                tst.b   iff_compression ;Compression ?
                beq     iff_nocompression

*               Bild zuerst entpacken
                addq.l  #1,D0
                and.w   #$FFFE,D0       ;Mache d0 gerade
                lea     0(A0,D0.l),A1   ;Erste freie Adresse

                movea.l A1,A2

                moveq   #0,D3
                move.b  iff_planes,D3
                add.b   iff_mask,D3
                move.w  iff_breite,D4
                addq.w  #7,D4
                lsr.w   #3,D4           ;Anzahl Bytes pro zeile
                mulu    D4,D3           ;Anzahl Bytes fÅr alle Planes

iff_entpack:    moveq   #0,D1
                move.b  (A0)+,D1
                bpl.s   iff_comp1
                cmp.b   #$80,D1
                beq.s   iff_next1
                neg.b   D1
                sub.l   D1,D3
                move.b  (A0)+,D2
iff_loop1:      move.b  D2,(A2)+
                dbra    D1,iff_loop1
                bra.s   iff_next1

iff_comp1:      sub.l   D1,D3
iff_loop2:      move.b  (A0)+,(A2)+
                dbra    D1,iff_loop2

iff_next1:      subq.l  #1,D3
                bgt     iff_entpack

                suba.l  scr2,A0
                sub.l   A0,D5
                sub.l   A0,D7
                move.l  D5,D0
                moveq   #1,D1           ;Offset relativ
                neg.l   D0
                bsr     iff_seek

                movea.l A1,A0

iff_nocompression:
*               zurÅck
                rts




* Setzt Flag fÅr Ladefehler und kehrt zurÅck zur aufruf. Routine

iff_ladefehler: moveq   #iff_readerror,D0
                movea.l A6,SP           ;Stack korrigieren
                rts

* Setzt Flag fÅr ' kein  IFF Format ' und kehrt zurÅck zur  aufruf. Routine

iff_keinifformat:moveq  #iff_noiff,D0
                movea.l A6,SP           ;Stack korrigieren
                rts


* d0 = Eingabe Chunk-Name

* Funktion: Positioniert File-Zeiger auf erstes Byte in Chunk
*           d0 = RÅckgabe der ChunklÑnge

iff_searchchunk:
                move.l  D0,-(SP)        ;Sichere Chunkname
                moveq   #12,D0
                moveq   #0,D1
                bsr     iff_seek        ;Positioniere Filepos auf 12tes Byte
                cmp.l   #12,D0
                bne     iff_ladefehler

iff_testchunk:  moveq   #8,D0
                suba.l  D0,SP           ;reserviere 8 bytes
                movea.l SP,A0
                bsr     iff_read        ;Lese 8 Bytes
                movem.l (SP)+,D1-D2
                cmp.l   #8,D0
                bne     iff_ladefehler
                cmp.l   (SP),D1
                beq     iff_chunkgefunden

* Suche nach nÑchstem Chunk
                move.l  D2,D0
                moveq   #1,D1
                bsr     iff_seek        ;Bewege Filepos zu nÑchsten Chunk
                tst.l   D0
                ble     iff_ladefehler
                bra     iff_testchunk

* Chunk ist gefunden

iff_chunkgefunden:

                addq.l  #4,SP           ;Chunkname von Stack
                move.l  D2,D0           ;Chunk LÑnge
                rts

* d0 = Eingabe absolute Fileposition oder Offset
* d1 = Eingabe  (0 => Position Absolut ) (1 => Position relativ)

* d0 = RÅckgabe der absoluten Position des Filepointers ( d0 >= 0)
*      oder Fehler ( d0 < 0)

iff_seek:       move.w  D1,-(SP)        ;Relativ oder Absolut ?
                move.w  D6,-(SP)        ;Filehandle
                move.l  D0,-(SP)        ;Fileposition Abs. oder Offset
                move.w  #$0042,-(SP)    ;Seek
                trap    #1
                lea     10(SP),SP
                rts




* a0 = Einbgabe pufferstartadresse
* d0 = Eingabe Anzahl der zu lesenden Bytes

* d0 = RÅckgabe der Anzahl gelesener Bytes

iff_read:       pea     (A0)            ;Bytepuffer
                move.l  D0,-(SP)        ;Anzahl Bytes
                move.w  D6,-(SP)        ;handle
                move.w  #$003F,-(SP)    ;Read
                trap    #1
                lea     12(SP),SP
                rts

                        ENDPART

                        >PART 'Load Degas'
load_pkd_degas: moveq   #2,D1           ;ab jetzt gepackte Degas_pics
                jsr     change_load_typ ;und merken
                cmpi.w  #$8000,bytes_4  ;Header ok?
                bne     wrong_format    ;Nein, raus

                bsr     clear_rasters   ;Alle Raster weg bitte

                bsr.s   load_degas_pal  ;und die Palette holen

                movea.l scr2,A0
                movem.l 4(A0),D0-D7
                movem.l D0-D7,hbl_system+2 ;und in VBL-Palette speichern
                bsr     palette_changed ;wurde verÑndert

                movea.l scr2,A6         ;hier wird hingeladen!
                move.l  #32000+7424,D6  ;max. laden
                jsr     read            ;und gib's dir
                beq     ende_load       ;Noch lÑnger->Quit

                movea.l scr2,A0         ;Hier stehen die Daten
                movea.l scr1,A1         ;und hier kommen sie hin
                bsr     entpack_pic     ;Bild entpacken
                bra     ende_load       ;und ende

load_degas:     moveq   #1,D1           ;Neuen Ladetyp merken
                jsr     change_load_typ

                tst.w   bytes_4         ;Erste 2 Byte mÅssen 0 sein!
                bne     wrong_format

                bsr.s   load_degas_pal  ;Palette des Degas-Bildes laden
                cmp.l   D6,D0           ;alle Bytes angekommen?
                bne     wrong_format
                bra.s   load_img        ;lade den Rest

;LÑdt Palette eines Degas-Bildes:
load_degas_pal: movea.l scr2,A0         ;Hier Degas-Bild laden
                moveq   #31,D0          ;128 Bytes lîschen
clr_loop:       clr.l   (A0)+
                dbra    D0,clr_loop

                movea.l rotate_buffer,A6
                moveq   #2,D6
                jsr     read            ;Header Åberlesen

                movea.l scr2,A6
                addq.l  #4,A6           ;hier hin kommt Palette
                moveq   #32,D6          ;32 Bytes
                jmp     read
                        ENDPART

load_neo_img:   moveq   #0,D1           ;ab jetzt Neochrom!
                jsr     change_load_typ

                movea.l scr2,A6         ;hier hin laden
                move.l  #128,D6         ;128 Bytes
                jsr     read
                cmp.l   D6,D0           ;Alle Bytes da?
                bne     wrong_format

load_img:       lea     lade_adresse,A0
                movea.l scr2,A1
                tst.w   (A1)
                bne     wrong_format    ;4 Byte Null am Start
                tst.w   2(A1)
                bne     wrong_format
                bsr     rette_palette
                moveq   #31,D0
L000F:          move.l  (A1)+,(A0)+     ;Alle 128 Bytes Åbertragen!
                dbra    D0,L000F

                clr.w   L0756
                clr.w   L0755
                move.w  L0754,D0
                bpl.s   L0011
                move.w  D0,D1
                andi.w  #$000F,D1
                move.w  D1,right_col_mark
                lsr.w   #4,D0
                andi.w  #$000F,D0
                move.w  D0,left_col_mark

L0011:          lea     palette,A0
                tst.w   ste_machine     ;Arbeitet hier ein STE?
                bne.s   no_con3
                tst.w   ste_support     ;STE-Support?
                beq.s   no_con3         ;ja, okay
                jsr     convert2st
no_con3:        lea     hbl_system+2,A1 ;als vbl-palette
                moveq   #15,D0          ;16 Farben Åbertragen
oo:             move.w  (A0)+,(A1)+
                dbra    D0,oo

                bsr     clear_rasters   ;Jetzt sind die Raster aus

;                tst.w   no_pic_load     ;Wurde kein Bild geladen?
;                beq.s   L0012           ;ja, Abbruch
                bsr     Hm              ;Sonst anzeigen
                move.l  scr1,-(SP)
                move.l  #$00007D00,-(SP)
                move.w  fhandle,-(SP)   ;Bild laden
                move.w  #$003F,-(SP)
                trap    #1
                lea     12(SP),SP
;                tst.l   D0
;                bmi.s   wrong_format
;                cmpi.w  #$7D00,D0
;                bne.s   wrong_format   ;Bilder laden, die kÅrzer sind...(evtl. Readerror)

ende_load:      jsr     fclose

                movea.l komplettbild,A0
                movea.l scr1,A1         ;und in komplettbild kopieren
                move.w  #1999,D0
L0013:          move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                dbra    D0,L0013

                moveq   #0,D0           ;ok
load_back:      movem.l (SP)+,D1-A6
                rts

wrong_format:   jsr     fclose
                moveq   #-2,D0          ;Fehlercode 2
                bra.s   load_back       ;und zurÅck

abbruch:        bsr     Hm
                bsr     switch2neo
                move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                lea     fun_init(PC),A0
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0   ;Funktion reaktivieren
                jsr     (A0)
                bsr     get_maus
                move.b  #-$80,L07A1
                bra     endboard

;Schaltet log. Bildschirm auf Border von scr1 (CHS)
into_border:    movem.l D0-A6,-(SP)

                bsr     Hm              ;Maus aus

                lea     32000.w,A0
set_screen:     adda.l  scr1,A0
                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                pea     -1.w            ;Phys. Bildschirm beibehalten
                pea     (A0)
                move.w  #5,-(SP)
                trap    #14
                lea     12(SP),SP

                movem.l (SP)+,D0-A6
                rts

;Setzt log. Bildschirm auf scr1 (CHS)
into_screen:    movem.l D0-A6,-(SP)

                suba.l  A0,A0           ;A0 lîschen
                bra.s   set_screen      ;und auf scr1 setzen

;Schaltet die beiden Bildschirme um (CHS)
switch_screens: movea.l scr2,A0
                move.l  scr1,scr2       ;auf Scr2 aufbauen
                move.l  A0,scr1
                move.w  #-1,-(SP)       ;Scr1 darstellen
                pea     (A0)
                pea     (A0)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP
                rts

cutter_init:    bsr     put_work_back   ;Arbeit sichern

copybox_init:   clr.b   no_resize
                move.b  #-1,rotate_gefÅllt ;Rotierbuffer ist leer!

                move.l  komplettbild,objekt_pointer ;Hier wird hinkopiert
                move.w  #160,breite_bytes ;So breit ist irgendetwas (?)
                clr.b   fun_key         ;Keine Taste ist gedrÅckt
                rts

cutter_exit:    btst    #0,copy_status  ;Noch was selektiert?
                beq.s   l1              ;Nein, weiter
                clr.b   copy_status     ;Jetzt nicht mehr
                bsr     delete_cut_rahm ;Rahmen weg machen!
                jsr     on_off_cutter
l1:             rts

copybox_exit:   btst    #0,copy_status  ;noch was selektiert?
                beq.s   L01CE           ;Nein, weiter
                clr.b   copy_status     ;->wegmachen
                jsr     on_off_buttons  ;Buttons entsprechend schalten
                bsr     L0207           ;ZurÅckschreibroutine
L01CE:          rts

;Falls mehr als 70 Raster zu sehen sind, wird mit dieser Routine die Raster
;abgeschaltet, um mehr Rechenleistung bei rechenintensiven Prozeduren zu haben
raster_ggf_aus: cmpi.w  #70,raster_count ;mehr als 70 Raster?
                ble.s   alles_ok

                move.l  D0,-(SP)

                moveq   #100,D0
                bset    #15,D0          ;Board_y
                tst.w   board_da        ;Ist das Board da?
                beq.s   set_y2

                move.w  #198,D0
                bset    #15,D0
                bset    #14,D0
                tst.b   magnify         ;Ist Lupe da?
                beq.s   set_y2

                move.w  #220,D0         ;Sonst kein HBL
set_y2:         move.w  D0,vbl_raster   ;merken

                move.l  (SP)+,D0
                clr.b   raster_aus      ;Raster bitte abschalten
alles_ok:       rts

;Hiermit kînnen die Raster wieder eingeschaltet werden.
raster_ggf_an:  tst.b   raster_aus      ;Sind die Raster aus?
                bne.s   alles_ok2
                move.b  #1,raster_aus   ;Dann wieder anschalten
alles_ok2:      rts

;Routine zum Auswerten der Klicks in Workscreen (CHS):
do_raster:      movem.l D0-A6,-(SP)

                move.w  D2,D5
                and.w   #%0000000000001100,D5 ;Wurde links oder rechts neu geklickt?
                beq.s   raus_hier23

                tst.w   rst_akt         ;VBL-Palette?
                beq.s   raus_hier23     ;Ja, kann nicht gesetzt werden...

                movem.l D0-A6,-(SP)
                moveq   #3,D1
                jsr     chg_save_typ    ;auf IFF schalten
                movem.l (SP)+,D0-A6

                bsr     rst12rst2       ;rasters1 -> Rasters2

                move.w  D1,D7           ;Y-Wert
                tst.w   board_da
                bne.s   no_brd          ;Nein
                add.w   grab_y,D7       ;Sonst + grab_y
no_brd:         btst    #3,D5           ;Rechts neu geklickt?
                bne.s   paletten_setzen

                lea     hbl_system,A0
                move.w  rst_akt,D5
                mulu    #34,D5
                adda.l  D5,A0
                move.w  D7,(A0)         ;Der Raster steht jetzt hier

raster_end:     bsr     neue_raster     ;und die neuen Raster anzeigen
                tst.w   blitter_an      ;Ist der Blitter an?
                bne.s   raus_hier23     ;Nein,Weiter
                bsr     blitter_off     ;->Ausschalten
raus_hier23:    movem.l (SP)+,D0-A6
                rts

;NEOchrome setzt eine ganze Reihe von Rastern...
paletten_setzen:lea     hbl_system,A0
                move.w  rst_akt,D5
                mulu    #34,D5
                adda.l  D5,A0
                lea     34(A0),A2       ;Ende der Raster

                moveq   #0,D6           ;Counter fÅr Anzahl der Paletten

such_raster:    addq.w  #1,D6           ;Einen Raster mehr
                lea     -34(A0),A0      ;Einen Raster zurÅckgehen
                cmpa.l  #hbl_system,A0  ;Schon beim VBL?
                ble.s   vbl_found
                tst.w   (A0)            ;Raster noch unbenutzt?
                beq.s   such_raster

vbl_found:      cmp.w   (A0),D7         ;Letzter Raster Åber jetzigem?
                ble.s   raus_hier23     ;Nein

                move.w  D7,D5           ;Position des letzten Rasters

                move.w  (A0),D0         ;Position des alten Rasters
                sub.w   D0,D5           ;-Position des neuen=Anzahl Scanlines
                mulu    #100,D5         ;Festkomma
                divu    D6,D5

                lea     34(A0),A1       ;zum nÑchsten Raster gehen
                move.w  (A0),D0         ;Alte Rasterposition
                mulu    #100,D0         ;Festkomma

setz_raster:    cmpa.l  A2,A1           ;Ende der Raster erreicht?
                bge.s   ende_jetzt      ;ja
                add.w   D5,D0           ;+Offset zum nÑchsten Raster
                move.w  D0,D1
                ext.l   D1
                divu    #100,D1         ;Festkomma zurÅck
                move.w  D1,(A1)+        ;Rasterposition eintragen
                moveq   #7,D1           ;Palette Åbertragen
                lea     2(A0),A3
copy_pal2:      move.l  (A3)+,(A1)+
                dbra    D1,copy_pal2
                bra.s   setz_raster

ende_jetzt:     move.w  D7,-34(A1)      ;Letzten Raster auf Mausposition
                bsr     blitz
                bra     raster_end

;Diese Funktion setzt einen Raster ins Rastersystem. Dabei wird ein zuerst ein
;Eintrag gesucht, der denselben Offset hat. Dieser wird dann ersetzt. Ansonsten
;wird hinten ein neuer Offset angehÑngt. Gibt im Z-Flag den Erfolg zurÅck.
; A0.L: Pointer auf neuen Raster
;  A1.L: Pointer auf Rastersystem
update_raster:  movem.l D0-A6,-(SP)

                bsr.s   freshen_raster  ;Kann ein bereits existierender ersetzt
                beq.s   update_end

                lea     34(A1),A1       ;VBL-Raster Åberspringen
                move.w  #anz_raster-2,D7
such_frei:      tst.w   (A1)            ;Raster frei?
                beq.s   frei
                lea     34(A1),A1
                dbra    D7,such_frei    ;Alle testen
                moveq   #-1,D0          ;nichts mehr frei
                bra.s   update_end

frei:           moveq   #16,D7
frei_loop:      move.w  (A0)+,(A1)+     ;Raster eintragen
                dbra    D7,frei_loop

                moveq   #0,D0           ;okay, eingetragen
update_end:     movem.l (SP)+,D0-A6
                rts

;Versucht Raster in Rastersystem zu ersetzen. Ist dieser Raster nicht vorhanden,
;wird abgebrochen. Erfolg im Z-Flag.
; A0.L: Neuer Raster
;  A1.L: Rastersystem
freshen_raster: movem.l D0-A6,-(SP)

                move.w  (A0),D6         ;VBL-Raster
                beq.s   gefunden        ;ja, eintragen

                lea     34(A1),A1       ;VBL-Raster Åberspringen
                move.w  #anz_raster-2,D7
such_diesen:    cmp.w   (A1),D6         ;Ist es dieser Raster?
                beq.s   gefunden
                lea     34(A1),A1
                dbra    D7,such_diesen
                moveq   #-1,D0          ;Error
                bra.s   freshen_end

gefunden:       moveq   #16,D7
gef_loop:       move.w  (A0)+,(A1)+
                dbra    D7,gef_loop

                moveq   #0,D0
freshen_end:    movem.l (SP)+,D0-A6
                rts


;Sortiert die Raster nach Benutzung
; A0.L: Adresse der Rastertabelle
sort_raster:    movem.l D0-A6,-(SP)

                bsr     raster_ggf_aus

                lea     rasters2,A2     ;hier aufbauen

                moveq   #-1,D6          ;bisher kleinster Raster
such_them:      move.w  #1000,D5        ;bisher grîûter Raster

                move.w  #anz_raster-1,D7
                movea.l A0,A1
such_raster2:   move.w  (A1),D0         ;Position holen
                cmp.w   D6,D0
                ble.s   such_nÑchsten
                cmp.w   D5,D0
                bge.s   such_nÑchsten
                move.w  D0,D5
                movea.l A1,A3           ;Position merken
such_nÑchsten:  lea     34(A1),A1
                dbra    D7,such_raster2

                cmp.w   #1000,D5        ;Noch ein Raster vorhanden?
                beq.s   keiner_mehr

                moveq   #16,D7          ;17 Worte
copy_loop4:     move.w  (A3)+,(A2)+
                dbra    D7,copy_loop4

                move.w  D5,D6           ;grîûer als der hier
                bra.s   such_them

keiner_mehr:    movea.l A0,A1
                move.w  #anz_raster-1,D7
clear_them:     clr.w   (A1)            ;Altes Rastersystem lîschen
                lea     34(A1),A1
                dbra    D7,clear_them

                lea     rasters2,A1

copy_worte:     move.w  (A1)+,(A0)+
                cmpa.l  A2,A1
                blt.s   copy_worte

                bsr     raster_ggf_an

                movem.l (SP)+,D0-A6
                rts

;ZÑhlt wieviel Raster im Bild gesetzt sind.
;<- D0.W: Anzahl der Raster
count_rasters:  movem.l D1-A6,-(SP)

                lea     hbl_system,A0
                move.w  #anz_raster-1,D7
                moveq   #1,D0           ;Raster zÑhlen
check_rasters:  tst.w   (A0)
                beq.s   keiner
                addq.w  #1,D0           ;Ein Raster mehr
keiner:         lea     34(A0),A0
                dbra    D7,check_rasters

                movem.l (SP)+,D1-A6
                rts

;Berechnet die Offsets innerhalb des HBL-System2 neu (CHS):
;Gibt in D0 zurÅck, ob Raster wieder an sind.
calc_offsets:   movem.l D1-A6,-(SP)

                bsr     raster_ggf_aus

                clr.w   first_pal       ;es wird jetzt die erste Raster berechnet
                clr.w   raster_count

                lea     lupen_pal,A3    ;Tabelle der Lupenpaletten

;VBL-Tabelle suchen:
                moveq   #1,D7           ;Y-Wert
                tst.w   board_da
                bne.s   such_nx_raster
                add.w   grab_y,D7
such_nx_raster: moveq   #-1,D6          ;Min-Wert
                move.w  #anz_raster-1,D5 ;Anzahl der zu untersuchenden Raster
                lea     hbl_system,A0   ;Tabelle der Rasters
such_max:       move.w  (A0),D0         ;Y-Position dieses Rasters
                beq.s   nx_raster       ;unbenutzt->nÑchsten
                cmp.w   D6,D0           ;Dieser Raster weiter unten?
                blt.s   nx_raster       ;Nein->nÑchsten
                cmp.w   D7,D0           ;weiter oben als letzter Raster?
                bgt.s   nx_raster       ;Nein->nÑchsten
                lea     2(A0),A1        ;Position der Palette merken
                move.w  D0,D6           ;als neuen Kleinsten nehmen
nx_raster:      lea     34(A0),A0       ;nÑchsten Raster nehmen
                dbra    D5,such_max

                cmp.w   #-1,D6          ;ein Raster gefunden?
                bne.s   found_one       ;ja, weiter
                lea     hbl_system+2,A1 ;Sonst VBL-Palette nehmen
found_one:      move.l  A1,D7           ;Adresse der Farbpalette
                sub.l   #hbl_system+2,D7 ;=Offset
                divu    #34,D7          ;=Nummer der Palette
                move.w  D7,pal_nr       ;und merken

                movem.l (A1),D0-D7      ;Palette holen
                lea     rasters2,A2
                movem.l D0-D7,2(A2)     ;und VBL-Palette eintragen
                lea     34(A2),A2       ;und zum 1. Raster gehen

                moveq   #1,D7           ;Y-Wert
                tst.w   board_da
                bne.s   such_nxt_raster
                add.w   grab_y,D7
such_nxt_raster:move.w  #1000,D6        ;Max-Wert
                move.w  #anz_raster-1,D5 ;Anzahl der zu untersuchenden Raster
                lea     hbl_system,A0   ;Tabelle der Rasters
such_min:       move.w  (A0),D0         ;Y-Position dieses Rasters
                beq.s   nxt_raster      ;unbenutzt->nÑchsten
                cmp.w   D6,D0           ;Dieser Raster weiter oben?
                bge.s   nxt_raster      ;Nein->nÑchsten
                cmp.w   D7,D0           ;weiter unten als letzter Raster?
                ble.s   nxt_raster      ;Nein->nÑchsten
                lea     2(A0),A1        ;Position der Palette merken
                move.w  D0,D6           ;als neuen Kleinsten nehmen
nxt_raster:     lea     34(A0),A0       ;nÑchsten Raster nehmen
                dbra    D5,such_min

                cmp.w   #1000,D6        ;Alle Raster gesetzt?
                beq.s   fertig

                move.l  A1,D1
                sub.l   #hbl_system+2,D1
                divu    #34,D1          ;=Nummer der Palette
                move.w  D1,-(SP)        ;merken

                addq.w  #1,raster_count ;Ein Raster mehr im Bild

                move.w  D6,D1           ;Position der aktuellen Rasters
                sub.w   D7,D1           ;-letzte Position=Offset
                move.w  D1,-34(A2)      ;Beim letzten Raster als Offset eintragen
                tst.w   first_pal       ;Ist es der 1. Raster?
                bne.s   in_loop237      ;Nein, eintragen
                addq.w  #1,D1           ;Sonst eins tiefer
                move.w  #-1,first_pal   ;Jetzt nichtmehr die 1. Raster
                bra.s   in_loop237
loop23:         move.w  pal_nr,(A3)+    ;Alte Palette eintragen
in_loop237:     dbra    D1,loop23

                move.w  (SP)+,pal_nr    ;und neue Palettennr merken

                addq.w  #2,A2           ;und diesen Offset Åberspringen
                moveq   #15,D1
copy2367:       move.w  (A1)+,(A2)+     ;Farbpalette Åbertragen
                dbra    D1,copy2367

                move.w  D6,D7           ;Position des aktiven Rasters->letzter
                bra.s   such_nxt_raster

fertig:         lea     lupen_pal+220*2,A4 ;Ende der Tabelle
fertig_loop:    cmpa.l  A4,A3           ;alles eingetragen?
                bge.s   fertig2
                move.w  pal_nr,(A3)+    ;Alte Palettennummer bis Ende eintragen
                bra.s   fertig_loop

fertig2:        move.w  #220,-34(A2)    ;und irgendwas
                addq.l  #2,A2
                move.w  (A2),D0
                not.w   D0
                move.w  D0,30(A2)       ;und als Zeichenfarbe

                moveq   #-1,D0          ;Raster sind aus
                cmpi.w  #220,rasters2   ;Sind Åberhaupt Raster da?
                beq.s   no_rasterda     ;Nein->Raus
                moveq   #0,D0           ;Es sind Raster da...

                tst.w   board_da
                bne.s   rand_suchen     ;Nein, dann Position zum Randaufklappen

                lea     rasters2,A0     ;und Board-HBL einklemmen
                moveq   #1,D7           ;Startwert Y=1
such_board:     move.w  (A0),D1         ;nÑchster Offset
                add.w   D1,D7           ;=Y des Rasters
                cmp.w   #100,D7         ;Schon unterhalb von 100?
                bge.s   zu_weit         ;Ja, Letzten Raster stutzen
                lea     34(A0),A0       ;und nÑchsten Raster testen
                bra.s   such_board

zu_weit:        sub.w   D1,D7           ;letzten Offset wieder abziehen
                moveq   #100,D1
                sub.w   D7,D1           ;von 100 abziehen
set_y:          bset    #15,D1          ;und 'negativ' machen
eintragen:      move.w  D1,(A0)         ;und eintragen

rrr:            bsr     raster_ggf_an
                movem.l (SP)+,D1-A6
                rts

no_rasterda:    lea     rasters2,A0
                moveq   #99,D1          ;volle 100 nehmen
                tst.w   board_da
                beq.s   set_y
                move.w  #199,D1         ;220 Kein Board da...
                bset    #14,D1          ;Rand-Flag setzen
                tst.b   magnify         ;Lupe da?
                beq.s   set_y           ;Nein, also setzen
                move.w  #220,D1
                bra.s   set_y

rand_suchen:    move.w  #220,D1         ;kein Raster mehr
                tst.b   magnify         ;Lupe im Rand Åberhaupt da?
                bne.s   eintragen

                lea     rasters2,A0     ;und Board-HBL einklemmen
                moveq   #1,D7           ;Startwert Y=1
such_rand:      move.w  (A0),D1         ;nÑchster Offset
                add.w   D1,D7           ;=Y des Rasters
                cmp.w   #200,D7         ;Schon unterhalb von 199?
                bge.s   zu_weit_unten   ;Ja, Letzten Raster stutzen
                lea     34(A0),A0       ;und nÑchsten Raster testen
                bra.s   such_rand

zu_weit_unten:  sub.w   D1,D7           ;letzten Offset wieder abziehen
                move.w  #200,D1
                sub.w   D7,D1           ;von 100 abziehen
                bset    #14,D1          ;und Randflag setzen
                bra.s   set_y           ;und rein damit

;Kopiert Rasters1 -> Rasters2 (CHS):
rst12rst2:      movem.l D0-A6,-(SP)
                lea     rasters1,A0     ;Raster1->Rasters2
                lea     rasters2,A1
                bra.s   copy_them

;Kopiert Rasters2 -> Rasters1 (CHS):
rst22rst1:      movem.l D0-A6,-(SP)
                lea     rasters2,A0     ;Rasters2->Rasters1
                lea     rasters1,A1
copy_them:      move.w  #anz_raster-1,D6 ;max .Anzahl der Raster
copy_raster:    moveq   #16,D7          ;17 Worte Åbertragen
copy_pal:       move.w  (A0)+,(A1)+
                dbra    D7,copy_pal
                dbra    D6,copy_raster
                movem.l (SP)+,D0-A6
                rts

;Das Optionsboard der Rasterroutine bedienen (CHS):
raster_opt:     movem.l D0-A6,-(SP)     ;Register sichern

rast_opt_again: move.w  D2,D7
                and.w   #%0000000000000011,D7 ;Links oder rechts neu gedrÅckt?
                beq     end_rast_opt    ;nein, weiter

                move.w  #270,D3
                move.w  #150,D4
                move.w  #313,D5         ;Load?
                move.w  #158,D6
                jsr     maus_in
                bne.s   no_load3

                lea     picture_neo,A0
                lea     picture_neu,A1
copy673:        move.b  (A0)+,(A1)+     ;Filenamen duplizieren
                bne.s   copy673

                lea     load_path,A0
                lea     scroll_save,A1
copy674:        move.b  (A0)+,(A1)+     ;und Pfad duplizieren
                bne.s   copy674

                lea     scroll_save,A0
                moveq   #9,D1           ;*.RST
                jsr     change_path     ;Als Extension anhÑngen
                lea     picture_neu,A1
                jsr     change_file     ;Und an Filenamen anhÑngen
                lea     rst_lext,A2
                moveq   #0,D0           ;Laden
                jsr     fileselect
                bne.s   no_352          ;und ganz raus hier

                bsr     load_raster     ;Rasterfile laden
no_352:         bsr     screen2neo
                bsr     palette_changed
                bra     end_rast_opt

no_load3:       move.w  #158,D4
                move.w  #166,D6         ;Save?
                jsr     maus_in
                bne.s   no_load_save2

                lea     picture_neo,A0
                lea     picture_neu,A1
copy6732:       move.b  (A0)+,(A1)+     ;Filenamen duplizieren
                bne.s   copy6732

                lea     save_path,A0
                lea     scroll_save,A1
copy6742:       move.b  (A0)+,(A1)+     ;und Pfad duplizieren
                bne.s   copy6742

                lea     scroll_save,A0
                moveq   #9,D1           ;*.RST
                jsr     change_path     ;Als Extension anhÑngen
                lea     picture_neu,A1
                jsr     change_file     ;Und an Filenamen anhÑngen
                lea     rst_sext,A2
                btst    #2,D2           ;Links gedrÅckt?
                bne.s   normal3
                lea     rst_used_sext,A2
normal3:        moveq   #1,D0           ;Speichern
                jsr     fileselect
                bne.s   no342           ;und ganz raus hier

                btst    #2,D2           ;Links gedrÅckt?
                bne.s   normal4
                bsr     save_used_raster
                bra.s   no342
normal4:        bsr     save_raster     ;und abspeichern
no342:          bsr     screen2neo
                bra     end_rast_opt

no_load_save2:  move.w  #165,D4
                move.w  #173,D6         ;Get?
                jsr     maus_in
                bne.s   no_get

                jsr     inv_btn_back

                lea     hbl_system,A1
                lea     hbl_put_get,A0
                move.w  #anz_raster-1,D7
copy_rst2:      moveq   #16,D6          ;17 Worte pro Rastereintrag
copy_rst:       move.w  (A0)+,(A1)+
                dbra    D6,copy_rst
                dbra    D7,copy_rst2

                btst    #2,D2           ;Links gedrÅckt?
                bne.s   normal1

                lea     hbl_system,A0
                bsr     sort_raster

normal1:        bsr     palette_changed
                bsr     wait_los        ;und loslassen bitte

no_get:         move.w  #173,D4
                move.w  #181,D6         ;Put?
                jsr     maus_in
                bne.s   no_put

                jsr     inv_btn_back

                lea     hbl_system,A0
                lea     hbl_put_get,A1
                move.w  #anz_raster-1,D7
copy_rst4:      moveq   #16,D6          ;17 Worte pro Rastereintrag
copy_rst3:      move.w  (A0)+,(A1)+
                dbra    D6,copy_rst3
                dbra    D7,copy_rst4

                btst    #2,D2           ;Links gedrÅckt?
                bne.s   normal2

                lea     hbl_put_get,A0
                bsr     sort_raster

normal2:        bsr     wait_los        ;und loslassen bitte
                bra     end_rast_opt

no_put:         move.w  #189,D4
                move.w  #197,D6         ;Load Spektrum Pal?
                jsr     maus_in
                bne.s   no_ld_pal

                lea     picture_neo,A0
                lea     picture_neu,A1
copy672:        move.b  (A0)+,(A1)+     ;Filenamen duplizieren
                bne.s   copy672

                lea     load_path,A0
                lea     scroll_save,A1
copy675:        move.b  (A0)+,(A1)+     ;und Pfad duplizieren
                bne.s   copy675

                lea     scroll_save,A0
                moveq   #10,D1          ;*.PAL
                jsr     change_path     ;Als Extension anhÑngen
                lea     picture_neu,A1
                jsr     change_file     ;Und an Filenamen anhÑngen
                lea     pal_lext,A2
                moveq   #0,D0           ;Laden
                jsr     fileselect
                bne.s   no_353          ;und ganz raus hier

                bsr     load_pal        ;Rasterpalette laden
no_353:         bsr     screen2neo
                bsr     palette_changed
                bra.s   end_rast_opt

no_ld_pal:      move.w  #181,D4
                move.w  #189,D6         ;Clear?
                jsr     maus_in
                bne.s   no_clear

                move.l  #sure_new2,D0   ;Sicher alles lîschen?
                bsr     switch_alert
                cmpi.w  #2,int_out      ;Okay?
                bne.s   no_clear        ;Nein->Raus

                bsr     clear_rasters   ;Alle Raster weglîschen

no_clear:       lea     raster_buttons,A0
                jsr     check_button    ;In welches Rechteck wurde geklickt?
                tst.w   D7              ;Rechteck gefunden?
                bmi.s   end_rast_opt    ;Nein, weiter

                jsr     inv_button      ;Knopf invertieren

                lsl.w   #2,D7           ;mal 4
                lea     raster_tabelle(PC),A0
                movea.l 0(A0,D7.w),A0   ;Sprungvektor der Funktion
                moveq   #-1,D7          ;Nachher nichts machen
                movem.w D3-D6,-(SP)     ;Koordinaten des Buttons retten
                jsr     (A0)
                movem.w (SP)+,D3-D6     ;Koordinaten wieder holen
                jsr     inv_button      ;und zurÅckinvertieren

                tst.w   D7              ;Nachher was machen?
                bmi.s   end_rast_opt    ;Nein->Weiter

                lsl.w   #2,D7           ;mal 4
                lea     after_raster(PC),A0
                movea.l 0(A0,D7.w),A0
                jsr     (A0)

end_rast_opt:   bsr     get_mouse_pos   ;Maustasten holen
                move.w  int_out,D2
                and.w   #%0000000000000011,D2 ;Mausknopf gedrÅckt?
                beq.s   endlich_raus2   ;nochmal alles auswerten
                bsr     get_maus        ;Mausknîpfe holen
                bra     rast_opt_again  ;und nochmal
endlich_raus2:  movem.l (SP)+,D0-A6
                rts

;Tabelle der verschiedenen Buttons bei Rasteroptions:
raster_tabelle:         DC.L raster_hoch
                        DC.L raster_runter
                        DC.L raster_rechts
                        DC.L raster_links
                        DC.L raster_del
                        DC.L raster_show

;Tabelle der verschiedenen Aktionen, die nach den Buttons ausgefÅhrt werden:
after_raster:           DC.L neue_palette ;Es wurde eine neue Rasterpalette gewÑhlt
                        DC.L neue_raster ;Raster neu berechnen
                        DC.L palette_changed

;Die Palette von Neochrome wurde verÑndert, also alle Farben anpassen
palette_changed:bsr.s   neue_raster
                bra.s   neue_palette

;Berechnet die Rasteroffsets neu und zeigt die Raster an
neue_raster:    movem.l D0-A6,-(SP)

                bsr     calc_offsets    ;und neu ausrechnen
                move.l  #rasters2,rasters ;und neue anzeigen
                bsr     show_width      ;und neue Offsets anzeigen
                bsr     vsync_neo
                bsr     rst22rst1       ;und zurÅck kopieren
                move.l  #rasters1,rasters ;und 1. System wieder anzeigen
                bsr     vsync_neo
                movem.l (SP)+,D0-A6
                rts

;Lîscht die gesamten Raster vom Bildschirm
clear_rasters:  movem.l D7-A0,-(SP)
                lea     hbl_system,A0
                move.w  #anz_raster-1,D7
clear_lp:       clr.w   (A0)
                lea     34(A0),A0
                dbra    D7,clear_lp

                clr.w   rst_akt         ;Jetzt ist Raster #0 aktiv
                bsr.s   palette_changed

                movem.l (SP)+,D7-A0
                rts

;éndert die Farben der Board-palette je nach rst_akt und zeigt rst_akt an
neue_palette:   movem.l D0-A6,-(SP)     ;Wird nachher wieder runtergeholt

                move.w  rst_akt,D1      ;Nummer des aktiven Rasters
                lea     hbl_system+2,A0
                mulu    #34,D1
                adda.l  D1,A0
                movem.l (A0),D0-D7
                movem.l D0-D7,board_palette ;Und Farben merken
                move.w  rst_akt,D1
                lea     raster_nummer,A0
                bsr     wandel_fest_dez3 ;und eintragen
                bsr.s   show_width      ;Neue Breite anzeigen
                cmpi.b  #8,function     ;Ist Raster aktiv?
                bne.s   no_zeichne      ;Nein, nichts zeichnen
                tst.w   board_da
                bne.s   no_zeichne
                tst.b   lupe_an
                beq.s   no_zeichne
                bsr     Hm
                lea     raster_koord,A3
                lea     raster_nummer,A0
                moveq   #1,D7           ;2 Strings neu zeichnen
                jmp     redr2           ;Holt auch Register wieder
no_zeichne:     movem.l (SP)+,D0-A6     ;Register runter
                rts

;Printet ggf. die Grîûe des aktiven Rasters aus (CHS):
show_width:     movem.l D0-A6,-(SP)

                lea     hbl_system,A1
                move.w  rst_akt,D0
                mulu    #34,D0
                adda.l  D0,A1
                lea     raster_width,A0
                tst.w   rst_akt         ;VBL-Palette?
                beq.s   anzeigen        ;Ja, anzeigen
                tst.w   (A1)            ;Ist Palette aktiv?
                bne.s   anzeigen        ;Ja, Wert ausgeben

                moveq   #'X',D0
                move.b  D0,(A0)+
                move.b  D0,(A0)+
                move.b  D0,(A0)+
                addq.l  #1,A0
                move.b  D0,(A0)+
                move.b  D0,(A0)+
                move.b  D0,(A0)+
                bra.s   show_end2

anzeigen:       move.w  (A1),D1         ;Startwert holen
                bsr     wandel_fest_dez3 ;und eintragen
                addq.l  #1,A0           ;'-' Åberspringen
                move.w  (A1),D0         ;Startwert holen
                move.w  #200,D1         ;Max-Wert
                move.w  #anz_raster-1,D7 ;Counter
                lea     hbl_system,A2
nxt_loop:       move.w  (A2),D2         ;aktiven Raster holen
                cmp.w   D0,D2           ;Grîûer als Startwert?
                ble.s   nxt_one         ;Nein, weiter
                cmp.w   D1,D2           ;Kleiner als Max-Wert?
                bge.s   nxt_one
                move.w  D2,D1           ;Dann merken
nxt_one:        lea     34(A2),A2       ;nÑchster Raster
                dbra    D7,nxt_loop

                subq.w  #1,D1
                bsr     wandel_fest_dez3 ;und eintragen

show_end2:      cmpi.b  #8,function     ;Rasterfunction an?
                bne.s   no_show
                tst.w   board_da
                bne.s   no_show
                tst.b   lupe_an
                beq.s   no_show

                bsr     Hm
                lea     raster_widthk,A3
                lea     raster_widthstr,A0
                moveq   #0,D7           ;1 String neu zeichnen
                jmp     redr2           ;Holt auch Register wieder

no_show:        movem.l (SP)+,D0-A6
                rts


raster_hoch:    move.w  rst_akt,D0
                mulu    #34,D0
                lea     hbl_system+2,A0
                adda.l  D0,A0
                movem.l (A0),D0-D7      ;Palette holen
                movem.l D0-D7,raster_palette ;und merken
                moveq   #-1,D7          ;Keine Aktion
                bra     wait_los

raster_runter:  move.w  rst_akt,D0
                mulu    #34,D0
                lea     hbl_system+2,A0
                adda.l  D0,A0
                movem.l raster_palette,D0-D7 ;Palette holen
                movem.l D0-D7,(A0)      ;und setzen
                moveq   #2,D7           ;palette_changed
                bra     wait_los

raster_rechts:  cmpi.w  #anz_raster-1,rst_akt ;Schon bei 99?
                bge.s   no_up
                addq.w  #1,rst_akt      ;Eins hîher
                moveq   #0,D7           ;Nachher neue Rasterpalette
no_up:          rts

raster_links:   tst.w   rst_akt         ;Schon bei Null?
                ble.s   no_down
                subq.w  #1,rst_akt
                moveq   #0,D7           ;Neue Rasterpalette
no_down:        rts

raster_del:     lea     hbl_system,A0
                move.w  rst_akt,D0      ;Atueller Raster
                mulu    #34,D0
                clr.w   0(A0,D0.w)      ;Raster inaktivieren
                moveq   #1,D7           ;Raster neu berechnen
                rts

raster_show:    lea     hbl_system+2,A0
                move.w  rst_akt,D0
                mulu    #34,D0
                adda.l  D0,A0
                move.w  (A0),D0         ;und aktive Farbe merken

                lea     flashtab(PC),A1
nxt_flash:      move.w  (A1)+,(A0)      ;und Farbe setzen
                bmi.s   end_flash
                bsr     neue_raster     ;und anzeigen
                bra.s   nxt_flash

end_flash:      move.w  D0,(A0)         ;Alte Farbe wieder setzen
                moveq   #1,D7           ;und anzeigen
                rts

flashtab:               DC.W $0000,$0111,$0222,$0333,$0444,$0555,$0666,$0777
                        DC.W $0666,$0555,$0444,$0333,$0222,$0111,$0000,-1

;LÑdt eine Rastertabelle nach
load_raster:    jsr     fopen
                bmi.s   derror

                lea     hbl_system,A6
                move.l  #anz_raster*34,D6
                jsr     read

                jsr     fclose
                moveq   #0,D0
                rts

derror:         bsr     switch2tos
                move.l  #filenotfound,D1
                bsr     alert
                moveq   #-1,D0
                rts

;Speichert nur die benÅtzen Raster ab
save_used_raster:jsr    fcreate
                bmi.s   derror2

                bsr.s   save_used       ;Nur die benutzten schreiben
                bne     save_error

                jmp     fclose

save_used:      movem.l D0-A6,-(SP)

                lea     hbl_system,A6
                moveq   #34,D6
                jsr     write           ;VBL-Palette speichern
                bne.s   save_used_end

                move.w  #anz_raster-1,D7
such_raster5:   tst.w   (A6)
                beq.s   no_save3
                jsr     write
                bne.s   save_used_end
no_save3:       lea     34(A6),A6
                dbra    D7,such_raster5

                moveq   #0,D0           ;Alles okay
save_used_end:  movem.l (SP)+,D0-A6
                rts

;Speichert eine Rastertabelle ab
save_raster:    jsr     fcreate
                bmi.s   derror2

                lea     hbl_system,A6
                move.l  #anz_raster*34,D6
                jsr     write
                bne     save_error

                jmp     fclose

derror2:        bsr     switch2tos
                move.l  #save_error_msg,D0
                bra     alert

;LÑdt eine Spektrum.512 Color calculation Tabelle nach
load_pal:       clr.w   -(SP)
                pea     fsel_path
                move.w  #$003D,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                bmi     derror

                movea.l scr2,A6
                move.l  #31000,D6
                jsr     read
                move.b  #-1,0(A6,D0.l)
                move.b  #-1,1(A6,D0.l)  ;Ende Kennung anhÑngen
                move.b  #-1,2(A6,D0.l)

                jsr     fclose

                tst.w   (A6)            ;Åberhaupt Farben da?
                bmi.s   end_ld_pal

                move.w  rst_akt,D0      ;Aktueller Raster
                mulu    #34,D0
                lea     hbl_system,A0
                adda.l  D0,A0
                move.w  (A0),D7         ;Min-Wert holen
                move.w  zeichenfarbe,D0
                add.w   D0,D0
                move.w  (A6)+,2(A0,D0.w)

nxt_color:      tst.w   (A6)            ;Noch Werte in der Tabelle?
                bmi.s   end_ld_pal      ;Nein->Ende

                move.w  #1000,D6
                move.w  #anz_raster-1,D5 ;Anzahl der zu untersuchenden Raster
                lea     hbl_system,A0   ;Tabelle der Rasters
such_max2:      move.w  (A0),D0         ;Y-Position dieses Rasters
                cmp.w   D6,D0           ;Dieser Raster weiter unten?
                bgt.s   nx_raster2      ;Nein->nÑchsten
                cmp.w   D7,D0           ;weiter oben als letzter Raster?
                ble.s   nx_raster2      ;Nein->nÑchsten
                lea     2(A0),A1        ;Position der Palette merken
                move.w  D0,D6           ;als neuen Kleinsten nehmen
nx_raster2:     lea     34(A0),A0       ;nÑchsten Raster nehmen
                dbra    D5,such_max2

                cmp.w   #1000,D6        ;noch einen Raster gefunden?
                beq.s   end_ld_pal      ;Nein->Ende

                move.w  D6,D7           ;als neuen Min-Wert nehmen

                move.w  zeichenfarbe,D0
                add.w   D0,D0           ;mal 2
                move.w  (A6)+,0(A1,D0.w) ;und eintragen
                bra.s   nxt_color

end_ld_pal:     moveq   #0,D0
                rts

                        IF disk_version=1

space:                  DC.B '        ',0

;Gibt Zeichen in Hex aus
hex_out:        movem.l D0-A6,-(SP)

                move.l  D0,-(SP)

                move.w  #3,-(SP)
                trap    #14
                addq.l  #2,SP
                movea.l D0,A6

                move.w  #2,-(SP)
                trap    #14
                addq.l  #2,SP

                move.w  #-1,-(SP)       ;Auflîsung beinehalten
                pea     -1.w
                move.l  D0,-(SP)
                move.w  #5,-(SP)
                trap    #14
                lea     12(SP),SP

                move.l  (SP)+,D0

                moveq   #7,D7           ;8 Stellen
                lea     space(PC),A0
                lea     hex_tab,A1
hex_loop:       rol.l   #4,D0
                move.w  D0,D6
                and.w   #$000F,D6
                move.b  0(A1,D6.w),(A0)+
                dbra    D7,hex_loop
                clr.b   (A0)

                move.w  #26,D0
                move.w  #10,D1
                moveq   #0,D2
                lea     space(PC),A0
                bsr     print6x6        ;und ausgeben

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                pea     -1.w
                move.l  A6,-(SP)
                move.w  #5,-(SP)
                trap    #14
                lea     12(SP),SP

                movem.l (SP)+,D0-A6
                rts

show_d2:        move    SR,-(SP)
                movem.l D0-A6,-(SP)
                move.l  D2,D0
                bsr     hex_out
                tst.w   D0
;                beq     ok
;                bsr     crawcin
ok:             movem.l (SP)+,D0-A6
                rtr

                        ENDC

;Spieler macht Fullscreen, deshalb mÅssen die Koordinaten der ani-box
;angepaût werden:
box_anpass:     movem.l D0-D7,-(SP)

                move.w  grab_y,D0
                add.w   D0,ani_y1
                add.w   D0,ani_y4

                movem.l (SP)+,D0-D7
                rts

;Spieler schaltet Board an, Jetzt muû Grab_y berechnet werden, damit
;Box mîglichst gut zu sehen ist
calc_grab:      movem.l D0-D7,-(SP)

                move.w  ani_y4,D0
                sub.w   ani_y1,D0       ;Hîhe berechnen
                lsr.w   #1,D0           ;/2
                add.w   ani_y1,D0       ;Y-Zeile des Mittelpunktes
                sub.w   #50,D0          ;Workscreen ist 100 Pixel hoch
                bpl.s   ok89
                moveq   #0,D0
ok89:           cmp.w   #100,D0
                ble.s   ok88
                moveq   #100,D0
ok88:           move.w  D0,grab_y

                sub.w   D0,ani_y1
                sub.w   D0,ani_y4

                movem.l (SP)+,D0-D7
                rts

;Tabelle der Routinen die beim DrÅcken der F-Tasten im Cutter angesprungen werden
fun_cutter:             DC.L add_akt_flash ;F1
                        DC.L replace_akt_flash ;F2
                        DC.L show_akt_flash ;F3
                        DC.L pling ;F4
                        DC.L pling ;F5
                        DC.L pling ;F6
                        DC.L pling ;F7
                        DC.L pling ;F8
                        DC.L pling ;F9
                        DC.L recut_flash ;F10

;Die Tastenfunktionen des Cutters mit Flash:

add_akt_flash:  bsr     blitz
                jmp     add_akt_fkey

replace_akt_flash:bsr   blitz
                jmp     replace_akt_fkey

show_akt_flash: bsr     blitz
                jmp     show_akt_fkey

recut_flash:    bsr     blitz
                jmp     recut

;Cutter-Routine im Zeichenfeld:
do_cutter:      tst.b   D2              ;Mausbutton gedrÅckt?
                bne.s   knopf_auswert   ;Ja, auswerten
                tst.b   fun_key         ;Funktionstaste gedrÅckt?
                beq.s   knopf_auswert   ;Nein, Maustasten auswerten
                moveq   #0,D7
                move.b  fun_key,D7      ;Funktionstaste holen
                clr.b   fun_key         ;und weg ist sie
                subq.w  #1,D7           ;eins abziehen!
                lsl.w   #2,D7
                lea     fun_cutter(PC),A0
                movea.l 0(A0,D7.w),A0   ;Funktion holen
                jmp     (A0)

knopf_auswert:  btst    #0,copy_status  ;Schon was selektiert?
                beq.s   maus_unverÑndert ;Nein
                btst    #2,copy_status  ;wird gerade verschoben?
                bne.s   maus_unverÑndert ;ja
                bsr     check_in_box    ;Ist Maus innerhalb Box?
                bne.s   maus_auûerhalb  ;Nein
                bset    #3,copy_status  ;Maus innerhalb Box merken
                bne.s   maus_unverÑndert ;war schon so..
                move.w  D0,-(SP)
                moveq   #$0F,D0         ;Arrow setzen (innerhalb Box)
                bsr     set_mouse_d0
                move.w  (SP)+,D0
                bra.s   maus_unverÑndert
maus_auûerhalb: bclr    #3,copy_status  ;Maus ist auûerhalb Box
                beq.s   maus_unverÑndert ;war schon immer so..
                bsr     set_mouse       ;sonst wieder Kreuz
maus_unverÑndert:move.w D2,D5           ;Maustaste
                andi.w  #%0000000000111100,D5 ;losgelassen, neu gedrÅckt?
                beq     knopf_unverÑndert ;Nein
                clr.b   any_shift
                btst    #2,D2           ;wurde links neu gedrÅckt?
                bne     left_pressed    ;ja
                btst    #4,D2           ;Wurde links neu losgelassen
                beq     no_left_released ;Nein

;Es wurde links losgelassen:

                clr.b   any_shift
                bclr    #2,copy_status  ;Noch wird nicht verschoben

;Aufspannen ist beendet
select_ready:   btst    #1,copy_status  ;Ist schon ein Rahmen da?
                beq     no_left_released ;nein, es wurde also daneben geklickt
                bset    #0,copy_status  ;Es ist jetzt fertig ausgeschnitten

                move.w  ani_x4,D7
                cmp.w   ani_x1,D7
                bgt.s   vertausch_x
                move.w  ani_x1,ani_x4   ;in richtige Reihenfolge bringen
                move.w  D7,ani_x1
vertausch_x:    move.w  ani_y4,D7
                cmp.w   ani_y1,D7
                bgt.s   vertausch_y
                move.w  ani_y1,ani_y4   ;vertauschen
                move.w  D7,ani_y1
vertausch_y:    moveq   #0,D5           ;Board Offset=0
                tst.w   board_da
                bne.s   kein_board2
                move.w  grab_y,D5       ;Sonst Grab_y
kein_board2:    move.w  ani_x1,D7
                move.w  D7,objekt_x1
                move.w  ani_x4,D6
                sub.w   D7,D6
                addq.w  #1,D6
                move.w  D6,breite       ;Breite berechnen
                move.w  D7,objekt_x2
                move.w  ani_y1,D7
                move.w  D7,objekt_y1
                add.w   D5,objekt_y1    ;+Grab_y
                move.w  ani_y4,D6
                sub.w   D7,D6
                addq.w  #1,D6
                move.w  D6,hîhe         ;Hîhe berechnen
                add.w   D5,D7           ;+Grab_y
                move.w  D7,objekt_y2

                bsr     show_ausmaûe

                movea.l scr1,A1         ;Box auf scr1 animieren
                bsr     ani_box         ;Box animieren
                jsr     on_off_cutter   ;Schaltet nur die Buttons an oder aus
                jsr     redraw_cut_opt  ;Zeichnet sie neu auf den Screen
                bra     cutter_end      ;->RTS

;Es wurde links neu gedrÅckt
left_pressed:   btst    #0,copy_status  ;Schon was selektiert?
                bne.s   already_select  ;ja, weiter

                move.l  komplettbild,objekt_pointer ;Nein, mit Rahmen spannen anfangen
                move.w  #160,breite_bytes
                bset    #1,copy_status  ;Ab jetzt ist ein Rahmen da
                move.w  D0,ani_x1
                move.w  D1,ani_y1       ;Box-Koordinaten starten ab Maus
                move.w  D0,ani_x4
                move.w  D1,ani_y4

                bra.s   drÅber3

                movea.l scr1,A0         ;Scr1 ist zu sehen
                movea.l copybox_screen,A1 ;nach Physbase wird kopiert
                move.w  #1999,D5
copy_scr3:      move.l  (A0)+,(A1)+     ;Ganzen Scr1->Physbase
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D5,copy_scr3

drÅber3:        clr.b   L076B
                move.w  #8,aufzieh_typ  ;es wird von rechts unten gezogen
                movea.l scr1,A1
                bsr     ani_box         ;und auf scr1 die Box animieren
                bra     cutter_end      ;RTS

;Es wurde links neu gedrÅckt, Rahmen ist aber schon da
already_select: btst    #3,copy_status  ;Maus innerhalb der Box?
                beq.s   deselect        ;nein, Rahmen wieder weg...

                movem.l D0-D7,-(SP)     ;Sonst resize
                sub.w   ani_x1,D0       ;abziehen
                move.w  ani_x4,D3
                sub.w   ani_x1,D3       ;Breite berechnen
                addq.w  #1,D3           ;+1=Breite
                ext.l   D3
                divu    #3,D3           ;durch 3 teilen
                beq.s   zu_schmal       ;nicht wenigstens 3 breit
                ext.l   D3
                ext.l   D0
                divu    D3,D0           ;x durch Breite/3
                cmp.w   #2,D0
                ble.s   ok92
                moveq   #2,D0           ;Obergrenze
ok92:           sub.w   ani_y1,D1       ;Abziehen
                move.w  ani_y4,D3
                sub.w   ani_y1,D3       ;Hîhe berechnen
                addq.w  #1,D3           ;+1=Hîhe
                ext.l   D3
                divu    #3,D3           ;/3
                beq.s   zu_schmal       ;nicht wenigstens 3 hoch
                ext.l   D3
                ext.l   D1
                divu    D3,D1
                cmp.w   #2,D1
                ble.s   ok91
                moveq   #2,D1
ok91:           mulu    #3,D1           ;Hîhe mal 3
                add.w   D0,D1
setz_typ:       move.w  D1,aufzieh_typ  ;Es wird wieder vergrîûert!
                bclr    #0,copy_status  ;Noch ist nichts selektiert!
                movem.l (SP)+,D0-D7
                bra     cutter_end

;Die Objektbox ist nichtmal 3 breit oder hoch
zu_schmal:      moveq   #8,D1           ;rechts unten aufziehen
                bra.s   setz_typ

;Spieler hat auûerhalb der Box links geklickt, -> Alten Rahmen weg, neuen machen
deselect:       clr.b   copy_status     ;Nichts mehr ausgeschnitten
                jsr     on_off_cutter   ;Buttons an, oder ausschalten
                jsr     redraw_cut_opt  ;und ggf. neu zeichnen
                clr.b   copy_status
                bsr     delete_cut_rahm ;Rahmen wieder wegmachen
                clr.w   ani_x1
                clr.w   ani_y1          ;Keine Box mehr da...
                clr.w   ani_x4
                clr.w   ani_y4
                bsr     show_ausmaûe
                bra     left_pressed    ;Neuen Rahmen aufziehen

no_left_released:move.w D2,D5
                and.w   #%0000000000101000,D5 ;Rechts was verÑndert?
                beq.s   knopf_unverÑndert

                btst    #3,copy_status  ;Maus innerhalb Rahmen?
                bne.s   innerhalb
                btst    #3,D2           ;Maus rechts gedrÅckt?
                bne     such_rahmen

innerhalb:      btst    #0,copy_status  ;Rahmen schon da?
                beq.s   knopf_unverÑndert

                btst    #3,D2           ;Rechts neu gedrÅckt?
                bne.s   verschieben     ;ja, verschieben

                bclr    #2,copy_status  ;Jetzt wird nicht mehr verschoben
                bra     cutter_end

verschieben:    btst    #0,copy_status  ;öberhaupt schon fertig geschnitten?
                beq     cutter_end      ;nein->selektieren

                move.w  D0,pos_x
                move.w  D1,pos_y
                bset    #2,copy_status  ;Jetzt wird verschoben!
                bsr     get_shift       ;Status der Shift-Tasten holen
                bra     cutter_end

knopf_unverÑndert:btst  #2,copy_status  ;Wird verschoben?
                beq     no_move         ;Nein

;Verschieberoutine:
                tst.w   D2              ;Position verÑndert worden?
                bpl     cutter_end      ;Nein, Raus

                movem.w D0-D4,-(SP)
                bsr     chg_koord_shift
                move.w  pos_x,D3
                move.w  pos_y,D4
                sub.w   D0,D3           ;Differenz bestimmen
                sub.w   D1,D4
                sub.w   D3,ani_x1
                sub.w   D3,ani_x4
                sub.w   D4,ani_y1       ;Und Box verschieben
                sub.w   D4,ani_y4
                tst.w   ani_x1          ;noch im Screen?
                bpl.s   ok_l
                move.w  ani_x1,D3       ;negativer Wert
                sub.w   D3,ani_x4
                sub.w   D3,ani_x1       ;Anpassen
ok_l:           tst.w   ani_y1
                bpl.s   ok_o
                move.w  ani_y1,D3
                sub.w   D3,ani_y4
                sub.w   D3,ani_y1
ok_o:           cmpi.w  #320,ani_x4
                blt.s   ok_r
                move.w  ani_x4,D3
                sub.w   #319,D3
                sub.w   D3,ani_x1
                sub.w   D3,ani_x4
ok_r:           cmpi.w  #200,ani_y4
                blt.s   ok_u
                move.w  ani_y4,D3
                sub.w   #199,D3
                sub.w   D3,ani_y1
                sub.w   D3,ani_y4
ok_u:           move.w  D0,pos_x
                move.w  D1,pos_y
                movem.w (SP)+,D0-D4

                bsr     delete_cut_rahm ;Kopiert Komplettscreen auf scr1
                movea.l scr1,A1
                bsr     ani_box         ;Und Box neu zeichnen
                bra.s   cutter_end

;Hier wird Rahmen weiter aufgespannt:
no_move:        btst    #1,copy_status  ;Ist Rahmen schon da?
                beq.s   cutter_end      ;Nein->RTS
                btst    #0,copy_status  ;Schon fertig selektiert?
                bne.s   cutter_end      ;ja->RTS
                tst.w   D2              ;Wurde Mausposition verÑndert?
                bpl.s   cutter_end      ;Nein->RTS
                cmpi.w  #4,aufzieh_typ  ;Mitte?
                beq.s   cutter_end      ;ja, nichts verÑndern!
                bsr     delete_cut_rahm ;alten Rahmen weglîschen
                movem.w D0-D2,-(SP)     ;Alten Mausstatus merken
                move.w  aufzieh_typ,D2
                lsl.w   #2,D2           ;Je nach Typ in Routine
                lea     aufzieh_tab(PC),A0
                movea.l 0(A0,D2.w),A0   ;Routine holen
                move.w  D0,D2
                move.w  D1,D3
                jsr     (A0)            ;und starten
                move.w  D0,ani_x1
                move.w  D1,ani_y1
                move.w  D2,ani_x4       ;2. Koordinate merken
                move.w  D3,ani_y4       ;-'-

                movem.w (SP)+,D0-D2     ;und alten Status holen
                bsr     show_ausmaûe    ;Maûe anschreiben
                movea.l scr1,A1
                bsr     ani_box         ;Neue Box zeichnen
cutter_end:     rts

aufzieh_tab:            DC.L rout0,rout1,rout2,rout3,rout4,rout5,rout6,rout7,rout8

;Linkes Oberes Eck ziehen
rout0:          bsr.s   check_oben
                bra.s   check_links

;Oben Mitte
rout1:          move.w  ani_x4,D2       ;x nicht verÑndern
                move.w  ani_x1,D0
                bra.s   check_oben

;Oben Rechts:
rout2:          bsr.s   check_rechts
check_oben:     cmp.w   ani_y4,D1
                ble.s   rout2_ok1
                move.w  ani_y4,D1
rout2_ok1:      move.w  ani_y4,D3
                rts

;Links Mitte
rout3:          move.w  ani_y1,D1
                move.w  ani_y4,D3       ;Hîhe Nichts verÑndern
                bra.s   check_links

;Mittelpunkt
rout4:          move.w  ani_x1,D0
                move.w  ani_y1,D1
                move.w  ani_x4,D2       ;Nichts verÑndern!
                move.w  ani_y4,D3
                rts

;Rechts Mitte:
rout5:          move.w  ani_y1,D1
                move.w  ani_y4,D3       ;Hîhe nicht verÑndern
check_rechts:   cmp.w   ani_x1,D2       ;Linken Rand schon erreicht?
                bge.s   rout5_ok1       ;Nein, weiter
                move.w  ani_x1,D2       ;Sonst linken Rand nehmen
rout5_ok1:      move.w  ani_x1,D0       ;und linken Rand lassen
                rts

;Linkes Unteres Eck:
rout6:          bsr.s   check_unten
check_links:    cmp.w   ani_x4,D0
                ble.s   rout6_ok1
                move.w  ani_x4,D0
rout6_ok1:      move.w  ani_x4,D2
                rts

;Unten Mitte ziehen:
rout7:          move.w  ani_x1,D0
                move.w  ani_x4,D2       ;x nicht verÑndern
check_unten:    cmp.w   ani_y1,D3
                bge.s   rout7_ok1
                move.w  ani_y1,D3
rout7_ok1:      move.w  ani_y1,D1
                rts

;Rechtes Unteres Eck ziehen:
rout8:          bsr.s   check_rechts
                bra.s   check_unten

show_ausmaûe:   cmpi.b  #7,function     ;Cutter?
                bne.s   no_cutter2
                tst.w   board_da        ;Ist Åberhaupt ein Board da?
                bne.s   no_cutter2
                tst.b   lupe_an
                beq.s   no_cutter2
                movem.l D0-A6,-(SP)

                lea     maûex,A0
                move.w  ani_x4,D0
                sub.w   ani_x1,D0
                addq.w  #1,D0
                bsr     wandel_fest_dez
                move.b  #' ',-(A0)
                addq.l  #3,A0
                move.w  ani_y4,D0
                sub.w   ani_y1,D0
                addq.w  #1,D0
                bsr     wandel_fest_dez

                bsr     Hm

                lea     maûe,A0
                move.w  #202,D0
                move.w  #192,D1
                moveq   #0,D2
                bsr     print6x6

                movem.l (SP)+,D0-A6
no_cutter2:     rts

;User hat mit der rechten Maustaste auûerhalb der Box geklickt...
;->Rahmen suchen in zeichenfarbe
such_rahmen:    movem.l D0-A6,-(SP)     ;Register retten

                bsr     delete_cut_rahm ;Alten Rahmen wegmachen

                moveq   #0,D5           ;Grab_y
                tst.w   board_da
                bne.s   drÅber2
                move.w  grab_y,D5       ;Offset
drÅber2:        add.w   D5,D1           ;Maus_y angleichen
                bsr.s   such_it         ;Rahmen suchen
                tst.w   D0              ;Fehler?
                bmi.s   not_found       ;Negativ->Fehler

                sub.w   D5,D1           ;Y angleichen
                sub.w   D5,D3           ;-'-

                addq.w  #1,D0           ;Rahmen weglassen
                addq.w  #1,D1
                subq.w  #1,D2
                subq.w  #1,D3

                move.w  D0,ani_x1       ;Sonst Koordinaten setzen
                move.w  D1,ani_y1
                move.w  D2,ani_x4
                move.w  D3,ani_y4
                move.b  #11,copy_status ;Rahmen ist jetzt da

                movea.l scr1,A1
                bsr     ani_box         ;Box zeichnen
und_weiter:     bsr     show_ausmaûe    ;Grîûe anzeigen
                jsr     on_off_cutter   ;Schaltet nur die Buttons an oder aus
                jsr     redraw_cut_opt  ;Zeichnet sie neu auf den Screen

                movem.l (SP)+,D0-A6
                rts

not_found:      clr.b   copy_status     ;Kein Rahmen ist jetzt da
                bra.s   und_weiter

;Sucht nach einem Rahmen um Objekte (CHS):
;Parameter:
;D0: X-Start
;D1: Y-Start
;Ausgabe:
;D0: x1 (negativ bei Fehler)
;D1: y1
;D2: x2
;D3: y2
such_it:        movem.l D4-A2,-(SP)     ;Register retten

                tst.w   D0
                ble.s   such_it_fehler
                cmp.w   #319,D0
                bge.s   such_it_fehler
                tst.w   D1
                ble.s   such_it_fehler
                cmp.w   #199,D1
                bge.s   such_it_fehler

                move.w  D0,D4
                move.w  D1,D5
                subq.w  #1,D4
                subq.w  #1,D5

                movea.l komplettbild,A0
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                bne.s   inloop1

such_it_fehler: moveq   #-1,D0
                bra     such_it_ende

restart1:       move.w  D5,D1
                bra.s   inloop1

start1:         bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
inloop1:        dbeq    D0,start1
                bne     such_it_ende

                move.w  D0,D6

restart2:       move.w  D6,D0
                moveq   #1,D3           ;Zero lîschen
                bra.s   inloop2

start2:         bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                bne.s   restart1
                addq.w  #1,D0
                bsr     get_pixel_scr
                subq.w  #1,D0
                cmp.w   zeichenfarbe,D3
inloop2:        dbeq    D1,start2
                bne.s   restart1

                move.w  D1,D7

                addq.w  #1,D0
                move.w  D4,D2
                sub.w   D0,D2
                bmi.s   restart3a

prestart3:      addq.w  #1,D0
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                dbne    D2,prestart3
                bne.s   restart2

restart3:       move.w  D7,D1
restart3a:      move.w  #318,D2
                sub.w   D0,D2
start3:         addq.w  #1,D0
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                bne.s   restart2
                addq.w  #1,D1
                bsr     get_pixel_scr
                subq.w  #1,D1
                cmp.w   zeichenfarbe,D3
                dbeq    D2,start3
                bne.s   restart2

                movea.w D0,A1

                addq.w  #1,D1
                move.w  D5,D2
                sub.w   D1,D2
                bmi.s   restart4a

prestart4:      addq.w  #1,D1
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                dbne    D2,prestart4
                bne.s   restart3

restart4:       move.w  A1,D0
restart4a:      move.w  #198,D2
                sub.w   D1,D2
start4:         addq.w  #1,D1
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                bne.s   restart3
                subq.w  #1,D0
                bsr     get_pixel_scr
                addq.w  #1,D0
                cmp.w   zeichenfarbe,D3
                dbeq    D2,start4
                bne.s   restart3

                movea.w D1,A2

                subq.w  #1,D0
                move.w  D0,D2
                sub.w   D6,D2
                subq.w  #1,D2
start5:         subq.w  #1,D0
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                dbne    D2,start5
                bne.s   restart4

                move.w  D1,D2
                sub.w   D5,D2
                subq.w  #3,D2
                bmi.s   such_okay

start6:         subq.w  #1,D1
                bsr     get_pixel_scr
                cmp.w   zeichenfarbe,D3
                dbne    D2,start6
                beq.s   such_okay
                move.w  A2,D1
                bra.s   restart4

such_okay:      move.w  D7,D1
                move.w  A1,D2
                move.w  A2,D3
such_it_ende:   movem.l (SP)+,D4-A2
                rts

;Copybox Routine im Zeichenfeld:
do_copybox:     tst.b   D2              ;Mausbutton gedrÅckt?
                bne.s   L01D0           ;Ja, auswerten
                tst.b   fun_key         ;Funktionstaste gedrÅckt?
                bne     copybox_fkey    ;Funktionstastenauswertung...
L01D0:          btst    #0,copy_status  ;Schon was selektiert?
                beq.s   L01D2           ;Nein
                btst    #2,copy_status  ;wird gerade verschoben?
                bne.s   L01D2           ;ja
                bsr     check_in_box    ;Ist Maus innerhalb Box?
                bne.s   L01D1           ;Nein
                bset    #3,copy_status  ;Maus innerhalb Box merken
                bne.s   L01D2           ;war schon so..
                move.w  D0,-(SP)
                moveq   #$0F,D0         ;Arrow setzen (innerhalb Box)
                bsr     set_mouse_d0
                move.w  (SP)+,D0
                bra.s   L01D2
L01D1:          bclr    #3,copy_status  ;Maus ist auûerhalb Box
                beq.s   L01D2           ;war schon immer so..
                bsr     set_mouse       ;sonst wieder Kreuz
L01D2:          move.w  D2,D5           ;Maustaste
                andi.w  #%0000000000111100,D5 ;losgelassen, neu gedrÅckt?
                beq     L01EB           ;wurde was verÑndert? nein
                btst    #2,D2           ;wurde links neu gedrÅckt?
                bne     L01DC           ;ja
                btst    #4,D2           ;Wurde links neu losgelassen
                beq     L01E8           ;Nein
;Immer wenn linke Maustaste losgelassen wird:
L01D3:          bsr     show_fn
                clr.b   any_shift
                bclr    #2,copy_status  ;Noch wird nicht verschoben
                btst    #0,copy_status  ;öberhaupt schon fertig geschnitten?
                beq     L01D7           ;nein->selektieren
                move.b  no_resize,D5
                beq     L01E8
                move.b  #-1,no_resize
                cmpi.b  #%10000101,D5
                bne.s   L01D5
                move.w  board_y,D6      ;Bis zum Board den Screen retten
                mulu    #10,D6          ;wegen Undo (?)
                subq.w  #1,D6
                movea.l copybox_screen,A0
                movea.l scr2,A1
L01D4:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D6,L01D4
                bra     L01E8

L01D5:          bsr     L0219
                lea     L07E7,A6
                move.w  22(A6),D4
                move.w  24(A6),D5
                move.w  26(A6),D6
                move.w  D6,breite
                move.w  28(A6),D7
                move.w  D7,hîhe
                move.w  D4,ani_x1
                move.w  D4,objekt_x2
                move.w  D4,objekt_x1
                move.w  D5,ani_y1
                move.w  D5,objekt_y2
                move.w  D5,objekt_y1
                add.w   D6,D4
                subq.w  #1,D4
                move.w  D4,ani_x4
                add.w   D7,D5
                subq.w  #1,D5
                move.w  D5,ani_y4
                movea.l scr2,A0
                movea.l irgend_copy,A1
                movea.l copybox_screen,A2
                move.l  A1,objekt_pointer
                move.w  #160,breite_bytes

                move.w  #1999,D5
                tst.w   board_da
                bne.s   L01D6
                move.w  #999,D5
L01D6:          move.l  (A0),(A1)+
                move.l  (A2)+,(A0)+
                move.l  (A0),(A1)+
                move.l  (A2)+,(A0)+
                move.l  (A0),(A1)+
                move.l  (A2)+,(A0)+
                move.l  (A0),(A1)+
                move.l  (A2)+,(A0)+
                dbra    D5,L01D6
                bsr     phys2scr2
                bsr     make_maske
                bra     L01EE           ;->RTS

;Aufspannen ist beendet
L01D7:          btst    #1,copy_status  ;Ist schon ein Rahmen da?
                beq     L01E8           ;nein...
                bset    #0,copy_status  ;Es ist jetzt fertig ausgeschnitten
                move.w  ani_x4,D7
                cmp.w   ani_x1,D7
                bcc.s   L01D8
                move.w  ani_x1,ani_x4   ;in richtige Reihenfolge bringen
                move.w  D7,ani_x1
L01D8:          move.w  ani_y4,D7
                cmp.w   ani_y1,D7
                bcc.s   L01D9
                move.w  ani_y1,ani_y4   ;vertauschen
                move.w  D7,ani_y1
L01D9:          moveq   #0,D5           ;Board Offset=0
                tst.w   board_da
                bne.s   L01DA
                move.w  grab_y,D5       ;Sonst Grab_y
L01DA:          move.w  ani_x1,D7
                move.w  D7,objekt_x1
                move.w  ani_x4,D6
                sub.w   D7,D6
                addq.w  #1,D6
                move.w  D6,breite       ;Breite berechnen
                move.w  D7,objekt_x2
                move.w  ani_y1,D7
                move.w  D7,objekt_y1
                move.w  ani_y4,D6
                sub.w   D7,D6
                addq.w  #1,D6
                move.w  D6,hîhe         ;Hîhe berechnen
                add.w   D5,D7
                move.w  D7,objekt_y2
                bsr     phys2scr2       ;kopiert Phys->scr2
                bsr     delete_rahmen
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #1999,D5
L01DB:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Kopiert Scr1->Scr2
                move.l  (A0)+,(A1)+
                dbra    D5,L01DB
                movea.l scr1,A1         ;Box auf scr1 animieren
                bsr     ani_box         ;Box animieren
                bsr     make_maske
                bsr     clear_box       ;Box vom Bildschirm lîschen
                jsr     on_off_buttons  ;Schaltet nur die Buttons an oder aus
                bsr     redraw_copy_opt ;Zeichnet sie neu auf den Screen
                bra     L01EE           ;->RTS

;Es wurde links neu gedrÅckt (ok)
L01DC:          btst    #0,copy_status  ;Schon was selektiert?
                bne     L01DE           ;ja, weiter

                movem.l D0-A6,-(SP)
                moveq   #16,D0
                move.w  #182,D1
                move.w  #119,D2
                move.w  #189,D3         ;Filenamen weglîschen
                moveq   #0,D4
                moveq   #0,D5
                tst.w   board_da
                beq.s   ja_1
                bsr     into_border
                moveq   #14,D1
                moveq   #21,D3
ja_1:           jsr     fill_box
                bsr     into_screen
                movem.l (SP)+,D0-A6

                move.l  komplettbild,objekt_pointer ;Nein, mit Rahmen spannen anfangen
                move.w  #160,breite_bytes
                bset    #1,copy_status
                move.w  D0,ani_x1
                move.w  D1,ani_y1       ;Box-Koordinaten starten hier
                move.w  D0,ani_x4
                move.w  D1,ani_y4
                movea.l scr1,A0
                movea.l copybox_screen,A1
                move.w  #1999,D5
L01DD:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;und erstmal Screen kopieren..(?)
                move.l  (A0)+,(A1)+
                dbra    D5,L01DD
                clr.b   L076B
                bsr     put_work_back
                movea.l scr1,A1
                bsr     ani_box
                bra     L01EE           ;RTS

;Es wurde links geklickt, aber ein Objekt ist bereits selektiert
L01DE:          clr.b   changed         ;Es wurde an der Grafik verÑndert
                btst    #3,copy_status  ;Maus innerhalb der Box?
                beq     L01E7           ;nein, Rahmen wieder weg...
                bsr     get_shift       ;Shift-Status holen
                bset    #2,copy_status  ;verschiebe gerade...
                tst.b   no_resize       ;Kein Vergrîûern?
                beq     L01EE           ;ja->RTS
                move.w  ani_y1,D5
                bpl.s   L01DF
                moveq   #0,D5
L01DF:          move.w  ani_y4,D6
                move.w  board_y,D7
                subq.w  #1,D7
                cmp.w   D7,D6
                ble.s   L01E0
                move.w  D7,D6
L01E0:          sub.w   D5,D6
                addq.w  #1,D6
                ext.l   D6
                divu    #3,D6
                moveq   #0,D7
                move.w  #1,D4
L01E1:          add.w   D6,D5
                cmp.w   D1,D5
                bgt.s   L01E2
                addq.w  #4,D7
                dbra    D4,L01E1
L01E2:          move.w  ani_x1,D5
                bpl.s   L01E3
                moveq   #0,D5
L01E3:          move.w  ani_x4,D6
                cmpi.w  #$013F,D6
                ble.s   L01E4
                move.w  #$013F,D6
L01E4:          sub.w   D5,D6
                addq.w  #1,D6
                ext.l   D6
                divu    #3,D6
                move.w  #1,D4
L01E5:          add.w   D6,D5
                cmp.w   D0,D5
                bgt.s   L01E6
                addq.w  #1,D7
                dbra    D4,L01E5
L01E6:          ori.b   #-$80,D7
                move.b  D7,no_resize
                bra     L01EE

;Spieler hat auûerhalb der Box links geklickt...
L01E7:          clr.b   copy_status     ;Nichts mehr ausgeschnitten
                move.b  #-1,rotate_gefÅllt ;Auch der Rotatebuffer ist ungÅltig
                jsr     on_off_buttons
                bsr     redraw_copy_opt
                clr.b   copy_status
                bsr     L0207
                clr.w   ani_x1
                clr.w   ani_y1          ;Keine Box mehr da...
                clr.w   ani_x4
                clr.w   ani_y4
                bra     L01EE           ;RTS

L01E8:          btst    #3,D2           ;Rechts neu gedrÅckt?
                beq.s   L01EB           ;Nein
                btst    #0,copy_status  ;Schon was aufgespannt?
                beq.s   L01EB           ;Nein
                clr.b   changed
                btst    #0,D2           ;links gedrÅckt?
                beq.s   L01EA           ;nein
                btst    #2,copy_status  ;wird verschoben?
                beq.s   L01EA           ;Nein
                tst.w   D2              ;Mausposition verÑndert?
                bpl.s   L01EA           ;Nein
                bsr     chg_koord_shift ;je nach Shift Koordinaten anpassen
                tst.b   no_resize
                beq.s   L01E9
                bsr     L020D           ;Copybox in Hintergrund kopieren
                bra.s   L01EA
L01E9:          bsr     draw_box
L01EA:          bsr     L0237
                bra     L01EE

;Es wurde an den Maustasten keine VerÑnderung durchgefÅhrt
L01EB:          btst    #0,D2           ;links gedrÅckt?
                beq     L01EE           ;Nein, -> RTS
                btst    #2,copy_status  ;Wird verschoben?
                beq.s   L01ED           ;Nein
                tst.w   D2              ;Mausposition verÑndert?
                bpl     L01EE           ;Nein->RTS
                bsr     chg_koord_shift

                tst.b   no_resize       ;Wird nicht vergrîûert?
                beq.s   L01EC           ;Ja->verschieben
                bsr     L020D           ;Resize
                bra     L01EE           ;->RTS

;Verschieben:
L01EC:          bsr     draw_box
                bra     L01EE           ;->RTS

;Aufziehen der Copybox:
L01ED:          btst    #1,copy_status  ;Ist Rahmen schon da?
                beq     L01EE           ;Nein->RTS
                btst    #0,copy_status  ;Schon fertig selektiert?
                bne     L01EE           ;ja->RTS
                tst.w   D2              ;(?)
                bpl     L01EE
                bsr     delete_rahmen   ;Boxinhalt retten
                move.w  D0,ani_x4       ;2. Koordinate merken
                move.w  D1,ani_y4       ;-'-
                movea.l scr1,A1
                bsr     ani_box

                movem.l D0-A6,-(SP)
                move.w  ani_x4,D1
                sub.w   ani_x1,D1
                bpl.s   pos1
                neg.w   D1
pos1:           addq.w  #1,D1
                lea     breite_cb+2,A0
                bsr     wandel_fest_dez3 ;Breite eintragen
                move.w  ani_y4,D1
                sub.w   ani_y1,D1
                bpl.s   pos2
                neg.w   D1
pos2:           addq.w  #1,D1
                lea     hoehe_cb+2,A0
                bsr     wandel_fest_dez3

                tst.w   board_da
                bne     in_rand

                moveq   #40,D0
                move.w  #183,D1
                moveq   #0,D2           ;Status
                lea     breite_cb,A0
                bsr     print6x6
                bra.s   gem7

in_rand:        bsr     into_border

                moveq   #40,D0
                moveq   #12,D1          ;Y-Wert = unterer Rand
                tst.b   pal_flag        ;Palette im Fullscreen?
                bne.s   zeichne9
                addq.w  #3,D1           ;3 Zeilen tiefer
zeichne9:       moveq   #0,D2           ;Status
                lea     breite_cb,A0
                bsr     print6x6

                bsr     into_screen

gem7:           movem.l (SP)+,D0-A6

L01EE:          rts

;öberprÅft, ob Mauszeiger innerhalb der Box ist:
check_in_box:   cmp.w   ani_x1,D0
                blt.s   L01F0
                cmp.w   ani_x4,D0
                bgt.s   L01F0
                cmp.w   ani_y1,D1
                blt.s   L01F0
                cmp.w   ani_y4,D1
                bgt.s   L01F0
                moveq   #0,D7
                rts
L01F0:          moveq   #-1,D7
                rts

make_maske:     movem.l D0-D7,-(SP)
                lea     bitblit,A6
                move.w  breite,0(A6)    ;Breite in Pixeln
                move.w  hîhe,2(A6)      ;Hîhe in Pixeln
                move.l  objekt_pointer,18(A6) ;Anfangsadresse Quelle
                lea     mask_buff,A0
                move.l  A0,32(A6)       ;Anfangsadresse Ziel
                move.w  objekt_x2,D7
                move.w  D7,14(A6)       ;Source-x
                move.w  D7,28(A6)       ;Dest-x
                move.w  objekt_y2,D7
                move.w  D7,16(A6)       ;Source-y
                move.w  D7,30(A6)       ;Dest-y
                move.w  #4,4(A6)        ;4 Planes
                move.w  #$000E,6(A6)    ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$0C040404,10(A6) ;Operation;12=Not q,4=Not q and z
                move.w  breite_bytes,D0
                move.w  #8,22(A6)       ;Offset zur selben Plane
                move.w  D0,24(A6)       ;Breite Quelle in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                lsr.w   #2,D0           ;/4
                move.w  #2,36(A6)       ;Offset zur selben Plane
                move.w  D0,38(A6)       ;Breite des Zielrasters in Bytes
                move.w  #0,40(A6)       ;Offset zur nÑchsten Plane (Maske machen)
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D0-D7
                rts

;Lîscht den alten Copybox-Rahmen wieder weg:
delete_rahmen:  movem.l D0-D3/A0-A3,-(SP)
                movea.l komplettbild,A0
                movea.l scr1,A1
                tst.w   board_da
                bne.s   L01F3
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A0
L01F3:          move.w  ani_x1,D0
                move.w  ani_y1,D1
                move.w  ani_x4,D2
                move.w  ani_y4,D3
                lsr.w   #4,D0           ;/16
                lsr.w   #4,D2           ;/16
                sub.w   D0,D2
                bcc.s   L01F4           ;negativ?
                neg.w   D2              ;Dann Breite negieren
                sub.w   D2,D0
L01F4:          lsl.w   #3,D0
                sub.w   D1,D3
                bcc.s   L01F5
                neg.w   D3
                sub.w   D3,D1
L01F5:          mulu    #$00A0,D1
                add.w   D0,D1
                adda.w  D1,A0           ;Offset im Komplettbild
                adda.w  D1,A1           ;Offset im scr1
                movea.l A0,A2           ;Komplettbild
                movea.l A1,A3           ;scr1
                move.w  D2,D0
L01F6:          move.l  (A2)+,(A3)+     ;ein BB Åbertragen
                move.l  (A2)+,(A3)+
                dbra    D2,L01F6        ;Alle BB Åbertragen
                move.w  #152,D2
                addq.l  #8,A0           ;entsprechend weitergehen
                addq.l  #8,A1
                subq.w  #1,D3           ;Bis Åber die ganze Zeile
                bmi.s   L01FA           ;->RTS
                bra.s   L01F8
L01F7:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A2)+,(A3)+
                move.l  (A2)+,(A3)+
L01F8:          adda.w  D2,A0           ;nÑchstes Zeile
                adda.w  D2,A1
                adda.w  D2,A2
                adda.w  D2,A3
                dbra    D3,L01F7
L01F9:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L01F9
L01FA:          movem.l (SP)+,D0-D3/A0-A3
                rts

;Animiert Copybox mit Clipping (CHS)
;Parameter:
;A1: Adresse des Zielscreens
ani_box:        movem.l D0-A6,-(SP)     ;Register retten

                move.w  ani_x1,D0
                move.w  ani_y1,D1       ;Koordinaten der Copybox

                move.w  D0,pos_objektx
                move.w  D1,pos_objekty  ;Koordinaten merken

                tst.w   board_da
                bne.s   keins1
                move.w  grab_y,D6
                add.w   D6,pos_objekty  ;angleichen
keins1:         move.w  ani_x4,D2
                move.w  ani_y4,D3
                cmp.w   D0,D2
                bge.s   L01FC
                exg     D2,D0           ;richtig ordnen
L01FC:          cmp.w   D1,D3
                bge.s   L01FD
                exg     D3,D1           ;richtig ordnen
L01FD:          moveq   #0,D6
                cmpi.w  #320,D2
                blt.s   L01FE
                move.w  #319,D2
                ori.w   #8,D6           ;kein rechter Rand...
L01FE:          moveq   #100,D7
                tst.w   board_da
                beq.s   L01FF
                add.w   D7,D7           ;sonst bei 200 Ende
L01FF:          cmp.w   D7,D3
                blt.s   L0200
                move.w  D7,D3           ;hier ist Schluss
                subq.w  #1,D3           ;d.h. eins vorher
                ori.w   #2,D6           ;kein unterer Rand
L0200:          tst.w   D0
                bpl.s   L0201
                clr.w   D0
                ori.w   #4,D6           ;kein linker Rand...
L0201:          tst.w   D1
                bpl.s   L0202
                clr.w   D1
                ori.w   #1,D6           ;kein oberer Rand
L0202:          lea     ani_bb,A6
                move.l  pos_ani_box,42(A6) ;Und-Maske
                move.w  #2,46(A6)       ;Hîhe des Maske in Bytes
                move.w  #4,4(A6)        ;4 Planes
                move.w  #1,2(A6)        ;Hîhe des Blocks in Pixeln
                move.w  D0,28(A6)       ;X-Koordinate Ziel
                move.w  D0,D4
                addq.w  #1,D4
                andi.w  #$000F,D4
                move.w  D4,14(A6)       ;X-Koordinate Quelle
                move.w  D1,30(A6)       ;Y-Koordinate Ziel
                move.l  A1,32(A6)       ;Anfangsadresse Zielraster
                move.w  D2,D4           ;x2
                sub.w   D0,D4           ;-x1
                addq.w  #1,D4           ;+1=Breite
                move.w  D4,0(A6)        ;Breite in Pixel
                lsr.w   #1,D6           ;entsprechender Rand da?
                bcs.s   L0203           ;nein, weiter
                movem.l D1-D3/D6/A6,-(SP)
                linea   #7 [ Bitblk ]   ;Zeichnen
                movem.l (SP)+,D1-D3/D6/A6
L0203:          move.l  pos_ani_box,42(A6)
                move.w  #2,46(A6)
                move.w  #4,4(A6)
                move.w  D3,30(A6)
                lsr.w   #1,D6           ;Rand da?
                bcs.s   L0204
                movem.l D1-D3/D6/A6,-(SP)
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D1-D3/D6/A6
L0204:          move.l  pos_ani_box,42(A6)
                move.w  #2,46(A6)
                move.w  #4,4(A6)
                move.w  #1,0(A6)
                move.w  D1,30(A6)
                move.w  D3,D4
                sub.w   D1,D4
                addq.w  #1,D4
                move.w  D4,2(A6)
                lsr.w   #1,D6
                bcs.s   L0205
                movem.l D2/D6/A6,-(SP)
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D2/D6/A6
L0205:          move.l  pos_ani_box,42(A6)
                move.w  #2,46(A6)
                move.w  #4,4(A6)
                move.w  #1,0(A6)
                move.w  D2,28(A6)
                lsr.w   #1,D6
                bcs.s   ani_ende
                linea   #7 [ Bitblk ]
ani_ende:       movem.l (SP)+,D0-A6
                rts

;Diese Funktion wird aufgerufen, wenn User Rahmen wegmacht, also entweder
;neben die Copybox klickt, oder mit laufender Copybox neue Funktion wÑhlt.
L0207:          move.b  #-1,rotate_gefÅllt ;Rotatebuffer ungÅltig!
                move.l  D7,-(SP)
                move.b  function,D7     ;Funktion merken
                ext.w   D7
                clr.b   function        ;Jetzt Jack Knife..
                swap    D7
                move.w  jack_mode,D7
                cmpi.l  #$00020001,D7   ;CopyBox und L077A=1?
                bne.s   L0208           ;Nein
                clr.w   jack_mode       ;dann L077A lîschen
L0208:          moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                move.l  D7,-(SP)
                bsr     draw_box        ;Irgendwas kopieren
                move.l  (SP)+,D7
                move.w  D7,jack_mode
                swap    D7
                move.b  D7,function     ;Alte Funktion wieder setzen
                move.l  (SP)+,D7
                rts

blitz:          movem.l D0-A6,-(SP)

                moveq   #10,D7

blitz_loop:     move.w  #$0777,-(SP)
                move.w  #0,-(SP)
                move.w  #7,-(SP)
                trap    #14
                addq.l  #6,SP
                move.w  #$0000,-(SP)
                move.w  #0,-(SP)
                move.w  #7,-(SP)
                trap    #14
                addq.l  #6,SP

                dbra    D7,blitz_loop

                movem.l (SP)+,D0-A6
                rts

;Lîscht den Speicherbereich, in der Grafik, wo die Box ist.
clear_box:      movem.w D0-D7,-(SP)
                lea     bitblit,A6
                move.w  ani_x1,D6
                move.w  D6,28(A6)       ;Ziel_x
                move.w  D6,14(A6)       ;Quelle_x
                move.w  breite,0(A6)    ;Breite eintragen
                move.w  ani_y1,D6
                move.w  D6,30(A6)       ;Dest_y
                move.w  D6,16(A6)       ;Source_y
                move.w  hîhe,2(A6)      ;Hîhe eintragen
                move.w  #4,4(A6)        ;Anzahl Planes
                move.l  #0,10(A6)       ;Speicherbereich lîschen(!)
                move.l  copybox_screen,32(A6) ;Ziel
                move.l  scr2,18(A6)     ;Quelle (Ist aber egal)
                move.w  #8,22(A6)       ;Source-Offset zum nÑchsten Wort
                move.w  #160,24(A6)     ;Source-Breite in Bytes
                move.w  #2,26(A6)       ;Source-Offset zur nÑchsten Plane
                move.w  #8,36(A6)       ;Dest-Offset zum nÑchsten Wort
                move.w  #160,38(A6)     ;Dest-Breite in Bytes
                move.w  #2,40(A6)       ;Dest-Offset zur nÑchsten Plane
                linea   #7 [ Bitblk ]
                movem.w (SP)+,D0-D7
                rts

phys2scr2:      movem.l D6/A0-A1,-(SP)
                move.w  breite,D6
                move.w  D6,breite_o1
                move.w  D6,breite_o2
                move.w  hîhe,D6
                move.w  D6,hîhe_o1
                move.w  D6,hîhe_o2
                btst    #0,copy_status  ;Fertig ausgeschnitten?
                beq.s   L020C           ;Nein->RTS
                movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #1999,D6
                tst.w   board_da
                bne.s   L020B
                move.w  #999,D6
L020B:          move.l  (A0)+,(A1)+     ;sichtbaren Screen ->scr2 kopieren
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D6,L020B
L020C:          movem.l (SP)+,D6/A0-A1
                rts

;Kopiert Copybox auf Screen (?)
L020D:          cmpi.b  #-$7B,no_resize
                beq     draw_box
                movem.w D0-D7,-(SP)
                move.w  breite_o2,D6
                move.w  hîhe_o2,D7
                bsr     L022C           ;clippen...
                move.w  breite,breite_o2
                move.w  hîhe,hîhe_o2
                move.w  ani_x1,objekt_x1
                move.w  ani_y1,objekt_y1
                sub.w   D3,D0
                sub.w   D4,D1
                move.b  no_resize,D6
                andi.w  #$007F,D6
                btst    #2,D6
                beq.s   L020E
                moveq   #0,D1
L020E:          btst    #0,D6
                beq.s   L020F
                moveq   #0,D0
L020F:          move.w  D6,D5
                andi.w  #3,D5
                bne.s   L0210
                neg.w   D0
L0210:          cmpi.b  #3,D6
                bgt.s   L0211
                neg.w   D1
L0211:          move.w  breite,D3
                add.w   D0,D3
                bgt.s   L0212
                neg.w   D3
                addq.w  #2,D3
                move.w  ani_x4,D7
                move.w  ani_x1,ani_x4
                move.w  D7,ani_x1
                eori.b  #2,D6
                eori.b  #2,no_resize
                neg.w   D0
L0212:          move.w  hîhe,D4
                add.w   D1,D4
                bgt.s   L0213
                neg.w   D4
                addq.w  #2,D4
                move.w  ani_y4,D7
                move.w  ani_y1,ani_y4
                move.w  D7,ani_y1
                eori.b  #8,D6
                eori.b  #8,no_resize
                neg.w   D1
L0213:          move.w  D3,breite
                move.w  D4,hîhe
                move.w  D6,D5
                andi.w  #3,D5
                cmpi.w  #2,D5
                bne.s   L0214
                add.w   D0,ani_x4
L0214:          tst.w   D5
                bne.s   L0215
                sub.w   D0,ani_x1
L0215:          cmpi.w  #8,D6
                blt.s   L0216
                add.w   D1,ani_y4
L0216:          cmpi.w  #3,D6
                bge.s   L0217
                sub.w   D1,ani_y1
L0217:          move.w  #8,22(A6)
                move.w  #$00A0,24(A6)
                move.w  #2,26(A6)
                move.w  #8,36(A6)
                move.w  #$00A0,38(A6)
                move.w  #2,40(A6)
                move.w  old_vblcount,D7
L0218:          cmp.w   vblcounter,D7
                beq.s   L0218
                linea   #7 [ Bitblk ]
                bsr.s   L021A
                movea.l scr2,A1
                bsr     ani_box
                bsr     switch_screens
                move.w  vblcounter,old_vblcount
                movem.w (SP)+,D0-D7
                rts

L0219:          movem.l D0-A6,-(SP)
                moveq   #0,D7
                bra.s   L021B

L021A:          movem.l D0-A6,-(SP)
                moveq   #0,D7
                tst.w   copy_mode
                bpl.s   L021B
                moveq   #1,D7
L021B:          lea     L07E7,A6
                move.w  D7,0(A6)
                move.l  objekt_pointer,2(A6)
                move.l  scr2,16(A6)
                move.w  #$00A0,20(A6)
                move.w  breite_bytes,6(A6)
                moveq   #0,D4
                move.w  breite_o1,D0
                move.w  breite,D1
                move.w  objekt_x2,D2
                move.w  ani_x1,D3
                bpl.s   L021C
                move.w  D0,D4
                ext.l   D4
                lsl.w   #7,D4
                divu    D1,D4
                add.w   D3,D1
                neg.w   D3
                mulu    D4,D3
                lsr.w   #7,D3
                add.w   D3,D2
                sub.w   D3,D0
                moveq   #0,D3
L021C:          move.w  D3,D5
                add.w   D1,D5
                subi.w  #$0140,D5
                ble.s   L021E
                tst.w   D4
                bne.s   L021D
                move.w  D0,D4
                ext.l   D4
                lsl.w   #7,D4
                divu    D1,D4
L021D:          sub.w   D5,D1
                mulu    D4,D5
                lsr.w   #7,D5
                sub.w   D5,D0
L021E:          move.w  D0,12(A6)
                move.w  D1,26(A6)
                move.w  D2,8(A6)
                move.w  D3,22(A6)
                moveq   #0,D4
                move.w  hîhe_o1,D0
                move.w  hîhe,D1
                move.w  objekt_y2,D2
                move.w  ani_y1,D3
                bpl.s   L021F
                move.w  D0,D4
                ext.l   D4
                lsl.w   #7,D4
                divu    D1,D4
                add.w   D3,D1
                neg.w   D3
                mulu    D4,D3
                lsr.w   #7,D3
                add.w   D3,D2
                sub.w   D3,D0
                moveq   #0,D3
L021F:          move.w  D3,D5
                add.w   D1,D5
                sub.w   board_y,D5
                ble.s   L0221
                tst.w   D4
                bne.s   L0220
                move.w  D0,D4
                ext.l   D4
                lsl.w   #7,D4
                divu    D1,D4
L0220:          sub.w   D5,D1
                mulu    D4,D5
                lsr.w   #7,D5
                sub.w   D5,D0
L0221:          move.w  D0,14(A6)
                move.w  D1,28(A6)
                move.w  D2,10(A6)
                move.w  D3,24(A6)
                bsr     Sm
                jsr     L0690
                bsr     Hm
                movem.l (SP)+,D0-A6
                rts

;Box verschieben....
draw_box:       movem.w D0-D7,-(SP)
                bsr     clip_objekt     ;entsprechend den RÑndern
                move.w  ani_x1,objekt_x1
                move.w  ani_y1,objekt_y1
                sub.w   D0,D3
                sub.w   D1,D4
                move.w  ani_x1,D7
                sub.w   D3,D7
                cmpi.w  #320,D7
                blt.s   L0223
                subi.w  #319,D7
                add.w   D7,D3
                move.w  #319,D7
L0223:          move.w  D7,ani_x1
                sub.w   D3,ani_x4
                bpl.s   L0224           ;Clippen...
                move.w  ani_x4,D3
                neg.w   D3
                add.w   D3,ani_x1
                add.w   D3,ani_x4
L0224:          move.w  ani_y1,D7
                sub.w   D4,D7
                cmp.w   D6,D7
                blt.s   L0225
                subq.w  #1,D6
                sub.w   D6,D7
                add.w   D7,D4
                move.w  D6,D7
L0225:          move.w  D7,ani_y1
                sub.w   D4,ani_y4
                bpl.s   L0226
                move.w  ani_y4,D4
                neg.w   D4
                add.w   D4,ani_y1
                add.w   D4,ani_y4
L0226:          move.w  old_vblcount,D7
L0227:          cmp.w   vblcounter,D7   ;Vsync
                beq.s   L0227
                linea   #7 [ Bitblk ]   ;und ausfÅhren
                lea     bitblit,A6
                move.w  #4,4(A6)        ;4 Planes
                bsr     L0232
                move.l  scr2,32(A6)     ;Ziel
                tst.w   copy_mode
                bpl.s   L0228
                move.w  breite_bytes,D0
                lsr.w   #2,D0
                move.w  #2,22(A6)
                move.w  D0,24(A6)
                move.w  #0,26(A6)
                move.w  #8,36(A6)
                move.w  #$00A0,38(A6)
                move.w  #2,40(A6)
                move.l  #mask_buff,18(A6)
                bsr     L023D
                lea     bitblit,A6
                move.w  #4,4(A6)
                move.l  #$07070707,10(A6) ;einodern
L0228:          move.w  #8,22(A6)
                move.w  breite_bytes,24(A6)
                move.w  #2,26(A6)
                move.l  objekt_pointer,18(A6)
                linea   #7 [ Bitblk ]
                cmpi.b  #2,function     ;Copybox?
                beq.s   L0229
                cmpi.b  #7,function     ;Cutter?
                beq.s   L0229
                cmpi.w  #1,jack_mode
                bne.s   L022A
                movea.l copybox_screen,A0
                movea.l scr2,A1
                lea     bitblit,A6
                move.w  28(A6),D4
                move.w  30(A6),D5
                move.w  0(A6),D6
                move.w  2(A6),D7
                jsr     L05B9
                bra.s   L022A
L0229:          movea.l scr2,A1
                bsr     ani_box
L022A:          bsr     switch_screens
                move.w  vblcounter,old_vblcount
                movem.w (SP)+,D0-D7
                rts

;Setzt die Variablen des BB entsprechend und clippt das Objekt
clip_objekt:    move.w  breite,D6
                move.w  hîhe,D7
L022C:          lea     bitblit,A6
                move.w  #8,22(A6)       ;Offset zur gleichen Plane (Quelle)
                move.w  #160,24(A6)     ;Bildschirmbreite in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  #8,36(A6)       ;Offset zur selben Plane (Ziel)
                move.w  #160,38(A6)     ;Breite in Bytes (Ziel)
                move.w  #2,40(A6)       ;Offset zur nÑchsten Plane (Ziel)
                move.l  copybox_screen,18(A6) ;Quelle
                move.l  scr2,32(A6)     ;Ziel
                move.w  objekt_x1,D5
                bpl.s   L022D           ;positiv->Okay
                add.w   D5,D6           ;Sonst Breite verringern
                clr.w   D5              ;und bei 0 starten
L022D:          move.w  D5,14(A6)       ;X-Koordinate (quelle)
                move.w  D5,28(A6)       ;X-Koordinate (ziel)
                add.w   D6,D5           ;+Breite
                subi.w  #320,D5         ;Breiter wie 320?
                ble.s   L022E           ;Nein, Okay
                sub.w   D5,D6           ;Sonst entsprechend verringern
L022E:          move.w  D6,0(A6)        ;Breite setzen
                moveq   #100,D6
                tst.w   board_da
                beq.s   L022F
                add.w   D6,D6           ;kein Board, Bild bis 200
L022F:          move.w  objekt_y1,D5
                bpl.s   L0230           ;Positiv->Okay
                add.w   D5,D7           ;Sonst Hîhe entsprechend verringern
                clr.w   D5              ;und bei y=0 starten
L0230:          move.w  D5,16(A6)       ;Y-Koordinate
                move.w  D5,30(A6)       ;setzen
                add.w   D7,D5           ;+Hîhe
                sub.w   D6,D5           ;minus max. Hîhe
                ble.s   L0231           ;Kleiner->Ok
                sub.w   D5,D7           ;Sonst Hîhe entsprechend verringern
L0231:          move.w  D7,2(A6)        ;Hîhe setzen
                move.w  #4,4(A6)        ;4 Planes
                move.l  #$03030303,10(A6) ;Copy.....
                rts

L0232:          move.w  breite,D2
                move.w  hîhe,D3
                move.w  objekt_x2,D6
                move.w  objekt_y2,D7
                move.w  ani_x1,D4
                bpl.s   L0233
                add.w   D4,D2
                sub.w   D4,D6
                clr.w   D4
L0233:          move.w  ani_y1,D5
                bpl.s   L0234
                add.w   D5,D3
                sub.w   D5,D7
                clr.w   D5
L0234:          move.w  D4,28(A6)
                move.w  D5,30(A6)
                move.w  D6,14(A6)
                move.w  D7,16(A6)
                add.w   D2,D4
                subi.w  #$0140,D4
                ble.s   L0235
                sub.w   D4,D2
L0235:          add.w   D3,D5
                sub.w   board_y,D5
                ble.s   L0236
                sub.w   D5,D3
L0236:          move.w  D2,0(A6)
                move.w  D3,2(A6)
                rts

L0237:          movem.w D0-D7,-(SP)
                bsr     clip_objekt
                move.l  A6,-(SP)
                linea   #7 [ Bitblk ]
                movea.l (SP)+,A6
L0238:          move.w  #4,4(A6)
                move.l  copybox_screen,32(A6)
                bsr     L0232
                move.w  ani_x1,objekt_x1
                move.w  ani_y1,objekt_y1
                tst.b   function        ;Jack Knife?
                bne.s   L0239           ;Nein
                cmpi.w  #1,jack_mode
                beq.s   L023A
L0239:          tst.w   copy_mode
                bpl.s   L023B
L023A:          move.w  breite_bytes,D0
                lsr.w   #2,D0
                move.w  #2,22(A6)
                move.w  D0,24(A6)
                move.w  #0,26(A6)
                move.l  #mask_buff,18(A6)
                move.l  A6,-(SP)
                bsr.s   L023D
                movea.l (SP)+,A6
                move.w  #4,4(A6)
                move.l  #$07070707,10(A6)
L023B:          move.w  #8,22(A6)
                move.w  breite_bytes,24(A6)
                move.w  #2,26(A6)
                move.l  objekt_pointer,18(A6)
                linea   #7 [ Bitblk ]
                tst.b   function        ;Jack Knife?
                bne.s   L023C           ;Nein...
                cmpi.w  #1,jack_mode    ;3D-Modus?
                bne.s   L023C
                movea.l scr2,A0
                movea.l copybox_screen,A1
                lea     bitblit,A6
                move.w  28(A6),D4
                move.w  30(A6),D5
                move.w  0(A6),D6
                move.w  2(A6),D7
                jsr     L05B9
L023C:          movem.w (SP)+,D0-D7
                rts
L023D:          move.w  0(A6),D1
                subq.w  #1,D1
                move.w  14(A6),D0
                move.w  D0,D4
                add.w   D1,D4
                move.w  28(A6),D2
                move.w  D2,D6
                add.w   D1,D6
                moveq   #$0F,D5
                move.w  D0,D1
                and.w   D5,D1
                move.w  D2,D3
                and.w   D5,D3
                lsr.w   #4,D0
                lsr.w   #4,D2
                lsr.w   #4,D4
                lsr.w   #4,D6
                sub.w   D0,D4
                sub.w   D2,D6
                move.w  D4,D5
                sub.w   D6,D5
                sub.w   D3,D1
                move.w  D6,D0
                subq.w  #1,D0
                move.w  D0,70(A6)
                and.w   #1,D5
                lsl.w   #2,D5
                move.w  D4,D7
                move.w  D1,D4
                move.w  D1,D2
                tst.w   D4
                bgt.s   L023E
                beq.s   L023F
                neg.w   D4
                addq.w  #1,D5
L023E:          cmp.w   #8,D4
                blt.s   L023F
                addq.w  #2,D5
                neg.w   D4
                add.w   #$0010,D4
L023F:          moveq   #0,D0
                move.w  14(A6),D0
                and.w   #-$0010,D0
                lsr.w   #3,D0
                move.w  16(A6),D1
                move.w  24(A6),D3
                muls    D3,D1
                add.l   D0,D1
                movea.l 18(A6),A0
                adda.l  D1,A0
                addq.w  #1,D7
                add.w   D7,D7
                sub.w   D3,D7
                neg.w   D7
                move.w  28(A6),D0
                and.w   #-$0010,D0
                lsr.w   #1,D0
                move.w  30(A6),D1
                move.w  38(A6),D3
                muls    D3,D1
                add.l   D0,D1
                movea.l 32(A6),A1
                adda.l  D1,A1
                addq.w  #1,D6
                asl.w   #3,D6
                sub.w   D3,D6
                neg.w   D6
                move.w  D7,74(A6)
                move.w  D6,72(A6)
                move.w  28(A6),D0
                add.w   0(A6),D0
                subq.w  #1,D0
                and.w   #$000F,D0
                add.w   D0,D0
                move.w  L0242(PC,D0.w),D6
                not.w   D6
                swap    D6
                move.w  28(A6),D0
                and.w   #$000F,D0
                add.w   D0,D0
                move.w  L0241(PC,D0.w),D6
                asl.w   #3,D5
                movea.l L0245(PC,D5.w),A3
                movea.l L0244(PC,D5.w),A4
                tst.w   70(A6)
                bge.s   L0240
                move.l  D6,D0
                swap    D0
                or.w    D0,D6
                lea     L0254(PC),A3
                btst    #5,D5
                bne.s   L0240
                lsr.w   #1,D5
                and.w   #$000C,D5
                movea.l L0243(PC,D5.w),A4
L0240:          move.w  2(A6),D7
                move.w  70(A6),D5
                jmp     (A4)
L0241:                  DS.W 1
L0242:                  DC.B $80,$00,$C0,$00,$E0,$00,$F0,$00
                        DC.B $F8,$00,$FC,$00,$FE,$00,$FF,$00
                        DC.B $FF,$80,$FF,$C0,$FF,$E0,$FF,$F0
                        DC.B $FF,$F8,$FF,$FC,$FF,$FE,$FF,$FF
L0243:                  DC.L L0246
                        DC.L L0247
                        DC.L L0247
                        DC.L L0246
L0244:                  DC.L L024A
L0245:                  DC.L L0251
                        DC.L L0249
                        DC.L L024E
                        DC.L L0248
                        DC.L L0250
                        DC.L L024B
                        DC.L L024F
                        DC.L L024A
                        DC.L L024F
                        DC.L L0249
                        DC.L L0250
                        DC.L L0248
                        DC.L L024E
                        DC.L L024B
                        DC.L L0251
L0246:          move.w  (A0)+,D0
                rol.w   D4,D0
                or.w    D6,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L0247:          move.w  (A0)+,D0
                ror.w   D4,D0
                or.w    D6,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L0248:          move.w  (A0)+,D0
                swap    D0
L0249:          move.w  (A0)+,D0
                move.l  D0,D1
                swap    D1
                ror.l   D4,D0
                or.w    D6,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L024A:          move.w  (A0)+,D0
                swap    D0
L024B:          move.w  (A0)+,D0
                swap    D0
                move.l  D0,D1
                rol.l   D4,D0
                or.w    D6,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L024C:          move.l  D1,D0
                move.w  (A0)+,D0
                move.l  D0,D1
                swap    D1
                ror.l   D4,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L024D:          move.l  D1,D0
                move.w  (A0)+,D0
                swap    D0
                move.l  D0,D1
                rol.l   D4,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                jmp     (A3)
L024E:          dbra    D5,L024C
                move.l  D1,D0
                move.w  (A0)+,D0
                ror.l   D4,D0
                bra.s   L0253
L024F:          dbra    D5,L024D
                move.l  D1,D0
                move.w  (A0)+,D0
                rol.l   D4,D0
                bra.s   L0252
L0250:          dbra    D5,L024C
                bra.s   L0252
L0251:          dbra    D5,L024D
L0252:          swap    D0
L0253:          swap    D6
                or.w    D6,D0
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                and.w   D0,(A1)+
                swap    D6
                move.w  70(A6),D5
L0254:          subq.w  #1,D7
                beq.s   L0255
                adda.w  74(A6),A0
                adda.w  72(A6),A1
                jmp     (A4)
L0255:          rts
L0256:          movem.l D0-A6,-(SP)
                linea   #0 [ Init ]
                move.w  #0,24(A0)
                move.w  #0,26(A0)
                move.w  #0,28(A0)
                move.w  #0,30(A0)
                bra.s   L0258
L0257:          movem.l D0-A6,-(SP)
                linea   #0 [ Init ]
                move.w  #1,24(A0)
                move.w  #1,26(A0)
                move.w  #1,28(A0)
                move.w  #1,30(A0)
                move.b  #3,text_status
L0258:          move.w  vblcounter,L07FB
                move.w  #-1,32(A0)
                move.w  #-1,34(A0)
                move.w  #0,36(A0)
                move.w  L0807,D0
                move.w  D0,40(A0)
                move.w  board_y,D1
                cmp.w   D1,D0
                bcc.s   L025A
                add.w   L0796,D0
                sub.w   D0,D1
                bcc.s   L0259
                add.w   D1,D0
L0259:          subq.w  #1,D0
                move.w  D0,44(A0)
                move.w  L0806,D0
                cmpi.w  #$0140,D0
                bcc.s   L025A
                move.w  D0,38(A0)
                move.w  D0,42(A0)
                linea   #3 [ Line ]
L025A:          movem.l (SP)+,D0-A6
                rts
L025B:          movem.l D0-D3/A0-A1,-(SP)
                bclr    #1,text_status
                move.w  L0806,D0
                cmpi.w  #$0140,D0
                bcc     L0260
                move.w  L0807,D1
                move.w  board_y,D2
                cmp.w   D2,D1
                bcc     L0260
                move.w  D1,D3
                add.w   L0796,D3
                sub.w   D3,D2
                bcc.s   L025C
                add.w   D2,D3
L025C:          sub.w   D1,D3
                mulu    #$00A0,D1
                movea.l komplettbild,A0
                movea.l scr1,A1
                tst.w   board_da
                bne.s   L025D
                move.w  grab_y,D2
                mulu    #$00A0,D2
                adda.w  D2,A0
L025D:          move.w  D0,D2
                lsr.w   #1,D2
                andi.w  #-8,D2
                add.w   D2,D1
                adda.w  D1,A0
                adda.w  D1,A1
                not.w   D0
                andi.w  #$000F,D0
                moveq   #0,D2
                bset    D0,D2
                move.w  D2,D1
                not.w   D1
                bra.s   L025F
L025E:          move.w  (A0)+,D0
                and.w   D2,D0
                and.w   D1,(A1)
                or.w    D0,(A1)+
                move.w  (A0)+,D0
                and.w   D2,D0
                and.w   D1,(A1)
                or.w    D0,(A1)+
                move.w  (A0)+,D0
                and.w   D2,D0
                and.w   D1,(A1)
                or.w    D0,(A1)+
                move.w  (A0)+,D0
                and.w   D2,D0
                and.w   D1,(A1)
                or.w    D0,(A1)+
                lea     $0098(A0),A0
                lea     $0098(A1),A1
L025F:          dbra    D3,L025E
L0260:          movem.l (SP)+,D0-D3/A0-A1
                rts
L0261:          movem.l D0-D3/A0-A1,-(SP)
                move.w  L0807,D0
                move.w  board_y,D1
                move.w  L0796,D2
                move.w  D0,D3
                add.w   D2,D3
                sub.w   D3,D1
                bcc.s   L0262
                add.w   D1,D2
                bmi.s   L0266
                beq.s   L0266
L0262:          movea.l komplettbild,A0
                movea.l scr2,A1
                mulu    #$00A0,D0
                adda.w  D0,A0
                adda.w  D0,A1
                tst.w   board_da
                bne.s   L0263
                move.w  grab_y,D1
                mulu    #$00A0,D1
                adda.w  D1,A0
L0263:          lsl.w   #3,D2
                bra.s   L0265
L0264:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
L0265:          dbra    D2,L0264
L0266:          movem.l (SP)+,D0-D3/A0-A1
                rts

L0267:          movem.l D0-D3/A0-A1,-(SP)
                move.w  L0807,D0
                move.w  board_y,D1
                cmp.w   D1,D0
                bcc.s   L026B
                move.w  L0796,D2
                move.w  D0,D3
                add.w   D2,D3
                sub.w   D3,D1
                bcc.s   L0268
                add.w   D1,D2
                bmi.s   L026B
                beq.s   L026B
L0268:          movea.l scr1,A0
                movea.l scr2,A1
                mulu    #$00A0,D0
                adda.w  D0,A0
                adda.w  D0,A1
                lsl.w   #3,D2
                bra.s   L026A
L0269:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
L026A:          dbra    D2,L0269
L026B:          movem.l (SP)+,D0-D3/A0-A1
                rts

;Kopiert Board von scr1 auf scr2
copy_board:     movem.l D0/A0-A1,-(SP)
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #160*100,D0
                adda.w  D0,A0
                adda.w  D0,A1
                move.w  #999,D0
L026D:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L026D
                movem.l (SP)+,D0/A0-A1
                rts

;Setzt die Auflîsung neu, und initialisiert den HBL neu, wegen TT
; D0.W: Neue Auflîsung (0..2)
set_resolution: movem.l D0-A6,-(SP)

                move.w  D0,newrez

                clr.l   -(SP)
                move.w  #$0020,-(SP)    ; Supervisor an
                trap    #1
                addq.l  #6,SP
                move.l  D0,-(SP)

                move.l  $00000070.w,oldvblvotze
                move.l  #myvbl,$00000070.w ; eigene VBL-Routine

                move.w  #$0020,-(SP)    ; Supervisor aus
                trap    #1
                addq.l  #6,SP

                move.w  newrez,-(SP)
                moveq   #-1,D0
                move.l  D0,-(SP)        ;Bildschirm lassen
                move.l  D0,-(SP)
                move.w  #5,-(SP)
                trap    #14
                lea     12(SP),SP

                clr.l   -(SP)
                move.w  #$0020,-(SP)    ; Supervisor an
                trap    #1
                addq.l  #6,SP
                move.l  D0,-(SP)
                move.l  oldvblvotze,$00000070.w

                move.w  #$0020,-(SP)    ; Supervisor aus
                trap    #1
                addq.l  #6,SP

                bsr     init_hbl        ;und Raster neu anschalten

                movem.l (SP)+,D0-A6
                rts

myvbl:          addq.l  #1,$00000466.w  ; nur kurz fÅr Setscreen
                rte

switch2tos:     movem.l D0-A6,-(SP)
                bset    #0,L07A6
                bne.s   L026F
                move.b  grid_on,save_grid
                clr.b   grid_on         ;Grid abschalten
L026F:          tst.b   tos_screen      ;Tos-Screen schon da?
                beq.s   nur_fÅllen      ;ja

                lea     fun_exit(PC),A0 ;verschiedene Routinen fÅr Zeichenfeld
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0
                clr.b   L076B
                jsr     (A0)            ;Zeichenfunktion disablen

                clr.b   tos_screen      ;Jetzt ist Tos-Screen da...
                tst.w   old_rez         ;Low-Rez?
                beq.s   switch2low      ;Nein

                linea   #0 [ Init ]
                move.w  mid_width,-$02B4(A0)
                move.w  mid_height,-$02B2(A0)
                move.w  mid_#_colors,-$029A(A0)

switch2low:     move.w  #-1,-(SP)
                move.l  copybox_screen,-(SP)
                move.l  copybox_screen,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                move.w  old_rez,D0
                bsr     set_resolution

nur_fÅllen:     move.l  #tos_pal,vbl_pal

                pea     tos_pal
                move.w  #6,-(SP)
                trap    #$0E
                addq.l  #6,SP

                clr.w   int_in          ;Desktop
                move.w  #4,int_in+2     ;WF_WORKXYWH
                move.l  #wind_get,D0
                bsr     _aes

                lea     int_out+2,A0
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                move.w  D0,D2
                move.w  D1,D3
                add.w   (A0)+,D2
                add.w   (A0)+,D3
                subq.w  #1,D2
                subq.w  #1,D3
                moveq   #2,D4
                moveq   #0,D5
                jsr     fill_box

                move.w  D1,D3
                moveq   #0,D1
                moveq   #0,D4           ;Weiû
                jsr     fill_box

                move.w  D3,D1
                moveq   #3,D4           ;Schwarz
                tst.w   old_rez
                bne.s   ok22
                moveq   #15,D4
ok22:           jsr     fill_box

                movem.l (SP)+,D0-A6
                rts

switch2neo:     movem.l D0-D1/A0-A1,-(SP)
                move.b  #-1,tos_screen  ;Jetzt ist Neochrome-Screen da
                clr.b   L07A6
                move.b  save_grid,grid_on
                tst.w   old_rez         ;Low-Rez?
                beq.s   L0278           ;Ja
L0277:          moveq   #0,D0
                bsr     set_resolution  ;Low-Rez einschalten

                linea   #0 [ Init ]     ;von Mid-Rez in Low-Rez
                move.w  #319,-$02B4(A0)
                move.w  #199,-$02B2(A0) ;FÅr Low-Rez initialisieren
                move.w  #16,-$029A(A0)
                move.w  #163,-$025A(A0) ;Mausx setzen
                move.w  #106,-$0258(A0) ;Mauxy setzen

L0278:          move.w  #-1,-(SP)
                move.l  scr1,-(SP)
                move.l  scr1,-(SP)      ;Screenbasis setzen
                move.w  #5,-(SP)
                trap    #$0E
                lea     12(SP),SP
                movem.l (SP)+,D0-D1/A0-A1
                rts

;Neue Farbe einrahmen, bzw. vorher alten Rahmen lîschen
L0279:          movem.w D0-D7,-(SP)
                move.b  colorx,D0
                sub.b   pos_color512,D0
                bcs.s   L027B           ;->RTS
                cmpi.b  #$0D,D0
                bcc.s   L027B           ;->RTS
                ext.w   D0
                move.b  colory,D1
                ext.w   D1
                bsr.s   del_hot_spot
                tst.w   D0
                beq.s   L027A
                tst.w   D1
                beq.s   L027A
                cmpi.w  #$000C,D0
                beq.s   L027A
                cmpi.w  #$000F,D1
                bne.s   L027B
L027A:          bsr.s   rahm_color
L027B:          movem.w (SP)+,D0-D7
                rts

;Lîscht den Rahmen um die Lupe fÅr Farbauswahl
del_rahm_color: movem.w D0-D6,-(SP)
                moveq   #0,D4
                bra.s   L027E

;Zeichnet den Rahmen um die Lupe fÅr Farbauswahl
rahm_color:     movem.w D0-D6,-(SP)
                moveq   #15,D4          ;Farbe
L027E:          move.w  #191,D2
                move.w  #194,D3
                bra.s   L0282

;Lîscht den Rahmen um die Lupe bei der Lupenarbeit
del_rahm_lupe:  movem.w D0-D6,-(SP)
                moveq   #0,D4
                bra.s   L0281

;Umrahmt die Lupe fÅr Lupenarbeit
rahm_lupe:      movem.w D0-D6,-(SP)
                moveq   #15,D4          ;Farbe
L0281:          move.w  #191,D2         ;Koordinaten
                move.w  #199,D3
L0282:          move.w  #126,D0
                move.w  #114,D1
                moveq   #0,D5
                moveq   #-1,D6
                bsr.s   rahmen
                movem.w (SP)+,D0-D6
                rts

;Lîscht in der Lupe den Hot-Spot
del_hot_spot:   movem.l D0-A0,-(SP)
                moveq   #0,D4           ;Farbe
                bra.s   L0285

;Zeichnet in der Lupe in der Mitte den Hot-Spot
draw_hot_spot:  movem.l D0-A0,-(SP)
                move.w  #$000F,D4       ;Farbe
L0285:          mulu    #5,D0
                addi.w  #126,D0
                mulu    #5,D1
                addi.w  #114,D1
                move.w  D0,D2
                move.w  D1,D3
                addi.w  #5,D2
                addi.w  #5,D3
                moveq   #0,D5
                moveq   #-1,D6
                bra.s   L0288

L0286:          movem.l D0-A0,-(SP)
                move.w  L07D0,D0
                move.w  L07D1,D1
                move.w  L07D2,D2
                move.w  L07D3,D3
                move.w  #2,D5
                move.w  #$000F,D4
                move.w  #-$5556,D6
                bra.s   L0288

;Zeichnet einen Rahmen
;Parameter:
;D0: x1
;D1: y1
;D2: x2
;D3: y2
;D4: farbe
;D5: Schreibmodus
;D6: Linientyp
rahmen:         movem.l D0-A0,-(SP)
L0288:          bsr     Hm
                movem.w D0-D6,-(SP)
                linea   #0 [ Init ]
                movem.w (SP)+,D0-D6
                move.w  #-1,32(A0)
                move.w  D6,34(A0)       ;Muster fÅr Linie
                move.w  D5,36(A0)       ;Schreibmodus
                move.w  #3,D6
L0289:          moveq   #0,D5
                lsr.w   #1,D4           ;d4=Farbe
                bcc.s   L028A
                addq.w  #1,D5
L028A:          move.w  D5,24(A0)
                addq.l  #2,A0
                dbra    D6,L0289
                subq.l  #8,A0
                cmp.w   D0,D2
                beq     L028F
                cmp.w   D1,D3
                beq     L028F
                move.w  D0,38(A0)
                move.w  D1,40(A0)       ;Koordinaten
                move.w  D2,42(A0)
                move.w  D1,44(A0)
                movem.l D0-D3/A0,-(SP)
                linea   #3 [ Line ]
                movem.l (SP)+,D0-D3/A0
                move.w  D2,38(A0)
                addq.w  #1,D1
                cmp.w   D1,D3
                bcc.s   L028B
                subq.w  #2,D1
L028B:          move.w  D1,40(A0)
                move.w  D2,42(A0)
                move.w  D3,44(A0)
                movem.l D0-D3/A0,-(SP)
                linea   #3 [ Line ]
                movem.l (SP)+,D0-D3/A0
                addq.w  #1,D2
                cmp.w   D2,D0
                bcc.s   L028C
                subq.w  #2,D2
L028C:          move.w  D2,38(A0)
                move.w  D3,40(A0)
                move.w  D0,42(A0)
                move.w  D3,44(A0)
                movem.l D0-D4/A0,-(SP)
                linea   #3 [ Line ]
                movem.l (SP)+,D0-D4/A0
                cmp.w   D3,D1
                beq.s   L028E
                addq.w  #1,D3
                cmp.w   D3,D1
                bcc.s   L028D
                subq.w  #2,D3
L028D:          move.w  D0,38(A0)
                move.w  D3,40(A0)
                move.w  D0,42(A0)
                move.w  D1,44(A0)
                linea   #3 [ Line ]
L028E:          movem.l (SP)+,D0-A0
                rts
L028F:          move.w  D0,38(A0)
                move.w  D1,40(A0)
                move.w  D2,42(A0)
                move.w  D3,44(A0)
                linea   #3 [ Line ]
                movem.l (SP)+,D0-A0
                rts


;Macht einen Bitblit-Transfer auf 320x200 Screens (CHS)
;Parameter:
;D0: x1
;D1: y1
;D2: breite
;D3: Hîhe
;D4: x2
;D5: y2
;A0: screen1
;A1: screen2
bitblt:         movem.l D0-A6,-(SP)

                lea     bb,A6           ;verschieben des Objektes nach 0/0

                move.w  D2,(A6)         ;Breite in Pixeln
                move.w  D3,2(A6)        ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #15,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                move.w  D0,14(A6)
                move.w  D1,16(A6)
                move.l  A0,18(A6)       ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  #160,24(A6)
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  D4,28(A6)       ;Zielkoordinaten
                move.w  D5,30(A6)
                move.l  A1,32(A6)       ;Zieladresse
                move.w  #8,36(A6)       ;Offset zurselben Plane
                move.w  #160,38(A6)
                move.w  #2,40(A6)
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                movem.l (SP)+,D0-A6
                rts

alle_irqs_aus:  move.w  #$2600,acia_irq_sr
                clr.w   evt_timer_aus
                rts

;Baut die Farbpaletten fÅr die Lupe auf
;Erwartet die Mauskoordinaten in d0/d1
check_lupe:     tst.w   board_da        ;Board da->Lupe zeichnen
                beq.s   L0292
                tst.b   magnify         ;Lupe im Fullscreen da?
                beq     make_lupe       ;ja, immer aufbauen
                movem.w D0-D2,-(SP)
                bra     L029F           ;Sonst Sm->RTS
L0292:          bclr    #1,mouse_pos    ;Work->Board || Board->Work?
                beq     make_lupe       ;Nein
                movem.w D0-D2,-(SP)
                bsr     Hm
                btst    #0,mouse_pos    ;Jetzt im Board?
                beq.s   L0293           ;ja->weiter
                bsr     scroller_aus    ;ggf. Scroller lîschen
                tst.b   copyr_work      ;Werden noch Copyrights durchgeschaltet?
                bmi.s   kein_copyright2 ;Nein, weiter
                move.b  #-1,copyr_work  ;ausschalten
                bsr     show_fn         ;Filenamen ausgeben
kein_copyright2:move.w  magtyp,D0       ;eigene Lupe?
                beq.s   neo_lupe
                movea.l scr1,A0
                jsr     clear_lupe      ;Lupenplatz lîschen
                bra.s   weiter6
neo_lupe:
;                cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
;                bne     L0295           ;ja->nicht Colorbox anschalten
                bsr     L0279           ;öbergang Board->Work
                bsr     del_rahm_color
                bsr     rahm_lupe
                moveq   #6,D0
                moveq   #8,D1
                bsr     draw_hot_spot
weiter6:        btst    #3,copy_status  ;Maus innerhalb Copybox?
                bne     L0295
                btst    #3,jack_status  ;Maus innerhalb Jack Knife?
                bne     L0295
                bsr     set_mouse       ;Entsprechenden Maustyp setzen
                bsr     clear_logo      ;Optionbox oben lîschen
                bra     L0295

L0293:          cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                bne     L0295           ;Ja->Nichts machen
                movem.w (SP),D0-D2      ;Mauskoordinaten holen
                st      lupe_an         ;groûe Lupe ist abgeschaltet
                bsr     draw_board
                bsr     del_rahm_lupe   ;öbergang Work->Board
                bsr     rahm_color
                moveq   #15,D0          ;Pfeil im Board
                bsr     set_mouse_d0
                bclr    #3,copy_status
                move.b  copy_status,D0
                andi.b  #3,D0
                cmpi.b  #2,D0
                bne.s   L0294
                bsr     L01D3
L0294:          bsr     L02A0
                move.w  #6,D0
                move.w  #8,D1
                bsr     del_hot_spot
                move.b  colorx,D0
                sub.b   pos_color512,D0
                bcs.s   L0295
                cmpi.b  #$0D,D0
                bcc.s   L0295
                move.b  colory,D1
                ext.w   D0
                ext.w   D1
                bsr     draw_hot_spot
L0295:          bsr     copy_board
                movem.w (SP)+,D0-D2
make_lupe:      movem.w D0-D2,-(SP)
                btst    #0,mouse_pos    ;Maus im Board?
                bne.s   keine_fix       ;Nein->Lupe zeichnen
                cmpi.l  #-1,maus_lupex  ;Keine Fixe Lupe?
                beq     L029F           ;ja->RTS
                tst.w   magtyp          ;Original NEO-Lupe?
                beq     L029F           ;ja->Keine Lupe
                movem.w maus_lupex,D0-D1 ;Sonst Koordinaten holen
keine_fix:      tst.b   lupe_paint      ;Wird innerhalb der Lupe gezeichnet?
                bne.s   no_inside
                movem.w maus_lupex,D0-D1 ;Sonst Mauskoordinaten holen
no_inside:      movea.l scr1,A0         ;hier ist Maus

                tst.w   board_da        ;Wenn kein Board da -> normale Lupe
                bne.s   normal_mag
                move.w  magtyp,D3       ;Normale Lupe?
                beq.s   normal_mag

                movem.l D0-A4,-(SP)     ;Koordinaten retten
                add.w   D3,D3
                lea     hotspot_y,A0
                sub.w   0(A0,D3.w),D1   ;Wegen Hotspot der Lupe, kann negativ werden
                lea     lupen_pal,A0    ;in welcher Scanline ist welcher Raster?
                add.w   D1,D1
                adda.w  D1,A0

                move.w  magtyp,D1
                lea     lupen_hîhe,A1   ;Anzahl an Raster zu setzen
                move.b  0(A1,D1.w),D1
                lea     raster_big_lupe,A2 ;Hier die Raster aufbauen

raster_setzen:  move.w  (A0)+,D0        ;Nummer des Rasters in dieser Zeile
                lea     hbl_system,A1
                mulu    #34,D0
                adda.l  D0,A1
                movem.l 2(A1),D2-D7/A3-A4 ;Palette holen
                movem.l D2-D7/A3-A4,(A2)
                lea     32(A2),A2
                dbra    D1,raster_setzen

                movem.l (SP)+,D0-A4
                moveq   #0,D2
                addq.w  #1,D3
                bset    D3,D2           ;und Typ wÑhlen
                jsr     big_lupe

                movem.w (SP),D0-D2
                bra     L029F           ;->Raus

normal_mag:     lea     lupe,A1
                lea     hbl_system+2,A2
                move.w  rst_akt,D2
                mulu    #34,D2
                adda.l  D2,A2           ;=Adresse der aktuellen Palette
                move.w  #16,lupe_hîhe
                tst.w   board_da
                beq.s   lupe_16         ;->Lupe ist 16 KÑstchen hoch
                move.w  lupe_y,lupe_hîhe
lupe_16:        move.w  lupe_hîhe,D2
                lsr.w   #1,D2           ;Lupenhîhe halbieren
                move.w  #-1,L0801
                sub.w   D2,D1           ;Mausy-=8
                bcc.s   L0299           ;oberhalb von 0->nicht clippen
                add.w   D1,lupe_hîhe    ;von Lupenhîhe abziehen
                eori.w  #-1,D1
                movea.l rasters,A2
                move.w  2(A2),D2        ;Hintergrundfarbe VBL-Palette holen
L0297:          move.w  #12,D7
L0298:          move.w  D2,(A1)+        ;Zeile fÅllen
                dbra    D7,L0298        ;Oberen Teil der Lupe clippen mit Back
                dbra    D1,L0297
                moveq   #0,D1           ;Jetzt in Zeile 0 beginnen
L0299:          move.w  D1,D7           ;Y-Wert
                add.w   D7,D7           ;verdoppeln
                lea     lupen_pal,A3
                adda.w  D7,A3           ;=Basis in der Lupe
                move.w  (A3)+,D7        ;Nummer der Palette in dieser Zeile
                mulu    #34,D7
                lea     hbl_system+2,A2 ;Adresse der Palette
                adda.l  D7,A2
                mulu    #160,D1         ;Y-Wert berechnen
                subi.w  #6,D0           ;x-=6
                bcc.s   L029B           ;Grîûer Null->Links nicht clippen
                add.w   #16,D0
                suba.w  #8,A0
                move.w  D0,D2
                add.w   D2,D2
                move.w  L029A(PC,D2.w),L0801
                bra.s   L029B

L029A:                  DC.W 0
                        DC.B $00,$01,$00,$03,$00,$07,$00,$0F
                        DC.B $00,$1F,$00,$3F,$00,$7F,$00,$FF
                        DC.B $01,$FF,$03,$FF,$07,$FF,$0F,$FF
                        DC.B $1F,$FF,$3F,$FF,$7F,$FF,$FF,$FF

L029B:          move.w  D0,D2
                add.w   #13,D2
                subi.w  #320,D2
                bls.s   L029C           ;Kleiner 320->rechts nicht clippen
                add.w   #$0010,D2
                sub.w   #$000D,D2
                add.w   D2,D2
                move.w  L029A(PC,D2.w),D2
                eori.w  #-1,D2
                move.w  D2,L0801
L029C:          move.w  D0,D2
                andi.w  #15,D2
                lsr.w   #1,D0
                andi.w  #%1111111111111000,D0
                add.w   D0,D1
L029D:          movem.w 0(A0,D1.w),D3-D6 ;Planes holen
                swap    D3
                swap    D4
                swap    D5
                swap    D6
                move.w  8(A0,D1.w),D3
                move.w  10(A0,D1.w),D4
                move.w  12(A0,D1.w),D5
                move.w  14(A0,D1.w),D6
                lsl.l   D2,D3
                lsl.l   D2,D4
                lsl.l   D2,D5
                lsl.l   D2,D6
                move.w  L0801,D7
                swap    D7
                or.w    #-1,D7
                and.l   D7,D3
                and.l   D7,D4
                and.l   D7,D5
                and.l   D7,D6
                move.w  #12,D7          ;13 Farben in der Lupe
L029E:          moveq   #0,D0
                addx.l  D6,D6
                addx.w  D0,D0
                addx.l  D5,D5
                addx.w  D0,D0
                addx.l  D4,D4
                addx.w  D0,D0
                addx.l  D3,D3
                addx.w  D0,D0
                add.w   D0,D0
                move.w  0(A2,D0.w),(A1)+ ;Farbwert setzen
                dbra    D7,L029E
                addi.w  #160,D1         ;Eine Scanline tiefer

                move.w  (A3)+,D7        ;Nummer der Palette in dieser Zeile
                mulu    #34,D7
                lea     hbl_system+2,A2 ;Adresse der Palette
                adda.l  D7,A2

                subq.w  #1,lupe_hîhe
                bpl.s   L029D
L029F:          bsr     Sm
                movem.w (SP)+,D0-D2
                rts

L02A0:          movem.l D0-D1/A0-A1,-(SP)
                lea     color512,A0
                lea     lupe,A1
                move.b  pos_color512,D0
                ext.w   D0
                lsl.w   #5,D0
                adda.w  D0,A0
                move.w  #$000C,D1
L02A1:          move.l  A1,-(SP)
                move.w  #$000F,D0
L02A2:          move.w  (A0)+,(A1)
                lea     $001A(A1),A1
                dbra    D0,L02A2
                movea.l (SP)+,A1
                addq.w  #2,A1
                dbra    D1,L02A1
                bsr.s   clear_bottom_lupe
                movem.l (SP)+,D0-D1/A0-A1
                rts

hotspot_y:              DC.W 8,10,4,2 ;Hotspotwerte der groûen Lupe
hotspot_x:              DC.W 6,23,11,5 ;-"-
lupen_hîhe:             DC.B 16,20,9,4 ;Hîhe der Lupe in KÑsten-1
lupen_breite:           DC.B 13,48,24,12 ;Breite der Lupe
lupen_zoom:             DC.B 5,4,8,16 ;Vergrîûerung der Lupe

;Damit wird die unterste Zeile der Lupe gelîscht, wenn die Maus
;im Board ist, da dort das Board nur 16 Zeilen hoch ist.
clear_bottom_lupe:movem.l D0-D1/A0,-(SP)
                lea     board_palette(PC),A0
                move.w  (A0),D0
                moveq   #0,D0
                moveq   #12,D1          ;13 mal Hintergrundfarbe schreiben
                lea     last_hbl_pal,A0
L02A4:          move.w  D0,(A0)+
                dbra    D1,L02A4
                movem.l (SP)+,D0-D1/A0
                rts

;Printet den RGB-Wert der aktuellen Farbe
print_rgb:      cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                bne.s   kein_rgb2       ;Ja
                movem.l D0-A1,-(SP)
                lea     color512,A0
                move.b  colorx,D0
                move.b  colory,D1
                ext.w   D0
                ext.w   D1
                lsl.w   #4,D0
                add.w   D0,D1
                add.w   D1,D1
                move.w  0(A0,D1.w),D1
                move.w  D1,color        ;Farbe holen und setzen
                lea     L038D(PC),A0    ;Ende von '000'
                moveq   #2,D3
L02A6:          move.w  D1,D2
                tst.w   ste_support     ;ist hier ein STE?
                bne.s   normal_st
                and.w   #15,D2          ;4 gÅltige Bits
                move    #16,CCR         ;X setzen
                bclr    #3,D2           ;oberstes Bit lîschen
                bne.s   bit_gesetzt
                move    #0,CCR          ;X lîschen
bit_gesetzt:    addx.w  D2,D2           ;und von unten wieder reinschieben
                bra.s   till5
normal_st:      and.w   #7,D2
till5:          move.b  comp_digit(PC,D2.w),-(A0)
                lsr.w   #4,D1           ;und nÑchstes Nibble
                dbra    D3,L02A6
                move.w  #$00D4,D0
                move.w  #$0076,D1
                lea     L038C(PC),A0    ;'000'
                bsr     print8x8
                movem.l (SP)+,D0-A1
kein_rgb2:      rts

comp_digit:             DC.B 'ABCDEF'

set_mouse_d0:   movem.l D0/A0,-(SP)     ;Setzt Maus wie in d0
                bra.s   L02AA

set_mouse:      movem.l D0/A0,-(SP)
                move.b  function,D0     ;je nach aktuelle Funktion
L02AA:          ext.w   D0
                lsl.w   #2,D0
                lea     zeiger_table,A0
                move.l  0(A0,D0.w),intin_pt ;Mauszeiger setzen

                move.l  #vsc_form,D0
                bsr     _vdi
                move.l  #int_in,intin_pt ;Altes intin wieder setzem

                movem.l (SP)+,D0/A0
                rts

;User hat von Jack Knife in Copybox gewechselt
transfer2copybox:movem.l D0-A6,-(SP)

                move.b  jack_status,D0
                and.b   #%00000001,D0   ;Ist was selektiert?
                beq.s   no_transfer1

                bsr     jack_cut        ;Ausschneiden
                clr.w   copycut

no_transfer1:   movem.l (SP)+,D0-A6
                rts

;User hat von Coybox in Jack Knife gewechselt
transfer2jack:  movem.l D0-A6,-(SP)

                move.b  copy_status,D0
                and.b   #%00000001,D0   ;Ist was selektiert?
                beq.s   no_transfer2

                bsr     copy_cut        ;Ausschneiden
                clr.w   copycut

no_transfer2:   movem.l (SP)+,D0-A6
                rts


;Es hat ein Transfer Jack Knife<->Copybox stattgefunden:
;Jetzt wieder bei neuer Funktion einfÅgen:
jack_copy_paste:movem.l D0-A6,-(SP)

                tst.w   copycut         ;Wurde was tranferiert?
                bne.s   kein_transfer4

                move.w  #1,copycut      ;Kein Transfer mehr....
                tst.b   function        ;Jetzt Jack Knife?
                bne.s   copy_p
                bsr     jack_paste
                bra.s   kein_transfer4
copy_p:         bsr     copy_paste
kein_transfer4: movem.l (SP)+,D0-A6
                rts

;Schaltet den entsprechenden Arbeitsscreen an (CHS)
;Parameter:
;D0: Neuer Screen (0..anz_screens-1)
show_workscreen:movem.l D0-A6,-(SP)     ;Register sichern
                tst.w   D0
                bmi     nichts_Ñndern
                cmp.w   anz_screens,D0  ;PrÅfen
                bge     nichts_Ñndern

                move.w  D0,-(SP)        ;Screennr retten

                bsr     Hm              ;Maus hier weg

                move.w  #1,copycut

                tst.b   function        ;Jack Knife?
                beq.s   rette_jack
                cmpi.b  #2,function     ;Copy Box?
                bne.s   no_rette

;Copybox aktiviert:
                move.b  copy_status,D0
                and.b   #%00000001,D0   ;Rahmen da und fertig?
                beq.s   no_rette        ;Nein->weiter

                bsr     copy_cut        ;und auschneiden bitte
                clr.w   copycut         ;merken
                bra.s   no_rette

rette_jack:     move.b  jack_status,D0
                and.b   #%00000001,D0   ;Rahmen da und fertig?
                beq.s   no_rette

                bsr     jack_cut
                clr.w   copycut

no_rette:       lea     fun_exit(PC),A0 ;Tabelle
                move.b  function,D7
                ext.w   D7
                lsl.w   #2,D7
                movea.l 0(A0,D7.w),A0
                jsr     (A0)            ;laufende Funktion abschalten...

                move.b  function,D7
                move.b  #10,function    ;Nicht Copybox
                bsr     put_work_sure   ;Erstmal Komplettbild erstellen
                move.b  D7,function     ;Originalfunktion wieder an

                move.w  akt_work,D7     ;Alten Screen
                mulu    #13,D7
                lea     fn_screens,A1   ;Alten Filenamen retten
                adda.l  D7,A1
                lea     picture_neo,A0
copy1:          move.b  (A0)+,(A1)+
                bne.s   copy1

                move.w  akt_work,D7     ;Alten Screen
                lea     changes,A0
                move.b  changed,0(A0,D7.w) ;Alten changed-Wert merken

                add.w   D7,D7
                lea     grab_tab,A0     ;Grabber Tabelle
                move.w  grab_y,0(A0,D7.w) ;Alten Grabberwert sichern

                move.w  akt_work,D7     ;alten Screen
                mulu    #2*anz_raster*(1+16),D7
                movea.l hbls,A1
                adda.l  D7,A1
                lea     hbl_system,A0
                move.w  #anz_raster*(1+16)-1,D7 ;Alte Raster retten
lhjh:           move.w  (A0)+,(A1)+
                dbra    D7,lhjh

                move.w  akt_work,D7
                add.w   D7,D7
                lea     rst_tab,A0
                move.w  rst_akt,0(A0,D7.w) ;Alten Raster merken

                move.w  akt_work,D7
                lsl.w   #2,D7
                lea     col_tab,A0
                adda.l  D7,A0
                move.b  hintergrundfarbe+1,(A0)+
                move.b  zeichenfarbe+1,(A0)+ ;Alte Farben abspeichern
                move.b  left_col_mark+1,(A0)+
                move.b  right_col_mark+1,(A0)+
                bsr     del_farb_ecke   ;Alte Zeichenfarbe lîschen
                bsr     del_left_col_mark
                bsr     del_right_col_mark

                move.w  (SP)+,D0
                move.w  D0,akt_work     ;Das ist jetzt der aktuelle Screen
                move.w  D0,D7           ;0..anz_screens-1
                lea     work_tab,A0     ;Tabelle der Screens
                lsl.w   #2,D0
                move.l  0(A0,D0.w),komplettbild ;Neues Arbeitsbild

                move.w  akt_work,D7
                lsl.w   #2,D7
                lea     col_tab,A0
                adda.l  D7,A0
                move.b  (A0)+,hintergrundfarbe+1
                move.b  (A0)+,zeichenfarbe+1 ;Neue Farben setzen
                move.b  (A0)+,left_col_mark+1
                move.b  (A0)+,right_col_mark+1
                bsr     set_farb_ecke   ;und neue Farbe anschalten
                bsr     draw_left_col_mark
                bsr     draw_right_col_mark

                move.w  akt_work,D0
                add.w   D0,D0
                lea     grab_tab,A0     ;Neuen Grab_y setzen
                move.w  0(A0,D0.w),grab_y

                bsr     show_komplett   ;Bringt Bild zur Anzeige

                move.w  akt_work,D7
                add.w   D7,D7
                lea     rst_tab,A0
                move.w  0(A0,D7.w),rst_akt ;Neue Raster setzen

                move.w  akt_work,D7     ;alten Screen
                mulu    #2*anz_raster*(1+16),D7
                movea.l hbls,A0
                adda.l  D7,A0
                lea     hbl_system,A1
                move.w  #anz_raster*(1+16)-1,D7 ;Neue Raster setzen
lhjh2:          move.w  (A0)+,(A1)+
                dbra    D7,lhjh2

                bsr     palette_changed ;Neue Raster anzeigen

                move.w  akt_work,D7     ;Neuer Screen
                lea     changes,A0
                move.b  0(A0,D7.w),changed ;Alten Changed-Status holen

                move.w  akt_work,D7
                mulu    #13,D7
                lea     fn_screens,A0
                adda.l  D7,A0
                lea     picture_neo,A1
copy2:          move.b  (A0)+,(A1)+     ;Neuen Filenamen kopieren
                bne.s   copy2

                bsr     show_fn_border  ;im Rand immer anzeigen
                tst.w   board_da
                bne.s   no_show2
                bsr     show_fn         ;Neuen Filenamen anzeigen
no_show2:       lea     fun_init(PC),A0
                move.b  function,D7
                lsl.w   #2,D7
                ext.w   D7
                movea.l 0(A0,D7.w),A0   ;Funktion reaktivieren
                jsr     (A0)

                tst.w   copycut         ;Wurde vorher was ausgeschnitten?
                bne.s   no_cut
                bsr     jack_copy_paste ;Wieder einfÅgen
no_cut:         bsr     Sm              ;und Maus wieder an

nichts_Ñndern:  movem.l (SP)+,D0-A6     ;Register wieder holen
                rts

;Bringt Komplettbild zur Anzeige, je nach Board und grab_y
show_komplett:  movem.l D0-A3,-(SP)
                bsr     Hm
                movea.l komplettbild,A1
                move.w  #7999,D0
                tst.w   board_da
                bne.s   L02AC2
                move.w  grab_y,D0
                mulu    #$00A0,D0
                adda.w  D0,A1
                move.w  #3999,D0
L02AC2:         move.b  function,D1     ;Jack Knife?
                bne.s   L02AE2          ;Nein
                btst    #3,jack_status
                beq.s   L02AD2
                bsr     set_mouse
L02AD2:         movem.l D0/A1,-(SP)
                bsr     L00E1
                bsr     redraw_copy_opt
                movem.l (SP)+,D0/A1
                bra.s   L02B12
L02AE2:         cmp.b   #7,D1           ;Cutter?
                beq.s   cut32           ;ja
                cmpi.b  #2,D1           ;Copybox?
                bne.s   L02B02          ;Nein...
                btst    #3,copy_status  ;Maus innerhalb Umrahmung?
                beq.s   L02AF2          ;Nein
                bsr     set_mouse       ;Pfeil an
L02AF2:         movem.l D0/A1,-(SP)
                bsr     copybox_exit    ;copybox abschalten
                bsr     redraw_copy_opt
                movem.l (SP)+,D0/A1
                bra.s   L02B12
cut32:          movem.l D0/A1,-(SP)     ;Cutter ist aktiv
                bsr     cutter_exit
                bsr     redraw_cut_opt
                movem.l (SP)+,D0/A1
L02B02:         cmpi.b  #3,D1           ;Text?
                bne.s   L02B12          ;nein...
                bsr     text_exit
L02B12:         movea.l scr1,A0
L02B22:         move.l  (A1)+,(A0)+     ;von Komplettbild auf Screen
                dbra    D0,L02B22
                move.b  #-$80,L07A1
                movem.l (SP)+,D0-A3
                rts

;Vertauscht scr1 und komplettbild
do_undo:        movem.l D0-A3,-(SP)
                bsr     Hm
                movea.l komplettbild,A1
                move.w  #7999,D0
                tst.w   board_da
                bne.s   L02AC
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A1
                move.w  #3999,D0
L02AC:          move.b  function,D1     ;Jack Knife?
                bne.s   L02AE           ;Nein
                btst    #3,jack_status
                beq.s   L02AD
                bsr     set_mouse
L02AD:          movem.l D0/A1,-(SP)
                bsr     L00E1
                bsr     redraw_copy_opt
                movem.l (SP)+,D0/A1
                bra.s   L02B1
L02AE:          cmpi.b  #2,D1           ;Copybox?
                bne.s   L02B0           ;Nein...
cut3:           btst    #3,copy_status
                beq.s   L02AF
                bsr     set_mouse
L02AF:          movem.l D0/A1,-(SP)
                bsr     copybox_exit
                bsr     redraw_copy_opt
                movem.l (SP)+,D0/A1
                bra.s   L02B1
L02B0:          cmp.w   #7,D1           ;Cutter?
                bne.s   L02B03
                btst    #3,copy_status  ;Maus innerhalb Box?
                beq.s   L02AF3
                bsr     set_mouse
L02AF3:         movem.l D0/A1,-(SP)
                bsr     cutter_exit
                bsr     redraw_cut_opt
                movem.l (SP)+,D0/A1
                bra.s   L02B1
L02B03:         cmpi.b  #3,D1           ;Text?
                bne.s   L02B1           ;nein...
                bsr     text_exit
L02B1:          movea.l scr1,A0
L02B2:          move.l  (A0),D1
                move.l  (A1),(A0)+      ;vertauschen....
                move.l  D1,(A1)+
                dbra    D0,L02B2
                move.b  #-$80,L07A1
                movem.l (SP)+,D0-A3
                rts

;Wartet, die Mausknopf losgelassen wird... (CHS)
wait_los:       movem.l D0-A6,-(SP)     ;Register retten

wait_loop:      bsr     get_maus
                bne.s   wait_loop

                movem.l (SP)+,D0-A6     ;und wieder her
                rts

;Die folgenden Routinen werden von taste_func angesprungen, wenn die Cursortasten gedrÅckt
;werden:
clear_home:     move.b  function,D0
                cmp.b   #1,D0           ;Grabber?
                beq.s   clear_it
                cmp.b   #4,D0           ;Draw?
                beq.s   clear_it
                cmp.b   #6,D0           ;Fill?
                beq.s   clear_it
                cmp.b   #5,D0           ;Line?
                beq.s   clear_it
                cmp.b   #8,D0           ;Raster?
                beq.s   clear_it
                cmp.b   #9,D0           ;Brush/Nozzle?
                beq.s   clear_it
                cmp.b   #10,D0          ;Eraser/Disk?
                beq.s   clear_it
                rts

;Lîscht den Arbeitsscreen
clear_it:       movem.l D0-A6,-(SP)
                tst.b   changed         ;wurde was verÑndert?
                bne.s   clear_all       ;Nein, lîschen
                move.l  #erase_alert,D0 ;Erase all?..
                bsr     switch_alert
                cmpi.w  #1,int_out      ;Okay
                bne.s   to_rts22        ;Nein, also verschonen
clear_all:      clr.w   grab_y
                move.b  #-1,changed

                movea.l komplettbild,A0
                moveq   #0,D0
                move.w  #1999,D1
L014F:          move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+        ;Komplettbild lîschen
                move.l  D0,(A0)+
                dbra    D1,L014F

                movea.l scr1,A0
                moveq   #0,D0
                move.w  #999,D1
                tst.w   board_da
                beq.s   L0152
                move.w  #1999,D1
L0152:          move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                dbra    D1,L0152
to_rts22:       movem.l (SP)+,D0-A6
                rts

cursor_right:   cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                beq.s   do_right        ;Nein->Funktion

                addi.w  #1,maus_lupex
                cmpi.w  #319,maus_lupex
                ble.s   end_right
                move.w  #319,maus_lupex
                bra.s   end_right

do_right:       jsr     one_rechts

end_right:      rts

cursor_left:    cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                beq.s   do_left         ;Nein->Funktion

                subi.w  #1,maus_lupex
                bpl.s   end_left
                clr.w   maus_lupex
                bra.s   end_left

do_left:        jsr     one_links       ;Normale Links-Routine
end_left:       rts


cursor_up:      cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                beq.s   do_up           ;Nein->Funktion

                subi.w  #1,maus_lupex+2
                bpl.s   end_up
                clr.w   maus_lupex+2
                bra.s   end_up

do_up:          jsr     speed_up
end_up:         rts

cursor_down:    cmpi.l  #-1,maus_lupex  ;Fixierte Lupe?
                beq.s   do_down         ;Nein->Funktion

                addq.w  #1,maus_lupex+2
                cmpi.w  #99,maus_lupex+2
                ble.s   end_down
                move.w  #99,maus_lupex+2
                bra.s   end_down

do_down:        jsr     speed_down
end_down:       rts


;Fragt die Position der Maus ab (CHS):
get_mouse_pos:  movem.l D0-A6,-(SP)

                move.l  #vq_mouse,D0
                bsr     _vdi

                tst.l   taste           ;Noch Taste da?
                bne.s   noch_da         ;Ja, auswerten
                bsr     Bconstat        ;Zeichen von Tastatur da?
                beq.s   noch_da         ;nein, weiter
                bsr     Kbshift
                bsr     Bconin          ;Zeichen abholen
                move.l  D0,taste        ;und merken
noch_da:        cmpi.w  #9,taste+2      ;Tab?
                bne.s   kein_tab

                move.l  #-1,maus_lupex  ;Keine feste Lupe mehr
                clr.l   taste           ;Taste ist ausgewertet

                bsr     get_shift
                tst.b   any_shift       ;Irgendeine Shifttaste gedrÅckt?
                bne.s   kein_tab        ;kein shift->Lupe loslassen

                move.l  ptsout,maus_lupex ;Und Koordinaten merken
                bsr     Hm
                movem.w maus_lupex,D0-D1 ;Koordinaten holen
                bsr     make_lupe       ;und anzeigen

kein_tab:       move.b  lupe_paint,D7   ;Alter Lupenpaint status
                st      lupe_paint      ;Es wird nicht in der Lupe gezeichnet

                cmpi.l  #-1,maus_lupex  ;Fixe Lupe vorhanden?
                beq     no_lupe

                tst.w   board_da
                bne     no_lupe
                cmpi.w  #126,ptsout     ;Innerhalb der Lupe geklickt?
                ble     no_lupe2
                cmpi.w  #113,ptsout+2
                ble     no_lupe2

                movem.w ptsout,D0-D1    ;X/Y holen
                subi.w  #127,D0
                subi.w  #115,D1
                move.w  magtyp,D4       ;Original-Neo-Lupe?
                bne.s   no_original     ;Nein
                cmpi.w  #190,ptsout     ;Rechts der Lupe?
                bgt.s   no_lupe2        ;Ja, ausserhalb der Lupe
no_original:    lea     lupen_zoom,A0
                moveq   #0,D3
                move.b  0(A0,D4.w),D3   ;Vergrîûerung holen
                ext.l   D0
                ext.l   D1
                divu    D3,D0
                divu    D3,D1
                add.w   D4,D4
                add.w   maus_lupex,D0
                lea     hotspot_x,A0
                sub.w   0(A0,D4.w),D0
                add.w   maus_lupex+2,D1
                lea     hotspot_y,A0
                sub.w   0(A0,D4.w),D1

                tst.w   D0              ;Auf Bildschirmrand clippen
                bpl.s   hiller1
                moveq   #0,D0
hiller1:        cmp.w   #319,D0
                ble.s   hiller2
                move.w  #319,D0
hiller2:        tst.w   D1
                bpl.s   hiller3
                moveq   #0,D1
hiller3:        cmp.w   #99,D1
                ble.s   hiller4
                moveq   #99,D1

hiller4:        movem.w D0-D1,ptsout    ;und geÑnderte Mauskoordinaten eintragen
                clr.b   lupe_paint      ;Es wird in der Lupe gezeichnet
                bra.s   no_lupe

no_lupe2:       tst.b   D7              ;Vorher innerhalb der Lupe gezeichnet?
                bne.s   no_lupe         ;Nein->Okay
                clr.w   int_out         ;Ja->Maustasten lîschen

no_lupe:        movea.l rasters,A0
                tst.w   (A0)            ;öberhaupt Raster da?
                bmi     no_auswert      ;Nein, gleich weiter

                cmpi.w  #32,taste+2     ;Space gedrÅckt?
                bne.s   weiter_jetzt    ;Nein->Weiter
                cmpi.b  #3,function     ;Textmodus?
                bne.s   auswerten       ;Nein, Space nehmen
                btst    #1,text_status  ;Cursor zu sehen?
                bne.s   weiter_jetzt    ;Ja, an Textroutine Åbergeben

auswerten:      clr.l   taste           ;Taste ist ausgewertet

                move.w  #200,D0
                tst.w   board_da
                bne.s   ok23
                moveq   #100,D0
ok23:           move.w  ptsout+2,D1     ;Maus_y
                cmp.w   D0,D1           ;Ist Maus im Board?
                bge.s   weiter_jetzt    ;Ja, nichts machen
                add.w   D1,D1           ;verdoppeln
                lea     lupen_pal,A0
                move.w  0(A0,D1.w),rst_akt ;Und neue Palette auswÑhlen
                bsr     neue_palette

weiter_jetzt:   move.w  #200,D0
                tst.w   board_da
                bne.s   ok232
                moveq   #100,D0
ok232:          move.w  ptsout+2,D1     ;Y
                cmp.w   D0,D1           ;im Board?
                bge.s   akt_palette     ;Ja, rst_akt nehmen
                lea     lupen_pal,A0
                add.w   D1,D1           ;mal 4
                move.w  0(A0,D1.w),D0   ;Nummer der Boardpalette
auswert:        mulu    #34,D0
                lea     hbl_system+2,A0
                adda.l  D0,A0
                movem.l (A0),D0-D7
                movem.l D0-D7,board_palette ;und Palette merken

no_auswert:     movem.l (SP)+,D0-A6
                rts

akt_palette:    move.w  rst_akt,D0
                bra.s   auswert         ;und weiter

;Holt die Mauskoordinaten und wertet die Maustaste aus
;RÅckgabe:
;D0: mausx
;D1: mausy
;D2: maus_button:
;               Bit 0 gesetzt: links gedrÅckt
;               Bit 1 gesetzt: rechts gedrÅckt
;               Bit 2 gesetzt: links neu gedrÅckt
;               Bit 3 gesetzt: rechts neu gedrÅckt
;               Bit 4 gesetzt: links neu losgelassen
;               Bit 5 gesetzt: rechts neu losgelassen
;               Bit 6 gesetzt: Doppelklick links (nicht sehr zuverlÑssig)
;               Bit 7 gesetzt: Doppelklick rechts (-'-)
;               Bit 14 gesetzt: Taste ist gekommen
;               Bit 15 gesetzt: Mausposition verÑndert
;D3: Alte Mausx
;D4: Alte Mausy
get_maus:       bsr     get_mouse_pos   ;Mausposition erfragen
                move.w  int_out,D2      ;Mousekeys
                andi.w  #%0000000000000011,D2 ;Nur 2 Maustasten
                bne.s   gedrÅckt        ;Es ist eine gedrÅckt....
                move.w  #-1,repeat_control ;Und kein Repeat mehr bitte
gedrÅckt:       move.w  D2,-(SP)
                tst.l   taste           ;Noch Taste da?
                bne.s   L02B5
                bsr     Bconstat        ;Zeichen von Tastatur da?
                beq.s   L02B6           ;nein, weiter
                bsr     get_mouse_pos   ;ja, Space auswerten
L02B5:          ori.w   #$4000,(SP)     ;in Mausstatus odern
L02B6:          move.w  (SP)+,D2        ;und wieder holen
                lea     ptsout,A0
                move.w  (A0)+,D0        ;X
                move.w  (A0),D1         ;Y
                lea     mousex,A0
                move.w  (A0)+,D3        ;alte X
                move.w  (A0)+,D4        ;alte Y
                move.w  (A0),D5         ;alte Maustaste holen
                move.w  D2,(A0)         ;neue Maustaste speichern
                move.w  D1,-(A0)        ;neue Y
                move.w  D0,-(A0)        ;neue X
                eor.w   D2,D5           ;vergleichen der Mausstati
                btst    #0,D5           ;links Maustaste verÑndert?
                beq.s   L02B9           ;nein
                moveq   #2,D6           ;Bit 2 gesetzt->links neu gedrÅckt
                btst    #0,D2           ;Jetzt gedrÅckt?
                bne.s   L02B7           ;Ja, vorher war nicht gedrÅckt
                move.b  #-$0A,L079C
                moveq   #4,D6           ;Bit 4 gesetzt->links losgelassen
                bra.s   L02B8
L02B7:          tst.b   L079C
                bpl.s   L02B8
                bset    #6,D2
L02B8:          bset    D6,D2           ;entsprechendes Bit setzen
L02B9:          btst    #1,D5           ;Hat sich rechts was geÑndert?
                beq.s   L02BC           ;nein
                moveq   #3,D6           ;Bit 3 gesetzt->rechts neu gedrÅckt
                btst    #1,D2           ;Jetzt rechts gedrÅckt?
                bne.s   L02BA           ;Ja, vorher war nicht gedrÅckt
                move.b  #-$0A,L079D
                moveq   #5,D6           ;Bit 5 gesetzt->rechts neu losgelassen
                bra.s   L02BB
L02BA:          tst.b   L079D
                bpl.s   L02BB
                bset    #7,D2
L02BB:          bset    D6,D2           ;entsprechendes Bit setzen
L02BC:          move.b  mouse_pos,D7
                move.w  D2,D5           ;neuer Mausstatus
                or.b    L062A,D5
                btst    #2,D7
                beq.s   L02C0
                andi.w  #%0000000000110011,D5
                bne.s   L02BD
                bclr    #2,D7
                bset    #1,D7
                bra.s   L02C0
L02BD:          move.w  board_y,D6
                subq.w  #1,D6
                cmp.w   D1,D6           ;Y
                bcs.s   L02BE
                bclr    #2,D7
                bra.s   L02C0
L02BE:          tst.b   grid_on
                beq.s   L02BF
                move.w  grab_y,D6
                andi.w  #7,D6
                move.b  L02C3(PC,D6.w),D6
L02BF:          move.w  D6,D4
                move.w  D6,D1
                move.w  D1,mousey
L02C0:          cmp.w   board_y,D1
                bcs.s   L02C5
                clr.w   L078C
                bclr    #0,D7
                beq.s   L02C6
                andi.w  #3,D5
                bne.s   L02C1
                bclr    #0,L07A3
                bra.s   L02C4
L02C1:          moveq   #5,D7
                move.w  board_y,D1
                subq.w  #1,D1
                tst.b   grid_on
                beq.s   L02C2
                move.w  grab_y,D1
                andi.w  #7,D1
                move.b  L02C3(PC,D1.w),D1
L02C2:          move.w  D1,mousey
                move.w  #-1,L078C
                bra.s   L02C6

L02C3:                  DC.B 96,95,94,93,92,99,98,97
L02C4:          bset    #1,D7
                bra.s   L02C6
L02C5:          move.w  #-1,L078C
                bset    #0,D7
                bne.s   L02C6
                bset    #1,D7
                bclr    #2,D7
L02C6:          move.b  D7,mouse_pos
                cmp.w   D0,D3
                bne.s   L02C7
                cmp.w   D1,D4
                bne.s   L02C7
                bclr    #7,L07A1
                beq.s   L02C8
L02C7:          ori.w   #$8000,D2
L02C8:          cmp.w   board_y,D4
                bcs.s   L02C9
                move.w  board_y,D4
                subq.w  #1,D4
                tst.b   grid_on
                beq.s   L02C9
                move.w  grab_y,D4
                andi.w  #7,D4
                move.b  L02C3(PC,D4.w),D4
L02C9:          move.w  D0,mausposx
                move.w  D1,mausposy
                move.w  D2,mauskeys
                tst.w   D2
                rts

Bconin:         move.w  #2,-(SP)
                move.w  #2,-(SP)
                trap    #$0D
                addq.l  #4,SP
                rts

Bconstat:       move.w  #2,-(SP)
                move.w  #1,-(SP)
                trap    #$0D
                addq.l  #4,SP
                tst.w   D0
                rts

Kbshift:        movem.l D1-A6,-(SP)
                move.w  #-1,-(SP)
                move.w  #11,-(SP)       ;Kbshift!
                trap    #13
                addq.l  #4,SP
                move.w  D0,sondertasten ;Merken
                movem.l (SP)+,D1-A6
                rts

get_shift:      movem.l D0-D4,-(SP)
                move.w  D0,L07F5
                move.w  D1,L07F6
                bsr     Kbshift
                moveq   #0,D1
                moveq   #0,D2
                andi.w  #3,D0           ;Shift isolieren
                beq.s   L02CD           ;Nichts gedrÅckt
                moveq   #%10000000,D1   ;linke Shift-Taste gedrÅckt
                subq.w  #1,D0           ;Nur rechte gedrÅckt?
                bne.s   L02CD           ;Nein->beide gedrÅckt
                moveq   #%10000000,D2   ;nur rechte Shifttaste gedrÅckt
L02CD:          move.b  D2,right_shift
                move.b  D1,any_shift
                movem.l (SP)+,D0-D4
                rts

L02CE:          tst.b   any_shift
                beq     L02DE
                movem.w D2-D4,-(SP)
                moveq   #0,D2
                sub.w   L07F5,D0
                bpl.s   L02CF
                neg.w   D0
                addq.w  #4,D2
L02CF:          sub.w   L07F6,D1
                bpl.s   L02D0
                neg.w   D1
                addq.w  #2,D2
L02D0:          tst.b   right_shift
                beq.s   L02D2
                cmp.w   D0,D1
                bhi.s   L02D1
                move.w  D1,D4
                mulu    #-$71C8,D4
                add.l   D4,D4
                swap    D4
                cmp.w   D0,D4
                bhi.s   L02D1
                move.w  D4,D0
                exg     D1,D0
                addq.w  #1,D2
                bra.s   L02DA
L02D1:          move.w  D0,D1
                mulu    #-$199A,D1
                swap    D1
                bra.s   L02DA
L02D2:          cmp.w   D0,D1
                bgt.s   L02D3
                exg     D1,D0
                addq.w  #1,D2
L02D3:          bra.s   L02D8
L02D4:          tst.b   any_shift
                beq.s   L02DE
                movem.w D2-D4,-(SP)
                moveq   #0,D2
                sub.w   L07F5,D0
                bpl.s   L02D5
                neg.w   D0
                addq.w  #4,D2
L02D5:          sub.w   L07F6,D1
                bpl.s   L02D6
                neg.w   D1
                addq.w  #2,D2
L02D6:          cmp.w   D0,D1
                bgt.s   L02D7
                exg     D1,D0
                addq.w  #1,D2
L02D7:          move.w  D1,D3
                sub.w   D0,D3
                move.w  D0,D4
                add.w   D4,D4
                mulu    D3,D3
                mulu    D4,D4
                add.l   D3,D3
                cmp.l   D3,D4
                bcs.s   L02D9
L02D8:          move.w  D0,D1
                bra.s   L02DA
L02D9:          moveq   #0,D0
L02DA:          lsr.w   #1,D2
                bcc.s   L02DB
                exg     D1,D0
L02DB:          lsr.w   #1,D2
                bcc.s   L02DC
                neg.w   D1
L02DC:          lsr.w   #1,D2
                bcc.s   L02DD
                neg.w   D0
L02DD:          add.w   L07F5,D0
                add.w   L07F6,D1
                movem.w (SP)+,D2-D4
L02DE:          rts

chg_koord_shift:move.w  D2,-(SP)
                move.b  any_shift,D2
                ext.w   D2
                beq     L02EE           ;Shift nicht gedrÅckt->RTS
                bpl.s   L02EA
                moveq   #0,D2
                cmp.w   L07F5,D0
                beq.s   L02E0
                addq.w  #4,D2
L02E0:          cmp.w   L07F6,D1
                beq.s   L02E1
                addq.w  #8,D2
L02E1:          tst.w   D2
                bne.s   L02E2
                move.w  D0,D3
                move.w  D1,D4
                move.w  (SP)+,D2
                rts
L02E2:          cmpi.w  #$000C,D2
                bne.s   L02E9
                movem.w D0-D1,-(SP)
                moveq   #0,D2
                sub.w   L07F5,D0
                bpl.s   L02E3
                neg.w   D0
                addq.w  #1,D2
L02E3:          sub.w   L07F6,D1
                bpl.s   L02E4
                neg.w   D1
                addq.w  #2,D2
L02E4:          cmp.w   D0,D1
                bne.s   L02E6
                move.b  L02E5(PC,D2.w),D2
                bra.s   L02E8
L02E5:                  DC.B $04,$08,$04,$08
L02E6:          blt.s   L02E7
                moveq   #8,D2
                bra.s   L02E8
L02E7:          moveq   #4,D2
L02E8:          movem.w (SP)+,D0-D1
L02E9:          move.b  D2,any_shift
L02EA:          move.l  L02EB(PC,D2.w),-(SP)
L02EB                   EQU L02EA+2
                rts
                        DC.L L02ED
                        DC.L L02EC
L02EC:          move.w  L07F5,D0
                move.w  D0,D3
                bra.s   L02EE
L02ED:          move.w  L07F6,D1
                move.w  D1,D4
L02EE:          move.w  (SP)+,D2
                rts

;Zeichnet das aktuelle Objekt auf den Bildschirm und trÑgt dessen Nummer
;in das Optionboard ein und zeigt es ggf. an...
draw_objekt:    movem.l D0-A6,-(SP)

                bsr     Hm

                movea.l scr2,A1
                movea.l rotate_buffer,A0
                move.w  #799,D7
                tst.w   board_da
                bne.s   ganz_da
                move.w  grab_y,D0
                mulu    #160,D0
                adda.l  D0,A0           ;Erst hier anfangen
                move.w  #399,D7         ;Counter
ganz_da:        movem.l (A0)+,D0-D6/A2-A4
                movem.l D0-D6/A2-A4,(A1)
                lea     40(A1),A1       ;Bild hinkopieren
                dbra    D7,ganz_da

                tst.w   board_da
                bne.s   ok64
                bsr     copy_board      ;Kopiert Board scr1->scr2
ok64:
                lea     sequenzen,A6
                move.w  seq_akt,D0
                lsl.w   #3,D0           ;mal 8
                adda.w  D0,A6           ;aktuelle Sequenz

                move.w  4(A6),D1        ;Aktuelles Objekt
                tst.l   mem_cutter      ;öberhaupt Objekte da?
                beq     keins_da        ;Nein, Fehler
                movea.l mem_cutter,A0   ;Adresse der Objekte
                cmp.w   12(A0),D1       ;Soviel Objekte gibt es...
                bgt     keins_da        ;Nein, zu groû!

                clr.w   akt_obj_strk    ;Normale Schrift

                lea     14(A0),A0       ;Header1+Header2 Åberspringen
                moveq   #1,D7           ;Jetzt ist Nummer 1 dran
spr_loop3:      cmp.w   D1,D7           ;Sprite erreicht?
                beq.s   spr_found4      ;Ja, Eintrag gefunden
                addq.w  #1,D7           ;nÑchster Sprite
                adda.l  (A0)+,A0        ;Diesen Sprite Åberspringen!
                bra.s   spr_loop3

spr_found4:     move.w  6(A6),D0        ;Position auf Screen
                and.w   #%0111000000000000,D0 ;Maskieren
                rol.w   #6,D0           ;in Position, mal 4
                lea     koord_board(PC),A5 ;Koordinaten mit Board
                tst.w   board_da
                beq.s   ok78
                lea     koord_ohne(PC),A5
ok78:           lea     pos_routine(PC),A4
                adda.w  D0,A4
                movea.l (A4),A4
                jsr     (A4)            ;und in entsprechende Routine springen

;Ist öberhaupt ein Objekt vorhanden?
                tst.w   D2
                ble.s   draw_objekt_end
                tst.w   D3
                ble.s   draw_objekt_end

                move.w  #320,-(SP)      ;Breite des Zielbildschirms
                move.l  scr2,-(SP)      ;Zieladresse
                move.w  D1,-(SP)        ;Ziel_y
                move.w  D0,-(SP)        ;Ziel_x
                move.w  10(A0),D4       ;Breite des Objekts in Bytes
                add.w   D4,D4           ;Breite in Pixel berechnen
                move.w  D4,-(SP)
                pea     20(A0)          ;Quelladresse des Objekts
                add.w   D6,D2           ;Start_x+Breite=rechter Rand
                subq.w  #1,D2
                add.w   D5,D3           ;Start_y+Hîhe=unterer Rand
                subq.w  #1,D3
                move.w  D3,-(SP)
                move.w  D2,-(SP)
                move.w  D5,-(SP)
                move.w  D6,-(SP)
                jsr     raster_transp
                lea     24(SP),SP
                bsr     switch_screens

draw_objekt_end:bsr     show_akt_nr     ;aktuelle Nummer printen
                bsr     get_mouse_pos   ;Mauskoordinaten holen
                move.w  ptsout,D0
                move.w  ptsout+2,D1     ;Koordinaten holen
                bsr     make_lupe       ;und dort die Lupe aufbauen+Sm
                movem.l (SP)+,D0-A6
                rts

keins_da:       move.w  #2,akt_obj_strk
                bra.s   draw_objekt_end

;Tabelle zum Berechnen der Positionen des Objektes
pos_routine:            DC.L links_oben
                        DC.L rechts_oben
                        DC.L links_unten
                        DC.L rechts_unten
                        DC.L mitte

links_oben:     moveq   #0,D0           ;Zielkoordinaten linkes oberes Eck
                moveq   #0,D1
dierk1:         move.w  4(A0),D2        ;Breite
                move.w  6(A0),D3        ;Hîhe
                cmp.w   6(A5),D3        ;Ist Bildschirm so hoch?
                ble.s   ok53            ;Ja, weiter
                move.w  6(A5),D3        ;Sonst Bildschirmhîhe nehmen
ok53:           moveq   #0,D5           ;Offset innerhalb Objekt
                moveq   #0,D6           ;X in Objekt
                rts

rechts_oben:    moveq   #0,D1
                move.w  #320,D0         ;Zielkoordinaten rechtes oberes Eck
                sub.w   4(A0),D0        ;- Breite = linkes Oberes Eck
                bra.s   dierk1

rechts_unten:   move.w  #320,D0         ;Zielkoordinaten rechter Rand
                sub.w   4(A0),D0        ;- Breite = linkes Eck
                bra.s   dierk2

mitte:          moveq   #0,D5           ;Start y im Objekt
                moveq   #0,D6           ;Start x im Objekt
                move.w  4(A0),D2        ;Breite des Objektes
                move.w  D2,D4
                lsr.w   #1,D4           ;Breite halbieren
                move.w  ani_centerx,D0
                sub.w   D4,D0           ;=Linker Rand
                bpl.s   ok_links
                neg.w   D0
                move.w  D0,D6           ;Start X Im Objekt
                moveq   #0,D0           ;Start x auf Screen
                sub.w   D6,D2           ;von Breite abziehen
ok_links:       move.w  D0,D4
                add.w   D2,D4           ;+Breite=rechter Rand
                cmp.w   4(A5),D4        ;Breiter als rechter Rand?
                blt.s   ok_rechts
                sub.w   4(A5),D4
                sub.w   D4,D2           ;Breite verringern

ok_rechts:      move.w  ani_centery,D1  ;Position auf Screen
                tst.w   board_da
                bne.s   no88
                sub.w   grab_y,D1
no88:           move.w  6(A0),D3        ;Hîhe des Objektes
                move.w  D3,D4
                lsr.w   #1,D4           ;Objekthîhe/2
                sub.w   D4,D1           ;-Y_Mitte-Hîhe/2=Anfang_y
                bpl.s   ok55
                neg.w   D1
                move.w  D1,D5           ;Start_y im Objekt
                moveq   #0,D1           ;y=0 auf Screen
                sub.w   D5,D3           ;Hîhe Objekt-Offset innerhalb Objekt
ok55:           move.w  D1,D4           ;Unterkante berechnen, dazu Y-Start
                add.w   D3,D4           ;+Objekthîhe
                cmp.w   6(A5),D4        ;Grîûer als Screenhîhe?
                blt.s   ok57            ;Nein, weiter
                sub.w   6(A5),D4        ;Sonst -Screenhîhe
                sub.w   D4,D3           ;von Objekthîhe abziehen
ok57:           rts

links_unten:    moveq   #0,D0           ;X=0

dierk2:         moveq   #0,D5
                moveq   #0,D6           ;X in Objekt
                move.w  4(A0),D2        ;Breite des Objektes

                move.w  6(A0),D3        ;Hîhe des Objektes
                move.w  6(A5),D1        ;Hîhe des Screens
                sub.w   D3,D1           ;-Hîhe des Objektes
                bpl.s   ok65
                neg.w   D1
                move.w  D1,D5           ;Offset innerhalb Objekt
                moveq   #0,D1           ;Bei 0 starten
                move.w  6(A5),D3        ;Hîhe = Screenhîhe
ok65:           rts

koord_board:            DC.W 0,0,320,100
koord_ohne:             DC.W 0,0,320,200

show_akt_nr:    movem.l D0-A6,-(SP)

                lea     sequenzen,A0
                move.w  seq_akt,D0
                lsl.w   #3,D0           ;mal 8
                adda.w  D0,A0
                move.w  4(A0),D1
                lea     akt_objekt,A0   ;Aktuelles Objekt
                bsr     wandel_fest_dez3 ;speichern

                tst.w   board_da        ;Ist das Board da?
                bne.s   no_show_akt
                tst.b   lupe_an
                beq.s   no_show_akt
                cmpi.b  #11,function    ;Animate?
                bne.s   no_show_akt

                lea     akt_obj_strk,A3
                move.w  (A3)+,D2        ;Status
                move.w  (A3)+,D0        ;Koordinaten
                move.w  (A3)+,D1
                lea     akt_objekt,A0   ;String
                bsr     print6x6        ;und ausgeben
no_show_akt:    movem.l (SP)+,D0-A6
                rts



;Animiert sÑmtliche Objekte, z.B. Copybox bzw. Farbpalette
animier_objekte:move.w  ani_obj_direct,D0 ;In Welche Richtung die Objekte animieren?
                beq.s   no_obj_animate
                cmpi.b  #11,function    ;öberhaupt Animate angeschaltet?
                bne.s   no_obj_animate

                movem.l D0-A6,-(SP)

                lea     sequenzen,A6
                move.w  seq_akt,D1
                lsl.w   #3,D1
                adda.w  D1,A6
                move.w  6(A6),D2        ;Speed holen
                and.w   #%0000111111111111,D2 ;Maskieren

                move.w  vblcounter,D1
                sub.w   ani_obj_vbl,D1
                cmp.w   D2,D1           ;Anzahl an VBL's zwischen den Animationen
                bcs.s   no_obj          ;noch nicht erreicht
                move.w  vblcounter,ani_obj_vbl

                btst    #0,D0           ;Wird nach links animiert?
                beq.s   no_links67

                jsr     one_left        ;Ein Objekt nach links
                bra.s   draw_obj        ;und das war's

no_links67:     btst    #1,D0           ;Wird nach rechts animiert?
                beq.s   no_obj          ;Nein, weiter

                jsr     one_right       ;Ein Objekt weiter
draw_obj:       bsr     draw_objekt     ;Zeichnet aktuelles Objekt auf den Screen
no_obj:         movem.l (SP)+,D0-A6

no_obj_animate: move.w  rot_col_direct,D0
                beq.s   L02F1
                move.w  vblcounter,D1
                sub.w   rot_col_vbl,D1
                cmp.w   rot_col_speed,D1 ;Anzahl an VBL's zwischen den Animationen
                bcs.s   L02F1
                addq.w  #1,rot_col_counter
                move.w  vblcounter,rot_col_vbl
                btst    #0,D0           ;Wird nach links animiert?
                beq.s   L02F0           ;Nein, weiter
                bsr     rot_col_links
                bra.s   L02F1
L02F0:          btst    #1,D0           ;Wird nach rechts animiert?
                beq.s   L02F1           ;Nein, weiter
                bsr     rot_col_rechts
L02F1:          move.b  copy_status,D1  ;öberhaupt was da?
                beq.s   L02F3           ;Nein, bei Jack weitermachen
                btst    #2,D1           ;Wird gerade verschoben?
                bne     L02FE           ;ja->RTS
                move.w  vblcounter,D1
                sub.w   counter_box,D1
                cmp.w   #6,D1           ;alle 6 VBL's scrollen
                bcs     L02FE           ;noch nicht so weit->RTS
                move.w  vblcounter,counter_box ;merken
                movea.l pos_ani_box,A1  ;welches Liniemuster ist dran?
                subq.l  #4,A1
                cmpa.l  #L0777,A1       ;schon unten?
                bcc.s   L02F2
                lea     $0010(A1),A1    ;oben wieder anfangen...
L02F2:          move.l  A1,pos_ani_box
                bsr     Hm
                movea.l scr1,A1         ;Auf Scr1 animieren
                bsr     ani_box
                move.b  #%10000000,L07A1
L02F3:          move.b  jack_status,D1  ;Ist was bei Jack ausgeschnitten?
                beq     L02F9
                andi.w  #5,D1
                cmpi.w  #1,D1
                bne     L02FE
                move.w  vblcounter,D1
                sub.w   counter_box,D1
                cmp.w   #6,D1
                bcs     L02FE
                move.w  vblcounter,counter_box
                movea.l pos_ani_box,A2
                subq.l  #4,A2
                cmpa.l  #L0777,A2
                bcc.s   L02F4
                lea     $0010(A2),A2
L02F4:          move.l  A2,pos_ani_box
                bsr     Hm
                movea.l scr2,A0
                movea.l scr1,A1
                movea.w #160,A5
                move.w  L07E5,D4
                movea.w D4,A4

                move.w  ani_x1,D0
                move.w  ani_y1,D1       ;Koordinaten der Copybox

                move.w  D0,pos_objektx
                move.w  D1,pos_objekty  ;Koordinaten merken

                tst.w   board_da
                bne.s   keins2
                move.w  grab_y,D6
                add.w   D6,pos_objekty  ;angleichen
keins2:
                move.w  ani_x1,D0
                bpl.s   L02F5
                neg.w   D0
                add.w   #$000F,D0
                lsr.w   #4,D0
                add.w   D0,D0
                adda.w  D0,A0
                clr.w   D0
L02F5:          move.w  ani_y1,D1
                bpl.s   L02F6
                neg.w   D1
                mulu    D4,D1
                adda.l  D1,A0
                clr.w   D1
L02F6:          move.w  ani_x4,D2
                cmpi.w  #319,D2
                ble.s   L02F7
                move.w  #319,D2
L02F7:          move.w  ani_y4,D3
                cmp.w   board_y,D3
                blt.s   L02F8
                move.w  board_y,D3
                subq.w  #1,D3
L02F8:          jsr     L0737
                move.b  #-$80,L07A1
                bra     L02FE
L02F9:          btst    #1,text_status  ;Cursor zu sehen?
                beq.s   L02FB
                move.w  vblcounter,D1
                sub.w   L07FB,D1
                cmpi.w  #$001E,D1
                bcs     L02FE
                bsr     Hm
                move.b  #-$80,L07A1
                bchg    #0,text_status
                bne.s   L02FA
                bsr     L0257
                bra.s   L02FE
L02FA:          bsr     L0256
                bra.s   L02FE
L02FB:          move.b  function,D1
                cmpi.b  #11,D1          ;Camera
                bne.s   L02FE           ;->RTS
                move.b  L0784,D0
                btst    #4,D0
                beq.s   L02FE
                move.l  L082D,D2
                beq.s   L02FE
                move.w  vblcounter,D1
                sub.w   L07FA,D1
                cmp.w   L068C,D1
                bcs.s   L02FE
                move.w  vblcounter,L07FA
                movea.l D2,A0
                btst    #5,D0
                beq.s   L02FC
                move.l  2(A0),L082D
                bra.s   L02FD
L02FC:          move.l  6(A0),L082D
L02FD:          jsr     L066E
                bsr     switch_screens
                move.b  #-$80,L07A1
L02FE:          rts

rot_col_rechts: movem.l D0-D4/A0,-(SP)
                move.w  left_col_mark,D0
                move.w  right_col_mark,D1
                moveq   #-2,D2
                bra.s   L0301

rot_col_links:  movem.l D0-D4/A0,-(SP)
                move.w  right_col_mark,D0
                move.w  left_col_mark,D1
                moveq   #2,D2
L0301:          move.b  #-$80,L07A1
                lea     hbl_system+2,A0
                move.w  rst_akt,D3
                mulu    #34,D3          ;in aktueller Palette rotieren
                adda.l  D3,A0
                add.w   D0,D0
                add.w   D1,D1
                move.w  0(A0,D1.w),D3
L0302:          cmp.w   D0,D1
                beq.s   L0303
                move.w  D1,D4
                add.w   D2,D1
                move.w  0(A0,D1.w),0(A0,D4.w)
                bra.s   L0302
L0303:          move.w  D3,0(A0,D1.w)
                tst.w   left_col_mark
                bne.s   L0304
                tst.w   board_da
                bne.s   L0304
                bsr     clear_bottom_lupe
L0304:          bsr     palette_changed ;und Åbernehmen
                movem.l (SP)+,D0-D4/A0
                rts

;Wandelt immer in 3-stellige Dezzahl
;Parameter:
;A0: Speicherbereich 4 Byte groû
;D0: Wert
wandel_fest_dez:lea     dez_tab,A1
                tst.w   D0
                bpl.s   ok90            ;Positiv?
                neg.w   D0
ok90:           ext.l   D0
                divu    #100,D0
                move.b  0(A1,D0.w),(A0)+
                swap    D0
                ext.l   D0
                divu    #10,D0
                move.b  0(A1,D0.w),(A0)+
                swap    D0
                move.b  0(A1,D0.w),(A0)+
                clr.b   (A0)+
                rts

;Wandelt in 3-Stellige Dezzahl, unterdrÅckt fÅhrende Nullen
;Parameter:
;A1: Speicherbereich 3 Byte groû
;D0: Zahl 0-199
wandel_dez:     tst.w   D0              ;Null?
                bne.s   wandeln
                move.b  #'0',(A1)+      ;Falls nichts mehr kommt
                rts

wandeln:        ext.l   D0
                moveq   #0,D1           ;Stellenanzahl
                divu    #100,D0
                beq.s   L0507
                addi.b  #'0',D0
                move.b  D0,(A1)+        ;in Dez wandeln
                addq.w  #1,D1           ;eine Stelle mehr
L0507:          swap    D0
                ext.l   D0
                divu    #$000A,D0
                bne.s   L0508
                tst.w   D1              ;fÅhrende Nullen unterdrÅcken
                beq.s   L0509
L0508:          addq.w  #1,D1
                addi.b  #'0',D0
                move.b  D0,(A1)+
L0509:          swap    D0
                addi.b  #'0',D0
                move.b  D0,(A1)+
                rts

;Wandelt in 3-stellige Dezimalzahl ohne UnterdrÅckung fÅhrender Nullen etc.
;Parameter:
;D1: Wert
;A0: Speicherbereich
wandel_fest_dez3:ext.l  D1
                divu    #100,D1
                add.b   #'0',D1
                move.b  D1,(A0)+
                swap    D1
                ext.l   D1
                divu    #10,D1
                add.b   #'0',D1
                move.b  D1,(A0)+
                swap    D1
                add.b   #'0',D1
                move.b  D1,(A0)+
                rts

;Wandelt in 2-stellige Dezimalzahl ohne UnterdrÅckung fÅhrender Nullen etc.
;Parameter:
;D1: Wert
;A0: Speicherbereich
wandel_fest_dez2:ext.l  D1
                divu    #10,D1
                add.b   #'0',D1
                move.b  D1,(A0)+
                swap    D1
                add.b   #'0',D1
                move.b  D1,(A0)+
                rts


schieb_board:
; Intro fÅr NEOchrome
; schiebt Board wie Kamm rein

                tst.w   effektflag
                bne     nixmehrangucken

                movem.l D0-A6,-(SP)

                pea     mouseoff
                clr.w   -(SP)
                move.w  #25,-(SP)
                trap    #14
                addq.l  #8,SP

                clr.w   kamm_counter    ; geht von 0-39

                move.l  rotate_buffer,kamm_screen1 ;rotate_buffer ist zu sehen
                movea.l scr1,A0         ;hier steht das fertige Board
                lea     100*160(A0),A0
                move.l  A0,scrollpointer1
                lea     160+152(A0),A1
                move.l  A1,scrollpointer2

kamm_loop:
                movea.l kamm_screen1,A0
                movea.l A0,A4
                lea     100*160+8(A0),A0 ; auf zweiten Bitblock gehen
                lea     101*160+144(A4),A4
                moveq   #49,D0          ; 50*2 Scanlines
wuchtvor:       movem.l (A0)+,D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-48(A0) ; um einen BB nach vorne
                movem.l (A0)+,D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-48(A0) ; um einen BB nach vorne
                movem.l (A0)+,D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-48(A0) ; um einen BB nach vorne
                movem.l (A0)+,D1-D7/A1  ; 8 Longs
                movem.l D1-D7/A1,-40(A0) ; um einen BB nach vorne

                movem.l -40(A4),D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-32(A4)
                movem.l -80(A4),D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-72(A4)
                movem.l -120(A4),D1-D7/A1-A3 ; 10 Longs
                movem.l D1-D7/A1-A3,-112(A4)
                movem.l -144(A4),D1-D7/A1 ; 8 Longs
                movem.l D1-D7/A1,-136(A4)

                lea     320(A4),A4
                lea     168(A0),A0
                dbra    D0,wuchtvor

                movea.l scrollpointer1,A0
                movea.l scrollpointer2,A2
                movea.l kamm_screen1,A1
                movea.l A1,A3
                lea     100*160+152(A1),A1
                lea     101*160(A3),A3
                moveq   #98,D0          ; 100 Zeilen
fuckloop:       move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A2)+,(A3)+
                move.l  (A2)+,(A3)+
                lea     152(A0),A0
                lea     152(A1),A1
                lea     152(A2),A2
                lea     152(A3),A3
                dbra    D0,fuckloop

                addq.l  #8,scrollpointer1
                subq.l  #8,scrollpointer2
                addq.w  #1,kamm_counter
                cmpi.w  #20,kamm_counter
                beq.s   undab
                bsr     vsync_neo
                bra     kamm_loop

undab:
                pea     mouseon
                clr.w   -(SP)
                move.w  #25,-(SP)
                trap    #14
                addq.l  #8,SP

                move.w  #-1,effektflag
                movem.l (SP)+,D0-A6
nixmehrangucken:rts


draw_board:             PART 'Draw Board'
;Zeichnet das Board
;D1: Maus_y -> Lupe/Color512
                movem.l D0-A6,-(SP)

                bsr     raster_ggf_aus

                tst.b   board_gerettet  ;Board schon gespeichert?
                beq     board_restore   ;Ja, nur restaurieren

                movea.l scr1,A0
                lea     200*160(A0),A0  ;die unteren 100 Zeilen lîschen

                movem.l zeros,D0-D6/A1-A6
                move.w  #306,D7
L0306:          movem.l D0-D6/A1-A6,-(A0) ;Biûchen auf Touren bringen....
                dbra    D7,L0306
                movem.l D0-D6/A1-A2,-(A0) ;restlichen 36 Bytes lîschen

                moveq   #0,D2           ;kleiner Kasten
                moveq   #114,D1         ;Y Start
                moveq   #16,D4          ;17 Zeilen hoch
L0307:          moveq   #126,D0         ;X Start
                moveq   #12,D5
L0308:          moveq   #13,D3
                sub.w   D5,D3           ;Farbe immer um eins vermindern
                bsr     draw_icon       ;Kasten zeichnen
                addq.w  #5,D0           ;X+=5
                dbra    D5,L0308
                addq.w  #5,D1           ;Y+=5
                dbra    D4,L0307

                movea.l scr1,A0
                lea     115*160+56(A0),A0 ;Eine Zeile aus voller Lupe holen
                movem.l (A0),D0-D6/A2-A4
                movem.l D0-D6/A2-A4,lupe_voll
                lea     4*160(A0),A0    ;und leere Zeile
                movem.l (A0),D0-D6/A2-A4
                movem.l D0-D6/A2-A4,lupe_leer

                bsr     draw_palette

                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                move.w  #198,D0
                moveq   #114,D1         ;Kasten um RGB-Werte
                move.w  #276,D2
                move.w  #128,D3
                bsr     rahmen
                move.w  #210,D0
                move.w  D0,D2
                bsr     rahmen          ;Color RGB-Kasten aufbauen
                move.w  #264,D0
                move.w  D0,D2
                bsr     rahmen

                move.w  #239,D0
                moveq   #116,D1
                moveq   #25,D2          ;Zeichenfarbe setzen
                moveq   #14,D3
                bsr     draw_icon

                moveq   #0,D0
                moveq   #114,D1
                moveq   #16,D2
                moveq   #$0F,D3
                bsr     draw_icon       ;'Fullscreen'

                moveq   #15,D4
                moveq   #0,D5
                moveq   #114,D1
                moveq   #2,D7
L0315:          moveq   #8,D0
                moveq   #4,D6
L0316:          move.w  D6,-(SP)
                move.w  #-1,D6
                move.w  D0,D2
                move.w  D1,D3
                add.w   #21,D2
                add.w   #21,D3
                bsr     rahmen          ;Rahmen um Funktionen zeichnen
                move.w  (SP)+,D6
                add.w   #21,D0
                dbra    D6,L0316
                add.w   #21,D1
                dbra    D7,L0315

                moveq   #10,D0          ;Start_x
                moveq   #116,D1         ;Start_y
                lea     icon_func,A0    ;Welche Funktion hat welches Icon?
                moveq   #0,D2
                moveq   #$0F,D3
                moveq   #2,D7
                ext.l   D7
L0317:          swap    D7
                move.w  D0,-(SP)
                moveq   #4,D6
L0318:          cmp.b   #13,D7          ;User 1?
                beq.s   L031A           ;-> dann nicht zeichnen
                cmp.b   #14,D7          ;User 2?
                beq.s   L031A           ;-> dann nicht zeichnen
                move.b  (A0)+,D2        ;Iconnr holen
                beq.s   L031A
                bsr     draw_func
L031A:          addq.w  #1,D7
                add.w   #21,D0          ;x+=21
                dbra    D6,L0318        ;5 pro Zeile
                move.w  (SP)+,D0        ;wieder vorne anfangen
                add.w   #21,D1          ;y+=21
                swap    D7
                dbra    D7,L0317

                lea     neo_version(PC),A0 ;'v2.0'
                moveq   #0,D0
                move.w  #194,D1
                moveq   #0,D2
                bsr     print6x6

                move.w  #278,D0
                move.w  #114,D1
                move.w  #101,D2
                move.w  #15,D3
                bsr     draw_icon       ;UNDO-Icon zeichnen

                movea.l scr1,A0
                lea     100*160(A0),A0
                lea     board,A1
                move.w  #399,D7
save_board:     movem.l (A0)+,D0-D6/A2-A4
                movem.l D0-D6/A2-A4,(A1) ;Board retten
                lea     40(A1),A1
                dbra    D7,save_board

                clr.b   board_gerettet
                bsr     make_border_lupe
                bsr     copy_lupen      ;und kopieren
                bra.s   weiter67

board_restore:  movea.l scr1,A1
                lea     100*160(A1),A1
                lea     board,A0
                move.w  #399,D7
rest_board:     movem.l (A0)+,D0-D6/A2-A4
                movem.l D0-D6/A2-A4,(A1) ;Board schreiben
                lea     40(A1),A1
                dbra    D7,rest_board

weiter67:       movem.l (SP),D0-A6

                bsr     beschriften     ;Farbnummern ggf. eintragen

                cmp.w   board_y,D1      ;Wo steht der Mauszeiger?
                bcs.s   L0309           ;im Work
                bsr     rahm_color      ;Sonst Rahmen fÅr Farbe zeichnen
                move.b  colorx,D0
                sub.b   pos_color512,D0
                bcs.s   L030A
                cmpi.b  #$0D,D0
                bcc.s   L030A
                move.b  colory,D1       ;512 Farbenbild aufbauen
                ext.w   D0
                ext.w   D1
                bsr     draw_hot_spot
                bra.s   L030A
L0309:          tst.w   magtyp          ;Groûe Lupe an?
                beq.s   neo_lupe1       ;Nein
                movea.l scr1,A0
                move.w  magtyp,D0
                jsr     clear_lupe
                bra     L0312
neo_lupe1:      bsr     rahm_lupe
                moveq   #6,D0           ;an diesen Koordinaten den Hot-Spot
                moveq   #8,D1
                bsr     draw_hot_spot   ;Umrandet noch irgendeine Farbe
L030A:          tst.b   back_saved      ;Wurde der Hintergrund schon gesichert?
                beq.s   no_save78       ;ja, nichts mehr retten

                move.l  A1,-(SP)        ;a1 retten
                lea     scroll_save,A1
                movea.l scr1,A0
                lea     192*160(A0),A0
                move.w  #(8*160/4)/2-1,D0
save_loop:      move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,save_loop
                clr.b   back_saved      ;Hintergrund ist jetzt gerettet!

                lea     scrollspace,A1
nuff:           clr.w   (A1)+
                cmpa.l  #scrollwabbel,A1
                blt.s   nuff

                movea.l (SP)+,A1        ;und a1 wieder runterholen

                bsr     do_scroller     ;Einmal zeichnen!
                clr.b   scroll_aktiv    ;und Scroller an!

no_save78:      move.w  #200,D0
                moveq   #116,D1
                moveq   #23,D2          ;Color animation rechts
                moveq   #15,D3
                btst    #0,rot_col_directlow
                beq.s   L030C
                bsr     draw_icon_inv
                bra.s   L030D
L030C:          bsr     draw_icon
L030D:          move.w  #266,D0
                moveq   #116,D1
                moveq   #24,D2
                btst    #1,rot_col_directlow ;nach links animieren?
                beq.s   L030E
                bsr     draw_icon_inv
                bra.s   L030F
L030E:          bsr     draw_icon
L030F:


L0312:          cmpi.b  #8,copyr_work   ;Start-Logo?
                bne.s   L0312B          ;nein, weiter
                bsr     draw_big_logo
                bra.s   L0313

L0312B:         bsr     draw_options    ;fÅr wirkliche Funktion Options zeichnen
L0313:
                moveq   #114,D0
                moveq   #114,D1
                moveq   #16,D2
                moveq   #$0F,D3         ;'Grid'
                moveq   #8,D5
                moveq   #0,D6
                bsr     L032B
                tst.b   grid_on
                beq.s   L0314
                move.l  #-$0000FFF8,D5
                move.l  #-$0001FFFF,D6
                addq.w  #1,D1
                bsr     L032A
L0314:

                moveq   #10,D0          ;Start_x
                moveq   #116,D1         ;Start_y
                lea     icon_func,A0    ;Welche Funktion hat welches Icon?
                moveq   #0,D2
                moveq   #$0F,D3
                moveq   #2,D7
                ext.l   D7
L03172:         swap    D7
                move.w  D0,-(SP)
                moveq   #4,D6
L03182:         cmp.b   #13,D7          ;User1?
                bne.s   no_user1
                bsr     check_user1     ;Ist User1 vorhanden?
                bne.s   L031A2          ;Nein->Nichts zeichnen
                moveq   #-1,D2          ;Iconnummer User #1
                bra.s   draw_usser
no_user1:       cmp.b   #14,D7
                bne.s   zeichne_normal

                bsr     check_user2     ;Ist User #2 vorhanden?
                bne.s   L031A2
                moveq   #-2,D2          ;Iconnummer User #2

draw_usser:     cmp.b   function,D7     ;Funktion aktiv
                beq.s   zeichne
                bsr     draw_func       ;Sonst normal zeichnen
                bra.s   L031A2

zeichne_normal: move.b  (A0)+,D2        ;Iconnr holen
                beq.s   L031A2          ;Funktion deselktiert->Kein Icon
                cmp.b   function,D7     ;gerade aktiv?
                bne.s   L031A2
zeichne:        bsr     draw_func_inv   ;Aktiv->Invers zeichnen
L031A2:         addq.w  #1,D7
                add.w   #21,D0          ;x+=21
                dbra    D6,L03182       ;5 pro Zeile
                move.w  (SP)+,D0        ;wieder vorne anfangen
                add.w   #21,D1          ;y+=21
                swap    D7
                dbra    D7,L03172

                tst.b   copyr_work      ;noch beim Copyrighten?
                bpl.s   L031B           ;Ja, weiter
                bsr     show_fn         ;Nein, Filename anzeigen
                bra.s   L031C
L031B:          lea     neochrome(PC),A0 ;Neochrom V1.1 printen
                moveq   #0,D0
                move.w  #182,D1
                bsr     print8x8
L031C:
                bsr     set_farb_ecke
                bsr     draw_left_col_mark
                bsr     draw_right_col_mark
                tst.b   lupe_an         ;Ist die groûe Lupe an?
                beq.s   kein_rgb
                bsr     print_rgb
kein_rgb:       bsr     raster_ggf_an

                movem.l (SP)+,D0-A6
                rts

                        ENDPART

;Zeichnet den Farbbalken neu
draw_color_balken:movem.l D0-A6,-(SP)

                bsr.s   draw_palette    ;Zeichnet die FarbkÑsten

                bsr.s   draw_left_col_mark
                bsr     draw_right_col_mark
                bsr     set_farb_ecke

                movem.l (SP)+,D0-A6
to_rts2:        rts


;Zeichnet die 16 FarbkÑsten der Palette
draw_palette:   movem.l D0-A6,-(SP)

                moveq   #1,D2           ;Groûer Kasten
                moveq   #0,D0
                moveq   #101,D1
                moveq   #15,D4          ;16 Farb-Register-Kasten zeichnen
L030B:          moveq   #15,D3
                sub.w   D4,D3
                bsr     draw_icon
                add.w   #20,D0          ;X+=20
                dbra    D4,L030B

                bsr     beschriften
                movem.l (SP)+,D0-A6
                rts

;Beschriftet ggf. die Farbpalette mit den Farbnummern
beschriften:    movem.l D0-A6,-(SP)

                tst.b   beschriftung
                bne.s   keine_beschriftung
                moveq   #7,D0           ;x
                moveq   #103,D1         ;y
                moveq   #15,D2          ;Farbe
                moveq   #1,D3           ;Schreibmodus=Transparent
                moveq   #0,D4           ;Schreibstil
                moveq   #'0',D5
                moveq   #15,D6          ;16 Farbregister beschriften
print_farb_nr:  lea     bb,A0
                move.b  D5,(A0)
                clr.b   1(A0)
                bsr     print6x6_col
                addq.w  #1,D5
                cmp.w   #'1',D5
                bne.s   keine_eins
                moveq   #0,D2           ;Mit Hintergrundfarbe weitermachen
keine_eins:     cmp.w   #'9'+1,D5
                bne.s   ooo
                moveq   #'A',D5
ooo:            add.w   #20,D0          ;x+=20
                dbra    D6,print_farb_nr

keine_beschriftung:movem.l (SP)+,D0-A6
                rts


draw_left_col_mark:tst.w board_da
                bne.s   to_rts2
                movem.l D0-A6,-(SP)
                move.w  left_col_mark,D0
                bne.s   L031E
                move.w  #$000F,D3
                bra.s   L0322
L031E:          move.w  D0,D3
                mulu    #$0014,D0
                move.w  #$0065,D1
                move.w  #3,D2
                bra     L032E

draw_right_col_mark:tst.w board_da
                bne     to_rts2
                movem.l D0-A6,-(SP)
                move.w  right_col_mark,D0
                bne.s   L0320
                move.w  #$000F,D3
                bra.s   L0324
L0320:          move.w  D0,D3
                mulu    #$0014,D0
                add.w   #$000E,D0
                move.w  #$0065,D1
                move.w  #4,D2
                bra     L032E

del_left_col_mark:tst.w board_da
                bne     to_rts2
                movem.l D0-A6,-(SP)
                move.w  left_col_mark,D0
                move.w  D0,D3
                mulu    #$0014,D0
L0322:          move.w  #$0065,D1
                move.w  #3,D2
                move.l  #$04040707,D4
                bra     L0330           ;in Drawicon

del_right_col_mark:tst.w board_da
                bne     to_rts2
                movem.l D0-A6,-(SP)
                move.w  right_col_mark,D0
                move.w  D0,D3
                mulu    #$0014,D0
L0324:          add.w   #$000E,D0
                move.w  #$0065,D1
                move.w  #4,D2
                move.l  #$04040707,D4
                bra     L0330

;Erstellt die Lupen im Border von scr1 je nach lupe_y und pal_flag
;Achtung im Rand wurde Platz fÅr 46 Scanlines geschaffen.
make_border_lupe:movem.l D0-A6,-(SP)

                bsr     into_border     ;Ausgabe in Border leiten

                moveq   #0,D0
                moveq   #0,D1
                move.w  #319,D2
                moveq   #45,D3          ;Kompletten Border lîschen
                moveq   #0,D4
                moveq   #1,D5
                jsr     fill_box

                movea.l scr1,A0         ;Hier fÑngt Lupe an
                lea     202*160+56(A0),A0

                tst.b   pal_flag        ;Palette im Fullscreen?
                bne.s   keine_palette

                moveq   #0,D0
                moveq   #0,D1
                moveq   #1,D3
                moveq   #0,D4
                moveq   #1,D5
zeichne_pal:    move.w  D0,D2
                add.w   #17,D2
                jsr     fill_box
                add.w   #20,D0
                addq.w  #1,D4
                cmp.w   #16,D4
                blt.s   zeichne_pal

                movea.l scr1,A0
                adda.l  #205*160+56,A0  ;Langwort!

keine_palette:  move.w  lupe_y,D7       ;Counter
                bra.s   zeichne_dbra

zeichne_lupe:   movem.l lupe_voll,D0-D6/A2-A4
                movem.l D0-D6/A2-A4,(A0)
                lea     160(A0),A0
                movem.l D0-D6/A2-A4,(A0)
                lea     160(A0),A0
                movem.l D0-D6/A2-A4,(A0)
                lea     160(A0),A0
                movem.l D0-D6/A2-A4,(A0)
                lea     160(A0),A0
                movem.l lupe_leer,D0-D6/A2-A4
                movem.l D0-D6/A2-A4,(A0)
                lea     160(A0),A0
zeichne_dbra:   dbra    D7,zeichne_lupe

                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                move.w  #126,D0
                moveq   #1,D1
                move.w  #191,D2
                move.w  lupe_y,D3
                mulu    #5,D3
                add.w   D1,D3
                tst.b   pal_flag        ;Palette im Fullscreen?
                bne.s   zeichne2
                addq.w  #3,D1           ;Sonst 3 Zeilen tiefer starten
                addq.w  #3,D3
zeichne2:       bsr     rahmen          ;Groûer Rahmen um Lupe

                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                move.w  #156,D0
                move.w  lupe_y,D1
                lsr.w   #1,D1           ;halbieren
                mulu    #5,D1
                addq.w  #1,D1
                move.w  #161,D2
                move.w  D1,D3
                addq.w  #5,D3
                tst.b   pal_flag
                bne.s   zeichne3
                addq.w  #3,D1
                addq.w  #3,D3
zeichne3:       bsr     rahmen          ;Hot Spot zeichnen

                lea     neo_logo+29*64,A0 ;Master-Schriftzug
                movea.l scr1,A1
                adda.l  #32000+5*160+96,A1
                moveq   #30,D7          ;31 Scanlines hoch
copy2357:       moveq   #7,D6
copy2356:       movem.w (A0)+,D0-D3     ;1 BB holen
                clr.w   (A1)+
                move.w  D0,(A1)+
                move.w  D0,(A1)+
                move.w  D0,(A1)+
                dbra    D6,copy2356
                lea     160-64(A1),A1
                dbra    D7,copy2357

                lea     neo(PC),A0
                move.w  #200,D0
                moveq   #5,D1
                moveq   #0,D2
                bsr     print6x6        ;ausgeben

                lea     neo_version(PC),A0
                move.w  #224,D0
                moveq   #5,D1
                moveq   #0,D2
                bsr     print6x6        ;ausgeben

                lea     by_chaos(PC),A0
                move.w  #240,D0
                moveq   #30,D1
                moveq   #0,D2
                bsr     print6x6        ;ausgeben

                bsr     show_fn_border  ;und Filenamen neu printen
                bsr.s   set_farb_ecke   ;und Farbe neu setzen

                movem.l (SP)+,D0-A6
                rts

;Kopiert die Border-Lupe von scr1 -> scr2 (46 Scanlines)
copy_lupen:     movem.l D7-A1,-(SP)
                movea.l scr1,A0
                movea.l scr2,A1
                lea     32000(A0),A0    ;Lupe von Scr1 nach Scr2 Åbertragen
                lea     32000(A1),A1
                move.w  #1839,D7
copy_lupen2:    move.l  (A0)+,(A1)+
                dbra    D7,copy_lupen2

                movem.l (SP)+,D7-A1
                rts

set_farb_ecke:  movem.l D0-A6,-(SP)
                tst.w   board_da
                bne.s   kein_zeichnen1
                moveq   #6,D1
                move.w  zeichenfarbe,D0
                cmp.w   hintergrundfarbe,D0
                bne.s   nicht_gleich1
                moveq   #2,D1
nicht_gleich1:  mulu    #20,D0
                add.w   D1,D0
                moveq   #110,D1
                moveq   #2,D2
                moveq   #15,D3
                bsr     draw_icon
                moveq   #6,D1
                move.w  hintergrundfarbe,D0
                cmp.w   zeichenfarbe,D0
                bne.s   nicht_gleich2
                moveq   #11,D1
nicht_gleich2:  mulu    #20,D0
                add.w   D1,D0
                moveq   #110,D1
                moveq   #99,D2
                moveq   #15,D3
                bsr     draw_icon
kein_zeichnen1: bsr     into_border

                move.w  zeichenfarbe,D0
                mulu    #20,D0
                addq.w  #6,D0
                moveq   #2,D1
                move.w  D0,D2
                addq.w  #5,D2
                moveq   #2,D3
                moveq   #15,D4
                moveq   #1,D5
                jsr     fill_box        ;Im Rand zeichnen

                move.w  hintergrundfarbe,D0
                mulu    #20,D0
                move.w  D0,D2
                addq.w  #3,D2
                jsr     fill_box

                add.w   #14,D0
                add.w   #14,D2
                jsr     fill_box

                bsr     copy_lupen

                bsr     into_screen
                movem.l (SP)+,D0-A6
                rts

del_farb_ecke:  movem.l D0-A6,-(SP)
                tst.w   board_da
                bne.s   kein_zeichnen2
                moveq   #6,D1
                move.w  zeichenfarbe,D0
                cmp.w   hintergrundfarbe,D0
                bne.s   nicht_gleich3
                moveq   #2,D1
nicht_gleich3:  mulu    #20,D0
                add.w   D1,D0
                moveq   #110,D1
                moveq   #2,D2           ;Nummer des Icons
                moveq   #15,D3
                bsr     del_icon        ;Alte Farbecke wegmachen
                moveq   #6,D1
                move.w  hintergrundfarbe,D0
                cmp.w   zeichenfarbe,D0
                bne.s   nicht_gleich4
                moveq   #11,D1
nicht_gleich4:  mulu    #20,D0
                add.w   D1,D0
                moveq   #110,D1
                moveq   #99,D2          ;Nummer des Icons
                moveq   #15,D3
                bsr     del_icon
kein_zeichnen2: bsr     into_border

                moveq   #0,D0
                moveq   #2,D1
                move.w  #319,D2
                moveq   #2,D3
                moveq   #0,D4
                moveq   #1,D5
                jsr     fill_box
                bsr     copy_lupen      ;und auf Screen2 kopieren

                bsr     into_screen
                movem.l (SP)+,D0-A6
                rts

draw_func:      movem.w D0-D1,-(SP)
                addq.w  #1,D0
                addq.w  #1,D1
                bsr.s   draw_icon
                movem.w (SP)+,D0-D1
                move.l  A0,-(SP)
                movem.w D2-D6,-(SP)
                moveq   #0,D4
                bra.s   L0329

draw_func_inv:  movem.w D0-D1,-(SP)
                addq.w  #1,D0
                addq.w  #1,D1
                bsr.s   draw_icon_inv
                movem.w (SP)+,D0-D1
                move.l  A0,-(SP)
                movem.w D2-D6,-(SP)
                moveq   #$0F,D4
L0329:          moveq   #0,D5
                moveq   #-1,D6
                lea     bitblit,A0
                move.w  D0,D2
                move.w  D1,D3
                add.w   0(A0),D2
                add.w   2(A0),D3
                addq.w  #1,D2
                addq.w  #1,D3
                bsr     rahmen
                movem.w (SP)+,D2-D6
                movea.l (SP)+,A0
                rts

L032A:          movem.l D0-A6,-(SP)
                move.l  #$00030C0F,D4
                bra.s   L0331
L032B:          movem.l D0-A6,-(SP)
                move.l  #$000C030F,D4
                bra.s   L0331
del_icon:       movem.l D0-A6,-(SP)     ;(?)
                move.l  #$000C030F,D4
                moveq   #0,D3
                bra.s   L0330
draw_icon_inv:  movem.l D0-A6,-(SP)
L032E:          move.l  #$00030C0F,D4
                bra.s   L0330


;Zeichnet Icon auf den Bildschirm
;Parameter:
;D0: X-Koordinate auf Screen
;D1: Y-Koordinate auf Screen
;D2: Nummer des Icons
;D3: Farbe
draw_icon:      movem.l D0-A6,-(SP)
                move.l  #$000C030F,D4   ;0=0, 12=Not q,3=Copy,15=1
L0330:          moveq   #0,D5
                moveq   #0,D6
L0331:          lea     bitblit,A6
                move.l  D4,10(A6)       ;operation
                move.w  D3,6(A6)        ;Vordergrundfarbe
                clr.w   8(A6)           ;Hintergrundfarbe
                move.w  D5,14(A6)       ;X-Koordinate des Quellrasters
                move.w  D6,16(A6)       ;Y-Koordinate des Quellrasters
                swap    D5
                swap    D6
                tst.w   D2              ;Usericon?
                bpl.s   normales_icon
                moveq   #0,D7
                cmp.w   #-1,D2          ;User1?
                beq.s   user11
                moveq   #1,D7
user11:         move.l  D0,-(SP)
                moveq   #8,D0           ;Adresse #8 = Usericon
                bsr     get_adress      ;und Adresse holen
                addq.l  #4,A0           ;Auf Grafik gehen
                move.l  (SP)+,D0
                bra.s   draw_endlich
normales_icon:  lea     icons_offset,A0
                add.w   D2,D2           ;mal 2
                move.w  0(A0,D2.w),D2
                lea     icons,A0        ;Basisadresse der Grafiken
                lea     4(A0,D2.w),A0
draw_endlich:   move.l  A0,18(A6)       ;Anfangsadresse Quelle
                add.w   -4(A0),D5
                move.w  D5,0(A6)        ;Breite des Blocks in Pixeln
                add.w   #$000F,D5
                lsr.w   #4,D5
                add.w   D5,D5
                move.w  #2,22(A6)       ;Source-Offset zurselben Plane
                move.w  D5,24(A6)       ;Breite Quelle in Bytes
                clr.w   26(A6)          ;Source-Offset zur nÑchsten Plane
                move.w  #4,4(A6)        ;Anzahl an Planes
                add.w   -2(A0),D6
                move.w  D6,2(A6)        ;Hîhe in Pixeln
                move.l  scr1,32(A6)
                move.w  D0,28(A6)       ;Dest-X
                move.w  D1,30(A6)       ;Dest-Y
                move.w  #8,36(A6)
                move.w  #160,38(A6)
                move.w  #2,40(A6)
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D0-A6
                rts

                        IF 1=2
;Keine Label->unbenutzt

                movem.l D0-A6,-(SP)
                move.w  #-1,-(SP)
                move.l  #-1,-(SP)
                move.l  scr2,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP
                movem.l (SP)+,D0-A6
                rts

                movem.l D0-A6,-(SP)
                move.w  #-1,-(SP)
                move.l  #-1,-(SP)
                move.l  scr1,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP
                movem.l (SP)+,D0-A6
                rts
                        ENDC

L0332:          tst.b   grid_on
                beq.s   L0337           ;->RTS
                movem.l D0-A6,-(SP)
                linea   #0 [ Init ]
                lea     -$025A(A0),A0   ;aktuelle Mausposition.x
                move.w  (A0)+,D0        ;holen
                move.w  (A0),D1         ;maus_y
                cmp.w   board_y,D1      ;im Board?
                bge.s   L0336           ;->RTS

                moveq   #0,D3
                cmpi.w  #100,board_y
                bne.s   L0333
                move.w  grab_y,D3
L0333:          add.w   D3,D1
                addq.w  #4,D0
                addq.w  #4,D1
                moveq   #-8,D2
                and.w   D2,D0
                and.w   D2,D1
                sub.w   D3,D1
                cmp.w   #320,D0
                blt.s   L0334
                subq.w  #8,D0
L0334:          cmp.w   board_y,D1
                blt.s   L0335
                subq.w  #8,D1
L0335:          move.w  D1,(A0)         ;Maus setzen
                move.w  D0,-(A0)
                move.w  D0,mouseirq_x
                move.w  D1,mouseirq_y
                move.w  D0,mousex
                move.w  D1,mousey
                clr.b   L079E
                clr.b   L079F
L0336:          movem.l (SP)+,D0-A6
L0337:          rts

ms_button_irq:  tst.w   get_mouse_button
                bne.s   L0339
                rts
L0339:          jmp     $00000000
old_button_irq          EQU L0339+2

;Mausirq-Routine
ms_move_irq:    tst.b   scroll_aktiv    ;Ist Laufschrift an?
                bne.s   drunter         ;Nein
                cmp.w   #177,D1         ;In Laufschrift?
                blt.s   drunter
                move.w  #177,D1         ;Dann Drunter bleiben
drunter:        tst.b   grid_on         ;Grid an?
                beq     L0353
                move.w  D1,-(SP)        ;Maus_Y
                move.w  board_y,D1
                cmp.w   mouseirq_y,D1
                bgt.s   L033F
                move.w  (SP)+,D1
                cmp.w   board_y,D1      ;Maus oberhalb Board?
                blt.s   L033C           ;ja
                tst.b   L07A3
                beq     L0344
                btst    #0,L07A3
                bne.s   L0340
                clr.b   L07A3
                bra.s   L0344
L033C:          move.w  grab_y,D1       ;maus
                andi.w  #7,D1
                move.b  L033E(PC,D1.w),D1
                addq.w  #4,D0           ;X+=4
                andi.w  #%1111111111111000,D0
                cmpi.w  #320,D0
                blt.s   L033D
                subq.w  #8,D0           ;8 zurÅck
L033D:          move.w  D0,mousex       ;x speichern
                bra.s   L0344

L033E:                  DC.B 96,95,94,93,92,99,98,97

L033F:          move.w  (SP)+,D1
L0340:          sub.w   mouseirq_y,D1
                bmi.s   L0341
                cmpi.w  #1,D1
                bgt.s   L0342
                bra.s   L0343
L0341:          cmpi.w  #-1,D1
                bge.s   L0343
L0342:          lsl.w   #2,D1
L0343:          add.b   D1,L079F
                cmpi.w  #$0064,board_y
                bne.s   L0345
                move.b  L079F,D1
                ext.w   D1
                asr.w   #2,D1
                add.w   mouseirq_y,D1
                cmp.w   board_y,D1
                blt.s   L0345
                move.b  #3,L07A3
                bra.s   L0345
L0344:          clr.b   L079F
                clr.b   L079E
                bra     L035D
L0345:          move.w  mouseirq_y,D1
                cmpi.b  #$20,L079F
                blt.s   L0346
                subi.b  #$20,L079F
                addq.w  #8,D1
                bra.s   L0347
L0346:          cmpi.b  #-$20,L079F
                bgt.s   L0347
                addi.b  #$20,L079F
                subq.w  #8,D1
L0347:          tst.w   D1
                bpl.s   L0348
                addq.w  #8,D1
                bra.s   L0349
L0348:          cmpi.w  #$00C8,D1
                blt.s   L034A
                subq.w  #8,D1
L0349:          clr.b   L079F
L034A:          move.w  D1,mouseirq_y
                sub.w   mouseirq_x,D0
                bmi.s   L034B
                cmpi.w  #1,D0
                bgt.s   L034C
                bra.s   L034D
L034B:          cmpi.w  #-1,D0
                bge.s   L034D
L034C:          lsl.w   #2,D0
L034D:          add.b   D0,L079E
                move.w  mouseirq_x,D0
                cmpi.b  #$20,L079E
                blt.s   L034E
                subi.b  #$20,L079E
                addq.w  #8,D0
                bra.s   L034F
L034E:          cmpi.b  #-$20,L079E
                bgt.s   L034F
                addi.b  #$20,L079E
                subq.w  #8,D0
L034F:          tst.w   D0
                bpl.s   L0350
                addq.w  #8,D0
                bra.s   L0351
L0350:          cmpi.w  #320,D0
                blt.s   L0352
                subq.w  #8,D0
L0351:          clr.b   L079E
L0352:          move.w  D0,mouseirq_x
                bra     L035C

L0353:          tst.w   evt_timer_aus   ;Sind die Timer an?
                beq     L035D           ;Ja, normal abspeichern
                tst.w   L078C
                beq     L035C           ;Testen auf 319 und raus
                movem.l D0-D1,-(SP)     ;Koordinaten sichern
                sub.w   mouseirq_x,D0
                bcc.s   L0355
                cmpi.w  #-1,D0          ;eins nach links?
                bcs     L035F
                tst.b   L079E
                bmi.s   L0354
                move.b  #%10000001,L079E
                bra.s   L0357
L0354:          addq.b  #1,L079E
                cmpi.b  #-$7C,L079E
                bne.s   L0357
                move.b  #$80,L079E
                subq.w  #1,mouseirq_x
                bpl.s   L0357
                move.w  #0,mouseirq_x
                bra.s   L0357
L0355:          beq.s   L0357
                cmpi.w  #2,D0
                bcc     L035F
                tst.b   L079E
                bpl.s   L0356
                move.b  #1,L079E
                bra.s   L0357
L0356:          addq.b  #1,L079E
                cmpi.b  #4,L079E
                bne.s   L0357
                move.b  #0,L079E
                addq.w  #1,mouseirq_x
L0357:          sub.w   mouseirq_y,D1
                bcc.s   L0359
                cmpi.w  #-1,D1
                bcs     L035F
                tst.b   L079F
                bmi.s   L0358
                move.b  #-$7F,L079F
                bra.s   L035B
L0358:          addq.b  #1,L079F
                cmpi.b  #%10000100,L079F
                bne.s   L035B
                move.b  #-$80,L079F
                subq.w  #1,mouseirq_y
                bpl.s   L035B
                move.w  #0,mouseirq_y
                bra.s   L035B
L0359:          beq.s   L035B
                cmpi.w  #2,D1
                bcc.s   L035F
                tst.b   L079F
                bpl.s   L035A
                move.b  #1,L079F
                bra.s   L035B
L035A:          addq.b  #1,L079F
                cmpi.b  #4,L079F
                bne.s   L035B
                move.b  #0,L079F
                addq.w  #1,mouseirq_y
L035B:          addq.w  #8,SP
                move.w  mouseirq_x,D0
                move.w  mouseirq_y,D1
L035C:          cmpi.w  #320,D0
                bcs.s   L035D
                move.w  #319,D0
L035D:          move.w  D0,mouseirq_x
                move.w  D1,mouseirq_y
                jmp     far_rts         ;muû JMP bleiben!
old_ms_move             EQU L035D+14

L035F:          movem.l (SP)+,D0-D1
                bra.s   L035C

switch_alert:   move.l  D0,-(SP)        ;Adresse retten
                bsr     Hm
                bsr     alle_irqs_aus
                bsr     switch2tos
                move.l  (SP)+,D0
                bsr.s   alert
neo_an:         bsr     switch2neo
alle_irqs_an:   move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                rts

alert:          move.l  D0,addr_in      ;String merken
                bsr     Sm
                move.w  #1,int_in       ;1. Button Default
                move.l  #form_alert,D0
                jsr     _aes
L0361:          rts

;Schaut ob ein Blitter vorhanden ist und schaltet ihn ggf. an (CHS)
check_blitter:  movem.l D0-A6,-(SP)

                move.w  #-1,-(SP)
                move.w  #64,-(SP)
                trap    #14
                addq.l  #4,SP
                btst    #1,D0           ;Blitter vorhanden?
                beq.s   glue_geh_heim

                clr.w   blitter_da      ;Blitter ist da!
                tst.w   blitter_an      ;Blitter anschalten?
                bne.s   blitter_weg     ;Nein, ausschalten
                bsr.s   blitter_on      ;Dann Blitter anschalten

glue_geh_heim:  movem.l (SP)+,D0-A6
                rts

blitter_weg:    bsr.s   blitter_off
                bra.s   glue_geh_heim

;Schaltet den Blitter aus (CHS):
blitter_off:    movem.l D0-A6,-(SP)

                move.w  #%0000000000000000,-(SP)
                move.w  #64,-(SP)
                trap    #14             ;Blitter ausschalten
                addq.l  #4,SP
                move.w  #-1,blitter_an  ;Blitter ist jetzt aus

                movem.l (SP)+,D0-A6
                rts

;Schaltet den Blitter an (CHS):
blitter_on:     tst.w   blitter_da      ;öberhaupt ein Blitter da?
                bne.s   no_on           ;Nein, nicht anschalten

                movem.l D0-A6,-(SP)

                move.w  #%0000000000000011,-(SP)
                move.w  #64,-(SP)
                trap    #14             ;Blitter anschalten
                addq.l  #4,SP

                clr.w   blitter_an      ;Blitter ist jetzt an

                movem.l (SP)+,D0-A6
no_on:          rts

;Testet, ob ein STE vorliegt (CHS)
;RÅckgabe in D0 (0=STE, -1=Sonst)
check_ste:      clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor an
                addq.l  #6,SP
                move.l  D0,-(SP)

                move.b  #-2,$FFFF820D.w ;STE-Test
                cmpi.b  #-2,$FFFF820D.w
                bne.s   no_ste
                clr.b   $FFFF820D.w
                tst.b   $FFFF820D.w
no_ste:         sne     D2
                ext.w   D2
                move.w  D2,ani_x1

                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor aus
                addq.l  #6,SP

                move.w  ani_x1,D0       ;RÅckgabe-Wert holen
                rts

;Setzt die Synchronisationsfrequenz:
; D7: Neuer Wert fÅr $ff820a
set_sync:       movem.l D0-A6,-(SP)

                move.b  D7,neue_sync

                pea     sync_mcode(PC)
                move.w  #38,-(SP)
                trap    #14
                addq.l  #6,SP

                movem.l (SP)+,D0-A6
                rts

sync_mcode:     move.b  $FFFF820A.w,D0  ;Sync holen
                and.b   #%11111101,D0   ;Bit lîschen
                or.b    neue_sync,D0    ;Neue Sync einodern
                bsr     vsync           ;Vsync machen
                move.b  D0,$FFFF820A.w  ;und setzen
                rts

;Setzt das Bit #7 im Port A entsprechend, d.h. Schaltet Cache an/aus
set_porta:      tst.b   porta           ;PortA Bit #7 setzen?
                beq.s   setzen2
                move.w  #%0000000001111111,-(SP)
                move.w  #29,-(SP)
                trap    #14
                addq.l  #4,SP
                rts
setzen2:        move.w  #%0000000010000000,-(SP)
                move.w  #30,-(SP)
                trap    #14
                addq.l  #4,SP
                rts

;Initialisiert das gesamte System von NEOchrome:
init_neochrome: movem.l D0-A6,-(SP)

                move.w  #anz_raster-1,D7 ;100 Paletten fÅllen
                movem.l palette,D0-D6/A1 ;Palette holen
                lea     hbl_system,A0
                lea     hbl_put_get,A2
fill_paletten:  clr.w   (A0)
                clr.w   (A2)
                movem.l D0-D6/A1,2(A0)
                movem.l D0-D6/A1,2(A2)
                lea     34(A0),A0       ;und nÑchste Palette
                lea     34(A2),A2
                dbra    D7,fill_paletten

                lea     hbl_put_get,A0
                move.w  #66,34(A0)
                move.w  #$0700,36(A0)   ;Deutschland-Flagge in Get-Put Buffer
                move.w  #132,34*2(A0)
                move.w  #$0760,2+34*2(A0)

                move.w  anz_screens,D7
                mulu    #anz_raster,D7
                subq.w  #1,D7           ;Anzahl der Rasterzeilen-1
                movea.l hbls,A0
fill_paletten2: clr.w   (A0)
                movem.l D0-D6/A1,2(A0)
                lea     34(A0),A0       ;und nÑchste Palette
                dbra    D7,fill_paletten2

                bsr     calc_offsets
                bsr     rst22rst1       ;in Rasters1 Åbertragen
                move.l  #rasters1,rasters ;und anschalten

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor an
                addq.l  #6,SP
                move.l  D0,old_ssp

                moveq   #$15,D0         ;Disable Joysticks
                bsr     send_ikbd
                moveq   #$08,D0         ;rel. Maus an
                bsr     send_ikbd

end_patch:              IF disk_version<>0
                move.l  #ende_error,$0000040C.w ;Bei Abbruch Workstations schliessen
                        ENDC

                move.l  #tastatur_buffer,tastatur_write.w

                move.w  #34,-(SP)       ;Kbdvbase
                trap    #14
                addq.l  #2,SP
                movea.l D0,A0
                move.l  16(A0),mausrout ;Adresse der Mausroutine
                movea.l 32(A0),A0       ;Adresse der IKBD-Routine

xbra_loop:      cmpi.l  #'XBRA',-12(A0) ;XBRA-Kennung?
                bne.s   no_xbra
                movea.l -4(A0),A0       ;Alter Vektor holen
                bra.s   xbra_loop

no_xbra:        cmpi.w  #$41F8,(A0)     ;lea xxx.w,a0 (TOS 030)?
                beq.s   tos030
                cmpi.w  #$41ED,(A0)     ;lea xxx(a5),a0?
                bne.s   no_mouse_jmp    ;nein->falsches TOS oder Treiber

tos030:         move.l  (A0),a0_laden   ;Befehl eintragen
                cmpi.w  #$FC00,6(A0)    ;Absolut Kurze-Adressierung?
                beq.s   abs_kurz
                addq.l  #2,A0           ;Sonst 2 Byte mehr
abs_kurz:       addq.l  #8,A0           ;lea fc00,a1 Åberspringen
                move.l  A0,sprung_ikbd+2

                movea.l D0,A6

                move    SR,-(SP)
scheisse:       move    #$2300,SR       ;Tastatur zulassen
warte_paket:    tst.b   $0024(A6)       ;Paket fertig?
                bne.s   warte_paket
                move    #$2700,SR
                tst.b   $0024(A6)       ;Neues Paket da?
                bne.s   scheisse

                move.l  32(A6),old_tastatur
                move.l  #neue_tastatur,32(A6) ;Neue Tastaturroutine einhÑngen
                move    (SP)+,SR
                bra.s   wt65
no_mouse_jmp:   move.b  #$60,branch_kurz ;Keine Tastaturabfrage im HBL
wt65:           clr.w   evt_timer_aus   ;Kein HBL, bitte

                movem.l $FFFF8240.w,D0-D7 ;Palette holen
                movem.l D0-D7,tos_pal   ;und speichern
                movem.l D0-D7,palette_undo

                move.b  $FFFF820A.w,old_sync ;Alte Synchronisation merken

                move.l  $00000404.w,old_critic ;evt_critic retten
                move.l  #evt_critic,$00000404.w ;Zeigt auf RTS
                move.l  $00000400.w,old_timer
                move.l  #evt_timer,$00000400.w
                move.l  $00000118.w,old_118 ;ACIA-IRQ Vektor
                move.l  #acia_irq,$00000118.w
                move.l  $00000114.w,old_timer_c
                move.l  #timer_c,$00000114.w
                move.l  $00000120.w,old_timer_b
                move.l  $00000070.w,old_vbl

                move.b  $00000484.w,old_conterm
                bclr    #3,$00000484.w  ;Kbshift nicht bei Cconin zurÅckliefern

                movea.l $000004F2.w,A0  ;sysbase
                move.w  2(A0),tos_version

                move.l  old_ssp,-(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor aus
                addq.l  #6,SP

                bsr.s   init_hbl        ;HBL auch initialisieren

                bsr     palette_changed ;Es wurde an der Palette geÑndert

                cmpi.b  #$60,branch_kurz ;Tastaturabfrage im Raster?
                bne.s   wt66            ;Ja->Weiter

                move.l  #attention_raster,D0
                bsr     alert

wt66:           movem.l (SP)+,D0-A6
                rts

;Diese Routine initialisiert die Raster:
init_hbl:       movem.l D0-A6,-(SP)

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Supervisor anschalten
                addq.l  #6,SP
                move.l  D0,-(SP)

                move    SR,-(SP)
                move    #$2700,SR       ;IRQs sperren

                andi.b  #$FE,$FFFFFA07.w ;Timer B IRQ sperren
;                andi.b  #%11011111,$FFFFFA09.w ;200Hz sperren

                clr.b   $FFFFFA1B.w     ;Timer B STop!

                move.l  #timer_b_aus,$00000120.w
                move.l  #vbl,$00000070.w

                ori.b   #1,$FFFFFA07.w  ;Timer B zulassen
                ori.b   #1,$FFFFFA13.w  ;nicht maskieren
                bclr    #0,$FFFFFA0F.w  ;In-Service Bit lîschen
                bclr    #3,$FFFFFA03.w  ;Timer B am Ende der Rasterzeile bitte

                move    (SP)+,SR

                move.w  #$0020,-(SP)
                trap    #1
                addq.l  #6,SP

                movem.l (SP)+,D0-A6
                rts


;Hier kommt eine Routine hin, die ziemlich gewagt ist, sie springt nÑmlich direkt
;ins TOS in Tastaturauswert-Routine.
;Achtung! Zerstîrt ziemlich viele Register!
; D0.B: Wert, der ans OS als Byte vom IKBD Åbergeben werden soll
Åbergib_tastatur:tst.l  sprung_ikbd+2   ;Adresse eingetragen?
                beq.s   to_rts          ;Nein->vergessen
                move.l  A0,-(SP)        ;a0 retten
                suba.l  A5,A5
                lea     pseudo_acia,A1  ;Adresse des vermeintlichen ACIAs
                move.b  #%10000001,(A1) ;IRQ-Request+Receiver full
                move.b  D0,2(A1)        ;und Wert eintragen
a0_laden:       lea     $0000(A5),A0    ;Hier wird richtiger OPcode eingetragen
sprung_ikbd:    jsr     $00000000
                movea.l (SP)+,A0
to_rts:         rts

;Diese IRQ-Routine wird angesprungen, falls von der Tastatur ein Zeichen
;abgeholt werden soll.
;Achtung, zerstîrt ziemlich viele Register!
neue_tastatur:  movem.l D0-A6,-(SP)     ;Alle Register retten

                btst    #0,$FFFFFC00.w  ;Byte angekommen?
                beq.s   start_send      ;Nein, weitermachen

hol_byte:       move    SR,-(SP)
                move    #$2700,SR       ;HBL sperren
                move.b  $FFFFFC00.w,D0  ;ACIA-Status holen
                btst    #0,D0           ;Receiver full, also Byte da?
                beq.s   no_byte_da      ;Nein->Scheiû HBL hat geklaut
                movea.l tastatur_write.w,A0
                move.b  $FFFFFC02.w,(A0)+ ;Wert merken
                move.l  A0,tastatur_write.w ;Neue Schreibposition merken
no_byte_da:     move    (SP)+,SR
                btst    #5,D0           ;Overrun?
                beq.s   start_send

                clr.b   overrun         ;merken
                move.b  $FFFFFC02.w,D0  ;Daten nochmal lesen, Status lîschen

start_send:     tst.b   overrun         ;Ist Overrun aufgetreten?
                beq     overrun_auswert ;ja, neu synchronisieren
                movea.l tastatur_read,A0 ;Leseposition
                clr.w   offx
                clr.w   offy
                moveq   #0,D0
                moveq   #0,D1
                lea     sende_buffer,A2 ;hier wird der Sendebuffer aufgebaut
                move.b  old_mk,neu_mk   ;Alte Maustaste eintragen

weitersuchen:   cmpa.l  tastatur_write.w,A0 ;Schreibposition erreicht?
                bge.s   start_senden    ;ja, Ende interpret
                move.b  (A0)+,D0        ;Zeichen holen
                cmp.b   #$F6,D0         ;Paket?
                bcs.s   senden          ;Nein, also senden
                move.b  D0,D1
                sub.w   #$00F6,D1
                lea     paket_tabelle,A1
                move.b  0(A1,D1.w),D1   ;LÑnge des Pakets-1 holen
                lea     -1(A0,D1.w),A1  ;letztes Byte des Pakets
                cmpa.l  tastatur_write.w,A1 ;Ist das Paket komplett?
                blt.s   paket_komplett  ;Ja, auswerten
                subq.l  #1,A0           ;Um den Header zurÅckgehen
                bra.s   start_senden

paket_komplett: cmpi.b  #$F8,D0         ;rel. Maus?
                blt.s   kopier_paket    ;Nein->Weiter
                cmpi.b  #$FB,D0         ;rel. Maus?
                bgt.s   kopier_paket    ;Nein->Weiter

                move.b  D0,neu_mk       ;Neue Maustasten merken
                move.b  (A0)+,D0        ;X Offset holen
                ext.w   D0
                add.w   D0,offx         ;und dazuaddieren
                move.b  (A0)+,D0
                ext.w   D0
                add.w   D0,offy         ;Y Offset addieren
                bra.s   weitersuchen

kopier_paket:   move.b  D0,(A2)+        ;Header speichern
                bra.s   copy_dbra
copy_loop9:     move.b  (A0)+,(A2)+
copy_dbra:      dbra    D1,copy_loop9
                bra.s   weitersuchen

senden:         move.b  D0,(A2)+
                bra.s   weitersuchen

start_senden:   move.l  A0,ende_auswert ;Bis hier wurde ausgewertet
                move.l  A2,ende_sende   ;bis hier muû gesendet werden

                move.b  neu_mk,D0       ;Neue Maustasten holen
                move.w  offx,D1
                move.w  offy,D2         ;Mausbewegung holen
                bne.s   sende_relativ
                tst.w   D1              ;Bewegung um X-Achse?
                bne.s   sende_relativ   ;ja, absenden
                cmp.b   old_mk,D0       ;Hat sich bei den Tasten was geÑndert?
                beq     weitersenden    ;Nein, Rest senden

sende_relativ:  move.b  D0,old_mk       ;Neue Maustaste merken
                tst.b   cheat_modus     ;Cheat-Modus aktiv?
                bne.s   no_cheat2
                neg.w   D1              ;Achsen umdrehen
                neg.w   D2
no_cheat2:      cmp.w   #128,D1         ;grîûer als 127?
                blt.s   ok530
                moveq   #127,D1         ;max. 127 nehmen
ok530:          cmp.w   #-128,D1        ;kleiner als -128
                bge.s   ok531
                move.w  #-128,D1        ;min. -128 nehmen
ok531:          cmp.w   #128,D2         ;grîûer als 127?
                blt.s   ok532
                moveq   #127,D2         ;max. 127 nehmen
ok532:          cmp.w   #-128,D2        ;kleiner als -128
                bge.s   ok533
                move.w  #-128,D2        ;min. -128 nehmen
ok533:          lea     maus_paket,A0
                move.b  D0,(A0)
                move.b  D1,1(A0)        ;eintragen
                move.b  D2,2(A0)        ;-'-

                btst    #0,$FFFFFC00.w  ;Byte angekommen?
                beq.s   weiter4         ;Nein, weitermachen

                move    SR,-(SP)
                move    #$2700,SR       ;HBL sperren
                move.b  $FFFFFC00.w,D0  ;ACIA-Status holen
                btst    #0,D0           ;Receiver full, also Byte da?
                beq.s   no_byte_da2     ;Nein->Scheiû HBL hat geklaut
                movea.l tastatur_write.w,A3
                move.b  $FFFFFC02.w,(A3)+ ;Wert merken
                move.l  A3,tastatur_write.w ;Neue Schreibposition merken
no_byte_da2:    move    (SP)+,SR
                btst    #5,D0           ;Overrun?
                beq.s   weiter4
                clr.b   overrun         ;merken
                move.b  $FFFFFC02.w,D0  ;Byte nochmal lesen,Status lîschen

weiter4:        tst.b   overrun         ;Ist Overrun aufgetreten?
                beq     overrun_auswert ;ja, neu synchronisieren

                move.l  A0,-(SP)        ;Adresse auch auf Stack
                movea.l mausrout,A3
                jsr     (A3)            ;Direkt in Mausroutine springen
                addq.l  #4,SP

weitersenden:   btst    #0,$FFFFFC00.w  ;Byte angekommen?
                beq.s   weiter2         ;Nein, weitermachen

                move    SR,-(SP)
                move    #$2700,SR       ;HBL sperren
                move.b  $FFFFFC00.w,D0
                btst    #0,D0           ;Receiver full, also Byte da?
                beq.s   no_byte_da3     ;Nein->Scheiû HBL hat geklaut
                movea.l tastatur_write.w,A0
                move.b  $FFFFFC02.w,(A0)+ ;Wert merken
                move.l  A0,tastatur_write.w ;Neue Schreibposition merken
no_byte_da3:    move    (SP)+,SR
                btst    #5,D0           ;Overrun?
                beq.s   weiter2
                clr.b   overrun         ;merken
                move.b  $FFFFFC02.w,D0  ;Daten nochmal lesen, Status lîschen

weiter2:        tst.b   overrun         ;Ist Overrun aufgetreten?
                beq.s   overrun_auswert ;ja, neu synchronisieren
                lea     sende_buffer,A0
                bra.s   sende_if
senden_loop:    move.b  (A0)+,D0        ;Normale Pakete und Bytes ans OS
                bsr     Åbergib_tastatur
sende_if:       cmpa.l  ende_sende,A0   ;Ende erreicht?
                blt.s   senden_loop
                lea     tastatur_buffer,A0
                movea.l ende_auswert,A1
                tst.b   overrun         ;Overrun Error?
                beq.s   overrun_auswert
                move    SR,-(SP)
                move    #$2700,SR
                move.l  A0,tastatur_read ;vorne im Buffer anfangen zu lesen
                bra.s   copy_if
copy_buffer:    move.b  (A1)+,(A0)+
copy_if:        cmpa.l  tastatur_write.w,A1
                blt.s   copy_buffer
                move.l  A0,tastatur_write.w
                move    (SP)+,SR

                btst    #0,$FFFFFC00.w  ;noch ein Zeichen angekommen?
                bne     hol_byte        ;ja, abholen

                clr.w   screen_counter  ;fÅr Screensaver

ende_tastatur:  movem.l (SP)+,D0-A6     ;Register wieder holen
                rts

;Es ist ein Overrun aufgetreten. Deshalb wird der IKBD auf absolute Maus
;umgeschaltet, und gewartet, bis keine Daten mehr kommen. Dann wird wieder
;auf relative Maus zurÅckgeschaltet. Damit bekommt der Computer den Anfang
;eines Datenpakets wieder mit.
overrun_auswert:move    #$2300,SR       ;VBL zulassen

                moveq   #4,D1           ;LÑnge
                lea     abs_maus_an,A0
                bsr.s   send_ikbd_str

                move.w  #3000,D7        ;Counter

warten_ende:    btst    #0,$FFFFFC00.w  ;Byte angekommen?
                beq.s   nichts_da
                move.w  #3000,D7
                move.b  $FFFFFC02.w,D0  ;abholen
nichts_da:      tst.w   D7
                dbmi    D7,warten_ende

                moveq   #$08,D0
                bsr.s   send_ikbd       ;rel. Maus wieder anschalten

                lea     tastatur_buffer,A0
                move    SR,-(SP)
                move    #$2700,SR       ;Tastaturbuffer lîschen
                move.b  #1,overrun      ;Jetzt kein Overrun mehr!
                move.l  A0,tastatur_read
                move.l  A0,tastatur_write.w
                move    (SP)+,SR

                bra.s   ende_tastatur

acia_irq:       move    acia_irq_sr,SR  ;entsprechende IRQ's maskieren
tb1:            jmp     $00000000       ;und weiter ins OS
old_118                 EQU tb1+2

timer_c:        move    acia_irq_sr,SR  ;entsprechende IRQ's maskieren
tb2:            jmp     $00000000       ;und tschÅss
old_timer_c             EQU tb2+2

evt_timer:      tst.w   evt_timer_aus   ;evt_timer ausfÅhren?
                beq.s   L0367           ;ja
                rts                     ;Sonst zurÅck bitte
L0367:          jmp     $00000000
old_timer               EQU L0367+2


;öbermittelt einen String an den IKBD
; A0.L: Stringadresse
;  D1.W: LÑnge-1
send_ikbd_str:  move.b  (A0)+,D0
                bsr.s   send_ikbd
                dbra    D1,send_ikbd_str
                rts

;öbermittelt ein Byte an die Tastatur
; D0.B: Wert, der gesendet werden soll
send_ikbd:      btst    #1,$FFFFFC00.w  ;ACIA bereit?
                beq.s   send_ikbd       ;Nein, warten
                move.b  D0,$FFFFFC02.w  ;und abschicken
                rts

;Dies ist die VBL-Routine aus NEOchrome
vbl:            move    #$2700,SR       ;Erstmal Raster initialisieren
                movem.l D0-A6,-(SP)

                movea.l rasters,A1      ;von hier die Raster holen
                tst.b   tos_screen      ;TOS aktiv?
                bne.s   take_raster
                movem.l tos_pal,D0-D7   ;ja, dann TOS-Palette nehmen
                bra.s   ssfhjd
take_raster:    movem.l 2(A1),D0-D7     ;VBL-Palette holen
ssfhjd:         movem.l D0-D7,$FFFF8240.w ;und setzen

                addq.w  #1,vblcounter   ;Ein VBL mehr

                tst.b   L079C
                bpl.s   L0370
                addq.b  #1,L079C
L0370:          tst.b   L079D
                bpl.s   L0371
                addq.b  #1,L079D
L0371:          lea     34(A1),A1       ;ersten Raster nehmen
                move.l  A1,raster_pos   ;Wieder von oben anfangen
                move.l  #raster_big_lupe,raster_big_pos ;Auch in Lupe von oben starten

                tst.b   raster_aus      ;Sollen die Raster ausgeschaltet werden?
                bne.s   nein_anlassen

                move.l  #vbl_raster+34,raster_pos
                move.w  vbl_raster,D0   ;Holen
                bra.s   und_setzen      ;und anmachen

nein_anlassen:  lea     sync_hbl(PC),A0 ;Neue HBL-Routine nehmen
                move.w  -34(A1),D0      ;Rasteroffset holen
und_setzen:     bpl.s   neue_hbl        ;Ja, neue HBL-Routine nehmen
                btst    #14,D0          ;Randaufklapp-Raster?
                beq.s   board_raster2
                lea     rand_auf(PC),A0
                bra.s   neue_hbl
board_raster2:  lea     raster_board(PC),A0 ;als nÑchstes Board rastern
neue_hbl:       move.l  A0,$00000120.w  ;und eintragen
                move.l  #lupe,hbl_pos
                move.w  #16,hbl_counter ;16 KÑstchen hoch
                clr.b   $FFFFFA1B.w     ;Timer B Stop!
                tst.w   evt_timer_aus   ;HBL System aus?
                bne.s   hbl_noch_an     ;Nein, weiter
                move.l  #timer_b_aus,$00000120.w ;HBL aus
                bra.s   vbl_end

hbl_noch_an:    move.b  D0,$FFFFFA21.w  ;Hier beginnt der 1. Raster
                move.b  #8,$FFFFFA1B.w  ;Timer B Go!

vbl_end:        move    #$2300,SR       ;Neuen VBL wieder zulassen

                tst.b   screen_saver    ;Screen-Saver aktiv?
                bne.s   noch_nicht3

                move.w  screen_counter,D0
                addq.w  #1,D0
                cmpi.w  #3*60*60,D0     ;schon 3 Minuten vorbei?
                ble.s   noch_nicht2

                move    #$2500,SR       ;VBL sperren, Maus erlauben

                clr.b   $FFFFFA1B.w     ;Timer B Stop!
                movem.l zeros,D0-D7
                movem.l D0-D7,$FFFF8240.w ;und alles Schwarz

warten:         tst.w   screen_counter  ;und auf Mausbewegung warten
                bne.s   warten

                moveq   #0,D0
noch_nicht2:    move.w  D0,screen_counter

noch_nicht3:    movem.l (SP)+,D0-A6

                tst.b   scroll_aktiv
                bne.s   till89
                jsr     do_scroller

till89:         jmp     $00FC11A6       ;und in alte VBL-Routine
old_vbl                 EQU till89+2

;Dies ist die neue HBL-Routine, die nicht mit Blitter arbeitet, dafÅr aber
;absolut flackerfrei arbeitet
sync_hbl:       movem.l D0-A1,register

                movea.l raster_pos(PC),A0 ;Position des nÑchsten Rasters
nÑchster_raster:clr.b   $FFFFFA1B.w     ;Timer B Stop!
                move.w  (A0)+,D0        ;Position des nÑchsten Rasters
                bpl.s   normal_raster   ;positiv->normaler Raster
                btst    #14,D0          ;Randaufklapp-Raster?
                beq.s   board_raster
                move.l  #rand_auf,$00000120.w
                bra.s   normal_raster
board_raster:   move.l  #raster_board,$00000120.w ;Als nÑchstes Board rastern
normal_raster:  cmp.b   #1,D0           ;Abstand eins?
                beq.s   kurzer_raster   ;ja, dann im IRQ bleiben
                move.b  D0,$FFFFFA21.w  ;NÑchsten Raster setzen
                move.b  #8,$FFFFFA1B.w  ;und wieder starten

                movem.l (A0)+,D1-D7/A1  ;Farben holen
                move.l  A0,raster_pos   ;und merken

cpsync_loop:    cmp.b   $FFFFFA21.w,D0  ;synchonisieren
                beq.s   cpsync_loop

                nop
                nop
                nop
                nop                     ;Flackern verhindern
                nop
                nop

                movem.l D1-D7/A1,$FFFF8240.w ;Farben setzen

                movem.l register,D0-A1
                bclr    #0,$FFFFFA0F.w  ;In-Service-Bit lîschen
                rte

raster_pos:             DC.L 0  ;Position des Rastersystems

kurzer_raster:  clr.b   $FFFFFA21.w     ;Timer setzen
                move.b  #8,$FFFFFA1B.w  ;und wieder starten

                move.b  $FFFFFC00.w,D1  ;ACIA-Status holen
                btst    #0,D1           ;Receiver full, also Byte da?
branch_kurz:    beq.s   get_colors      ;Nein->nichts machen
                btst    #5,D1           ;Overrun?
                beq.s   hols_dir
                clr.b   overrun
hols_dir:       movea.l tastatur_write.w,A1
                move.b  $FFFFFC02.w,(A1)+ ;Wert merken
                move.l  A1,tastatur_write.w ;Neue Schreibposition merken

get_colors:     movem.l (A0)+,D1-D7/A1  ;Farben holen

                and.w   #%0100000000000000,D0 ;Nur Bit 14 lassen

cpsync_loop56:  tst.b   $FFFFFA21.w     ;synchonisieren
                beq.s   cpsync_loop56

                        REPT 4
                nop
                        ENDR

                movem.l D1-D7/A1,$FFFF8240.w ;Farben setzen

                tst.w   D0              ;Randaufklappung?
                bne     w1              ;ja->reinspringen

                tst.w   -34(A0)         ;Board anschalten?
                bpl     nÑchster_raster ;Nein, also normalen Raster setzen
                bra.s   nÑchstes_board

;Diese Routine schaltet in Scanline 100 die Board Palette an
raster_board:   movem.l D0-A1,register

nÑchstes_board: moveq   #10,D0          ;10 Pixel weiter einen IRQ (nach Palette)
                clr.b   $FFFFFA1B.w     ;Timer B Stop!
                move.b  D0,$FFFFFA21.w  ;NÑchsten Raster setzen
                move.b  #8,$FFFFFA1B.w  ;und wieder starten

                move.l  #change_palette,$00000120.w ;Als nÑchstes Board rastern
                movem.l board_palette(PC),D1-D7/A1

cpsync_loop2:   cmp.b   $FFFFFA21.w,D0  ;synchonisieren
                beq.s   cpsync_loop2

                nop
                nop
                nop
                nop                     ;Flackern verhindern
                nop
                nop

                movem.l D1-D7/A1,$FFFF8240.w ;Farben setzen

                movem.l register,D0-A1
                bclr    #0,$FFFFFA0F.w  ;In-Service-Bit lîschen
                rte

;Diese Routine wird direkt unter der Palette aufgerufen
change_palette: move.l  D0,register

                tst.b   lupe_an         ;Ist groûe Lupe an?
                bne.s   alte_lupe

                move.w  magtyp,D0       ;Lupentyp holen
                move.b  lupen_zeilen(PC,D0.w),raster_zahl ;Anzahl an Raster merken

                move.b  lupen_abstÑnde(PC,D0.w),lupen_abstand
                move.l  #change_big_lupe,$00000120.w ;Als nÑchstes Board rastern
                moveq   #4,D0           ;4 Zeilen weiter startet groûe Lupe
                bra.s   beide_lupen

alte_lupe:      move.l  #change_lupe,$00000120.w ;Als nÑchstes Board rastern
                moveq   #5,D0           ;5 Pixel weiter einen IRQ (hier startet Lupe)
beide_lupen:    clr.b   $FFFFFA1B.w     ;Timer B Stop!
                move.b  D0,$FFFFFA21.w  ;NÑchsten Raster setzen
                move.b  #8,$FFFFFA1B.w  ;und wieder starten

cpsync_loop3:   cmp.b   $FFFFFA21.w,D0  ;synchonisieren
                beq.s   cpsync_loop3

                nop
                nop
                nop
                nop                     ;Flackern verhindern
                nop
                nop

                moveq   #0,D0           ;Schwarz
                move.w  D0,$FFFF8240.w
                eori.w  #-1,D0          ;negieren
                move.w  D0,$FFFF825E.w  ;Als 'weiû' nehmen
                move.w  color,$FFFF825C.w

                move.l  register,D0
                bclr    #0,$FFFFFA0F.w  ;In-Service-Bit lîschen
                rte

;AbstÑnde zwischen den Rastern der groûen Lupe:
lupen_abstÑnde:         DC.B 5,4,8,16
lupen_zeilen:           DC.B 1,21,10,5
lupen_abstand:          DC.B 0  ;Abstand der aktuellen Lupe

;Diese Routine wird alle 5 Scanlines aufgerufen und schaltet die Lupe um (fÅr alte Lupe)
change_lupe:    move.l  A1,-(SP)        ;24 -> 14

                movea.l hbl_pos(PC),A1
                move.l  (A1)+,$FFFF8242.w ;20 -> 24
                move.l  (A1)+,$FFFF8246.w
                move.l  (A1)+,$FFFF824A.w
                move.l  (A1)+,$FFFF824E.w
                move.l  (A1)+,$FFFF8252.w ;Summe 192 -> 182
                move.l  (A1)+,$FFFF8256.w
                move.w  (A1)+,$FFFF825A.w ;12 -> 16
                move.l  A1,hbl_pos

                subq.w  #1,hbl_counter
                bpl.s   weiter_gehts
                clr.b   $FFFFFA1B.w     ;Timer B Stop!
weiter_gehts:   movea.l (SP)+,A1        ;28 -> 12
timer_b_aus:    bclr    #0,$FFFFFA0F.w
                rte

;Diese Routine schaltet die Raster in der groûen Lupe um
change_big_lupe:movem.l D0-A1,register

                move.b  lupen_abstand(PC),D0
                clr.b   $FFFFFA1B.w     ;Timer B Stop!
                move.b  D0,$FFFFFA21.w  ;NÑchsten Raster setzen
                move.b  #8,$FFFFFA1B.w  ;und wieder starten

                movea.l raster_big_pos(PC),A0 ;Position des nÑchsten Rasters
                movem.l (A0)+,D1-D7/A1  ;Farben holen
                move.l  A0,raster_big_pos ;und merken

cpsync_loop6:   cmp.b   $FFFFFA21.w,D0  ;synchonisieren
                beq.s   cpsync_loop6

                nop
                nop
                nop
                nop                     ;Flackern verhindern
                nop
                nop

                movem.l D1-D7/A1,$FFFF8240.w ;Farben setzen

                subq.b  #1,raster_zahl  ;Noch Raster abzuarbeiten?
                bne.s   noch_was_da
                clr.b   $FFFFFA1B.w     ;Timer B Stop!
noch_was_da:    movem.l register,D0-A1
kein_magnify:   bclr    #0,$FFFFFA0F.w  ;In-Service-Bit lîschen
                rte

raster_big_pos:         DC.L raster_big_lupe ;Position in raster_big_lupe
raster_zahl:            DC.B 10 ;Anzahl der noch verbleibenden Raster in der Big_Lupe

;Diese Routine klappt den unteren Rand auf im Fullscreen
;Dieser ist bei 50Hz 44 Zeilen hoch
rand_auf:       tst.b   magnify         ;Lupe vorhanden?
                bne.s   kein_magnify

                movem.l D0-A1,register

                movea.l raster_pos(PC),A0

w1:             clr.b   $FFFFFA1B.w     ;Timer B Stop!
                clr.b   $FFFFFA21.w     ;Counter setzen
                move.b  #8,$FFFFFA1B.w  ;und weiter zÑhlen
                movem.l board_palette(PC),D0-D7
ww1:            tst.b   $FFFFFA21.w     ;Synchronisieren
                beq.s   ww1

                bchg    #1,$FFFF820A.w

                bra     rand_wait
rand_wait_aus:  movem.l D0-D7,$FFFF8240.w

                move.b  $FFFFFA21.w,D0
ww3:            cmp.b   $FFFFFA21.w,D0  ;Nochmal synchronisieren
                beq.s   ww3

                move.b  $FFFFFA21.w,D1
ww4:            cmp.b   $FFFFFA21.w,D1  ;Nochmal synchronisieren
                beq.s   ww4

                        REPT 4
                nop
                        ENDR

                clr.w   $FFFF8240.w
                move.l  #$07000777,$FFFF825C.w ;Farben setzen

                move.b  $FFFFFA21.w,D1
ww5:            cmp.b   $FFFFFA21.w,D1  ;Nochmal synchronisieren
                beq.s   ww5
                move.b  $FFFFFA21.w,D1
ww6:            cmp.b   $FFFFFA21.w,D1  ;Nochmal synchronisieren
                beq.s   ww6

                clr.b   $FFFFFA1B.w     ;Timer B Stop!
                move.b  #5,$FFFFFA21.w
                move.b  #8,$FFFFFA1B.w

                move.l  #change_lupe,$00000120.w

                movem.l register,D0-A1
                bra     change_lupe     ;und Lupe darstellen

hbl_pos:                DC.L 0  ;Position der Lupe
board_palette:          DS.W 16 ;Platz fÅr die Palette des Boards

rand_wait:              REPT 210
                nop
                        ENDR
rand_wait_jmp:  bchg    #1,$FFFF820A.w
                jmp     rand_wait_aus   ;Muû JMP bleiben!

;TrÑgt, je nach nop_zahl die entsprechenden NOPs ein
compile_nops:   movem.l D0-A6,-(SP)

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Superloser an
                addq.l  #6,SP
                move.l  D0,-(SP)

                move.w  nop_zahl,D0
                lea     rand_wait(PC),A0
                lea     rand_wait_jmp(PC),A1
                move.w  #$4E71,D1       ;NOP
                move    SR,-(SP)
                move    #$2700,SR
fill_nops:      move.w  D1,(A0)+        ;entsprechende Anzahl NOPs eintragen
                dbra    D0,fill_nops
                move.l  (A1)+,(A0)+     ;bchg
                move.l  (A1)+,(A0)+     ;JMP
                move.l  (A1)+,(A0)+
                move    (SP)+,SR

                move.w  #$0020,-(SP)
                trap    #1              ;und wieder aus
                addq.l  #6,SP

                movem.l (SP)+,D0-A6
                rts

;IRQ-Routine zum Abspielen eines Hippelsound
music_irq:      move    #$2500,SR       ;HBL zulassen

                tst.b   music           ;Soll Musik dudeln?
                bne     keine_musik

                movem.l D0-A6,-(SP)     ;Register retten
                jsr     music_prg+8     ;und dudeln
                movem.l (SP)+,D0-A6

keine_musik:    bclr    #4,$FFFFFA11    ;In-Service Bit lîschen
                rte


;Schaltet eine Hippelmusik an/um,
; D0.W: Hippelsoundnummer
turn_music_on:  movem.l D0-A6,-(SP)

                tst.b   music
                bne     abschalten      ;Musik bitte abschalten

                lea     music_prg,A0    ;Start der Musik
                move.w  #$6000,D1
                cmp.w   (A0),D1         ;Branch.l
                bne     abschalten
                cmp.w   4(A0),D1
                bne     abschalten
                cmp.w   8(A0),D1
                bne     abschalten

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;in Supervisor gehen
                addq.l  #6,SP
                move.l  D0,-(SP)

                move.l  #music_irq,$00000110.w

                bclr    #4,$FFFFFA09    ;Timer D IRQ sperren
                andi.b  #%11110000,$FFFFFA1D ;Timer D Stop1
                move.b  #246,$FFFFFA25  ;Counterwert eintragen
                bset    #4,$FFFFFA15    ;Timer D nicht maskieren
                move.b  #%11101111,$FFFFFA0D ;Pending Bit lîschen
                ori.b   #%00000111,$FFFFFA1D ;Vorteiler teilt durch 200
                bset    #4,$FFFFFA09    ;Timer D erlauben

                bclr    #4,$FFFFFA11    ;In-Service lîschen

                move.l  4(SP),D0        ;Hippelnummer holen
                jsr     music_prg       ;und enspr. anschalten

music_ende:     move.w  #$0020,-(SP)
                trap    #1              ;Supervisor aus
                addq.l  #6,SP

                movem.l (SP)+,D0-A6
                rts

abschalten:     st      music           ;Musik ist jetzt aus

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1              ;Super an
                addq.l  #6,SP
                move.l  D0,-(SP)

                bclr    #4,$FFFFFA09.w  ;Timer D IRQ sperren
                lea     $FFFF8800.w,A0
                move.l  #$08080000,(A0)
                move.l  #$09090000,(A0) ;Alle LautstÑrken aus
                move.l  #$0A0A0000,(A0)
                bra.s   music_ende

;lÑdt die in fsel_path angegebene Musik
load_music:     movem.l D0-A6,-(SP)

                tst.b   music_path      ;File ausgewÑhlt?
                beq.s   keine_musik1

                bsr     fopen
                bmi.s   keine_musik1

                lea     music_prg,A6
                move.l  #hippel_len,D6
                bsr     read
                tst.w   D0              ;Fehler?
                bmi.s   fehler

                moveq   #1,D6
                bsr     read            ;Noch ein Byte vorhanden?
                bne.s   schliessen      ;Nein->Fclose

fehler:         clr.w   music_prg       ;Keine Musik geladen
schliessen:     bsr     fclose

keine_musik1:   movem.l (SP)+,D0-A6
                rts

;Wartet, bis Neochrom seinen Vsync macht
vsync_neo:      move.w  vblcounter,D0
wait_sync:      cmp.w   vblcounter,D0
                beq.s   wait_sync
                rts


                        PART 'AES/VDI-Calls'
;************************************************************************
;* Mein eigener kleiner AES-Aufruf                                      *
;* D0=Die ersten 4 EintrÑge im control-Array (Bytebreite!)              *
;*    Bit 24-31 = Der Opcode bzw. die Funktionsnummer                   *
;*    Bit 16-23 = Anzahl der EintrÑge in int_in                         *
;*    Bit 8-15  = Anzahl der EintrÑge in int_out                        *
;*    Bit 0-7   = Anzahl der EintrÑge in addr_in                        *
;* Die Anzahl der EintrÑge in addr_out ist stets 0.                     *
;* Ausnahme:Bei rsrc_gaddr() sollte dort eine 1 stehen (Atari hÑlt sich *
;*          allerdings selbst nicht dran)                               *
;************************************************************************
_aes:           movem.l D1-A6,-(SP)     ;besser retten, man kann nie wissen
                lea     control,A0
                clr.l   (A0)+
                clr.l   (A0)+           ;control-Array lîschen
                clr.w   (A0)
                movep.l D0,-7(A0)       ;und die neuen Daten eintragen
                cmpi.b  #112,-7(A0)     ;Ist es rsrc_gaddr()?
                bne.s   _aes1           ;Nein! =>
                move.b  #1,1(A0)        ;Anzahl der EintrÑge in addr_out=1
_aes1:          lea     _aes_pb(PC),A0
                move.l  A0,D1
                move.w  #200,D0
                move.w  #-1,get_mouse_button ;Mausbutton abfragen
                trap    #2              ;AES aufrufen
                clr.w   get_mouse_button ;Mausbutton nicht mehr abfragen
                moveq   #0,D0
                move.w  int_out,D0      ;int_out[0]
                movem.l (SP)+,D1-A6
                rts

_aes_pb:                DC.L control ;Der AES-Parameterblock
                        DC.L global
                        DC.L int_in
                        DC.L int_out
                        DC.L addr_in
                        DC.L addr_out

;************************************************************************
;* Und das gleiche nochmal fÅr die VDI-Funktionen                       *
;* D0 = Die Eingabeparameter                                            *
;*      Bit 24-31 = Opcode der Funktion                                 *
;*      Bit 16-23 = LÑnge des Intin-Arrays                              *
;*      Bit 8-15  = Identifikationsnummer fÅr Unter-Opcodes             *
;*      Bit 0-7   = Anzahl der EintrÑge in ptsin                        *
;* Die GerÑtekennung wird der Variable "gr_handle" entnommen.           *
;************************************************************************
_vdi:           movem.l D1-A6,-(SP)
                lea     control+2,A0
                clr.w   (A0)+           ;alle Parameter lîschen
                clr.l   (A0)+
                clr.w   (A0)
                move.l  D0,-(SP)
                tst.b   (SP)            ;kein Opcode vorhanden? => Kurzformat
                addq.l  #4,SP
                bne.s   _vdi1
                move.b  D0,1-8(A0)      ;Funktionsnummer in den Bits 0-7
                bra.s   _vdi2           ;alle anderen Parameter sind 0!
_vdi1:          move.b  D0,3-8(A0)      ;Anzahl der EintrÑge in ptsin
                lsr.w   #8,D0
                move.w  D0,10-8(A0)     ;Unter-Opcode
                swap    D0
                move.b  D0,7-8(A0)      ;Anzahl der EintrÑge in intin
                lsr.w   #8,D0
                move.w  D0,0-8(A0)      ;Funktionsnummer
_vdi2:          move.w  vdi_handle,12-8(A0) ;VDI-Handle
                lea     _vdi_pb(PC),A0
                move.l  A0,D1
                moveq   #$73,D0
                trap    #2
                moveq   #0,D0
                move.w  int_out,D0      ;int_out[0]
                movem.l (SP)+,D1-A6
                rts

_vdi_pb:                DC.L control ;Der VDI-Parameterblock
intin_pt:               DC.L int_in
                        DC.L ptsin
                        DC.L int_out
                        DC.L ptsout

                        ENDPART

                        PART 'AES/VDI-Library-EQUs'
;************************************************************************
;* Die AES-"Library"                                                    *
;************************************************************************
appl_init               EQU $0A000100
appl_read               EQU $0B020101
appl_write              EQU $0C020101
appl_find               EQU $0D000101
appl_tplay              EQU $0E020101
appl_trecord            EQU $0F010101
appl_bvset              EQU $10020100 ;ab GEM 2.0
appl_yield              EQU $11000100 ;ab GEM 2.0
appl_exit               EQU $13000100

evnt_keybd              EQU $14000100
evnt_button             EQU $15030500
evnt_mouse              EQU $16050500
evnt_mesag              EQU $17000101
evnt_timer              EQU $18020100
evnt_multi              EQU $19100701
evnt_dclick             EQU $1A020100

menu_bar                EQU $1E010101
menu_icheck             EQU $1F020101
menu_ienable            EQU $20020101
menu_tnormal            EQU $21020101
menu_text               EQU $22010102
menu_register           EQU $23010101
menu_unregister         EQU $24010100 ;ab GEM 2.0

objc_add                EQU $28020101
objc_delete             EQU $29010101
objc_draw               EQU $2A060101
objc_find               EQU $2B040101
objc_offset             EQU $2C010301
objc_order              EQU $2D020101
objc_edit               EQU $2E040201
objc_change             EQU $2F080101

form_do                 EQU $32010101
form_dial               EQU $33090100
form_alert              EQU $34010101
form_error              EQU $35010100
form_center             EQU $36000501
form_keybd              EQU $37030301
form_button             EQU $38020201

graf_rubberbox          EQU $46040300
graf_rubbox             EQU $46040300 ;dies ist der richtige Name!
graf_dragbox            EQU $47080300
graf_movebox            EQU $48060100
graf_mbox               EQU $48060100 ;dies ist der richtige Name!
graf_growbox            EQU $49080100
graf_shrinkbox          EQU $4A080100
graf_watchbox           EQU $4B040101
graf_slidebox           EQU $4C030101
graf_handle             EQU $4D000500
graf_mouse              EQU $4E010101
graf_mkstate            EQU $4F000500

srcp_read               EQU $50000101
srcp_write              EQU $51000101
scrp_clear              EQU $52000100 ;ab GEM 2.0

fsel_input              EQU $5A000202
fsel_exinput            EQU $5B000203 ;ab TOS 1.4

wind_create             EQU $64050100
wind_open               EQU $65050100
wind_close              EQU $66010100
wind_delete             EQU $67010100

wind_get                EQU $68020500
wind_set                EQU $69060100
wind_find               EQU $6A020100
wind_update             EQU $6B010100
wind_calc               EQU $6C060500
wind_new                EQU $6D000000 ;ab TOS 1.4

rsrc_load               EQU $6E000101
rsrc_free               EQU $6F000100
rsrc_gaddr              EQU $70020100
rsrc_saddr              EQU $71020101
rsrc_obfix              EQU $72010101

shel_read               EQU $78000102
shel_write              EQU $79030102
shel_get                EQU $7A010101
shel_put                EQU $7B010101
shel_find               EQU $7C000101
shel_envrn              EQU $7D000102
shel_rdef               EQU $7E000102 ;ab GEM 2.0
shel_wdef               EQU $7F000002 ;ab GEM 2.0

xgrf_stepcalc           EQU $82060600 ;ab GEM 2.0
xgrf_2box               EQU $83090100 ;ab GEM 2.0

; Die Messages des AES
MN_SELECTED             EQU 10  ;MenÅeintrag angewÑhlt
WM_REDRAW               EQU 20  ;Teil eines Windows muû neu gezeichnet werden
WM_TOPPED               EQU 21  ;Window ist nun das aktuelle Fenster
WM_CLOSED               EQU 22  ;Window soll geschlossen werden
WM_FULLED               EQU 23  ;Window soll auf max.Grîûe gebracht werden
WM_ARROWED              EQU 24  ;Scollbalken angeklickt
WM_HSLID                EQU 25  ;Der horizontale Slider wurde bewegt
WM_VSLID                EQU 26  ;Der vertikale Slider wurde bewegt
WM_SIZED                EQU 27  ;Die Grîûe des Windows wurde geÑndert
WM_MOVED                EQU 28  ;Das Window wurde bewegt
WM_NEWTOP               EQU 29  ;Das Fenster wurde aktiviert (siehe WM_TOPPED)
WM_UNTOPPED             EQU 30  ;Der Fenster wird gleich inaktiv (erst ab GEM 2.0!)
AC_OPEN                 EQU 40  ;Ein Acc wurde angeklickt.(30 bzw. 31 ist FALSCH!)
AC_CLOSE                EQU 41  ;Prg wurde beendet, ACC soll seinen Speicher freigeben.
CT_UPDATE               EQU 50
CT_MOVE                 EQU 51  ;Funktion unbekannt
CT_NEWTOP               EQU 52

; WM_ARROWED angeklickt (nun die genauere Definition)
WA_UPPAGE               EQU 0   ;Balken oberhalb des Sliders
WA_DNPAGE               EQU 1   ;Balken unterhalb des Sliders
WA_UPLINE               EQU 2   ;Pfeil nach oben
WA_DNLINE               EQU 3   ;Pfeil nach unten
WA_LFPAGE               EQU 4   ;Balken links vom Slider
WA_RTPAGE               EQU 5   ;Balken rechts vom Slider
WA_LFLINE               EQU 6   ;Pfeil nach links
WA_RTLINE               EQU 7   ;und Pfeil nach rechts

; Die Objekttypen des Resource-Baumes
G_BOX                   EQU 20
G_TEXT                  EQU 21
G_BOXTEXT               EQU 22
G_IMAGE                 EQU 23
G_PROGDEF               EQU 24
G_IBOX                  EQU 25  ;Bitte in entsprechender Literatur nachschlagen
G_BUTTON                EQU 26
G_BOXCHAR               EQU 27
G_STRING                EQU 28
G_FTEXT                 EQU 29
G_FBOXTEXT              EQU 30
G_ICON                  EQU 31
G_TITLE                 EQU 32

; Object-Flags bei einem Objekt
NONE_FLG                EQU $00000000
SELECTABLE_FLG          EQU $00000001
DEFAULT_FLG             EQU $00000002
EXIT_FLG                EQU $00000004
EDITABLE_FLG            EQU $00000008
RBUTTON_FLG             EQU $00000010 ;Bitte ebenfalls in der Literatur nachlesen
LASTOB_FLG              EQU $00000020
TOUCHEXIT_FLG           EQU $00000040
HIDETREE_FLG            EQU $00000080
INDIRECT_FLG            EQU $00000100

; Objekt-Status bei einem Objekt
NORMAL                  EQU $00000000
SELECTED                EQU $00000001
CROSSED                 EQU $00000002
CHECKED                 EQU $00000004 ;s.o.
DISABLED                EQU $00000008
OUTLINED                EQU $00000010
SHADOWED                EQU $00000020

; Die einzelnen Bits bei evnt_multi()
MU_KEYBD                EQU $00000001 ;Tastaturereignis
MU_BUTTON               EQU $00000002 ;Maustastenereignis
MU_M1                   EQU $00000004 ;1.Mausereignis
MU_M2                   EQU $00000008 ;2.Mausereignis
MU_MESAG                EQU $00000010 ;Message des AES
MU_TIMER                EQU $00000020 ;Timer-Ereignis

; form_dial()
FMD_START               EQU $00000000 ;Bildschirmhintergrund reservieren
FMD_GROW                EQU $00000001 ;Ausdehnende Box zeichnen
FMD_SHRINK              EQU $00000002 ;Schrumpfende Box zeichnen
FMD_FINISH              EQU $00000003 ;Bildschirmbereich wieder freigeben

; graf_mouse()
ARROW                   EQU $00000000
TEXT_CRSR               EQU $00000001
HOURGLASS               EQU $00000002
BUSYBEE                 EQU $00000002
POINT_HAND              EQU $00000003
FLAT_HAND               EQU $00000004
THIN_CROSS              EQU $00000005
THICK_CROSS             EQU $00000006
OUTL_CROSS              EQU $00000007
USER_DEF                EQU $000000FF
M_OFF                   EQU $00000100
M_ON                    EQU $00000101

; Parameter bei wind_create()
WI_NAME                 EQU $00000001
WI_CLOSE                EQU $00000002
WI_FULL                 EQU $00000004
WI_MOVE                 EQU $00000008
WI_INFO                 EQU $00000010
WI_SIZE                 EQU $00000020
WI_UPARROW              EQU $00000040
WI_DNARROW              EQU $00000080
WI_VSLIDE               EQU $00000100
WI_LFARROW              EQU $00000200
WI_RARROW               EQU $00000400
WI_HSLIDE               EQU $00000800

; Parameter bei wind_get() & wind_set()
WF_KIND                 EQU 1
WF_NAME                 EQU 2
WF_INFO                 EQU 3
WF_WORKXYWH             EQU 4
WF_CURRXYWH             EQU 5
WF_PREVXYWH             EQU 6
WF_FULLXYWH             EQU 7
WF_HSLIDE               EQU 8
WF_VSLIDE               EQU 9
WF_TOP                  EQU 10
WF_FIRSTXYWH            EQU 11
WF_NEXTXYWH             EQU 12
WF_NEWDESK              EQU 14
WF_HSLSIZE              EQU 15
WF_VSLSIZE              EQU 16

; wind_update()
END_UPDATE              EQU 0
BEG_UPDATE              EQU 1
END_MCTRL               EQU 2
BEG_MCTRL               EQU 3

;************************************************************************
;* Die VDI-"Library"                                                    *
;* Wer nÑheres dazu wissen mîchte, sollte sich im Profibuch von Sybex   *
;* die Informationen dazu besorgen.                                     *
;************************************************************************
;1. Kontrollfunktionen
v_opnwk                 EQU $010B0000 ;Open workstation
v_clswk                 EQU $02000000 ;Close workstation
v_opnvwk                EQU $640B0000 ;Open virtual screen workstation
v_clsvwk                EQU $65000000 ;Close virtual screen workstation
v_clrwk                 EQU $03000000 ;Clear workstation
v_updwk                 EQU $04000000 ;Update workstation
vst_load_fonts          EQU $77010000 ;Load fonts
unload_fonts            EQU $78010000 ;Unload fonts
vs_clip                 EQU $81010002 ;Set clipping rectangle
;2. Ausgabefunktionen
v_pline                 EQU $06000000 ;Polyline (Byte 0=count(n))
v_pmarker               EQU $07000000 ;Polymarker (Byte 0=count(n))
v_gtext                 EQU $08000001 ;Text (Byte 2=n)
v_fillarea              EQU $09000000 ;Filled area (Byte 0=count(n))
v_cellarray             EQU $0A000002 ;Cell array (Byte 2=n)
v_contourfill           EQU $67010001 ;Contour fill
vr_recfl                EQU $72000002 ;Fill rectangle
v_bar                   EQU $0B000102 ;Bar
v_arc                   EQU $0B020204 ;Arc
v_pieslice              EQU $0B020304 ;Pie
v_circle                EQU $0B000403 ;Circle
v_ellipse               EQU $0B000502 ;Ellipse
v_ellarc                EQU $0B020602 ;Elliptical arc
v_ellpie                EQU $0B020702 ;Elliptical pie
v_rbox                  EQU $0B000802 ;Rounded rectangle
v_rfbox                 EQU $0B000902 ;Filled rounded rectangle
v_justified             EQU $0B020A02 ;Justified graphics text (Byte 2=n+2)
;3. Attribut-Funktionen
vswr_mode               EQU $20010000 ;Set writing mode
vs_color                EQU $0E040000 ;Set color representation
vsl_type                EQU $0F010000 ;Set polyline line type
vsl_udsty               EQU $71010000 ;Set user-defined line style pattern
vsl_width               EQU $10000001 ;Set polyline line width
vsl_color               EQU $11010000 ;Set polyline color index
vsl_ends                EQU $6C020000 ;Set polyline end styles
vsm_type                EQU $12010000 ;Set polymarker type
vsm_height              EQU $13000001 ;Set polymarker height
vsm_color               EQU $14010000 ;Set polymarker color index
vst_height              EQU $0C000001 ;Set character height, absolute mode
vst_point               EQU $6B010000 ;Set character height, points mode
vst_rotation            EQU $0D010000 ;Set character baseline vector
vst_font                EQU $15010000 ;Set text face
vst_color               EQU $16010000 ;Set graphic text color index
vst_effects             EQU $6A010000 ;Set graphic text special effects
vst_alignment           EQU $27020000 ;Set graphic text alignment
vsf_interior            EQU $17010000 ;Set fill interior index
vsf_style               EQU $18010000 ;Set fill style index
vsf_color               EQU $19010000 ;Set fill color index
vsf_perimeter           EQU $68010000 ;Set fill perimeter visibility
vsf_udpat               EQU $70000000 ;Set user-defined fill pattern (Byte 2=16*planes)
;4. Rasteroperationen
vro_cpyfm               EQU $6D010004 ;Copy raster, opaque
vrt_cpyfm               EQU $79030004 ;Copy raster, transparent
vr_trnfm                EQU $6E000000 ;Transform form
v_get_pixel             EQU $69000001 ;Get pixel
;5. Eingabefunktionen
vsin_mode               EQU $21020000 ;Set input mode
vrq_locator             EQU $1C000001 ;Input locator, request mode
vsm_locator             EQU $1C000001 ;Input locator, sample mode
vrq_valuator            EQU $1D010000 ;Input valuator, request mode
vsm_valuator            EQU $1D010000 ;Input valuator, sample mode
vrq_choice              EQU $1E010000 ;Input choice, request mode
vsm_choice              EQU $1E010000 ;Input choice, sample mode
vrq_string              EQU $1F020001 ;Input string, request mode
vsm_string              EQU $1F020001 ;Input string, sample mode
vsc_form                EQU $6F250000 ;Set mouse form
vex_timv                EQU $76000000 ;Exchange timer interrupt vector
v_show_c                EQU $7A010000 ;Show cursor
v_hide_c                EQU $7B000000 ;Hide cursor
vq_mouse                EQU $7C000000 ;Sample mouse button state
vex_butv                EQU $7D000000 ;Exchange button change vector
vex_motv                EQU $7E000000 ;Exchange mouse movement vector
vex_curv                EQU $7F000000 ;Exchange cursor change vector
vq_key_s                EQU $80000000 ;Sample keyboard state information
;6. Auskunftsfunktionen
vq_extnd                EQU $66010000 ;Extended inquire function
vq_color                EQU $1A020000 ;Inquire color representation
vql_attributes          EQU $23000000 ;Inquire current polyline attributes
vqm_attributes          EQU $24000000 ;Inquire current polymarker attributes
vqf_attributes          EQU $25000000 ;Inquire current fill area attributes
vqt_attributes          EQU $26000000 ;Inquire current graphic text attributes
vqt_extent              EQU $74000000 ;Inquire text extent (Byte 2=n)
vqt_width               EQU $75010000 ;Inquire character cell width
vqt_name                EQU $82010000 ;Inquire face name and index
vq_cellarray            EQU $1B000002 ;Inquire cell array
vqin_mode               EQU $73010000 ;Inquire input mode
vqt_fontinfo            EQU $83000000 ;Inquire current face information
vqt_justified           EQU $84020002 ;Inquire just.graph.text (Byte 2=n+2) GEM 2.0!
;7. Escapes
vq_chcells              EQU $05000100 ;Inquire addressable alpha character cells
v_exit_cur              EQU $05000200 ;Exit alpha mode
v_enter_cur             EQU $05000300 ;Enter alpha mode
v_curup                 EQU $05000400 ;Alpha cursor up
v_curdown               EQU $05000500 ;Alpha cursor down
v_curright              EQU $05000600 ;Alpha cursor right
c_curleft               EQU $05000700 ;Alpha cursor left
v_curhome               EQU $05000800 ;Home alpha cursor
v_eeos                  EQU $05000900 ;Erase to end of alpha screen
v_eeol                  EQU $05000A00 ;Erase to end of alpha text line
v_curaddress            EQU $05020B00 ;Direct alpha cursor address
v_curtext               EQU $05000C00 ;Output cursor addressable alpha text (Byte 2=n)
v_rvon                  EQU $05000D00 ;Reverse video on
v_rvoff                 EQU $05000E00 ;Reverse video off
vq_curaddress           EQU $05000F00 ;Inquire current alpha cursor address
vq_tabstatus            EQU $05001000 ;Inquire tablet status
v_hardcopy              EQU $05001100 ;Hardcopy
v_dspcur                EQU $05001201 ;Place graphic cursor at location
v_rmcur                 EQU $05001300 ;Remove last graphic cursor
v_form_adv              EQU $05001400 ;Form advance
v_output_window         EQU $05001500 ;Output window
v_clear_disp_list       EQU $05001600 ;Clear display list
v_bit_image             EQU $05051702 ;Output bit image file (Byte 2=n+5)
vq_scan                 EQU $05001800 ;Inquire printer scan
v_alpha_text            EQU $05001900 ;Output alpha text (Byte 2=n)
vs_palette              EQU $05013C00 ;Select palette
v_sound                 EQU $05023D00 ;Generate specified tone
vs_mute                 EQU $05013E00 ;Set/clear tone muting flag
vt_resolution           EQU $05025100 ;Set tablet axis resolution in lines/inch
vt_axis                 EQU $05025200 ;Set table axis resolution in lines
vt_origin               EQU $05025300 ;Set tablet x and y origin
vq_tdimensions          EQU $05005400 ;Return tablet x and y dimensions
vt_alignment            EQU $05025500 ;Set tablet alignment
vsp_film                EQU $05025B00 ;Set camera file type and exposure time
vqp_filename            EQU $05015C00 ;Inquire camera file name
vsc_expose              EQU $05015D00 ;Disable or enable file exposure for frame preview
v_meta_extents          EQU $05006202 ;Update metafile extents
v_write_meta            EQU $05006300 ;Write metafile item (Byte 0=num_ptsin, Byte 2=num_intin)
vm_pagesize             EQU $05036300 ;Physical page size
wm_coords               EQU $05056300 ;Coordinate window
vm_filename             EQU $05006400 ;Change gem vdi filename (Byte 2=n)
v_offset                EQU $05016500 ;Set line offset
v_fontinit              EQU $05026600 ;Init system font
;v_escape2000(times) -> (klappt mit dem Konzept leider nicht...)
                        ENDPART


neo:                    DC.B 'NEO',0
neochrome:              DC.B 'NEOchrome '
neo_version:            DC.B 'v'
                        DC.B release_1+'0','.',release_2+'0',release_3+'0',0
by_chaos:               DC.B 'by CHAOS,INC',0
undo:                   DC.B 'UNDO',$00
L038C:                  DC.B '000'
L038D:                  DC.B 0

;holt komplettbild auf scr2 zurÅck, je nach grab_y und Board
get_komplett:   movem.l D0-D1/A4-A5,-(SP)
                movea.l scr2,A4
                movea.l komplettbild,A5
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L038F
                move.w  grab_y,D1
                mulu    #160,D1
                adda.l  D1,A5
                move.w  #999,D0
L038F:          move.l  (A5)+,(A4)+
                move.l  (A5)+,(A4)+
                move.l  (A5)+,(A4)+
                move.l  (A5)+,(A4)+
                dbra    D0,L038F
                movem.l (SP)+,D0-D1/A4-A5
                rts

;Zeichnet einen Brush/Nozzle oder Eraser in den Screen
draw_brush:     movem.l D0-D7/A2-A5,-(SP)
                movea.l scr1,A3
                movea.l A3,A4
                movea.l A3,A2
                movea.l akt_shape,A5
                move.w  D3,D2
                move.w  D4,D3
                exg     D2,D0
                exg     D3,D1
                move.w  (A5)+,D5
                lsr.w   #1,D5
                sub.w   D5,D0
                sub.w   D5,D2
                move.w  (A5),D5
                lsr.w   #1,D5
                sub.w   D5,D1
                sub.w   D5,D3
                move.w  D1,D4
                muls    #$00A0,D4
                move.w  D0,D5
                bpl.s   L0391
                addi.w  #$0010,D5
                subq.w  #8,D4
L0391:          lsr.w   #1,D5
                andi.w  #-8,D5
                add.w   D5,D4
                adda.w  D4,A4
                move.w  board_y,D4
                mulu    #$00A0,D4
                adda.w  D4,A2
                moveq   #0,D4
                moveq   #0,D5
                move.l  #-$7FFF0001,D6
                move.w  D2,D4
                sub.w   D0,D4
                bpl.s   L0392
                eor.l   D6,D4
                addq.w  #1,D4
L0392:          move.w  D1,D5
                sub.w   D3,D5
                bpl.s   L0393
                eor.l   D6,D5
                addq.w  #1,D5
L0393:          move.w  D0,D1
                andi.w  #$000F,D1
                cmp.w   D5,D4
                bcc.s   L039B
                move.w  D4,D6
                add.w   D6,D6
                sub.w   D5,D6
                move.w  D4,D7
                sub.w   D5,D7
                add.w   D7,D7
                move.w  #-$00A0,D3
                tst.l   D5
                bpl.s   L0394
                move.w  #$00A0,D3
L0394:          moveq   #-1,D2
                add.l   D4,D4
                bcs.s   L0395
                moveq   #1,D2
L0395:          bsr     L03A3
                bra.s   L039A
L0396:          adda.w  D3,A4
                bsr     L03A3
                tst.w   D6
                bmi.s   L0399
                add.w   D7,D6
                add.w   D2,D0
                add.w   D2,D1
                bmi.s   L0397
                beq.s   L0398
                andi.w  #$000F,D1
                bne.s   L0398
                addq.l  #8,A4
                bra.s   L0398
L0397:          andi.w  #$000F,D1
                subq.l  #8,A4
L0398:          bsr.s   L03A3
                bra.s   L039A
L0399:          add.w   D4,D6
L039A:          dbra    D5,L0396
                movem.l (SP)+,D0-D7/A2-A5
                rts
L039B:          move.w  D5,D6
                add.w   D6,D6
                sub.w   D4,D6
                move.w  D5,D7
                sub.w   D4,D7
                add.w   D7,D7
                moveq   #1,D2
                tst.l   D4
                bpl.s   L039C
                moveq   #-1,D2
L039C:          move.w  #$00A0,D3
                add.l   D5,D5
                bcs.s   L039D
                move.w  #-$00A0,D3
L039D:          bsr.s   L03A3
                bra.s   L03A2
L039E:          add.w   D2,D0
                add.w   D2,D1
                bmi.s   L039F
                beq.s   L03A0
                andi.w  #$000F,D1
                bne.s   L03A0
                addq.l  #8,A4
                bra.s   L03A0
L039F:          andi.w  #$000F,D1
                subq.l  #8,A4
L03A0:          bsr.s   L03A3
                tst.w   D6
                bmi.s   L03A1
                add.w   D7,D6
                adda.w  D3,A4
                bsr.s   L03A3
                bra.s   L03A2
L03A1:          add.w   D5,D6
L03A2:          dbra    D4,L039E
                movem.l (SP)+,D0-D7/A2-A5
                rts
L03A3:          movem.l D0-D6/A2-A5,-(SP)
                cmpi.w  #-$0010,D0
                ble     L03B1
                cmpi.w  #$0140,D0
                bge     L03B1
                tst.w   D0
                bpl.s   L03A4
                subq.l  #8,A2
                subq.l  #8,A3
L03A4:          move.w  zeichenfarbe,D4
                bset    #4,D4
                move.w  (A5)+,D2
                bra.s   L03B0
L03A5:          moveq   #0,D3
                move.w  (A5)+,D3
                swap    D3
                cmpa.l  A2,A4
                bcc.s   L03B1
                cmpa.l  A3,A4
                bcs.s   L03AF
                lsr.l   D1,D3
                move.l  D3,D5
                not.l   D5
                move.w  D4,D6
                move.l  A4,-(SP)
                tst.w   D0
                bmi.s   L03A8
                cmpi.w  #$0130,D0
                bge.s   L03AB
L03A6:          lsr.w   #1,D6
                beq.s   L03AE
                bcc.s   L03A7
                or.w    D3,8(A4)
                swap    D3
                or.w    D3,(A4)+
                swap    D3
                bra.s   L03A6
L03A7:          and.w   D5,8(A4)
                swap    D5
                and.w   D5,(A4)+
                swap    D5
                bra.s   L03A6
L03A8:          addq.l  #8,A4
L03A9:          lsr.w   #1,D6
                beq.s   L03AE
                bcc.s   L03AA
                or.w    D3,(A4)+
                bra.s   L03A9
L03AA:          and.w   D5,(A4)+
                bra.s   L03A9
L03AB:          swap    D3
                swap    D5
L03AC:          lsr.w   #1,D6
                beq.s   L03AE
                bcc.s   L03AD
                or.w    D3,(A4)+
                bra.s   L03AC
L03AD:          and.w   D5,(A4)+
                bra.s   L03AC
L03AE:          movea.l (SP)+,A4
L03AF:          lea     $00A0(A4),A4
L03B0:          dbra    D2,L03A5
L03B1:          movem.l (SP)+,D0-D6/A2-A5
                rts

;Zeichnet die Linie der Line-Funktion
;-> D0.W: x1
;   D1.W: y1
;   D2.W: x2
;   D3.W: y2
do_draw_line:   movem.l D0-D7/A1-A5,-(SP)
                move.w  right_line_color,D7
                move.w  left_line_color,D5
                sub.w   D5,D7
                addq.w  #1,D7
                movea.w D5,A1
                movea.l scr2,A3
                movea.l A3,A4
                movea.l A3,A2
                movea.l akt_shape,A5
                move.w  (A5)+,D5        ;Breite in Pixel des Brushes
                lsr.w   #1,D5
                sub.w   D5,D0           ;=Startposition links
                sub.w   D5,D2
                move.w  (A5),D5         ;Hîhe des Burshes in Pixel
                lsr.w   #1,D5
                sub.w   D5,D1           ;=Startposition oben
                sub.w   D5,D3
                move.w  D1,D4
                muls    #160,D4         ;Adresse der Scanline
                move.w  D0,D5
                bpl.s   L03B3
                addi.w  #$0010,D5
                subq.w  #8,D4
L03B3:          lsr.w   #1,D5
                andi.w  #-8,D5
                add.w   D5,D4
                adda.w  D4,A4
                move.w  board_y,D4
                mulu    #$00A0,D4
                adda.w  D4,A2
                moveq   #0,D4
                moveq   #0,D5
                move.l  #-$7FFF0001,D6
                move.w  D2,D4
                sub.w   D0,D4
                bpl.s   L03B4
                eor.l   D6,D4
                addq.w  #1,D4
L03B4:          move.w  D1,D5
                sub.w   D3,D5
                bpl.s   L03B5
                eor.l   D6,D5
                addq.w  #1,D5
L03B5:          move.w  D0,D1
                andi.w  #$000F,D1
                cmp.w   D5,D4
                bcc.s   L03BD
                move.w  D5,D6
                addq.w  #1,D6
                ext.l   D6
                divu    D7,D6
                move.w  D6,L0810
                move.w  D6,L0811
                swap    D6
                subq.w  #1,D6
                move.w  D6,L080F
                bmi.s   L03B6
                addq.w  #1,L0811
L03B6:          move.w  D4,D6
                add.w   D6,D6
                sub.w   D5,D6
                move.w  D4,D7
                sub.w   D5,D7
                add.w   D7,D7
                move.w  #-$00A0,D3
                tst.l   D5
                bpl.s   L03B7
                move.w  #$00A0,D3
L03B7:          moveq   #-1,D2
                add.l   D4,D4
                bcs.s   L03B8
                moveq   #1,D2
L03B8:          bra.s   L03BC
L03B9:          adda.w  D3,A4
                tst.w   D6
                bmi.s   L03BB
                add.w   D7,D6
                add.w   D2,D0
                add.w   D2,D1
                bmi.s   L03BA
                beq.s   L03BC
                andi.w  #$000F,D1
                bne.s   L03BC
                addq.l  #8,A4
                bra.s   L03BC
L03BA:          andi.w  #$000F,D1
                subq.l  #8,A4
                bra.s   L03BC
L03BB:          add.w   D4,D6
L03BC:          bsr     draw_user_line
                dbra    D5,L03B9
                movem.l (SP)+,D0-D7/A1-A5
                rts

L03BD:          move.w  D4,D6
                addq.w  #1,D6
                ext.l   D6
                divu    D7,D6
                move.w  D6,L0810
                move.w  D6,L0811
                swap    D6
                subq.w  #1,D6
                move.w  D6,L080F
                bmi.s   L03BE
                addq.w  #1,L0811
L03BE:          move.w  D5,D6
                add.w   D6,D6
                sub.w   D4,D6
                move.w  D5,D7
                sub.w   D4,D7
                add.w   D7,D7
                moveq   #1,D2
                tst.l   D4
                bpl.s   L03BF
                moveq   #-1,D2
L03BF:          move.w  #$00A0,D3
                add.l   D5,D5
                bcs.s   L03C0
                move.w  #-$00A0,D3
L03C0:          bra.s   L03C5
L03C1:          add.w   D2,D0
                add.w   D2,D1
                bmi.s   L03C2
                beq.s   L03C3
                andi.w  #$000F,D1
                bne.s   L03C3
                addq.l  #8,A4
                bra.s   L03C3
L03C2:          andi.w  #$000F,D1
                subq.l  #8,A4
L03C3:          tst.w   D6
                bmi.s   L03C4
                add.w   D7,D6
                adda.w  D3,A4
                bra.s   L03C5
L03C4:          add.w   D5,D6
L03C5:          bsr.s   draw_user_line
                dbra    D4,L03C1
                movem.l (SP)+,D0-D7/A1-A5
                rts

                        IF 1=2

;Alte Routine:
L03C6:          movem.l D0-D6/A2-A5,-(SP)
                cmpi.w  #-$0010,D0
                ble     L03D6
                cmpi.w  #$0140,D0
                bge     L03D6
                tst.w   D0
                bpl.s   L03C7
                subq.l  #8,A2
                subq.l  #8,A3
L03C7:          subq.w  #1,L0811
                bpl.s   L03C9
                move.w  L0810,L0811
                subq.w  #1,L080F
                bpl.s   L03C8
                subq.w  #1,L0811
L03C8:          addq.l  #1,A1
L03C9:          move.w  A1,D4
                bset    #4,D4
                move.w  (A5)+,D2
                bra.s   L03D5
L03CA:          moveq   #0,D3
                move.w  (A5)+,D3
                swap    D3
                cmpa.l  A2,A4
                bcc.s   L03D6
                cmpa.l  A3,A4
                bcs.s   L03D4
                lsr.l   D1,D3
                move.l  D3,D5
                not.l   D5
                move.w  D4,D6
                move.l  A4,-(SP)
                tst.w   D0
                bmi.s   L03CD
                cmpi.w  #$0130,D0
                bge.s   L03D0
L03CB:          lsr.w   #1,D6
                beq.s   L03D3
                bcc.s   L03CC
                or.w    D3,8(A4)
                swap    D3
                or.w    D3,(A4)+
                swap    D3
                bra.s   L03CB
L03CC:          and.w   D5,8(A4)
                swap    D5
                and.w   D5,(A4)+
                swap    D5
                bra.s   L03CB
L03CD:          addq.l  #8,A4
L03CE:          lsr.w   #1,D6
                beq.s   L03D3
                bcc.s   L03CF
                or.w    D3,(A4)+
                bra.s   L03CE
L03CF:          and.w   D5,(A4)+
                bra.s   L03CE
L03D0:          swap    D3
                swap    D5
L03D1:          lsr.w   #1,D6
                beq.s   L03D3
                bcc.s   L03D2
                or.w    D3,(A4)+
                bra.s   L03D1
L03D2:          and.w   D5,(A4)+
                bra.s   L03D1
L03D3:          movea.l (SP)+,A4
L03D4:          lea     $00A0(A4),A4
L03D5:          dbra    D2,L03CA
L03D6:          movem.l (SP)+,D0-D6/A2-A5
                rts

                        ENDC


;->D0.W: x1
draw_user_line: movem.l D0-D7/A2-A5,-(SP)
                cmpi.w  #-16,D0
                ble     L03D6           ;->RTS
                cmpi.w  #320,D0
                bge     L03D6           ;->RTS
                tst.w   D0
                bpl.s   L03C7
                subq.l  #8,A2           ;Auûerhalb des Screens
                subq.l  #8,A3
L03C7:          subq.w  #1,L0811
                bpl.s   L03C9
                move.w  L0810,L0811
                subq.w  #1,L080F
                bpl.s   L03C8
                subq.w  #1,L0811
L03C8:          addq.l  #1,A1
L03C9:          move.w  A1,D4
                bset    #4,D4
                move.w  (A5)+,D2
                bra     L03D5
L03CA:          moveq   #0,D3
                move.w  (A5)+,D3
                swap    D3
                cmpa.l  A2,A4
                bcc     L03D6           ;->RTS
                cmpa.l  A3,A4
                bcs     L03D4           ;nÑchste Scanline
                lsr.l   D1,D3
                move.l  D3,D5
                not.l   D5
                move.w  D4,D6
                move.l  A4,-(SP)
                tst.w   D0
                bmi.s   L03CD
                cmpi.w  #304,D0
                bge.s   L03D0
L03CB:          lsr.w   #1,D6
                beq     L03D3
                bcc.s   L03CC
                move.w  line_pattern,D7
                and.w   D3,D7
                or.w    D3,8(A4)        ;setzen
                swap    D3
                move.w  line_pattern,D7
                and.w   D3,D7
                or.w    D3,(A4)+        ;setzen
                swap    D3
                bra.s   L03CB
L03CC:          move.w  line_pattern,D7
                not.w   D7
                and.w   D5,D7
                and.w   D5,8(A4)        ;lîschen
                swap    D5
                move.w  line_pattern,D7
                not.w   D7
                and.w   D5,D7
                and.w   D5,(A4)+        ;lîschen
                swap    D5
                bra.s   L03CB
L03CD:          addq.l  #8,A4
L03CE:          lsr.w   #1,D6
                beq.s   L03D3
                bcc.s   L03CF
                move.w  line_pattern,D7
                and.w   D3,D7
                or.w    D3,(A4)+        ;setzen
                bra.s   L03CE
L03CF:          move.w  line_pattern,D7
                not.w   D7
                and.w   D5,D7
                and.w   D5,(A4)+        ;lîschen
                bra.s   L03CE
L03D0:          swap    D3
                swap    D5
L03D1:          lsr.w   #1,D6
                beq.s   L03D3
                bcc.s   L03D2
                move.w  line_pattern,D7
                and.w   D3,D7
                or.w    D3,(A4)+        ;setzen
                bra.s   L03D1
L03D2:          move.w  line_pattern,D7
                not.w   D7
                and.w   D5,D7
                and.w   D5,(A4)+        ;lîschen
                bra.s   L03D1
L03D3:          movea.l (SP)+,A4
L03D4:          lea     160(A4),A4      ;NÑchste Scanline
L03D5:          dbra    D2,L03CA
L03D6:          movem.l (SP)+,D0-D7/A2-A5
                rts

;Da ein Branch auf Save_error teilweise zu groû ist, ist ein StÅtzpunkt
;zum anspringen
save_error_far: jmp     save_error

init_text:      linea   #0 [ Init ]
                clr.w   L0815
                move.w  text_height,D0
                movea.l A1,A4           ;Adresse der Fonts
                movea.l (A4)+,A2        ;6x6 Font(?)
                moveq   #-1,D2
L03D8:          move.w  $0028(A2),D3    ;Abstand Topline<->Baseline (?)
                sub.w   D0,D3
                beq.s   L03DE
                bcc.s   L03D9
                neg.w   D3
L03D9:          cmp.w   D2,D3
                bcc.s   L03DA
                move.w  D3,D2
                movea.l A2,A3
L03DA:          movea.l (A4)+,A2        ;NÑchster Font
                cmpa.w  #0,A2           ;gibt's denn Åberhaupt noch?
                bne.s   L03D8           ;ja
                movea.l A1,A4
                movea.l (A4)+,A2
L03DB:          move.w  40(A2),D1
                add.w   D1,D1
                sub.w   D0,D1
                beq.s   L03DE
                bcc.s   L03DC
                neg.w   D1
L03DC:          cmp.w   D2,D1
                bcc.s   L03DD
                move.w  D1,D2
                movea.l A2,A3
L03DD:          movea.l (A4)+,A2
                cmpa.w  #0,A2
                bne.s   L03DB
                bra.s   L03DF
L03DE:          movea.l A2,A3
L03DF:          move.l  A3,L0814
                move.w  40(A3),D1
                cmp.w   D1,D0
                beq.s   L03E0
                bsr     L03EE
                move.w  D0,L0816
                not.w   L0815
L03E0:          movea.l L0814,A2
                move.w  40(A2),D0
                bsr.s   L03E4
                move.w  D0,L081C
                move.w  60(A2),D0
                bsr.s   L03E4
                move.w  D0,L0819
                move.w  54(A2),D0
                move.w  56(A2),D1
                move.w  82(A2),D5
                move.w  D1,D3
                add.w   D0,D3
                move.w  D5,D2
                lsr.w   #1,D2
                sub.w   D3,D2
                add.w   D2,D1
                bpl.s   L03E1
                move.w  #0,D1
L03E1:          bsr.s   L03E4
                move.w  D0,L081A
                move.w  D1,D0
                bsr.s   L03E4
                move.w  D0,L081B
                move.w  D5,D0
                bsr.s   L03E4
                move.w  D0,D4
                move.w  text_style,D0
                btst    #4,D0
                beq.s   L03E2
                addq.w  #2,D4
L03E2:          btst    #3,D0
                beq.s   L03E3
                move.w  D4,L0818
                add.w   L0819,D4
L03E3:          move.w  D4,L0796
                rts

L03E4:          move.w  #$7FFF,D3
L03E5:          tst.w   L0815
                beq.s   L03ED
                move.w  L0816,D2
                cmp.w   #-1,D2
                beq.s   L03E9
                moveq   #0,D4
                subq.w  #1,D0
                bmi.s   L03E8
                tst.w   L0817
                beq.s   L03EA
L03E6:          add.w   D2,D3
                bcc.s   L03E7
                addq.w  #1,D4
L03E7:          addq.w  #1,D4
                dbra    D0,L03E6
L03E8:          bra.s   L03EC
L03E9:          move.w  D0,D4
                add.w   D4,D4
                bra.s   L03EC
L03EA:          add.w   D2,D3
                bcc.s   L03EB
                addq.w  #1,D4
L03EB:          dbra    D0,L03EA
                tst.w   D4
                bne.s   L03EC
                addq.w  #1,D4
L03EC:          move.w  D4,D0
L03ED:          rts

L03EE:          cmp.w   D1,D0
                ble.s   L03EF
                move.w  #1,L0817
                sub.w   D1,D0
                cmp.w   D1,D0
                blt.s   L03F0
                moveq   #-1,D0
                rts
L03EF:          clr.w   L0817
                tst.w   D0
                bne.s   L03F0
                moveq   #1,D0
L03F0:          swap    D0
                clr.w   D0
                divu    D1,D0
                rts

;Printet einen String zentriert, je nach Auflîsung (CHS):
;-> D0: Y-Zeile
;   A0: Stringadr
center_print:   movem.l D0-A6,-(SP)

                movea.l A0,A6
                move.w  D0,D5           ;Y-Wert

                moveq   #-1,D7
strlen:         tst.b   (A0)+
                dbeq    D7,strlen
                neg.w   D7
                lsl.w   #3,D7           ;mal 8

                move.w  #4,-(SP)        ;GetRez
                trap    #14
                addq.l  #2,SP
                move.w  #639,D6
                tst.w   D0              ;Low-Rez
                bne.s   ok21
                move.w  #319,D6
ok21:           sub.w   D7,D6
                lsr.w   #1,D6
                move.w  D6,D0           ;X-Wert
                move.w  D5,D1
                movea.l A6,A0
                bsr.s   print8x8

                movem.l (SP)+,D0-A6
                rts

print8x8:       moveq   #0,D2           ;Farbe
                moveq   #0,D3           ;Transparent
                movem.l D0-D3/A0,-(SP)
                linea   #0 [ Init ]
                movea.l 4(A1),A1        ;8x8 Font
                bra.s   L03F5

;Schreibt Invers
;-> D0.W: X
;   D1.W: Y
;   D2.W: Textstyle
;   A0.L: String (wird erhîht)
print6x6_inv:   moveq   #2,D3           ;Invert
                bra.s   L03F4

                        DC.B $76,$01,96,$02

;Printet im 6x6 Font, dabei kînnen aber sÑmtliche Einstellungen gemacht werden
; D0.w: x
;  D1.w: y
;  D2.w: Farbe
;  D3.w: Schreibmodus
;  D4.w: Schreibstil
;  A0.L: Stringadresse
;Es werden keine Register verÑndert!
print6x6_col:   movem.l D0-A6,-(SP)

                movem.l D0-D6/A0,-(SP)

                linea   #0 [ Init ]
                movea.l (A1),A1         ;6x6 Font
                clr.w   $0036(A0)       ;Clipping ausschalten
                clr.w   $0066(A0)       ;kein Scale
                movem.l (SP)+,D0-D6/A0

                bsr     L03FD           ;und ausgeben

                movem.l (SP)+,D0-A6
                rts

;Parameter:
;D0: x
;D1: y
;D2: Schreibstil
;A0: Stringsadresse (wird erhîht, sodaû A0 hinter Null zeigt)
print6x6:       moveq   #0,D3           ;Normal
L03F4:          movem.l D0-D3/A0,-(SP)
                linea   #0 [ Init ]
                movea.l (A1),A1         ;6x6 Font
L03F5:          clr.w   $0036(A0)       ;Clipping ausschalten
                clr.w   $0066(A0)       ;kein Scale
                movem.l (SP)+,D0-D3/A0
                move.w  D2,D4
                moveq   #$0F,D2         ;Farbe 15
                bra     L03FD

L03F6:          movem.l D0-D1/A0,-(SP)
                linea   #0 [ Init ]
                move.w  #-1,$0036(A0)   ;Clipping einschalten
                clr.w   $0038(A0)       ;Clip_x1
                clr.w   $003A(A0)       ;Clip_y1
                move.w  #319,$003C(A0)  ;Clip_x2
                move.w  board_y,D0
                subq.w  #1,D0
                move.w  D0,$003E(A0)    ;Clip_y2
                move.w  L0815,$0066(A0) ;Scale
                move.w  L0816,$0042(A0) ;Vergrîûerungsfaktor
                move.w  L0817,$0044(A0) ;Vergrîûerungsrichtung
                move.w  $0040(A0),D3
                movem.l (SP)+,D0-D1/A0
                movea.l L0814,A1
                move.w  text_align,D2
                beq.s   L03FC
                movem.l D0-D1/A0,-(SP)
                move.w  D2,D1
                moveq   #0,D5
                move.w  $0024(A1),D6    ;Schreibmodus
                move.w  text_style,D2
                moveq   #0,D7
                btst    #4,D2
                beq.s   L03F7
                addq.w  #2,D7
L03F7:          btst    #0,D2
                beq.s   L03F8
                add.w   58(A1),D7
L03F8:          swap    D7
                move.w  38(A1),D7
                movea.l 72(A1),A3
L03F9:          move.b  (A0)+,D2
                beq.s   L03FA
                andi.w  #$00FF,D2
                sub.w   D6,D2
                cmp.w   D7,D2
                bhi.s   L03F9
                add.w   D2,D2
                move.w  2(A3,D2.w),D0
                sub.w   0(A3,D2.w),D0
                add.w   D0,D5
                swap    D5
                swap    D7
                add.w   D7,D5
                swap    D7
                swap    D5
                bra.s   L03F9
L03FA:          move.w  D5,D0
                bsr     L03E5
                swap    D5
                add.w   D0,D5
                cmpi.w  #1,D1
                bne.s   L03FB
                lsr.w   #1,D5
L03FB:          movem.l (SP)+,D0-D1/A0
                sub.w   D5,D0
L03FC:          move.w  zeichenfarbe,D2
                moveq   #1,D3
                move.w  text_style,D4
L03FD:          movem.l D1-D7/A1-A6,-(SP)
                movem.l D0-D4/A0-A1,-(SP)
                linea   #0 [ Init ]
                movea.l A0,A2
                movem.l (SP)+,D0-D4/A0-A1
                clr.w   70(A2)          ;Breite der Zeichen Ñndert sich bei FETT
                move.w  D0,$004C(A2)    ;Zeichen_x
                move.w  D1,$004E(A2)    ;Zeichen_y
                move.w  D2,$006A(A2)    ;Farbe
                move.w  D3,$0024(A2)    ;Schreibmodus
                move.w  D4,$005A(A2)    ;Schreibstil
                move.l  76(A1),$0054(A2) ;Pointer auf die Fontdaten
                move.w  80(A1),$0058(A2) ;Breite des Fonts in Bytes
                move.w  82(A1),$0052(A2) ;Hîhe des Fonts in Pixeln
                move.w  64(A1),$005E(A2) ;Skewing Mask
                move.w  #%1010101010101010,$005C(A2) ;Maske fÅr Light
                move.w  58(A1),$0060(A2)
                btst    #2,D4
                beq.s   L03FE
                move.w  L081A,100(A2)
                move.w  L081B,98(A2)
                bra.s   L03FF
L03FE:          clr.l   98(A2)
L03FF:          movea.l 72(A1),A3
                move.b  (A0)+,D3
                beq.s   L0403
                bra.s   L0401
L0400:          move.b  (A0)+,D3
                beq.s   L0402
L0401:          andi.w  #$00FF,D3
                sub.w   36(A1),D3
                cmp.w   38(A1),D3
                bhi.s   L0400
                add.w   D3,D3
                move.w  0(A3,D3.w),D5
                move.w  D5,72(A2)
                move.w  2(A3,D3.w),D6
                sub.w   D5,D6
                move.w  D6,80(A2)
                movem.l D0-D4/A0-A3,-(SP)
                linea   #8 [ Textblk ]
                movem.l (SP)+,D0-D4/A0-A3
                bra.s   L0400
L0402:          btst    #3,D4
                beq.s   L0403
                move.w  D2,D4
                move.w  76(A2),D2
                subq.w  #1,D2
                add.w   L0818,D1
                move.w  D1,D3
                add.w   L0819,D3
                subq.w  #1,D3
                moveq   #1,D5
                bsr     fill_box
L0403:          move.w  76(A2),D0
                movem.l (SP)+,D1-D7/A1-A6
                rts

jack_opt:       cmpi.w  #274,D0         ;Funktionstasten?
                bcs     L040C           ;ja->Weiter
                cmp.w   #191,D1         ;Print?
                bge     jack_print
                move.w  D1,D3
                subi.w  #140,D3
                bcs     L040C
                cmpi.w  #20,D3
                bcs.s   L0405
                cmpi.w  #1,jack_mode
                beq     L040C
                moveq   #1,D3
                bra.s   L0406
L0405:          move.w  D0,D3
                subi.w  #278,D3
                bcs     L040C
                lsr.w   #4,D3
                cmpi.w  #2,D3
                bcc     L042E
                neg.w   D3
                cmp.w   jack_mode,D3
                beq     L040B
L0406:          move.w  D3,jack_mode
                bsr     change_jack_mode
                btst    #0,jack_status
                beq     L040B
calc_jack_ani:  bsr     copy_board
                bsr     scr12scr2
L0408:          bsr     L0487
                movea.l objekt_pointer,A0
                movea.l scr2,A1
                lea     mask_buff,A2
                move.w  objekt_x2,D4
                move.w  objekt_y2,D5
                move.w  D4,D6
                move.w  D5,D7
                add.w   breite,D6
                subq.w  #1,D6
                add.w   hîhe,D7
                subq.w  #1,D7
                movem.w D4-D7,-(SP)
                jsr     L0726
                movem.w (SP)+,D4-D7
                bsr     L0102
                beq     L040B
                move.w  D4,objekt_x2
                move.w  D5,objekt_y2
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,breite
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,hîhe
                add.w   ani_x1,D6
                subq.w  #1,D6
                move.w  D6,ani_x4
                add.w   ani_y1,D7
                subq.w  #1,D7
                move.w  D7,ani_y4
                movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #$07CF,D0
                tst.w   board_da
                bne.s   L0409
                move.w  #$03E7,D0
L0409:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0409
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                bsr     draw_box
                move.w  old_vblcount,D7
L040A:          cmp.w   vblcounter,D7
                beq.s   L040A
                jsr     L00FC
L040B:          rts

;Funktionstastenauswertung fÅr Jack knife-Options
L040C:          cmp.w   #272,D0         ;Im Bereich der F-Tasten?
                bcc.s   L040B           ;Nein->RTS
                move.w  D2,D5
                and.w   #%0000000000001100,D5 ;Rechts/Links neu gedrÅckt?
                beq.s   L040B           ;Nein->RTS
                move.w  D1,D5
                subi.w  #141,D5
                bcs.s   L040B
                ext.l   D5
                divu    #6,D5
                cmpi.w  #6,D5           ;6 Tasten gibts
                bcc.s   L040B
                move.w  D5,D4
                mulu    #6,D4
                lea     L0572,A3
                tst.w   0(A3,D4.w)      ;Taste eingeschaltet?
                bne.s   L040B
                bsr     inv_copy_btn
L040D:          move.w  D5,-(SP)
                bsr     animier_objekte
                bsr     Sm
                bsr     get_maus
                move.w  (SP)+,D5
                move.w  D2,D4
                and.w   #%0000000000110000,D4 ;Links/Rechts neu losgelassen?
                bne.s   L0410
                cmpi.w  #272,D0
                bcc.s   L040F
                move.w  D1,D4
                subi.w  #141,D4
                bcs.s   L040F
                ext.l   D4
                divu    #6,D4
                cmpi.w  #6,D4           ;6 Buttons gibts
                bcc.s   L040F
                move.w  D4,D6
                mulu    #6,D6
                lea     L0572,A3
                tst.w   0(A3,D6.w)
                bne.s   L040F
                cmp.w   D4,D5
                beq.s   L040D
                bsr     Hm
                tst.w   D5
                bmi.s   L040E
                bsr     inv_copy_btn
L040E:          move.w  D4,D5
                bsr     inv_copy_btn
                bsr     Sm
                bra.s   L040D
L040F:          tst.w   D5
                bmi.s   L040D
                bsr     Hm
                bsr     inv_copy_btn
                move.w  #-1,D5
                bsr     Sm
                bra.s   L040D
L0410:          st      ohne_raster     ;Nur ausgewÑhlte Farben benutzen
                btst    #4,D4           ;Links losgelassen?
                bne.s   okokok
                sf      ohne_raster     ;Alle Farben benutzen
okokok:         tst.w   D5
                bmi     Hm
                bsr     Hm
                move.w  #7,D6
L0411:          bsr     inv_copy_btn
                move.w  vblcounter,button_klicked
L0412:          move.w  vblcounter,D7
                sub.w   button_klicked,D7
                cmpi.w  #2,D7
                bcs.s   L0412
                dbra    D6,L0411
                move.w  D5,-(SP)
                add.w   D5,D5
                add.w   D5,D5
                pea     L0413(PC)
                lea     L0418(PC),A0
                move.l  0(A0,D5.w),-(SP)
                rts

L0413:          move.w  (SP)+,D5
                cmpi.w  #1,D5
                bne     L0443
                clr.b   changed
                bra     L0443
jack_cut:       bclr    #4,jack_status
                beq.s   L0415
                bsr     L041B
L0415:          bsr     copy_copy
jack_clear:     bclr    #4,jack_status
                beq.s   L0417
                bsr     L041B
L0417:          clr.b   jack_status
                bra     phys_2_scr1

jack_print:     tst.w   L0572+54        ;Jack Print enabled?
                bne     nichts_da2      ;Nein->RTS

                tst.w   pixel_per_scan
                beq     nichts_da2

                movem.l D0-A6,-(SP)
                move.w  #273,D3
                move.w  #191,D4
                move.w  #313,D5
                move.w  #199,D6
                bsr     inv_button

test_printer:   move.w  #$0011,-(SP)
                trap    #1              ;Prtout Stat
                addq.l  #2,SP
                tst.w   D0
                bne.s   printer_ready

                move.l  #wake_up,D0
                bsr     switch_alert
                cmpi.w  #1,int_out
                beq.s   test_printer
                bra     nichts_da3      ;Abbruch

printer_ready:  movea.l scr2,A0
                bsr     clear_neo

                lea     bitblit,A6      ;hier Parameter aufbauen
                move.w  pixel_per_scan(PC),D0 ;Breite des Blocks in Pixeln
                cmp.w   #320,D0
                ble.s   ok346
                move.w  #320,D0         ;Clippen
ok346:          move.w  D0,(A6)
                move.w  anz_scanlines(PC),D0 ;Hîhe des Blocks in Pixeln
                cmp.w   #200,D0
                ble.s   ok345
                move.w  #200,D0
ok345:          move.w  D0,2(A6)
                move.w  #4,4(A6)        ;Anzahl der Planes
                move.l  #$03030303,10(A6) ;3=COPY (fÅr Sprite)
                move.w  cutbuffer_x(PC),14(A6) ;X des Quellrasters
                move.w  cutbuffer_y(PC),16(A6) ;Y des Quellrasters
                move.l  cut_buff,18(A6) ;Anfangsadresse des Quellrasters
                move.w  #8,22(A6)       ;Source-Offset zum nÑchsten Wort
                move.w  breite_bytes,24(A6) ;Breite des Quellrasters in Bytes
                move.w  #2,26(A6)       ;Source-Offset zur nÑchstes Plane
                move.w  #0,28(A6)       ;X des Zielrasters
                move.w  #0,30(A6)       ;Y des Zielrasters
                move.l  scr2,32(A6)     ;Anfangsadresse des Zielrasters
                move.w  #8,36(A6)       ;Dest-Offset zur gleichen Plane
                move.w  #160,38(A6)     ;Breite des Zielrasters in Bytes
                move.w  #2,40(A6)       ;Offset zur nÑchsten Plane
                clr.l   42(A6)          ;keine Masken
                linea   #7 [ Bitblk ]   ;kopieren

                pea     hbl_system+2
                move.w  #200,-(SP)
                move.w  #320,-(SP)
                move.l  scr2,-(SP)
                jsr     convert         ;in Monochrom-konvertieren
                lea     12(SP),SP

                move.w  #-1,-(SP)
                move.w  #33,-(SP)
                trap    #14             ;Druckertyp erfragen
                addq.l  #4,SP
                move.w  D0,D7           ;und merken

                lea     bitblit,A6      ;Hier Druckerparameter aufbauen
                move.l  scr2,(A6)+      ;Screenbasis
                clr.w   (A6)+           ;Offset
                move.w  pixel_per_scan(PC),D0 ;Breite
                add.w   D0,D0           ;verdoppeln
                cmp.w   #640,D0
                ble.s   ok347
                move.w  #640,D0
ok347:          move.w  D0,(A6)+
                move.w  anz_scanlines(PC),D0 ;Hîhe
                add.w   D0,D0           ;verdoppeln
                cmp.w   #400,D0
                ble.s   ok348
                move.w  #400,D0
ok348:          move.w  D0,(A6)+
                clr.w   (A6)+           ;Links
                move.w  #640,D0
                sub.w   -6(A6),D0       ;rechten Rand berechnen
                move.w  D0,(A6)+
                move.w  #2,(A6)+        ;High-Rez!
                move.w  #1,(A6)+        ;QualitÑtsdruck
                move.l  #druck_pal,(A6)+ ;Normale Monochrom-Palette nehmen

                move.w  D7,D0           ;Druckertyp
                and.w   #7,D0
                move.b  drucker_tab(PC,D0.w),D0
                move.w  D0,(A6)+

                move.w  D7,D0           ;Druckertyp
                lsr.w   #4,D0
                and.w   #1,D0           ;Parallel/Seriell
                move.w  D0,(A6)+
                clr.l   (A6)+           ;Standardmasken

                clr.l   -(SP)
                move.w  #$0020,-(SP)
                trap    #1
                addq.l  #6,SP
                move.l  D0,-(SP)

                bsr     raster_ggf_aus

                move.w  #1,$000004EE.w  ;Dumpflag auf eins

                pea     bitblit
                move.w  #36,-(SP)       ;Prtblk
                trap    #14
                addq.l  #6,SP

                move.w  #-1,$000004EE.w ;Dumpflag wieder aus

                bsr     raster_ggf_an

                move.w  #$0020,-(SP)
                trap    #1
                addq.l  #6,SP

nichts_da3:     move.w  #273,D3
                move.w  #191,D4
                move.w  #313,D5
                move.w  #199,D6
                bsr     inv_button

                movem.l (SP)+,D0-A6
nichts_da2:     rts

;Tabelle fÅr die verschiedenen Hardcopytreiber
drucker_tab:            DC.B 0,2,1,-1,3,-1,-1,-1

;Diese Routine lîscht einen 32000 Bytes groûen Speicherbereich
; A0.L: Speicher
clear_neo:      movem.l D0-A6,-(SP)

                move.w  #3999,D7
                moveq   #0,D0
clr_loop5:      move.l  D0,(A0)+
                move.l  D0,(A0)+
                dbra    D7,clr_loop5

                movem.l (SP)+,D0-A6
                rts

;Sprungroutinen fÅr die Funktionstasten der Jack Knife
L0418:                  DC.L jack_cut ;Jack Cut   (F1)
                        DC.L copy_copy ;Jack Copy  (F2)
                        DC.L jack_paste ;Jack Paste (F3)
                        DC.L jack_clear ;Jack Clear (F4)
                        DC.L jack_remap ;(F5)
                        DC.L jack_alias ;(F6)
                        DC.L pling ;(F7)
                        DC.L pling ;(F8)
                        DC.L pling ;(F9)
                        DC.L jack_print ;Hardcopy (F10)

L0419:          move.b  fun_key,D5
                clr.b   fun_key
                subq.b  #1,D5
                ext.w   D5
                cmpi.w  #1,D5
                beq.s   L041A
                clr.b   changed
L041A:          move.w  D5,D6
                cmpi.w  #9,D6           ;5 Tasten gibts
                bgt     pling
                mulu    #6,D6
                lea     L0572(PC),A0
                tst.w   0(A0,D6.w)      ;Funktion enabled?
                bne     pling
                move.w  D5,D6
                add.w   D6,D6
                add.w   D6,D6
                movem.l D0-A6,-(SP)
                bsr     get_shift
                st      ohne_raster     ;nur ausgewÑhlte betrachten
                moveq   #0,D0
                move.b  any_shift,D0
                or.b    right_shift,D0
                beq.s   keine_shift
                sf      ohne_raster
keine_shift:    movem.l (SP)+,D0-A6
                movem.w D1/D5,-(SP)
                pea     L041D(PC)
                lea     L0418(PC),A0
                move.l  0(A0,D6.w),-(SP)
                rts

L041B:          movea.l scr2,A0
                move.w  #$07CF,D7
                moveq   #0,D6
L041C:          move.l  D6,(A0)+
                move.l  D6,(A0)+
                move.l  D6,(A0)+
                move.l  D6,(A0)+
                dbra    D7,L041C
                bra     L0237
L041D:          movem.w (SP)+,D1/D5
                cmp.w   board_y,D1
                bhi     L0444
                tst.w   D5
                beq.s   L041E
                cmpi.w  #3,D5
                bne     L0444
L041E:          bsr     set_mouse
                bra     L0444

;Copybox - Funktionstastenauswertung
copybox_fkey:   move.b  fun_key,D5
                clr.b   fun_key         ;Jetzt keine Funktionstaste
                subq.b  #1,D5
                ext.w   D5
                cmpi.w  #1,D5           ;F2?
                beq.s   L0420           ;ja
                clr.b   changed         ;Paste->es wurde geÑndert
L0420:          move.w  D5,D6
                cmpi.w  #9,D6           ;F10?
                beq.s   L0421
                mulu    #6,D6
                lea     L0575(PC),A0    ;Ist Funktion disabled?
                tst.w   0(A0,D6.w)
                bne.s   pling           ;ja->Raus
                move.w  D5,D6
L0421:          add.w   D6,D6           ;mal 4
                add.w   D6,D6
                move.w  D5,-(SP)
                pea     L0422(PC)       ;RÅcksprungadresse
                move.l  L0425(PC,D6.w),-(SP)
                rts                     ;Routine starten

L0422:          move.w  (SP)+,D5
                cmpi.w  #4,D5           ;F5?
                bcc.s   L0423           ;>=->RTS
                bsr     on_off_buttons  ;Sonst Buttons neu malen
                bsr     redraw_copy_opt
L0423:          rts
                addq.l  #6,SP

pling:          movem.l D0-A6,-(SP)
                move.w  #7,-(SP)        ;Control+G (Bell)
                move.w  #2,-(SP)
                move.w  #3,-(SP)
                trap    #$0D
                addq.l  #6,SP
                movem.l (SP)+,D0-A6
                rts

;Sprungtabelle fÅr die einzelnen Routinen der Funktionstasten in Copybox:
L0425:                  DC.L copy_cut ;F1=Cut
                        DC.L copy_copy ;F2=Copy
                        DC.L copy_paste ;F3=Paste
                        DC.L copy_clear ;F4=Clear
                        DC.L copy_rotate ;F5=Rotate
                        DC.L copy_hflip ;F6=H-Flip
                        DC.L copy_vflip ;F7=V-Flip
                        DC.L copy_tedge ;F8=T-Edge
                        DC.L copy_resize ;F9=Resize
                        DC.L copy_swapcol ;F10=Swap Color

copy_clear:     btst    #3,copy_status
                beq.s   L0427
                bsr     set_mouse
L0427:          bra     phys_2_scr1

copy_cut:       bsr     copy_copy
                bra     phys_2_scr1

;Bedient das Optionsboard der Copybox
copybox_opt:    cmpi.w  #274,D0         ;Funktionstasten?
                bcs     L042E           ;ja
                move.w  D1,D3
                subi.w  #140,D3
                bcs     L042E
                cmpi.w  #20,D3
                bcs.s   L042C
                cmpi.w  #38,D3
                bcs.s   copy_resize
                cmpi.w  #40,D3
                bcs     L042D
                cmpi.w  #58,D3
                bcc     L042D
                btst    #2,D2           ;Links neu geklickt?
                beq     L042D
                lea     L057A(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #15,D3
                bsr     draw_func_inv
                bsr     copy_swapcol
                clr.b   changed
                lea     L057A(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #15,D3
                bsr     draw_func
                rts

copy_resize:    tst.b   no_resize
                beq.s   L042B
                bsr     resize_aus
                bra.s   L042D           ;->RTS
L042B:          bsr     resize_an
                bsr     phys2scr2
                bra.s   L042D           ;->RTS

L042C:          move.w  D0,D3
                subi.w  #278,D3
                bcs.s   L042E
                lsr.w   #4,D3
                cmpi.w  #2,D3
                bcc.s   L042E
                neg.w   D3
                cmp.w   copy_mode,D3
                beq.s   L042D
                move.w  D3,copy_mode
                bsr     L04BA
                btst    #0,copy_status
                beq.s   L042D
                movem.w D0-D4,-(SP)
                bsr     copy_board
                move.w  ani_x1,D0
                move.w  ani_y1,D1
                move.w  D0,D3
                move.w  D1,D4
                bsr     draw_box
                movem.w (SP)+,D0-D4
L042D:          rts

;Bedient die Funktionstasten der Copybox
L042E:          cmpi.w  #272,D0         ;Rechts der Funktionstasten?
                bcc     Hm
                cmp.w   #190,D1         ;Winkel verÑndern?
                bgt     change_angle
                btst    #2,D2           ;Links neu gedrÅckt?
                beq     Hm              ;Nein->Raus
                move.w  D1,D5
                subi.w  #141,D5         ;Unterhalb der Funktionstasten?
                bcs     Hm
                ext.l   D5
                divu    #6,D5           ;Nummer der Funktionstaste bestimmen
                cmpi.w  #8,D5           ;8 StÅck hat es maximal
                bcc     Hm
                move.w  D5,D4
                mulu    #6,D4
                lea     L0575(PC),A3    ;copy_strk
                tst.w   0(A3,D4.w)      ;Funktion aktiviert?
                bne     Hm              ;Nein -> RTS
                bsr     inv_copy_btn
L042F:          move.w  D5,-(SP)        ;Nummer des Buttons merken
                bsr     animier_objekte
                bsr     Sm
                bsr     get_maus
                move.w  (SP)+,D5
                btst    #4,D2           ;Links neu losgelassen?
                bne.s   L0432           ;ja, Ende der Abfrage
                cmpi.w  #272,D0         ;zu weit nach rechts?
                bcc.s   L0431
                move.w  D1,D4
                subi.w  #141,D4         ;Obere Grenze
                bcs.s   L0431
                ext.l   D4
                divu    #6,D4           ;Neue Buttonnummer bestimmen
                cmpi.w  #8,D4
                bcc.s   L0431
                move.w  D4,D6
                mulu    #6,D6
                lea     L0575(PC),A3
                tst.w   0(A3,D6.w)      ;Funktion aktiviert?
                bne.s   L0431           ;Nein
                cmp.w   D4,D5           ;Gleiche Funktionstaste wie vorher?
                beq.s   L042F           ;ja, weiter warten
                bsr     Hm
                tst.w   D5              ;War vorher was invertiert?
                bmi.s   L0430           ;Nein
                bsr     inv_copy_btn    ;Sonst invertierung wieder ausschalten
L0430:          move.w  D4,D5           ;Neue Buttonnummer merken
                bsr     inv_copy_btn    ;Und Button invertieren
                bsr     Sm
                bra.s   L042F
L0431:          tst.w   D5              ;War vorher was invertiert?
                bmi.s   L042F           ;Nein, weiter
                bsr     Hm
                bsr     inv_copy_btn    ;Sonst aktuellen Button deaktivieren
                move.w  #-1,D5          ;und merken
                bsr     Sm
                bra.s   L042F           ;Und weiter warten

;Links wurde der Mausknopf losgelassen
L0432:          tst.w   D5              ;War Funktion angewÑhlt?
                bmi     Hm              ;Nein->RTS
                bsr     Hm
                move.w  #7,D6
L0433:          bsr     inv_copy_btn    ;Button wieder abschalten
                move.w  vblcounter,button_klicked
L0434:          move.w  vblcounter,D7
                sub.w   button_klicked,D7
                cmpi.w  #2,D7           ;2 VBLs warten
                bcs.s   L0434
                dbra    D6,L0433        ;und flashen lassen

                cmpi.w  #1,D5           ;Copy?
                beq.s   L0435           ;ja, dann weiter
                clr.b   changed         ;Es wurde was verÑndert!
L0435:          cmpi.w  #2,D5           ;Paste?
                bne.s   L0436           ;Nein, weiter
                bsr     copy_paste      ;Sonst Paste ausfÅhren
                move.w  #2,D5           ;es wurde Paste angeklickt
                bra     L0443           ;zurÅckinvertieren, anzeigen->RTS
L0436:          cmpi.w  #4,D5           ;Rotate?
                bne     L043E
                bsr     copy_rotate
                moveq   #4,D5
                bsr     inv_copy_btn    ;Rotate-Button zurÅckinvertieren
                rts

L0437:          bsr.s   put_copybox_back
                bsr.s   draw_copybox
                rts

put_copybox_back:movea.l irgend_copy,A0 ;Pointer auf den Copybuffer(?)
                move.l  A0,objekt_pointer ;hier steht das Objekt
                movea.l scr2,A1
                movea.l A1,A2
                move.w  #2240,D0        ;224 Scanlines
                tst.b   less_memory
                bne.s   L0439
                lsr.w   #1,D0           ;sonst nur 112 Scanlines
                bra.s   L0439
L0438:          move.l  (A1)+,(A0)+     ;gedrehtes Objekt in irgend_copy
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
L0439:          dbra    D0,L0438
                movea.l copybox_screen,A1
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L043A
                move.w  #999,D0
L043A:          move.l  (A1)+,(A2)+     ;copybox_screen->scr2
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                dbra    D0,L043A
                rts

draw_copybox:   tst.w   board_da
                bne.s   L043C
                bsr     copy_board
L043C:          bsr     make_maske
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                bsr     draw_box        ;Objekt neu zeichnen
                movea.l scr2,A0
                movea.l copybox_screen,A1
                move.w  #1999,D0
                tst.w   board_da
                bne.s   L043D
                move.w  #999,D0
L043D:          move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
                dbra    D0,L043D
                bsr     phys2scr2
                rts

L043E:          cmpi.w  #5,D5           ;H-Flip?
                bne.s   L043F
                bsr     copy_hflip
                move.w  #5,D5           ;Button wieder aus
                bsr     inv_copy_btn
                rts
L043F:          cmpi.w  #6,D5           ;V-Flip?
                bne.s   L0440
                bsr     copy_vflip
                move.w  #6,D5
                bsr     inv_copy_btn    ;Button wieder aus
                rts
L0440:          cmpi.w  #7,D5           ;T_edge?
                bne.s   L0441
                bsr     copy_tedge
                move.w  #7,D5
                bsr     inv_copy_btn    ;Und Button wieder aus
                rts
L0441:          cmpi.w  #3,D5           ;Clear?
                beq.s   L0442
                bsr     copy_copy       ;Copy ausfÅhren
                cmpi.w  #1,D5           ;Nur Copy?
                beq.s   L0443           ;ja, weiter, sonst weglîschen
L0442:          bsr     phys_2_scr1     ;ja, so merken wie
L0443:          bsr     inv_copy_btn
L0444:          bsr     on_off_buttons
                bra     redraw_copy_opt

;User will den Rotate-Winkel verÑndern
change_angle:   cmp.w   #254,D0
                bgt     change_richtung

                movem.l D0-A6,-(SP)     ;Register retten

                bsr.s   check_angle     ;VerÑndert ggf. den Winkel

                bsr     Sm
                moveq   #-1,D7
delay1:         bsr     get_maus
                move.w  D2,D6
                and.w   #%0000000000000011,D6 ;Links oder rechts gedrÅckt?
                beq.s   raus_hier
                dbra    D7,delay1

nochmal6:       bsr     Hm
                bsr.s   check_angle
                bsr     Sm
                move.w  #8000,D7
delay2:         bsr     get_maus
                move.w  D2,D6
                and.w   #%0000000000000011,D6 ;Links oder rechts gedrÅckt?
                beq.s   raus_hier
                dbra    D7,delay2
                bra.s   nochmal6

raus_hier:      bsr     Hm
                movem.l (SP)+,D0-A6
                rts

check_angle:    movem.l D0-A6,-(SP)
                btst    #0,D2           ;Links gedrÅckt?
                beq.s   no_links
                addq.w  #1,rotate_winkel
                cmpi.w  #360,rotate_winkel
                blt.s   show_angle
                move.w  #1,rotate_winkel
                bra.s   show_angle
no_links:       btst    #1,D2           ;Rechts gedrÅckt?
                beq.s   raus_hier2
                subq.w  #1,rotate_winkel
                bgt.s   show_angle
                move.w  #359,rotate_winkel
show_angle:     lea     winkel_ascii(PC),A0
                move.w  rotate_winkel,D0
                bsr     wandel_fest_dez ;Winkel einsetzen
                move.b  #'¯',-(A0)
                lea     winkel_koord(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                lea     winkel_ascii(PC),A0
                bsr     print6x6
raus_hier2:     movem.l (SP)+,D0-A6
                rts

change_richtung:eori.w  #%0000000000000011,rotate_richtung ;Anderes Icon darstellen
                movem.l D0-A6,-(SP)
                lea     rotate_richtung(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                addq.w  #1,D0
                addq.w  #1,D1
                moveq   #15,D3
                bsr     draw_icon
                movem.l (SP)+,D0-A6
                rts

Hm:             move.l  D0,-(SP)
                move.l  #v_hide_c,D0
                bsr     _vdi
                move.l  (SP)+,D0
                rts

Sm:             move.l  D0,-(SP)
                clr.w   int_in          ;normale Funktion
                move.l  #v_show_c,D0
                bsr     _vdi
                move.l  (SP)+,D0
                rts

;F2 im Copybox-Modus:
copy_copy:      movea.l objekt_pointer,A0
                cmpa.l  cut_buff,A0
                beq     L044A           ;->RTS
;                move.w  ani_x1,pos_objektx ;Bildschirmkordinate merken
;                move.w  ani_y1,pos_objekty
                tst.w   board_da
;                bne     keins1
                move.w  grab_y,D6
;                add.w   D6,pos_objekty  ;angleichen
;keins1:
                movem.l D0-A6,-(SP)

                move.w  pos_objekty,D0
                move.w  pos_objekty,D1
                lea     hbl_system,A0
                bsr     sammel_raster   ;Welche Palette hat das Objekt?
                movem.l rasters2+2,D0-D7
                movem.l D0-D7,objekt_palette
                movem.l (SP)+,D0-A6

                move.w  breite_bytes,D6
                move.w  D6,cpy_buff_breite_bytes
                move.w  objekt_x2,cutbuffer_x ;Position des alten Copycuts merken
                clr.w   cutbuffer_y
                move.w  objekt_y2,D7
                mulu    D6,D7
                adda.w  D7,A0
                lsr.w   #3,D6
                move.w  breite,pixel_per_scan
                move.w  hîhe,D7
                move.w  D7,anz_scanlines
                mulu    D6,D7
                movea.l cut_buff,A1
                bra.s   L0449
L0448:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
L0449:          dbra    D7,L0448
L044A:          rts

;Antialiased das aktuelle Objekt bzw. den kompletten Arbeitsscreen
jack_alias:     movem.l D0-A6,-(SP)

                bsr     Hm

                btst    #0,jack_status  ;Ist was ausgeschnitten
                bne.s   ja1

                jsr     put_work_sure
                clr.b   changed         ;Es wurde was verÑndert

                moveq   #0,D0           ;VBL-Palette
                moveq   #0,D1
                lea     hbl_system,A0
                bsr     sammel_raster   ;An welche Palette kommt Objekt?

                tst.b   ohne_raster     ;Alle benutzen Farben nehmen?
                bne.s   alle_nehmen3
alle_nehmen3:

                lea     rasters2+2,A0   ;Palette des Objektes
                movea.l scr1,A1         ;Adresse des Objekts
                move.w  #200,D0         ;Hîhe
                tst.w   board_da
                bne.s   kein2
                moveq   #100,D0
kein2:          move.w  #320,D1
                move.w  #160,D2
                moveq   #0,D3           ;normaler ST
                tst.w   ste_support
                bne.s   kein_ste4
                jsr     umsort_ste_pal  ;Palette des Bildschirms umdrehen
                moveq   #1,D3
kein_ste4:      bsr     anti_alias
                bra     alias_end

ja1:            movea.l scr2,A0         ;Scr2 lîschen
                bsr     clear_neo

                lea     bb,A6           ;verschieben des Objektes nach 0/0
                move.w  breite,(A6)     ;Breite in Pixeln
                move.w  hîhe,2(A6)      ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #14,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                move.w  objekt_x2,14(A6) ;Quell_x
                move.w  objekt_y2,16(A6) ;Quell_y
                move.l  objekt_pointer,18(A6) ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  breite_bytes,24(A6) ;Breite Quelle in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                clr.w   28(A6)          ;Zielkoordinaten
                clr.w   30(A6)
                move.l  scr2,32(A6)     ;Zieladresse
                move.w  #8,36(A6)       ;Offset zur selben Plane
                move.w  breite_bytes,38(A6) ;Breite Ziel in Bytes
                move.w  #2,40(A6)       ;Offset zur nÑchsten Plane
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                move.w  objekt_y1,D0
                bpl.s   pos8888
                moveq   #0,D0           ;Positiv machen
pos8888:        move.w  D0,D1
                lea     hbl_system,A0
                bsr     sammel_raster   ;An welche Palette kommt Objekt?

alias1:
                moveq   #0,D2           ;Normal von Farbe 0 bis 15
                moveq   #15,D3
                tst.b   ohne_raster     ;Alle benutzen Farben nehmen?
                bne.s   alle_nehmen2
                jsr     blitz
alle_nehmen2:

                lea     rasters2+2,A0   ;Palette des Objektes
                movea.l scr2,A1         ;Adresse des Objekts
                move.w  hîhe,D0
                move.w  breite,D1
                move.w  breite_bytes,D2
                moveq   #0,D3           ;normaler ST
                tst.w   ste_support
                bne.s   kein_ste3
                moveq   #1,D3           ;STE
                jsr     umsort_ste_pal  ;Palette des Bildschirms umdrehen
kein_ste3:      bsr     anti_alias

                lea     bb,A6           ;verschieben des Objektes nach 0/0
                move.w  breite,(A6)     ;Breite in Pixeln
                move.w  hîhe,2(A6)      ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #14,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                clr.w   14(A6)          ;Quell_x
                clr.w   16(A6)          ;Quell_y
                move.l  scr2,18(A6)     ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  breite_bytes,24(A6) ;Breite Quelle in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  objekt_x2,28(A6) ;Zielkoordinaten
                move.w  objekt_y2,30(A6)
                move.l  objekt_pointer,32(A6) ;Zieladresse
                move.w  #8,36(A6)       ;Offset zur selben Plane
                move.w  breite_bytes,38(A6) ;Breite Ziel in Bytes
                move.w  #2,40(A6)       ;Offset zur nÑchsten Plane
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                bsr     calc_jack_ani

alias_end:      movem.l (SP)+,D0-A6
                rts

***
***  Antialiasroutine fÅr NEOchrome Master
***  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
***  (C) by Steffen Fischer
***
***   "Konversion" aus Cyberpaint v2.0
***   (Anpassung auf STE-Farben war nîtig, verlangsamt aber erheblich!)
***   (jetzt behoben. STE-Farben sind einstellbar)
***   öbergabeparameter:
***   ~~~~~~~~~~~~~~~~~~
***   a0 = Palette auf der antialiased wird (im STE-Format!!!! $000-$FFF)
***   a1 = Pointer auf Grafikbuffer
***   d0 = Hîhe der Grafik in Scanlines (1-200)
***   d1 = Breite der Grafik in Pixeln (16-320) VIELFACHES VON 16!!!!!
***   d2 = Bytes pro Scanline (8-160)
***   d3 = STE-Flag (1=STE/TT, 0= normaler ST)
***
***   Vorsicht! Nimmt keine RÅcksicht auf eventuelle Rasterpaletten etc.!
***

anti_alias:     movem.l D0-A6,-(SP)

                move.l  A0,a_alias_palpoint
                move.l  A1,a_alias_graphpoint
                move.w  D0,hoehe_in_scanlines
                move.w  D1,breite_in_pixel
                move.w  D1,D4           ; fÅr spÑter merken
                addq.w  #2,D1           ; Links und rechts kommen zwei Pixel dazu
                lsr.w   #1,D1           ; /2 -> Worte
                move.w  D1,breite2_in_worte
                move.w  D2,bytes_pro_scanline
                move.w  D3,a_alias_ste_flag

                subq.w  #1,D4           ; Werte von 0-319
                and.w   #-16,D4         ; untere 4 Bits weg
                lsr.w   #4,D4           ;/16 = Anzahl der Bitblocks pro Zeile
                addq.w  #1,D4
                move.w  D4,bitblocks_pro_scanline

;******                bsr     preshift_plot_data ; preshiftet Punkte
; kann auch einmal beim Start von NEOchrome ausgefÅhrt werden.


                bsr     col_organisation ; Farben errechnen

                lea     colbytes1+1,A0
                movea.l a_alias_graphpoint,A1
                bsr     conv_cols_to_bytes ; Eine Scanline umrechnen

                lea     colbytes1,A0
                move.b  1(A0),(A0)      ; Byte 2 nach Byte 1 kopieren
                move.w  breite_in_pixel,D0
                move.b  0(A0,D0.w),1(A0,D0.w) ; vorletztes Byte in letztes Byte kopieren

                lea     colbytes1,A0    ; Zeile 1 in Zeile 2 kopieren
                lea     colbytes2,A1
                move.w  breite2_in_worte,D0
                bsr     copy_words

                lea     colbytes1,A0    ; Zeile 1 in Zeile 3 kopieren
                lea     colbytes3,A1
                move.w  breite2_in_worte,D0
                bsr     copy_words

                cmpi.w  #1,hoehe_in_scanlines ; weniger als 1 Zeile zum antialiasen
                ble.s   object_too_small

                lea     colbytes3+1,A0
                movea.l a_alias_graphpoint,A1
                adda.w  bytes_pro_scanline,A1 ; eine Zeile tiefer
                bsr     conv_cols_to_bytes

                lea     colbytes3,A0
                move.b  1(A0),(A0)      ; zweites Byte nach vorne
                move.w  breite_in_pixel,D0
                move.b  0(A0,D0.w),1(A0,D0.w) ; vorletztes Byte in Letztes

object_too_small:
                move.w  hoehe_in_scanlines,D7
                subq.w  #1,D7
                bmi     exit_antialias  ; weniger als eine Zeile -> raus!
a_alias_work_loop:
                move.w  D7,-(SP)

                bsr     do_antialias    ; eigentliches Antialiasen

                bsr     write_back_buffer

                movea.l a_alias_graphpoint,A0 ; eine Zeile tiefer
                adda.w  bytes_pro_scanline,A0
                move.l  A0,a_alias_graphpoint

                lea     colbytes2,A0    ; Zeile 2 in Zeile 1 kopieren
                lea     colbytes1,A1
                move.w  breite2_in_worte,D0
                bsr     copy_words

                lea     colbytes3,A0    ; Zeile 3 in Zeile 2 kopieren
                lea     colbytes2,A1
                move.w  breite2_in_worte,D0
                bsr     copy_words

                move.w  (SP),D0         ; ZÑhler vom Stack holen
                cmp.w   #1,D0           ; letzte Zeile nicht holen
                ble.s   dont_alias_lastline

                lea     colbytes3+1,A0  ; 3. Zeile
                movea.l a_alias_graphpoint,A1
                adda.w  bytes_pro_scanline,A1 ; eine Scanline tiefer
                bsr     conv_cols_to_bytes ; Zeile umrechnen

                lea     colbytes3,A0
                move.b  1(A0),(A0)      ; zweites Byte nach vorne
                move.w  breite_in_pixel,D0
                move.b  0(A0,D0.w),1(A0,D0.w) ; vorletztes Byte in Letztes

dont_alias_lastline:
                move.w  (SP)+,D7
                dbra    D7,a_alias_work_loop

exit_antialias: movem.l (SP)+,D0-A6
                rts


copy_words:
; Kopiert x Worte
; Parameter:
; a0=Quelladresse
; a1=Zieladresse
; d0=Anzahl der Worte

                subq.w  #1,D0           ; -1 wegen DBRA
copyloop:       move.w  (A0)+,(A1)+
                dbra    D0,copyloop
                rts



do_antialias:
; eigentliche Antialiasroutine. Antialiased die Farbbytewerte
; Parameter: keine

                lea     work_colbytes,A0 ; Dort wird Scanline erstellt
                lea     colbytes1,A1    ; Zeile 1
                lea     colbytes2,A2    ; Zeile 2
                lea     colbytes3,A3    ; Zeile 3
                lea     similar_colstab,A4 ; éhnlichkeiten der Farben
                lea     rgb_nibbletab,A6 ; Aufgesplittete Palette

                move.w  breite_in_pixel,D6
                subq.w  #1,D6           ; -1 wegen DBRA

antialiasloop:  move.b  1(A2),D0        ; 2. Farbbyte der Zeile 2 holen
                cmp.b   (A2),D0         ; mit einem vorher vergleichen!
                bne.s   not_links       ; nicht gleich! -> verzweigen!
                cmp.b   2(A2),D0        ; 3. Farbbyte auch gleich? verzweigen
                beq.s   antialias_nix
not_links:      cmp.b   1(A1),D0        ; 2. Farbbyte der Zeile 1
                bne.s   not_rechts      ; nicht gleich -> verzweig!
                cmp.b   1(A3),D0        ; 2. Farbbyte der Zeile 3
                beq.s   antialias_nix   ; gleich! -> verzweig
not_rechts:     cmp.b   (A1),D0         ; 1. Farbbyte der 1. Zeile?
                bne.s   not_oben        ; nicht gleich! -> verzweig
                cmp.b   2(A3),D0        ; 3. Farbbyte der 3. Zeile
                beq.s   antialias_nix   ; gleich -> verzweig!
not_oben:       cmp.b   2(A1),D0        ; 3. Farbbyte der 1. Zeile!
                bne.s   antialias_it    ; nicht gleich-> antialias
                cmp.b   (A3),D0         ; 1. Farbyte der 3. Zeile
                bne.s   antialias_it    ; nicht gleich -> antialias
antialias_nix:  addq.l  #1,A1           ; nÑchstes Farbbyte!
                addq.l  #1,A2
                addq.l  #1,A3
                move.b  (A2),(A0)+      ; Farbbyte Zeile 2 einfach kopieren
                dbra    D6,antialiasloop
                rts

; Vergleiche oben immer in 3*3 Pixelfeld
;
; ~ ist das Sourcepixel
; * sind die Pixel mit denen verglichen wird
;
; Vergleich 1:
;
; + + +
; * ~ *
; + + +
;
; Vergleich 2:
;
; + * +
; + ~ +
; + * +
;
; Vergleich 3:
;
; * + +
; + ~ +
; + + *
;
; Vergleich 4:
;
; + + *
; + ~ +
; * + +

; Farbwerte werden folgendermaûen berechnet:
;
; die einzelnen Nibbles werden so gewichtet:
;
; 1      4     1        Zeile 1
;
; 4     12     4        Zeile 2
;
; 1      4     1        Zeile 3
;
; Bsp.:  GesamtRotwert=R1Z1+4*R2Z1+R3Z1+4*R1Z2+12*R2Z2+4*R3Z2+R1Z3+4*R2Z3+R3Z3
;        ditto fÅr Blau und GrÅn
;
; anschlieûend wird 16 aufaddiert und die Werte durch 32 geteilt.


antialias_it:
                clr.w   D0              ; Hier wird antialiased!
                move.b  (A1)+,D0        ; 1. Farbwert Zeile 1 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D1
                move.w  (A5)+,D2
                move.w  (A5)+,D3
                clr.w   D0
                move.b  (A1),D0         ; 2. Farbwert Zeile 1 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D1
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D2
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D3
                clr.w   D0
                move.b  1(A1),D0        ; 3. Farbwert Zeile 1 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                add.w   (A5)+,D1
                add.w   (A5)+,D2
                add.w   (A5)+,D3
                clr.w   D0
                move.b  (A2)+,D0        ; 1. Farbwert Zeile 2 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D1
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D2
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D3
                clr.w   D0
                move.b  (A2),D0         ; 2. Farbwert Zeile 2 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D1
                add.w   D0,D1
                add.w   D0,D1
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D2
                add.w   D0,D2
                add.w   D0,D2
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D3
                add.w   D0,D3
                add.w   D0,D3
                clr.w   D0
                move.b  1(A2),D0        ; 3. Farbwert Zeile 2 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D1
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D2
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D3
                clr.w   D0
                move.b  (A3)+,D0        ; 1. Farbwert Zeile 3 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                add.w   (A5)+,D1
                add.w   (A5)+,D2
                add.w   (A5)+,D3
                clr.w   D0
                move.b  (A3),D0         ; 2. Farbwert Zeile 3 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D1
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D2
                move.w  (A5)+,D0
                add.w   D0,D0
                add.w   D0,D0
                add.w   D0,D3
                clr.w   D0
                move.b  1(A3),D0        ; 3. Farbwert Zeile 3 holen
                asl.w   #3,D0
                lea     0(A6,D0.w),A5
                add.w   (A5)+,D1
                add.w   (A5)+,D2
                add.w   (A5)+,D3
                add.w   #16,D1
                add.w   #16,D2
                add.w   #16,D3
                asr.w   #5,D1
                asr.w   #5,D2
                asr.w   #5,D3
                asl.w   #6,D1           ; R-Wert mal 64 (wegen Tabelle!)
                asl.w   #3,D2           ; G-Wert mal 8
                tst.w   a_alias_ste_flag
                beq.s   thatsalldude
                add.w   D1,D1           ; beim STE noch mal 4
                add.w   D1,D1           ; und mal 2
                add.w   D2,D2
thatsalldude:   add.w   D2,D1
                add.w   D3,D1
                move.b  0(A4,D1.w),(A0)+ ; Ñhnliche Farbnummer reinkopieren!
                dbra    D6,antialiasloop ; Hoch verzweigen
                rts

write_back_buffer:
; hier wird der Antialiasbuffer wieder zurÅckgeschrieben

                lea     work_colbytes,A0 ; Farbbuffer
                movea.l a_alias_graphpoint,A1 ; Graphikobjekt
                move.w  bitblocks_pro_scanline,D1
                subq.w  #1,D1
                lea     plot_data_preshiftet,A2 ; Preshiftbuffer fÅr Plotdaten
write_back_loop:move.l  (A0),D2
                bne.s   not_zero
                move.l  4(A0),D3
                bne.s   not_zero
                move.l  8(A0),D3
                bne.s   not_zero
                move.l  12(A0),D3
                bne.s   not_zero
                lea     16(A0),A0
                bra     klopf_rein
not_zero:       moveq   #0,D0
                move.b  (A0)+,D0        ; 1. Farbbyte holen (0-15)
                lsl.w   #3,D0           ; *8 (0-120)
                lea     0(A2,D0.w),A3   ;
                move.l  (A3)+,D2        ; Zwei Werte holen
                move.l  (A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 2. Farbbyte holen (0-15)
                lsl.w   #3,D0           ; *8 (0-120)
                lea     0(A2,D0.w),A3
                or.l    128(A3),D2
                or.l    132(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 3. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    256(A3),D2
                or.l    260(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 4. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    384(A3),D2
                or.l    388(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 5. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    512(A3),D2
                or.l    516(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 6. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    640(A3),D2
                or.l    644(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 7. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    768(A3),D2
                or.l    772(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 8. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    896(A3),D2
                or.l    900(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 9. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1024(A3),D2
                or.l    1028(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 10. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1152(A3),D2
                or.l    1156(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 11. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1280(A3),D2
                or.l    1284(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 12. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1408(A3),D2
                or.l    1412(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 13. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1536(A3),D2
                or.l    1540(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 14. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1664(A3),D2
                or.l    1668(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 15. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1792(A3),D2
                or.l    1796(A3),D3
                moveq   #0,D0
                move.b  (A0)+,D0        ; 16. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1920(A3),D2
                or.l    1924(A3),D3
klopf_rein:     move.l  D2,(A1)+        ; Werte auf Screen klopfen
                move.l  D3,(A1)+
                dbra    D1,write_back_loop
                rts



conv_cols_to_bytes:
; rechnet eine Scanline in Bytedaten um, d.h. aus Farbnibbles werden Farbbytes
; in a0=Adresse des Buffers fÅr die Farbbytes (0-15) dieser Buffer muû 322
; Bytes groû sein.
; in a1=Adresse der Graphik

                move.w  bitblocks_pro_scanline,D1 ; Werte von 1-20
                subq.w  #1,D1           ; -1 wegen DBRA
convertscanline:move.l  (A1),D3         ; alle Bits zusammenfassen
                or.l    4(A1),D3        ; eines Bitblocks
                bne.s   notallzero      ; alle Werte gleich 0?
                addq.l  #8,A1
                move.b  D3,(A0)+        ; 16 Nuller kopieren
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                move.b  D3,(A0)+
                bra.s   weiterinloop
notallzero:     move.w  (A1)+,D3        ; Plane 0
                move.w  (A1)+,D4        ; Plane 1
                move.w  (A1)+,D5        ; Plane 2
                move.w  (A1)+,D6        ; Plane 3
                moveq   #15,D7          ; 16-1 Bits
getcolors:      clr.b   D2              ; Getpixel
                add.w   D6,D6
                addx.b  D2,D2
                add.w   D5,D5
                addx.b  D2,D2
                add.w   D4,D4
                addx.b  D2,D2
                add.w   D3,D3
                addx.b  D2,D2
                move.b  D2,(A0)+        ; Jedes Nibble als Byte abspeichern
                dbra    D7,getcolors
weiterinloop:   dbra    D1,convertscanline
                rts




col_organisation:
; Farben fÅr Antialiasing organisieren

                bsr.s   split_rgb       ; Palette in Nibbles aufspalten

;Hier wird zu jedem mîgl. Farbwert (000-fff oder (777)) die jeweils Ñhnlichste
; Farbe in der aktuellen Palette gesucht.

                lea     similar_colstab,A3 ; dort kommen 4096 Farbnummern rein
                move.w  a_alias_ste_flag,D6 ; 1=STE, 0=ST
                lsl.w   #3,D6           ; *8 -> 8 oder 0
                moveq   #8,D7
                add.w   D6,D7           ; jetzt 16 (STE) oder 8 (ST) als ZÑhler
                moveq   #0,D4           ; R-ZÑhler (0-f)
r_loop:         moveq   #0,D5           ; G-ZÑhler (0-f)
g_loop:         moveq   #0,D6           ; B-ZÑhler (0-f)
b_loop:         move.w  D4,D0
                asl.w   #8,D0
                move.w  D5,D1
                asl.w   #4,D1
                add.w   D1,D0
                add.w   D6,D0           ; Farbwert aus d4,d5,d6 erstellen
                bsr.s   search_color    ; sucht dazu éhnlichste Farbe
                move.b  D0,(A3)+        ; Ñhnlichste Farbnummer speichern
                addq.w  #1,D6
                cmp.w   D7,D6           ; B-fertig?
                blt.s   b_loop
                addq.w  #1,D5
                cmp.w   D7,D5
                blt.s   g_loop          ; G-fertig?
                addq.w  #1,D4
                cmp.w   D7,D4
                blt.s   r_loop          ; R-fertig?
                rts

split_rgb:
*** Spaltet die Palette in R,G,B auf
                lea     rgb_nibbletab,A3
                movea.l a_alias_palpoint,A4
                moveq   #15,D4          ; 16 Farben
                move.w  #$0777,D7
                move.w  a_alias_ste_flag,D6
                mulu    #$0888,D6
                add.w   D6,D7           ; Andwert berechnen (777 oder fff)
splitloop:      move.w  (A4)+,D5        ; Farbwert holen
                and.w   D7,D5
                move.w  D5,D0
                asr.w   #8,D0
                move.w  D0,(A3)         ; Rot-Wert
                move.w  D5,D0
                and.w   #$00F0,D0
                asr.w   #4,D0
                move.w  D0,2(A3)        ; GrÅn-Wert
                move.w  D5,D0
                and.w   #$000F,D0
                move.w  D0,4(A3)        ; Blau-Wert
                addq.l  #8,A3           ; 8 weiter (wegen Rechenzeit spÑter)
                dbra    D4,splitloop
                rts

search_color:
; bekommt in d0 Farbwert und sucht Ñhnlichste Farbe in der Farbpalette
; gibt in d0 Farbnummer (0-15) zurÅck

                movem.l D1-D7/A3,-(SP)
                movea.l a_alias_palpoint,A3 ; Zeiger auf Palette
                lea     muls_tab_mitte,A4 ; Dort sind Quadrate von -15 bis 15
                move.w  #1000,D7        ; Farbdifferenz als Minimum
                moveq   #0,D6
                moveq   #0,D1           ; FarbzÑhler auf 0
                move.w  D0,D4           ; zu dieser Farbe Ñhnlichste suchen
                move.w  #$0777,D3
                move.w  a_alias_ste_flag,D2
                muls    #$0888,D2
                add.w   D2,D3
diffloop:       move.w  (A3)+,D5        ; Farbe aus Palette holen
                and.w   D3,D5

; farbdiffquadr:
; bekommt in d4 und d5 zwei Farben
; gibt in d0 eine Farbdifferenz von zwei Farben zurÅck
; d0=(r1-r2)^2+(g1-g2)^2+(b1-b2)^2

                move.w  D1,-(SP)
                move.w  D6,-(SP)
                move.w  D7,-(SP)
                move.w  D4,D0
                and.w   #$000F,D0       ; nur Blauwert1
                move.w  D5,D1
                and.w   #$000F,D1       ; nur Blauwert2
                move.w  D0,D6
                sub.w   D1,D6           ; Blauwert1-Blauwert2
                move.w  D6,D7
                add.w   D7,D7
                move.w  0(A4,D7.w),D7   ; Quadrat holen
;                muls    D6,D7                ; (Blauwert1-Blauwert2)^2
                move.w  D4,D0
                asr.w   #4,D0
                and.w   #$000F,D0       ; GrÅnwert1
                move.w  D5,D1
                asr.w   #4,D1
                and.w   #$000F,D1       ; GrÅnwert2
                move.w  D0,D6
                sub.w   D1,D6           ; (G1-G2)
                move.w  D6,D0
;                muls    D6,D0                ; (G1-G2)^2
                add.w   D0,D0
                move.w  0(A4,D0.w),D0   ; Quadrat holen
                add.w   D0,D7           ; auf (B1-B2)^2 addieren
                move.w  D4,D0
                asr.w   #8,D0           ; R1
                move.w  D5,D1
                asr.w   #8,D1           ; R2
                move.w  D0,D6
                sub.w   D1,D6           ; R1-R2
                move.w  D6,D0
;                muls    D6,D0                ; (R1-R2)^2
                add.w   D0,D0
                move.w  0(A4,D0.w),D0   ; Quadrat holen
                add.w   D0,D7           ; auf bisher. Quadrate addieren
                move.w  D7,D0           ; in d0 zurÅckgeben
                move.w  (SP)+,D7
                move.w  (SP)+,D6
                move.w  (SP)+,D1

                cmp.w   D7,D0           ; éhnlichkeit grîûer?
                bge.s   nicht_Ñhnlicher
                move.w  D0,D7           ; neue minimale éhnlichkeit
                move.w  D1,D6           ; Pos. der Farbe
nicht_Ñhnlicher:addq.w  #1,D1           ; alle Farben durchmachen
                cmp.w   #16,D1
                bne.s   diffloop
                move.w  D6,D0
                movem.l (SP)+,D1-D7/A3
                rts



preshift_plot_data:
; preshiftet Plotdaten 16 mal in Buffer. Jeweils 16 Farben hintereinander.

                lea     plot_data_preshiftet,A1 ; Buffer zum preshiften
                moveq   #0,D0           ; Shiftcounter
preshift_loop:  lea     point_data,A0   ; Punkte zum preshiften
                moveq   #15,D1          ; 16 Farben
preshift_loop1: move.l  (A0)+,D2        ; Grafikdaten holen
                lsr.l   D0,D2           ; um d0 nach rechts shiften
                move.l  D2,(A1)+
                move.l  (A0)+,D2        ; Grafikdaten holen
                lsr.l   D0,D2           ; um d0 nach rechts shiften
                move.l  D2,(A1)+
                dbra    D1,preshift_loop1
                addq.w  #1,D0           ; Shiftcounter+1
                cmp.w   #16,D0          ; schon 16 mal geshiftet?
                bne.s   preshift_loop
                rts



point_data:
; Punkte fÅr das preshiften

                        DC.W $0000,$0000,$0000,$0000,$8000,$0000,$0000,$0000
                        DC.W $0000,$8000,$0000,$0000,$8000,$8000,$0000,$0000
                        DC.W $0000,$0000,$8000,$0000,$8000,$0000,$8000,$0000
                        DC.W $0000,$8000,$8000,$0000,$8000,$8000,$8000,$0000
                        DC.W $0000,$0000,$0000,$8000,$8000,$0000,$0000,$8000
                        DC.W $0000,$8000,$0000,$8000,$8000,$8000,$0000,$8000
                        DC.W $0000,$0000,$8000,$8000,$8000,$0000,$8000,$8000
                        DC.W $0000,$8000,$8000,$8000,$8000,$8000,$8000,$8000
muls_tab:
; fÅr jeweils von 0 bis -15 die Quadrate

quadrcounter            SET 15
                        REPT 15
                        DC.W quadrcounter*quadrcounter
quadrcounter            SET quadrcounter-1
                        ENDR
muls_tab_mitte:                         ; ab hier mit Offsets arbeiten

quadrcounter            SET 0
                        REPT 16
                        DC.W quadrcounter*quadrcounter
quadrcounter            SET quadrcounter+1
                        ENDR

;Remapt das aktuelle Jack_Knife Objekt
jack_remap:     movem.l D0-A6,-(SP)

                movea.l scr1,A1
                jsr     restore_a1

                lea     bb,A6           ;verschieben des Objektes nach 0/0

                move.w  breite,(A6)     ;Breite in Pixeln
                move.w  hîhe,2(A6)      ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #14,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                move.w  objekt_x2,14(A6) ;Quell_x
                move.w  objekt_y2,16(A6) ;Quell_y
                move.l  objekt_pointer,18(A6) ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  breite_bytes,24(A6) ;Breite Quelle in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                clr.w   28(A6)          ;Zielkoordinaten
                clr.w   30(A6)
                move.l  scr2,32(A6)     ;Zieladresse
                move.w  #8,36(A6)       ;Offset zurselben Plane
                move.w  breite,D1       ;Breite in Pixeln
                addi.w  #$000F,D1       ;auf nÑchsten BB
                lsr.w   #4,D1
                lsl.w   #3,D1           ;Adresse auf BB berechnen
                move.w  D1,38(A6)       ;Breite Ziel in Bytes
                move.w  #2,40(A6)
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                move.w  objekt_y1,D0
                bpl.s   pos888
                moveq   #0,D0           ;Positiv machen
pos888:         move.w  D0,D1
                lea     hbl_system,A0
                bsr     sammel_raster   ;An welche Palette kommt Objekt?

                lea     objekt_palette,A0
                jsr     umsort_ste_pal
                lea     rasters2+2,A0
                jsr     umsort_ste_pal  ;umdrehen

                moveq   #0,D2           ;Normal von Farbe 0 bis 15
                moveq   #15,D3
                tst.b   ohne_raster     ;Alle benutzen Farben nehmen?
                bne.s   alle_nehmen
                move.w  left_col_mark,D2
                move.w  right_col_mark,D3
alle_nehmen:    move.w  breite,D0
                move.w  hîhe,D1
                movea.l scr2,A0
                lea     objekt_palette,A1 ;Palette aus der die Copybox kam
                lea     rasters2+2,A2   ;Neue Palette
                movea.l rotate_buffer,A3 ;Zielspeicher
                bsr     remap

                lea     objekt_palette,A0
                jsr     resort_ste_pal
                lea     rasters2+2,A0
                jsr     resort_ste_pal  ;umdrehen

                lea     bb,A6           ;verschieben des Objektes nach 0/0

                move.w  breite,(A6)     ;Breite in Pixeln
                move.w  hîhe,2(A6)      ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #14,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                clr.w   14(A6)          ;Quell_x
                clr.w   16(A6)          ;Quell_y
                move.l  rotate_buffer,18(A6) ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  breite,D1       ;Breite in Pixeln
                addi.w  #$000F,D1       ;auf nÑchsten BB
                lsr.w   #4,D1
                lsl.w   #3,D1           ;Adresse auf BB berechnen
                move.w  D1,24(A6)       ;Breite Quelle in Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  objekt_x2,28(A6) ;Zielkoordinaten
                move.w  objekt_y2,30(A6)
                move.l  objekt_pointer,32(A6) ;Zieladresse
                move.w  #8,36(A6)       ;Offset zurselben Plane
                move.w  breite_bytes,38(A6) ;Breite Ziel in Bytes
                move.w  #2,40(A6)
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                bsr     calc_jack_ani

                movem.l (SP)+,D0-A6
                rts

;----------------------------------------------------------------------

****
**** ~~~ M.J.A.R. ~~~ (Make Jochen Angry Routine)
****
**** (Routine die bestehende Bilder auf weniger Farben umrechnet)
****                                    -------
**** fÅr NEOchrome Masterø
****
**** (C) by Steffen Fischer
****
**** Programmentwicklung begann am : 20.11.1990
**** Datum der letzten énderung    : 23.11.1990
****
**** ZU BEACHTEN:
**** ~~~~~~~~~~~~
**** -1- Die Anzahl der Farben auf die gekÅrzt wird muû (logischerweise) kleiner
****     der Anzahl der alten Farben sein!
**** -2- Es werden maximal fÅnf Planes bearbeitet (wozu auch mehr?)
**** -3- Es wird eine neue Palette entstehen, die immer 16 Farben groû ist!
**** -4- Es wird immer ein ganzer Screen bearbeitet!
**** -5- Es werden keine eventuellen Raster berÅcksichtigt!
**** -6- Es werden drei Screens benîtigt
**** -7- Zielscreen muû gelîscht sein!
**** -8- Palette muû 32 Werte enthalten (gegebenenfalls unnîtige Farben schwarz)
****
**** öbergabeparameter:
**** ------------------
**** a0..........Palette im ST(E)-Format (-> 32 (!!!!) Farben) ($000-$FFF)
**** a1-a5.......Pointer (Grafik) auf jeweils erstes Wort von Plane 1-5
**** a6..........Pointer auf Zielbuffer fÅr normales Bild (32000 Bytes am StÅck)
**** d0..........Anzahl der Zielfarben (min. 2, max.16)
**** d1..........Offset von einer Plane zur selben Plane (normal 8)
****
**** RÅckgabewerte:
**** --------------
**** a0..........Pointer auf erstellte Farbpalette

shorten_colors:
                movem.l D0-D7/A1-A6,-(SP)

                move.l  A0,mjar_palpointer
                move.l  A6,mjar_destpointer
                move.w  D0,dest_cols_anzahl
                move.w  D1,offset_plane1
                move.w  D1,offset_plane2
                move.w  D1,offset_plane3
                move.w  D1,offset_plane4
                move.w  D1,offset_plane5

                movem.l A1-A5,mjar_planespointer ; Pointer auf Grafik!
                move.w  #19,anzbitblocks ; Bitblocks pro Scanline -1
                move.w  #199,anzscanlines ; Hîhe -1

;********                bsr     preshift_plot_data ; Auch bei Antialiaser

                bsr     count_colors    ; HÑufigkeiten der Farben zÑhlen


                bsr     sort_colors     ; nach HÑufigkeit sortieren

                bsr     sort_colors2    ; nach Farbwert sortieren

                bsr     create_new_palette

                bsr     remap_on_new_palette ; passt Grafik an neue Palette an

                lea     shorten_palette,A0 ; diese Palette zurÅckgeben
                movem.l (SP)+,D0-D7/A1-A6
                rts


remap_on_new_palette:
; passt alte Grafik an neue (beschrÑnkte) Palette an

                bsr     pal_transfer    ; Farben anpassen

                bsr     sort_colors3

                bsr     remap_the_graphic ; Objekt remappen

                rts


remap_the_graphic:
; eigentliches Remappen (remappt komplette Grafik)

                movem.l mjar_planespointer,A1-A5 ; Plane 1 bis 5
                move.w  anzscanlines,D0 ; Anzahl der Scanlines -1
remap2_loop1:   lea     mjar_transfer_numbers,A0 ; zu jeder Farbe die neue Farbe
                lea     mjar_scanline,A6
                move.w  D0,-(SP)
                move.w  anzbitblocks,D0 ; Bitblocks -1
remap2_loop2:   move.w  (A1),D3         ;
                move.w  (A2),D4         ; eine Scanline in Farbwerte
                move.w  (A3),D5         ; umrechnen
                move.w  (A4),D6
                move.w  (A5),D7
                adda.w  offset_plane1,A1
                adda.w  offset_plane2,A2
                adda.w  offset_plane3,A3
                adda.w  offset_plane4,A4
                adda.w  offset_plane5,A5
                        REPT 16 ; 16 Pixel
                moveq   #0,D1
                add.w   D7,D7
                addx.w  D1,D1
                add.w   D6,D6
                addx.w  D1,D1
                add.w   D5,D5
                addx.w  D1,D1
                add.w   D4,D4
                addx.w  D1,D1
                add.w   D3,D3
                addx.w  D1,D1           ; in d1 jetzt Color
                move.b  0(A0,D1.w),(A6)+ ; zugehîrigen Farbwert abspeichern
                        ENDR
                dbra    D0,remap2_loop2

                move.l  A2,-(SP)
                move.l  A3,-(SP)

                movea.l mjar_destpointer,A0 ; Dort kommt neue Grafik hin
                lea     plot_data_preshiftet,A2 ; Preshiftbuffer fÅr Plotdaten
                lea     mjar_scanline,A6
                move.w  anzbitblocks,D1 ; Bitblocks -1
writebackscanline:
                move.l  (A6),D2
                bne.s   not_zero1
                move.l  4(A6),D3
                bne.s   not_zero1
                move.l  8(A6),D3
                bne.s   not_zero1
                move.l  12(A6),D3
                bne.s   not_zero1
                lea     16(A6),A6
                bra     klopf_rein1

not_zero1:      moveq   #0,D0
                move.b  (A6)+,D0        ; 1. Farbbyte holen (0-15)
                lsl.w   #3,D0           ; *8 (0-120)
                lea     0(A2,D0.w),A3   ;
                move.l  (A3)+,D2        ; Zwei Werte holen
                move.l  (A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 2. Farbbyte holen (0-15)
                lsl.w   #3,D0           ; *8 (0-120)
                lea     0(A2,D0.w),A3
                or.l    128(A3),D2
                or.l    132(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 3. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    256(A3),D2
                or.l    260(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 4. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    384(A3),D2
                or.l    388(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 5. Farbbyte holen
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    512(A3),D2
                or.l    516(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 6. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    640(A3),D2
                or.l    644(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 7. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    768(A3),D2
                or.l    772(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 8. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    896(A3),D2
                or.l    900(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 9. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1024(A3),D2
                or.l    1028(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 10. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1152(A3),D2
                or.l    1156(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 11. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1280(A3),D2
                or.l    1284(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 12. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1408(A3),D2
                or.l    1412(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 13. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1536(A3),D2
                or.l    1540(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 14. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1664(A3),D2
                or.l    1668(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 15. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1792(A3),D2
                or.l    1796(A3),D3
                moveq   #0,D0
                move.b  (A6)+,D0        ; 16. Farbbyte
                lsl.w   #3,D0
                lea     0(A2,D0.w),A3
                or.l    1920(A3),D2
                or.l    1924(A3),D3
klopf_rein1:    move.l  D2,(A0)+        ; Werte auf Screen klopfen
                move.l  D3,(A0)+
                dbra    D1,writebackscanline

                move.l  A0,mjar_destpointer

                movea.l (SP)+,A3
                movea.l (SP)+,A2
                move.w  (SP)+,D0

endremap2:      dbra    D0,remap2_loop1

                rts

pal_transfer:
; éhnlichkeitstabelle erstellen
                movea.l mjar_palpointer,A0 ; alte Palette
                lea     mjar_transfer_numbers,A1
                lea     col_number_tab,A2
                moveq   #31,D0          ; 32 Farben
remap_pal:      move.w  D0,-(SP)
                moveq   #0,D1
                move.b  (A2)+,D1        ; Farbnummer holen (0-31)
                add.w   D1,D1           ; *2 wegen Worten
                move.w  0(A0,D1.w),D1   ; Farbe holen
                move.w  D1,D2
                move.w  D2,D3
                lsr.w   #8,D1
                lsr.w   #4,D2
                and.w   #15,D1          ; R, G, B Werte isolieren
                and.w   #15,D2
                and.w   #15,D3
                lea     shorten_palette,A3 ; neue Palette
                moveq   #0,D4
                moveq   #0,D0
                move.w  #1000,D7        ; max. éhnlichkeit Default
search_simcolor:move.w  (A3),D6
                lsr.w   #8,D6           ; Rotwert
                and.w   #15,D6
                sub.w   D1,D6           ; R1-R2
                muls    D6,D6           ; Quadrieren
                move.w  (A3),D5
                lsr.w   #4,D5           ; GrÅnwert
                and.w   #15,D5
                sub.w   D2,D5           ; G1-G2
                muls    D5,D5           ; Quadrieren
                add.w   D5,D6
                move.w  (A3)+,D5        ; Blauwert
                and.w   #15,D5
                sub.w   D3,D5           ; B1-B2
                muls    D5,D5           ; Quadrieren
                add.w   D5,D6
                cmp.w   D7,D6           ; neue éhnlichkeit kleiner?
                bge.s   not_new_aehnl
                move.w  D6,D7           ; neue éhnlichste Farbe
                move.w  D4,D0           ; Pos. merken
not_new_aehnl:  addq.w  #1,D4
                cmp.w   dest_cols_anzahl,D4 ; maximale Anzahl der Farben
                bne.s   search_simcolor
                move.b  D0,(A1)+        ; Position der Farbe merken
                move.w  (SP)+,D0
                dbra    D0,remap_pal
                rts



create_new_palette:
; erstellt neue Palette mit den hÑufigsten Farben

                lea     shorten_palette,A0
                moveq   #15,D0          ; 16 Farben lîschen
clrnewpalette:  move.w  #$00F0,(A0)+    ; GrÅnwert reintun
                dbra    D0,clrnewpalette

                lea     shorten_palette,A0 ; neue Palette
                lea     col_number_tab,A1 ; dort stehen die Farbnummern
                movea.l mjar_palpointer,A2 ; alte Palette
                move.w  dest_cols_anzahl,D0 ; auf soviele Farben umrechnen
                subq.w  #1,D0           ; -1 wegen DBRA
create_pal:     moveq   #0,D1
                move.b  (A1)+,D1        ; Farbnummer holen
                add.w   D1,D1           ; *2 wegen Worten
                move.w  0(A2,D1.w),(A0)+ ; Farbwert aus alter Palette holen
                dbra    D0,create_pal
                rts

count_colors:
;zÑhlt die HÑufigkeit der einzelnen Farben (Pixel) in einem Bild

                lea     anzahl_pixel_pro_color,A0 ; Tabelle mit Anzahl
                moveq   #31,D0
clr_anzahl_tab: clr.w   (A0)+           ; zuerst Tabelle lîschen
                dbra    D0,clr_anzahl_tab

                lea     col_number_tab,A0
                moveq   #0,D0
make_col_numb:  move.b  D0,(A0)+        ; Tabelle mit Werten von 0-31
                addq.w  #1,D0           ; erstellen
                cmpi.w  #32,D0
                bne.s   make_col_numb

                lea     anzahl_pixel_pro_color,A0
                movem.l mjar_planespointer,A1-A5 ; Planes (1-5) holen
                move.w  #3999,D0        ; 4000 Bitblocks
count_cols_loop:moveq   #15,D1          ; 16 Pixel pro Bitblock
                move.w  (A1),D2         ; 5 Grafikwîrter holen
                move.w  (A2),D3
                move.w  (A3),D4
                move.w  (A4),D5
                move.w  (A5),D6
                adda.w  offset_plane1,A1 ; nÑchste Plane
                adda.w  offset_plane2,A2
                adda.w  offset_plane3,A3
                adda.w  offset_plane4,A4
                adda.w  offset_plane5,A5
count_cols_l2:  moveq   #0,D7
                add.w   D6,D6
                addx.w  D7,D7           ; Getcolor
                add.w   D5,D5
                addx.w  D7,D7
                add.w   D4,D4
                addx.w  D7,D7
                add.w   D3,D3
                addx.w  D7,D7
                add.w   D2,D2
                addx.w  D7,D7           ; jetzt Wert von 0-31 in d7
                add.w   D7,D7           ; *2 wegen Worten
                addq.w  #1,0(A0,D7.w)   ; jeweiligen Farbwert erhîhen
                dbra    D1,count_cols_l2
                dbra    D0,count_cols_loop
                rts


sort_colors:
; Sortierroutine mit Bubble-Sort Algorithmus
; Sortiert die Farben nach Anzahl der Pixel (absteigend)
; öbergabeparameter: keine
; RÅckgabewerte: keine

                moveq   #30,D0          ; 32 Farben -2
sortloop0:      move.w  D0,D2
                lea     anzahl_pixel_pro_color,A0
                lea     col_number_tab,A1
sortloop1:      moveq   #0,D3
                moveq   #0,D4
                move.w  (A0),D3         ; Anzahl 1 holen
                move.w  2(A0),D4        ; Anzahl 2 holen
                cmp.l   D3,D4           ; Wert 2 < Wert 1 ?
                ble.s   notsort         ; wenn <= dann kein Tausch
                exg     D3,D4           ; vertauschen
                move.w  D3,(A0)         ; z speichern
                move.w  D4,2(A0)
                move.b  (A1),D3
                move.b  1(A1),D4        ; Farbnummern tauschen
                exg     D3,D4
                move.b  D3,(A1)
                move.b  D4,1(A1)
notsort:        lea     2(A0),A0        ; nÑchster Farbwert
                lea     1(A1),A1
                dbra    D2,sortloop1
                dbra    D0,sortloop0
                rts

sort_colors2:
; Sortierroutine mit Bubble-Sort Algorithmus
; Sortiert die Palette nach Farbwerten (aufsteigend)
; öbergabeparameter: keine
; RÅckgabewerte: keine

                move.w  dest_cols_anzahl,D0 ; soviele Farben sortieren
                subq.w  #2,D0
sort2loop0:     move.w  D0,D2
                lea     anzahl_pixel_pro_color,A1
                lea     col_number_tab,A0
sort2loop1:     moveq   #0,D3
                moveq   #0,D4
                move.b  (A0),D3         ; Anzahl 1 holen
                move.b  1(A0),D4        ; Anzahl 2 holen
                cmp.w   D3,D4           ; Wert 2 < Wert 1 ?
                bge.s   notsort2        ; wenn <= dann kein Tausch
                exg     D3,D4           ; vertauschen
                move.b  D3,(A0)         ; z speichern
                move.b  D4,1(A0)
                move.w  (A1),D3
                move.w  2(A1),D4        ; Farbnummern tauschen
                exg     D3,D4
                move.w  D3,(A1)
                move.w  D4,2(A1)
notsort2:       lea     1(A0),A0        ; nÑchster Farbwert
                lea     2(A1),A1
                dbra    D2,sort2loop1
                dbra    D0,sort2loop0
                rts


sort_colors3:
; Sortierroutine mit Bubble-Sort Algorithmus
; Sortiert die Palette nach Farbwerten (aufsteigend)
; öbergabeparameter: keine
; RÅckgabewerte: keine

                moveq   #30,D0
sort3loop0:     move.w  D0,D2
                lea     mjar_transfer_numbers,A1
                lea     col_number_tab,A0
sort3loop1:     moveq   #0,D3
                moveq   #0,D4
                move.b  (A0),D3         ; Anzahl 1 holen
                move.b  1(A0),D4        ; Anzahl 2 holen
                cmp.w   D3,D4           ; Wert 2 < Wert 1 ?
                bge.s   notsort3        ; wenn <= dann kein Tausch
                exg     D3,D4           ; vertauschen
                move.b  D3,(A0)         ; z speichern
                move.b  D4,1(A0)
                move.b  (A1),D3
                move.b  1(A1),D4        ; Farbnummern tauschen
                exg     D3,D4
                move.b  D3,(A1)
                move.b  D4,1(A1)
notsort3:       lea     1(A0),A0        ; nÑchster Farbwert
                lea     1(A1),A1
                dbra    D2,sort3loop1
                dbra    D0,sort3loop0
                rts



;-------------------------------------------------------------------------

*****
***** REMAP-Funktion fÅr NEOchrome Master (paût Copybox auf neue Palette an)
***** (C) by Steffen Fischer
***** Programmentwicklung begann am: 21.10.90
***** letzte énderungen am         : 23.11.90 (1000% schnellere Version)
***** (nur fÅr Copybox)
*****
***** öbergabeparameter:
***** ------------------
***** d0=Breite der Copybox in Pixel
***** d1=Hîhe   -"-
***** d2=Leftcolormark (0-15)
***** d3=Rightcolormark (0-15)
***** a0=Pointer auf Copybox
***** a1=alte Palette   (mit der Copybox ausgeschnitten wurde)
***** a2=neue Palette   (auf die die Copybox angepaût wird)
***** a3=Pointer auf neuen Buffer
***** (Bitte die Paletten auf folgendes Format vorher anpassen:
***** bei STE-Farben das untere Bit NICHT in das oberste Bit schieben!)
***** Behandelt die Zielpalette mit Leftcolmark und Rightcolmark
***** (NEU: Benutzt die neue (viel schnellere) MJAR-Routine


remap:          movem.l D0-A6,-(SP)     ; alle Register retten

;!!!!!!!!!!!!!!!!!!!!!!
*****                bsr     preshift_plot_data ; schon viel frÅher machen!
; am besten beim Init von NEOchrome, da ich die Routine im Antialiaser, im MJAR
; und hier mache!

                subq.w  #1,D0           ; nur Werte von 0-319
                and.w   #-16,D0         ; untere 4 Bits weg
                lsr.w   #4,D0           ; /16 -> Bitblocks per Scanline
                move.w  D0,anzbitblocks ; Bitblocks pro Zeile -1
                subq.w  #1,D1
                move.w  D1,anzscanlines ; Hîhe -1

                move.w  D2,stefflcolmark
                move.w  D3,steffrcolmark

                move.l  A3,mjar_destpointer ; dort kommt fertige Grafik rein

                movem.l A0-A4,-(SP)
                lea     2(A0),A1        ; alles wegen neuer Routine
                lea     2(A1),A2
                lea     2(A2),A3
                lea     offset_plane5,A4 ; Pointer auf gelîschtes Wort, da nur 4 Planes remapt werden sollen
                movem.l A0-A4,mjar_planespointer
                movem.l (SP)+,A0-A4
                move.w  #8,offset_plane1 ; Planeabstand=8
                move.w  #8,offset_plane2 ; Planeabstand=8
                move.w  #8,offset_plane3 ; Planeabstand=8
                move.w  #8,offset_plane4 ; Planeabstand=8
                move.w  #0,offset_plane5 ; Planeabstand=0 fÅr Plane 5

                move.w  stefflcolmark,D0
                add.w   D0,D0           ; Linke Grenze fÅr Zielpalette
                adda.w  D0,A2           ; Auf Palpointer addieren

                move.w  steffrcolmark,D0
                sub.w   stefflcolmark,D0 ; Anzahl der Farben -1 (wegen DBRA)
                move.w  D0,anzcolors

                addq.l  #2,A1           ; erste Farbe Åberspringen (in Sourcepal)

                lea     mjar_transfer_numbers,A4
                clr.b   (A4)+
                moveq   #1,D7           ; Farbcounter 1=Startfarbe 1!!
remaploop:      move.w  (A1)+,D0        ; alte Farbe holen
                move.w  D0,D1           ; 3 mal wegen R,G,B
                move.w  D0,D2

                and.w   #$0F00,D0       ; nur zulÑssige Bits fÅr R
                lsr.w   #8,D0
                and.w   #$00F0,D1       ; ditto fÅr G
                lsr.w   #4,D1
                and.w   #$000F,D2       ; ditto fÅr B
                movea.l A2,A3           ; neue Palette zum Suchen
                move.w  #1000,D5        ; minimale éhnlichkeit+1 zum Suchen
                move.w  stefflcolmark,D6 ; Farbcounter 2=Dort Startfarbe
searchcolsloop: move.w  (A3),D3         ; neue Farbe holen
                and.w   #$0F00,D3       ; nur R-Wert
                lsr.w   #8,D3
                sub.w   D0,D3           ; neuer R-Wert-alter R-Wert
                mulu    D3,D3           ; Quadrieren
                move.w  D3,D4

                move.w  (A3),D3         ; neue Farbe holen
                and.w   #$00F0,D3       ; nur G-Wert
                lsr.w   #4,D3
                sub.w   D1,D3           ; neuer G-Wert-alter G-Wert
                mulu    D3,D3           ; Quadrieren
                add.w   D3,D4
                move.w  (A3)+,D3        ; neue Farbe holen
                and.w   #$000F,D3       ; nur B-Wert
                sub.w   D2,D3           ; neuer B-Wert-alter B-Wert
                mulu    D3,D3
                add.w   D3,D4           ; in d4 jetzt Farbdifferenzen
                beq.s   endsearchcol    ; falls Wert 0 = Farben gleich
                cmp.w   D5,D4           ; Grîûer bisheriges Minimum?
                bgt.s   nixnewmin
                move.w  D4,D5           ; das ist neues Minimum
                move.w  D6,colpos       ; dort ist Minimum
nixnewmin:      addq.w  #1,D6
                cmp.w   steffrcolmark,D6 ; ZielPal. bis rechte Marke suchen
                ble.s   searchcolsloop
                bra.s   endsearchcol2
endsearchcol:   move.w  D6,colpos
endsearchcol2:  move.w  colpos,D0       ; das ist die neue Farbe
                move.b  D0,(A4)+
                addq.w  #1,D7
                cmp.w   #16,D7          ; schon alle 16 Farben gemacht?
                bne.s   remaploop

                bsr     remap_the_graphic ; eigentliches Pixelaustauschen

                movem.l (SP)+,D0-A6     ; alle Register zurÅck
                rts



;-------------------------------- Ende Remap


jack_paste:     move.b  #1,jack_status
                bra     L044E

copy_paste:     move.b  #-1,rotate_gefÅllt ;Buffer ist nicht mehr gefÅllt
                btst    #0,copy_status  ;Ist schon was selektiert?
                beq.s   L044D           ;Nein, weiter
                move.b  #1,copy_status  ;Jetzt ist was ausgeschnitten
                lea     L07E7,A5        ;Verkleinern(?)
                movea.l A5,A6
                clr.w   (A5)+
                move.l  cut_buff,(A5)+
                move.w  cpy_buff_breite_bytes,(A5)+
                move.w  cutbuffer_x(PC),(A5)+
                move.w  cutbuffer_y(PC),(A5)+
                move.w  pixel_per_scan(PC),(A5)+
                move.w  anz_scanlines(PC),(A5)+
                move.l  irgend_copy,(A5)+
                move.w  breite_bytes,(A5)+
                move.w  objekt_x2,(A5)+
                move.w  objekt_y2,(A5)+
                move.w  breite,(A5)+
                move.w  hîhe,(A5)+
                bsr     L0690
                move.l  irgend_copy,objekt_pointer
                bra     L0450

L044D:          move.b  #1,copy_status
L044E:          move.l  cut_buff,objekt_pointer
                move.w  cpy_buff_breite_bytes,breite_bytes
                move.w  cutbuffer_x(PC),D6
                move.w  D6,objekt_x2
                move.w  cutbuffer_y(PC),D6
                move.w  D6,objekt_y2
                move.w  pixel_per_scan(PC),D6
                move.w  D6,breite
                move.w  anz_scanlines(PC),D6
                move.w  D6,hîhe

                move.w  sondertasten,D7
                and.w   #%0000000000000011,D7 ;Irgendeine Shift gedrÅckt?
                bne.s   paste_old_pos   ;Ja->an alte Position pasten

                move.w  breite,D7       ;Breite
                lsr.w   #1,D7           ;halbieren
                neg.w   D7
                add.w   #160,D7         ;Bildschirmmitte
                move.w  D7,ani_x1
                move.w  D7,objekt_x1
                add.w   breite,D7
                subq.w  #1,D7
                move.w  D7,ani_x4

                move.w  hîhe,D7         ;Hîhe
                lsr.w   #1,D7           ;halbieren
                neg.w   D7
                add.w   #50,D7
                tst.w   board_da
                beq.s   fff
                add.w   #50,D7          ;Bildschirmmitte Fullscreen
                bra.s   ggg
fff:            add.w   grab_y,D7
ggg:            move.w  D7,ani_y1
                move.w  D7,objekt_y1
                add.w   hîhe,D7
                subq.w  #1,D7
                move.w  D7,ani_y4
                bra.s   koord_ready

paste_old_pos:  move.w  pos_objektx,D7  ;Alte Position
                move.w  D7,ani_x1
                move.w  D7,objekt_x1
                add.w   breite,D7       ;+Breite
                subq.w  #1,D7
                move.w  D7,ani_x4       ;=Rechter Rand
                move.w  pos_objekty,D7  ;Alte Position
                move.w  D7,ani_y1
                move.w  D7,objekt_y1
                add.w   hîhe,D7         ;+Hîhe
                subq.w  #1,D7
                move.w  D7,ani_y4       ;=unterer Rand

koord_ready:    move.b  function,D0
                move.w  D0,-(SP)
                move.b  #1,function     ;vom Bildschirm holen
                jsr     put_work_sure   ;Bild zurÅckschreiben
                move.w  (SP)+,D0
                move.b  D0,function     ;wieder alte Funktion aktiv

                tst.w   board_da
                bne.s   show_c1
                bsr     calc_grab       ;Richtige Grabber-Einstellung berechnen
                move.w  grab_y,D0
                sub.w   D0,objekt_y1
                bsr     palette_changed

                movea.l komplettbild,A0
                movea.l scr1,A1
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A0
                move.w  #999,D0
show_work2:     move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Oberen 100 Zeilen vom Komplettbild
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,show_work2

show_c1:        movea.l scr1,A0
                movea.l copybox_screen,A1
                movea.l scr2,A2
                move.w  #1999,D6
L044F:          move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+     ;scr1->scr2->copybox_screen
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                dbra    D6,L044F

                clr.b   L076B
                jsr     put_work_back

                tst.b   function        ;Jack Knife?
                beq     calc_jack_ani   ;ja...
L0450:          bsr     make_maske
                moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D3
                moveq   #0,D4
                bsr     draw_box
                bsr     phys2scr2
                rts

phys_2_scr1:    clr.b   copy_status
                movea.l copybox_screen,A0
                movea.l scr1,A1
                move.w  #1999,D6        ;ganzen Screen -> scr1
                tst.w   board_da        ;Board da?
                bne.s   L0452
                move.w  #999,D6         ;oder bis zum Board
L0452:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D6,L0452
                rts

;Rotierroutine der Copybox
copy_rotate:    tst.b   rotate_gefÅllt  ;Ist der Rotatebuffer gefÅllt?
                beq.s   new_rotate      ;Ja, also neue Rotierfunktion nehmen

                cmpi.w  #90,rotate_winkel ;90 Grad rotieren?
                beq     old_rotate      ;ja, alte Rotierfunktion

new_rotate:     move.b  invertiert,D0   ;Alten Invert-Status merken
                move.w  D0,-(SP)

                jsr     raster_ggf_aus

                bsr     scr12scr2       ;Kopiert scr1->scr2 und zeigt ihn an
                tst.b   rotate_gefÅllt  ;Ist der Rotierbuffer gefÅllt?
                beq.s   ja_gefÅllt      ;ja

                move.w  objekt_x2,D0
                move.w  objekt_y2,D1
                move.w  breite,D2
                move.w  hîhe,D3
                cmp.w   #1,D2           ;Breite=1?
                bgt.s   groû1
                cmp.w   #1,D3           ;Hîhe=1?
                bgt.s   groû1           ;beides->Raus
                tst.w   (SP)+           ;D0 runterholen
                rts
groû1:          moveq   #0,D4           ;Objekt in Buffer Åbertragen
                moveq   #0,D5
                movea.l objekt_pointer,A0
                movea.l rotate_buffer,A1
                bsr     bitblt
                clr.b   rotate_gefÅllt  ;Der Rotatebuffer ist jetzt gefÅllt
                clr.w   akt_winkel      ;Aktueller Winkel ist 0¯
                move.w  breite,breite_old
                move.w  hîhe,hîhe_old

ja_gefÅllt:     move.w  rotate_winkel,D0 ;Um Soviel wird gedreht
                cmpi.w  #93,rotate_richtung ;im math. positiven Sinn?
                beq.s   math_pos
                neg.w   D0              ;Sonst andersrum!
math_pos:       add.w   D0,akt_winkel   ;das ist der neue Winkel!

mach_positiv:   tst.w   akt_winkel      ;Ist der Winkel noch negativ?
                bpl.s   is_positiv
                addi.w  #360,akt_winkel ;Dann 360¯ aufaddieren
                bra.s   mach_positiv    ;und weiter testen
is_positiv:     cmpi.w  #360,akt_winkel
                blt.s   is_okay
                subi.w  #360,akt_winkel
                bra.s   is_positiv

is_okay:        move.w  akt_winkel,D0
                move.w  breite_old,D1
                move.w  hîhe_old,D2
                moveq   #0,D3
                moveq   #0,D4           ;ab 0/0
                movea.l rotate_buffer,A0
                movea.l scr2,A1
                bsr     cls
                bsr     rotate          ;und drehen

                move.w  xmax(PC),D0
                sub.w   xmin(PC),D0
                addq.w  #1,D0           ;Breite berechnen
                cmp.w   #320,D0         ;breiter als Screen?
                ble.s   ok63
                move.w  #320,D0         ;Sonst 320 nehmen
                clr.w   xmin
                move.w  #319,xmax
ok63:           move.w  ymax(PC),D1
                sub.w   ymin(PC),D1
                addq.w  #1,D1           ;Hîhe berechnen
                cmp.w   #200,D1         ;Grîûer als Screen?
                ble.s   ok66
                clr.w   ymin
                move.w  #199,ymax       ;Dann Screenkoodinaten nehmen
                move.w  #200,D1         ;Sonst 200 nehmen
ok66:           move.w  D0,breite
                move.w  D1,hîhe

                move.w  xmin(PC),D0
                move.w  ymin(PC),D1
                move.w  breite,D2
                move.w  hîhe,D3
                moveq   #0,D4
                moveq   #0,D5           ;Gedrehtes nach 0/0 kopieren
                movea.l scr2,A0
                movea.l A0,A1
                bsr     bitblt

rotier2:        move.w  ani_x4,D0
                sub.w   ani_x1,D0       ;Alte Breite berechnen
                addq.w  #1,D0
                lsr.w   #1,D0           ;halbieren
                add.w   ani_x1,D0       ;=Mittelpunkt_x

                move.w  ani_y4,D1
                sub.w   ani_y1,D1       ;Alte Hîhe berechnen
                addq.w  #1,D1
                lsr.w   #1,D1
                add.w   ani_y1,D1       ;=Mittelpunkt_y

                move.w  breite,D3       ;Neue Breite
                lsr.w   #1,D3           ;halbieren
                move.w  hîhe,D4         ;Neue Hîhe
                lsr.w   #1,D4           ;halbieren
                sub.w   D3,D0           ;linker Rand
                move.w  D0,ani_x1
                move.w  D0,objekt_x1
                sub.w   D4,D1           ;Oberer Rand
                move.w  D1,ani_y1
                move.w  D1,objekt_y1
                add.w   breite,D0       ;Rechter Rand
                subq.w  #1,D0
                move.w  D0,ani_x4
                add.w   hîhe,D1         ;Unterer Rand
                subq.w  #1,D1
                move.w  D1,ani_y4

                clr.w   objekt_x2
                clr.w   objekt_y2

                move.w  (SP)+,D0
                cmp.b   invertiert,D0   ;Wieder derselbe Invert-Status?
                beq.s   ok67            ;ja
                moveq   #4,D5
                bsr     inv_copy_btn    ;Sonst zurÅckinvertieren
ok67:           jsr     raster_ggf_an
                bra     L0437           ;und Objekt zeichnen

; Rotationsroutine:
; -----------------
; öbergabewerte:
; d0=Drehwinkel (0-359)
; d1=Breite des Sourcepics
; d2=Hîhe des Sourcepics
; d3=x1
; d4=y1
; a0=Screen1 (auf dem ist Sourcepic)
; a1=Screen2 (auf den wird gezeichnet)
; das Bild wird auf Screen2 gezeichnet
; von dort werden die Daten auch geholt.
; gibt in d0-d3 die Koord. des neuen Objektes zurÅck.
; auf Screen2 steht neues Bild.
rotate:         movem.l D0-A6,-(SP)

                move.w  vblcounter,button_klicked

                movea.l A0,A5
                movea.l A1,A6

                move.w  D3,xstart       ;Linke obere Ecke im Quellbild
                move.w  D4,ystart

                move.w  D1,D3           ;Breite
                move.w  D3,breite_alt
                lsr.w   #1,D3           ; Breite/2
                move.w  D3,breite_halb_alt
                move.w  D2,D3           ;Hîhe
                move.w  D3,hoehe_alt
                lsr.w   #1,D3           ; Hîhe/2
                move.w  D3,hoehe_halb_alt

                lea     sintab(PC),A2
                move.w  D0,D3           ;Winkel
                add.w   #90,D3          ;Winkel2 + 90 Grad
                cmp.w   #360,D3
                blt.s   nixwinkelgr360  ; Grîûer als Vollwinkel?
                sub.w   #360,D3
nixwinkelgr360: add.w   D0,D0           ; Winkel*2 wegen Words
                add.w   D3,D3
                move.w  0(A2,D0.w),sinus
                move.w  0(A2,D3.w),cosinus
                lsr.w   #1,D1           ; Breite/2
                lsr.w   #1,D2           ; Hîhe/2
                mulu    D1,D1           ; (Breite/2)^2
                mulu    D2,D2           ; (Hîhe/2)^2
                add.l   D2,D1           ; beides addieren
                move.l  D1,D0           ; nach Phythagoras
                bsr     wurzel          ; damit neuen Radius!
                move.w  D0,hoehe_halb
                add.w   D0,D0
                move.w  D0,hoehe_neu

                move.w  D0,D1
                and.w   #15,D1          ; Bits 0-3 belegt?
                beq.s   schon16erzahl
                or.w    #15,D0          ; damit nÑchste 16er Zahl!
                addq.w  #1,D0
schon16erzahl:  move.w  D0,breite_neu
                lsr.w   #1,D0           ; /2
                move.w  D0,breite_halb

                moveq   #0,D6           ; X-ZÑhler (0-Breite)
rotateloop0:    moveq   #0,D7           ; Y-ZÑhler (0-Hîhe)
rotateloop1:    move.w  D6,D3
                move.w  D7,D4
                sub.w   breite_halb(PC),D3 ; Mittelpunkt abziehen
                sub.w   hoehe_halb(PC),D4
                move.w  sinus(PC),D0
                move.w  cosinus(PC),D1

                move.w  D6,-(SP)        ;Rotation:
                move.w  D3,D5           ;x
                move.w  D4,D6           ;y
                muls    D1,D5           ;x*cos
                muls    D0,D6           ;y*sin
                sub.l   D6,D5           ;x'=x*cos-y*sin
                lsl.l   #2,D5           ;mal 4
                swap    D5
                muls    D0,D3           ;x*sin
                muls    D1,D4           ;y*cos
                add.l   D3,D4           ;y'=x*sin+y*cos
                lsl.l   #2,D4
                swap    D4
                move.w  D4,D6           ; Y
                move.w  D5,D3           ; x,y
                move.w  (SP)+,D6

                add.w   breite_halb_alt(PC),D3 ; alter Mittelpunkt
                add.w   hoehe_halb_alt(PC),D4

                tst.w   D3              ; x<0 ?
                bmi     no_plot
                tst.w   D4              ; y<0 ?
                bmi     no_plot
                cmp.w   breite_alt(PC),D3 ; x > alte Breite?
                bge     no_plot
                cmp.w   hoehe_alt(PC),D4 ; y > alte Hîhe ?
                bge.s   no_plot
                move.w  D3,D0
                move.w  D4,D1
                add.w   xstart(PC),D0   ;Linkes oberes Eck
                add.w   ystart(PC),D1
                movea.l A5,A0
                move.l  D1,-(SP)
                move.l  D2,-(SP)
                and.l   #$0000FFFF,D0   ; oberes Wort weg!
                ror.l   #4,D0
                rol.w   #3,D0
                mulu    #160,D1
                adda.w  D0,A0
                adda.w  D1,A0
                clr.w   D0
                rol.l   #4,D0           ; Rest (0-15)
                moveq   #15,D1
                sub.w   D0,D1
                moveq   #0,D0
                move.w  (A0)+,D2
                btst    D1,D2
                beq.s   nop4s
                bset    #0,D0
nop4s:          move.w  (A0)+,D2
                btst    D1,D2
                beq.s   nop3s
                bset    #1,D0
nop3s:          move.w  (A0)+,D2
                btst    D1,D2
                beq.s   nop2s
                bset    #2,D0
nop2s:          move.w  (A0)+,D2
                btst    D1,D2
                beq.s   nop1s
                bset    #3,D0
nop1s:          move.l  (SP)+,D2
                move.l  (SP)+,D1
                tst.w   D0              ;Hintergrundfarbe?
                beq.s   no_plot         ;ja, dann nicht plotten
                move.w  D0,D2           ;Farbwert fÅrs Zeichnen
                move.w  D6,D0           ;x

                add.w   #160,D0         ;Mittelpunkt
                sub.w   breite_halb(PC),D0
                move.w  D7,D1           ;y
                add.w   #100,D1
                sub.w   hoehe_halb(PC),D1
                movea.l A6,A0
                bsr.s   plot
no_plot:        addq.w  #1,D7
                cmp.w   hoehe_neu(PC),D7
                bne     rotateloop1

                tst.w   board_da
                bne.s   L04FDC

                move.w  vblcounter,D7
                sub.w   button_klicked,D7
                cmpi.w  #15,D7          ;15 VBL's abwarten
                bcs.s   L04FDC          ;Nein, weiter rotieren
                move.w  vblcounter,button_klicked
                tst.b   lupe_an         ;Ist Groûe Lupe an?
                beq.s   L04FDC          ;ja->nichts invertieren
                moveq   #4,D5           ;Button #4
                bsr     inv_copy_btn    ;Rotate-Button invertieren

L04FDC:         addq.w  #1,D6
                cmp.w   breite_neu(PC),D6
                bne     rotateloop0
rotate_ende:    move.w  #160,D0         ;Mittelpunkt
                moveq   #100,D1
                sub.w   breite_halb(PC),D0 ;linker Rand
                sub.w   hoehe_halb(PC),D1
                move.w  D0,xmin
                move.w  D1,ymin
                add.w   breite_neu(PC),D0 ;+Breite=Rechter Rand
                add.w   hoehe_neu(PC),D1
                subq.w  #1,D0
                subq.w  #1,D1
                move.w  D0,xmax
                move.w  D1,ymax

                movem.l (SP)+,D0-A6
koordzugross:   rts

plot:
; 4 Plane Plotroutine
;d0=x,d1=y,d2=farbe; a0=Screen
                cmp.w   #319,D0
                bgt.s   koordzugross
                tst.w   D0
                bmi.s   koordzugross
                tst.w   D1
                bmi.s   koordzugross
                cmp.w   #199,D1
                bgt.s   koordzugross

;               cmp.w   xmax(PC),D0
;                ble.s   nixgreaterx
;                move.w  D0,xmax
;nixgreaterx:    cmp.w   xmin(PC),D0
;                bge.s   nixlowerx
;                move.w  D0,xmin
;nixlowerx:      cmp.w   ymax(PC),D1
;                ble.s   nixgreatery
;                move.w  D1,ymax
;nixgreatery:    cmp.w   ymin(PC),D1
;                bge.s   nixlowery
;                move.w  D1,ymin
;nixlowery:


                move.w  D2,D4
                mulu    #160,D1         ;bytes / scanline
                move.w  D0,D2
                and.w   #-16,D0
                lsr.w   #1,D0           ;1 -> 4 planes  (2 -> 2 planes)
                add.w   D0,D1
                adda.w  D1,A0           ;plot-adresse
                not.w   D2
                and.w   #15,D2
                moveq   #0,D0
                bset    D2,D0
                move.w  D0,D1
                not.w   D1
                add.w   D4,D4
                move.w  D4,D2
                add.w   D4,D4
                add.w   D4,D4
                add.w   D2,D4
                jmp     plot_commands(PC,D4.w)
plot_commands:  and.w   D1,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                rts
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                rts
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                rts
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                rts
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                rts
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                rts
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                rts
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                rts
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                rts
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                rts
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                rts
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                rts
                and.w   D1,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                rts
                or.w    D0,(A0)+
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                rts
                and.w   D1,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                rts
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                or.w    D0,(A0)+
                rts

wurzel:
; zieht Wurzel aus Zahl in d0
                tst.l   D0
                beq.s   wurzelfertig    ; Wurzel aus 0=0
                cmp.l   #$00010000,D0   ; Langwort?
                bhs.s   wurzellong
                cmp.w   #625,D0
                bhi.s   wurzelwort

                move.l  D1,-(SP)
                moveq   #-1,D1
qsqrt1:         addq.w  #2,D1           ; fÅr Werte < 625
                sub.w   D1,D0
                bpl.s   qsqrt1
                asr.w   #1,D1
                move.w  D1,D0
                move.l  (SP)+,D1
wurzelfertig:   rts

wurzelwort:     movem.l D1-D4,-(SP)
                moveq   #7,D4
                moveq   #0,D1
                moveq   #0,D2
sqrt1:          add.w   D0,D0
                addx.w  D1,D1
                add.w   D0,D0
                addx.w  D1,D1
                add.w   D2,D2
                move.w  D2,D3
                add.w   D3,D3
                cmp.w   D3,D1
                bls.s   sqrt2
                addq.w  #1,D2
                addq.w  #1,D3
                sub.w   D3,D1
sqrt2:          dbra    D4,sqrt1
                move.w  D2,D0
                movem.l (SP)+,D1-D4
                rts
wurzellong:     movem.l D1-D4,-(SP)
                moveq   #13,D4
                moveq   #0,D1
                moveq   #0,D2
lsqrt1:         add.l   D0,D0
                addx.w  D1,D1
                add.l   D0,D0
                addx.w  D1,D1
                add.w   D2,D2
                move.w  D2,D3
                add.w   D3,D3
                cmp.w   D3,D1
                bls.s   lsqrt2
                addq.w  #1,D2
                addq.w  #1,D3
                sub.w   D3,D1
lsqrt2:         dbra    D4,lsqrt1
                add.l   D0,D0
                addx.w  D1,D1
                add.l   D0,D0
                addx.l  D1,D1
                add.w   D2,D2
                move.l  D2,D3
                add.w   D3,D3
                cmp.l   D3,D1
                bls.s   lsqrt3
                addq.w  #1,D2
                addq.w  #1,D3
                sub.l   D3,D1
lsqrt3:         add.l   D0,D0
                addx.l  D1,D1
                add.l   D0,D0
                addx.l  D1,D1
                add.w   D2,D2
                move.l  D2,D3
                add.l   D3,D3
                cmp.l   D3,D1
                bls.s   lsqrt4
                addq.w  #1,D2
lsqrt4:         move.w  D2,D0
                movem.l (SP)+,D1-D4
                rts

sintab:                 DC.W 0,286,572,857,1143,1428,1713,1997,2280
                        DC.W 2563,2845,3126,3406,3686,3964,4240,4516
                        DC.W 4790,5063,5334,5604,5872,6138,6402,6664
                        DC.W 6924,7182,7438,7692,7943,8192,8438,8682
                        DC.W 8923,9162,9397,9630,9860,10087,10311,10531
                        DC.W 10749,10963,11174,11381,11585,11786,11982,12176
                        DC.W 12365,12551,12733,12911,13085,13255,13421,13583
                        DC.W 13741,13894,14044,14189,14330,14466,14598,14726
                        DC.W 14849,14962,15082,15191,15296,15396,15491,15582
                        DC.W 15668,15749,15826,15897,15964,16026,16083,16135
                        DC.W 16182,16225,16262,16294,16322,16344,16362,16374
                        DC.W 16382,16384

                        DC.W 16382,16374,16362,16344,16322,16294,16262,16225
                        DC.W 16182
                        DC.W 16135,16083,16026,15964,15897,15826,15749,15668
                        DC.W 15582,15491,15396,15296,15191,15082,14962,14849
                        DC.W 14726,14598,14466,14330,14189,14044,13894,13741
                        DC.W 13583,13421,13255,13085,12911,12733,12551,12365
                        DC.W 12176,11982,11786,11585,11381,11174,10963,10749
                        DC.W 10531,10311,10087,9860,9630,9397,9162,8923
                        DC.W 8682,8438,8192,7943,7692,7438,7182,6924
                        DC.W 6664,6402,6138,5872,5604,5334,5063,4790
                        DC.W 4516,4240,3964,3686,3406,3126,2845,2563
                        DC.W 2280,1997,1713,1428,1143,857,572,286,0

                        DC.W -286,-572,-857,-1143,-1428,-1713,-1997,-2280
                        DC.W -2563,-2845,-3126,-3406,-3686,-3964,-4240,-4516
                        DC.W -4790,-5063,-5334,-5604,-5872,-6138,-6402,-6664
                        DC.W -6924,-7182,-7438,-7692,-7943,-8192,-8438,-8682
                        DC.W -8923,-9162,-9397,-9630,-9860,-10087,-10311,-10531
                        DC.W -10749,-10963,-11174,-11381,-11585,-11786,-11982
                        DC.W -12176
                        DC.W -12365,-12551,-12733,-12911,-13085,-13255,-13421
                        DC.W -13583
                        DC.W -13741,-13894,-14044,-14189,-14330,-14466,-14598
                        DC.W -14726
                        DC.W -14849,-14962,-15082,-15191,-15296,-15396,-15491
                        DC.W -15582
                        DC.W -15668,-15749,-15826,-15897,-15964,-16026,-16083
                        DC.W -16135
                        DC.W -16182,-16225,-16262,-16294,-16322,-16344,-16362
                        DC.W -16374,-16382,-16384

                        DC.W -16382,-16374,-16362,-16344,-16322,-16294,-16262
                        DC.W -16225,-16182
                        DC.W -16135,-16083,-16026,-15964,-15897,-15826,-15749
                        DC.W -15668
                        DC.W -15582,-15491,-15396,-15296,-15191,-15082,-14962
                        DC.W -14849
                        DC.W -14726,-14598,-14466,-14330,-14189,-14044,-13894
                        DC.W -13741
                        DC.W -13583,-13421,-13255,-13085,-12911,-12733,-12551
                        DC.W -12365
                        DC.W -12176,-11982,-11786,-11585,-11381,-11174,-10963
                        DC.W -10749
                        DC.W -10531,-10311,-10087,-9860,-9630,-9397,-9162,-8923
                        DC.W -8682,-8438,-8192,-7943,-7692,-7438,-7182,-6924
                        DC.W -6664,-6402,-6138,-5872,-5604,-5334,-5063,-4790
                        DC.W -4516,-4240,-3964,-3686,-3406,-3126,-2845,-2563
                        DC.W -2280,-1997,-1713,-1428,-1143,-857,-572,-286,0

xmax:                   DS.W 1
xmin:                   DS.W 1
ymax:                   DS.W 1
ymin:                   DS.W 1
xstart:                 DS.W 1
ystart:                 DS.W 1
sinus:                  DS.W 1
cosinus:                DS.W 1
breite_neu:             DS.W 1
hoehe_neu:              DS.W 1
breite_halb:            DS.W 1
hoehe_halb:             DS.W 1
breite_alt:             DS.W 1
hoehe_alt:              DS.W 1
breite_halb_alt:        DS.W 1
hoehe_halb_alt:         DS.W 1

;Alte NEOchrome Rotierfunktion (90¯):
old_rotate:     cmpi.w  #93,rotate_richtung ;Links rum?
                beq.s   rotier_90_grad
                bsr.s   rotier_90       ;Sonst 3 mal drehen
                bsr.s   rotier_90
rotier_90_grad: bsr.s   rotier_90
                bra     draw_copybox

rotier_90:      movea.l objekt_pointer,A0 ;Pointer auf das Objekt(?)
                movea.l scr2,A1         ;Hier wird Objekt aufgebaut
                move.w  objekt_x2,D0    ;Koordinaten des Objektes
                move.w  objekt_y2,D1    ;-'-
                move.w  breite_bytes,D4
                mulu    D4,D1
                adda.l  D1,A0
                movea.w D4,A2
                move.w  D0,D1
                lsr.w   #4,D1
                lsl.w   #3,D1           ;Adresse des BB's berechnen
                adda.w  D1,A0
                andi.w  #$000F,D0
                move.w  #160,D1
                move.w  breite,D2       ;Breite des Objektes
                move.w  D2,D5
                move.w  hîhe,D3         ;Hîhe des Objekts
                move.w  D3,D6
                cmp.w   board_y,D2
                ble.s   L0454
                add.w   #$000F,D6
                lsr.w   #1,D6
                andi.w  #%1111111111111000,D6
                move.w  D6,D1
                move.w  D3,D6
L0454:          move.w  D3,breite       ;Alte Hîhe wird Breite
                movea.w D1,A3
                move.l  #$00008C00,D7
                tst.b   less_memory
                bne.s   L0455
                lsr.w   #1,D7
L0455:          divu    D1,D7
                cmp.w   D2,D7
                bcc.s   L0456
                move.w  D7,D2
L0456:          move.w  D2,hîhe
                lsr.w   #1,D5           ;Breite halbieren
                move.w  ani_x1,D7
                add.w   D5,D7           ;=Mittelpunkt x
                move.w  D3,D5
                lsr.w   #1,D5           ;Hîhe halbieren
                sub.w   D5,D7
                cmpi.w  #319,D7
                ble.s   L0457
                move.w  #319,D7
L0457:          move.w  D7,D5
                add.w   D3,D5
                subq.w  #1,D5
                bpl.s   L0458
                sub.w   D5,D7
                move.w  D7,D5
                add.w   D3,D5
                subq.w  #1,D5
L0458:          move.w  D7,ani_x1
                move.w  D7,objekt_x1
                move.w  D5,ani_x4
                lsr.w   #1,D6
                move.w  ani_y1,D7
                add.w   D6,D7
                move.w  D2,D5
                lsr.w   #1,D5
                sub.w   D5,D7
                cmp.w   board_y,D7
                blt.s   L0459
                move.w  board_y,D7
                subq.w  #1,D7
L0459:          move.w  D7,D5
                add.w   D2,D5
                subq.w  #1,D5
                bpl.s   L045A
                sub.w   D5,D7
                move.w  D7,D5
                add.w   D2,D5
                subq.w  #1,D5
L045A:          move.w  D7,ani_y1
                move.w  D7,objekt_y1
                move.w  D5,ani_y4
                clr.w   objekt_x2
                clr.w   objekt_y2
                move.w  A3,D4
                lsr.w   #3,D4
                mulu    D2,D4
                moveq   #0,D5
                bra.s   L045C
L045B:          move.l  D5,(A1)+
                move.l  D5,(A1)+
L045C:          dbra    D4,L045B
                suba.w  A3,A1
                move.w  #%1000000000000000,D1
                bra.s   L0466
L045D:          movem.l A0-A1,-(SP)
                move.w  (A0)+,D4
                move.w  (A0)+,D5
                move.w  (A0)+,D6        ;Einen BB holen
                move.w  (A0)+,D7
                tst.w   D0
                beq.s   L045E
                lsl.w   D0,D4
                lsl.w   D0,D5
                lsl.w   D0,D6
                lsl.w   D0,D7
L045E:          movea.w #$000F,A4
                suba.w  D0,A4
                swap    D0
                move.w  A4,D0
L045F:          add.w   D4,D4
                bcc.s   L0460
                or.w    D1,(A1)
L0460:          add.w   D5,D5
                bcc.s   L0461
                or.w    D1,2(A1)
L0461:          add.w   D6,D6
                bcc.s   L0462
                or.w    D1,4(A1)
L0462:          add.w   D7,D7
                bcc.s   L0463
                or.w    D1,6(A1)
L0463:          suba.w  A3,A1
                subq.w  #1,D2
                beq.s   L0464
                dbra    D0,L045F
                move.w  (A0)+,D4
                move.w  (A0)+,D5
                move.w  (A0)+,D6
                move.w  (A0)+,D7
                move.w  #$000F,D0
                bra.s   L045F
L0464:          movem.l (SP)+,A0-A1
                move.w  hîhe,D2
                swap    D0
                ror.w   #1,D1
                bcc.s   L0465
                addq.l  #8,A1
L0465:          adda.w  A2,A0
L0466:          dbra    D3,L045D
                move.w  A3,breite_bytes
                bra     put_copybox_back

;Da ein Branch auf Save_error teilweise zu groû ist, ist ein StÅtzpunkt
;zum anspringen
save_error_far2:jmp     save_error

;Kopiert einen 32000 Bytes groûen Speicherbereich von a0 nach a1
copy_screen:    movem.l D0/A0-A1,-(SP)

                move.w  #1999,D0
copy_loop:      move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,copy_loop

                movem.l (SP)+,D0/A0-A1
                rts

;Lîscht einen 32000 Bytes groûen Speicherbereich ab A1
cls:            movem.l D0-D1/A1,-(SP)

                moveq   #0,D1
                move.w  #7999,D0
clear_loop:     move.l  D1,(A1)+
                dbra    D0,clear_loop

                movem.l (SP)+,D0-D1/A1
                rts


copy_hflip:     movem.l D0-A3,-(SP)
                bsr     scr12scr2
                movea.l objekt_pointer,A0
                movea.l scr2,A1
                movea.w breite_bytes,A2
                movea.l A2,A3
                move.w  objekt_x2,D0
                move.w  breite,D2
                move.w  D0,D1
                add.w   D2,D1
                subq.w  #1,D1
                not.w   D1
                and.w   #$000F,D1
                move.w  D1,objekt_x2
                move.w  objekt_y2,D1
                move.w  hîhe,D3
                bsr     L05A4
                movem.l (SP)+,D0-A3
                clr.w   objekt_y2
                bsr     L0437
                rts
copy_vflip:     movem.l D0-A3,-(SP)
                bsr     scr12scr2
                movea.l objekt_pointer,A0
                movea.l scr2,A1
                movea.w breite_bytes,A2
                movea.l A2,A3
                move.w  objekt_x2,D0
                move.w  D0,D1
                andi.w  #$000F,D1
                move.w  D1,objekt_x2
                move.w  objekt_y2,D1
                move.w  breite,D2
                move.w  hîhe,D3
                bsr     L05A0
                movem.l (SP)+,D0-A3
                clr.w   objekt_y2
                bsr     L0437
                rts
copy_tedge:     movea.l scr2,A0
                movea.l A0,A1
                moveq   #0,D7
                move.w  #$03E7,D6
L046A:          move.l  D7,(A0)+
                move.l  D7,(A0)+
                move.l  D7,(A0)+
                move.l  D7,(A0)+
                dbra    D6,L046A
                movea.l objekt_pointer,A0
                move.w  objekt_x2,D0
                move.w  objekt_y2,D1
                move.w  hîhe,D2
                move.w  breite,D3
                add.w   D0,D3
                subq.w  #1,D3
                lsr.w   #4,D3
                move.w  D0,D4
                lsr.w   #4,D4
                sub.w   D4,D3
                move.w  breite_bytes,D4
                mulu    D4,D1
                adda.w  D1,A0
                lsr.w   #1,D0
                andi.w  #-8,D0
                adda.w  D0,A0
                move.w  D3,D1
                addq.w  #3,D1
                add.w   D1,D1
                adda.w  D1,A1
                adda.w  D1,A1
                addq.l  #2,A1
                moveq   #0,D0
                movea.l A0,A2
                movea.l A1,A3
                move.w  D2,D5
                btst    D0,zeichenfarbe+1
                beq.s   L0470
                bra.s   L046D
L046B:          movea.l A2,A4
                movea.l A3,A5
                move.w  D3,D6
L046C:          move.w  (A4),(A5)+
                addq.l  #8,A4
                dbra    D6,L046C
                adda.w  D4,A2
                adda.w  D1,A3
L046D:          dbra    D5,L046B
                bra.s   L0478
L046E:          movea.l A2,A4
                movea.l A3,A5
                move.w  D3,D6
L046F:          move.w  (A4),D7
                not.w   D7
                move.w  D7,(A5)+
                addq.l  #8,A4
                dbra    D6,L046F
                adda.w  D4,A2
                adda.w  D1,A3
L0470:          dbra    D5,L046E
L0471:          movea.l A0,A2
                movea.l A1,A3
                move.w  D2,D5
                btst    D0,zeichenfarbe+1
                beq.s   L0477
                bra.s   L0474
L0472:          movea.l A2,A4
                movea.l A3,A5
                move.w  D3,D6
L0473:          move.w  (A4),D7
                and.w   D7,(A5)+
                addq.l  #8,A4
                dbra    D6,L0473
                adda.w  D4,A2
                adda.w  D1,A3
L0474:          dbra    D5,L0472
                bra.s   L0478
L0475:          movea.l A2,A4
                movea.l A3,A5
                move.w  D3,D6
L0476:          move.w  (A4),D7
                not.w   D7
                and.w   D7,(A5)+
                addq.l  #8,A4
                dbra    D6,L0476
                adda.w  D4,A2
                adda.w  D1,A3
L0477:          dbra    D5,L0475
L0478:          addq.w  #1,D0
                addq.l  #2,A0
                cmpi.w  #4,D0
                bcs.s   L0471
                move.w  objekt_x2,D4
                move.w  D4,D5
                add.w   breite,D5
                lea     L029A(PC),A2
                not.w   D4
                andi.w  #$000F,D4
                not.w   D5
                andi.w  #$000F,D5
                add.w   D4,D4
                add.w   D5,D5
                move.w  2(A2,D4.w),D4
                move.w  2(A2,D5.w),D5
                not.w   D5
                add.w   D3,D3
                movem.w D1-D2,-(SP)
                bra.s   L047A
L0479:          movea.l A1,A2
                and.w   D4,(A2)
                adda.w  D3,A2
                and.w   D5,(A2)
                adda.w  D1,A1
L047A:          dbra    D2,L0479
                bsr     L0487
                lea     bitblit,A6
                move.w  breite,0(A6)
                move.w  hîhe,2(A6)
                move.l  scr2,18(A6)
                move.l  irgend_copy,32(A6)
                move.w  objekt_x2,D7
                move.w  D7,28(A6)
                andi.w  #$000F,D7
                addi.w  #$0010,D7
                move.w  D7,14(A6)
                move.w  objekt_y2,D7
                move.w  D7,30(A6)
                move.w  #2,16(A6)
                move.w  #2,22(A6)
                move.w  D1,24(A6)
                move.w  #0,26(A6)
                move.w  #8,36(A6)
                move.w  breite_bytes,38(A6)
                move.w  #2,40(A6)
                move.w  #4,4(A6)
                move.l  #$04040404,10(A6)
                linea   #7 [ Bitblk ]
                movem.w (SP)+,D1-D2
                movea.l scr2,A0
                move.w  D2,D6
                addq.w  #2,D6
                move.w  D1,D7
                movea.w D7,A3
                bsr.s   L047C
                lea     bitblit,A6
                move.w  #4,4(A6)
                move.w  zeichenfarbe,6(A6)
                clr.w   8(A6)
                move.l  #$04040707,10(A6)
                linea   #7 [ Bitblk ]
                movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #$03E7,D2
L047B:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D2,L047B
                bsr     draw_copybox
                rts
L047C:          lea     0(A0,D7.w),A1
                lea     0(A1,D7.w),A2
                lsr.w   #1,D7
                subq.w  #1,D7
                bra.s   L047F
L047D:          movem.l D6-A2,-(SP)
                moveq   #0,D5
                moveq   #0,D6
                move.l  (A2),D1
                lsr.l   #1,D1
L047E:          move.l  (A0),D0
                move.b  D5,D0
                ror.l   #1,D0
                move.l  (A1),D2
                move.b  D6,D2
                move.l  D2,D3
                ror.l   #1,D3
                move.l  D3,D4
                ror.l   #1,D4
                move.l  D0,D5
                move.l  D0,D6
                eor.l   D2,D0
                eor.l   D3,D5
                eor.l   D4,D6
                rol.l   #1,D5
                rol.l   #2,D6
                or.l    D5,D0
                or.l    D6,D0
                move.l  D1,D5
                move.l  D1,D6
                eor.l   D2,D1
                eor.l   D3,D5
                eor.l   D4,D6
                rol.l   #1,D5
                rol.l   #2,D6
                or.l    D1,D0
                or.l    D5,D0
                or.l    D6,D0
                eor.l   D3,D2
                eor.l   D3,D4
                rol.l   #2,D4
                or.l    D2,D0
                or.l    D4,D0
                swap    D0
                move.w  (A1),D6
                move.w  D6,D5
                eor.w   D0,D5
                and.w   D0,D5
                addq.l  #2,A2
                move.l  (A2),D1
                move.b  -1(A2),D1
                ror.l   #1,D1
                move.w  D5,(A1)+
                move.w  (A0),D5
                move.w  D6,(A0)+
                dbra    D7,L047E
                movem.l (SP)+,D6-A2
                movea.l A2,A1
                adda.l  A3,A2
                cmpi.w  #1,D6
                bne.s   L047F
                movea.l A1,A2
L047F:          dbra    D6,L047D
                rts
copy_swapcol:   lea     L0482(PC),A0
                move.w  #$000F,D1
L0481:          move.b  D1,0(A0,D1.w)
                dbra    D1,L0481
                move.w  left_col_mark,D1
                move.w  right_col_mark,D2
                move.w  zeichenfarbe,D3
                cmp.w   D3,D1
                beq.s   L0484
                cmp.w   D3,D2
                bne.s   L0483
                move.b  D2,0(A0,D1.w)
                bra.s   L0485

L0482:                  DC.B $00,$01,$02,$03,$04,$05,$06,$07
                        DC.B $08,$09,$0A,$0B,$0C,$0D,$0E,$0F

L0483:          move.b  D2,0(A0,D1.w)
L0484:          move.b  D1,0(A0,D2.w)
L0485:          btst    #0,copy_status
                bne.s   L0486
                move.b  function,D1
                clr.b   function
                clr.b   L076B
                jsr     put_work_back
                move.b  D1,function
                bra.s   L048A
L0486:          bsr.s   L0487
                move.w  objekt_x2,D2
                move.w  objekt_y2,D3
                movea.w hîhe,A2
                move.w  breite,D0
                bra.s   L048C
L0487:          movea.l objekt_pointer,A1
                movea.l irgend_copy,A2
                cmpa.l  A2,A1
                beq.s   L0489
                move.w  #$03E7,D2
                tst.b   less_memory
                beq.s   L0488
                move.w  #$07CF,D2
L0488:          move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                dbra    D2,L0488
                movea.l irgend_copy,A1
                move.l  A1,objekt_pointer
L0489:          rts
L048A:          movea.l scr1,A1
                clr.w   D2
                clr.w   D3
                movea.w #$00C8,A2
                tst.w   board_da
                bne.s   L048B
                movea.w #$0064,A2
L048B:          move.w  #$0140,D0
                move.w  #160,breite_bytes
L048C:          bsr     L05A9
                btst    #0,copy_status
                beq.s   L048E
                movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #$03E7,D2
                tst.w   board_da
                beq.s   L048D
                move.w  #$07CF,D2
L048D:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D2,L048D
                bsr     draw_copybox
L048E:          rts

;Kopiert den gesamten Screen1 -> Screen2 und zeigt in an
scr12scr2:      movem.l D0/A0-A1,-(SP)
                movea.l scr1,A0
                movea.l scr2,A1
                cmpa.l  A0,A1
                bgt.s   L0491
                move.w  #1999,D0
L0490:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0490
                jsr     switch_screens
L0491:          movem.l (SP)+,D0/A0-A1
                rts

clear_logo:     tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   raus1           ;ja->RTS
                tst.w   logo_typ        ;Logo Åberhaupt da?
                beq.s   raus1           ;Nein
                movem.l D5-A0,-(SP)
                moveq   #30,D7          ;Kleines Logo
                cmpi.w  #2,logo_typ     ;Kleines Logo?
                beq.s   L0494           ;dann weglîschen
                moveq   #69,D7          ;Sonst groûes Logo lîschen
                bra.s   L0494

clear_options:  movem.l D5-A0,-(SP)
                move.w  #$0045,D7
L0494:          clr.w   logo_typ        ;Jetzt ist kein Logo mehr da!
                movea.l scr1,A0
                lea     $51A0(A0),A0
                moveq   #0,D5
L0495:          move.w  #7,D6
L0496:          move.l  D5,(A0)+
                move.l  D5,(A0)+
                dbra    D6,L0496
                lea     $0060(A0),A0
                dbra    D7,L0495
                movem.l (SP)+,D5-A0
raus1:          rts

;Zeichnet die Options der momentan aktiven Funktion neu (CHS):
draw_options:   tst.w   board_da        ;öberhaupt ein Board da?
                bne.s   raus1
                tst.b   lupe_an         ;Ist die groûe Lupe an?
                beq.s   raus1           ;ja, nichts zeichnen
                cmpi.b  #13,function    ;Draw?
                beq     draw_ggf_user1
                cmpi.b  #14,function    ;Eraser?
                beq     draw_ggf_user2
draw_options2:  bsr.s   clear_options
                move.b  function,D5
                ext.w   D5
                mulu    #$000A,D5       ;Jeder Eintrag hat 10 Bytes
                lea     L0499(PC),A4    ;Pointer auf Tabelle
                adda.l  D5,A4
                cmpi.b  #9,function     ;Brush/Nozzle?
                bne.s   zeichne_sie
                tst.w   brush
                beq.s   zeichne_sie
                lea     nozzle_akt,A4   ;Sonst Nozzle Options
zeichne_sie:    bsr     write_options   ;und Options auf Screen
                move.b  function,D5
                ext.w   D5
                add.w   D5,D5
                lea     L04B2(PC),A0    ;Sprungtabelle zum neuzeichnen aufrufen
                adda.w  L0498(PC,D5.w),A0
                jmp     (A0)

L0498:                  DC.W aft_jack-L04B2
                        DC.W aft_grab-L04B2
                        DC.W aft_copy-L04B2
                        DC.W aft_text-L04B2
                        DC.W aft_pen-L04B2
                        DC.W aft_line-L04B2
                        DC.W aft_and-L04B2
                        DC.W aft_cut-L04B2
                        DC.W aft_raster-L04B2
                        DC.W aft_brush-L04B2
                        DC.W set_eraser-L04B2 ;Disk
                        DC.W aft_camera-L04B2
                        DC.W aft_box-L04B2
                        DC.W set_eraser-L04B2
                        DC.W aft_nozzle-L04B2
                        DC.W aft_copyr-L04B2

;Tabelle, die Offsets fÅr opt_aussehen enthÑlt:
;Format:
;0(a6): Offset zu den Fill-Box Werten
;2(a6): Offset zu den Rahmen Werten
;4(a6): Offset zun den Textkoordianten
;6(a6): Offset zum Text
;8(a6): Offset zu den Icons
L0499:
;Jack-Knife:
                        DC.W misc_fill-opt ;fill-box
                        DC.W jack_rahm-opt ;Rahmen
                        DC.W jack_strk-opt ;Textkoord
                        DC.W jack_str-opt ;Text
                        DC.W jack_icon-opt ;Icons

;Grabber:
                        DC.W misc_fill-opt ;Fill-Box
                        DC.W grab_rahm-opt ;Rahmen
                        DC.W grab_strk-opt ;Textkoord
                        DC.W grab_str-opt ;Text
                        DC.W 0  ;Icons

;Copybox:
                        DC.W copy_fill-opt ;Fillbox
                        DC.W copy_rahmen-opt
                        DC.W copy_strk-opt ;Textkoord
                        DC.W copy_str-opt
                        DC.W copy_icon-opt

;Text:
                        DC.W text_fill-opt
                        DC.W text_rahm-opt
                        DC.W text_strk-opt
                        DC.W $05BF
                        DC.W $02B8

;Pencil:
                        DC.W misc_fill-opt
                        DC.W 0
                        DC.W $0056
                        DC.W $06E5
                        DC.W 0

;Line:
                        DC.W line_fill-opt
                        DC.W line_rahmen-opt
                        DC.W line_strk-opt
                        DC.W line_str-opt
                        DC.W line_icon-opt

;Fill:
                        DC.W misc_fill-opt
                        DC.W misc_rahmen-opt
                        DC.W misc_strk-opt
                        DC.W misc_str-opt
                        DC.W 0

;Cutter:
                        DC.W cut_fill-opt
                        DC.W cut_rahmen-opt
                        DC.W cut_strk-opt
                        DC.W cut_str-opt
                        DC.W cut_icon-opt

;Miscall (&):
                        DC.W raster_fill-opt
                        DC.W raster_rahm-opt
                        DC.W raster_strk-opt
                        DC.W raster_str-opt
                        DC.W raster_icon-opt

;Brush:
                        DC.W brush_fill-opt
                        DC.W brush_rahmen-opt
                        DC.W brush_strk-opt
                        DC.W brush_str-opt
                        DC.W brush_icon-opt

;Disc:
                        DC.W disk_fill-opt
                        DC.W disk_rahm-opt
                        DC.W disk_strk-opt
                        DC.W disk_str-opt
                        DC.W disk_icon-opt

;Camera:
                        DC.W camera_fill-opt
                        DC.W camera_rahm-opt
                        DC.W camera_strk-opt
                        DC.W camera_str-opt
                        DC.W camera_icon-opt

;Boxes:
                        DC.W $0068
                        DC.W $00E4
                        DC.W $0056
                        DC.W $0742
                        DC.W box_icons-opt

;Eraser:
                        DC.W misc_fill-opt
                        DC.W $0000
                        DC.W $0056
                        DC.W $0736
                        DC.W $0000

;Nozzles:
nozzle_akt:             DC.W $03EE
                        DC.W $03E4
                        DC.W $03F8
                        DC.W $06C9
                        DC.W $02CC

;Copyright:
                        DC.W 0
                        DC.W 0  ;Rahmen
                        DC.W davek-opt ;Textk
                        DC.W dave-opt ;Text
                        DC.W 0

;Smoke und Mirrors by...
L049A:                  DC.W 0
                        DC.W 0
                        DC.W smokek-opt ;Textk
                        DC.W smoke-opt ;Text
                        DC.W 0



;Zeichnet die komplette Optionbox auf Screen
;Parameter:
;A4: Pointer auf Eintrag in L0499 (^^)
write_options:  movem.l D0-A1,-(SP)
                lea     opt(PC),A0
                adda.w  0(A4),A0        ;Offset in Tabelle
                moveq   #$0F,D4         ;Farbe
                moveq   #1,D5           ;Schreibmodus
L049C:          move.w  (A0)+,D0        ;x1
                bmi.s   L049D
                move.w  (A0)+,D1        ;y1
                move.w  (A0)+,D2        ;x2
                move.w  (A0)+,D3        ;y2
                bsr     fill_box
                bra.s   L049C
L049D:          moveq   #0,D5
                moveq   #-1,D6
                lea     opt(PC),A0
                adda.w  2(A4),A0        ;Offset zum Rahmen
L049E:          move.w  (A0)+,D0
                bmi.s   L049F
                move.w  (A0)+,D1
                move.w  (A0)+,D2        ;Koordinaten holen
                move.w  (A0)+,D3
                bsr     rahmen
                bra.s   L049E
L049F:          move.w  #6,L0818
                move.w  #1,L0819
                lea     opt(PC),A0
                movea.l A0,A3
                adda.w  4(A4),A3
                adda.w  6(A4),A0        ;Offset zum Text
L04A0:          move.w  (A3)+,D2        ;Farbe
                bmi.s   L04A1
                move.w  (A3)+,D0        ;x
                move.w  (A3)+,D1        ;y
                bsr     print6x6_inv
                bra.s   L04A0
L04A1:          lea     opt(PC),A0
                adda.w  8(A4),A0
L04A2:          move.w  #$000F,D3       ;Farbe
L04A3:          move.w  (A0)+,D2        ;Iconnummer
                bmi.s   L04A4
                move.w  (A0)+,D0        ;x
                move.w  (A0)+,D1        ;y
                addq.w  #1,D0
                addq.w  #1,D1
                bsr     draw_icon
                bra.s   L04A3
L04A4:          movem.l (SP)+,D0-A1
                rts

;Zeichnet bei den Options der Box die Boxtypen icons neu:
draw_boxen:     movem.l D0-A1,-(SP)
                lea     boxicons(PC),A0
                bra.s   L04A2

;Zeichnet die Copybox Funktionstasten und Winkel neu (CHS)
redraw_copy_opt:tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   L04AA           ;ja->RTS
                tst.w   board_da
                bne.s   L04AA           ;Nein->RTS
                movem.l D0-A3,-(SP)
                movea.l scr1,A0
                lea     22656(A0),A0
                moveq   #0,D0
                move.l  #%11111111000000001111111100000000,D3
                moveq   #47,D1
L04A7:          and.l   D3,(A0)+
                and.l   D3,(A0)+
                move.l  D0,(A0)+        ;Optionbox lîschen...
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                lea     120(A0),A0      ;nÑchste Zeile
                dbra    D1,L04A7
                lea     L0575(PC),A3
                lea     L058A(PC),A0    ;Bei Copybox sind's 8
                tst.b   function        ;Jack Knife?
                bne.s   L04A8           ;Nein...
                lea     L0572(PC),A3
                lea     L058D(PC),A0    ;nur 4 Funktionen mîglich
L04A8:          move.w  (A3)+,D2
                bmi.s   L04A9
                move.w  (A3)+,D0
                move.w  (A3)+,D1
                bsr     print6x6
                bra.s   L04A8
L04A9:          bsr     copy_board
                movem.l (SP)+,D0-A3
L04AA:          rts

                        IF 1=2  ;Camera-Routine
L04AB:          movem.l D0-A3,-(SP)
                lea     L057F,A3
                lea     L058F,A0
L04AC:          move.w  (A3)+,D2
                bmi.s   L04AD
                move.w  (A3)+,D0
                move.w  (A3)+,D1
                bsr     print6x6
                bra.s   L04AC
L04AD:          bsr     copy_board
                movem.l (SP)+,D0-A3
                rts
                        ENDC

redraw_cut_opt: tst.w   board_da        ;öberhaupt ein Board da?
                bne.s   no_redraw1
                tst.b   lupe_an
                beq.s   no_redraw1

                movem.l D0-A6,-(SP)

                lea     cut_rplck(PC),A3 ;Koordinaten
                lea     cut_rplc(PC),A0 ;Text
                moveq   #3,D7           ;4 Buttons neu zeichnen
redr2:          move.w  (A3)+,D2        ;Status holen
                move.w  (A3)+,D0        ;Koordinaten holen
                move.w  (A3)+,D1
                bsr     print6x6        ;und anzeigen
                dbra    D7,redr2

                movem.l (SP)+,D0-A6     ;Nicht verÑndern!
no_redraw1:     rts

print_load:     movem.l D0-A3,-(SP)
                lea     L057D(PC),A3
                lea     L058E(PC),A0    ;Load/Save der Camera neu printen
                move.w  (A3)+,D2        ;Farbe holen
                move.w  (A3)+,D0        ;Koordinaten holen
                move.w  (A3)+,D1
                bsr     print6x6
                move.w  (A3)+,D2        ;Farbe holen
                move.w  (A3)+,D0        ;Koordinaten holen
                move.w  (A3)+,D1
                bsr     print6x6
                bsr     copy_board
                movem.l (SP)+,D0-A3
                rts

L04AF:          movem.l D0-A3,-(SP)
                lea     L057B(PC),A3
                lea     L058B(PC),A0    ;System
L04B0:          move.w  (A3)+,D2
                bmi.s   L04B1
                move.w  (A3)+,D0
                move.w  (A3)+,D1
                bsr     print6x6
                bra.s   L04B0
L04B1:          movem.l (SP)+,D0-A3
                rts

;Sprungtabelle zum Initialisieren der Options, wird nach Zeichnen aufgerufen
L04B2:
aft_grab:
aft_pen:
aft_fill:
aft_disk:
aft_copyr:
aft_raster:
                rts

aft_cut:        bra     draw_r          ;öberprÅft, ob aktuelles Objekt mit Raster

aft_text:       movem.l D0-A1,-(SP)
                bsr     show_align
                bsr     show_style
                bsr     show_height
                bsr     init_text
                movem.l (SP)+,D0-A1
                rts

aft_brush:      movem.l D0-A1,-(SP)
                tst.w   brush
                beq.s   aft_brush2
                bsr     rahm_nozzle
                bsr     set_nozzle
                bra.s   hj
aft_brush2:     bsr     rahm_brush
                bsr     set_brush
hj:             movem.l (SP)+,D0-A1
                rts

aft_nozzle:     movem.l D0-A1,-(SP)
                bsr     rahm_nozzle
                bsr     set_nozzle
                movem.l (SP)+,D0-A1
                rts

aft_box:        movem.l D0-A1,-(SP)
                bsr     draw_hÑkchen    ;Neuen Haken zeichnen
                bsr     L055F
                bsr     inv_akt_boxtyp
                movem.l (SP)+,D0-A1
                rts

aft_line:       movem.l D0-A1,-(SP)
                bsr     show_line_haken
                bsr     show_line_editor
                movem.l (SP)+,D0-A1
                rts

aft_copy:       movem.l D0-A1,-(SP)
                bsr     L04BA
                tst.b   no_resize
                beq.s   L04B3
                bsr.s   resize_an
L04B3:          movem.l (SP)+,D0-A1
                rts

aft_jack:       movem.l D0-A1,-(SP)
                bsr.s   change_jack_mode
                movem.l (SP)+,D0-A1
                rts

resize_an:      tst.w   board_da
                bne.s   L04B5
                tst.b   lupe_an         ;Ist groûe Lupe an?
                beq.s   L04B5
                lea     L0579(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #$0F,D3
                bsr     draw_func_inv
                bsr     copy_board
L04B5:          move.b  #-1,no_resize
                rts

resize_aus:     clr.b   no_resize
                tst.w   board_da
                bne.s   L04B7
                tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   L04B7
                movem.l D0-D3/A0,-(SP)
                lea     L0579(PC),A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #15,D3
                bsr     draw_func
                bsr     copy_board
                movem.l (SP)+,D0-D3/A0
L04B7:          rts


change_jack_mode:move.w jack_mode,D1
                moveq   #2,D2
                moveq   #$0F,D3
                cmpi.w  #1,D1           ;3D?
                bne.s   L04B9           ;Nein
                move.w  #302,D0
                move.w  #283,D4
                move.w  #156,D1
                bsr     del_icon        ;oberen beiden aus
                exg     D0,D4
                bsr     del_icon
                move.w  #292,D0
                move.w  #186,D1         ;3D Icon an
                bsr     draw_icon
                rts

L04B9:          move.w  D1,-(SP)
                move.w  #292,D0         ;3D-Icon aus
                move.w  #186,D1
                bsr     del_icon
                move.w  (SP)+,D1
                bra.s   L04BB
L04BA:          move.w  copy_mode,D1
L04BB:          move.w  #283,D0
                move.w  #302,D4         ;welches Icon an, welches aus?
                tst.w   D1
                bpl.s   L04BC
                exg     D0,D4
L04BC:          move.w  #$009C,D1
                move.w  #2,D2
                move.w  #$000F,D3
                bsr     draw_icon
                exg     D0,D4
                bsr     del_icon
                rts

;Zeichnet einen Haken unter Box_filled oder unter nicht gefÅllt...
draw_hÑkchen:   move.w  #275,D0
                move.w  #298,D4
                tst.w   just_rahmen
                bpl.s   L04BE
                exg     D0,D4
L04BE:          move.w  #192,D1
                moveq   #2,D2
                moveq   #15,D3
                bsr     draw_icon       ;Neuen Haken hinzeichnen
                exg     D0,D4
                bsr     del_icon        ;Alten Haken wegmachen
                jmp     L0138

L04BF:          moveq   #-1,D4
                bra.s   L04C1
inv_akt_boxtyp: moveq   #0,D4
L04C1:          movem.l D0-D3/A0,-(SP)
                move.w  box_typ,D3
                mulu    #6,D3
                lea     boxicons(PC),A0
                adda.w  D3,A0
                move.w  (A0)+,D2
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                addq.w  #1,D0
                addq.w  #1,D1
                moveq   #$0F,D3
                tst.w   D4
                beq.s   L04C2
                bsr     draw_icon
                bra.s   L04C3
L04C2:          bsr     draw_icon_inv
L04C3:          movem.l (SP)+,D0-D3/A0
                rts


aft_camera:     rts

set_eraser:     movem.l D0-D2/A0-A1,-(SP)
                moveq   #$42,D1         ;Iconnummer des Erasers
                bra.s   L04C8

;Berechnet akt_brush fÅr den aktiven Brush
set_nozzle:     movem.l D0-D2/A0-A1,-(SP)
                move.w  akt_nozzle,D1
                bra.s   L04C7

set_brush:      movem.l D0-D2/A0-A1,-(SP)
                move.w  akt_brush,D1
L04C7:          add.w   #$001A,D1
L04C8:          add.w   D1,D1
                lea     icons_offset,A0 ;aus Icon den Sprite aufbauen
                move.w  0(A0,D1.w),D1
                lea     icons,A0
                adda.w  D1,A0
                move.l  A0,akt_shape
                lea     shape_buff,A1
                move.w  (A0)+,D1
                lsr.w   #1,D1
                move.w  D1,(A1)+
                move.w  (A0)+,D1
                move.w  D1,D0
                lsr.w   #1,D0
                move.w  D0,(A1)+
                addq.l  #6,A1
                moveq   #$0F,D0
                moveq   #0,D2
L04C9:          subq.w  #1,D1
                bmi.s   L04CA
                move.w  (A0),32(A1)     ;Mouseform in Spriteform umrechnen
                move.w  (A0)+,(A1)+
                dbra    D0,L04C9
                bra.s   L04CB
L04CA:          move.w  D2,32(A1)
                move.w  D2,(A1)+
                dbra    D0,L04CA
L04CB:          movem.l (SP)+,D0-D2/A0-A1
                rts

;Zeichnet Rahmen um aktuelle Nozzle/Brush
rahm_nozzle:    move.w  akt_nozzle,D1
                bra.s   L04CE
rahm_brush:     move.w  akt_brush,D1
L04CE:          ext.l   D1
                divu    #5,D1
                move.w  D1,D0
                swap    D1
                mulu    #$000D,D0
                add.w   #200,D0
                cmpi.w  #291,D0
                bne.s   L04D1
                add.w   D1,D1
                move.w  #$0137,D2
                move.w  L04D0(PC,D1.w),D3
                move.w  L04CF(PC,D1.w),D1
                bra.s   L04D2

L04CF:                  DC.B 0,141
L04D0:                  DC.B 0,162,0,179,0,196

L04D1:          mulu    #$000B,D1
                add.w   #$008D,D1
                move.w  D0,D2
                move.w  D1,D3
                add.w   #$000D,D2
                add.w   #$000B,D3
                cmpi.w  #$00C4,D3
                bne.s   L04D2
                addq.w  #1,D3
L04D2:          moveq   #$0F,D4
                moveq   #2,D5
                moveq   #-1,D6
                bsr     rahmen
                rts

;Bedient das rechte Optionsfenster, je nach Funktion
bedien_options: move.b  function,D5     ;angewÑhlte Funktion
                ext.w   D5
                lsl.w   #2,D5
                movea.l L04D4(PC,D5.w),A0
                jmp     (A0)            ;in Routine springen

L04D4:                  DC.L jack_opt ;Jack Knife
                        DC.L grab_opt ;Grabber
                        DC.L copybox_opt ;copybox
                        DC.L text_opt ;text
                        DC.L pencil_opt ;Pencil
                        DC.L line_opt ;line
                        DC.L AND_opt ;fill
                        DC.L cut_opt ;sprite_cut
                        DC.L raster_opt ;&-Funktion
                        DC.L nozzle_opt ;brush
                        DC.L disk_opt ;disc
                        DC.L cam_opt ;camera
                        DC.L box_opt ;Rechtecke, Kreise, etc.
                        DC.L user1_opt ;eraser
                        DC.L user2_opt ;nozzles

pencil_opt:     rts

;Optionroutine des Grabbers:
grab_opt:       cmpi.w  #165,D1         ;Y
                bcc     save_data       ;>=165 -> abspeichern

                btst    #2,D2           ;linke Taste neu gedrÅckt?
                beq     grabber_end     ;Nein->RTS
                move.w  D1,D5           ;Y-Koordinate
                sub.w   #141,D5         ;kleiner 142
                bmi     grabber_end     ;->RTS
                lsr.w   #3,D5           ;durch 8
                cmpi.w  #3,D5           ;mehr als 3 Button gibt es (noch) nicht!
                bcc     grabber_end     ;->Raus
                bsr     invert_grab_btn
L04F8B:         move.w  D5,-(SP)        ;welcher war invertiert?
                bsr     animier_objekte ;Animiert z.B. die Copybox
                bsr     Sm
                bsr     get_maus
                move.w  (SP)+,D5
                btst    #4,D2           ;Links losgelassen?
                bne.s   L04FBB
                move.w  D1,D4           ;Y
                sub.w   #141,D4         ;Raus gefahren?
                bmi.s   L04FAB
                lsr.w   #3,D4
                cmpi.w  #3,D4           ;Neue Buttonnr berechnen
                bcc.s   L04FAB          ;zu gross, also alles ausschalten
                cmp.w   D4,D5           ;Gleich wie vorher?
                beq.s   L04F8B          ;JA, weiter warten
                bsr     Hm
                tst.w   D5              ;war vorher nichts gezeichnet?
                bmi.s   L04F9B          ;Ja, weiter
                bsr     invert_grab_btn ;Altes ausschalten
L04F9B:         move.w  D4,D5           ;Jetzt neues merken
                bsr     invert_grab_btn ;und einschalten
                bsr     Sm
                bra.s   L04F8B          ;weiter warten

L04FAB:         tst.w   D5              ;War vorher was invertiert?
                bmi.s   L04F8B          ;Nein, weiter warten, da Knopf gedrÅckt
                bsr     Hm
                bsr     invert_grab_btn ;zurÅckinvertieren
                moveq   #-1,D5          ;Jetzt ist nichts mehr invertiert
                bsr     Sm
                bra.s   L04F8B

L04FBB:         tst.w   D5              ;war vorher nichts invertiert?
                bmi.s   grabber_end     ;Ja->RTS
                bsr     Hm
                move.w  #7,D6           ;7 mal flashen
L04FCB:         bsr     invert_grab_btn
                move.w  vblcounter,button_klicked
L04FDB:         move.w  vblcounter,D7
                sub.w   button_klicked,D7
                cmpi.w  #2,D7           ;2 Vsyncs
                bcs.s   L04FDB
                dbra    D6,L04FCB
                move.w  D5,button_klicked ;Buttonnr merken

                lea     grab_opt_tab(PC),A0
                add.w   D5,D5
                add.w   D5,D5           ;Je nach Buttonnr Funktion ausfÅhren
                movea.l 0(A0,D5.w),A0
                movem.l D0-A6,-(SP)
                jsr     (A0)
                movem.l (SP)+,D0-A6
                move.w  button_klicked,D5
                bsr     invert_grab_btn
grabber_end:    rts

;Tabelle der Sprungvektoren fÅr die einzelnen Buttzons des Grabbers
grab_opt_tab:           DC.L calc_colors
                        DC.L save_pal
                        DC.L save_pal

calc_colors:    movem.l D0-A6,-(SP)

                move.w  left_col_mark,D6
                move.w  right_col_mark,D7
                cmp.w   D6,D7           ;gleich?
                beq     calc_end        ;ja->Raus
                addq.w  #1,D6
                cmp.w   D6,D7           ;eins Unterschied?
                beq     calc_end
                subq.w  #1,D6           ;wieder wegnehmen

                clr.b   changed         ;Es wurde was verÑndert...
                jsr     rette_palette

                move.w  D7,D3
                sub.w   D6,D3           ;Anzahl der Zwischenschritte

                add.w   D6,D6           ;Index linker Rand
                add.w   D7,D7           ;Index rechter Rand

                lea     hbl_system+2,A0
                move.w  rst_akt,D0      ;Aktuelle Palettenummer
                mulu    #34,D0
                adda.l  D0,A0           ;Adresse der aktuellen Palette
                move.w  0(A0,D6.w),D4   ;linken Farbwert holen
                move.w  0(A0,D7.w),D5   ;rechten Farbwert holen
                move.w  D4,D0
                move.w  D5,D1
                lsr.w   #8,D0
                lsr.w   #8,D1
                bsr     isolieren_ste   ;Rotton isolieren
                muls    #100,D0
                move.w  D0,start_rot
                muls    #100,D1
                sub.w   D0,D1           ;Differenz Rotwerte bilden
                ext.l   D1
                divs    D3,D1           ;Anzahl der Zwischenschritte
                move.w  D1,step_rot

                move.w  D4,D0           ;linken Farbwert holen
                move.w  D5,D1           ;rechten Farbwert holen
                lsr.w   #4,D0
                lsr.w   #4,D1
                bsr     isolieren_ste
                muls    #100,D0
                move.w  D0,start_gruen
                muls    #100,D1
                sub.w   D0,D1           ;Differenz GrÅnwerte bilden
                ext.l   D1
                divs    D3,D1           ;Anzahl der Zwischenschritte
                move.w  D1,step_gruen

                move.w  D4,D0
                move.w  D5,D1
                bsr     isolieren_ste   ;nur Blauton
                muls    #100,D0
                move.w  D0,start_blau
                muls    #100,D1
                sub.w   D0,D1           ;Differenz Blauwerte bilden
                ext.l   D1
                divs    D3,D1           ;Anzahl der Zwischenschritte
                move.w  D1,step_blau

                subq.w  #2,D3           ;wegen DBRA
                lea     normal2ste,A1
all_steps:      move.w  step_rot,D0
                add.w   D0,start_rot
                move.w  step_gruen,D0
                add.w   D0,start_gruen
                move.w  step_blau,D0
                add.w   D0,start_blau

                moveq   #0,D1
                move.w  start_rot,D1
                divs    #100,D1
                and.w   #15,D1
                move.w  D1,D2
                swap    D1              ;Rest bei Division durch 100
                cmp.w   #50,D1          ;Aufrunden...
                blt.s   noo1
                addq.w  #1,D2           ;aufrunden
noo1:           move.b  0(A1,D2.w),D2
                lsl.w   #8,D2
                move.w  D2,D0

                moveq   #0,D1
                move.w  start_gruen,D1
                divs    #100,D1
                and.w   #15,D1
                move.w  D1,D2
                swap    D1              ;Rest bei Division durch 100
                cmp.w   #50,D1
                blt.s   noo2
                addq.w  #1,D2
noo2:           move.b  0(A1,D2.w),D2
                lsl.w   #4,D2
                or.w    D2,D0

                moveq   #0,D1
                move.w  start_blau,D1
                divs    #100,D1
                and.w   #15,D1
                move.w  D1,D2
                swap    D1
                cmp.w   #50,D1
                blt.s   noo3
                addq.w  #1,D2
noo3:           move.b  0(A1,D2.w),D2
                or.w    D2,D0

                addq.w  #2,D6           ;nÑchste Farbe
                move.w  D0,0(A0,D6.w)   ;in Palette
                dbra    D3,all_steps

                jsr     palette_changed ;Eine Palette wurde geÑndert

calc_end:       movem.l (SP)+,D0-A6
                rts

;Isoliert einen Farbanteil und rechnet bei STE in normale Darstellung um
; D0.B: 1. Farbe
;  D1.B: 2. Farbe
isolieren_ste:  and.w   #15,D0
                and.w   #15,D1
                lea     ste2normal,A1   ;In normale Darstellung umrechnen
                move.b  0(A1,D0.w),D0
                move.b  0(A1,D1.w),D1
                rts

save_pal:       lea     save_path,A0
                lea     scrollwabbel,A1
copy53:         move.b  (A0)+,(A1)+     ;Pfadnamen sichern
                bne.s   copy53

                lea     picture_neo,A0
                lea     scrollspace,A1
copy52:         move.b  (A0)+,(A1)+     ;Filenamen duplizieren
                bne.s   copy52

                lea     scrollspace,A1
                moveq   #7,D1           ;*.S
                cmpi.w  #1,button_klicked ;Ass?
                beq.s   ok19
                moveq   #8,D1           ;*.C
ok19:           move.w  D1,D0
                mulu    #6,D0
                lea     extensions(PC),A0
                move.b  2(A0,D0.w),save_pal_typ
                bsr     change_file     ;und an Filenamen anhÑngen
                lea     scrollwabbel,A0 ;Pfad
                bsr     change_path
                lea     scrollspace,A1  ;Filenamen
                lea     save_pal_ext,A2
                moveq   #1,D0           ;Speichern
                bsr     fileselect
                bne     save_pal_end    ;Abbruch angeklickt

                bsr     neo_an          ;Und Neo wieder an

                clr.w   -(SP)
                pea     fsel_path       ;Filename
                move.w  #$003C,-(SP)
                trap    #1              ;Create fÅr Save Palette
                addq.l  #8,SP
                move.l  SP,save_sp
                move.w  D0,handle
                bmi     disk_error

                lea     pal_titel_s,A2
                lea     pal_titel2_s,A3
                lea     L0520(PC),A4    ;FÅr die Assembler-Version
                lea     L0521(PC),A5
                lea     eol_s(PC),A6
                cmpi.w  #1,button_klicked ;Assembler?
                beq.s   ok20
                lea     pal_titel_c,A2  ;FÅr die C-Version
                lea     pal_titel2_c,A3
                lea     neue_zeile,A4
                lea     neuer_wert,A5
                lea     eol_c,A6
ok20:           movea.l copybox_screen,A0 ;Hier den Buffer aufbauen
                movea.l A0,A1
                lea     $0400(A0),A0    ;Ende des Buffers
                bsr     Fwrite_str      ;Titelstring in Datei schreiben
                lea     picture_neo,A2  ;Bildname ins File schreiben
                bsr     Fwrite_str
                movea.l A3,A2           ;Rest in Datei
                bsr     Fwrite_str

                movea.l A4,A2           ;CRLF dc.w
                bsr     Fwrite_str

                lea     hbl_system+2,A3
                move.w  rst_akt,D4      ;Aktuelle Palette
                mulu    #34,D4
                adda.l  D4,A3           ;=Adresse der aktuellen Palette
                moveq   #1,D4
L050F2:         moveq   #6,D3           ;Erstmal 7 Farben
L05102:         move.w  (A3)+,D2
                and.w   #$0FFF,D2       ;Bits ausmaskieren
                tst.w   ste_support
                beq.s   save_it
                and.w   #$0777,D2       ;Bei normalem ST noch mehr ausblenden
save_it:        bsr     save_word
                movea.l A5,A2           ;',$'
                bsr     Fwrite_str
                dbra    D3,L05102
                move.w  (A3)+,D2        ;Das 8. ohne ','
                bsr     save_word
                tst.w   D4              ;letzte Zeile?
                beq.s   L05112          ;Dann nich
                movea.l A6,A2           ;EOL
                bsr     Fwrite_str      ;und speichern
                movea.l A4,A2           ;CRLF ; dc.w
                bsr     Fwrite_str
L05112:         dbra    D4,L050F2       ;in 2 Zeilen

                cmpi.w  #1,button_klicked ;Assembler-Version?
                beq.s   ok11
                lea     eof_c,A2        ;End of File
                bsr     Fwrite_str

ok11:           addq.w  #3,button_klicked ;in Grabber umrechnen
                bsr     L0517           ;Und den Rest voll saven
                subq.w  #3,button_klicked
                move.w  button_klicked,D5
                bra     invert_grab_btn ;und wieder invertieren

save_pal_end:   bra     neo_an          ;Neochrom wieder anschalten

disk_opt:       movem.l D0-A3,-(SP)

                move.w  #198,D3
                move.w  #191,D4
                move.w  #238,D5
                move.w  #199,D6
                bsr     maus_in
                beq     format

                move.w  #242,D3
                move.w  #282,D5
                bsr     maus_in
                beq     delete

                move.w  #286,D3
                move.w  #313,D5
                bsr     maus_in
                bne.s   kein_quit
                jmp     quit_from_board

kein_quit:      sub.w   #149,D1
                bmi.s   no_disk_opt
                ext.l   D1
                divu    #7,D1
                cmp.w   #5,D1
                bge.s   no_disk_opt
                cmp.w   #198,D0         ;x1
                blt.s   no_disk_opt
                cmp.w   #313,D0
                bgt.s   no_disk_opt
                cmp.w   #255,D0
                blt.s   chg_load

                bsr     chg_save_typ    ;Typ des Speicherns Ñndern
                bra.s   end_disk_opt

chg_load:       bsr     chg_load_typ    ;Neuen Ladetyp merken

end_disk_opt:   lea     haken_loadk(PC),A3 ;Haken ausgeben
                lea     haken_load(PC),A0
pr_loop1:       move.w  (A3)+,D2        ;Farbe
                bmi.s   no_disk_opt
                move.w  (A3)+,D0        ;x
                move.w  (A3)+,D1        ;y
                bsr     print6x6
                bra.s   pr_loop1
no_disk_opt:    movem.l (SP)+,D0-A3
                rts

;Baut aus Pfad mit Extension und Filenamen den absoluten
;Zugriffspfad in fsel_path auf.
;-> A0.L: Pfad
;   A1.L: Filename
build_pathfn:   movem.l D0-A6,-(SP)

                lea     fsel_path,A2
copy_path:      move.b  (A0)+,D0
                cmp.b   #'\',D0
                bne.s   no_back
                lea     1(A2),A3        ;Position merken
no_back:        move.b  D0,(A2)+
                bne.s   copy_path

copy_file:      move.b  (A1)+,(A3)+
                bne.s   copy_file

                movem.l (SP)+,D0-A6
                rts

;éndert den Pfad einer Fileselectbox: (CHS)
;Parameter:
;D1: neuer Typ
;A0: Adresse des Pfades
change_path:    movem.l D0-A6,-(SP)

chg_loop:       tst.b   (A0)+           ;Ende des Pfades suchen
                bne.s   chg_loop
such_back2:     cmpi.b  #'\',-(A0)      ;Backslash suchen
                bne.s   such_back2

                addq.l  #1,A0           ;'\' Åberspringen

                mulu    #6,D1
                lea     extensions(PC),A1
                adda.l  D1,A1
copy_ext:       move.b  (A1)+,(A0)+     ;Ganze Extension kopieren
                bne.s   copy_ext

                movem.l (SP)+,D0-A6
                rts

;HÑngt richtige Extension an Filenamen an (CHS)
;Parameter:
;D1: neuer Typ
;A1: Adresse des Filenamens
change_file:    movem.l D0-A6,-(SP)
                movea.l A1,A2

                tst.b   (A1)            ;öberhaupt ein String da?
                beq.s   no_anhÑngen     ;Nein, nichts anhÑngen

                moveq   #8,D0           ;9 Zeichen testen
such_punkt:     cmpi.b  #'.',(A1)+      ;Punkt gefunden?
                beq.s   punkt_found
                dbra    D0,such_punkt
                movea.l A2,A1           ;Wieder vom Start an
such_end5:      tst.b   (A1)+           ;Ende suchen
                bne.s   such_end5
                move.b  #'.',-1(A1)
punkt_found:    mulu    #6,D1
                lea     extensions+2(PC),A0
                adda.l  D1,A0
                move.b  (A0)+,(A1)+
                move.b  (A0)+,(A1)+     ;richtige Extension anhÑngen
                move.b  (A0)+,(A1)+
                move.b  (A0)+,(A1)+

no_anhÑngen:    movem.l (SP)+,D0-A6
                rts

;initialisiert die Haken vor Load und Save
init_haken:     lea     haken_save(PC),A0
                move.w  save_typ,D0
                add.w   D0,D0
                move.b  #'',0(A0,D0.w) ;Neuen Haken hinmachen
                lea     haken_load(PC),A0
                move.w  load_typ,D0
                add.w   D0,D0
                move.b  #'',0(A0,D0.w) ;Neuen Haken hinmachen
                rts

;éndert den Ladetyp (CHS)
;Parameter:     D1: Neuer loadtyp, wird gesetzt in Anzeige und Fileselektor und Fsel-Pfad
chg_load_typ:   bsr     change_load_typ

                move.w  load_typ,D1     ;neuen Ladetyp holen
                lea     load_path,A0    ;hier Extension Ñndern
                bra     change_path     ;und change it!

;éndert den Ladetyp (CHS)
;Parameter:     D1: Neuer loadtyp, wird gesetzt in Anzeige und Fileselektor
change_load_typ:lea     haken_load(PC),A0
                move.w  load_typ,D0
                add.w   D0,D0
                move.b  #' ',0(A0,D0.w) ;Alten Haken wegmachen
                move.w  D1,load_typ
                add.w   D1,D1
                move.b  #'',0(A0,D1.w)

;Setzt im Fileselektor die Extension neu:
set_load_ext:   movem.l D0/A0-A1,-(SP)
                lea     load_str,A1
                move.w  load_typ,D0
                mulu    #6,D0
                lea     extensions+2(PC),A0
                adda.w  D0,A0
                move.b  (A0)+,(A1)+
                move.b  (A0)+,(A1)+     ;Extension eintragen
                move.b  (A0)+,(A1)+
                movem.l (SP)+,D0/A0-A1
                rts

;éndert den Savetyp (CHS)
;Parameter:     D1: Neuer savetyp, wird gesetzt
chg_save_typ:   lea     haken_save(PC),A0
                move.w  save_typ,D0
                add.w   D0,D0
                move.b  #' ',0(A0,D0.w) ;Alten Haken wegmachen
                move.w  D1,save_typ
                add.w   D1,D1
                move.b  #'',0(A0,D1.w) ;Neuen Haken hinmachen

                bsr     set_save_ext    ;Setzt im Fileselektor xxx-Picture

                lea     save_path,A0    ;Hier Extension hinmachen
                lsr.w   #1,D1           ;Neuen Typ halbieren
                bra     change_path

;Setzt im Fileselektor den Savetyp neu:
set_save_ext:   movem.l D0/A0-A1,-(SP)
                lea     save_str,A1
                move.w  save_typ,D0
                mulu    #6,D0
                lea     extensions+2(PC),A0
                adda.w  D0,A0
                move.b  (A0)+,(A1)+
                move.b  (A0)+,(A1)+     ;Extension eintragen
                move.b  (A0)+,(A1)+
                movem.l (SP)+,D0/A0-A1
                rts

format:         bsr     Hm
                move.b  invertiert,D0
                move.w  D0,-(SP)
                movem.w D3-D6,-(SP)     ;Parameter retten
                bsr     inv_button
                move.l  #sure,D0
                bsr     switch_alert
                cmpi.w  #1,int_out      ;Cancel
                beq     format_end      ;ja, zurÅck

                move.w  int_out,step_rot ;Merken

                bsr     Hm
                jsr     raster_ggf_aus
                moveq   #79,D7          ;Track 79 starten
form_again:     moveq   #0,D6           ;Seite 0
                bsr     format_track
                tst.w   D0
                bmi     format_error
                cmpi.w  #3,step_rot     ;Doppelseitig?
                bne.s   single
                moveq   #1,D6           ;Seite 1
                bsr     format_track
                tst.w   D0
                bmi     format_error
single:         movem.w (SP),D3-D6      ;Parameter holen
                bsr     inv_button      ;und flashen lassen
                dbra    D7,form_again

                jsr     raster_ggf_an

                movea.l scr2,A0
                move.w  #255,D0
clr_loop9:      clr.l   (A0)+           ;1024 Bytes lîschen
                dbra    D0,clr_loop9

                move.w  #17,-(SP)
                trap    #14             ;Random
                addq.l  #2,SP
                lea     seriennummer,A0
                move.b  D0,(A0)+
                lsr.w   #8,D0
                move.b  D0,(A0)+        ;Seriennummer eintragen
                swap    D0
                move.b  D0,(A0)+

                lea     bootsektor,A0
                movea.l scr2,A1
copy_it73:      move.b  (A0)+,D0
                cmp.b   #-1,D0
                beq.s   end_copy
                move.b  D0,(A1)+
                bra.s   copy_it73
end_copy:       movea.l scr2,A6         ;Adresse des Bootsektors
                cmpi.w  #3,step_rot     ;Doppelseitig?
                bne.s   no_single       ;nein, also so lassen
                move.b  #$F9,media_byte-bootsektor(A6)
                move.b  #3,spf-bootsektor(A6) ;3 Sektoren pro FAT
                move.b  #$A0,disk_size-bootsektor(A6)
                move.b  #$05,disk_size+1-bootsektor(A6)
                move.b  #2,sides-bootsektor(A6)
no_single:      move.b  media_byte-bootsektor(A6),512(A6)
                move.b  #-1,513(A6)     ;FAT vorbereiten
                move.b  #-1,514(A6)

                move.w  #2,-(SP)
                clr.l   -(SP)
                move.w  #1,-(SP)
                clr.w   -(SP)
                clr.l   -(SP)
                move.l  A6,-(SP)
                move.w  #9,-(SP)
                trap    #14             ;Bootsektor+1.FAT schreiben
                lea     20(SP),SP

                move.w  #1,-(SP)
                clr.l   -(SP)
                moveq   #0,D0
                move.b  spf-bootsektor(A6),D0
                addq.w  #2,D0
                move.w  D0,-(SP)        ;Startsektor 2. FAT
                clr.w   -(SP)           ;A:
                clr.l   -(SP)
                pea     512(A6)
                move.w  #9,-(SP)
                trap    #14
                lea     20(SP),SP

format_end:     movem.w (SP)+,D3-D6
                move.w  (SP)+,D0
                cmp.b   invertiert,D0   ;Derselbe Status?
                beq.s   ok68
                bsr     inv_button      ;ZurÅckinvertieren
ok68:           bra     no_disk_opt

format_error:   move.l  #write_protect,D0 ;Disk may be write-protected
                bsr     switch_alert
                bsr     Hm
                cmpi.w  #1,int_out      ;Retry?
                beq     form_again      ;nochmal testen
                bra.s   format_end

;Formatiert einen Track (CHS)
;D6: Seite
;D7: Track
format_track:   clr.w   -(SP)           ;Virgin
                move.l  #$87654321,-(SP)
                move.w  #1,-(SP)        ;Interleave
                move.w  D6,-(SP)        ;Seite
                move.w  D7,-(SP)        ;Track
                move.w  #9,-(SP)        ;SpT
                clr.w   -(SP)           ;A:
                clr.l   -(SP)
                move.l  scr2,-(SP)
                move.w  #10,-(SP)
                trap    #14
                lea     $001A(SP),SP
                rts

delete:         bsr     Hm

                lea     save_path,A0
                lea     scrollspace,A1  ;Keinen Filenamen
                clr.b   (A1)
                lea     del_ext,A2
                moveq   #0,D0           ;'Laden'
                bsr     fileselect
                bne.s   end_delete      ;Abbruch angeklickt

                move.l  #sure_del,D0
                bsr     switch_alert
                cmpi.w  #2,int_out      ;Okay?
                bne.s   end_hier        ;Nein, weiter

once_again:     pea     fsel_path
                move.w  #$0041,-(SP)    ;Unlink
                trap    #1
                addq.l  #6,SP
                tst.w   D0              ;gelîscht?
                beq.s   end_hier        ;ja, okay

                move.l  #write_protect,D0 ;write-rpotect...
                bsr     switch_alert
                cmpi.w  #1,int_out      ;Retry?
                beq.s   once_again
                bra.s   end_hier

end_delete:     bsr     neo_an
end_hier:       bra     no_disk_opt

text_opt:       movem.l D0-A1,-(SP)
                cmpi.w  #181,D1
                bcs.s   L04D9
                cmpi.w  #190,D1
                bcc.s   L04D9
                move.w  D0,D5
                subi.w  #240,D5
                bcs.s   L04D9
                ext.l   D5
                divu    #12,D5
                cmpi.w  #3,D5
                bcc.s   L04D9
                move.w  text_align,D4
                move.w  D4,-(SP)
                mulu    #6,D4
                lea     L057C(PC),A0
                move.w  0(A0,D4.w),D2
                move.w  2(A0,D4.w),D0
                move.w  4(A0,D4.w),D1
                moveq   #15,D3
                bsr     draw_func
                move.w  D5,text_align
                bsr     show_align
                move.w  (SP)+,D4
                cmp.w   D4,D5
                beq     L04E1
                bra     L04DE

L04D9:          move.w  text_style,D3
                cmpi.w  #$00C6,D0
                bcs.s   L04DD
                cmpi.w  #$0114,D0
                bcc.s   L04DD
                move.w  D1,D4
                subi.w  #$008B,D4
                bcs.s   L04DD
                lsr.w   #3,D4
                cmpi.w  #5,D4
                bcc.s   L04DD
                tst.w   D4
                bne.s   L04DA
                tst.w   D3
                beq.s   L04DD
                clr.w   text_style
                bra.s   L04DC
L04DA:          cmpi.w  #1,D4
                bne.s   L04DB
                moveq   #0,D4
L04DB:          bchg    D4,L0799
L04DC:          bsr     show_style
                bra.s   L04DE

L04DD:          move.w  text_height,D3
                cmpi.w  #$0115,D0
                bcs.s   L04DF
                cmpi.w  #$0139,D0
                bcc.s   L04DF
                move.w  D1,D4
                subi.w  #$008C,D4
                bcs.s   L04DF
                lsr.w   #3,D4
                cmpi.w  #6,D4
                bcc.s   L04DF
                lea     text_hîhen(PC),A0
                move.b  0(A0,D4.w),L079B
                bsr     show_height
                cmp.w   text_height,D3
                beq.s   L04E1
L04DE:          bsr     init_text
                bsr     copy_board
                jsr     L0189
                movem.l (SP)+,D0-A1
                rts

L04DF:          cmpi.w  #$00BF,D1
                bcs.s   L04E1
                cmpi.w  #$00E4,D0
                bcs.s   L04E1
                cmpi.w  #$0138,D0
                bcc.s   L04E1
                bchg    #7,L0599
                lea     L058B(PC),A0
                lea     L058C(PC),A1
L04E0:          move.b  (A0),D7
                move.b  (A1),(A0)+
                move.b  D7,(A1)+
                bne.s   L04E0
                bsr     L04AF
L04E1:          bsr     init_text
                bsr     copy_board
                movem.l (SP)+,D0-A1
                rts

;Setzt, je nach dem ob bei Box gefÅllt wird das entsprechende Icon in das Funktionspanel
set_box_icon:   move.b  #19,box_fill    ;ausgefÅlltes Icon
                tst.w   just_rahmen     ;Nur FÅllen?
                bne.s   nein26126
                move.b  #103,box_fill
nein26126:      rts

;und Zeichnet diese Icon:
show_box_icon:  moveq   #52,D0
                move.w  #158,D1
                moveq   #0,D2
                move.b  box_fill,D2
                moveq   #15,D3
                bra     draw_func_inv

box_opt:        move.w  D1,D5           ;Maus_y
                subi.w  #114,D5
                bcs     L04F0           ;->RTS
                cmpi.w  #49,D5
                bcs     L04EE
                cmpi.w  #198,D0         ;Maus_x
                bcs     L04F0           ;->RTS
                cmpi.w  #234,D0
                bcs.s   L04E4
                cmpi.w  #266,D0
                bcc.s   L04E9
                moveq   #3,D4           ;Dicke StrichstÑrken
                move.w  #5,randstÑrke
L04E3:          cmp.b   dicke_strich_y(PC,D4.w),D5
                bcc.s   L04E6
                dbra    D4,L04E3
                bra.s   L04E6
L04E4:          moveq   #4,D4           ;DÅnne StrickstÑrken
                clr.w   randstÑrke
L04E5:          cmp.b   dÅnne_strich_y(PC,D4.w),D5
                bcc.s   L04E6
                dbra    D4,L04E5
L04E6:          add.w   D4,randstÑrke
                bsr     L055F
                jsr     L0138
                bra     L04F0

;Tabelle der verschiedenen Y-Werte der StrichstÑrken:
dÅnne_strich_y:         DC.B 49,56,62,68,75,$FF
dicke_strich_y:         DC.B 49,57,65,74

;Einstellen, ob ausgefÅllt oder nicht:
L04E9:          clr.w   just_rahmen
                cmpi.w  #290,D0
                bcs.s   L04EA
                move.w  #-1,just_rahmen
L04EA:          bsr     draw_hÑkchen    ;Neuen Haken zeichnen
                lea     boxicons(PC),A0
                move.w  (A0),D4
                cmpi.w  #76,D4
                bne.s   L04EB
                tst.w   just_rahmen     ;Nur einen Rahmen zeichnen?
                beq.s   L04F0           ;ja->RTS
                moveq   #5,D5
                bra.s   L04EC
L04EB:          tst.w   just_rahmen     ;Nur Rahmen?
                bmi.s   L04F0           ;Nein->RTS
                moveq   #-5,D5
L04EC:          moveq   #4,D4           ;5 Icons zu verÑndern
L04ED:          add.w   D5,(A0)         ;+/- 5
                addq.l  #6,A0           ;nÑchstes Icon
                dbra    D4,L04ED
                bsr     set_box_icon    ;und Funktionsicon neu setzen
                bsr     show_box_icon   ;und anzeigen
                bsr     draw_boxen      ;Boxenicons neu zeichnen
                bra     inv_akt_boxtyp  ;aktuellen Boxtyp invertieren

;Einstellen des Types (Rechteck, Kreis, etc.)
L04EE:          cmpi.w  #25,D5
                bcs.s   L04F0           ;->RTS
                move.w  D0,D5
                subi.w  #198,D5
                bcs.s   L04F0
                ext.l   D5
                divu    #23,D5
                bsr     L04BF
                cmpi.w  #5,D5
                bcs.s   L04EF
                moveq   #4,D5           ;Maximalwert
L04EF:          move.w  D5,box_typ
                bsr     inv_akt_boxtyp
L04F0:          rts

aft_and:        movem.l D0-A6,-(SP)
                bsr     haken_aus       ;Noch den Haken vor x/y ausgeben
                bsr     music_nr_out    ;und die Nummer der aktiven Musik
                movem.l (SP)+,D0-A6
                rts

;Fragt wieviel Speicher frei ist
; D0.L: freier Speicher
get_free_mem:   movem.l D1-D2/A0-A2,-(SP)

                pea     -1.w
                move.w  #$0048,-(SP)
                trap    #1
                addq.l  #6,SP
                sub.l   #5000,D0        ;5K freihalten

                movem.l (SP)+,D1-D2/A0-A2
                rts

;öberprÅft, ob Maus in einem Quadratischen Feld ist
;Parameter:
;D0: mx
;D1: my
;D3: x1
;D4: y1
;D5; x2
;D6: y2
;RÅckgabe Zeroflag..
maus_in:        cmp.w   D3,D0           ;x1
                blt.s   nicht_drin
                cmp.w   D4,D1           ;y1
                blt.s   nicht_drin
                cmp.w   D5,D0           ;x2
                bgt.s   nicht_drin
                cmp.w   D6,D1           ;y2
                bgt.s   nicht_drin
                ori     #%00000100,CCR  ;Zero setzen
                rts
nicht_drin:     andi    #%11111011,CCR  ;Zero lîschen
                rts

inv_btn_back:   tst.w   board_da        ;Ist Åberhaupt das Board da?
                bne     no_invert       ;Nein->RTS
                bsr.s   inv_button
                movem.l D0-A6,-(SP)
wait_los2:      bsr     get_maus
                bne.s   wait_los2
                movem.l (SP)+,D0-A6

;Invertiert Quadratisches Feld (Button)
;Parameter:
;D3: x1
;D4: y1
;D5; x2
;D6: y2
inv_button:     tst.w   board_da
                bne.s   no_invert

                not.b   invertiert      ;Flag umdrehen

                movem.l D0-A6,-(SP)

                lea     bb,A6
                sub.w   D3,D5
                subq.w  #1,D5
                move.w  D5,(A6)+        ;Breite
                sub.w   D4,D6
                subq.w  #1,D6
                move.w  D6,(A6)+        ;Hîhe
                addq.w  #1,D3
                addq.w  #1,D4
                move.w  #4,(A6)+        ;4 Planes
                move.w  #0,(A6)+        ;Vordergrundfarbe
                move.w  #15,(A6)+       ;Hintergrundfarbe
                move.l  #$0C0C0C0C,(A6)+ ;Invertieren
                move.w  D3,(A6)+        ;x
                move.w  D4,(A6)+        ;y
                move.w  #3,-(SP)
                trap    #14             ;Logbase holen
                addq.l  #2,SP
                move.l  D0,(A6)+        ;Quelle
                move.w  #8,(A6)+
                move.w  #160,(A6)+
                move.w  #2,(A6)+
                move.w  D3,(A6)+
                move.w  D4,(A6)+
                move.l  D0,(A6)+
                move.w  #8,(A6)+
                move.w  #160,(A6)+
                move.w  #2,(A6)+
                clr.l   (A6)+
                lea     bb,A6
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D0-A6
no_invert:      rts

;Tabelle der verschiedenen Buttons bei Cut_opt
cut_btn_tab:            DC.L add_akt_btn
                        DC.L replace_akt_btn
                        DC.L del_akt
                        DC.L show_akt_btn
                        DC.L left_akt
                        DC.L right_akt

;Bedient die Cutteroptions
cut_opt:        movem.l D0-A6,-(SP)

                move.w  D2,D5
                and.w   #%0000000000001100,D5 ;Links oder rechts neu gedrÅckt?
                beq     end_cut_opt

                lea     spaces,A0
                bsr     cut_status

                move.w  #270,D3
                move.w  #153,D4
                move.w  #314,D5         ;LOAD/SAVE...
                move.w  #153+4*8,D6
                bsr     maus_in
                bne.s   no_ld_sv

                sub.w   #153,D1
                lsr.w   #3,D1           ;/8
                cmp.w   #3,D1
                bgt.s   no_ld_sv

                move.w  D1,D5
                mulu    #6,D5
                lea     cut_loadk(PC),A0
                tst.w   0(A0,D5.w)      ;Button enabled?
                bne.s   end_cut_opt     ;Nein, raus

                bsr     Hm

                tst.w   D1
                bne.s   no_load
                bsr     load_cut        ;laden
                bra.s   end_cut_opt     ;und raus hier
no_load:        cmp.w   #1,D1
                bne.s   no_save
                bsr     save_cut        ;speichern
                bra.s   end_cut_opt
no_save:        cmp.w   #3,D1           ;Recut?
                bne.s   no_recut
                move.w  D1,D5           ;Buttonummer
                bsr     inv_camera_btn  ;Button invertieren
                move.w  D1,-(SP)        ;Buttonnummer merken
                bsr     recut
                move.w  (SP)+,D5
                bsr     inv_camera_btn  ;und zurÅck
                bra.s   end_cut_opt
no_recut:       cmp.w   #2,D1           ;New?
                bne.s   no_new          ;Nein->Weiter
                move.l  #sure_new,D0    ;Sicher alles lîschen?
                bsr     switch_alert
                cmpi.w  #2,int_out      ;Okay?
                bne.s   no_new          ;Nein->Raus
                bsr     new_cutter      ;Allen Speicher freigeben
no_new:         bra.s   end_cut_opt     ;und raus hier

no_ld_sv:       move.b  D2,maus_status  ;Alten Mausstatus merken

                lea     cut_btn(PC),A0
                bsr     check_button    ;In welches Rechteck wurde geklickt?
                tst.w   D7              ;Rechteck gefunden?
                bmi.s   end_cut_opt     ;Nein, weiter

                bsr     inv_btn_back    ;Knopf invertieren
                lsl.w   #2,D7           ;mal 4
                lea     cut_btn_tab(PC),A0
                movea.l 0(A0,D7.w),A0
                jsr     (A0)
end_cut_opt:    movem.l (SP)+,D0-A6
no_print:       rts

less_mem:       lea     memerr,A0
cut_status:     tst.w   board_da        ;Ist öberhaupt ein Board da?
                bne.s   no_print        ;Nein, bloû raus hier
                movem.l D0-A6,-(SP)
                move.w  #202,D0
                move.w  #192,D1
                moveq   #0,D2
                bsr     print6x6
                movem.l (SP)+,D0-A6
                rts

load_cut:       move.l  SP,save_sp      ;SP retten

                jsr     delete_cut_rahm ;Rahmen ggf. wegmachen
                lea     cut_path,A0
                moveq   #5,D1           ;*.OBJ
                bsr     change_path     ;An Pfad anhÑngen
                lea     picture_neo,A2
                lea     cut_file,A1
loop1:          move.b  (A2)+,(A1)+
                bne.s   loop1
                lea     cut_file,A1
                bsr     change_file     ;und an File anhÑngen
                lea     cut_lext,A2
                moveq   #0,D0           ;Laden
                bsr     fileselect
                bne     end_load        ;und ganz raus hier

                bsr     fopen
                bmi     read_error

                tst.l   mem_cutter      ;Ist schon Speicher angefordert?
                bne.s   speicher_da     ;ja

                bsr     get_free_mem    ;Wieviel Speicher ist frei?
                move.l  D0,mem_lÑnge
                bmi     less_mem2       ;Leider gar nichts mehr

                move.l  D0,-(SP)
                move.w  #$0048,-(SP)
                trap    #1
                addq.l  #6,SP
                move.l  D0,mem_cutter
                movea.l D0,A6
                move.l  #'NEOO',(A6)+   ;header1 erzeugen
                move.l  #version,(A6)+
                clr.l   (A6)+           ;Header2: Bisher kein Byte im Speicher
                clr.w   (A6)+           ;Null Objecte

speicher_da:    lea     scrollwabbel,A6 ;Platz zum Lesen von Header1
                moveq   #8,D6           ;Header1 lesen
                bsr     fread

                cmpi.l  #'NEOO',(A6)+   ;Magic1?
                bne     wrong_obj_format
                cmpi.l  #version,(A6)+  ;Richtige Version?
                bne     wrong_obj_format

                lea     scroll_save,A6
                moveq   #2,D6
                bsr     fread           ;Anzahl der internal Bytes holen

                move.w  (A6)+,D6
                move.w  D6,D0
                ext.l   D0
                divu    #14,D0          ;Anzahl der Bilder
                move.w  D0,-2(A6)       ;berechnen
                bsr     fread           ;die Filenamen lesen

                movea.l mem_cutter,A5
                lea     12(A5),A5       ;Header1+Header2 Åberspringen
                move.w  (A5)+,D7        ;Anzahl der alten Objekte
                bra.s   inloop8
spr_loop28:     adda.l  (A5)+,A5        ;Diesen Sprite Åberspringen!
inloop8:        dbra    D7,spr_loop28

                lea     scrollwabbel,A6
                moveq   #6,D6           ;Header2
                bsr     fread           ;lesen

                move.l  mem_lÑnge,D0    ;Speicher der fÅr Objekte zur VerfÅgung
                move.l  A5,D6           ;Ende der alten Objekte
                sub.l   mem_cutter,D6   ;-Start=Anzahl verbrauchter Bytes
                sub.l   D6,D0           ;-LÑnge=Freie Bytes

                lea     scrollwabbel,A6
                move.l  (A6)+,D7        ;neue FilelÑnge
                subq.l  #2,D7           ;2 Bytes weniger da Anzahl mitgespeichert
                move.w  (A6)+,D5        ;neue Anzahl der Objekte
                subq.w  #1,D5           ;wegen DBRA
                move.w  D5,D4

                cmp.l   D7,D0           ;genug Speicher da?
                bgt.s   enough_mem23    ;ja, weiter
less_mem2:      lea     memerr,A6
                bra     load_msg

enough_mem23:   movea.l mem_cutter,A0   ;Speicher der Objekte
                add.l   D7,8(A0)        ;+neue FilelÑnge
                add.w   D5,12(A0)       ;+Neue Objekte
                addq.w  #1,12(A0)       ;+1 (?)

                movea.l A5,A6           ;Ab Ende der alten Objekte laden

header_loop2:   moveq   #header_len,D6  ;1. Header lesen
                bsr     fread
                move.w  10(A6),D0       ;Breite in Bytes
                mulu    6(A6),D0        ;x Hîhe=Anzahl der Bytes
                move.l  16(A6),D1       ;reserved
                lsr.w   #8,D1           ;Anzahl der Raster
                mulu    #34,D1
                add.l   D1,D0           ;+Grîûer der Raster
                add.l   #header_len-4,D0 ;So groû ist dieses Objekt
                move.l  D0,(A6)+        ;LÑnge eintragen
                adda.l  D0,A6           ;und zum nÑchsten Header
                dbra    D4,header_loop2

                movea.l A5,A6           ;Ab dem Ende der alten Objekte laden

data_loop2:     move.l  (A6),D6         ;LÑnge des Objektes
                sub.l   #header_len-4,D6 ;tatsÑchliche LÑnge
                lea     header_len(A6),A6
                bsr     fread           ;Daten lesen
                adda.l  D6,A6           ;und diese Daten Åberspringen
                dbra    D5,data_loop2

                bsr     fclose

                move.l  #load_used,D0   ;Benutzte Bilder laden?
                bsr     switch_alert
                cmpi.w  #1,int_out      ;Ja?
                bne     no_pic_load2

                lea     scroll_save,A6
                move.w  (A6)+,D7        ;Anzahl der Bilder
                lea     -13(A6),A6      ;wird nachher wieder draufaddiert
                bra     nxt_pic

nxt_pic2:       moveq   #0,D0
                move.b  (A6)+,D0        ;Nummer des Screens holen
                cmp.w   anz_screens,D0
                blt.s   ok2378

                movea.l A6,A5
                moveq   #12,D0          ;13 Zeichen lang
                lea     error_screen_fn,A0
copy82:         move.b  (A5)+,(A0)+     ;eintragen
                dbeq    D0,copy82

                move.b  #' ',-1(A0)     ;Space Åber Null
copy92:         move.b  #' ',(A0)+
                dbra    D0,copy92

                move.l  #error_screen,D0
                bra.s   err_err

ok2378:         bsr     show_workscreen ;Entsprechenden Workscreen anschalten

                movea.l A6,A5

                lea     fsel_path,A0    ;Pfad des Objektes benutzen
such_end8:      tst.b   (A0)+
                bne.s   such_end8
such_back:      cmpi.b  #'\',-(A0)
                bne.s   such_back
                addq.l  #1,A0           ;'\' Åberspringen
copy_it:        move.b  (A5)+,(A0)+     ;Filenamen Åbertragen
                bne.s   copy_it

                bsr     fopen           ;Datei îffnen

                movea.l A6,A5
                lea     picture_neo,A0  ;Neuen Filenamen retten
                moveq   #12,D4          ;13 Bytes lang
copy4:          move.b  (A5)+,(A0)+
                dbra    D4,copy4

                bsr     alle_irqs_aus
                jsr     load_pic        ;Bild laden
                tst.w   D0              ;Fehler?
                bpl.s   nxt_pic         ;Nein, nÑchstes

                movea.l A6,A5
                moveq   #12,D0          ;13 Zeichen lang
                lea     error_load_fn,A0
copy8:          move.b  (A5)+,(A0)+     ;eintragen
                dbeq    D0,copy8

                move.b  #' ',-1(A0)     ;Space Åber Null
copy9:          move.b  #' ',(A0)+
                dbra    D0,copy9

                move.l  #error_load,D0
err_err:        bsr     switch_alert    ;Und Alert-Box raus

nxt_pic:        lea     13(A6),A6       ;nÑchster Filename
                dbra    D7,nxt_pic2

                move.w  #1,akt_cut_shape ;Ok, alles richtig geladen

                bsr     alle_irqs_an
                bsr     get_maus
                bsr     draw_board      ;Leiste zeichnen
                bsr     check_lupe

no_pic_load2:   move.w  #1,akt_cut_shape ;Ok, alles richtig geladen

                bsr     on_off_cutter   ;Buttons an/Aus schalten
                clr.w   cut_savek       ;Mann kann jetzt saven
                clr.w   cut_savek+6     ;und new
                clr.w   cut_savek+12    ;und re-cut
                bsr     draw_options
                bra.s   no_end

end_load:       jsr     screen2neo
no_end:         bsr     on_off_cutter
                bsr     show_numbers
                bsr     redraw_cut_opt

                movea.l save_sp,SP      ;Alten SP wiederherstellen
                rts

wrong_obj_format:lea    wrg_frmt,A6
                bra.s   load_msg

read_error:     lea     fileerror,A6
                bra.s   load_msg

load_space:     lea     spaces,A6
load_msg:       bsr     fclose          ;ggf. Datei schliessen
                jsr     screen2neo
                bsr     new_cutter      ;Alles wieder freigeben
                movea.l A6,A0
                bsr     cut_status
                bra.s   no_end

save_cut:       jsr     delete_cut_rahm ;Rahmen ggf. weglîschen
                lea     cut_path,A0
                moveq   #5,D1           ;*.OBJ
                bsr     change_path     ;und anhÑngen
                lea     picture_neo,A2
                lea     cut_file,A1
sssd:           move.b  (A2)+,(A1)+     ;Originalfilenamen Åbernehmen
                bne.s   sssd
                lea     cut_file,A1
                bsr     change_file     ;und .OBJ anhÑngen
                lea     cut_sext,A2
                moveq   #1,D0           ;Speichern
                bsr     fileselect
                bne     no_save2        ;Abbruch angeklickt

                move.l  #header_yes_no,D0 ;Mit oder ohne Header speichern
                bsr     alert

                move.l  SP,save_sp

                move.w  akt_work,D7     ;aktuellen Screen
                mulu    #13,D7
                lea     fn_screens,A1   ;Aktuellen Filenamen zurÅckschreiben
                adda.l  D7,A1
                lea     picture_neo,A0
copy3:          move.b  (A0)+,(A1)+
                bne.s   copy3

                bsr     fcreate
                bmi     ferror          ;Fileerror

                movea.l mem_cutter,A5   ;Speicherbereich

                cmpi.w  #1,int_out      ;Mit Header speichern?
                bne     without1        ;Nein, weiter

                movea.l A5,A6           ;ab hier speichern
                moveq   #8,D6           ;header1
                bsr     fwrite

                moveq   #9,D7           ;10 Screens
                lea     used,A0
clr_loop898:    st      (A0)+           ;unbenutzt
                dbra    D7,clr_loop898

                lea     used,A0
                lea     12(A5),A6       ;Magic+LÑnge Åberspringen
                move.w  (A6)+,D7        ;Anzahl der Objekte
                bra.s   check_used_dbra

check_used_loop:move.l  16(A6),D0       ;reserved holen
                and.w   #$00FF,D0       ;nur unteres Byte!
                clr.b   0(A0,D0.w)      ;Screen wird benutzt
                adda.l  (A6)+,A6
check_used_dbra:dbra    D7,check_used_loop

                lea     used,A0
                moveq   #9,D7
                moveq   #0,D6
count_them:     tst.b   (A0)+
                bne.s   no_count
                addq.w  #1,D6           ;Anzahl der benutzen Screens
no_count:       dbra    D7,count_them

                lea     scrollspace,A6
                mulu    #14,D6          ;Anzahl an internal Bytes berechnen
                move.w  D6,(A6)         ;und merken
                moveq   #2,D6
                bsr     fwrite          ;und Anzahl schreiben

                moveq   #9,D7           ;10 Screens
                moveq   #0,D5           ;ZÑhler
                lea     fn_screens,A3
                lea     used,A4
save_names:     tst.b   (A4)+           ;Wird dieser Screen benutzt?
                bne.s   nxt_one2
                lea     scrollspace,A6
                move.b  D5,(A6)
                moveq   #1,D6
                bsr     fwrite          ;Nummer des Screens speichern
                movea.l A3,A6
                moveq   #13,D6
                bsr     fwrite          ;Filenamen speichern
nxt_one2:       lea     13(A3),A3       ;Filenamen Åberspringen
                addq.w  #1,D5
                dbra    D7,save_names

                lea     8(A5),A6        ;header2
                addq.l  #2,(A6)         ;Bytes fÅr Anzahl=Integer
                moveq   #6,D6
                bsr     fwrite
                subq.l  #2,(A6)         ;und wieder zurÅck

                lea     12(A5),A5       ;Magic+LÑnge Åberspringen
                move.w  (A5)+,D7        ;Anzahl der Objekte holen
                moveq   #header_len,D4  ;Startoffset
                mulu    D7,D4           ;*Anzahl der Objekte
                bra.s   save_header

save_header_loop:movea.l A5,A6          ;ab hier kommt ein Header
                move.l  (A5),D5         ;LÑnge des Objekts merken
                move.l  D4,(A5)         ;und Start-Offset eintragen
                moveq   #header_len,D6  ;der ist 20 Bytes lang
                bsr     fwrite          ;Schreiben
                move.l  D5,(A5)         ;LÑnge wieder eintragen
                subi.w  #header_len-4,D5 ;LÑnge Objekt ohne Header
                ext.l   D5
                add.l   D5,D4           ;NÑchster Offset
                adda.l  (A5)+,A5        ;Objekt Åberspringen
save_header:    dbra    D7,save_header_loop

without1:       movea.l mem_cutter,A5
                lea     12(A5),A5       ;Magic+LÑnge Åberspringen
                move.w  (A5)+,D7        ;Anzahl der Objekte
                bra.s   save_daten

save_daten_loop:lea     header_len(A5),A6 ;ab hier kommen die Daten
                move.l  (A5),D6         ;LÑnge der Daten+Header
                sub.l   #header_len-4,D6 ;-LÑnge des Headers
                bsr     fwrite
                adda.l  (A5)+,A5        ;Objekt weiter
save_daten:     dbra    D7,save_daten_loop

                bsr.s   fclose          ;Datei schliessen
                bra.s   no_save2

ferror:         movea.l save_sp,SP
                bsr.s   fclose
                jsr     screen2neo
                lea     fileerror,A0
                bra     cut_status      ;und Meldung ausgeben

no_save2:       jsr     screen2neo      ;Auf Neochrom zurÅckschalten
                rts

fcreate:        clr.w   -(SP)
                pea     fsel_path
                move.w  #$003C,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                rts

fopen:          clr.w   -(SP)
                pea     fsel_path
                move.w  #$003D,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                rts

fclose:         tst.w   fhandle
                ble.s   no_opened
                move.w  fhandle,-(SP)
                move.w  #$003E,-(SP)    ;Fclose
                trap    #1
                addq.l  #4,SP
no_opened:      rts

read:           move.l  A6,-(SP)
                move.l  D6,-(SP)
                move.w  fhandle,-(SP)
                move.w  #$003F,-(SP)
                trap    #1
                lea     12(SP),SP
                cmp.l   D6,D0           ;Alles gelesen?
                rts

write:          move.l  A6,-(SP)
                move.l  D6,-(SP)
                move.w  fhandle,-(SP)
                move.w  #$0040,-(SP)
                trap    #1
                lea     12(SP),SP
                cmp.l   D6,D0           ;Alles auf Disk?
                rts

fread:          bsr.s   read
                bne     read_error      ;Fehler beim Lesen
                rts

fwrite:         bsr.s   write
                bne     ferror          ;Fehler beim Schreiben
raus_hier8:     rts

show_numbers:   movem.l D0-A6,-(SP)

                bsr     draw_r

                move.w  akt_cut_shape,D0
                lea     cut_mid(PC),A0
                bsr.s   set_shp_nr
                subq.w  #1,D0
                lea     cut_left(PC),A0
                bsr.s   set_shp_nr
                addq.w  #2,D0
                lea     cut_right(PC),A0
                bsr.s   set_shp_nr

                tst.w   board_da        ;öberhaupt ein Board da?
                bne.s   raus_hier9
                tst.b   lupe_an
                beq.s   raus_hier9
                lea     cut_left(PC),A0
                lea     cut_leftk(PC),A3
                moveq   #2,D7
                bra     redr2           ;und neu printen!

raus_hier9:     movem.l (SP)+,D0-A6
                rts

;Schreibt nach a0/a0+1 die Zahl d0, betrachtet aber die max. Zahl
;fÅr Pfeile im Cutter
set_shp_nr:     move.w  D0,D1
                tst.w   D0
                beq.s   nimm_max
                bmi.s   nimm_xx

                move.l  A0,-(SP)
                movea.l mem_cutter,A0
                cmp.w   12(A0),D0       ;Grîûer als Max?
                movea.l (SP)+,A0
                ble     wandel_fest_dez3
                moveq   #1,D1


nimm_max:       move.l  A0,-(SP)
                movea.l mem_cutter,A0
                move.w  12(A0),D1
                movea.l (SP)+,A0
                bra     wandel_fest_dez3 ;Und 'ausgeben'

nimm_xx:        cmp.w   #-1,D0          ;eins unter Max?
                beq.s   nimm_max_1
                move.b  #'X',(A0)+
                move.b  #'X',(A0)+
                move.b  #'X',(A0)+
                rts

nimm_max_1:     move.l  A0,-(SP)
                movea.l mem_cutter,A0
                move.w  12(A0),D1
                subq.w  #1,D1           ;eins drunter
                movea.l (SP)+,A0
                bra     wandel_fest_dez3 ;und 'ausgeben'

;öberprÅft, ob das aktuelle Objekt mit Rastern ist:
draw_r:         movem.l D0-A6,-(SP)

                tst.w   board_da
                bne.s   nicht_weg
                tst.b   lupe_an
                beq.s   nicht_weg
                move.w  #231,D0
                move.w  #171,D1
                move.w  #234,D2
                move.w  #174,D3
                moveq   #0,D4
                move.w  #1,D5
                bsr     fill_box        ;Altes 'r' wegmachen
nicht_weg:      tst.l   mem_cutter
                beq.s   fertig_hier
                movea.l mem_cutter,A0
                lea     14(A0),A0       ;Header1+Header2 Åberspringen
                moveq   #1,D7           ;Jetzt ist Nummer 1 dran
spr_loop27:     cmp.w   akt_cut_shape,D7 ;Sprite erreicht?
                beq.s   spr_found27     ;Ja, Eintrag gefunden
                addq.w  #1,D7           ;nÑchster Sprite
                adda.l  (A0)+,A0        ;Diesen Sprite Åberspringen!
                bra.s   spr_loop27

spr_found27:    move.w  18(A0),D0       ;Arbeitsbildschirm
                lsr.w   #8,D0           ;Rasteranzahl
                beq.s   fertig_hier     ;Keine Raster vorhaden

                tst.w   board_da
                bne.s   fertig_hier
                tst.b   lupe_an
                beq.s   fertig_hier

                move.w  #$000F,D3       ;Farbe
                moveq   #100,D2         ;Iconnummer
                move.w  #232,D0         ;x
                move.w  #171,D1         ;y
                bsr     draw_icon

fertig_hier:    movem.l (SP)+,D0-A6
                rts

;Gibt Speicher wieder frei...
new_cutter:     move.l  mem_cutter,-(SP)
                move.w  #$0049,-(SP)
                trap    #1              ;Speicher freigeben
                addq.l  #6,SP
                clr.l   mem_cutter      ;und vermerken
                move.w  #3,cut_savek    ;Mann kann nicht mehr saven
                move.w  #3,cut_savek+6  ;kein new
                move.w  #3,cut_savek+12 ;kein re-cut
                move.w  #-20,akt_cut_shape ;negativ->xx
                bsr     show_numbers
                bsr     on_off_cutter
                bra     draw_options

;Spieler will Pfeil nach rechts anklicken
right_akt:      cmpi.b  #'X',cut_right  ;Button anklickbar?
                beq.s   oben_weiter     ;Nein, weiter

                movea.l mem_cutter,A0
                lea     12(A0),A0
                move.w  (A0),D0         ;Anzahl der Shapes holen
                cmp.w   akt_cut_shape,D0 ;Hîchstzahl erreicht?
                ble.s   schon_oben      ;ja, unten weiter
                addq.w  #1,akt_cut_shape ;Ein Shape weiter
                bra.s   oben_weiter
schon_oben:     move.w  #1,akt_cut_shape
oben_weiter:    bra     show_numbers    ;Neue Nummern anzeigen


;Spieler will Pfeil nach links anklicken:
left_akt:       cmpi.b  #'X',cut_left   ;Button anklickbar?
                beq.s   ohne_sub        ;Nein, weiter

                cmpi.w  #1,akt_cut_shape ;unten angekommen?
                bne.s   schon_unten
                movea.l mem_cutter,A0
                move.w  12(A0),akt_cut_shape ;Max_nummer gehts weiter
                bra.s   ohne_sub
schon_unten:    subq.w  #1,akt_cut_shape ;Ein Shape weiter
ohne_sub:       bra     show_numbers    ;Neue Nummern anzeigen


;Spieler will aktuellen anzeigen, Klick mit Maus
show_akt_btn:   sf      ohne_raster     ;Keine Raster abspeichern
                btst    #1,maus_status  ;Rechts geklickt?
                beq.s   show_akt        ;Nein->Weiter
                st      ohne_raster     ;mit Raster bitte
                bra.s   show_akt

;Spieler will aktuellen anzeigen, Fkey
show_akt_fkey:  bsr     get_shift
                moveq   #0,D0
                move.b  right_shift,D0
                or.b    any_shift,D0
                move.b  D0,ohne_raster

;Spieler will sich aktives Shape anzeigen lassen
show_akt:       cmpi.b  #'X',cut_mid    ;öberhaupt was da?
                beq     show_end        ;Nein, kein Sprite im Work-Bereich
                movea.l mem_cutter,A0
                lea     14(A0),A0       ;Header1+Header2 Åberspringen
                moveq   #1,D7           ;Jetzt ist Nummer 1 dran
spr_loop2:      cmp.w   akt_cut_shape,D7 ;Sprite erreicht?
                beq.s   spr_found       ;Ja, Eintrag gefunden
                addq.w  #1,D7           ;nÑchster Sprite
                adda.l  (A0)+,A0        ;Diesen Sprite Åberspringen!
                bra.s   spr_loop2

spr_found:      move.l  16(A0),D0       ;Arbeitsbildschirm
                and.w   #$00FF,D0       ;nur Bits 0..7
                cmp.w   anz_screens,D0  ;Grîûer als Screenzahl
                bgt     cant_show
                btst    #0,copy_status  ;Schon ein Rahmen da?
                bne.s   ss2
                jsr     delete_cut_rahm ;Alten Rahmen weg!
ss2:            cmp.w   akt_work,D0     ;Ist dieser aktiv?
                beq.s   ok56
                bsr     show_workscreen ;Nein, dann anzeigen
ok56:           move.w  12(A0),ani_x1
                move.w  14(A0),ani_y1
                move.w  12(A0),ani_x4
                move.w  14(A0),ani_y4
                move.w  4(A0),D0        ;Breite holen
                subq.w  #1,D0           ;Breite--
                add.w   D0,ani_x4
                move.w  6(A0),D0
                subq.w  #1,D0           ;Hîhe--
                add.w   D0,ani_y4

                tst.b   ohne_raster
                beq     nicht_kopieren

                movem.l D0-A6,-(SP)

                lea     bb,A6           ;verschieben des Objektes nach 0/0

                move.w  4(A0),(A6)      ;Breite in Pixeln
                move.w  6(A0),2(A6)     ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #15,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                clr.l   14(A6)          ;x/y=0
                lea     header_len(A0),A1 ;Quelladresse
                move.l  A1,18(A6)       ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  10(A0),24(A6)   ;Breite Bytes
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                move.w  ani_x1,28(A6)   ;Zielkoordinaten
                move.w  ani_y1,30(A6)
                move.l  komplettbild,32(A6) ;Zieladresse
                move.w  #8,36(A6)       ;Offset zurselben Plane
                move.w  #160,38(A6)
                move.w  #2,40(A6)
                clr.l   42(A6)          ;Keine Maske
                linea   #7 [ Bitblk ]

                movem.l (SP),D0-A6      ;Register wieder her

                move.w  18(A0),D7
                lsr.w   #8,D7           ;Anzahl an Rastern?
                move.w  10(A0),D0       ;Breite Bytes
                mulu    6(A0),D0        ;*Hîhe=Anzahl Bytes
                lea     header_len(A0),A0
                adda.l  D0,A0           ;=Start der Raster
                bra.s   rst_dbra
rst_loop:       lea     hbl_system,A1
                move.w  ani_y1,D0
                add.w   D0,(A0)         ;+Startposition des Objektes
                jsr     update_raster   ;und in Rastersystem eintragen
                sub.w   D0,(A0)         ;und wieder abziehen
                lea     34(A0),A0       ;und nÑchsten Raster
rst_dbra:       dbra    D7,rst_loop

                jsr     palette_changed ;und Raster neu anzeigen

                movem.l (SP)+,D0-A6

nicht_kopieren: tst.w   board_da
                bne.s   show_spr
                jsr     calc_grab       ;Richtige Grabber-Einstellung berechnen
                jsr     neue_raster     ;Raster neu berechnen

                movea.l komplettbild,A0
                movea.l scr1,A1
                move.w  grab_y,D0
                mulu    #160,D0
                adda.w  D0,A0
                move.w  #999,D0
show_work:      move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Oberen 100 Zeilen vom Komplettbild
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,show_work
show_spr:       movea.l scr1,A1
                jsr     ani_box
                move.b  #%00000011,copy_status ;Wieder ausgeschnitten
                bsr     on_off_cutter   ;an/aus-Schalten
                bsr     redraw_cut_opt  ;ggf. anzeigen
show_end:       rts

;User will ein Object anzeigen lassen, das in einem Screen liegt, dessen
;Nummer grîûer als der grîûte jetzt ist:
cant_show:      move.l  #cant_show_obj,D0
                bra     switch_alert

;Spieler will sÑmtliche Sprites recutten (CHS)
recut:          tst.l   mem_cutter      ;öberhaupt Speicher da?
                beq     no_rect         ;Nein, Raus

                movea.l mem_cutter,A0
                lea     12(A0),A0       ;Header Åberspringen
                move.w  (A0)+,D7        ;Anzahl der Objekte holen
                moveq   #1,D6           ;Object-ZÑhler
                bra     recut_dbra

recut_loop:     move.w  6(A0),D0        ;Hîhe in Pixeln
                mulu    10(A0),D0       ;*Breite_Bytes=Gesamtgrîûe
                lsr.l   #2,D0
                lea     header_len(A0),A6 ;Start der Objektdaten
                bra.s   clr2_dbra
clr2:           clr.l   (A6)+           ;Zuerst den Speicher lîschen
clr2_dbra:      dbra    D0,clr2

                lea     bb,A6           ;verschieben des Objektes nach 0/0
                move.w  4(A0),(A6)      ;Breite in Pixeln
                move.w  6(A0),2(A6)     ;Hîhe in Pixeln
                move.w  #4,4(A6)        ;4 Planes
                move.w  #15,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                move.l  #$03030303,10(A6) ;Operation 3=Copy
                move.w  12(A0),14(A6)   ;X-Source
                move.w  14(A0),16(A6)   ;Y-Source
                movea.l komplettbild,A1 ;Default: komplettbild
                lea     hbl_system,A2   ;Default: aktuelle Raster
                move.l  16(A0),D0       ;Reserved
                and.w   #$00FF,D0       ;Nur Screennummer isolieren
                cmp.w   akt_work,D0     ;aktueller Screen?
                beq.s   nimm_aktuellen  ;Ja, also aktuellen Screen nehmen
                cmp.w   anz_screens,D0
                bgt     cant_recut      ;zu groû?
                lea     work_tab,A1
                lsl.w   #2,D0           ;mal 4
                movea.l 0(A1,D0.w),A1   ;Screenadresse holen
                lsr.w   #2,D0           ;Screennummer
                mulu    #2*anz_raster*(1+16),D0
                movea.l hbls,A2
                adda.l  D0,A2           ;Adresse der HBL-Palette dieses Bildes
nimm_aktuellen: move.l  A1,18(A6)       ;Quelladresse
                move.w  #8,22(A6)       ;Offset zum nÑchsten Wort derselben Plane
                move.w  #160,24(A6)
                move.w  #2,26(A6)       ;Offset zur nÑchsten Plane
                clr.l   28(A6)          ;Zielkoordinaten 0/0
                lea     header_len(A0),A1 ;Hinter Objekt Header
                move.l  A1,32(A6)       ;Zieladresse
                move.w  #8,36(A6)       ;Offset zurselben Plane
                move.w  10(A0),38(A6)   ;Breite in Bytes
                move.w  #2,40(A6)
                clr.l   42(A6)          ;Keine Maske
                movem.l D0-A6,-(SP)     ;Register retten
                linea   #7 [ Bitblk ]
                movem.l (SP)+,D0-A6     ;und wieder her
                move.w  18(A0),D0       ;Anzahl Raster+Workscreen
                lsr.w   #8,D0
                beq     nxt_object      ;Keine Raster abgespeichert...->weiter

                movem.l D0-A6,-(SP)     ;Register sichern
                movea.l A0,A3           ;Aktuelles Objekt
                move.w  D0,D7           ;Anzahl an alten Rastern

                move.w  14(A0),D0       ;Y-Start
                move.w  D0,D1
                add.w   6(A0),D1        ;+Hîhe=Ende
                subq.w  #1,D1           ;Y_Ende
                movea.l A2,A0
                bsr     sammel_raster   ;und alle Raster in dem Bereich sammeln
                move.w  D0,raster_platz
                moveq   #0,D1
                move.w  D0,D1           ;Anzahl an Bytes
                divu    #34,D1          ;=Anzahl an neuen Rastern
                cmp.w   D7,D1           ;Jetzt weniger Raster?
                ble.s   passt_rein      ;Ja, Paût also
                sub.w   D7,D1           ;Anzahl an zusÑtzlichen Rastern
                mulu    #34,D1          ;Anzahl an zusÑtzlichem Platz

                movea.l mem_cutter,A0   ;Speicherbereich
                move.l  8(A0),D0        ;Grîûe der Objekte holen
                add.l   #8+6,D0         ;+Header1,Header2
                move.l  mem_lÑnge,D2
                sub.l   D0,D2           ;Soviel ist noch frei
                cmp.l   D1,D2
                bge.s   passt_rein
                bsr     less_mem
                bra     nxt_oobj
passt_rein:     move.w  6(A3),D6        ;Hîhe des Objekts
                mulu    10(A3),D6       ;*Breite=Grîûe des Objekts
                lea     header_len(A3),A0 ;Start der Objektdaten
                adda.l  D6,A0           ;Start der Rasterdaten
                movea.l A0,A1
                mulu    #34,D7          ;Grîûe der alten Raster
                adda.l  D7,A0           ;Ende der alten Raster nach Quelle
                move.l  A0,D2           ;Ende der alten Raster
                move.l  mem_cutter,D0
                add.l   #8+6,D0         ;Start der Objekte
                sub.l   D0,D2           ;=Platz bis zu den Rastern
                movea.l mem_cutter,A2
                move.l  8(A2),D0        ;Grîûe der Objekte
                sub.l   D2,D0           ;von Dateigrîûe abziehen=Anzahl Restbytes
                bsr     memcpy          ;und alte Raster weglîschen
                sub.l   D7,8(A2)        ;von Dateigrîûe abziehen
                sub.l   D7,(A3)         ;und von Offset abziehen
                movea.l A1,A0           ;Start des nÑchsten Objekts
                adda.w  raster_platz,A1 ;Zieladresse
                move.l  8(A2),D0        ;Grîûe der Datei
                movea.l A0,A2           ;Startadresse nÑchstes Objekt
                move.l  mem_cutter,D7
                add.l   #8+6,D7         ;Startadresse der Objekte
                suba.l  D7,A2           ;=Bytes bis hierhin
                sub.l   A2,D0           ;von Dateigrîûe abziehen=Anzahl Restbytes
                bsr     memcpy          ;und Platz fÅr neue Raster schaffen
                moveq   #0,D7
                move.w  raster_platz,D7
                movea.l mem_cutter,A2
                add.l   D7,8(A2)        ;Neue Rastergrîûe zu Dateigrîûe addieren
                add.l   D7,(A3)         ;und zu aktuellem Offset
                divu    #34,D7          ;Anzahl an neuen Rastern
                move.b  D7,18(A3)       ;und eintragen

                lea     rasters2,A1
                move.w  raster_platz,D7
                bra.s   in_loop623
copy_loop90:    move.b  (A1)+,(A0)+     ;Neue Raster Åbertragen
in_loop623:     dbra    D7,copy_loop90

nxt_oobj:       movem.l (SP)+,D0-A6     ;Register wieder her

nxt_object:     adda.l  (A0)+,A0        ;und nÑchstes Objekt
                addq.w  #1,D6           ;nÑchste Nummer
recut_dbra:     dbra    D7,recut_loop
no_rect:        bra     wait_los        ;Knopf wieder loslassen bitte

cant_recut:     movem.l D0-A6,-(SP)

                move.w  D6,D1           ;In String eintragen
                lea     cant_recut_obj+26,A0
                bsr     wandel_fest_dez3

                move.l  #cant_recut_obj,D0
                bsr     switch_alert    ;und anzeigen

                movem.l (SP)+,D0-A6

                cmpi.w  #1,int_out      ;Skip?
                beq.s   nxt_object      ;ja->Skip
                bra.s   no_rect         ;Cancel

;Diese Funktion bestimmt alle Raster, in einem bestimmten Bildschirmbereich:
;Diese werden dann in rasters2 aufgebaut. Gibt in D0.W die LÑnge des Raster-
;speichers zurÅck.
; D0.W: Start_y
;  D1.W: End_y
;  A0.L: Adresse des HBL-Systems
sammel_raster:  movem.l D1-A6,-(SP)

                move.w  D0,start_y
                move.w  D1,end_y

                lea     rasters2,A2     ;Hier Raster aufbauen

                moveq   #0,D5           ;Min-Wert
                move.w  start_y,D6      ;Startwert
                beq.s   vbl_nehmen      ;=0->VBL-Palette
                movea.l A0,A3           ;HBL-System
                move.w  #anz_raster-1,D7
such_it2:       move.w  (A3),D0         ;Aktueller Raster
                beq.s   nicht_aktiv
                cmp.w   D5,D0           ;Grîûer als bisher kleinster?
                ble.s   nicht_aktiv
                cmp.w   D6,D0           ;Kleiner als Startwert?
                bgt.s   nicht_aktiv
                move.w  (A3),D5         ;Ist jetzt grîûter
                movea.l A3,A1           ;Position merken
nicht_aktiv:    lea     34(A3),A3
                dbra    D7,such_it2

                tst.w   D5              ;Raster gefunden?
                bne.s   a1_nehmen       ;Ja->Nehmen

vbl_nehmen:     movea.l A0,A1           ;VBL-Palette als 1. Raster

a1_nehmen:      moveq   #16,D7          ;17 Worte Åbertragen
copy42:         move.w  (A1)+,(A2)+
                dbra    D7,copy42

                move.w  start_y,D6      ;Startwert
nÑchsten_suchen:move.w  #1000,D5
                movea.l A0,A3           ;HBL-System
                move.w  #anz_raster-1,D7
such_it3:       move.w  (A3),D0         ;Aktuellen Raster holen
                beq.s   nicht_aktiv2
                cmp.w   D5,D0           ;Kleiner als bisher kleinster?
                bge.s   nicht_aktiv2
                cmp.w   D6,D0           ;Grîûer als Startwert?
                ble.s   nicht_aktiv2
                move.w  (A3),D5
                movea.l A3,A1
nicht_aktiv2:   lea     34(A3),A3
                dbra    D7,such_it3

                cmp.w   end_y,D5        ;Grîûer als Unterer Rand?
                bgt.s   fertig3

                moveq   #16,D7
copy43:         move.w  (A1)+,(A2)+
                dbra    D7,copy43

                move.w  D5,D6           ;Neuer Startwert=Dieser Raster
                bra.s   nÑchsten_suchen

fertig3:        lea     rasters2,A3
                move.w  start_y,D0
                tst.w   (A3)            ;VBL-Palette?
                beq.s   nicht_angleichen
angleichen:     sub.w   D0,(A3)
nicht_angleichen:lea    34(A3),A3
                cmpa.l  A2,A3
                blt.s   angleichen

                suba.l  #rasters2,A2    ;Platzbedarf
                move.l  A2,D0           ;zurÅckgeben

                movem.l (SP)+,D1-A6
                rts


;Spieler will aktuellen ersetzen, Klick mit Maus
replace_akt_btn:sf      ohne_raster     ;Keine Raster abspeichern
                btst    #1,maus_status  ;Rechts geklickt?
                beq.s   rplc_akt        ;Nein->Weiter
                st      ohne_raster     ;mit Raster bitte
                bra.s   rplc_akt

;Spieler will aktuellen ersetzen
replace_akt_fkey:bsr    get_shift
                moveq   #0,D0
                move.b  right_shift,D0
                or.b    any_shift,D0
                move.b  D0,ohne_raster

rplc_akt:       tst.w   cut_rplck       ;Replace erlaubt?
                bne     kann_man        ;Nein, ->RTS

                movem.l D0-A6,-(SP)

                tst.b   ohne_raster     ;Mit Raster abspeichern?
                bne.s   allright1       ;Ja, alles okay

                movea.l mem_cutter,A0
                lea     14(A0),A0       ;Header1+Header2 Åberspringen
                moveq   #1,D7           ;Jetzt ist Nummer 1 dran
spr_loop26:     cmp.w   akt_cut_shape,D7 ;Sprite erreicht?
                beq.s   spr_found26     ;Ja, Eintrag gefunden
                addq.w  #1,D7           ;nÑchster Sprite
                adda.l  (A0)+,A0        ;Diesen Sprite Åberspringen!
                bra.s   spr_loop26

spr_found26:    move.w  18(A0),D0       ;Arbeitsbildschirm+Rasterzahl
                lsr.w   #8,D0
                beq.s   allright1       ;Es waren keine Raster abgespeichert

                move.b  #8,function     ;Damit wird Cutter nicht abgemeldet
                move.l  #del_raster,D0
                bsr     switch_alert
                move.b  #7,function     ;und Cutter wieder an
                cmpi.w  #1,int_out      ;Raster beibehalten?
                bne.s   allright1       ;Nein, also lîschen
                st      ohne_raster     ;Ja, also mit Rastern abspeichern
allright1:      movem.l (SP)+,D0-A6

                move.w  akt_cut_shape,D7 ;Aktuelles Objekt merken
                bsr     del_akt         ;Aktuellen Button lîschen
                cmp.w   #1,D7           ;Wurde Objekt #1 gelîscht?
                bne.s   add_akt         ;Nein, also normal hinzufÅgen
                clr.w   akt_cut_shape   ;dann 'vor' 1. Objekt speichern
                bra.s   add_akt

;User will Objekt hinzufÅgen hat dafÅr auf 'add' geklickt
add_akt_btn:    sf      ohne_raster     ;Keine Raster abspeichern

                btst    #1,maus_status  ;Rechts geklickt?
                beq.s   add_akt         ;Nein->Weiter

                st      ohne_raster     ;mit Raster bitte
                bra.s   add_akt

;User will Objekt mit allen Rastern abspeichern
add_akt_fkey:   bsr     get_shift
                moveq   #0,D0
                move.b  right_shift,D0
                or.b    any_shift,D0
                move.b  D0,ohne_raster

;Spieler will Shape hinzufÅgen
add_akt:        tst.w   cut_addk        ;Button anklickbar?
                bne     kann_man        ;Nein->RTS
                btst    #0,copy_status  ;Rahmen zu sehen?
                bne.s   was_da
                bsr     pling
                lea     what,A0
                bsr     cut_status
                bra     kann_man        ;->RTS
was_da:         moveq   #0,D0           ;zusÑtzlicher Speicherbedarf fÅr Raster
                tst.b   ohne_raster
                beq.s   ohne_raster2

                move.w  ani_y1,D0
                move.w  ani_y4,D1
                lea     hbl_system,A0
                bsr     sammel_raster   ;und alle Raster in dem Bereich einsammeln
ohne_raster2:   move.w  D0,raster_platz

                move.w  ani_x4,D2
                sub.w   ani_x1,D2       ;Breite in Pixel berechnen
                addq.w  #1,D2
                move.w  ani_y4,D3
                sub.w   ani_y1,D3
                addq.w  #1,D3           ;Hîhe in Pixeln berechnen
                move.w  D2,D4           ;Breite->D4
                add.w   #15,D4
                lsr.w   #4,D4
                lsl.w   #3,D4           ;Breite in Bytes berechnen
                move.w  D4,D5
                mulu    D3,D4           ;Breite x Hîhe=Anzahl Bytes
                add.l   #header_len,D4  ;fÅr Header...
                ext.l   D0
                add.l   D0,D4           ;+Speicher fÅr Raster
                tst.l   mem_cutter      ;Speicher schon da?
                bne.s   schon_da
                bsr     get_free_mem
                cmp.l   D4,D0           ;Soviel noch frei?
                bge.s   enough_mem      ;Ja, GlÅck oder MEGA ST 4 gehabt..
                bsr     less_mem
                bra     kann_man        ;->RTS
enough_mem:     move.l  D0,mem_lÑnge    ;LÑnge des Speichers merken
                move.l  D0,-(SP)
                move.w  #$0048,-(SP)    ;Allen Speicher her!
                trap    #1
                addq.l  #6,SP
                move.l  D0,mem_cutter   ;und Startadresse merken
                movea.l D0,A0
                move.l  #'NEOO',(A0)+   ;Magic Schreiben
                move.l  #version,(A0)+  ;+ Versionsnummer
                clr.l   (A0)+           ;0 Bytes verwendet
                clr.w   (A0)            ;kein Eintrag da

schon_da:       movea.l mem_cutter,A0   ;Speicherbereich
                lea     8(A0),A0        ;Header Åberspringen
                move.l  (A0),D0         ;Grîûe der Datei ermitteln
                move.l  mem_lÑnge,D1
                sub.l   D0,D1           ;Soviel ist noch frei
                cmp.l   D4,D1
                bge.s   enough_mem2
                bsr     less_mem
                bra     kann_man        ;->RTS
enough_mem2:    lea     6(A0),A1        ;Header2 Åberspringen
                tst.w   4(A0)           ;Anzahl der Objekte
                beq.s   no_aufschieben  ;Bisher keines, also hier rein!

                tst.w   akt_cut_shape   ;'vor' dem 1. Objekt?
                beq.s   vor_erstes      ;Ja, dann ganz vorne einfÅgen

                moveq   #1,D7           ;Aktuelle Objektnummer
such_loop5:     cmp.w   akt_cut_shape,D7 ;Ist es dieses hier?
                beq.s   spr_found2      ;ja!
                addq.w  #1,D7           ;Ein Objekt weiter
                adda.l  (A1)+,A1        ;Objekt Åberspringen
                bra.s   such_loop5
spr_found2:     adda.l  (A1)+,A1        ;Hinter dieses Objekt einfÅgen
                cmp.w   4(A0),D7        ;Letztes Objekt?
                beq.s   no_aufschieben  ;ja, dann nicht verschieben

vor_erstes:     movem.l D0-A6,-(SP)     ;Register sichern

                lea     6(A0),A2        ;Start des Objektspeichers
                adda.l  (A0),A2         ;+Grîûe=Ende des Objektspeichers!
                movea.l A2,A4
                adda.l  D4,A4           ;Zieladresse

                move.l  A2,D4
                sub.l   A1,D4           ;Grîûe des zu verschiebenden Bereichs

                move.l  D4,D7           ;Grîûe des Bereichs
                lsr.l   #5,D7           ;/32
                bra.s   in_loop

trans_loop:     lea     -32(A2),A2
                movem.l (A2),D0-D3/D5-D6/A3/A5 ;32 Bytes
                movem.l D0-D3/D5-D6/A3/A5,-(A4) ;32 Bytes
in_loop:        dbra    D7,trans_loop

                and.w   #%0000000000011111,D4 ;Rest bei 32
                bra.s   in_loop2
trans_loop2:    move.b  -(A2),-(A4)     ;Rest koieren
in_loop2:       dbra    D4,trans_loop2

drÅber89:       movem.l (SP)+,D0-A6     ;Register wieder her

no_aufschieben: movea.l A1,A6           ;Zuerst den Speicher lîschen
                move.l  D4,D7           ;LÑnge des Bereichs
                lsr.l   #2,D7
                bra.s   clr_dbra
clr:            clr.l   (A6)+           ;und Speicher lîschen
clr_dbra:       dbra    D7,clr

                add.l   D4,(A0)+        ;Soviel Bytes sind jetzt mehr
                addq.w  #1,(A0)+        ;Ein Objekt mehr

                move.l  D4,(A1)         ;Soviel Bytes kommen jetzt
                subq.l  #4,(A1)+        ;minus diese 4
                move.w  D2,(A1)+        ;Breite
                move.w  D3,(A1)+        ;Hîhe
                clr.b   (A1)+           ;Keine Maske da
                move.b  #4,(A1)+        ;4 Planes
                move.w  D5,(A1)+        ;Breite in Bytes
                moveq   #0,D7           ;Ausgleichswort fÅr Grabberverschiebung
                tst.w   board_da        ;Ist ein Board da?
                bne.s   ok87
                move.w  grab_y,D7
ok87:           move.w  ani_x1,(A1)+    ;X im Bild
                move.w  ani_y1,(A1)     ;Y im Bild
                add.w   D7,(A1)+        ;+Ausgleich fÅr Grabber
                moveq   #0,D4
                move.w  raster_platz,D4
                divu    #34,D4          ;Anzahl an Rastern
                lsl.w   #8,D4           ;an Bits 8..15
                move.b  akt_work+1,D4   ;aktueller Arbeitsbildschirm 0..7
                move.l  D4,(A1)+

                movem.l D3/D5/A1,-(SP)

                lea     bitblit,A6      ;hier Parameter aufbauen
                move.w  D2,0(A6)        ;Breite des Blocks in Pixeln
                move.w  D3,2(A6)        ;Hîhe des Blocks in Pixeln
                move.l  komplettbild,18(A6) ;Anfangsadresse des Quellrasters
                move.l  A1,32(A6)       ;Anfangsadresse des Zielrasters

                move.w  ani_x1,14(A6)   ;X des Quellrasters
                move.w  ani_y1,16(A6)   ;Y des Quellrasters
                add.w   D7,16(A6)       ;+Grabberverschiebung
                move.w  #0,28(A6)       ;X des Zielrasters
                move.w  #0,30(A6)       ;Y des Zielrasters
                move.w  #8,22(A6)       ;Source-Offset zum nÑchsten Wort
                move.w  #160,24(A6)     ;Breite des Quellrasters in Bytes
                move.w  #2,26(A6)       ;Source-Offset zur nÑchstes Plane
                move.w  #4,4(A6)        ;Anzahl der Planes
                moveq   #8,D4           ;Offset zur gleichen Plane
                move.w  D2,D1           ;Breite in Pixeln
                addi.w  #$000F,D1       ;auf nÑchsten BB
                lsr.w   #4,D1
                lsl.w   #3,D1           ;Breite in Bytes
                move.w  D4,36(A6)       ;Dest-Offset zur gleichen Plane
                lsr.w   #2,D4           ;durch 4
                move.w  D4,40(A6)       ;Offset zur nÑchsten Plane
                move.w  D1,D2
                move.w  D2,38(A6)       ;Breite des Zielrasters in Bytes
                mulu    D2,D3           ;Breite mal Hîhe
                lsr.w   #1,D3           ;/2
                move.l  #$03030303,10(A6) ;operation
                linea   #7 [ Bitblk ]   ;kopieren

                movem.l (SP)+,D3/D5/A1
                mulu    D3,D5           ;Breite*Hîhe
                adda.l  D5,A1           ;Ende der Daten
                lea     rasters2,A0
                move.w  raster_platz,D0
                bra.s   copy_dbra2
copy_raster2:   move.b  (A0)+,(A1)+     ;Raster anhÑngen
copy_dbra2:     dbra    D0,copy_raster2

                tst.w   akt_cut_shape
                bpl.s   nxt_shape
                clr.w   akt_cut_shape
nxt_shape:      addq.w  #1,akt_cut_shape ;ein Shape weiter
                bsr     show_numbers

                tst.w   cut_savek       ;Kann man schon saven?
                beq.s   kann_man        ;ja
                bsr     on_off_cutter   ;Buttons an/Aus schalten
                clr.w   cut_savek       ;Mann kann jetzt saven
                clr.w   cut_savek+6     ;und new
                clr.w   cut_savek+12    ;und re-cut
                bsr     draw_options
kann_man:       rts

;Lîscht den aktuellen Shape
del_akt:        cmpi.b  #'X',cut_mid    ;Aktuelles Shape da?
                beq.s   del_akt_raus    ;Nein

                movem.l D0-A6,-(SP)

                movem.l mem_cutter,A0
                lea     8(A0),A0        ;Header1 Åberspringen
                lea     6(A0),A1
                moveq   #1,D7           ;Hier startet das erste Objekt
such_loop3:     cmp.w   akt_cut_shape,D7 ;Ist hier das aktuelle?
                beq.s   spr_found3      ;ja
                adda.l  (A1)+,A1        ;Nein, dieses Objekt Åberspringen
                addq.w  #1,D7
                bra.s   such_loop3
spr_found3:     move.l  (A1),D4         ;Anzahl der Bytes, die kommen
                addq.l  #4,D4           ;+diese 4 Bytes=LÑnge des Objektes

                movea.l A1,A2
                adda.l  D4,A2           ;Ende des Objektes

                cmpi.w  #1,akt_cut_shape ;Bei Objekt eins?
                ble.s   no_sub          ;Nicht vermindern
                subq.w  #1,akt_cut_shape ;Eins zurÅck gehen
no_sub:         movea.l (A0),A3         ;Grîûe des Speichers
                adda.l  A0,A3           ;Ende des Speichers
                addq.l  #6,A3

                sub.l   D4,(A0)+        ;Soviel Bytes weniger
                subq.w  #1,(A0)         ;Ein Objekt weniger
                bne.s   trans_loop3     ;Noch eines da...
                bsr     new_cutter      ;gesamten Speicher freigeben
                bra.s   und_raus2

trans_loop3:    movem.l (A2)+,D0-D7/A4-A6
                movem.l D0-D7/A4-A6,(A1)
                lea     44(A1),A1
                cmpa.l  A3,A2           ;Ende des Speichers erreicht?
                blt.s   trans_loop3     ;Nein, weiter verschieben

und_raus2:      bsr     show_numbers    ;Neue Werte anzeigen
                movem.l (SP)+,D0-A6
del_akt_raus:   rts

;Ruft Fileselektor auf und schaltet anschliessend wieder auf den NEOchrome Arbeitsbildschirm
;A0: Pfad (wird erneuert)
;A1: Filename (wird erneuert)
;A2: Extended Info, nur bei TOS 1.4
;D0: 0=Load, 1=Save
;RÅckgabe des kompletten Pfades+Filename in A0
;bne abbruch
user_fileselect:bsr     fileselect

                move    SR,-(SP)        ;Flags retten
                movem.l D0-A6,-(SP)     ;Register retten

                bsr     neo_an          ;ZurÅck zum Arbeitsbildschirm

                movem.l (SP)+,D0-A6
                move    (SP)+,CCR
                rts

;A0: Pfad (wird erneuert)
;A1: Filename (wird erneuert)
;A2: Extended Info, nur bei TOS 1.4
;D0: 0=Load, 1=Save
;RÅckgabe des kompletten Pfades+Filename in A0
;bne abbruch
fileselect:     move.b  D0,load_flag    ;1=Save, 0=load

                movem.l D0-A6,-(SP)

                move.l  A1,-(SP)        ;a1 retten
                lea     old_fn,A6
copy_it69:      move.b  (A1)+,(A6)+     ;Alten Filenamen retten
                bne.s   copy_it69
                movea.l (SP)+,A1        ;a1 wieder her!

fsel_again:     jsr     alle_irqs_aus
                bsr     Hm
                jsr     switch2tos      ;Desktop anschalten

                move.w  #0,int_in       ;Pfeil setzen
                move.l  #graf_mouse,D0
                bsr     _aes
                bsr     Sm
                movem.l (SP),D0-A6      ;Parameter wieder holen

                cmpi.w  #$0104,tos_version
                bge.s   ext_fileselect

                movea.l A2,A0
                moveq   #0,D0
                bsr     center_print    ;Printet zentriert

                movem.l (SP),D0-A6
                lea     addr_in,A3
                move.l  A0,(A3)+        ;Path
                move.l  A1,(A3)         ;File
                move.l  #fsel_input,D0
                bsr     _aes
                bra.s   gem2

ext_fileselect:
                lea     addr_in,A3
                move.l  A0,(A3)+
                move.l  A1,(A3)+
                move.l  A2,(A3)
                move.l  #fsel_exinput,D0
                bsr     _aes
gem2:           cmpi.w  #1,int_out+2    ;Wurde Okay gewÑhlt?
                bne     abbruch2

                bsr     build_pathfn    ;in fsel_path den kompletten aufbauen

                clr.w   -(SP)
                pea     fsel_path
                move.w  #$004E,-(SP)
                trap    #1
                addq.l  #8,SP

                tst.b   load_flag       ;Laden?
                beq.s   load_fsel       ;ja

                tst.l   D0
                bmi.s   okay_fsel       ;File nicht da, Okay

                lea     L00D1,A2
                move.w  #11,D0          ;11 Zeichen lang
fÅll_loop:      move.b  (A1)+,D1        ;Zeichen aus Filename holen
                beq.s   end_fn
                move.b  D1,(A2)+        ;und speichern
                dbra    D0,fÅll_loop
                bra.s   end_fÅll
end_fn:         move.b  #' ',(A2)+      ;Mit Spaces auffÅllen
                dbra    D0,end_fn

end_fÅll:       bsr     Hm
                jsr     switch2tos
                bsr     Sm

                move.l  #L00D0,D0       ;Overwrite existing...
                bsr     alert
                move.w  int_out,D1
                cmpi.w  #1,D1
                bne     fsel_again
                bra.s   okay_fsel

load_fsel:      tst.l   D0              ;File vorhanden?
                bpl.s   okay_fsel       ;ja, okay

                bsr     Hm
                jsr     switch2tos
                bsr     Sm

                move.l  #filenotfound,D0 ;Disk file not found
                bsr     alert
                bra     fsel_again

okay_fsel:      moveq   #0,D0           ;okay gewÑhlt, Z setzen
abbruch3:       movem.l (SP)+,D0-A6
                lea     fsel_path,A0    ;Pfad zurÅckgeben
                rts

abbruch2:       movem.l (SP),D0-A6      ;Alte Registerwerte holen
                lea     old_fn,A0       ;Alten Filenamen
copy_it70:      move.b  (A0)+,(A1)+     ;kopieren
                bne.s   copy_it70
                moveq   #1,D0           ;Z lîschen->Abbruch
                bra.s   abbruch3        ;und weiter im Konzept

misc_routinen:          DC.L ste_change
                        DC.L blitter_change
                        DC.L magnify_change
                        DC.L y_change
                        DC.L nop_change
                        DC.L typ_change
                        DC.L segment_change
                        DC.L color_change
                        DC.L port_change
                        DC.L music_change
                        DC.L saver_change
                        DC.L sync_change
                        DC.L select_user1
                        DC.L select_user2

;Bedient die Options von Miscelanous..
AND_opt:        cmp.w   #189,D1         ;Save?
                bge     save_options    ;ja, alle Options sichern
                cmpi.w  #140,D1
                bcs     L04F3           ;Kleiner ->RTS
                cmpi.w  #200,D0
                bcs     L04F3           ;X kleiner 200->RTS
                cmpi.w  #312,D0
                bcc     L04F3           ;Grîûer 312->raus

                move.w  D1,D3           ;Maus_y
                sub.w   #140,D3
                ext.l   D3
                divu    #7,D3           ;Buttonnummer berechnen

                lea     misc_routinen,A0
                cmpi.w  #259,D0         ;Vielleicht x/y an/abschalten
                bcs     linke_seite     ;ja...
                lea     7*4(A0),A0      ;7 Routinen pro Seite
linke_seite:    lsl.w   #2,D3           ;mal 4
                movea.l 0(A0,D3.w),A0
                jsr     (A0)            ;und Routine starten
                bra     haken_aus

typ_change:     btst    #0,D2           ;Rechts geklickt?
                bne     lupe_plus
                btst    #1,D2           ;Links geklickt?
                bne     lupe_minus
                rts

mag_typ_ausgabe:movem.l D0-A6,-(SP)

                move.w  magtyp,D0
                add.w   #'0',D0
                move.b  D0,mag_str+5

                tst.w   board_da
                bne.s   rts79
                tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   rts79           ;ja->RTS
                cmpi.b  #6,function     ;Miscellany angeschaltet?
                bne.s   rts79           ;Nein->keine Ausgabe
                move.w  magtyp_strk+2,D0 ;X
                move.w  magtyp_strk+4,D1 ;Y
                moveq   #0,D2
                lea     mag_str,A0
                bsr     print6x6
rts79:          movem.l (SP)+,D0-A6
rts78:          rts

lupe_plus:      tst.w   board_da
                bne.s   rts78
                cmpi.w  #3,magtyp
                bge.s   rts78
                addq.w  #1,magtyp       ;Nur bei Assemblerversion ermîglichen
neue_lupe:      bsr     mag_typ_ausgabe ;und ggf. in Options eintragen
                tst.w   magtyp          ;Ist NEOchrome Lupe an?
                beq.s   lupe_aufbauen
                btst    #0,mouse_pos    ;Jetzt im Board?
                beq.s   lupe_aufbauen   ;ja->nichts machen
                movea.l scr1,A0
                move.w  magtyp,D0
                bsr     clear_lupe      ;Lupe verÑndern
                jsr     copy_board
lupe_aufbauen:  bsr     get_maus        ;Koordinaten fÅr check_lupe holen
                jmp     check_lupe      ;und Lupe anzeigen

lupe_minus:     tst.w   board_da
                bne.s   rts78
                tst.w   magtyp          ;Kann noch runter gezÑhlt werden?
                ble.s   rts78           ;Nein->RTS
                subq.w  #1,magtyp
                bne     neue_lupe       ;noch eine groûe Lupe
                bsr     mag_typ_ausgabe
                st      lupe_an         ;Die groûe Lupe ist aus
                bsr     get_maus        ;Mauskoordinaten holen
                bsr     draw_board
                jsr     copy_board
                bra.s   lupe_aufbauen

segment_change: not.b   segmentierung
                bra     preshift_lupe

color_change:   not.b   beschriftung
                bra     draw_color_balken

port_change:    not.b   porta
                bra     set_porta       ;Port Bit setzen

music_change:   cmp.w   #300,D0         ;Music Nummer verÑndern?
                bgt.s   change_nummer

                btst    #1,D2           ;Rechts geklickt?
                beq.s   kein_rechts

                lea     music_path,A0
                lea     music_fn,A1
                lea     music_lext,A2
                moveq   #0,D0           ;Load
                bsr     fileselect
                move    SR,-(SP)
                jsr     screen2neo      ;ZurÅck zum NEOscreen
                move    (SP)+,CCR
                bne     L04F3           ;Abbruch->RTS

                move.b  music,D0        ;Musikflag retten
                st      music           ;Musik aus
                bsr     turn_music_on   ;abschalten
                bsr     load_music      ;und Musik laden
                move.b  D0,music
                move.w  music_nr,D0
                bra     turn_music_on   ;und wieder anschalten

kein_rechts:    not.b   music           ;Musik an/ausschalten
                move.w  music_nr,D0
                bra     turn_music_on   ;Musik umschalten

change_nummer:  btst    #0,D2           ;Links geklickt?
                beq.s   kein_links      ;Nein->vielleicht rechts

                cmpi.w  #30,music_nr    ;zu groû?
                bge.s   L04F3           ;->RTS

                addq.w  #1,music_nr
                bra.s   neues_musik

kein_links:     cmpi.w  #1,music_nr
                ble.s   L04F3           ;->RTS

                subq.w  #1,music_nr
neues_musik:    bsr     music_nr_out    ;Nummer ausgeben
                move.w  music_nr,D0
                bra     turn_music_on   ;und anschalten

saver_change:   not.b   screen_saver
L04F3:          rts

select_user_size:rts

select_user1:   lea     user_path,A0
                lea     user1_fn,A1
                moveq   #0,D7
                bra.s   select_user
select_user2:   lea     user_path,A0
                lea     user2_fn,A1
                moveq   #1,D7
select_user:    btst    #1,D2           ;Rechter Mausklick?
                bne.s   select_user_size
                lea     user_lext,A2
                moveq   #0,D0           ;Load
                bsr     fileselect
                move    SR,-(SP)
                jsr     screen2neo      ;ZurÅck zum NEOscreen
                move    (SP)+,CCR
                bne     L04F3           ;Abbruch->RTS

                tst.w   D7
                bne.s   load_uuser2
                bsr     load_user1
                bra.s   drÅber6236
load_uuser2:    bsr     load_user2
drÅber6236:     bsr     switch_user     ;an/ab schalten
                tst.w   D0              ;Fehler?
                bpl.s   okay_user       ;Nein->RTS

                lea     user_zu_groû_alert,A0
                addq.w  #1,D0
                beq.s   alert_found
                lea     user_not_found_alert,A0
                addq.w  #1,D0
alert_found:    bra     switch_alert

okay_user:      bsr     switch_user
                bsr     get_maus
                bsr     draw_board
                rts

load_user1:     lea     user_path,A0
                lea     user1_fn,A1
                moveq   #0,D7
                bra.s   load_user
load_user2:     lea     user_path,A0
                lea     user2_fn,A1
                moveq   #1,D7
load_user:      bsr     build_pathfn

                bsr     fopen           ;Datei îffnen
                tst.w   fhandle
                bmi     user_not_found  ;Fehler->Raus hier

                moveq   #28,D6
                movea.l rotate_buffer,A6
                bsr     read            ;Programmheader
                move.l  2(A6),D0        ;LÑnge Text
                add.l   6(A6),D0        ;+LÑnge Data
                move.l  D0,D5
                move.l  10(A6),D4       ;LÑnge BSS
                add.l   D4,D0           ;+LÑnge BSS=ProgrammlÑnge
                cmp.l   user_prg_len,D0
                bgt     user_zu_groû

                movea.l user_prg1,A5
                tst.w   D7
                beq.s   load_user11
                movea.l user_prg2,A5
load_user11:    cmpa.l  #0,A5           ;Userprg angelegt?
                beq.s   user_zu_groû

                move.l  D5,D6           ;LÑnge Text+Data
                movea.l A5,A6           ;In Userprgbuffer
                bsr     read            ;Und Text+Data laden

                movea.l rotate_buffer,A6 ;Programmheader
                move.w  #1,-(SP)        ;ab relativer Position
                move.w  fhandle,-(SP)
                move.l  $000E(A6),-(SP) ;Symboltabelle Åberspringen
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP

                movea.l rotate_buffer,A6
                move.l  #$00DFDFDF,D6
                bsr     read            ;Relozierinformation lesen

                movea.l A5,A4           ;Beginn des TEXT
                move.l  A5,D0
                moveq   #0,D1
                tst.l   (A6)            ;Relozierinfo vorhanden?
                beq.s   no_reloz
                adda.l  (A6)+,A4        ;Hier erstmalig relozieren
reloz:          add.l   D0,(A4)         ;relozieren
hol_reloz:      move.b  (A6)+,D1
                beq.s   no_reloz
                cmpi.b  #1,D1
                beq.s   einser
                adda.l  D1,A4
                bra.s   reloz
einser:         lea     254(A4),A4
                bra.s   hol_reloz

no_reloz:       adda.l  D5,A5           ;Start BSS
                bra.s   clear_dbra
clear_user_bss: clr.b   (A5)+           ;BSS lîschen
clear_dbra:     subq.l  #1,D4
                bpl.s   clear_user_bss

                bsr     fclose
                moveq   #0,D0           ;Alles Okay
                rts

user_zu_groû:   bsr     fclose
                moveq   #-1,D0
                rts
user_not_found: moveq   #-2,D0
                rts


save_options:   tst.w   param_save      ;Abspeichern erlaubt?
                bne     L04F3           ;Nein->RTS

                lea     hbl_system+2,A3
                move.w  rst_akt,D4
                mulu    #34,D4
                adda.l  D4,A3           ;=Adresse der aktuellen Palette
                lea     palette,A1
                moveq   #15,D7          ;16 Farben
col_save:       move.w  (A3)+,(A1)+
                dbra    D7,col_save

                bsr     Hm

                lea     save_rahmen(PC),A0
                movem.w (A0),D3-D6      ;Koordinaten des Rahmens holen
                bsr     inv_button

                move.w  rotate_richtung(PC),rotate_direct
                lea     lupe_y_60,A0
                tst.b   synchronisation ;60Hz?
                beq.s   hz604
                lea     lupe_y_50,A0
hz604:          move.w  lupe_y,(A0)+    ;Alte Lupe_Y merken
                move.w  nop_zahl,(A0)

retry_it:       move.w  #2,-(SP)        ;Lesen und Schreiben
                pea     pfadname
                move.w  #$003D,-(SP)
                trap    #1
                addq.l  #8,SP

                move.w  D0,fhandle
                bmi.s   d_error

                clr.w   -(SP)           ;Relativ zum Dateistart
                move.w  fhandle,-(SP)
                pea     28+options-Begin ;Header+Offset
                move.w  #$0042,-(SP)
                trap    #1
                lea     10(SP),SP
                tst.l   D0              ;Okay?
                bmi.s   d_error_close

                pea     options
                pea     options_end-options
                move.w  fhandle,-(SP)
                move.w  #$0040,-(SP)
                trap    #1
                lea     12(SP),SP
                tst.w   D0              ;Richtig geschrieben?
                bmi.s   d_error

                bsr     fclose
                tst.w   D0
                bmi.s   d_error
                bra.s   raus_hier89

d_error_close:  bsr     fclose
d_error:        move.l  #cant_save_opt,D0
                bsr     switch_alert
                bsr     Hm
                move.w  int_out,D7
                cmpi.w  #1,D7           ;Retry?
                beq     retry_it
raus_hier89:    lea     save_rahmen(PC),A0
                movem.w (A0),D3-D6      ;Koordinaten des Rahmens holen
                bra     inv_button

sync_change:    move.b  synchronisation,D7
                lea     lupe_y_60,A0
                tst.b   D7              ;60Hz?
                beq.s   hz602
                lea     lupe_y_50,A0
hz602:          move.w  lupe_y,(A0)+    ;Alte Lupe_Y merken
                move.w  nop_zahl,(A0)   ;und alte NOP-Zahl

                bchg    #1,D7           ;Synchronisation umdrehen
                move.b  D7,synchronisation
                bsr     set_sync
                move.w  lupe_y_60,D6
                move.w  nop_60,D5
                tst.b   D7              ;60Hz?
                beq.s   hz60
                move.w  lupe_y_50,D6
                move.w  nop_50,D5
hz60:           move.w  D6,lupe_y       ;Neue Lupe_y setzen
                move.w  D5,nop_zahl
                bsr     compile_nops    ;und Routine aufbauen
                bsr     haken_y_aus     ;Und Lupe_y auswerten

show_syncs:     bsr.s   ascii_syncs     ;Werte eintragen

                movem.l D0-A6,-(SP)
                bsr     Hm
                lea     syncs_strk(PC),A3 ;und Werte anzeigen
                lea     sync_str(PC),A0
                moveq   #0,D7           ;1 String neu zeichnen
                bra     redr2           ;Holt auch Register wieder

;TrÑgt die Werte in die Optionsbox ein
ascii_syncs:    movem.l D0-A6,-(SP)
                moveq   #'5',D7
                btst    #1,synchronisation
                bne.s   w50
                moveq   #'6',D7
w50:            move.b  D7,sync_str+5
                movem.l (SP)+,D0-A6
                rts

ste_change:     tst.w   ste_support
                bne.s   normal_st2
                tst.w   ste_machine     ;Ist hier ein STE am Werk?
                bne.s   normal_st2      ;Nein, einfach umschalten
                move.l  #switch2ste,D0
                bsr     switch_alert
                cmpi.w  #1,int_out      ;Yes?
                bne     L04F3           ;Nein->RTS

                lea     board_palette(PC),A0
                bsr     convert2st
                lea     raster_palette,A0
                bsr     convert2st
                lea     hbl_system+2,A0
                bsr     convert_rasters ;Alle Farbpaletten in normale ST
                lea     hbl_put_get+2,A0 ;Farben konvertieren
                bsr     convert_rasters
                lea     rasters1+2,A0
                bsr     convert_rasters
                lea     rasters2+2,A0
                bsr     convert_rasters

normal_st2:     not.w   ste_support
                jmp     print_rgb       ;RGB-Wert neu ausgeben

blitter_change: tst.b   blitter_da      ;Ist Blitter Åberhaupt da?
                bne     L04F3           ;nein->RTS
                tst.w   blitter_an      ;Ist Blitter an?
                beq     blitter_off     ;ja->dann aus
                bra     blitter_on      ;Blitter anschalten

magnify_change: not.b   magnify         ;Flag umdrehen
                tst.w   board_da
                bne.s   no_show22
                bsr     haken_aus
no_show22:      rts

y_change:       btst    #0,D2           ;Links gedrÅckt?
                bne.s   aufwÑrts

                cmpi.w  #1,lupe_y
                ble     L04F3
                subq.w  #1,lupe_y
                bra.s   haken_y_aus

aufwÑrts:       cmpi.w  #8,lupe_y
                bge     L04F3
                addq.w  #1,lupe_y
                bra.s   haken_y_aus

nop_change:     btst    #0,D2           ;Links gedrÅckt?
                bne.s   aufwÑrts2

                tst.w   nop_zahl
                ble.s   haken_y_aus
                subq.w  #1,nop_zahl
                bra.s   haken_y_aus
aufwÑrts2:      cmpi.w  #199,nop_zahl
                bge.s   haken_y_aus
                addq.w  #1,nop_zahl
haken_y_aus:    bsr     make_border_lupe
                bsr     copy_lupen
                move.w  lupe_y,D7
                add.w   #'0',D7
                move.b  D7,yyy+3
                bsr     compile_nops    ;Randaufklappung einbauen
                lea     nop_str+4(PC),A0
                move.w  nop_zahl,D0
                bsr     wandel_fest_dez ;und eintragen

haken_aus:      cmpi.b  #6,function     ;MISC aktiv?
                bne     kein_aus

                movem.l D0-D5/A0,-(SP)
                move.w  #203,D0
                move.w  #139,D1
                move.w  #211,D2
                move.w  #188,D3
                moveq   #0,D4
                moveq   #1,D5
                bsr     fill_box        ;Alte Haken weglîschen

                move.w  #259,D0
                move.w  #268,D2         ;Im rechten Kasten Haken weg
                bsr     fill_box

                lea     haken(PC),A0    ;
                move.w  #203,D0
                move.w  #148,D1
                moveq   #0,D2
                tst.w   blitter_an      ;ist Blitter an?
                bne.s   kein_haken1     ;Nein->RTS
                bsr     print6x6_inv    ;Sonst  printen,,
kein_haken1:    lea     yyy_koord+2(PC),A0
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #0,D2
                lea     yyy(PC),A0      ;Hîhe der Lupe ausgeben
                bsr     print6x6
                lea     nop_strk+2(PC),A0
                move.w  (A0)+,D0
                move.w  (A0)+,D1
                moveq   #0,D2           ;Anzahl der NOPs printen
                lea     nop_str(PC),A0
                bsr     print6x6
                move.w  #203,D0
                move.w  #155,D1
                moveq   #0,D2
                lea     haken(PC),A0    ;
                tst.b   magnify         ;Ist Lupe an?
                bne.s   keine_lupe
                bsr     print6x6_inv    ;Sonst  printen

keine_lupe:     move.w  #203,D0
                move.w  #141,D1
                moveq   #0,D2
                lea     haken(PC),A0    ;
                tst.w   ste_support     ;Ist Lupe an?
                bne.s   kein_ste2
                bsr     print6x6_inv    ;Sonst  printen

kein_ste2:      move.w  #262,D0
                move.w  #141,D1
                moveq   #0,D2
                lea     haken(PC),A0    ;
                tst.b   beschriftung    ;Ist Lupe an?
                bne.s   no_beschr
                bsr     print6x6_inv    ;Sonst  printen

no_beschr:      move.w  #262,D0
                move.w  #148,D1
                moveq   #0,D2
                lea     haken(PC),A0    ;
                tst.b   porta           ;Ist Lupe an?
                bne.s   L04F6
                bsr     print6x6_inv    ;Sonst  printen

L04F6:          move.w  #262,D0
                move.w  #155,D1
                moveq   #0,D2
                lea     haken(PC),A0    ;
                tst.b   music           ;Ist Lupe an?
                bne.s   kein_music
                bsr     print6x6_inv    ;Sonst  printen

kein_music:     move.w  #262,D0
                move.w  #162,D1
                moveq   #0,D2
                lea     haken(PC),A0
                tst.b   screen_saver
                bne.s   kein_saver
                bsr     print6x6_inv

kein_saver:     move.w  #203,D0
                move.w  #183,D1
                moveq   #0,D2
                lea     haken(PC),A0
                tst.b   segmentierung
                bne.s   kein_segment
                bsr     print6x6_inv
kein_segment:
                movem.l (SP)+,D0-D5/A0
kein_aus:       rts

;Gibt die Nummer der aktiven Musik aus
music_nr_out:   movem.l D0-A6,-(SP)

                move.w  music_nr,D0
                add.w   #'0',D0
                cmp.b   #'9',D0
                ble.s   ausgabe
                add.w   #'A'-'9'-1,D0
ausgabe:        move.b  D0,music_nrstr

                move.w  music_nrstrk+2,D0 ;X
                move.w  music_nrstrk+4,D1 ;Y
                moveq   #0,D2
                lea     music_str,A0
                bsr     print6x6

                movem.l (SP)+,D0-A6
                rts

                        PART 'Userprogramme'

;Userprogramm bekommt Pointer auf diese Routinen geliefert
user_interface:         DC.B 'NEOv'
                        DC.B release_1+'0','.',release_2+'0',release_3+'0'

                        DC.L get_maus ;2
                        DC.L taste ;3
                        DC.L Sm ;4
                        DC.L Hm ;5
                        DC.L rahmen ;6
                        DC.L fill_box ;7
                        DC.L print6x6 ;8
                        DC.L print6x6_inv ;9
                        DC.L print8x8 ;10
                        DC.L user_fileselect ;11
                        DC.L komplettbild ;12
                        DC.L rotate_buffer ;13
                        DC.L hbl_system ;14
                        DC.L palette_changed ;15
                        DC.L scr1 ;16
                        DC.L grab_y ;17
                        DC.L board_da ;18
                        DC.L zeichenfarbe ;19
                        DC.L hintergrundfarbe ;20
                        DC.L maus_in ;21
                        DC.L mem_cutter ;22
                        DC.L mem_lÑnge ;23
                        DC.L pixel_per_scan ;24
                        DC.L breite_bytes ;25
                        DC.L anz_scanlines ;26
                        DC.L cut_buff ;27
                        DC.L cutbuffer_x ;28
                        DC.L cutbuffer_y ;29
                        DC.L rst_akt ;30
                        DC.L inv_button ;31

user1_opt:      bsr     check_user1     ;Ist User 1 vorhanden?
                bne     nichts_da4      ;Nein
                moveq   #0,D7           ;User 1
                moveq   #4,D0           ;Funktion #4 serve_user
                bra     call_user

user2_opt:      bsr     check_user2     ;Ist User 2 vorhanden?
                bne     nichts_da4      ;Nein
                moveq   #1,D7           ;User 2
                moveq   #4,D0           ;Funktion #4 serve_user
                bra     call_user
nichts_da4:     rts

user1_init:     bsr     check_user1
                bne.s   kein_init
                moveq   #0,D7           ;User 1
u_init:         moveq   #5,D0           ;#5: Init_User
                bsr     call_user
kein_init:      rts

user2_init:     bsr     check_user2
                bne.s   kein_init
                moveq   #1,D7           ;User 2
                bra.s   u_init

user1_exit:     bsr     check_user1
                bne.s   kein_exit
                moveq   #0,D7           ;User 1
u_exit:         moveq   #6,D0           ;#6: Exit_User
                bsr     call_user
kein_exit:      rts

user2_exit:     bsr     check_user2
                bne.s   kein_exit
                moveq   #1,D7           ;User 2
                bra.s   u_exit

do_user1:       bsr     check_user1
                bne.s   kein_do
                movea.l user_prg1,A0
u_do:           movea.l 7*4(A0),A0
                jsr     (A0)
kein_do:        rts

do_user2:       bsr     check_user2
                bne.s   kein_do
                movea.l user_prg2,A0
                bra.s   u_do

draw_ggf_user1: bsr     check_user1     ;Ist User 1 vorhanden?
                bne     draw_options2   ;Nein->Options von NEOchrome zeichnen
                moveq   #0,D7           ;User 1
                moveq   #3,D0           ;Funktion #3 draw_all
                bra     call_user

draw_ggf_user2: bsr     check_user2     ;Ist User 2 vorhanden?
                bne     draw_options2   ;Nein->Options von NEOchrome zeichnen
                moveq   #1,D7           ;User 2
                moveq   #3,D0           ;Funktion #3 draw_all
                bra     call_user

;Schaltet die Icons von User1/2 an bzw. ab
switch_user:    movem.l D0-A6,-(SP)

                bsr     check_user1
                bne.s   k_u_1

                moveq   #0,D7
                moveq   #10,D0          ;Init_User
                bsr     call_user

k_u_1:          bsr     check_user2
                bne.s   k_u_2

                moveq   #1,D7
                moveq   #10,D0
                bsr     call_user       ;Init_User

k_u_2:          lea     icon_func,A0
                clr.b   13(A0)          ;User 1 + 2 nicht vorhanden
                clr.b   14(A0)
                bsr     check_user1
                bne.s   nicht_da1
                move.b  #-1,icon_func+13 ;User 1
                moveq   #0,D7           ;User 1
                moveq   #9,D0
                bsr     get_adress      ;Get Adress of Mousepointer
                move.l  A0,user1_arrow
nicht_da1:      bsr     check_user2
                bne.s   nicht_da2
                move.b  #-2,icon_func+14 ;User 2
                moveq   #1,D7           ;User 2
                moveq   #9,D0
                bsr     get_adress      ;Get Adress of Mousepointer
                move.l  A0,user2_arrow
nicht_da2:      movem.l (SP)+,D0-A6
                rts

;Holt sich eine Adresse aus dem Userprogramm
;-> D0.W: Nummer der Adresse [0..x]
;   D7.W: User [0..1]
get_adress:     movem.l D0-D7/A1-A6,-(SP)

                movea.l user_prg1,A0
                tst.w   D7
                beq.s   user1111
                movea.l user_prg2,A0
user1111:       lsl.w   #2,D0
                movea.l 0(A0,D0.w),A0   ;Adresse holen

                movem.l (SP)+,D0-D7/A1-A6
                rts

;Ruft eine Routine aus dem Userprogramm auf
;-> D0.W: Funktionsnummer [0..x]
;   D7.W: User [0..1]
call_user:      movem.l D0-A6,-(SP)

                movea.l user_prg1,A0
                tst.w   D7
                beq.s   user111
                movea.l user_prg2,A0
user111:        lsl.w   #2,D0
                movea.l 0(A0,D0.w),A0   ;Funktionsadresse holen
                lea     user_interface,A6
                jsr     (A0)

                movem.l (SP)+,D0-A6
                rts

;öberprÅft, ob ein Userprogramm vorliegt
check_user1:    move.l  A0,-(SP)
                movea.l user_prg1,A0
                bra.s   check_user
check_user2:    move.l  A0,-(SP)
                movea.l user_prg2,A0
check_user:     cmpa.l  #0,A0           ;Userprogramme angelegt?
                beq.s   kill_zero       ;Nein->Zeroflag lîschen
                cmpi.l  #'NEO-',4(A0)
                bne.s   kein_user
                cmpi.l  #'User',8(A0)
kein_user:      movea.l (SP)+,A0
                rts
kill_zero:      cmpa.w  #1,A0           ;Ergebnis ist falsch
                bra.s   kein_user

                        ENDPART


                        IF module_version=1
                        >PART 'DEMO USERPROGRAMM 1'

;Hierbei handelt es sich um zwei DEMO-Userprogramme, welche nicht nachgeladen, sondern direkt
;angesprungen werden (zu Entwicklungszwecken)
demo1:
                nop
                nop
                nop


                nop
                nop
                        DC.B 'NEO-User' ;Kennung
                        DC.L draw_demo1
                        DC.L serve_demo1

draw_demo1:     move.l  A6,interface

                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hide-Mouse

                move.w  #198,D0
                move.w  #130,D1
                move.w  #313,D2
                move.w  #199,D3
                moveq   #0,D4
                moveq   #0,D5           ;Replace
                movea.l 7*4(A6),A0
                jsr     (A0)

                move.w  #198,D0
                move.w  #130,D1
                move.w  #313,D2
                move.w  #138,D3
                moveq   #15,D4
                moveq   #0,D5           ;Replace
                movea.l 7*4(A6),A0
                jsr     (A0)

                move.w  #205,D0
                move.w  #132,D1
                moveq   #0,D2
                lea     copystr,A0
                movea.l 9*4(A6),A1
                jsr     (A1)
                rts

serve_demo1:    movea.l 2*4(A6),A0
                jsr     (A0)            ;Hol_Maus

                cmp.w   #198,D0         ;Ausserhalb des Optionsfeldes?
                blt.s   serve_end
                cmp.w   #130,D1
                blt.s   serve_end

                btst    #0,D2           ;Linke Maustaste?
                beq.s   serve_demo1

                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hm

                move.w  D0,D2
                move.w  D1,D3
                moveq   #15,D4
                moveq   #0,D5
                movea.l 7*4(A6),A0
                jsr     (A0)

                movea.l 4*4(A6),A0
                jsr     (A0)            ;Sm

                bra.s   serve_demo1

serve_end:      rts

interface:              DC.L 0  ;Pointer auf NEOchrome Interface

copystr:                DC.B 'N E O C H R O M E',0
                        EVEN

                        ENDPART

                        >PART 'DEMO USERPROGRAMM 2'

;Hierbei handelt es sich um zwei DEMO-Userprogramme, welche nicht nachgeladen, sondern direkt
;angesprungen werden (zu Entwicklungszwecken)
demo2:          bra     no_demo2        ;Should be a branch to Pterm0

                        DC.B 'NEO-User' ;Kennung
                        DC.L draw_demo2 ;to paint options
                        DC.L serve_demo2 ;to serve options
                        DC.L init_demo2 ;If demo2 gets selected, some init_stuff could be done
                        DC.L exit_demo2 ;id demo2 gets deselcted some exit_stuff
                        DC.L do_demo2 ;If mouse is moved inside the workscreen
                        DC.L demo_icon
                        DC.L demo_arrow
                        DC.L init_first ;After loading

;NEOchrome starts this routine right after loading
init_first:     cmpi.l  #'NEOv',(A6)    ;Hello NEOchrome?
                bne.s   i_cant_work     ;Not here -> I can't work
                movea.l A6,A5
                lea     min_version,A0
check_version:  tst.b   (A0)
                beq.s   i_can_work
                cmpm.b  (A5)+,(A0)+
                blt.s   i_can_work      ;Version is higher
                beq.s   check_version   ;Same

i_cant_work:    move.l  #'Shit',demo2+4 ;no module anymore
                rts

i_can_work:     move.w  #$0019,-(SP)    ;Get current drive
                trap    #1
                addq.l  #2,SP

                lea     spc_path,A0
                move.b  D0,(A0)
                addi.b  #'A',(A0)+      ;Build path
                move.b  #':',(A0)+
                addq.b  #1,D0
                ext.w   D0
                move.w  D0,-(SP)
                move.l  A0,-(SP)
                move.w  #$0047,-(SP)    ;Getpath of current drive
                trap    #1
                addq.l  #8,SP

                lea     spc_path,A0
search_end:     tst.b   (A0)+           ;Search end of path
                bne.s   search_end

                move.b  #'\',-1(A0)
                move.b  #'*',(A0)+      ;*.SPU
                move.b  #'.',(A0)+
                move.b  #'S',(A0)+
                move.b  #'P',(A0)+
                move.b  #'U',(A0)+
                clr.b   (A0)
                rts

min_version:            DC.B 'NEOv2.26',0 ;This module needs NEO v2.26 at least
                        EVEN

init_demo2:
exit_demo2:     rts                     ;No Init and Exit-Stuff

;-> D0.W: Mouse-x
;   D1.W: Mouse-y
;   D2.W: Mousekey
;               Bit 0 set: left pressed
;               Bit 1 set: right pressed
;               Bit 2 set: left new pressed (Since last get_mouse)
;               Bit 3 set: right new_pressed
;               Bit 4 set: left new released
;               Bit 5 set: right new released
;               Bit 6 set: Doubleclick left (not very reliable)
;               Bit 7 set: Doubleclick right (-'-)
;               Bit 14 set: There is a keyboard key pressed
;               Bit 15 set: Mouseposition changed
do_demo2:       btst    #0,D2           ;Linke Maustaste?
                beq.s   end_user

                movea.l interface2,A6
                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hidemouse

                move.w  D0,D2
                move.w  D1,D3
                moveq   #15,D4          ;Color 15
                moveq   #0,D5
                movea.l 7*4(A6),A0      ;Put-Pixel
                jsr     (A0)
end_user:       rts

draw_demo2:     move.l  A6,interface2

                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hide-Mouse

                move.w  #198,D0
                move.w  #130,D1
                move.w  #319,D2
                move.w  #199,D3
                moveq   #0,D4           ;Color #0
                moveq   #0,D5           ;Replacemode
                movea.l 7*4(A6),A0      ;Clear whole options
                jsr     (A0)

                move.w  #198,D0
                move.w  #130,D1
                move.w  #313,D2
                move.w  #138,D3
                moveq   #15,D4
                moveq   #0,D5           ;Replace
                movea.l 7*4(A6),A0
                jsr     (A0)

                move.w  #205,D0
                move.w  #132,D1
                moveq   #0,D2
                lea     module_titel,A0
                movea.l 9*4(A6),A1
                jsr     (A1)

                move.w  #286,D0
                move.w  #191,D1
                move.w  #313,D2
                move.w  #199,D3
                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                movea.l 6*4(A6),A0
                jsr     (A0)            ;Rahmen um Info

                move.w  #288,D0
                move.w  #193,D1
                moveq   #0,D2
                lea     info,A0
                movea.l 9*4(A6),A1
                jsr     (A1)

                move.w  #203,D0
                move.w  #158,D1
                move.w  #308,D2
                move.w  #173,D3
                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                movea.l 6*4(A6),A0
                jsr     (A0)            ;Rahmen um Button

                move.w  #205,D0
                move.w  #160,D1
                moveq   #0,D2
                lea     load_spec,A0
                movea.l 9*4(A6),A1
                jsr     (A1)
                move.w  #235,D0
                move.w  #167,D1
                moveq   #0,D2
                lea     pic,A0
                movea.l 9*4(A6),A1
                jsr     (A1)

                rts

serve_demo2:    movea.l 4*4(A6),A0      ;Show Mouse
                jsr     (A0)

                movea.l 2*4(A6),A0
                jsr     (A0)            ;Get_Mouse

                cmp.w   #198,D0         ;Out of the Options?
                blt     serve_end2      ;Yes, then end module
                cmp.w   #130,D1
                blt     serve_end2

                btst    #0,D2           ;Left Mousebutton?
                beq.s   serve_demo2     ;No->End module

                move.w  #203,D3
                move.w  #158,D4
                move.w  #308,D5
                move.w  #173,D6
                movea.l 21*4(A6),A0
                jsr     (A0)            ;Mouse_in? [Load-Button]
                beq.s   load_picture

                move.w  #286,D3
                move.w  #191,D4
                move.w  #313,D5
                move.w  #199,D6
                movea.l 21*4(A6),A0
                jsr     (A0)            ;Mouse_in? [Info-Button]
                bne.s   serve_demo2

;Info-Button:

                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hide-Mouse

                move.w  #199,D0
                move.w  #139,D1
                move.w  #319,D2
                move.w  #199,D3
                moveq   #0,D4
                moveq   #0,D5
                movea.l 7*4(A6),A0      ;Clear Buttons
                jsr     (A0)

                move.w  #199,D0
                move.w  #144,D1
                lea     info_text,A0
                bsr     string_out

wait_release:   movea.l 2*4(A6),A0
                jsr     (A0)            ;Get_Mouse
                btst    #0,D2           ;Left Button pressed?
                bne.s   wait_release

                bsr     draw_demo2      ;Redraw Options
                bra     serve_demo2

load_picture:   lea     spc_path,A0     ;Path (will be changed to new path)
                lea     spc_fn,A1       ;Filename (will be changed to new filename)
                lea     spc_ex,A2       ;Extended Info (e.g. Load Spectrum picture)
                moveq   #0,D0           ;Load (0=Load, 1=Save)
                movea.l interface2,A6
                movea.l 11*4(A6),A3     ;Fileselect
                jsr     (A3)
                bne     serve_end2      ;user clicked at cancel

                clr.w   -(SP)
                move.l  A0,-(SP)        ;Path+Filename of desired file (by fileselector)
                move.w  #$003D,-(SP)    ;Fopen
                trap    #1
                addq.l  #8,SP
                tst.l   D0              ;Does file exist?
                bmi     serve_demo2
                move.w  D0,file_handle

                movea.l 12*4(A6),A0     ;Pointer to Screenadress
                movea.l (A0),A5         ;Screenadress
                move.l  A5,-(SP)        ;Screenadress
                move.l  #32000,-(SP)    ;Get Picture
                move.w  file_handle,-(SP)
                move.w  #$003F,-(SP)    ;Fread Picture Body
                trap    #1
                lea     12(SP),SP

                movea.l 13*4(A6),A0     ;Pointer to Helpbufferadress
                move.l  (A0),-(SP)      ;Get Adress
                move.l  #32000,-(SP)
                move.w  file_handle,-(SP)
                move.w  #$003F,-(SP)    ;Get Spectrum 512 Colors
                trap    #1
                lea     12(SP),SP

                move.w  file_handle,-(SP)
                move.w  #$003E,-(SP)
                trap    #1              ;Fclose
                addq.l  #4,SP

                cmpi.w  #'SP',(A5)      ;Packed picture?
                beq     serve_demo2

                movea.l 5*4(A6),A0
                jsr     (A0)            ;Hide-Mouse

                bsr     convert_rst

                movea.l interface2,A6
                movea.l 15*4(A6),A0
                jsr     (A0)            ;Calculate and show changed rasters

                movea.l interface2,A6
                moveq   #0,D7
                movea.l 18*4(A6),A0     ;Board visible?
                tst.w   (A0)
                bne.s   no_board        ;Should be always visible

                movea.l 17*4(A6),A0
                move.w  (A0),D7         ;get Grab_y
no_board:       movea.l 12*4(A6),A0     ;Picture
                movea.l (A0),A0         ;Get Adress
                mulu    #160,D7
                adda.l  D7,A0
                movea.l 16*4(A6),A1     ;Screenadress
                movea.l (A1),A1         ;Get Adress
                move.w  #3999,D0
trans_pic:      move.l  (A0)+,(A1)+     ;Transfer Picture to Screen
                dbra    D0,trans_pic

serve_end2:     rts

;Converts Spectrum 512 picture to Raster IFF
;written by Michael of Avengers (some comments and improvements by Chaos, Inc. of Delta Force)
;-> Picture at workscreen
;   Colors at helpbuff
;<- new picture at workscreen
;   Rasters at rasters
convert_rst:    movea.l interface2,A6   ;Adress of NEOchrome Interface
                movea.l 12*4(A6),A5     ;Adresspointer to Screen
                movea.l (A5),A5         ;Get Adress

                movea.l 13*4(A6),A4     ;Adress of color palette
                movea.l (A4),A4         ;Get Adress
                suba.w  #96,A4          ;Go back 96 Bytes (why not?)

                moveq   #1,D1           ;Start at y=1
bcl7a:          move.w  #-1,col
                lea     line(PC),A6

                move.w  #319,D0         ;Get 320 Pixel
bcl7b:          bsr     get_pix_screen
                add.w   D7,D7
                move.l  #160,D5
                add.w   D0,D5
                lea     offset(PC),A3
                sub.w   0(A3,D7.w),D5
                divu    #160,D5         ;what an awful instruction!
                lsl.w   #5,D5
                add.w   D7,D5
                move.w  #96,D2
                mulu    D1,D2
                add.w   D2,D5
                move.w  0(A4,D5.w),D2   ;what col. is it?
                andi.w  #$0777,D2
                move.w  D2,(A6)+        ;Store color value
                beq.s   suiv2           ;background color?
                lea     col(PC),A3
test:           cmpi.w  #-1,(A3)
                beq.s   add_
                cmp.w   (A3),D2
                beq.s   suiv_1
                addq.l  #4,A3
                bra.s   test
suiv_1:         addq.w  #1,2(A3)
                bra.s   suiv2
add_:           move.w  D2,(A3)
                move.w  #1,2(A3)
                move.w  #-1,4(A3)
suiv2:          dbra    D0,bcl7b

                movea.l interface2,A3
                movea.l 14*4(A3),A3     ;Adress of rasters to build

                moveq   #0,D3           ;Start at scanline 0
                move.w  D1,D3
                mulu    #34,D3
                adda.l  D3,A3
                move.w  D1,(A3)+        ;Insert Y
                move.w  #0,(A3)+        ;Background always black (why?)

                moveq   #14,D7          ;15 remaining colors
dont_know:      moveq   #0,D2           ;max.
                moveq   #0,D3           ;col.
                moveq   #0,D4           ;pos
                lea     col(PC),A6
tst1:           cmpi.w  #-1,(A6)
                beq.s   fin_ok
                move.w  2(A6),D5
                cmp.w   D5,D2
                bgt.s   next1
                move.w  D5,D2
                move.w  (A6),D3
                move.l  A6,D4
next1:          addq.l  #4,A6
                bra.s   tst1
fin_ok:         move.w  D3,(A3)+
                movea.l D4,A6
                clr.l   (A6)
                dbra    D7,dont_know

                move.w  #319,D0
                lea     line(PC),A3
loop2:          movea.l interface2,A6
                movea.l 14*4(A6),A6     ;Build Rasters here

                movem.w D0-D1,-(SP)     ;store coordinates
                move.w  (A3)+,D0
                moveq   #0,D3
                move.w  D1,D3
                mulu    #34,D3
                adda.l  D3,A6
                addq.l  #2,A6
                moveq   #0,D1
                moveq   #0,D5
                moveq   #32,D7
bcl5b:          move.w  (A6)+,D2
                move.w  D2,D3
                move.w  D0,D4
                and.w   #$000F,D3
                and.w   #$000F,D4
                sub.w   D3,D4
                bpl.s   bcl5c
                neg.w   D4
bcl5c:          move.w  D4,D6
                move.w  D2,D3
                move.w  D0,D4
                and.w   #$00F0,D3
                and.w   #$00F0,D4
                sub.w   D3,D4
                bpl.s   bcl5d
                neg.w   D4
bcl5d:          lsr.w   #4,D4
                add.w   D4,D6
                move.w  D2,D3
                move.w  D0,D4
                and.w   #$0F00,D3
                and.w   #$0F00,D4
                sub.w   D3,D4
                bpl.s   bcl5e
                neg.w   D4
bcl5e:          lsr.w   #8,D4
                add.w   D4,D6
                cmp.w   D6,D7
                ble.s   bcl5f
                move.w  D6,D7
                move.w  D1,D5
bcl5f:
                addq.w  #1,D1
                cmp.w   #16,D1
                bne.s   bcl5b
                move.w  D5,D7
                movem.w (SP)+,D0-D1     ;Restore coordinates
                tst.w   D0              ;X=0?
                bne.s   no_zero
                moveq   #0,D7           ;Black first column
no_zero:        bsr     put_pix_screen
                dbra    D0,loop2

                addq.w  #1,D1           ;y++
                cmp.w   #200,D1         ;until bottom of screen
                blt     bcl7a
                rts                     ;Then Return

;Gets Pixel from screen
;-> D0.W: X
;   D1.W: Y
;   A5.L: Screen
;<- D7.W: Color [0..15]
get_pix_screen: movem.l D0-D3/D6/A5,-(SP)

                mulu    #160,D1
                adda.l  D1,A5
                move.w  D0,D6
                lsr.w   #4,D0           ;/16
                lsl.w   #3,D0
                adda.w  D0,A5
                and.w   #15,D6
                neg.w   D6
                add.w   #15,D6

                moveq   #0,D7
                movem.w (A5),D0-D3
                btst    D6,D3
                beq.s   no1
                addq.w  #1,D7
no1:            lsl.w   #1,D7
                btst    D6,D2
                beq.s   no2
                addq.w  #1,D7
no2:            lsl.w   #1,D7
                btst    D6,D1
                beq.s   no3
                addq.w  #1,D7
no3:            lsl.w   #1,D7
                btst    D6,D0
                beq.s   no4
                addq.w  #1,D7
no4:            movem.l (SP)+,D0-D3/D6/A5
                rts

;Puts Pixel on screen
;-> D0.W: X
;   D1.W: Y
;   D7.W: Color [0..15]
;   A5.L: Screen
put_pix_screen: movem.l D0-D3/D6-D7/A5,-(SP)

                mulu    #160,D1
                adda.l  D1,A5
                move.w  D0,D6
                lsr.w   #4,D0           ;/16
                lsl.w   #3,D0
                adda.w  D0,A5
                and.w   #15,D6
                neg.w   D6
                add.w   #15,D6

                movem.w (A5),D0-D3      ;Get all 4 planes
                bclr    D6,D0
                btst    #0,D7
                beq.s   nooo1
                bset    D6,D0
nooo1:          bclr    D6,D1
                btst    #1,D7
                beq.s   nooo2
                bset    D6,D1
nooo2:          bclr    D6,D2
                btst    #2,D7
                beq.s   nooo3
                bset    D6,D2
nooo3:          bclr    D6,D3
                btst    #3,D7
                beq.s   nooo4
                bset    D6,D3
nooo4:          movem.w D0-D3,(A5)      ;back to screen

                movem.l (SP)+,D0-D3/D6-D7/A5
                rts

offset:                 DC.W 1,5,21,25,41,45,61,65,81,85,101,105,121,125,141,145

;Prints String at Screen and interprets $0d, $0a
;-> D0.W: X
;   D1.W: Y
;   A0.L: Adress of String
string_out:     movem.l D0-A6,-(SP)

                move.w  D0,D6
                move.w  D1,D7           ;Store X/Y
get_new_string: lea     string,A1       ;Build Line

get_string:     move.b  (A0)+,D0        ;Get Char
                beq.s   string_ready
                cmp.b   #13,D0          ;CR/LF?
                beq.s   string_ready
                move.b  D0,(A1)+        ;and store char
                bra.s   get_string

string_ready:   movem.l D0/A0,-(SP)     ;store last charakter

                clr.b   (A1)            ;Terminate String

                move.w  D6,D0           ;X
                move.w  D7,D1           ;Y
                moveq   #0,D2           ;Style
                lea     string,A0
                movea.l 8*4(A6),A1
                jsr     (A1)            ;and print line

                addq.w  #7,D7           ;y+=7
                movem.l (SP)+,D0/A0     ;Get last charakter
                tst.w   D0
                bne.s   get_new_string

                movem.l (SP)+,D0-A6
                rts


no_demo2:       pea     message(PC)
                move.w  #9,-(SP)
                trap    #1
                addq.l  #6,SP

                move.w  #7,-(SP)
                trap    #1              ;Wait for key
                addq.l  #2,SP

                clr.w   -(SP)           ;Pterm0
                trap    #1

*    pixels/scanline    = $0010 (bytes/scanline: $0002)
*  # scanlines (height) = $0010
*  Monochrome mask (1 plane; background=0/non-background=1)
demo_icon:              DC.W 16,16 ;Width, Height
                        DC.W $0000,$0000,$1E7C,$3066,$1E7C,$0360,$3E60,$0000
                        DC.W $0000,$1C98,$10A4,$1C88,$0290,$1CBC,$0000,$0000

demo_arrow:             DC.W $0001,$0001 ;Offset to Hot-Spot
                        DC.W 1  ;Number of Planes
                        DC.W 0,1 ;VDI-Color of Mask, VDI-Color of Arrow
                        DC.W %1110000000000000
                        DC.W %1111000000000000
                        DC.W %1111100000000000
                        DC.W %1111110000000000
                        DC.W %1111111000000000
                        DC.W %1111111100000000
                        DC.W %1111111110000000
                        DC.W %1111111111000000
                        DC.W %1111111111000000
                        DC.W %1111111111000000
                        DC.W %1111111100000000
                        DC.W %1111111100000000
                        DC.W %1110111110000000
                        DC.W %0000111110000000
                        DC.W %0000011110000000
                        DC.W %0000011110000000

                        DC.W %0000000000000000
                        DC.W %0100000000000000
                        DC.W %0110000000000000
                        DC.W %0111000000000000
                        DC.W %0111100000000000
                        DC.W %0111110000000000
                        DC.W %0111111000000000
                        DC.W %0111111100000000
                        DC.W %0111111110000000
                        DC.W %0111110000000000
                        DC.W %0110110000000000
                        DC.W %0100011000000000
                        DC.W %0000011000000000
                        DC.W %0000001100000000
                        DC.W %0000001100000000
                        DC.W %0000000000000000

interface2:             DC.L 0  ;Pointer auf NEOchrome Interface
file_handle:            DC.W 0
spc_path:               DS.B 120 ;Path, e.g. A:\*.SP?
spc_fn:                 DS.B 14
spc_ex:                 DC.B 'Load Spectrum 512 Picture',0

module_titel:           DC.B 'L O A D   S P 512',0
info:                   DC.B 'INFO',0
load_spec:              DC.B 'LOAD SPECTRUM 512',0
pic:                    DC.B 'PICTURE',0

info_text:              DC.B 'THIS IS A MODULE TO',13
                        DC.B 'LOAD **UNPACKED**',13
                        DC.B 'PICTURES, THAT ARE',13
                        DC.B 'SAVED BY SPECTRUM.',13,13
                        DC.B 'WRITTEN BY:',13
                        DC.B '        CHAOS, INC.',0
message:                DC.B 27,"E"
                        DC.B 'This is a NEOchrome Masterø Module.',13,10
                        DC.B "It can't be startet on its own...",0
                        EVEN

string:                 DS.B 80
line:                   DS.W 320
col:                    DS.L 48

                        ENDPART
                        ENDC

;Konvertiert eine STE-Farbpalette in ST Farben
; A0.L: Zeiger auf Palette
convert2st:     movem.l D7-A0,-(SP)
                moveq   #15,D7
con_loop:       andi.w  #%0000011101110111,(A0)+
                dbra    D7,con_loop
                movem.l (SP)+,D7-A0
                rts

;Convertiert ein komplettes Rastersystem in ST-Farben
convert_rasters:movem.l D7-A0,-(SP)
                move.w  #anz_raster-1,D7
con_loop2:      bsr.s   convert2st
                lea     34(A0),A0
                dbra    D7,con_loop2
                movem.l (SP)+,D7-A0
                rts

crawcin:        movem.l D0-A6,-(SP)
                move.w  #7,-(SP)
                trap    #1
                addq.l  #2,SP
                movem.l (SP)+,D0-A6
                rts

save_data:      move.w  D2,D5
                and.w   #%0000000000001100,D5 ;Links oder rechts neu gedrÅckt?
                beq     L0530           ;Nein->RTS
                move.b  D2,maus_status
                move.w  D1,D5           ;Y-Koordinate
                sub.w   #167,D5         ;kleiner 167
                bmi     L0530           ;->RTS
                ext.l   D5
                divu    #7,D5
                cmpi.w  #3,D5           ;mehr als 3 Buttons gibt es nicht!
                bcc     L0530           ;->Raus
                bsr     invert_button
L04F8:          move.w  D5,-(SP)        ;welcher war invertiert?
                jsr     animier_objekte
                bsr     Sm
                jsr     get_maus
                move.w  (SP)+,D5
                btst    #4,D2           ;Links losgelassen?
                bne.s   L04FB
                btst    #5,D2           ;Rechte losgelassen?
                bne.s   L04FB
                move.w  D1,D4           ;Y
                sub.w   #166,D4         ;Raus gefahren?
                bmi.s   L04FA
                ext.l   D4
                divu    #7,D4
                cmpi.w  #3,D4           ;Neue Buttonnr berechnen
                bcc.s   L04FA           ;zu gross, also alles ausschalten
                cmp.w   D4,D5           ;Gleich wie vorher?
                beq.s   L04F8           ;JA, weiter warten
                bsr     Hm
                tst.w   D5              ;war vorher nichts gezeichnet?
                bmi.s   L04F9           ;Ja, weiter
                bsr     invert_button   ;Altes ausschalten
L04F9:          move.w  D4,D5           ;Jetzt neues merken
                bsr     invert_button   ;und einschalten
                bsr     Sm
                bra.s   L04F8           ;weiter warten
L04FA:          tst.w   D5              ;War vorher was invertiert?
                bmi.s   L04F8           ;Nein, weiter warten, da Knopf gedrÅckt
                bsr     Hm
                bsr     invert_button   ;zurÅckinvertieren
                moveq   #-1,D5          ;Jetzt ist nichts mehr invertiert
                bsr     Sm
                bra.s   L04F8

L04FB:          tst.w   D5              ;war vorher nichts invertiert?
                bmi     L0530           ;Ja->RTS
                bsr     Hm
                move.w  #7,D6           ;7 mal flashen
L04FC:          bsr     invert_button
                move.w  vblcounter,button_klicked
L04FD:          move.w  vblcounter,D7
                sub.w   button_klicked,D7
                cmpi.w  #2,D7
                bcs.s   L04FD
                dbra    D6,L04FC
                move.w  D5,button_klicked ;Button merken

                tst.w   pixel_per_scan  ;Åberhaupt was da?
                bne.s   L04FE
                lea     L0593(PC),A0    ;cut buffer empty
                bsr     print_status
                bra     save_data_end
L04FE:          lea     bitblit,A6      ;hier Parameter aufbauen
                move.w  pixel_per_scan(PC),D2
                move.w  D2,(A6)         ;Breite des Blocks in Pixeln
                move.w  anz_scanlines(PC),D3
                move.w  D3,2(A6)        ;Hîhe des Blocks in Pixeln
                move.l  cut_buff,18(A6) ;Anfangsadresse des Quellrasters
                movea.l scr2,A0
                move.l  A0,32(A6)       ;Anfangsadresse des Zielrasters

                moveq   #0,D0
                move.w  #7999,D1
L04FF:          move.l  D0,(A0)+        ;Savebuffer komplett lîschen
                dbra    D1,L04FF

                move.w  cutbuffer_x(PC),14(A6) ;X des Quellrasters
                move.w  #0,28(A6)       ;X des Zielrasters
                move.w  cutbuffer_y(PC),16(A6) ;Y des Quellrasters
                move.w  #0,30(A6)       ;Y des Zielrasters
                move.w  #8,22(A6)       ;Source-Offset zum nÑchsten Wort
                move.w  breite_bytes,24(A6) ;Breite des Quellrasters in Bytes
                move.w  #2,26(A6)       ;Source-Offset zur nÑchstes Plane
                move.w  #4,4(A6)        ;Anzahl der Planes
                move.l  #$03030303,D5   ;3=COPY (fÅr Sprite)
                moveq   #8,D4           ;Offset zur gleichen Plane
                move.w  D2,D1           ;Breite in Pixeln
                addi.w  #$000F,D1       ;auf nÑchsten BB
                lsr.w   #4,D1
                lsl.w   #3,D1           ;Adresse auf BB berechnen
                clr.b   L059B+1         ;Null ans Ende von Copyb*.x
                moveq   #'S',D0
                tst.w   button_klicked  ;Sprite_Saven?
                beq.s   L0500           ;ja, machen
                cmpi.w  #2,button_klicked ;Oder Image?
                bne.s   L0500b          ;nein, dann Maske
                moveq   #'I',D0
                move.b  #'M',L059B+1    ;Copy*.img
                move.b  #'G',L059B+2
                clr.b   L059B+3
                bra.s   L0500           ;Sprite machen
L0500b:         move.l  #$03070707,D5   ;3=Copy 7=Or
                move.w  #14,6(A6)       ;Vordergrundfarbe
                move.w  #0,8(A6)        ;Hintergrundfarbe
                moveq   #2,D4           ;Offset zur gleichen Plane
                move.w  D2,D1           ;Breite in Pixeln
                addi.w  #$000F,D1       ;auf nÑchsten BB
                lsr.w   #4,D1
                add.w   D1,D1           ;Offset berechnen
                moveq   #'M',D0         ;Maske machen
L0500:          move.b  D0,L059B        ;Extension CopyB*.x
                move.w  D4,36(A6)       ;Dest-Offset zur gleichen Plane
                lsr.w   #2,D4           ;durch 4
                move.w  D4,40(A6)       ;Offset zur nÑchsten Plane
                move.w  D1,D2
                move.w  D2,38(A6)       ;Breite des Zielrasters in Bytes
                mulu    D2,D3           ;Breite mal Hîhe
                lsr.w   #1,D3           ;/2=Anzahl der Worte
                move.l  D5,10(A6)       ;operation
                movem.l D2-D3/A6,-(SP)
                linea   #7 [ Bitblk ]   ;kopieren
                move.w  #1,L081F        ;bei Nr 1 anfangen

                btst    #1,maus_status  ;Rechter Knopf gedrÅckt?
                beq.s   normal_saven    ;nein

                lea     save_path,A0
                move.w  button_klicked,D1
                add.w   #11,D1          ;Extension berechnen
                bsr     change_path     ;Als Extension anhÑngen
                lea     picture_neo,A2
                lea     picture_neu,A1  ;Filenamen retten
copy_99:        move.b  (A2)+,(A1)+
                bne.s   copy_99
                lea     picture_neu,A1
                bsr     change_file     ;Und an Filenamen anhÑngen
                move.w  button_klicked,D0
                lsl.w   #2,D0
                lea     copyboxes,A2
                movea.l 0(A2,D0.w),A2   ;Erweiterte Information holen
                moveq   #1,D0           ;Speichern
                bsr     fileselect
                move    SR,-(SP)
                jsr     screen2neo      ;NEochrom anschalten
                move    (SP)+,CCR
                bne.s   abbruch1        ;Abbruch->ganz raus hier
                bsr     fcreate         ;Datei îffnen
                bra     speichern

abbruch1:       movem.l (SP)+,D2-D3/A6
                bra     save_data_end

normal_saven:   lea     load_path,A0
                lea     2(A0),A1        ;Pfadangabe

                cmpi.b  #':',1(A0)      ;Laufwerksangabe vorhanden?
                bne.s   kein_laufwerk

                move.b  (A0),D0
                sub.w   #'A',D0
                move.w  D0,-(SP)
                move.w  #$000E,-(SP)
                trap    #1              ;Aktuelles Laufwerk setzen
                addq.l  #4,SP

                lea     load_path,A1
kein_laufwerk:  pea     (A1)
                move.w  #$003B,-(SP)    ;Pfad setzen
                trap    #1
                addq.l  #6,SP

                clr.w   -(SP)
                pea     L059A(PC)       ;COPYB*.x
                move.w  #$004E,-(SP)    ;Fsfirst
                trap    #1
                addq.l  #8,SP
                tst.w   D0              ;vorhanden?
                bmi.s   L0505           ;nein
L0501:          moveq   #0,D1           ;dez-wandler
                lea     dta_filename+5,A0 ;normalerweise '.' in copyb*.x
L0502:          move.b  (A0)+,D0
                beq.s   L0503
                cmpi.b  #'.',D0
                beq.s   L0503
                subi.b  #$30,D0         ;in Zahl wandeln
                bcs.s   L0504           ;ja, kein copyb*.x
                cmpi.b  #$0A,D0         ;grîûer als 9?
                bcc.s   L0504
                mulu    #$000A,D1
                ext.w   D0
                add.w   D0,D1           ;dazuzÑhlen
                bra.s   L0502
L0503:          cmp.w   L081F,D1
                bcs.s   L0504
                addq.w  #1,D1           ;eins weiter
                move.w  D1,L081F        ;und speichern
L0504:          move.w  #$004F,-(SP)    ;Sfnext
                trap    #1
                addq.l  #2,SP
                tst.w   D0              ;Solange noch was da....
                bpl.s   L0501
L0505:          lea     L059A(PC),A0
                lea     filename,A1
                move.w  #4,D0
L0506:          move.b  (A0)+,(A1)+     ;Copyb kopieren
                dbra    D0,L0506
                move.w  L081F,D0        ;Zahl holen
                jsr     wandel_dez      ;in Dez wandeln -> a1
                addq.w  #1,A0           ;* Åberspringen
                moveq   #4,D0
L050A:          move.b  (A0)+,(A1)+     ;.S\0 kopieren
                dbra    D0,L050A
                lea     L0596(PC),A0    ;Filename.s
                lea     12(A0),A3       ;Auf \0
                lea     filename,A1
                movea.l A1,A2
L050B:          tst.b   (A1)+           ;zum Ende des Filenamens
                bne.s   L050B
                subq.l  #1,A1           ;a1 zeigt auf Null
L050C:          move.b  -(A1),-(A3)     ;Kompletten Filenamen Åbertragen
                cmpa.l  A1,A2           ;bis zum Start Åbertragen
                bne.s   L050C

L050D:          cmpa.l  A3,A0           ;volle LÑnge?
                beq.s   L050E
                move.b  #$20,-(A3)      ;Nein, dann mit Spaces auffÅllen
                bra.s   L050D

L050E:          lea     L0595(PC),A0    ;making copy... in Statuszeile
                bsr     print_status

                clr.w   -(SP)
                pea     filename        ;Filename
                move.w  #$003C,-(SP)
                trap    #1              ;Create fÅr Copyb1.s
                addq.l  #8,SP
speichern:      movem.l (SP)+,D2-D3/A6  ;Auch bei copy_99 Ñndern!
                move.w  D3,D1           ;Anzahl der Worte des Objektes
                move.l  SP,save_sp
                move.w  D0,handle
                bmi     disk_error
                cmpi.w  #2,button_klicked ;Image-File?
                beq     save_image      ;ja
                movea.l copybox_screen,A0
                movea.l A0,A1
                lea     $0400(A0),A0
                move.w  D2,-(SP)        ;Bytes pro Scanline retten
                lea     cut_titel(PC),A2 ;Titelstring in Datei schreiben
                bsr     Fwrite_str
                move.w  pixel_per_scan(PC),D2 ;Pixel/Scanline
                bsr     save_word
                lea     cut_titel2(PC),A2
                bsr     Fwrite_str
                move.w  (SP)+,D2        ;Bytes/Scanline
                bsr     save_word       ;->Datei
                lea     cut_titel3(PC),A2
                bsr     Fwrite_str
                move.w  anz_scanlines(PC),D2
                bsr     save_word       ;->Datei

                tst.w   button_klicked  ;Maske oder Sprite?
                bne.s   L0512           ;Maske,->keine Palette
                lea     pal_string(PC),A2
                bsr     Fwrite_str
                lea     hbl_system+2,A3
                move.w  rst_akt,D4
                mulu    #34,D4
                adda.l  D4,A3           ;=Adresse der aktuellen Palette
                moveq   #1,D4
L050F:          moveq   #6,D3           ;Erstmal 7 Farben
L0510:          move.w  (A3)+,D2
                bsr     save_word
                lea     L0521(PC),A2    ;',$'
                bsr     Fwrite_str
                dbra    D3,L0510
                move.w  (A3)+,D2        ;Das 8. ohne ','
                bsr     save_word
                tst.w   D4              ;letzte Zeile?
                beq.s   L0511
                lea     L0524(PC),A2    ;CRLF $
                bsr     Fwrite_str
L0511:          dbra    D4,L050F        ;in 2 Zeilen
                bra.s   L0513

L0512:          lea     L0525(PC),A2    ;monochrom mask...
                bsr     Fwrite_str
L0513:          movea.l scr2,A3
                lea     L051F(PC),A2    ;CRLF CRLF
                bsr     Fwrite_str
L0514:          lea     L0520(PC),A2    ;CRLF CRLF Tab .dc.w TAB
                bsr     Fwrite_str
                move.w  #7,D4           ;immer 8 Werte pro Zeile
L0515:          move.w  (A3)+,D2        ;Wort holen
                bsr     save_word       ;->Datei
                subq.w  #1,D1           ;Anzahl der Worte vermindern
                beq.s   L0517           ;Schon alle in Datei?
                tst.w   D4              ;letztes Wort in dieser Zeile?
                beq.s   L0516           ;ja, kein Komma
                lea     L0521(PC),A2    ;',$'
                bsr     Fwrite_str
L0516:          dbra    D4,L0515        ;alle 8 pro Zeile
                bra.s   L0514           ;und bis zum Ende

L0517:          lea     L0522(PC),A2    ;CRLF EOF
                bsr     Fwrite_str
                movea.l copybox_screen,A0 ;Buffer gerade geleert worden?
                cmpa.l  A0,A1
                beq.s   L0518           ;ja, nichts schreiben
                suba.l  A0,A1
save_rest:      move.l  A0,-(SP)
                move.l  A1,-(SP)        ;Rest des Buffers->Datei
                move.w  handle,-(SP)
                move.w  #$0040,-(SP)    ;Fwrite
                trap    #1
                lea     12(SP),SP
                cmp.l   -8(SP),D0       ;Alle Bytes geschrieben?
                bne.s   del_error
L0518:          move.w  handle,-(SP)
                move.w  #$003E,-(SP)    ;alles Ok, Datei zu
                trap    #1
                addq.l  #4,SP
                lea     L0597(PC),A0    ;'      ' in Statuszeile
                bsr.s   print_status
                bra     save_data_end

del_error:      pea     filename
                move.w  #$0041,-(SP)    ;Unlink
                trap    #1
                addq.l  #6,SP
disk_error:     movea.l save_sp,SP      ;SP restaurieren
                lea     L0594(PC),A0    ;File write error
                bsr.s   print_status
                bra     save_data_end

print_status:   move.w  #204,D0
                move.w  #192,D1
                moveq   #0,D2
                bsr     print6x6
                rts

save_image:     add.w   D1,D1           ;Anzahl an Bytes
                movea.w D1,A1           ;Soviel Bytes
                movea.l scr2,A0         ;Ab hier speichern
                bra.s   save_rest

cut_titel:              DC.B '*',$0D,$0A
                        DC.B '*  NEOchrome V'
                        DC.B release_1+'0','.',release_2+'0',release_3+'0'
                        DC.B ' cut buffer contents (left justified):',$0D,$0A
                        DC.B '*  by Chaos, Inc. of the Delta Force (member of The Union)',$0D,$0A
                        DC.B '*',$0D,$0A
                        DC.B '*    pixels/scanline    = $',0
cut_titel2:             DC.B ' (bytes/scanline: $',0
cut_titel3:             DC.B ')',$0D,$0A
                        DC.B '*  # scanlines (height) = $',0
L051F:                  DC.B $0D,$0A,'*',$0D,$0A,'*',$00
L0520:                  DC.B $0D,$0A,$09,$09,'dc.w'
                        DC.B $09,'$',$00
L0521:                  DC.B ',$'
eol_s:                  DC.B 0
L0522:                  DC.B $0D,$0A,$1A,$00
pal_string:             DC.B $0D,$0A,'*',$0D,$0A,'*  '
                        DC.B 'Hardware'
                        DC.B ' color p'
                        DC.B 'allet  ('
                        DC.B 'color 0 '
                        DC.B 'to 15):',$0D
                        DC.B $0A,'*'
L0524:                  DC.B $0D,$0A,'*     '
                        DC.B ' $',$00
L0525:                  DC.B $0D,$0A,'*',$0D,$0A,'*  M'
                        DC.B 'onochrom'
                        DC.B 'e mask ('
                        DC.B '1 plane;'
                        DC.B ' backgro'
                        DC.B 'und=0/no'
                        DC.B 'n-backgr'
                        DC.B 'ound=1)',$0D
                        DC.B $0A,'*',$00,$00
                movem.l D0-D7/A2-A6,-(SP)
                andi.w  #$007F,D3
                move.w  D3,D2
                bsr.s   save_char
                movem.l (SP)+,D0-D7/A2-A6
                rts

crlf:                   DC.B 13,10,0

Fwrite_str:     movem.l D0-D7/A2-A6,-(SP)
L0527:          move.b  (A2)+,D2        ;Zeichen aus Titel holen
                beq.s   L0528           ;Null, dann beenden
                bsr.s   save_char       ;in Datei schreiben
                bra.s   L0527           ;und weiter schreiben
L0528:          movem.l (SP)+,D0-D7/A2-A6
                rts

;Hier ist noch save_long, wird aber nicht benîtigt..

                swap    D2
                bsr.s   save_word
                swap    D2
save_word:      move.w  D2,-(SP)
                lsr.w   #8,D2
                bsr.s   save_byte
                move.w  (SP)+,D2
save_byte:      movem.l D0-D7/A2-A6,-(SP)
                move.w  D2,-(SP)
                lsr.w   #4,D2           ;oberes Nibble
                bsr.s   save_hex        ;->Datei
                move.w  (SP)+,D2        ;unteres Nibble
                bsr.s   save_hex        ;->Datei
                movem.l (SP)+,D0-D7/A2-A6
                rts

hex_tab:                DC.B '01234567'
                        DC.B '89ABCDEF'

save_hex:       andi.w  #$000F,D2
                move.b  hex_tab(PC,D2.w),D2
                bsr.s   save_char
                rts

;Speichert einen Buchstaben mit Bufferung
;-> A1: Adresse des Buffers
;   A0: Ende des Buffers
save_char:      movem.l D0-D7/A2-A6,-(SP)
                move.b  D2,(A1)+        ;Byte in Diskbuffer
                cmpa.l  A0,A1           ;Buffer (1K) voll?
                bne.s   L052E           ;Nein -> raus
                suba.w  #$0400,A1       ;an Anfang von Buffer gehen
                move.l  A0,-(SP)
                move.l  A1,-(SP)        ;vom Anfang des Buffers an schreiben
                move.l  #$00000400,-(SP) ;1K
                move.w  handle,-(SP)
                move.w  #$0040,-(SP)    ;Schreiben
                trap    #1
                lea     8(SP),SP
                movea.l (SP)+,A1        ;Bufferstart wieder holen
                movea.l (SP)+,A0        ;und Bufferende
                cmpi.l  #$00000400,D0   ;alles auf Disk?
                bne     del_error       ;Nein -> Diskfehler
L052E:          movem.l (SP)+,D0-D7/A2-A6
                rts

save_data_end:  move.w  button_klicked,D5 ;Entsprechenden Button rÅcksetzen
                bsr     invert_button
L0530:          rts

line_opt:       move.w  D1,D5           ;Maus_y
                subi.w  #114,D5
                bcs.s   L0537           ;->RTS
                cmpi.w  #48,D5
                bcs.s   line_editor     ;->RTS
                cmpi.w  #198,D0         ;Maus_y
                bcs.s   L0537           ;->RTS
                cmpi.w  #234,D0
                bcs.s   L0533
                cmpi.w  #266,D0
                bcc.s   L0537           ;->RTS
                moveq   #3,D4
                move.w  #5,linestÑrke
L0532:          cmp.b   L0539(PC,D4.w),D5
                bcc.s   L0535
                dbra    D4,L0532
                bra.s   L0535
L0533:          moveq   #4,D4
                clr.w   linestÑrke
L0534:          cmp.b   L0538(PC,D4.w),D5
                bcc.s   L0535
                dbra    D4,L0534
L0535:          add.w   D4,linestÑrke
                bne.s   L0536
;                addq.w  #1,linestÑrke
L0536:          bsr     show_line_haken
                jsr     L0136
L0537:          rts

L0538:                  DC.B 49,56,62,68,75,$FF
L0539:                  DC.B 49,57,65,74

;User will den Linientyp editieren
line_editor:    movem.l D0-A6,-(SP)

                cmp.w   #line_edity,D1
                blt.s   raus_edit
                cmp.w   #line_edity+6,D1
                bgt.s   raus_edit

                sub.w   #line_editx+1,D0
                bmi.s   raus_edit
                divu    #5,D0
                cmp.w   #15,D0
                bgt.s   raus_edit
                moveq   #15,D1
                sub.w   D0,D1
                move.w  line_pattern,D0
                bchg    D1,D0           ;Bit Ñndern
                move.w  D0,line_pattern
                bsr     show_line_editor

raus_edit:      movem.l (SP)+,D0-A6
                rts


L053A:                                  ;     lea     L0591,A0 ;MÅûte Animate sein
                jsr     blitz
                move.l  L082E,D0
                bne.s   L053B
                bsr.s   L053F
                bra.s   L053D
L053B:          movea.l D0,A1
                moveq   #0,D0
L053C:          addq.w  #1,D0
                movea.l 6(A1),A1
                cmpa.l  #0,A1
                bne.s   L053C
                bsr.s   L0540
L053D:          move.l  L082D,D0
                bne.s   L053E
                bsr.s   L053F
                bsr.s   L053F
                bsr.s   L053F
                rts

L053E:          movea.l D0,A1
                movea.l 2(A1),A2
                move.b  (A2),D0
                bsr.s   L0540
                move.b  (A1),D0
                bsr.s   L0540
                movea.l 6(A1),A2
                move.b  (A2),D0
                bsr.s   L0540
                rts

L053F:          move.b  #'X',(A0)+
                move.b  #'X',(A0)+
                addq.l  #1,A0
                rts

L0540:          ext.w   D0
                beq.s   L053F
                ext.l   D0
                divu    #10,D0
                move.b  L0541(PC,D0.w),(A0)+
                swap    D0
                move.b  L0541(PC,D0.w),(A0)+
                addq.l  #1,A0
                rts

L0541:                  DC.B '0123456789'

;Schaltet die Buttons an oder aus...
on_off_buttons: movem.l D4-D6/A0-A1,-(SP)
                lea     L0575(PC),A0    ;Str-Koordinaten COPY
                moveq   #0,D5           ;enabled
                btst    #0,copy_status
                bne.s   L0543
                moveq   #3,D5           ;disabled
L0543:          lea     L0572(PC),A1    ;Str-Koordinaten JACK
                moveq   #0,D4
                btst    #0,jack_status
                bne.s   L0544
                moveq   #3,D4           ;disabled
L0544:          moveq   #7,D6           ;alle 8 Buttons
L0545:          move.w  D5,(A0)         ;COPY dis/enablen
                move.w  D5,54(A0)       ;und Fx auch
                addq.l  #6,A0           ;nÑchster...
                dbra    D6,L0545

                moveq   #9,D6           ;alle 10 Buttons
L0546:          move.w  D4,(A1)         ;Jack Knife Disablen
                move.w  D4,60(A1)       ;und Fx
                addq.l  #6,A1
                dbra    D6,L0546

                moveq   #3,D6           ;Disablen
                move.w  D6,-36(A0)      ;Paste (Copybox)
                move.w  D6,18(A0)
                move.w  D6,-48(A1)      ;Paste (Jack Knife)
                move.w  D6,12(A1)
                move.w  D6,-6(A1)       ;Print (Jack)
                move.w  D6,54(A1)

                tst.b   less_memory     ;Tastatur da?
                bne.s   L0547
                move.w  #-1,(A1)        ;Dann keine Fx anzeigen

L0547:          tst.w   pixel_per_scan  ;War was ausgeschnitten?
                beq.s   L0548           ;Nein
                clr.w   -36(A0)         ;Doch, Paste enablen (Copybox)
                clr.w   18(A0)
L0548:          tst.w   D4              ;Jack Knife enablen?
                beq.s   L0549           ;ja->RTS
                tst.w   pixel_per_scan  ;Wurde was ausgeschnitten?
                beq.s   L0549           ;Nein->RTS
                clr.w   -48(A1)
                clr.w   12(A1)          ;Paste enablen (Jack)
                clr.w   -6(A1)          ;Print (Jack) enablen
                clr.w   54(A1)
L0549:          tst.w   -6(A1)          ;Print (Jack) enabled?
                beq.s   raus1111
                move.w  #2,-6(A1)       ;nicht Schrift 3 sondern 2
raus1111:       clr.w   a_alias_strk
                clr.w   a_alias_strk+60
                movem.l (SP)+,D4-D6/A0-A1
                rts

;Schaltet die Buttons der Cutter-Options an oder aus... (CHS)
on_off_cutter:  clr.w   cut_rplck
                clr.w   cut_addk        ;enabled
                clr.w   cut_showk
                clr.w   cut_delk
                btst    #0,copy_status  ;Schon was ausgeschnitten?
                bne.s   L05432          ;ja
                move.w  #2,cut_addk     ;disabled
                move.w  #2,cut_rplck
L05432:         tst.l   mem_cutter      ;Schon ein Speicherbereich da?
                bne.s   select_rest     ;Ja,selektieren
                move.w  #2,cut_showk
                move.w  #2,cut_delk     ;disablen
                move.w  #2,cut_rplck
select_rest:    rts


;Alte L054A Tabelle:
                        DC.W $5880,$5CE0,$6140,$65A0
                        DC.W $6A00,$6E60,$72C0,$7720

L054A:                  DC.W 140*160+96
                        DC.W 146*160+96
                        DC.W 152*160+96
                        DC.W 158*160+96
                        DC.W 164*160+96
                        DC.W 170*160+96
                        DC.W 176*160+96
                        DC.W 182*160+96

inv_copy_btn:   not.b   invertiert      ;Flag umdrehen
                movem.l D0-D2/A0,-(SP)
                movea.l scr1,A0
                add.w   D5,D5
                adda.w  L054A(PC,D5.w),A0
                lsr.w   #1,D5
                move.l  #$00FF00FF,D0
                moveq   #-1,D1
                move.w  #6,D2
L054C:          eor.l   D0,(A0)+
                eor.l   D0,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                lea     120(A0),A0
                dbra    D2,L054C
                movem.l (SP)+,D0-D2/A0
                rts

;Offsets zu 4 Buttons auf dem Screen fÅr Camera
L054D:                  DC.W $6028
                        DC.W $6528
                        DC.W $6A28
                        DC.W $6F28

;D5: Buttonnummer
inv_camera_btn: movem.l D0-D2/A0,-(SP)  ;Invert Button im Camera.Optionsboard
                movea.l scr1,A0
                add.w   D5,D5
                adda.w  L054D(PC,D5.w),A0
                lsr.w   #1,D5
                move.l  #-$00FF0100,D0
                moveq   #-1,D1
                move.w  #6,D2
L0550:          eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
L0551:          eor.l   D1,(A0)+
L0552:          eor.l   D0,(A0)+
L0553:          eor.l   D0,(A0)+
                lea     $0088(A0),A0
                dbra    D2,L0550
                movem.l (SP)+,D0-D2/A0
                rts

invert_grab_btn:addq.w  #3,D5           ;ab Nr. 3 stehen Grabber.Offsets
                bsr.s   invert_button
                subq.w  #3,D5           ;Offset wieder zurÅck auf Button-Nr
;Auch in save_pal Ñndern!
                rts

L0554:                  DC.W 166*160+96 ;Offsets auf Screen zu Buttons (Sprite)
                        DC.W 173*160+96 ;(Maske)
                        DC.W 180*160+96 ;Save Image
                        DC.W 140*160+96 ;calculate Color
                        DC.W 148*160+96 ;Save Palette S
                        DC.W 156*160+96 ;Save Palette C

invert_button:  movem.l D0-D2/A0,-(SP)
                movea.l scr1,A0
                add.w   D5,D5           ;Nummer des Buttons
                adda.w  L0554(PC,D5.w),A0
                lsr.w   #1,D5
                move.l  #$00FF00FF,D0
                moveq   #-1,D1
                move.w  #6,D2
L0556:          eor.l   D0,(A0)+
                eor.l   D0,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+        ;zurÅckinvertieren
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                eor.l   D1,(A0)+
                not.l   D0
                eor.l   D0,(A0)+
                eor.l   D0,(A0)+
                not.l   D0
                lea     $0060(A0),A0
                dbra    D2,L0556
                movem.l (SP)+,D0-D2/A0
                rts

nozzle_opt:     move.w  D0,D3
                subi.w  #$00C6,D3
                bcs     L055D
                cmpi.w  #$0073,D3
                bcc     L055D
                move.w  D1,D4
                subi.w  #$008D,D4
                bcs     L055D
                cmpi.w  #$0037,D4
                bcs.s   L0558
                moveq   #$36,D4
L0558:          ext.l   D3
                divu    #$000D,D3
                cmpi.w  #7,D3
                bcs.s   L055A
                moveq   #$23,D3
                moveq   #0,D5
                cmpi.w  #$0015,D4
                bcs.s   L0559
                addq.w  #1,D5
                cmpi.w  #$0026,D4
                bcs.s   L0559
                addq.w  #1,D5
L0559:          move.w  D5,D4
                bra.s   L055B
L055A:          mulu    #5,D3
                ext.l   D4
                divu    #$000B,D4
L055B:          add.w   D4,D3
                tst.w   brush           ;Brush?
                beq.s   L055C
                movem.l D0-D3,-(SP)
                bsr     rahm_nozzle
                movem.l (SP)+,D0-D3
                move.w  D3,akt_nozzle
                movem.l D0-D3,-(SP)
                bsr     rahm_nozzle
                bsr     set_nozzle
                movem.l (SP)+,D0-D3
                rts
L055C:          movem.l D0-D3,-(SP)
                bsr     rahm_brush
                movem.l (SP)+,D0-D3
                move.w  D3,akt_brush
                movem.l D0-D3,-(SP)
                bsr     rahm_brush
                bsr     set_brush
                movem.l (SP)+,D0-D3
L055D:          rts

;Zeichnet den Linien-Editor neu:
show_line_editor:movem.l D0-A6,-(SP)

                moveq   #15,D6          ;16 Bits

                move.w  line_pattern,D7
                move.w  #line_editx+2,D0
                move.w  #line_edity+2,D1
                move.w  #line_edity+5,D3
                moveq   #0,D5           ;Schreibmodus

alle:           moveq   #0,D4           ;Farbe 0
                lsl.w   #1,D7
                bcc.s   leeren
                moveq   #15,D4
leeren:         move.w  D0,D2
                addq.w  #3,D2
                bsr     fill_box
                addq.w  #5,D0
                dbra    D6,alle

                movem.l (SP)+,D0-A6
                rts

show_line_haken:move.w  linestÑrke,D2
                bra.s   L0560
L055F:          move.w  randstÑrke,D2
L0560:          move.w  D2,-(SP)
                move.w  #202,D0
                move.w  #165,D1
                move.w  #208,D2
                move.w  #195,D3
                moveq   #0,D4
                move.w  #1,D5
                bsr     fill_box
                move.w  #237,D0
                move.w  #243,D2
                bsr     fill_box
                move.w  (SP)+,D2
                lea     haken(PC),A0
                move.w  #203,D0
                cmpi.w  #5,D2
                bcs.s   L0561
                move.w  #238,D0
L0561:          move.b  L0562(PC,D2.w),D1
                ext.w   D1
                addi.w  #114,D1
                moveq   #0,D2
                bsr     print6x6_inv
                rts

L0562:                  DC.B '38>EM3;C'
                        DC.B 'L',$00

show_style:     movem.l D0-D6/A0,-(SP)
                move.w  #199,D0
                move.w  #139,D1
                move.w  #206,D2
                move.w  #179,D3
                moveq   #0,D4
                move.w  #1,D5
                bsr     fill_box
                lea     haken(PC),A0
                move.w  #201,D0
                move.w  #140,D1
                move.w  text_style,D2
                bne.s   L0564
                bsr     print6x6_inv
                bra.s   L0568
L0564:          addq.w  #8,D1
                lsr.w   #1,D2
                bcc.s   L0565
                movem.l D0-D2/A0,-(SP)
                moveq   #0,D2
                bsr     print6x6_inv
                movem.l (SP)+,D0-D2/A0
L0565:          lsr.w   #1,D2
                move.w  #2,D3
L0566:          addq.w  #8,D1
                lsr.w   #1,D2
                bcc.s   L0567
                movem.l D0-D3/A0,-(SP)
                moveq   #0,D2
                bsr     print6x6_inv
                movem.l (SP)+,D0-D3/A0
L0567:          dbra    D3,L0566
L0568:          movem.l (SP)+,D0-D6/A0
                rts

show_height:    movem.l D0-D6/A0,-(SP)
                move.w  #278,D0
                move.w  #139,D1
                move.w  #286,D2
                move.w  #187,D3
                moveq   #0,D4
                move.w  #1,D5
                bsr.s   fill_box
                lea     haken(PC),A0
                move.w  #280,D0
                move.w  #182,D1
                move.w  text_height,D2
                move.w  #5,D3
L056A:          cmp.b   text_hîhen(PC,D3.w),D2
                beq.s   L056B
                subq.w  #8,D1
                dbra    D3,L056A
                bra.s   L056C
L056B:          moveq   #0,D2
                bsr     print6x6_inv
L056C:          movem.l (SP)+,D0-D6/A0
                rts

;Tabelle der verschiedenen Texthîhen bei der Textausgabe:
text_hîhen:             DC.B $04,$06,$08,$0D,$0C,$1A

show_align:     movem.l D0-D4/A0,-(SP)
                move.w  #$000F,D3
                move.w  text_align,D4
                mulu    #6,D4
                lea     L057C(PC),A0
                move.w  0(A0,D4.w),D2
                move.w  2(A0,D4.w),D0
                move.w  4(A0,D4.w),D1
                jsr     draw_func_inv
                movem.l (SP)+,D0-D4/A0
                rts

;Umrechentabelle Registernummer -> Vdi-Farbnummer
normal2vdi:             DC.B $00,$02,$03,$06,$04,$07,$05,$08
                        DC.B $09,$0A,$0B,$0E,$0C,$0F,$0D,$01

;Zeichnet ein ausgefÅlltes Rechteck
;Parameter:
;D0: x1
;D1: y1
;D2: x2
;D3: y2
;D4: Farbe
;D5: neuer Schreibmodus (VDI)
fill_box:       movem.l D0-D6/A0-A1,-(SP)

                lea     int_in,A1
                move.w  D5,(A1)
                move.l  #vswr_mode,D0   ;Schreibmodus setzen
                jsr     _vdi

                clr.w   (A1)
                move.b  normal2vdi(PC,D4.w),1(A1)
                move.l  #vsf_color,D0
                jsr     _vdi

                move.w  #1,(A1)         ;voll ausfÅllen
                move.l  #vsf_interior,D0
                jsr     _vdi

                movem.l (SP),D0-D6/A0-A1 ;Koordinaten holen
                movem.w D0-D3,ptsin     ;Koordinaten eintragen
                move.l  #vr_recfl,D0
                bsr     _vdi            ;war vorher fill_area

                movem.l (SP)+,D0-D6/A0-A1
                rts

;Tabelle, die das Aussehen der Optionboxes bestimmt:
opt:                    DC.B $FF,$FF,$00,$00,$00,$DC,$00,$84
                        DC.B $FF,$FF

line_strk:              DC.W 0,205,143
                        DC.W 0,206,151
                        DC.W 0,208,132
                        DC.W -1

;alte Jack_strk (unbenutzt)
                        DC.W 0,202,132
                        DC.W 3,206,141
                        DC.W 3,206,147
                        DC.W 3,206,153
                        DC.W 3,206,159
                        DC.W 3,255,141
                        DC.W 3,255,147
                        DC.W 3,255,153
                        DC.W 3,255,159
                        DC.W -1

                        DC.W 0,223,132
                        DC.W -1

misc_fill:              DC.W 198,130,313,138 ;Titelbalken
                        DC.W -1

line_fill:              DC.W $00C6,$0082
                        DC.B $01,$39,$00,$8A,$00,$D4,$00,$AD
                        DC.B $00,$E6,$00,$AD,$00,$D4,$00,$B2
                        DC.B $00,$E6,$00,$B3,$00,$D4,$00,$B8
                        DC.B $00,$E6,$00,$BA,$00,$D4,$00,$C0
                        DC.B $00,$E6,$00,$C3,$00,$F6,$00,$A5
                        DC.B $01,$08,$00,$A9,$00,$F6,$00,$AC
                        DC.B $01,$08,$00,$B1,$00,$F6,$00,$B4
                        DC.B $01,$08,$00,$BA,$00,$F6,$00,$BD
                        DC.B $01,$08,$00,$C4,$FF,$FF

box_icons:              DC.W 103,270,170
                        DC.W 19,292,170
                        DC.W 87,211,166

boxicons:               DC.W 81,199,139
                        DC.W 82,222,139
                        DC.W 83,245,139
                        DC.W 84,268,139
                        DC.W 85,291,139
                        DC.W -1

                        DC.W 198,130,313,162
                        DC.W 198,162,266,199
                        DC.W 266,162,313,199
                        DC.W -1

line_rahmen:            DC.W 198,130,313,161
                        DC.W 198,161,313,199
                        DC.W -1

copy_fill:              DC.W $00C6,$0082,$0110,$008A
                        DC.W $0112,$0082,$0139,$008A
                        DC.W -1

;Rahmen der Copybox (Alte, nicht gebrauchte Version)
                        DC.W 198,138,313,199
                        DC.W 273,138,313,199
                        DC.W 273,161,313,179
                        DC.W -1

;Copybox Textkoord: (werden nicht mehr gebraucht)
                        DC.W 0,211,132
                        DC.W 0,283,132
                        DC.W 3,206,142
                        DC.W 3,206,148
                        DC.W 3,206,154
                        DC.W 3,206,160
                        DC.W 3,206,166
                        DC.W 3,206,172
                        DC.W 3,206,178
                        DC.W 3,206,184
                        DC.W -1,299,168 ;Stop, wenn wenig speicher, ab hier Tasten
                        DC.W 3,255,142
                        DC.W 3,255,149
                        DC.W 3,255,156
                        DC.W 3,255,163
                        DC.W 3,255,170
                        DC.W 3,255,177
                        DC.W 3,255,184
                        DC.W 3,255,191
                        DC.W -1

;Icons von Copybox (werden nicht mehr gebraucht)
                        DC.B $00,$58,$01,$29,$00,$BA
                        DC.B $00,'K',$01,$13,$00,$A3
                        DC.B $00,'J',$01,$13,$00,$B5,$00,'@'
                        DC.B $01,$17,$00,$8C,$00,'A',$01,'*'
                        DC.B $00,$8C,$FF,$FF

jack_icon:              DC.W 64,279,140
                        DC.W 65,298,140
                        DC.W 90,286,164
                        DC.W -1

davek:                  DC.W 0,233,163 ;165
                        DC.W 0,227,170 ;173
                        DC.W 0,251,177 ;181
                        DC.W 1,215,185 ;190
                        DC.W -1

                        DC.W -1 ;FrÅher Dave_rahmen

                        DC.W 0,212,141
                        DC.W 1,218,149 ;FrÅher smokek
                        DC.W 0,232,165
                        DC.W 1,218,173
                        DC.W -1

text_fill:              DC.W $00C6,$0082,$0139,$008A
                        DC.W $00C6,$00B5,$00EE,$00BD
                        DC.W $00C6,$00BF,$00E3,$00C7
                        DC.W -1

text_rahm:              DC.W 198,130,313,199
                        DC.W 198,191,313,199
                        DC.W 276,130,313,191
                        DC.W 238,181,276,189
                        DC.W -1

text_strk:              DC.W 16,210,173
                        DC.W 0,212,132
                        DC.W 0,283,132
                        DC.W 0,204,183
                        DC.W 0,201,193
                        DC.W 0,211,140
                        DC.W 1,211,148
                        DC.W 4,211,156
                        DC.W 8,211,164
                        DC.W 16,290,142
                        DC.W 16,290,150
                        DC.W 0,289,159
                        DC.W 16,288,166
                        DC.W 0,288,175
                        DC.W 0,290,182
L057B:                  DC.W 0,230,193
                        DC.W -1

L057C:                  DC.B $00,$14,$00,$F0,$00,$B6,$00,$15
                        DC.B $00,$FC,$00,$B6,$00,$16,$01,$08
                        DC.B $00,$B6,$FF,$FF

brush_icon:             DC.W $001A,$00CD,$0091
                        DC.W $001B,$00CC,$009B
                        DC.W $001C,$00CC,$00A6
                        DC.W $001D,$00CB,$00B0
                        DC.W $001E,$00CA,$00BA
                        DC.W $001F,$00D9,$0091

                        DC.B $00,$20,$00,$D9,$00,$9B,$00,$21
                        DC.B $00,$D8,$00,$A6,$00,$22,$00,$D8
                        DC.B $00,$B1,$00,$23,$00,$D7,$00,$BB
                        DC.B $00,$24,$00,$E6,$00,$91,$00,$25
                        DC.B $00,$E6,$00,$9B,$00,$26,$00,$E6
                        DC.B $00,$A6,$00,$27,$00,$E5,$00,$B0
                        DC.B $00,$28,$00,$E4,$00,$BB,$00,$29
                        DC.B $00,$F3,$00,$91,$00,$2A,$00,$F3
                        DC.B $00,$9B,$00,$2B,$00,$F3,$00,$A6
                        DC.B $00,$2C,$00,$F2,$00,$B0,$00,$2D
                        DC.B $00,$F2,$00,$BB,$00,$2E,$01,$01
                        DC.B $00,$91,$00,$2F,$01,$01,$00,$9B
                        DC.B $00,$30,$01,$01,$00,$A6,$00,$31
                        DC.B $01,$01,$00,$B0,$00,$32,$01,$01
                        DC.B $00,$BB,$00,$33,$01,$0E,$00,$92
                        DC.B $00,$34,$01,$0D,$00,$9D,$00,$35
                        DC.B $01,$0D,$00,$A7,$00,$36,$01,$0C
                        DC.B $00,$B2,$00,$37,$01,$0C,$00,$BE
                        DC.B $00,$38,$01,$1B,$00,$92,$00,$39
                        DC.B $01,$1A,$00,$9B,$00,$3A,$01,$19
                        DC.B $00,$A5,$00,$3B,$01,$18,$00,$AF
                        DC.B $00,$3C,$01,$18,$00,$BA,$00,$3D
                        DC.B $01,$25,$00,$8F,$00,$3E,$01,$26
                        DC.B $00,$A5,$00,$3F,$01,$28,$00,$B7
                        DC.B $FF,$FF

;Alte Misc-Rahmen, jetzt unbenÅtzt:
                        DC.W 258,139,258,163
                        DC.W 260,151,269,151
                        DC.W 302,151,311,151
                        DC.W 198,164,313,164
                        DC.W 198,130,313,199
                        DC.W -1

;Alter Jack_Rahmen
                        DC.W 273,130,313,199
;Alter Brush_Rahmen
                        DC.W 198,130,313,199
                        DC.W -1

brush_fill:             DC.W 198,130,313,138
                        DC.W -1

brush_strk:             DC.W 0,220,132
                        DC.W -1

;Alten Misc_strk (werden nicht mehr gebraucht)
                        DC.W 0,226,132
                        DC.W 0,217,142
                        DC.W 0,272,141
                        DC.W 0,266,157
                        DC.W 0,210,168
                        DC.W 0,204,176
                        DC.W -1

;Camera-Textkoord: (alt, jetzt unbenÅtzt)
                        DC.W 0,220,132
                        DC.W 0,281,142
                        DC.W 0,278,154
                        DC.W 3,278,162
                        DC.W 0,282,170
                        DC.W 0,278,183
                        DC.W 0,208,146
                        DC.W 0,224,178
                        DC.W 0,288,192
                        DC.W 0,237,146
                        DC.W 0,208,162
                        DC.W 0,228,162
                        DC.W 0,250,162
                        DC.W -1

;Camera-Fillbox: (alt, jetzt unbenÅtzt)
                        DC.W 198,130,313,138 ;alle ausgefÅllten FlÑchen
                        DC.W 270,140,313,148
                        DC.W 270,181,313,189
                        DC.W -1

;Camera-Rahmen: (alt, jetzt unbenÅtzt)
                        DC.W 198,130,313,199 ;Alle Rahmenkoordinaten
                        DC.W 270,138,313,199
                        DC.W 198,189,313,199
                        DC.W 205,144,227,152
                        DC.W 234,144,249,152
                        DC.W 224,159,242,169
                        DC.W 225,160,241,168
                        DC.W 221,176,243,184
                        DC.W 206,160,220,168
                        DC.W 248,160,262,168
                        DC.W -1

;Camera-Icons: (alt, jetzt unbenÅtzt)
                        DC.W 70,222,152
                        DC.W 70,242,152
                        DC.W 70,229,169
                        DC.W 69,235,152
                        DC.W 71,201,159
                        DC.W 72,261,159
                        DC.W 73,257,176
                        DC.W -1

                        DC.W 0  ;frÅher akt_brush
                        DC.W 0  ;frÅher akt_nozzle
cutbuffer_x:            DS.W 1
cutbuffer_y:            DS.W 1
pixel_per_scan:         DS.W 1  ;Anzahl der Pixel/Scanline fÅr Abspeichern
anz_scanlines:          DS.W 1
                        DC.W 0  ;frÅher just_rahmen
                        DC.W 0  ;frÅher strichstÑrke
                        DC.W 0  ;frÅher Boxtyp
                        DC.W $0001 ;FrÅher LinienstÑrke

;Alte Misc_str (werden nicht mehr gebraucht)
                        DC.B 'MISCELLANY',$00
                        DC.B 'x: /y:',0
                        DC.B 'color',0
                        DC.B 'palette',0
                        DC.B 'CUT=>HEX .S FILE',0
                        DC.B 'MASK=>HEX .M FILE',0

;Strings Copybox: (Alte Version, wird nicht mehr gebraucht)
                        DC.B 'COPY BOX',0
                        DC.B 'MODE',0
                        DC.B 'CUT',0
                        DC.B 'COPY',0
                        DC.B 'PASTE',0
                        DC.B 'CLEAR',0
                        DC.B 'ROTATE',0
                        DC.B 'H-FLIP',0
                        DC.B 'V-FLIP',0
                        DC.B 'T-EDGE',0
                        DC.B 'F9',$00
                        DC.B 'F1',$00
                        DC.B 'F2',$00
                        DC.B 'F3',$00
                        DC.B 'F4',$00
                        DC.B 'F5',$00
                        DC.B 'F6',$00
                        DC.B 'F7',$00
                        DC.B 'F8',$00

                        DC.B 'OUTLINE',0
                        DC.B 'S T Y L E',0
                        DC.B 'SIZ'
                        DC.B 'E',$00,'ALIGN',$00
                        DC.B 'FACE',$00,'PLA'
                        DC.B 'IN',$00,'BOLD',$00
                        DC.B 'ITALIC',$00,'U'
                        DC.B 'NDERLINE'
                        DC.B $00,'6 ',$00,'8 ',$00,'1'
                        DC.B '2 ',$00,'14',$00,'16'
                        DC.B $00,'28',$00
L058B:                  DC.B 'SYSTEM  '
                        DC.B '     ',$00
L058C:                  DC.B 'EXTENDED'
                        DC.B ' SYS.',$00

dave:                   DC.B 'Designed',$00
                        DC.B 'Programmed',0
                        DC.B 'by',$00
                        DC.B 'DAVE STAUGAS',0

                        DC.B 'Smoke & Mirrors',0 ;Alte Strings...
                        DC.B 'JIM EISENSTEIN',0
                        DC.B 'Graphics',0
                        DC.B 'JEROME DOMURAT',0

;Alte Jack Strings (unbenÅtzt):
                        DC.B 'J A C K  K N I F E',0
                        DC.B 'CUT',0
                        DC.B 'COPY',0
                        DC.B 'PASTE',0
                        DC.B 'CLEAR',0
                        DC.B 'F1',0
                        DC.B 'F2',0
                        DC.B 'F3',0
                        DC.B 'F4',0

brush_str:              DC.B 'B R U S H E S',$00

                        DC.B 'N O Z Z L E S',0
                        DC.B 'G R A B B E R',0
                        DC.B 'P E N C I L',0

line_str:               DC.B '      EDITOR     ',0
                        DC.B '                ',0
                        DC.B 'L I N E  D R A W',0

                        DC.B 'A R E'
                        DC.B ' A  F I '
                        DC.B 'L L',$00,'E R '
                        DC.B 'A S E R',$00
                        DC.B 'S H A P '
                        DC.B 'E S',$00

;Camera-Strings: (alt, unbenÅtzt)
                        DC.B 'A N I M A T E',0
                        DC.B 'FILE',$00
                        DC.B 'LOAD ',$00
                        DC.B 'SAVE ',$00
                        DC.B 'NEW',0
                        DC.B 'MAX #',$00
                        DC.B 'ADD',$00
                        DC.B 'DEL',$00
                        DC.B ' '
                        DC.B ' ',$00
                        DC.B 'XX',$00
                        DC.B 'XX',$00
                        DC.B 'XX',$00
                        DC.B 'XX',$00

haken:                  DC.B '',0
L0593:                  DC.B ' CUT BUFFER EMPTY ',0
L0594:                  DC.B ' FILE WRITE ERROR ',0
L0595:                  DC.B 'MAKE:'
L0596:                  DC.B 'COPYBxxx.'
                        DC.B 'IMG',$00
L0597:                  DC.B '        '
                        DC.B '        '
                        DC.B '  ',$00
L0598:                  DC.B 'UNDO',$00
L0599:                  DS.W 1
L059A:                  DC.B 'COPYB*.'
L059B:                  DC.B 'IMG',0 ;bzw. S/M


grid_on:                DC.B $00 ;StandardmÑûig aus

;Cutter Stringkoordinaten
cut_strk:               DC.W 0,226,132
                        DC.W 0,281,142
cut_loadk:              DC.W 0,278,154
cut_savek:              DC.W 3,278,162
                        DC.W 3,282,170
                        DC.W 3,274,178
cut_rplck:              DC.W 2,206,146 ;REPLACE
cut_addk:               DC.W 2,245,146 ;ADD
cut_delk:               DC.W 2,212,178 ;DEL
cut_showk:              DC.W 2,237,178 ;SHOW
cut_spc1k:              DC.W 0,288,192
cut_leftk:              DC.W 0,205,162 ;Pfeil links
                        DC.W 0,226,162
                        DC.W 0,247,162 ;Pfeil rechts
                        DC.W -1

;Cutter-Strings:
cut_str:                DC.B 'C U T T E R',0
                        DC.B 'FILE',$00
cut_load:               DC.B 'LOAD ',$00
                        DC.B 'SAVE ',$00
                        DC.B 'NEW',0
                        DC.B 'RE-CUT',0
cut_rplc:               DC.B 'CHNGE',0
                        DC.B 'ADD',$00
                        DC.B 'DEL',$00
                        DC.B 'SHOW',0
cut_spc1:               DC.B ' '
cut_spc2:               DC.B ' ',$00
cut_left:               DC.B 'XXX',$00
cut_mid:                DC.B 'XXX',$00
cut_right:              DC.B 'XXX',$00

;Cutter-Fillbox:
cut_fill:               DC.W 198,130,313,138 ;alle ausgefÅllten FlÑchen
                        DC.W 270,140,313,148
                        DC.W -1

;Cutter-Rahmen:
cut_rahmen:             DC.W 270,138,313,199
                        DC.W 198,189,313,199 ;Unterer Rahmen
                        DC.W 223,159,245,169 ;Akt_Objekt
                        DC.W 224,160,244,168 ;-'-
                        DC.W 198,130,313,199 ;groûer Rahmen
cut_btn:                DC.W 242,144,264,152 ;Add
                        DC.W 204,144,237,152 ;Replace
                        DC.W 209,176,231,184 ;Del
                        DC.W 235,176,261,184 ;Show
                        DC.W 204,160,223,168 ;Pfeil links
                        DC.W 245,160,264,168 ;Pfeil rechts
                        DC.W -1

;Cutter-Icons:
cut_icon:               DC.W 70,242,152 ;Pfeil runter Add
                        DC.W 70,230,152 ;Pfeil runter Replace
                        DC.W 70,224,169 ;Pfeil runter, DEL
                        DC.W 70,236,169 ;Pfeil runter, Show
                        DC.W 71,199,159 ;Pfeilspitze links
                        DC.W 72,263,159 ;Pfeilspitze rechts
                        DC.W -1

disk_rahm:              DC.W 198,130,313,188 ;Groûer Rahmen
                        DC.W 198,146,313,146 ;Strich unter Load-Save
                        DC.W 255,138,255,188 ;Senkrechter Trennstrich
                        DC.W 198,191,238,199 ;Rahmen um Format
                        DC.W 242,191,282,199 ;Rahmen um Delete
                        DC.W 286,191,313,199 ;Rahmen um Quit
                        DC.W -1

disk_fill:              DC.W 198,130,313,138
                        DC.W -1

disk_strk:              DC.W 0,220,132 ;Options
                        DC.W 1,212,140 ;load
                        DC.W 1,269,140 ;save
                        DC.W 0,201,193 ;Format
                        DC.W 0,245,193 ;Delete
                        DC.W 0,289,193 ;Quit

haken_loadk:            DC.W 0,204,149
                        DC.W 0,204,156
                        DC.W 0,204,163
                        DC.W 0,204,170
                        DC.W 0,204,177

haken_savek:            DC.W 0,262,149
                        DC.W 0,262,156
                        DC.W 0,262,163
                        DC.W 0,262,170
                        DC.W 0,262,177

                        DC.W 0,213,149 ;Extensions
                        DC.W 0,213,156
                        DC.W 0,213,163
                        DC.W 0,213,170
                        DC.W 0,213,177

                        DC.W 0,271,149
                        DC.W 0,271,156
                        DC.W 0,271,163
                        DC.W 0,271,170
                        DC.W 0,271,177

                        DC.W -1

disk_str:               DC.B 'O P T I O N S',0
                        DC.B 'LOAD:',0
                        DC.B 'SAVE:',0
                        DC.B 'FORMAT',0
                        DC.B 'DELETE',0
                        DC.B 'QUIT',0

haken_load:             DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
haken_save:             DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B '*.NEO',0
                        DC.B '*.PI1',0
                        DC.B '*.PC1',0
                        DC.B '*.IFF',0
                        DC.B '*.DOO',0
extensions:             DC.B '*.NEO',0 ;0
                        DC.B '*.PI1',0 ;1
                        DC.B '*.PC1',0 ;2
                        DC.B '*.IFF',0 ;3
                        DC.B '*.DOO',0 ;4
                        DC.B '*.OBJ',0 ;5
                        DC.B '*.ANI',0 ;6
                        DC.B '*.S',0,0,0 ;7
                        DC.B '*.C',0,0,0 ;8
                        DC.B '*.RST',0 ;9
                        DC.B '*.PAL',0 ;10
                        DC.B '*.S',0,0,0 ;11
                        DC.B '*.M',0,0,0 ;12
                        DC.B '*.IMG',0 ;13
disk_icon:              DC.L -1

grab_strk:              DC.W 0,220,132
                        DC.W 0,209,141
                        DC.W 0,209,149
                        DC.W 0,209,157
                        DC.W 0,210,167
                        DC.W 0,204,174
                        DC.W 0,210,181
                        DC.W -1

grab_str:               DC.B 'G R A B B E R',0
                        DC.B 'CALCULATE COLORS',0
                        DC.B 'SAVE PALETTE *.S',0
                        DC.B 'SAVE PALETTE *.C',0
                        DC.B 'CUT=>HEX .S FILE',0
                        DC.B 'MASK=>HEX .M FILE',0
                        DC.B 'CUT=>IMAGE FILE',0

;Rahmen der Copybox (Neue, verÑnderte Version)
copy_rahmen:            DC.W 198,138,313,199
                        DC.W 273,138,313,199
                        DC.W 273,161,313,179
                        DC.W 198,189,273,189
                        DC.W -1

;Copybox Textkoord (neue, verÑnderte Version)
copy_strk:              DC.W 0,211,132
                        DC.W 0,283,132
L0575:                  DC.W 3,206,141
                        DC.W 3,206,147
L0576:                  DC.W 3,206,153
                        DC.W 3,206,159
                        DC.W 3,206,165
                        DC.W 3,206,171
                        DC.W 3,206,177
                        DC.W 3,206,183
L0577:                  DC.W -1,299,168 ;Stop, wenn wenig speicher, ab hier Tasten
                        DC.W 3,255,141
                        DC.W 3,255,147
                        DC.W 3,255,153
                        DC.W 3,255,159
                        DC.W 3,255,165
                        DC.W 3,255,171
                        DC.W 3,255,177
                        DC.W 3,255,183
winkel_koord:           DC.W 0,222,192
                        DC.W -1

;Strings Copybox: (neue, verÑnderte Version)
copy_str:               DC.B 'COPY BOX',0
                        DC.B 'MODE',0
L058A:                  DC.B 'CUT',0
                        DC.B 'COPY',0
                        DC.B 'PASTE',0
                        DC.B 'CLEAR',0
                        DC.B 'ROTATE',0
                        DC.B 'H-FLIP',0
                        DC.B 'V-FLIP',0
                        DC.B 'T-EDGE',0
                        DC.B 'F9',$00
                        DC.B 'F1',$00
                        DC.B 'F2',$00
                        DC.B 'F3',$00
                        DC.B 'F4',$00
                        DC.B 'F5',$00
                        DC.B 'F6',$00
                        DC.B 'F7',$00
                        DC.B 'F8',$00
winkel_ascii:           DC.B '090¯',0

;Icons von Copybox (Neue, verÑnderte Version)
copy_icon:              DC.W 88,297,186
L0579:                  DC.W 75,275,163 ;Resize
L057A:                  DC.W 74,275,181
                        DC.W 64,279,140
                        DC.W 65,298,140
                        DC.W 92,206,190
rotate_richtung:        DC.W 93,263,190
                        DC.W -1

;Stringkoordinaten der Miscellany-Funktion (neue, verÑnderte Werte)
misc_strk:              DC.W 0,226,132
                        DC.W 0,214,141
blitter_da:             DC.W 2,214,148
                        DC.W 0,214,155
yyy_koord:              DC.W 0,226,162
nop_strk:               DC.W 0,214,169
magtyp_strk:            DC.W 0,214,176
                        DC.W 0,214,183
                        DC.W 0,270,141
                        DC.W 0,270,148
music_nrstrk:           DC.W 0,270,155 ;Music
                        DC.W 0,270,162
syncs_strk:             DC.W 0,270,169
                        DC.W 0,270,176
                        DC.W 0,270,183
param_save:             DC.W 2,207,192
                        DC.W -1

;String der Misc-Funktion (neue, verÑnderte Werte)
misc_str:               DC.B 'MISCELLANY',$00
                        DC.B 'STE',0
                        DC.B 'BLITTER',0
                        DC.B 'MAGNIFY',0
yyy:                    DC.B 'Y: 8',0
nop_str:                DC.B 'NOP:200',0
mag_str:                DC.B 'TYP: 0',0
                        DC.B 'SEGMENT',0
                        DC.B 'COLOR #',0
                        DC.B 'PORTA 7',0
music_str:              DC.B 'MUSIC '
music_nrstr:            DC.B 'x',0
                        DC.B "S-SAVER",0
sync_str:               DC.B 'SYNC 60',0
                        DC.B 'USER 1',0
                        DC.B 'USER 2',0

                        DC.B 'SAVE ALL OPTIONS',0

misc_rahmen:            DC.W 258,139,258,189
save_rahmen:            DC.W 198,189,313,199
                        DC.W 198,130,313,199
                        DC.W -1

grab_rahm:              DC.W 198,164,313,164
                        DC.W 198,130,313,199
                        DC.W -1

smokek:                 DC.W 0,215,133
                        DC.W 1,210,133+8
                        DC.W 0,235,133+20
                        DC.W 1,210,133+20+8
                        DC.W 0,205,133+40
                        DC.W 1,218,133+40+8
                        DC.W -1

smoke:                  DC.B 'SMOKE & MIRRORS',0 ;Alte Strings...
                        DC.B 'JIM EISENSTEIN',0
                        DC.B 'GRAPHIX',0
                        DC.B 'JEROME DOMURAT',0
                        DC.B 'ADVANCED FEATURES',0
                        DC.B 'CHAOS, INC.',0

;Camera-Textkoord:
camera_strk:            DC.W 0,220,132
                        DC.W 0,281,142
L057D:                  DC.W 0,278,151
L057E:                  DC.W 0,278,159
rechter_strk:           DC.W 0,247,158 ;Pfeil rechts
                        DC.W 0,205,158 ;Pfeil links
akt_obj_strk:           DC.W 0,226,158 ;Pfeil akt
                        DC.W 0,212,182
akt_sequenz_strk:       DC.W 0,229,191
ping_strk:              DC.W 0,274,168
                        DC.W -1

;Camera-Strings:
camera_str:             DC.B 'A N I M A T E',0
                        DC.B 'FILE',$00
L058E:                  DC.B 'LOAD ',$00
                        DC.B 'SAVE ',$00
rechter_rand:           DC.B '001',$00
linker_rand:            DC.B '001',$00
akt_objekt:             DC.B '001',$00
                        DC.B 'SEQUENZ:',0
akt_sequenz:            DC.B '00',0
ping_str:               DC.B '   ',0

;Camera-Fillbox:
camera_fill:            DC.W 198,130,313,138 ;alle ausgefÅllten FlÑchen
                        DC.W 270,140,313,148
pos_fill:               DC.W 273,176,286,181 ;l.o.
                        DC.W 296,176,296,176 ;r.o.
                        DC.W 273,192,273,192 ;l.u.
                        DC.W 296,192,296,192 ;r.u.
                        DC.W 284,184,284,184 ;mitte
                        DC.W -1

;Camera-Rahmen:
camera_rahm:            DC.W 198,130,313,199 ;groûer Rahmen
                        DC.W 270,138,313,199 ;Rahmen um File
                        DC.W 223,155,245,165 ;Zentrum1
                        DC.W 224,156,244,164 ;Zentrum2
                        DC.W 225,189,243,197 ;Seq-Nummer
                        DC.W 273,176,310,197 ;Screen-Pos-Rahmen
                        DC.W 270,174,313,174 ;Trennstrich

camera_buttons:         DC.W 206,144,220,153 ;links up
                        DC.W 206,167,220,176 ;links down
                        DC.W 248,144,262,153 ;rechts up
                        DC.W 248,167,262,176 ;rechts down
                        DC.W 204,156,223,164 ;Links
                        DC.W 245,156,264,164 ;Rechts
                        DC.W 206,189,220,197 ;Seq-links
                        DC.W 248,189,262,197 ;Seq-Rechts

pos_rahmen:             DC.W 273,176,286,181 ;l.o.
                        DC.W 296,176,310,181 ;r.o.
                        DC.W 273,192,286,197 ;l.u.
                        DC.W 296,192,310,197 ;r.u.
                        DC.W 284,184,299,189 ;mitte
                        DC.W 270,166,313,174 ;ping Pong?
                        DC.W -1

;Camera-Icons:
camera_icon:            DC.W 69,210,145 ;Links Up
                        DC.W 70,210,168 ;links down
                        DC.W 69,252,145 ;rechts up
                        DC.W 70,252,168 ;rechts down
                        DC.W 71,199,155 ;Pfeil links
                        DC.W 72,263,155 ;Pfeil rechts
                        DC.W 71,201,188 ;Seq-links-spitze
                        DC.W 72,261,188 ;Seq-rechts-spitze
                        DC.W -1

raster_fill:            DC.W 198,130,313,138 ;R A S T E R
                        DC.W 270,140,313,148 ;File
                        DC.W -1

raster_rahm:            DC.W 198,130,313,199 ;Groûer Rahmen
                        DC.W 270,138,313,199 ;Rahmen um File
                        DC.W 223,164,246,174 ;Akt Palette
                        DC.W 224,165,245,173 ;-'-
raster_buttons:         DC.W 226,151,234,161 ;Pfeil hoch
                        DC.W 236,148,244,157 ;Pfeil runter
                        DC.W 248,165,261,173 ;Pfeil rechts
                        DC.W 208,165,221,173 ;Pfeil links
                        DC.W 209,181,231,189 ;Del
                        DC.W 235,181,261,189 ;Show
                        DC.W -1

raster_strk:            DC.W 0,220,132
                        DC.W 0,281,142
                        DC.W 0,281,151
                        DC.W 0,281,159
                        DC.W 0,284,167
                        DC.W 0,284,175
                        DC.W 0,279,183
                        DC.W 0,274,191
                        DC.W 0,212,183
                        DC.W 0,237,183
raster_koord:           DC.W 0,227,167
raster_widthk:          DC.W 0,209,193
                        DC.W 0,212,154
                        DC.W 0,247,150
                        DC.W -1

raster_str:             DC.B 'R A S T E R S',0
                        DC.B 'FILE',$00
                        DC.B 'LOAD',$00
                        DC.B 'SAVE',$00
                        DC.B 'GET',0
                        DC.B 'PUT',0
                        DC.B 'CLEAR',0
                        DC.B 'LD PAL',0
                        DC.B 'DEL',0
                        DC.B 'SHOW',0
raster_nummer:          DC.B '000',0
raster_widthstr:        DC.B 'Y:'
raster_width:           DC.B '000-999',0
                        DC.B 'IN',0
                        DC.B 'OUT',0

raster_icon:            DC.W 96,204,142 ;Minipalette
                        DC.W 98,225,146 ;Pfeilspitze hoch
                        DC.W 97,235,156 ;Pfeilspitze runter
                        DC.W 71,203,164 ;Pfeilspitze links
                        DC.W 72,260,164 ;Pfeilspitze rechts
                        DC.W 70,224,174 ;Pfeil runter, DEL
                        DC.W 70,236,174 ;Pfeil runter, Show
                        DC.W -1

jack_strk:              DC.W 0,202,132
L0572:                  DC.W 3,202,141 ;F1
                        DC.W 3,202,147 ;F2
                        DC.W 3,202,153 ;F3
                        DC.W 3,202,159 ;F4
                        DC.W 3,202,165 ;F5
a_alias_strk:           DC.W 0,202,171 ;F6
                        DC.W 3,202,177
                        DC.W 3,202,183
                        DC.W 3,202,189
                        DC.W 2,280,193
L0573:                  DC.W 3,258,141 ;F1
                        DC.W 3,258,147 ;F2
                        DC.W 3,258,153 ;F3
                        DC.W 3,258,159 ;F4
                        DC.W 3,258,165 ;F5
                        DC.W 0,258,171 ;F6
                        DC.W 3,258,177
                        DC.W 3,258,183
                        DC.W 3,258,189
                        DC.W 3,258,189
                        DC.W -1

jack_str:               DC.B 'J A C K  K N I F E',0
L058D:                  DC.B 'CUT',0
                        DC.B 'COPY',0
                        DC.B 'PASTE',0
                        DC.B 'CLEAR',0
                        DC.B 'REMAP',0
                        DC.B 'A-ALIAS',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B ' ',0
                        DC.B 'PRINT',0
                        DC.B 'F1',0
                        DC.B 'F2',0
                        DC.B 'F3',0
                        DC.B 'F4',0
                        DC.B 'F5',0
                        DC.B 'F6',0
                        DC.B 0
                        DC.B 0
                        DC.B 0
                        DC.B 0

jack_rahm:              DC.W 273,130,313,199
                        DC.W 273,191,313,191
brush_rahmen:           DC.W 198,130,313,199
                        DC.W -1

line_icon:              DC.W 102,line_editx,line_edity
                        DC.W 87,211,166 ;Strichlinie
                        DC.W -1

L05A0:          add.w   D0,D2
                subq.w  #1,D2
                and.l   #$0000FFF0,D0
                and.w   #-$0010,D2
                sub.w   D0,D2
                lsr.w   #4,D2
                addq.w  #1,D2
                add.w   D3,D1
                subq.w  #1,D1
                move.w  A2,D4
                mulu    D4,D1
                lsr.w   #1,D0
                add.l   D1,D0
                adda.l  D0,A0
                move.w  D2,D4
                asl.w   #3,D4
                adda.w  D4,A2
                suba.w  D4,A3
                bra.s   L05A3
L05A1:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
L05A2:          dbra    D5,L05A1
                suba.w  A2,A0
                adda.w  A3,A1
L05A3:          move.w  D2,D5
                dbra    D3,L05A2
                rts

L05A4:          add.w   D0,D2
                subq.w  #1,D2
                and.l   #$0000FFF0,D0
                and.w   #-$0010,D2
                sub.w   D0,D2
                lsr.w   #4,D2
                addq.w  #1,D2
                move.w  A2,D4
                mulu    D4,D1
                lsr.w   #1,D0
                add.l   D1,D0
                adda.l  D0,A0
                move.w  D2,D4
                asl.w   #3,D4
                suba.w  D4,A2
                adda.w  D4,A3
                adda.w  D4,A1
                subq.w  #8,A1
                moveq   #$0E,D4
                moveq   #0,D7
                bra.s   L05A7
L05A5:          move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),1(A1)
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),(A1)
                addq.w  #2,A1
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),1(A1)
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),(A1)
                addq.w  #2,A1
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),1(A1)
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),(A1)
                addq.w  #2,A1
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),1(A1)
                move.b  (A0)+,D7
                move.b  mirror_tab(PC,D7.w),(A1)
                suba.w  D4,A1
L05A6:          dbra    D5,L05A5
                adda.w  A2,A0
                adda.w  A3,A1
L05A7:          move.w  D2,D5
                dbra    D3,L05A6
                rts

mirror_tab:             DC.B $00,$80,'@',$C0,' ',$A0,'`',$E0
                        DC.B $10,$90,'P',$D0,'0',$B0,'p',$F0
                        DC.B $08,$88,'H',$C8,'(',$A8,'h',$E8
                        DC.B $18,$98,'X',$D8,'8',$B8,'x',$F8
                        DC.B $04,$84,'D',$C4,'$',$A4,'d',$E4
                        DC.B $14,$94,'T',$D4,'4',$B4,'t',$F4
                        DC.B $0C,$8C,'L',$CC,',',$AC,'l',$EC
                        DC.B $1C,$9C,'\',$DC,'<',$BC,'|',$FC
                        DC.B $02,$82,'B',$C2,'"',$A2,'b',$E2
                        DC.B $12,$92,'R',$D2,'2',$B2,'r',$F2
                        DC.B $0A,$8A,'J',$CA,'*',$AA,'j',$EA
                        DC.B $1A,$9A,'Z',$DA,':',$BA,'z',$FA
                        DC.B $06,$86,'F',$C6,'&',$A6,'f',$E6
                        DC.B $16,$96,'V',$D6,'6',$B6,'v',$F6
                        DC.B $0E,$8E,'N',$CE,'.',$AE,'n',$EE
                        DC.B $1E,$9E,'^',$DE,'>',$BE,'~',$FE
                        DC.B $01,$81,'A',$C1,'!',$A1,'a',$E1
                        DC.B $11,$91,'Q',$D1,'1',$B1,'q',$F1
                        DC.B $09,$89,'I',$C9,')',$A9,'i',$E9
                        DC.B $19,$99,'Y',$D9,'9',$B9,'y',$F9
                        DC.B $05,$85,'E',$C5,'%',$A5,'e',$E5
                        DC.B $15,$95,'U',$D5,'5',$B5,'u',$F5
                        DC.B $0D,$8D,'M',$CD,'-',$AD,'m',$ED
                        DC.B $1D,$9D,']',$DD,'=',$BD,'}',$FD
                        DC.B $03,$83,'C',$C3,'#',$A3,'c',$E3
                        DC.B $13,$93,'S',$D3,'3',$B3,'s',$F3
                        DC.B $0B,$8B,'K',$CB,'+',$AB,'k',$EB
                        DC.B $1B,$9B,'[',$DB,';',$BB,'{',$FB
                        DC.B $07,$87,'G',$C7,$27,$A7,'g',$E7
                        DC.B $17,$97,'W',$D7,'7',$B7,'w',$F7
                        DC.B $0F,$8F,'O',$CF,'/',$AF,'o',$EF
                        DC.B $1F,$9F,'_',$DF,'?',$BF,'',$FF
L05A9:          tst.w   D0
                beq     L05B8
                cmpa.w  #0,A2
                beq     L05B8
                subq.w  #1,D0
                subq.w  #1,A2
                moveq   #$0F,D4
L05AA:          cmp.b   0(A0,D4.w),D4
                bne.s   L05AB
                ori.b   #-$80,0(A0,D4.w)
L05AB:          dbra    D4,L05AA
                move.w  D3,D4
                mulu    breite_bytes,D4
                adda.l  D4,A1
                move.w  D2,D4
                lsr.w   #4,D4
                lsl.w   #3,D4
                adda.w  D4,A1
                move.w  D2,D1
                not.w   D1
                andi.w  #$000F,D1
                movea.w D1,A4
L05AC:          movea.l A1,A3
                move.w  D0,D7
                move.w  A4,D1
L05AD:          movem.w (A3)+,D2-D5
L05AE:          clr.w   D6
                btst    D1,D2
                beq.s   L05AF
                or.w    #1,D6
L05AF:          btst    D1,D3
                beq.s   L05B0
                or.w    #2,D6
L05B0:          btst    D1,D4
                beq.s   L05B1
                or.w    #4,D6
L05B1:          btst    D1,D5
                beq.s   L05B2
                or.w    #8,D6
L05B2:          move.b  0(A0,D6.w),D6
                bmi.s   L05B6
                bclr    D1,D2
                bclr    D1,D3
                bclr    D1,D4
                bclr    D1,D5
                btst    #0,D6
                beq.s   L05B3
                bset    D1,D2
L05B3:          btst    #1,D6
                beq.s   L05B4
                bset    D1,D3
L05B4:          btst    #2,D6
                beq.s   L05B5
                bset    D1,D4
L05B5:          btst    #3,D6
                beq.s   L05B6
                bset    D1,D5
L05B6:          subq.w  #1,D7
                bpl.s   L05B7
                movem.w D2-D5,-8(A3)
                subq.l  #1,A2
                cmpa.w  #-1,A2
                beq.s   L05B8
                adda.w  breite_bytes,A1
                bra.s   L05AC
L05B7:          dbra    D1,L05AE
                movem.w D2-D5,-8(A3)
                moveq   #$0F,D1
                bra.s   L05AD
L05B8:          rts
L05B9:          mulu    #$00A0,D5
                adda.l  D5,A0
                adda.l  D5,A1
                add.w   D4,D6
                subq.w  #1,D6
                lsr.w   #4,D4
                lsr.w   #4,D6
                sub.w   D4,D6
                lsl.w   #3,D4
                adda.w  D4,A0
                adda.w  D4,A1
                move.w  D6,D5
                addq.w  #1,D5
                lsl.w   #3,D5
                movea.w #$00A0,A2
                suba.w  D5,A2
                move.w  D6,D5
                subq.w  #1,D7
L05BA:          move.l  (A0)+,D0
                move.l  (A0)+,D1
                move.l  D1,D2
                or.l    D0,D2
                move.l  D2,D3
                swap    D3
                or.l    D3,D2
                not.l   D2
                and.l   D2,(A1)
                or.l    D0,(A1)+
                and.l   D2,(A1)
                or.l    D1,(A1)+
                dbra    D6,L05BA
                move.w  D5,D6
                adda.w  A2,A0
                adda.w  A2,A1
                dbra    D7,L05BA
                rts

;Zeichnet fÅr Box ein Rechteck
L05BB:          movem.l D0-D3,-(SP)
                moveq   #-1,D4
                move.w  D4,L0627
                move.w  D4,L0628
                clr.w   L0629
                move.w  zeichenfarbe(PC),D4
                tst.w   just_rahmen
                beq.s   L05BC
                move.w  left_col_mark(PC),D4
L05BC:          move.w  D4,L0623
                bra.s   L05C1

L05BD:          move.b  (A0),D0
                move.b  (A0),D0
                move.b  (A2),D1
                move.b  (A4),D2
                move.b  (A0),D3
L05BE:          lea     build_path,A6
                move.w  (A6),D4
                move.b  L05BD(PC,D4.w),D4
                ext.w   D4
                move.w  D4,L0629
                movem.l D0-D3,-(SP)
                clr.w   L0628
                move.w  D0,L0626
                move.w  D2,D4
                sub.w   L0629(PC),D4
                sub.w   D0,D4
                blt.s   L05BF
                move.w  D4,L0628
                add.w   D4,D0
L05BF:          clr.w   L0627
                move.w  D3,D4
                sub.w   L0629(PC),D4
                sub.w   D1,D4
                blt.s   L05C0
                add.w   D4,D1
                mulu    #$00A0,D4
                move.w  D4,L0627
L05C0:          bsr     L05EE
                lsr.w   L0629
L05C1:          movem.l (SP)+,D0-D3
                move.w  L0627(PC),D4
                beq.s   L05C2
                tst.w   just_rahmen
                beq.s   L05C2
                movem.l D0-D3,-(SP)
                add.w   L0629(PC),D1
                sub.w   L0629(PC),D3
                move.w  zeichenfarbe(PC),D4
                moveq   #1,D5           ;Opcode(?)
                bsr     fill_rectangle
                movem.l (SP)+,D0-D3
L05C2:          lea     build_path,A6
                move.w  (A6),D6
                beq.s   L05C8
                subq.w  #1,D6
                move.w  L0623(PC),D4
                moveq   #1,D5
                tst.w   L0627
                beq.s   L05C5
                movem.w D0-D3,-(SP)
                add.w   L0629(PC),D1
                sub.w   L0629(PC),D3
                move.w  D2,-(SP)
                move.w  D0,D2
                add.w   D6,D2
                cmp.w   (SP),D2
                blt.s   L05C3
                move.w  (SP),D2
L05C3:          bsr     fill_rectangle
                move.w  (SP)+,D2
                move.w  D2,D0
                sub.w   D6,D0
                cmp.w   (SP),D0
                bgt.s   L05C4
                move.w  (SP),D0
L05C4:          bsr     fill_rectangle
                movem.w (SP)+,D0-D3
L05C5:          tst.w   L0628
                beq.s   L05C8
                add.w   L0629(PC),D0
                sub.w   L0629(PC),D2
                move.w  D3,-(SP)
                move.w  D1,D3
                add.w   D6,D3
                cmp.w   (SP),D3
                blt.s   L05C6
                move.w  (SP),D3
L05C6:          bsr     fill_rectangle
                move.w  (SP)+,D3
                move.w  D1,-(SP)
                move.w  D3,D1
                sub.w   D6,D1
                cmp.w   (SP),D1
                bgt.s   L05C7
                move.w  (SP),D1
L05C7:          bsr     fill_rectangle
                addq.l  #2,SP
L05C8:          rts

L05C9:          move.w  D2,D7
                andi.w  #$000C,D7
                beq.s   L05CB
                clr.b   L076B
                move.w  #$01F4,D7
                move.w  D7,L0828
                move.w  D7,L0829
                move.w  D4,L082A
                move.w  D4,L082B
                move.w  zeichenfarbe(PC),D7
                move.w  D7,L0827
                tst.w   just_rahmen
                beq.s   L05CA
                move.w  left_col_mark(PC),D7
L05CA:          move.w  D7,zeichenfarbe
                lea     mask_buff,A0
                move.w  D3,(A0)+
                move.w  D4,(A0)+
                move.l  A0,L0824
                move.w  #1,L0826
                bra     L05D5
L05CB:          move.w  D2,D7
                andi.w  #$0030,D7
                beq     L05D4
                addq.w  #1,L0826
L05CC:          cmpi.w  #2,L0826
                bcs     L05D3
                movea.l L0824,A0
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.w  #3,D2
                jsr     do_brush
                move.w  D0,D3
                move.w  D1,D4
                lea     mask_buff,A1
                move.w  (A1)+,D0
                move.w  (A1)+,D1
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                jsr     do_brush
                move.w  L0827,zeichenfarbe
                tst.w   just_rahmen
                beq     L05D3
                movea.l komplettbild,A0
                movea.l scr2,A1
                movea.l A1,A2
                move.w  #$07CF,D7
                tst.w   board_da
                bne.s   L05CD
                move.w  #$03E7,D7
                move.w  grab_y,D6
                mulu    #$00A0,D6
                adda.w  D6,A0
L05CD:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,L05CD

                move.w  #-1,-(SP)       ;Auflîsung beibehalten
                move.l  #-1,-(SP)
                move.l  A2,-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                linea   #0 [ Init ]
                move.l  #mask_buff,12(A0)
                move.l  #L0825,4(A0)
                move.w  zeichenfarbe(PC),D7
                lea     24(A0),A1
                moveq   #3,D5
L05CE:          move.w  D7,D6
                andi.w  #1,D6
                move.w  D6,(A1)+
                lsr.w   #1,D7
                dbra    D5,L05CE
                clr.w   36(A0)
                move.l  #L0625,46(A0)
                clr.w   50(A0)
                move.w  L082B,D0
                move.w  L082A,D7
                sub.w   D0,D7
                movea.l A0,A4
                move.w  D0,40(A4)
L05CF:          linea   #6 [ Fillpoly ]
                addq.w  #1,40(A4)
                dbra    D7,L05CF
                tst.w   randstÑrke
                beq.s   L05D2
                move.l  scr1,-(SP)
                move.l  scr2,scr1
                move.w  left_col_mark(PC),zeichenfarbe
                move.w  L0826,D7
                move.l  #mask_buff,L0824
                bra.s   L05D1
L05D0:          move.w  D7,-(SP)
                movea.l L0824,A1
                move.w  (A1)+,D3
                move.w  (A1)+,D4
                move.l  A1,L0824
                move.w  (A1)+,D0
                move.w  (A1)+,D1
                moveq   #1,D2
                jsr     do_brush
                move.w  (SP)+,D7
L05D1:          dbra    D7,L05D0
                move.l  (SP)+,scr1
L05D2:          move.w  L0827,zeichenfarbe
                jsr     switch_screens
L05D3:          clr.w   L0826
                clr.b   L076B
                rts
L05D4:          move.w  D2,D7
                andi.w  #3,D7
                beq     L05DC
                tst.w   L0826
                beq     L05DC
L05D5:          addq.w  #1,L0826
                tst.w   just_rahmen
                beq     L05DB
                cmpi.w  #$0200,L0826
                bcc     L05CC
                movea.l L0824,A0
                move.w  -2(A0),D6
                move.w  -4(A0),D5
                sub.w   D0,D5
                bne.s   L05D6
                tst.w   L0828
                bne.s   L05D6
                sub.w   D1,D6
                move.w  L0829,D7
                move.w  D6,L0829
                eor.w   D6,D7
                bpl.s   L05D7
                bra.s   L05DA
L05D6:          sub.w   D1,D6
                bne.s   L05D8
                tst.w   L0829
                bne.s   L05D8
                move.w  L0828,D7
                move.w  D5,L0828
                eor.w   D5,D7
                bmi.s   L05DA
L05D7:          subq.w  #1,L0826
                move.w  D0,-4(A0)
                move.w  D1,-2(A0)
                bra.s   L05DB
L05D8:          movea.l D5,A1
                movea.l D6,A2
                tst.w   D5
                beq.s   L05D9
                ext.l   D6
                divs    D5,D6
                move.w  L0828,D5
                beq.s   L05D9
                move.w  L0829,D7
                ext.l   D7
                divs    D5,D7
                cmp.l   D7,D6
                beq.s   L05D7
L05D9:          move.w  A1,L0828
                move.w  A2,L0829
L05DA:          move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.l  A0,L0824
L05DB:          bsr.s   L05DD
                clr.b   any_shift
                jmp     do_brush
L05DC:          rts

L05DD:          cmp.w   L082A,D1
                bls.s   L05DE
                move.w  D1,L082A
L05DE:          cmp.w   L082B,D1
                bcc.s   L05DF
                move.w  D1,L082B
L05DF:          rts

L05E0:          btst    #3,D2
                bne.s   L05E1
                btst    #2,D2
                beq     L05E6
                tst.w   L0826
                bne     L05E7
                bra.s   L05E3
L05E1:          tst.w   L0826
                beq     L05EC
                addq.w  #1,L0826
L05E2:          clr.b   L062A
                jsr     L02D4
                clr.b   any_shift
                move.w  D0,D3
                move.w  D1,D4
                bsr.s   L05DD
                bra     L05CC
L05E3:          move.b  #1,L062A
                move.w  zeichenfarbe(PC),D7
                move.w  D7,L0827
                tst.w   just_rahmen
                beq.s   L05E4
                move.w  left_col_mark(PC),D7
L05E4:          move.w  D7,zeichenfarbe
                movea.l scr1,A0
                movea.l scr2,A1
                movea.l copybox_screen,A2
                move.w  #1999,D7
                tst.w   board_da
                bne.s   L05E5
                move.w  #999,D7
L05E5:          move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                move.l  (A0),(A1)+
                move.l  (A0)+,(A2)+
                dbra    D7,L05E5
                move.w  D1,L082B
                move.w  D1,L082A
                move.w  #1,L0826
                lea     mask_buff,A0
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.l  A0,L0824
                move.w  D0,D3
                move.w  D1,D4
                jsr     do_brush
                rts

L05E6:          tst.w   L0826
                beq     L05EC
L05E7:          movea.l L0824,A0
                move.w  -2(A0),D4
                move.w  -4(A0),D3
                btst    #4,D2
                beq.s   L05E8
                addq.w  #1,L0826
                cmpi.w  #$0200,L0826
                bcc     L05E2
L05E8:          movea.l copybox_screen,A0
                movea.l scr2,A1
                move.w  #$07CF,D7
                tst.w   board_da
                bne.s   L05E9
                move.w  #$03E7,D7
L05E9:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,L05E9
                move.l  scr1,-(SP)
                move.l  scr2,scr1
                move.w  D2,-(SP)
                moveq   #1,D2
                jsr     do_brush
                move.w  (SP)+,D2
                move.l  (SP)+,scr1
                btst    #4,D2
                beq.s   L05EB
                movea.l L0824,A0
                move.w  D0,(A0)+
                move.w  D1,(A0)+
                move.l  A0,L0824
                bsr     L05DD
                move.w  D0,L07F5
                move.w  D1,L07F6
                movea.l scr2,A0
                movea.l copybox_screen,A1
                move.w  #$07CF,D7
                tst.w   board_da
                bne.s   L05EA
                move.w  #$03E7,D7
L05EA:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D7,L05EA
                tst.b   any_shift
                beq.s   L05EB
                bset    #7,L07A1
L05EB:          jsr     switch_screens
L05EC:          rts
L05ED:          move.w  D0,L0626
                clr.w   L0627
L05EE:          move.w  zeichenfarbe(PC),L0623
                tst.w   just_rahmen
                beq.s   L05F1
                movem.l D0-A6,-(SP)
                move.w  #-1,L0624
                move.w  L0626(PC),D4
                move.w  D4,-(SP)
                lea     build_path,A6
                cmpi.w  #2,(A6)
                bcs.s   L05F0
                addq.w  #1,D0
                addq.w  #1,D4
                subq.w  #1,D2
                cmp.w   D0,D2
                bgt.s   L05EF
                addq.w  #1,D2
                subq.w  #1,D0
                subq.w  #1,D4
L05EF:          move.w  D4,L0626
                addq.w  #1,D1
                subq.w  #1,D3
                cmp.w   D1,D3
                bgt.s   L05F0
                addq.w  #1,D3
                subq.w  #1,D1
L05F0:          bsr.s   L05F7
                move.w  (SP)+,L0626
                movem.l (SP)+,D0-A6
                move.w  left_col_mark(PC),L0623
L05F1:          clr.w   L0624
                movem.l D0-A6,-(SP)
                lea     build_path,A6
                move.w  (A6),D4
                subq.w  #1,D4
                bls.s   L05F6
                move.w  D2,D5
                sub.w   D4,D2
                bcs.s   L05F2
                cmp.w   D0,D2
                bcc.s   L05F3
L05F2:          bra.s   L05F5
L05F3:          sub.w   D4,D3
                bcs.s   L05F4
                cmp.w   D1,D3
                bcc.s   L05F6
L05F4:          add.w   D4,D3
L05F5:          move.w  D5,D2
                move.w  #-1,L0624
L05F6:          bsr.s   L05F7
                movem.l (SP)+,D0-A6
                rts
L05F7:          move.w  D2,D4
                sub.w   D0,D4
                move.w  D3,D5
                sub.w   D1,D5
                cmp.w   D5,D4
                blt     L0602
                lsr.w   #1,D4
                move.w  D2,D5
                not.w   D5
                andi.w  #$000F,D5
                movea.w D5,A6
                sub.w   D1,D3
                addq.w  #1,D3
                suba.l  A5,A5
                lsr.w   #1,D3
                bcs.s   L05F8
                movea.w #-$00A0,A5
                addq.w  #1,D1
                subq.w  #1,D3
L05F8:          suba.w  L0627(PC),A5
                add.w   D3,D1
                movea.l scr2,A0
                mulu    #$00A0,D1
                adda.w  D1,A0
                movea.l A0,A1
                move.w  D2,D5
                lsr.w   #1,D5
                andi.w  #-8,D5
                adda.w  D5,A0
                move.w  L0626(PC),D0
                move.w  D0,D5
                not.w   D5
                andi.w  #$000F,D5
                movea.w D5,A4
                lsr.w   #1,D0
                andi.w  #-8,D0
                adda.w  D0,A1
                move.w  D3,D1
                move.w  D4,D0
                move.w  D0,D2
                mulu    D2,D2
                move.l  D2,D7
                lsr.l   #1,D7
                add.l   D2,D2
                move.l  D2,D3
                add.l   D3,D3
                mulu    D1,D1
                move.l  D1,D6
                lsr.l   #1,D6
                move.l  D1,D4
                add.l   D4,D4
                move.l  D4,D5
                add.l   D5,D5
                move.l  D4,D1
                mulu    D0,D1
                sub.l   D1,D6
                add.l   D2,D6
                add.l   D1,D1
                movea.l D1,A2
                moveq   #0,D1
                movea.l D1,A3
                sub.l   A2,D7
                add.l   D4,D7
                exg     A4,D4
                exg     A5,D5
                move.l  A6,D1
                lea     build_path,A6
L05F9:          tst.l   D7
                bpl.s   L05FD
                bsr     L060D
                lea     $00A0(A0),A0
                lea     $00A0(A1),A1
                subi.w  #$0140,D5
                adda.l  D3,A3
                tst.l   D6
                bpl.s   L05FA
                add.l   A3,D6
                add.l   D2,D6
                add.l   A3,D7
                bra.s   L05F9
L05FA:          subq.w  #1,D0
                addq.w  #1,D1
                andi.w  #$000F,D1
                bne.s   L05FB
                subq.l  #8,A0
L05FB:          subq.w  #1,D4
                bpl.s   L05FC
                moveq   #$0F,D4
                addq.l  #8,A1
L05FC:          suba.l  A5,A2
                sub.l   A2,D6
                add.l   A3,D6
                add.l   D2,D6
                sub.l   A2,D7
                add.l   A4,D7
                add.l   A3,D7
                bra.s   L05F9
L05FD:          bsr     L060D
                suba.l  A5,A2
                tst.l   D7
                bpl.s   L05FE
                lea     $00A0(A0),A0
                lea     $00A0(A1),A1
                subi.w  #$0140,D5
                adda.l  D3,A3
                sub.l   A2,D7
                add.l   A4,D7
                add.l   A3,D7
                bra.s   L05FF
L05FE:          sub.l   A2,D7
                add.l   A4,D7
L05FF:          addq.w  #1,D1
                andi.w  #$000F,D1
                bne.s   L0600
                subq.l  #8,A0
L0600:          subq.w  #1,D4
                bpl.s   L0601
                moveq   #$0F,D4
                addq.l  #8,A1
L0601:          dbra    D0,L05FD
                rts
L0602:          exg     D1,D0
                exg     D3,D2
                move.w  D2,D4
                sub.w   D0,D4
                move.w  D4,D5
                muls    #-$00A0,D5
                movea.l D5,A5
                suba.w  L0627(PC),A5
                lsr.w   #1,D4
                move.w  D1,D5
                move.w  D1,D6
                sub.w   D1,D3
                addq.w  #1,D3
                lsr.w   #1,D3
                bcs.s   L0603
                addq.w  #1,D5
                subq.w  #1,D3
L0603:          add.w   D3,D5
                add.w   D3,D6
                move.w  D1,D7
                sub.w   L0626(PC),D7
                sub.w   D7,D6
                movea.l scr2,A0
                mulu    #$00A0,D2
                adda.w  D2,A0
                movea.l A0,A1
                move.w  D5,D7
                lsr.w   #1,D7
                andi.w  #-8,D7
                adda.w  D7,A0
                not.w   D5
                andi.w  #$000F,D5
                movea.w D5,A6
                move.w  D6,D7
                lsr.w   #1,D7
                andi.w  #-8,D7
                adda.w  D7,A1
                not.w   D6
                andi.w  #$000F,D6
                movea.w D6,A4
                move.w  D3,D1
                move.w  D4,D0
                move.w  D0,D2
                mulu    D2,D2
                move.l  D2,D7
                lsr.l   #1,D7
                add.l   D2,D2
                move.l  D2,D3
                add.l   D3,D3
                mulu    D1,D1
                move.l  D1,D6
                lsr.l   #1,D6
                move.l  D1,D4
                add.l   D4,D4
                move.l  D4,D5
                add.l   D5,D5
                move.l  D4,D1
                mulu    D0,D1
                sub.l   D1,D6
                add.l   D2,D6
                add.l   D1,D1
                movea.l D1,A2
                moveq   #0,D1
                movea.l D1,A3
                sub.l   A2,D7
                add.l   D4,D7
                exg     A4,D4
                exg     A5,D5
                move.l  A6,D1
                lea     build_path,A6
L0604:          tst.l   D7
                bpl.s   L0608
                bsr.s   L060D
                addq.w  #1,D4
                andi.w  #$000F,D4
                bne.s   L0605
                subq.l  #8,A1
L0605:          subq.w  #1,D1
                bpl.s   L0606
                moveq   #$0F,D1
                addq.l  #8,A0
L0606:          adda.l  D3,A3
                tst.l   D6
                bpl.s   L0607
                add.l   A3,D6
                add.l   D2,D6
                add.l   A3,D7
                bra.s   L0604
L0607:          subq.w  #1,D0
                suba.w  #$00A0,A0
                suba.w  #$00A0,A1
                addi.w  #$0140,D5
                suba.l  A5,A2
                sub.l   A2,D6
                add.l   A3,D6
                add.l   D2,D6
                sub.l   A2,D7
                add.l   A4,D7
                add.l   A3,D7
                bra.s   L0604
L0608:          bsr.s   L060D
                suba.l  A5,A2
                tst.l   D7
                bpl.s   L060B
                addq.w  #1,D4
                andi.w  #$000F,D4
                bne.s   L0609
                subq.l  #8,A1
L0609:          subq.w  #1,D1
                bpl.s   L060A
                moveq   #$0F,D1
                addq.l  #8,A0
L060A:          adda.l  D3,A3
                sub.l   A2,D7
                add.l   A4,D7
                add.l   A3,D7
                bra.s   L060C
L060B:          sub.l   A2,D7
                add.l   A4,D7
L060C:          suba.w  #$00A0,A0
                suba.w  #$00A0,A1
                addi.w  #$0140,D5
                dbra    D0,L0608
                rts
L060D:          movem.l D0-D4/D6-A1/A5-A6,-(SP)
                tst.w   L0624
                beq     L0617
                add.w   D1,D1
                move.w  L060E(PC,D1.w),D1
                not.w   D1
                add.w   D4,D4
                move.w  L060F(PC,D4.w),D4
                bra.s   L0610
L060E:                  DS.W 1
L060F:                  DC.B $00,$01,$00,$03,$00,$07,$00,$0F
                        DC.B $00,$1F,$00,'?',$00,'',$00,$FF
                        DC.B $01,$FF,$03,$FF,$07,$FF,$0F,$FF
                        DC.B $1F,$FF,'?',$FF,'',$FF,$FF,$FF
L0610:          cmpa.l  A0,A1
                bne.s   L0611
                and.w   D1,D4
                move.w  D4,D1
L0611:          move.w  D1,D0
                not.w   D0
                move.w  D4,D2
                not.w   D2
                move.w  L0623(PC),D3
                moveq   #3,D6
L0612:          lsr.w   #1,D3
                bcc.s   L0613
                or.w    D1,0(A0,D5.w)
                or.w    D4,0(A1,D5.w)
                or.w    D1,(A0)+
                or.w    D4,(A1)+
                dbra    D6,L0612
                bra.s   L0614
L0613:          and.w   D0,0(A0,D5.w)
                and.w   D2,0(A1,D5.w)
                and.w   D0,(A0)+
                and.w   D2,(A1)+
                dbra    D6,L0612
L0614:          subq.l  #8,A0
                move.w  L0623(PC),D3
                ror.w   #1,D3
                smi     D0
                ext.w   D0
                swap    D0
                ror.w   #1,D3
                smi     D0
                ext.w   D0
                ror.w   #1,D3
                smi     D1
                ext.w   D1
                swap    D1
                ror.w   #1,D3
                smi     D1
                ext.w   D1
                bra.s   L0616
L0615:          move.l  D0,0(A1,D5.w)
                move.l  D0,(A1)+
                move.l  D1,0(A1,D5.w)
                move.l  D1,(A1)+
L0616:          cmpa.l  A1,A0
                bhi.s   L0615
                bra     L0620
L0617:          move.w  (A6)+,D7
                movea.l A6,A5
                lsl.w   #5,D1
                lsl.w   #5,D4
                adda.w  D1,A5
                adda.w  D4,A6
                bra.s   L061F
L0618:          move.w  L0623(PC),D4
                moveq   #3,D6
                move.l  (A5)+,D0
                move.l  (A6)+,D1
                swap    D0
                swap    D1
                move.l  D0,D2
                move.l  D1,D3
                not.l   D2
                not.l   D3
L0619:          lsr.w   #1,D4
                bcc.s   L061A
                or.w    D0,0(A0,D5.w)
                or.w    D1,0(A1,D5.w)
                or.w    D0,(A0)+
                or.w    D1,(A1)+
                dbra    D6,L0619
                bra.s   L061B
L061A:          and.w   D2,0(A0,D5.w)
                and.w   D3,0(A1,D5.w)
                and.w   D2,(A0)+
                and.w   D3,(A1)+
                dbra    D6,L0619
L061B:          swap    D0
                swap    D1
                swap    D2
                swap    D3
                move.w  L0623(PC),D4
                moveq   #3,D6
L061C:          lsr.w   #1,D4
                bcc.s   L061D
                or.w    D0,0(A0,D5.w)
                or.w    D1,0(A1,D5.w)
                or.w    D0,(A0)+
                or.w    D1,(A1)+
                dbra    D6,L061C
                bra.s   L061E
L061D:          and.w   D2,0(A0,D5.w)
                and.w   D3,0(A1,D5.w)
                and.w   D2,(A0)+
                and.w   D3,(A1)+
                dbra    D6,L061C
L061E:          lea     $0090(A0),A0
                lea     $0090(A1),A1
L061F:          dbra    D7,L0618
L0620:          movem.l (SP)+,D0-D4/D6-A1/A5-A6
                rts

;Zeichnet ein gefÅlltes Rechteck
;Parameter:
;D0: x1
;D1: y1
;D2: x2
;D3: y2
;D4: Farbe
;D5: Nummer der OP-Codes
;A0: Basis des Bildschirms
fill_rectangle: movem.l D0-A6,-(SP)
                lea     bitblit,A6
                movea.l A6,A5
                movea.l scr2,A0
                sub.w   D0,D2           ;Breite berechnen
                addq.w  #1,D2           ;+1
                move.w  D2,(A5)+        ;und eintragen
                sub.w   D1,D3
                addq.w  #1,D3           ;Hîhe berechnen
                move.w  D3,(A5)+
                move.w  #4,(A5)+        ;4 Planes
                move.w  D4,(A5)+        ;Vordergrundfarbe
                clr.w   (A5)+           ;Hintergrundfarbe
                asl.w   #2,D5
                move.l  L0622(PC,D5.w),(A5)+ ;Op-Code
                clr.l   (A5)+           ;X/Y Source
                move.l  A0,(A5)+        ;Quelle_base
                clr.l   (A5)+           ;Offsets_quelle
                clr.w   (A5)+           ;Offsets_quelle
                move.w  D0,(A5)+        ;Ziel_x
                move.w  D1,(A5)+        ;Ziel_y
                move.l  A0,(A5)+        ;Ziel_base
                move.w  #8,(A5)+        ;Offset
                move.w  #160,(A5)+      ;Breite in Bytes
                move.w  #2,(A5)+        ;Offset
                clr.l   (A5)            ;keine Maske
                linea   #7 [ Bitblk ]
L0622A:         movem.l (SP)+,D0-A6
                rts

L0622                   EQU L0622A+2

;Tabelle der Op-Codes:
                        DC.B $00,$00,$0F,$0F ;Z=1
                        DC.B $00,$00,$0F,$0F ;Z=1
                        DC.B $0A,$0A,$0A,$0A ;Not Z
                        DC.B $00,$00,$0F,$0F ;Z=1

L0623:                  DS.W 1
L0624:                  DS.W 1
L0625:                  DC.B $FF,$FF
L0626:                  DS.W 1
L0627:                  DS.W 1
L0628:                  DS.W 1
L0629:                  DS.W 1
L062A:                  DS.W 1

;öberprÅft, ob der Spieler in eines der Options-Rechtecke geklickt hat
;ÅberprÅft gleichzeitig mit Repeat
;Parameter:
;A0: Tabelle der Rechtecke (mit -1 beendet)
;D0: Maus_x
;D1: Maus_y
;Ausgabe des Buttons in D7 bzw. -1 bei nicht gefunden
;bzw. der Rahmenkoordinate in d3-d6
check_button:   movem.l D0-D2/A0-A6,-(SP)

                move.l  A0,-(SP)        ;Pointer auf die Rechtecke sichern
                bsr.s   such_button     ;den entsprechenden Button suchen
                tst.w   D7              ;gefunden?
                bmi.s   not_found_btn   ;nein->Raus

                tst.w   repeat_control  ;Repeat in Arbeit
                beq.s   repeat_wart     ;Ja, auf 2. Taste warten
                bpl.s   repeat_schnell  ;Schnell repeaten

                clr.w   repeat_control  ;Nachher auf 2. Taste warten
                bra.s   not_found_end   ;und raus hier

repeat_wart:    jsr     Sm
                moveq   #-1,D7
delay3:         jsr     get_maus
                move.w  D2,D6
                and.w   #%0000000000000011,D6 ;Links oder rechts gedrÅckt?
                beq.s   not_found_btn   ;Nein, also raus
                dbra    D7,delay3

                move.w  #1,repeat_control ;Nacher schneller Repeat
                bra.s   zurÅckgeben     ;Und Wert zurÅckgeben

repeat_schnell: move.w  #6000,D7
delay4:         jsr     get_maus
                move.w  D2,D6
                and.w   #%0000000000000011,D6 ;Links oder rechts gedrÅckt?
                beq.s   not_found_btn
                dbra    D7,delay4

zurÅckgeben:    movea.l (SP),A0         ;Pointer auf die Rechtecke
                bsr.s   such_button
                tst.w   D7              ;Gefunden?
                bmi.s   not_found_btn   ;Nein,->Raus

not_found_end:  jsr     Hm
                tst.l   (SP)+           ;Pointer  wieder runter
                movem.l (SP)+,D0-D2/A0-A6
                rts

not_found_btn:  moveq   #-1,D7          ;und nichts gefunden
                move.w  #-1,repeat_control ;Kein Repeat in Arbeit
                bra.s   not_found_end

;öberprÅft, ob der Spieler in eines der Options-Rechtecke geklickt hat
;Parameter:
;A0: Tabelle der Rechtecke (mit -1 beendet)
;D0: Maus_x
;D1: Maus_y
;Ausgabe des Buttons in D7 bzw. -1 bei nicht gefunden
;bzw. der Rahmenkoordinate in d3-d6
such_button:    movem.l D0-D2/A0-A6,-(SP)

                moveq   #-1,D7          ;ZÑhler

nxt_rechteck:   addq.w  #1,D7           ;erhîhen
                move.w  (A0)+,D3
                bmi.s   not_found1
                move.w  (A0)+,D4        ;Rechteck holen
                move.w  (A0)+,D5
                move.w  (A0)+,D6
                bsr     maus_in
                bne.s   nxt_rechteck

end_check:      movem.l (SP)+,D0-D2/A0-A6
                rts

not_found1:     moveq   #-1,D7          ;Kein Rechteck gefunden
                bra.s   end_check

;Dies ist die Camera-Routine....
do_animate:     btst    #0,D2           ;Links gedrÅckt?
                beq.s   no_89
                movem.l D0-A6,-(SP)
                move.w  D0,ani_centerx
                tst.w   board_da
                bne.s   setzen
                add.w   grab_y(PC),D1
setzen:         move.w  D1,ani_centery
                lea     sequenzen,A6
                move.w  seq_akt(PC),D0  ;Aktuelle Sequenz
                lsl.w   #3,D0           ;mal 8
                adda.w  D0,A6           ;Start der aktuellen Sequenz
                bsr     pos_mitte       ;Zentriert zeichnen
                bsr     neue_pos        ;und anzeigen
                movem.l (SP)+,D0-A6
no_89:          rts

one_rechts:     cmpi.b  #11,function    ;Animate?
                beq.s   rechts_animate
                cmpi.b  #8,function     ;Raster?
                bne.s   no_89
                jsr     raster_rechts
                jmp     neue_palette
rechts_animate: move.w  seq_akt(PC),D0
                lsl.w   #3,D0
                lea     sequenzen,A6    ;Pointer auf aktuelle Sequenz Åbergeben
                adda.w  D0,A6
                bsr     one_right
                bsr     zeichne_rÑnder
                jmp     draw_objekt

one_links:      cmpi.b  #11,function    ;Animate?
                beq.s   links_animate
                cmpi.b  #8,function     ;Raster?
                bne.s   no_89
                jsr     raster_links
                jmp     neue_palette
links_animate:  move.w  seq_akt(PC),D0
                lsl.w   #3,D0
                lea     sequenzen,A6    ;Pointer auf aktuelle Sequenz Åbergeben
                adda.w  D0,A6
                bsr     one_left
                bsr     zeichne_rÑnder
                jmp     draw_objekt

;Bedient das Animate-Optionsboard
cam_opt:        movem.l D0-A6,-(SP)

cam_opt_again:  move.w  D2,D7
                and.w   #%0000000000000011,D7 ;Links oder rechts neu gedrÅckt?
                beq     end_cam_opt     ;nein, weiter

                move.w  #270,D3
                move.w  #150,D4
                move.w  #313,D5         ;Load?
                move.w  #158,D6
                bsr     maus_in
                bne.s   no_load2

                lea     cut_path,A0
                moveq   #6,D1           ;*.ANI
                bsr     change_path     ;Als Extension anhÑngen
                lea     cut_file,A1
                bsr     change_file     ;Und an Filenamen anhÑngen
                lea     ani_lext(PC),A2
                moveq   #0,D0           ;Laden
                bsr     fileselect
                bne.s   no_35           ;und ganz raus hier

                bsr     load_ani        ;Animationsfile laden
no_35:          jsr     screen2neo

                moveq   #4,D5           ;5 Felder
                lea     pos_fill(PC),A0
loop49:         move.l  (A0)+,(A0)+     ;Fillfeld wegmachen
                dbra    D5,loop49

                suba.l  A5,A5           ;Vorher war Seq #0 aktiv (irgendwas)
                bsr     neue_sequenz    ;Neue Werte eintragen
                bsr     draw_options    ;und Options neu zeichnen
                bra     end_cam_opt

no_load2:       move.w  #158,D4
                move.w  #166,D6         ;Save?
                bsr     maus_in
                bne.s   no_load_save

                lea     cut_path,A0
                moveq   #6,D1           ;*.ANI
                bsr     change_path     ;Als Extension anhÑngen
                lea     cut_file,A1
                bsr     change_file     ;Und an Filenamen anhÑngen
                lea     ani_sext(PC),A2
                moveq   #1,D0           ;Speichern
                bsr     fileselect
                bne.s   no34            ;und ganz raus hier

                bsr     save_ani        ;und abspeichern
no34:           jsr     screen2neo
                bra.s   end_cam_opt

no_load_save:   lea     camera_buttons(PC),A0
                bsr     check_button    ;In welches Rechteck wurde geklickt?
                tst.w   D7              ;Rechteck gefunden?
                bmi.s   end_cam_opt     ;Nein, weiter

                bsr     inv_button      ;Knopf invertieren

                lea     sequenzen,A6
                move.w  seq_akt(PC),D0  ;Aktuelle Sequenz
                lsl.w   #3,D0           ;mal 8
                adda.w  D0,A6           ;Start der aktuellen Sequenz

                lsl.w   #2,D7           ;mal 4
                lea     camera_tabelle(PC),A0
                movea.l 0(A0,D7.w),A0   ;Sprungvektor der Funktion
                moveq   #0,D7           ;nachher nichts neu zeichnen
                movem.w D3-D6,-(SP)     ;Koordinaten des Buttons retten
                jsr     (A0)
                movem.w (SP)+,D3-D6     ;Koordinaten wieder holen
                bsr     inv_button      ;und zurÅckinvertieren

                lsl.w   #2,D7           ;mal 4
                lea     aft_cam_opt(PC),A0
                movea.l 0(A0,D7.w),A0   ;Sprungvektor in After-Funktion
                jsr     (A0)            ;und ausfÅhren

end_cam_opt:    jsr     get_mouse_pos   ;Maustasten holen
                move.w  int_out,D2
                and.w   #%0000000000000011,D2 ;Mausknopf gedrÅckt?
                beq.s   endlich_raus    ;nochmal alles auswerten
                jsr     get_maus        ;Mausknîpfe holen
                bra     cam_opt_again   ;und nochmal
endlich_raus:   movem.l (SP)+,D0-A6
                rts

;Sprungtabelle der verschiedenen Camera-Buttons:
camera_tabelle:         DC.L links_up
                        DC.L links_down
                        DC.L rechts_up
                        DC.L rechts_down
                        DC.L animate_links
                        DC.L animate_rechts
                        DC.L seq_links
                        DC.L seq_rechts
                        DC.L pos_lo
                        DC.L pos_ro
                        DC.L pos_lu
                        DC.L pos_ru
                        DC.L pos_mitte
                        DC.L ping_pong

;Sprungtabelle der versch. After-Aktionen nach Button-Auswertung
aft_cam_opt:            DC.L nothing
                        DC.L zeichne_rÑnder ;Animations-RÑnder neu zeichnen
                        DC.L neue_sequenz ;Neue Sequenz wurde gewÑhlt
                        DC.L draw_objekt
                        DC.L neue_pos ;Neue Position auf Screen

;Erwartet in A5.w den alten Speed/Bitvektor
neue_pos:       move.w  A5,D6           ;Bitvektor holen
                and.w   #%0111000000000000,D6 ;Position maskieren
                rol.w   #7,D6           ;nach unten schieben, mal 8
                lea     pos_rahmen(PC),A0
                lea     pos_fill(PC),A1
                adda.w  D6,A0
                adda.w  D6,A1
                move.w  (A0)+,D3
                move.w  (A0)+,D4        ;Koordinaten des alten Buttons holen
                move.w  (A0)+,D5
                move.w  (A0)+,D6
                tst.w   board_da
                bne.s   no53
                tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   no53
                bsr     inv_button      ;Alten Button wegmachen
no53:           move.w  D3,(A1)+
                move.w  D4,(A1)+
                move.w  D3,(A1)+        ;Und altes Fill wegmachen
                move.w  D4,(A1)+

                move.w  seq_akt(PC),D0
                lea     sequenzen,A0
                lsl.w   #3,D0           ;mal 8
                adda.w  D0,A0
                move.w  6(A0),D0        ;Neuen Bitvektor holen
                movea.w D0,A5           ;und in A5.w merken
                and.w   #%0111000000000000,D0 ;Maskieren
                rol.w   #7,D0           ;in richtige Position, mal 8
                lea     pos_rahmen(PC),A0
                lea     pos_fill(PC),A1
                adda.w  D0,A0
                adda.w  D0,A1
                move.w  (A0)+,D3
                move.w  (A0)+,D4
                move.w  (A0)+,D5        ;Koordinaten des neuen Buttons holen
                move.w  (A0)+,D6
                tst.w   board_da
                bne.s   no42
                tst.b   lupe_an         ;Groûe Lupe an?
                beq.s   no42
                bsr     inv_button      ;zurÅckinvertieren des akt. Button->Stimmts nachher
no42:           move.w  D3,(A1)+
                move.w  D4,(A1)+
                move.w  D5,(A1)+        ;und in Fill-Tabelle speichern
                move.w  D6,(A1)+
                jsr     draw_objekt     ;und Objekt neu zeichnen

                tst.w   board_da
                bne     nicht_zeichnen  ;->RTS
                tst.b   lupe_an
                beq     nicht_zeichnen
                jsr     Hm
                lea     ping_str(PC),A0
                move.b  #' ',(A0)       ;Default: ' '
                move.w  A5,D0           ;Neuer Bitvektor
                btst    #15,D0          ;Ping-Pong?
                beq.s   no_ping
                move.b  #'',(A0)
no_ping:        lea     ping_strk(PC),A3
                move.w  (A3)+,D2
                move.w  (A3)+,D0
                move.w  (A3)+,D1
                jmp     print6x6

;Erwartet in A5.w die alte Sequenz Nummer
neue_sequenz:   move.w  A5,D7           ;Alte Seq_akt
                lsl.w   #3,D7           ;mal 8
                lea     sequenzen,A6
                adda.w  D7,A6
                movea.w 6(A6),A5        ;in A5 alten Bitvektor Åbergeben
                bsr     neue_pos        ;Neue Sequenz->Neue position

                move.w  seq_akt(PC),D7
                move.w  D7,D1
                lsl.w   #3,D7           ;Mal 8
                lea     sequenzen,A6
                adda.w  D7,A6
                lea     akt_sequenz(PC),A0
                jsr     wandel_fest_dez2

                lea     akt_sequenz_strk(PC),A3
                lea     akt_sequenz(PC),A0
                move.w  (A3)+,D2        ;Status holen
                move.w  (A3)+,D0        ;Koordinaten holen
                move.w  (A3)+,D1
                jsr     Hm              ;Maus weg
                jsr     print6x6        ;und neue Sequenz printen

zeichne_rÑnder: movem.l D0-A6,-(SP)

                move.w  seq_akt(PC),D0
                lsl.w   #3,D0           ;mal 8
                lea     sequenzen,A6
                adda.w  D0,A6

                move.w  2(A6),D1        ;Rechter Rand
                lea     rechter_rand(PC),A0
                jsr     wandel_fest_dez3
                move.w  (A6),D1         ;Linker rand
                lea     linker_rand(PC),A0
                jsr     wandel_fest_dez3
                move.w  4(A6),D1        ;Akt_objekt
                lea     akt_objekt(PC),A0
                jsr     wandel_fest_dez3
                tst.w   board_da        ;Board da?
                bne.s   no_65
                tst.b   lupe_an
                beq.s   no_65
                bsr.s   draw_cam_str    ;Zeichnet die Strings neu auf Screen
no_65:          movem.l (SP)+,D0-A6
nicht_zeichnen: rts

;Zeichnet die Strings der Animate-Options neu (CHS)
draw_cam_str:   movem.l D0-A6,-(SP)     ;Register retten

                lea     rechter_strk(PC),A3
                lea     rechter_rand(PC),A0
                moveq   #5,D7           ;6 Strings neu zeichnen
                bra     redr2           ;Holt auch Register wieder

;Funktionen zum Auswerten eines Klicks im Optionboard (CHS):
links_up:       move.w  (A6),D0         ;Linker Ani-Rand
                cmp.w   2(A6),D0        ;grîûer als rechter Rand?
                bge.s   no_links_up
                addq.w  #1,(A6)         ;Links eins hoch
                moveq   #1,D7           ;Linker+Rechter Rand neu zeichnen
nothing:
no_links_up:    rts

links_down:     cmpi.w  #1,(A6)         ;noch positiv?
                ble.s   no_links_down   ;Nein, raus
                subq.w  #1,(A6)         ;links eins runter
                moveq   #1,D7           ;Linker+rechter Rand neu zeichnen
no_links_down:  rts

rechts_up:      cmpi.w  #999,2(A6)      ;Max. Zahl erreicht?
                bge.s   no_rechts_up
                addq.w  #1,2(A6)        ;Rechts eins hoch
                moveq   #1,D7
no_rechts_up:   rts

rechts_down:    move.w  2(A6),D0        ;Rechter Ani-Rand
                cmp.w   (A6),D0
                ble.s   no_rechts_down
                subq.w  #1,2(A6)        ;Rechts eins runter
                moveq   #1,D7
no_rechts_down: rts

animate_links:  move.w  ani_obj_direct(PC),D0
                btst    #0,D0           ;Nach links animieren?
                bne.s   left_animate    ;Ja, also schneller oder langsam

                btst    #1,D0           ;Nach rechts animieren?
                bne.s   right_animate

                btst    #0,D2           ;Links neu gedrÅckt?
                bne.s   one_left        ;ja, ein Objekt nach links

                btst    #1,D2           ;Rechts neu gedrÅckt?
                beq.s   ani_end         ;Nein->Raus

                move.w  #1,ani_obj_direct ;Nach links animieren
ani_end:        rts

;Animiert ein Objekt nach links
one_left:       moveq   #3,D7           ;Nachher neues Objekt zeigen
                subq.w  #1,4(A6)        ;Ein Objekt nach links
                move.w  4(A6),D0        ;Aktuelles Objekt
                cmp.w   (A6),D0         ;linken Rand erreicht?
                bge.s   ok34
                btst    #7,6(A6)        ;Ping Pong?
                beq.s   no_ping2
                move.w  ani_obj_direct(PC),D0
                btst    #0,D0           ;Wird gerade nach links animiert?
                beq.s   no_ping2        ;Nein, also weiter
                move.w  #2,ani_obj_direct ;Jetzt geht's nach rechts weiter
                addq.w  #2,4(A6)        ;eins nach rechts
                move.w  4(A6),D0
                cmp.w   2(A6),D0        ;Rechten Rand erreicht?
                ble.s   ok34
no_ping2:       move.w  2(A6),4(A6)     ;Sonst rechten Rand nehmen
ok34:           rts

;Es wird nach rechts animiert, Spieler klickt in linken Pfeil->Stop!
right_animate:  clr.w   ani_obj_direct  ;Automatische Animation stoppen
                rts

;Es wird bereits nach links animiert, also schneller oder langsamer machen:
left_animate:   btst    #0,D2           ;Linker Knopf gedrÅckt?
                beq.s   no_left2        ;Nein, weiter
                bsr     speed_up
no_left2:       btst    #1,D2           ;Rechter Knopf gedrÅckt?
                beq.s   no_right2
                bsr     speed_down
no_right2:      rts

animate_rechts: move.w  ani_obj_direct(PC),D0
                btst    #1,D0           ;Nach rechts animieren?
                bne.s   right_animate2  ;Ja, also schneller oder langsam

                btst    #0,D0           ;Nach links animieren?
                bne.s   left_animate2

                btst    #0,D2           ;Links neu gedrÅckt?
                bne.s   one_right       ;ja, ein Objekt nach rechts

                btst    #1,D2           ;Rechts neu gedrÅckt?
                beq.s   ani_end2        ;Nein->Raus

                move.w  #2,ani_obj_direct ;Nach rechts animieren
ani_end2:       rts

;Animiert ein Objekt nach rechts
one_right:      moveq   #3,D7           ;Nachher Objekt neu zeichnen
                addq.w  #1,4(A6)        ;Ein Objekt weiter
                move.w  4(A6),D0
                cmp.w   2(A6),D0        ;Rechten Rand erreicht?
                ble.s   no_rechts67
                btst    #7,6(A6)        ;Ping Pong?
                beq.s   no_ping3        ;Nein, weiter
                move.w  ani_obj_direct(PC),D0
                btst    #1,D0           ;Wird gerade nach rechts animiert?
                beq.s   no_ping3        ;Nein, also weiter
                move.w  #1,ani_obj_direct ;Jetzt geht's nach links weiter
                subq.w  #2,4(A6)        ;Eins nach links gehen
                move.w  4(A6),D0        ;Aktuelles Objekt
                cmp.w   (A6),D0         ;linken Rand erreicht?
                bge.s   no_rechts67     ;Nein, also weiter
no_ping3:       move.w  (A6),4(A6)      ;links wieder anfangen
no_rechts67:    rts

;Es wird nach links animiert, Spieler klickt in rechten Pfeil->Stop!
left_animate2:  clr.w   ani_obj_direct  ;Automatische Animation stoppen
                rts

;Es wird bereits nach rechts animiert, also schneller oder langsamer machen:
right_animate2: btst    #1,D2           ;Rechter Knopf gedrÅckt?
                beq.s   no_left3        ;Nein, weiter
                bsr.s   speed_up
no_left3:       btst    #0,D2           ;Linker Knopf gedrÅckt?
                beq.s   no_right3
                bsr     speed_down
no_right3:      rts

seq_links:      tst.w   seq_akt
                ble.s   no_seq_links
                movea.w seq_akt(PC),A5  ;Alte Sequenz in A5.w merken
                subq.w  #1,seq_akt
                moveq   #2,D7           ;Neue Sequenz
no_seq_links:   rts

seq_rechts:     cmpi.w  #seq_max-1,seq_akt
                bge.s   no_seq_rechts
                movea.w seq_akt(PC),A5  ;Alte Sequenz in A5.w merken
                addq.w  #1,seq_akt
                moveq   #2,D7
no_seq_rechts:  rts

pos_lo:         move.w  #%0000000000000000,D1 ;Links oben=0
                bra.s   set_position

pos_ro:         move.w  #%0001000000000000,D1 ;Rechts oben=1
                bra.s   set_position

pos_lu:         move.w  #%0010000000000000,D1 ;Links unten=2
                bra.s   set_position

pos_ru:         move.w  #%0011000000000000,D1 ;Rechts unten=3
                bra.s   set_position

pos_mitte:      move.w  #%0100000000000000,D1 ;mitte=4

;Setzt D1 als Positonsbits im Speed/Bitvektor (CHS):
set_position:   move.w  6(A6),D0        ;Speed+Vektorbits
                movea.w D0,A5           ;Alten Vektor sichern
                and.w   #%1000111111111111,D0
                or.w    D1,D0           ;Position einodern
                move.w  D0,6(A6)        ;und zurÅck
                moveq   #4,D7           ;Positionsbalken neu zeichnen
                rts

;Beschleunigt die Animation, falls mîglich (CHS)
speed_up:       cmpi.b  #11,function    ;Animate?
                bne     no_animate1

                movem.l D0-A6,-(SP)

                move.w  seq_akt(PC),D0
                lsl.w   #3,D0           ;mal 8
                lea     sequenzen,A6
                adda.w  D0,A6

                move.w  6(A6),D0        ;Speed holen
                move.w  D0,D1
                and.w   #%0000111111111111,D0 ;maskieren
                and.w   #%1111000000000000,D1 ;Status-Bits isolieren

                tst.w   D0
                beq.s   no_faster       ;schon max. -> weiter
                subq.w  #1,D0           ;eins schneller
                or.w    D1,D0           ;Flags einodern
                move.w  D0,6(A6)        ;und wieder speichern
no_faster:      movem.l (SP)+,D0-A6
                rts

no_animate1:    cmpi.b  #8,function     ;Raster?
                bne.s   no_raster1

                jsr     raster_hoch

no_raster1:     rts

;Verlangsamt die Animation, falls mîglich
speed_down:     cmpi.b  #11,function    ;Animate?
                bne.s   no_animate2

                movem.l D0-A6,-(SP)

                move.w  seq_akt(PC),D0
                lsl.w   #3,D0           ;mal 8
                lea     sequenzen,A6
                adda.w  D0,A6

                move.w  6(A6),D0        ;Speed holen
                move.w  D0,D1
                and.w   #%0000111111111111,D0 ;maskieren
                and.w   #%1111000000000000,D1 ;Status-Bits isolieren

                cmp.w   #%0000111111111111,D0
                bge.s   no_slower
                addq.w  #1,D0
                or.w    D1,D0
                move.w  D0,6(A6)
no_slower:      movem.l (SP)+,D0-A6
                rts

no_animate2:    cmpi.b  #8,function     ;Raster?
                bne.s   no_raster2

                jsr     raster_runter
                jsr     palette_changed

no_raster2:     rts

ping_pong:      move.w  6(A6),D0        ;Alten Bitvektor holen
                movea.w D0,A5           ;und merken
                bchg    #15,D0          ;und ping pong verÑndern
                move.w  D0,6(A6)        ;und speichern
                moveq   #4,D7           ;und neu anzeigen
                rts

load_ani:       clr.w   -(SP)
                pea     fsel_path
                move.w  #$003D,-(SP)
                trap    #1              ;*.ANI îffnen
                addq.l  #8,SP
                move.w  D0,fhandle      ;Datei vorhanden?
                bmi.s   load_ani_end    ;Nein, weiter

                lea     sequenzen,A6
                move.l  #seq_max*8,D6
                bsr     read            ;und lesen
                bsr     fclose
load_ani_end:   rts

save_ani:       clr.w   -(SP)
                pea     fsel_path
                move.w  #$003C,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,fhandle
                bmi.s   save_ani_end

                lea     sequenzen,A6
                move.l  #seq_max*8,D6
                bsr     write
                bne     save_error_far2
                bsr     fclose
save_ani_end:   rts

                        IF 1=2
                tst.b   L0787           ;ANI
                beq.s   L062C
                clr.b   L0787
                bsr     copy_board
L062C:          move.b  L0784,D6
                cmpi.w  #$0110,D0
                bcs     L064E
                cmpi.w  #$0139,D0
                bcc     L066D
                move.w  D1,D5
                subi.w  #$0099,D5
                bcs     L066D
                lsr.w   #3,D5
                cmpi.w  #3,D5
                bcc     L066D
                btst    #4,D6
                bne     L066D
                btst    #2,D2
                beq     L066D
                move.w  D5,D7
                mulu    #6,D7
                lea     L057D,A4
                tst.w   0(A4,D7.w)
                bne     L066D
                bsr     inv_camera_btn
                bsr     Sm
L062D:          move.w  D5,-(SP)
                bsr     get_maus
                move.w  (SP)+,D5
                btst    #4,D2
                bne.s   L0633
                cmpi.w  #$0110,D0
                bcs.s   L0631
                cmpi.w  #$0137,D0
                bcc.s   L0631
                move.w  D1,D4
                sub.w   #$0099,D4
                bcs.s   L0631
                lsr.w   #3,D4
                cmpi.w  #3,D4
                bcc.s   L0631
                cmp.w   D4,D5
                beq.s   L062D
                tst.w   D5
                bmi.s   L062E
                bsr     Hm
                bsr     inv_camera_btn
L062E:          move.w  D4,D5
                move.w  D5,D7
                mulu    #6,D7
                tst.w   0(A4,D7.w)
                beq.s   L062F
                moveq   #-1,D5
                bra.s   L0630
L062F:          bsr     Hm
                bsr     inv_camera_btn
L0630:          bsr     Sm
                bra.s   L062D
L0631:          tst.w   D5
                bmi.s   L0632
                bsr     Hm
                bsr     inv_camera_btn
                bsr     Sm
L0632:          moveq   #-1,D5
                bra.s   L062D
L0633:          bsr     Hm
                tst.w   D5
                bmi     L066D
                bsr     inv_camera_btn
                cmpi.w  #2,D5
                bne.s   L0634
                tst.w   L068B
                beq     L066D
                move.l  L0830,L0831
                clr.l   L082E
                clr.l   L082F
                clr.w   L068B
                bra     L065A

L0634:          move.w  D5,-(SP)
                bsr     alle_irqs_aus
                bsr     Hm
                bsr     switch2tos
                bsr     Sm
L0635:          bsr     get_maus
                andi.w  #3,D2
                bne.s   L0635
                bset    #0,L068E
                bne.s   L0637
                move.w  #$0019,-(SP)
                trap    #1
                addq.l  #2,SP
                lea     L0833,A0
                move.b  D0,(A0)
                addi.b  #$41,(A0)+
                move.b  #$3A,(A0)+
                addq.b  #1,D0
                ext.w   D0
                move.w  D0,-(SP)
                move.l  A0,-(SP)
                move.w  #$0047,-(SP)
                trap    #1
                addq.l  #2,SP
                movea.l (SP)+,A0
                addq.l  #2,SP
L0636:          tst.b   (A0)+
                bne.s   L0636
                move.b  #$5C,-(A0)
                addq.l  #1,A0
                move.b  #'*',(A0)+
                move.b  #'.',(A0)+
                move.b  #'A',(A0)+
                move.b  #'N',(A0)+
                move.b  #'I',(A0)+
                move.b  #0,(A0)
L0637:          clr.w   int_out
                clr.w   int_out+2
                move.l  #L0833,addr_in
                move.l  #L0834,addr_in+4
                move.l  #fsel_input,D0
                bsr     _aes
                bsr     Hm
                move.w  int_out+2,D0
                cmpi.b  #1,D0
                bne     L064C
                lea     L0833,A0
                lea     build_path,A1
L0638:          move.b  (A0),(A1)+
                tst.b   (A0)+
                bne.s   L0638
L0639:          cmpi.b  #$5C,-(A1)
                bne.s   L0639
                addq.l  #1,A1
                lea     L0834,A0
                lea     L068F,A2
L063A:          move.b  (A0),(A2)+
                move.b  (A0)+,(A1)+
                bne.s   L063A
                move.w  (SP)+,D5
                cmpi.w  #1,D5
                beq     L0646
                move.w  #0,-(SP)
                pea     build_path
                move.w  #$003D,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,L082C
                bpl.s   L063C
L063B:          move.l  #filenotfound,D0 ;Disk file not found...
                bsr     alert
                bra     L064D
L063C:          btst    #0,L0784
                beq.s   L063D
                move.l  L0830,-(SP)
                move.w  #$0049,-(SP)
                trap    #1
                addq.l  #6,SP
                clr.l   L0830
                clr.l   L082D
L063D:          pea     L0685
                move.l  #$00000016,-(SP)
                move.w  L082C,-(SP)
                move.w  #$003F,-(SP)    ;Schreiben
                trap    #1
                lea     $000C(SP),SP
                cmpi.w  #$0016,D0
                bne.s   L063B
                bsr     get_free_mem
                tst.l   D0
                bpl.s   L063E
                moveq   #0,D0
L063E:          moveq   #0,D3
                move.w  L0688,D3
                beq     L064D
                divu    D3,D0
                cmpi.w  #$0064,D0
                bcs.s   L063F
                moveq   #$63,D0
L063F:          cmp.w   L068B,D0
                bcc.s   L0640
                move.l  #L068D,D0       ;Not enough RAM for *.ANI-file
                bsr     alert
                clr.w   L068B
                bra     L064D
L0640:          mulu    D0,D3
                movem.l D0/D3,-(SP)
                move.l  D3,-(SP)
                move.w  #$0048,-(SP)
                trap    #1
                addq.l  #6,SP
                move.l  D0,D1
                movem.l (SP)+,D0/D3
                move.l  D1,L0830
                move.l  D1,L0831
                add.l   D3,D1
                move.l  D1,L0832
                ext.l   D0
                divu    #$000A,D0
                lea     L0645(PC),A0
                lea     L058F,A1
                move.b  0(A0,D0.w),(A1)+
                swap    D0
                move.b  0(A0,D0.w),(A1)
                movea.l L0830,A0
                move.l  A0,L082D
                moveq   #1,D1
                move.w  L068B,D2
                subq.w  #1,D2
                move.w  L0688,D3
                andi.l  #$0000FFFF,D3
                subi.l  #$0000000A,D3
                movea.l A0,A1
                move.b  D1,(A0)+
                clr.b   (A0)+
                move.l  A1,(A0)+
                move.l  A1,(A0)+
                bra.s   L0642
L0641:          lea     0(A0,D3.w),A1
                addq.w  #1,D1
                movea.l -4(A0),A2
                move.l  A1,-4(A0)
                movea.l 2(A2),A3
                move.l  A1,2(A2)
                move.b  D1,(A1)+
                clr.b   (A1)+
                move.l  A3,(A1)+
                move.l  A2,(A1)+
                movea.l A1,A0
L0642:          movem.w D1-D2,-(SP)
                move.l  A0,-(SP)
                move.l  D3,-(SP)
                move.w  L082C,-(SP)
                move.w  #$003F,-(SP)
                trap    #1
                addq.l  #4,SP
                move.l  (SP)+,D3
                movea.l (SP)+,A0
                movem.w (SP)+,D1-D2
                cmp.l   D3,D0
                bne     L063B
                dbra    D2,L0641
                move.l  L0830,L082D
                lea     0(A0,D3.w),A0
                move.l  A0,L0831
                clr.l   L082E
                clr.l   L082F
                bsr     Hm
                bsr     switch2neo
                move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                btst    #0,L0784
                beq.s   L0643
                bsr     L0286
L0643:          move.b  #5,L0784
                move.w  L0686,D0
                add.w   D0,D0
                addq.w  #1,D0
                add.w   L0689,D0
                move.w  D0,L07D2
                move.w  L0687,D0
                add.w   L068A,D0
                addq.w  #1,D0
                move.w  D0,L07D3
                move.w  L0689,L07D0
                move.w  L068A,L07D1
                jsr     L01B8
                bsr     L0286
                move.w  #3,L057D
                move.w  #0,L057E
                bsr     print_load
                movea.l scr1,A0
                movea.l scr2,A1
                move.w  #$03E7,D0
L0644:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L0644
                bra     L0652

L0645:                  DC.B '0123456789'

L0646:          move.w  L07D0,L0689
                move.w  L07D1,L068A
                move.w  #0,-(SP)
                pea     build_path
                move.w  #$003C,-(SP)
                trap    #1
                addq.l  #8,SP
                move.w  D0,L082C
                bmi.s   L0647
                pea     L0685
                move.l  #$00000016,-(SP)
                move.w  L082C,-(SP)
                move.w  #$0040,-(SP)
                trap    #1
                lea     $000C(SP),SP
                cmpi.w  #$0016,D0
                beq.s   L0648
L0647:          move.l  #disk_full,D0   ;Disk full...
                bsr     alert
                bra.s   L064D
L0648:          move.w  L0688,D1
                subi.w  #$000A,D1
                andi.l  #$0000FFFF,D1
                movea.l L082D,A0
                move.b  (A0),D0
                ext.w   D0
                subq.w  #1,D0
                bra.s   L064A
L0649:          movea.l 2(A0),A0
L064A:          dbra    D0,L0649
                movea.l A0,A1
L064B:          move.l  A1,-(SP)
                lea     $000A(A0),A0
                move.l  A0,-(SP)
                move.l  D1,-(SP)
                move.w  L082C,-(SP)
                move.w  #$0040,-(SP)
                trap    #1
                addq.w  #4,SP
                move.l  (SP)+,D1
                movea.l (SP)+,A0
                suba.w  #$000A,A0
                movea.l (SP)+,A1
                cmp.l   D1,D0
                bne.s   L0647
                movea.l 6(A0),A0
                cmpa.l  A0,A1
                bne.s   L064B
                move.w  L082C,-(SP)
                move.w  #$003E,-(SP)
                trap    #1
                addq.l  #4,SP
                bra.s   L064D
L064C:          addq.l  #2,SP
L064D:          bsr     Hm
                jsr     switch2neo
                move.w  #-1,evt_timer_aus
                move.w  #$2500,acia_irq_sr
                bra     L066D
L064E:          move.w  D2,D3
                andi.w  #$000C,D3
                beq     L066D
                cmpi.w  #$0090,D1
                bcs     L0658
                cmpi.w  #$0099,D1
                bcc     L0658
                cmpi.w  #$00CD,D0
                bcs     L0658
                cmpi.w  #$00E4,D0
                bcc     L0658
                btst    #4,D6
                bne     L066D
                btst    #0,D6
                beq     L066D
                bset    #2,L0784
                move.l  L082F,D0
                beq.s   L064F
                movea.l D0,A0
                move.l  6(A0),L082F
                bra.s   L0650
L064F:          movea.l L0831,A0
                cmpa.l  L0832,A0
                beq     L066D
                move.l  A0,D0
                adda.w  L0688,A0
                move.l  A0,L0831
L0650:          moveq   #0,D2
L0651:          addq.w  #1,L068B
                cmpi.w  #1,L068B
                bne.s   L0653
                move.w  #3,L057D
                move.w  #0,L057E
                bsr     print_load
                move.l  D0,L082D
                movea.l D0,A0
                move.w  #$0101,(A0)+
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                tst.w   D2
                beq.s   L0656
L0652:          bsr     L053A
                bsr     L04AB
                bsr     L0673
                bra     L066D
L0653:          bsr     L067E
                movea.l L082D,A0
                move.b  (A0),D1
                movea.l A0,A1
L0654:          movea.l 6(A1),A1
                cmp.b   (A1),D1
                bcc.s   L0655
                addq.b  #1,(A1)
L0655:          cmpa.l  A0,A1
                bne.s   L0654
                addq.b  #1,D1
                movea.l 6(A0),A1
                move.l  D0,2(A1)
                move.l  D0,6(A0)
                move.l  D0,L082D
                movea.l D0,A2
                move.b  D1,(A2)
                move.b  #1,1(A2)
                move.l  A0,2(A2)
                move.l  A1,6(A2)
                tst.w   D2
                bne.s   L0652
L0656:          bsr     L0678
                bsr     L067E
L0657:          bsr     L053A
                bsr     L04AB
                bra     L066D
L0658:          cmpi.w  #$00B0,D1
                bcs     L0660
                cmpi.w  #$00B8,D1
                bcc     L0660
                cmpi.w  #$00DD,D0
                bcs     L0660
                cmpi.w  #$00F4,D0
                bcc     L0660
                btst    #4,D6
                bne     L066D
                lea     L082F,A4
L0659:          tst.w   L068B
                beq     L066D
                movea.l L082D,A0
                movea.l (A4),A1
                move.l  A0,(A4)
                move.b  (A0),D3
                movea.l 2(A0),A2
                movea.l 6(A0),A3
                move.l  A1,6(A0)
                subq.w  #1,L068B
                bne.s   L065D
L065A:          clr.l   L082D
                jsr     L01A6
                tst.l   L082E
                beq.s   L065B
                move.w  #3,L057D
                move.w  #3,L057E
                bra.s   L065C
L065B:          bclr    #2,L0784
                move.w  #0,L057D
                move.w  #3,L057E
L065C:          bsr     print_load
                bra     L0657
L065D:          move.l  A3,6(A2)
                move.l  A2,2(A3)
                move.l  A2,L082D
                movea.l A2,A3
L065E:          movea.l 6(A3),A3
                cmp.b   (A3),D3
                bcc.s   L065F
                subq.b  #1,(A3)
L065F:          cmpa.l  A3,A2
                bne.s   L065E
                bsr     L0673
                bsr     L0657
L0660:          cmpi.w  #$00A0,D1
                bcs     L0666
                cmpi.w  #$00A9,D1
                bcc     L0666
                cmpi.w  #$00CA,D0
                bcs     L0666
                cmpi.w  #$00DD,D0
                bcc     L0666
                btst    #4,D6
                bne.s   L0661
                btst    #2,D2
                bne.s   L0665
                move.w  L068B,D0
                cmpi.w  #2,D0
                bcs     L066D
                bset    #4,L0784
                bclr    #5,L0784
                bra     L066D
L0661:          btst    #5,D6
                bne.s   L0664
L0662:          btst    #2,D2
                bne.s   L0663
                addq.w  #1,L068C
                bra     L066D
L0663:          subq.w  #1,L068C
                bne     L066D
                move.w  #1,L068C
                bra     L066D
L0664:          andi.b  #-$31,D6
                move.b  D6,L0784
                bra     L0657
L0665:          tst.l   L082D
                beq     L066D
                bsr     L067E
                movea.l L082D,A0
                move.l  6(A0),L082D
                bsr     L0673
                bra     L0657
L0666:          cmpi.w  #$00A0,D1
                bcs     L0669
                cmpi.w  #$00A9,D1
                bcc.s   L0669
                cmpi.w  #$00F8,D0
                bcs.s   L0669
                cmpi.w  #$010B,D0
                bcc.s   L0669
                btst    #4,D6
                bne.s   L0667
                btst    #2,D2
                bne.s   L0668
                move.w  L068B,D0
                cmpi.w  #2,D0
                bcs     L066D
                bset    #4,L0784
                bset    #5,L0784
                bra     L066D
L0667:          btst    #5,D6
                beq.s   L0664
                eori.w  #$000C,D2
                bra     L0662
L0668:          tst.l   L082D
                beq     L066D
                bsr     L067E
                movea.l L082D,A0
                move.l  2(A0),L082D
                bsr     L0673
                bra     L0657
L0669:          cmpi.w  #$0090,D1
                bcs.s   L066A
                cmpi.w  #$0099,D1
                bcc.s   L066A
                cmpi.w  #$00EA,D0
                bcs.s   L066A
                cmpi.w  #$00FA,D0
                bcc.s   L066A
                btst    #4,D6
                bne     L066D
                move.l  L082E,D0
                beq     L066D
                movea.l D0,A0
                move.l  6(A0),L082E
                moveq   #-1,D2
                bra     L0651
L066A:          cmpi.w  #$009F,D1
                bcs.s   L066B
                cmpi.w  #$00AA,D1
                bcc.s   L066B
                cmpi.w  #$00E0,D0
                bcs.s   L066B
                cmpi.w  #$00F3,D0
                bcc.s   L066B
                btst    #4,D6
                bne     L066D
                lea     L082E,A4
                bra     L0659
L066B:          cmpi.w  #$00B1,D1
                bcs     L066D
                cmpi.w  #$00BC,D1
                bcc.s   L066D
                cmpi.w  #$0102,D0
                bcs.s   L066D
                cmpi.w  #$010D,D0
                bcc.s   L066D
                btst    #4,D6
                bne.s   L066D
                movea.l scr1,A0
                movea.l cut_buff,A1
                move.w  #$03E7,D0
L066C:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D0,L066C
                move.w  L07D0,D0
                addq.w  #1,D0
                move.w  D0,cutbuffer_x
                move.w  L07D1,D0
                addq.w  #1,D0
                move.w  D0,cutbuffer_y
                move.w  L0686,D0
                add.w   D0,D0
                move.w  D0,pixel_per_scan
                move.w  L0687,anz_scanlines
                move.w  #160,cpy_buff_breite_bytes
                move.w  #0,L0576
L066D:          rts

                        ENDC

L066E:          movem.l D0-A6,-(SP)
                movea.l scr2,A0
                bsr     L0684
                beq.s   L0679
                bsr.s   L0677
                movem.l (SP)+,D0-A6
                rts

L066F:          movem.l D0-A6,-(SP)
                movea.l scr1,A0
                bsr     L0684
                beq.s   L0670
                bsr.s   L0677
L0670:          movem.l (SP)+,D0-A6
                rts

L0671:          movem.l D0-A6,-(SP)
                movea.l copybox_screen,A0
                bsr     L0684
                beq.s   L0672
                bsr.s   L0677
L0672:          movem.l (SP)+,D0-A6
                rts

L0673:          movem.l D0-A6,-(SP)
                movea.l scr2,A0
                bsr.s   L0684
                beq.s   L0679
                bsr.s   L0677
                jsr     switch_screens
                movem.l (SP)+,D0-A6
                rts

L0674:          move.w  D1,D4
                bra.s   L0676
L0675:          move.l  (A1)+,(A0)+
L0676:          dbra    D4,L0675
                adda.w  D3,A0
L0677:          dbra    D2,L0674
                rts

L0678:          movem.l D0-A6,-(SP)
                movea.l scr2,A0
                bsr.s   L0684
L0679:          moveq   #0,D0
                bra.s   L067D
L067A:          move.w  D1,D4
                bra.s   L067C
L067B:          move.l  D0,(A0)+
L067C:          dbra    D4,L067B
                adda.w  D3,A0
L067D:          dbra    D2,L067A
                jsr     switch_screens
                movem.l (SP)+,D0-A6
                rts

L067E:          movem.l D0-A6,-(SP)
                movea.l scr1,A0
                bsr.s   L0684
                beq.s   L0683
                bra.s   L0682
L067F:          move.w  D1,D4
                bra.s   L0681
L0680:          move.l  (A0)+,(A1)+
L0681:          dbra    D4,L0680
                adda.w  D3,A0
L0682:          dbra    D2,L067F
L0683:          movem.l (SP)+,D0-A6
                rts
L0684:          move.w  L07D0,D1
                addq.w  #1,D1
                lsr.w   #1,D1
                move.w  L07D1,D2
                addq.w  #1,D2
                mulu    #$00A0,D2
                add.w   D1,D2
                adda.w  D2,A0
                movea.l L082D,A1
                lea     $000A(A1),A1
                move.w  L0686(PC),D1
                move.w  #$00A0,D3
                sub.w   D1,D3
                move.w  L0687(PC),D2
                lsr.w   #2,D1
                cmpa.l  #$0000000A,A1
                rts

L0685:                  DC.B $BA,$BE,$EB,$EA
L0686:                  DS.W 1
L0687:                  DS.W 1
L0688:                  DS.W 1
L0689:                  DS.W 1
L068A:                  DS.W 1
L068B:                  DS.W 1
L068C:                  DC.B $00,$14,$00,$00,$00,$00
L068D:                  DC.B '[3][Not '
                        DC.B 'enough R'
                        DC.B 'AM for|t'
                        DC.B 'his .ANI'
                        DC.B ' file..]'
                        DC.B '[OK]',$00
L068E:                  DC.B $00
L068F:                  DC.B 'ANNIE.AN'
                        DC.B 'I',$00,$00,$00,$00,$00,$00,$00
                        DS.W 13

L0690:          move.l  SP,64(A6)       ;SP merken
                movea.l 2(A6),A4        ;Adresse des Objektes (cutbuff)
                move.w  10(A6),D7       ;L0583(?)=Hîhe des Objekts(?)
                mulu    6(A6),D7        ;L07DC(?)=Bytes/Scanline(?)
                adda.l  D7,A4
                move.w  8(A6),D0        ;L0582(?)=Xstart(?)
                move.w  D0,D7
                lsr.w   #4,D7
                lsl.w   #3,D7           ;Ñquivalent zu unterem
;and.w   #%1111111111110000,D7
;lsr.w   #1,D7
                adda.l  D7,A4           ;Adresse des BB's berechnen
                move.l  A4,30(A6)
                not.w   D0              ;Startbit im BB berechnen(?)
                and.w   #$000F,D0
                move.w  D0,34(A6)       ;und speichern
                movea.l 16(A6),A5       ;irgend_copy(?), Zieladresse(?)
                move.w  24(A6),D7       ;objekt_y2
                mulu    20(A6),D7       ;x Breite in Bytes
                adda.l  D7,A5           ;Startadresse im Zielraster
                move.w  22(A6),D7       ;objekt_x2
                move.w  D7,D1
                lsr.w   #4,D7
                lsl.w   #3,D7           ;Ñquivalent zu unterer Konstruktion
;                and.w   #%1111111111110000,D7
;                lsr.w   #1,D7
                adda.l  D7,A5           ;Adresse des BB's berechnen
                move.l  A5,36(A6)       ;und merken
                not.w   D1
                and.w   #$000F,D1       ;Bitstart berechnen
                move.w  D1,40(A6)       ;und merken
                lea     L0697(PC),A0
                move.w  12(A6),D6       ;Pixel / Scanline
                move.w  26(A6),D5       ;Breite
                cmp.w   D5,D6           ;gleich?
                bge.s   L0691
                exg     D6,D5
                lea     8(A0),A0
L0691:          move.w  D5,42(A6)
                move.w  14(A6),D4
                move.w  28(A6),D3
                cmp.w   D3,D4
                bge.s   L0692
                exg     D4,D3
                lea     4(A0),A0
L0692:          move.w  D3,44(A6)
                move.l  #L06CD,L06B9
                move.l  #L06BB,L06B8
                tst.w   0(A6)
                beq.s   L0693
                lea     16(A0),A0
                move.l  #L06CB,L06B9
                move.l  #L06BA,L06B8
L0693:          move.w  22(A6),D0
                move.w  D0,D1
                add.w   26(A6),D1
                subq.w  #1,D1
                move.w  D0,D2
                lsr.w   #4,D2
                move.w  D1,D3
                lsr.w   #4,D3
                sub.w   D2,D3
                move.w  D3,54(A6)
                and.w   #$000F,D0
                add.w   D0,D0
                move.w  L0695(PC,D0.w),D0
                and.w   #$000F,D1
                add.w   D1,D1
                move.w  L0696(PC,D1.w),D1
                not.w   D1
                move.w  D0,56(A6)
                move.w  D0,58(A6)
                move.w  D1,60(A6)
                move.w  D1,62(A6)
                movea.l (A0),A0
                jmp     (A0)
L0694:          movea.l 64(A6),SP
                rts

L0695:                  DC.B $FF,$FF
L0696:                  DC.B '',$FF,'?',$FF,$1F,$FF,$0F,$FF
                        DC.B $07,$FF,$03,$FF,$01,$FF,$00,$FF
                        DC.B $00,'',$00,'?',$00,$1F,$00,$0F
                        DC.B $00,$07,$00,$03,$00,$01,$00,$00
L0697:                  DC.L L0699
                        DC.L L069C
                        DC.L L06A4
                        DC.L L06AC
                        DC.L L0698
                        DC.L L069B
                        DC.L L06A3
                        DC.L L06AB

L0698:          lea     L06F8(PC),SP
                lea     L06ED(PC),A5
                bra.s   L069A

L0699:          lea     L06F8(PC),SP
                lea     L06ED(PC),A5
L069A:          move.l  26(A6),D0
                clr.w   D0
                divu    12(A6),D0
                subq.w  #1,D0
                move.w  D0,46(A6)
                lsr.w   #1,D0
                move.w  D0,48(A6)
                move.l  28(A6),D0
                clr.w   D0
                divu    14(A6),D0
                subq.w  #1,D0
                move.w  D0,50(A6)
                lsr.w   #1,D0
                move.w  D0,52(A6)
                jmp     (A5)
L069B:          lea     L0704(PC),SP
                lea     L06FA(PC),A5
                bra.s   L069D
L069C:          lea     L0706(PC),SP
                lea     L06FA(PC),A5
L069D:          move.l  26(A6),D0
                clr.w   D0
                divu    12(A6),D0
                subq.w  #1,D0
                move.w  D0,46(A6)
                lsr.w   #1,D0
                move.w  D0,48(A6)
                move.l  14(A6),D0
                clr.w   D0
                divu    28(A6),D0
                bvc.s   L069E
                moveq   #-1,D0
                bra.s   L06A0
L069E:          swap    D0
                add.w   D0,D0
                cmp.w   28(A6),D0
                bcs.s   L069F
                addi.l  #$00010000,D0
L069F:          swap    D0
L06A0:          move.w  D0,50(A6)
                cmpi.w  #$00FF,D0
                bcc.s   L06A1
                mulu    28(A6),D0
                neg.w   D0
                bpl.s   L06A2
                clr.w   D0
L06A1:          lsr.w   #1,D0
L06A2:          move.w  D0,52(A6)
                jmp     (A5)
L06A3:          lea     L0716(PC),SP
                lea     L070C(PC),A5
                bra.s   L06A5
L06A4:          lea     L0716(PC),SP
                lea     L070C(PC),A5
L06A5:          move.l  12(A6),D0
                clr.w   D0
                divu    26(A6),D0
                bvc.s   L06A6
                moveq   #-1,D0
                bra.s   L06A8
L06A6:          swap    D0
                add.w   D0,D0
                cmp.w   26(A6),D0
                bcs.s   L06A7
                addi.l  #$00010000,D0
L06A7:          swap    D0
L06A8:          move.w  D0,46(A6)
                cmpi.w  #$00FF,D0
                bcc.s   L06A9
                mulu    26(A6),D0
                neg.w   D0
                bpl.s   L06AA
                clr.w   D0
L06A9:          lsr.w   #1,D0
L06AA:          move.w  D0,48(A6)
                move.l  28(A6),D0
                clr.w   D0
                divu    14(A6),D0
                subq.w  #1,D0
                move.w  D0,50(A6)
                lsr.w   #1,D0
                move.w  D0,52(A6)
                jmp     (A5)
L06AB:          lea     L0720(PC),SP
                lea     L0717(PC),A5
                bra.s   L06AD
L06AC:          lea     L0721(PC),SP
                lea     L0717(PC),A5
L06AD:          move.l  12(A6),D0
                clr.w   D0
                divu    26(A6),D0
                bvc.s   L06AE
                moveq   #-1,D0
                bra.s   L06B0
L06AE:          swap    D0
                add.w   D0,D0
                cmp.w   26(A6),D0
                bcs.s   L06AF
                addi.l  #$00010000,D0
L06AF:          swap    D0
L06B0:          move.w  D0,46(A6)
                cmpi.w  #$00FF,D0
                bcc.s   L06B1
                mulu    26(A6),D0
                neg.w   D0
                bpl.s   L06B2
                clr.w   D0
L06B1:          lsr.w   #1,D0
L06B2:          move.w  D0,48(A6)
                move.l  14(A6),D0
                clr.w   D0
                divu    28(A6),D0
                bvc.s   L06B3
                moveq   #-1,D0
                bra.s   L06B5
L06B3:          swap    D0
                add.w   D0,D0
                cmp.w   28(A6),D0
                bcs.s   L06B4
                addi.l  #$00010000,D0
L06B4:          swap    D0
L06B5:          move.w  D0,50(A6)
                cmpi.w  #$00FF,D0
                bcc.s   L06B6
                mulu    28(A6),D0
                neg.w   D0
                bpl.s   L06B7
                clr.w   D0
L06B6:          lsr.w   #1,D0
L06B7:          move.w  D0,52(A6)
                jmp     (A5)
L06B8:                  DC.L L06BB
                        DC.L L06BC
                        DC.L L06BD
                        DC.L L06BE
                        DC.L L06BF
                        DC.L L06C0
                        DC.L L06C1
                        DC.L L06C2
                        DC.L L06C3
                        DC.L L06C4
                        DC.L L06C5
                        DC.L L06C6
                        DC.L L06C7
                        DC.L L06C8
                        DC.L L06C9
                        DC.L L06CA
L06B9:                  DC.L L06CD
                        DC.L L06CF
                        DC.L L06D1
                        DC.L L06D3
                        DC.L L06D5
                        DC.L L06D7
                        DC.L L06D9
                        DC.L L06DB
                        DC.L L06DD
                        DC.L L06DF
                        DC.L L06E1
                        DC.L L06E3
                        DC.L L06E5
                        DC.L L06E7
                        DC.L L06E9
                        DC.L L06EB
L06BA:          add.w   #$0010,D1
                jmp     (SP)
L06BB:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06BC:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06BD:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06BE:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06BF:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C0:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C1:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C2:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C3:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06C4:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06C5:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06C6:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                jmp     (SP)
L06C7:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C8:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                jmp     (SP)
L06C9:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                jmp     (SP)
L06CA:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                jmp     (SP)
L06CB:          subq.w  #1,D1
                bge.s   L06CC
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06CC:          add.w   A2,D2
                bcc.s   L06CB
                jmp     (SP)
L06CD:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06CE
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06CE:          add.w   A2,D2
                bcc.s   L06CD
                jmp     (SP)
L06CF:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06D0
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06D0:          add.w   A2,D2
                bcc.s   L06CF
                jmp     (SP)
L06D1:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06D2
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06D2:          add.w   A2,D2
                bcc.s   L06D1
                jmp     (SP)
L06D3:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06D4
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06D4:          add.w   A2,D2
                bcc.s   L06D3
                jmp     (SP)
L06D5:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06D6
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06D6:          add.w   A2,D2
                bcc.s   L06D5
                jmp     (SP)
L06D7:          bclr    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06D8
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06D8:          add.w   A2,D2
                bcc.s   L06D7
                jmp     (SP)
L06D9:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06DA
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06DA:          add.w   A2,D2
                bcc.s   L06D9
                jmp     (SP)
L06DB:          bset    D1,D5
                bclr    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06DC
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06DC:          add.w   A2,D2
                bcc.s   L06DB
                jmp     (SP)
L06DD:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06DE
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06DE:          add.w   A2,D2
                bcc.s   L06DD
                jmp     (SP)
L06DF:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06E0
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06E0:          add.w   A2,D2
                bcc.s   L06DF
                jmp     (SP)
L06E1:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06E2
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06E2:          add.w   A2,D2
                bcc.s   L06E1
                jmp     (SP)
L06E3:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bclr    D1,D6
                sub.w   #$0011,D1
                bge.s   L06E4
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06E4:          add.w   A2,D2
                bcc.s   L06E3
                jmp     (SP)
L06E5:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06E6
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06E6:          add.w   A2,D2
                bcc.s   L06E5
                jmp     (SP)
L06E7:          bclr    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06E8
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06E8:          add.w   A2,D2
                bcc.s   L06E7
                jmp     (SP)
L06E9:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bclr    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06EA
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06EA:          add.w   A2,D2
                bcc.s   L06E9
                jmp     (SP)
L06EB:          bset    D1,D5
                bset    D1,D6
                add.w   #$0010,D1
                bset    D1,D5
                bset    D1,D6
                sub.w   #$0011,D1
                bge.s   L06EC
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
L06EC:          add.w   A2,D2
                bcc.s   L06EB
                jmp     (SP)
L06ED:          movea.w 46(A6),A2
                movea.l 30(A6),A4
                movea.l 36(A6),A5
                move.w  6(A6),D2
                move.w  44(A6),D7
                dbra    D7,L06EE
                bra     L0694
L06EE:          move.w  50(A6),D0
                move.w  52(A6),D1
L06EF:          add.w   D0,D1
                bcs.s   L06F0
                adda.w  D2,A4
                bra.s   L06EF
L06F0:          move.w  D1,52(A6)
                movea.l A4,A0
                movea.l A5,A1
                swap    D7
                move.w  42(A6),D7
                move.w  34(A6),D0
                move.w  40(A6),D1
                move.w  48(A6),D2
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                move.l  (A1),D5
                move.l  4(A1),D6
L06F1:          add.w   A2,D2
                bcs.s   L06F3
L06F2:          dbra    D0,L06F1
                moveq   #$0F,D0
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                bra.s   L06F1
L06F3:          lea     L06B8(PC),A3
                btst    D0,D3
                beq.s   L06F4
                lea     8(A3),A3
L06F4:          btst    D0,D4
                beq.s   L06F5
                lea     32(A3),A3
L06F5:          add.w   #$0010,D0
                btst    D0,D3
                beq.s   L06F6
                lea     4(A3),A3
L06F6:          btst    D0,D4
                beq.s   L06F7
                lea     16(A3),A3
L06F7:          sub.w   #$0010,D0
                movea.l (A3),A3
                jmp     (A3)
L06F8:          subq.w  #1,D7
                beq.s   L06F9
                sub.w   #$0011,D1
                bcc.s   L06F2
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
                bra.s   L06F2
L06F9:          move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.w  6(A6),D2
                adda.w  D2,A4
                adda.w  20(A6),A5
                swap    D7
                dbra    D7,L06EE
                bra     L0694
L06FA:          movea.w 46(A6),A2
                movea.l 30(A6),A4
                movea.l 36(A6),A5
                move.w  44(A6),D7
                dbra    D7,L06FB
                bra     L0694
L06FB:          swap    D7
L06FC:          movea.l A4,A0
                movea.l A5,A1
                move.w  34(A6),D0
                move.w  40(A6),D1
                move.w  48(A6),D2
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                move.l  (A1),D5
                move.l  4(A1),D6
                move.w  42(A6),D7
L06FD:          add.w   A2,D2
                bcs.s   L06FF
L06FE:          dbra    D0,L06FD
                moveq   #$0F,D0
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                bra.s   L06FD
L06FF:          lea     L06B8(PC),A3
                btst    D0,D3
                beq.s   L0700
                lea     8(A3),A3
L0700:          btst    D0,D4
                beq.s   L0701
                lea     32(A3),A3
L0701:          add.w   #$0010,D0
                btst    D0,D3
                beq.s   L0702
                lea     4(A3),A3
L0702:          btst    D0,D4
                beq.s   L0703
                lea     16(A3),A3
L0703:          sub.w   #$0010,D0
                movea.l (A3),A3
                jmp     (A3)
L0704:          subq.w  #1,D7
                beq.s   L0705
                sub.w   #$0011,D1
                bcc.s   L06FE
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
                bra.s   L06FE
L0705:          move.l  D5,(A1)+
                move.l  D6,(A1)+
                adda.w  20(A6),A5
                move.w  50(A6),D0
                add.w   D0,52(A6)
                bcc     L06FC
                adda.w  6(A6),A4
                swap    D7
                dbra    D7,L06FB
                bra     L0694
L0706:          subq.w  #1,D7
                beq.s   L0707
                sub.w   #$0011,D1
                bcc.s   L06FE
                moveq   #$0F,D1
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.l  (A1),D5
                move.l  4(A1),D6
                bra     L06FE
L0707:          move.l  D5,(A1)+
                move.l  D6,(A1)+
L0708:          move.w  50(A6),D0
                add.w   D0,52(A6)
                bcc.s   L0709
                adda.w  6(A6),A4
                adda.w  20(A6),A5
                swap    D7
                dbra    D7,L06FB
                bra     L0694
L0709:          movea.l A5,A0
                adda.w  20(A6),A5
                movea.l A5,A1
                move.l  56(A6),D5
                move.l  60(A6),D6
                move.w  54(A6),D2
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D5,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D5,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                subq.w  #1,D2
                bcs.s   L0708
                subq.w  #1,D2
                bcs.s   L070B
L070A:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D2,L070A
L070B:          move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D6,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D6,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                bra.s   L0708
L070C:          movea.w 46(A6),A2
                movea.l 30(A6),A4
                movea.l 36(A6),A5
                move.w  6(A6),D2
                move.w  44(A6),D7
                dbra    D7,L070D
                bra     L0694
L070D:          move.w  50(A6),D0
                move.w  52(A6),D1
L070E:          add.w   D0,D1
                bcs.s   L070F
                adda.w  D2,A4
                bra.s   L070E
L070F:          move.w  D1,52(A6)
                movea.l A4,A0
                movea.l A5,A1
                move.w  34(A6),D0
                move.w  40(A6),D1
                move.w  48(A6),D2
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                move.l  (A1),D5
                move.l  4(A1),D6
                swap    D7
                move.w  42(A6),D7
                dbra    D7,L0711
                bra     L0694
L0710:          dbra    D0,L0711
                moveq   #$0F,D0
                move.l  (A0)+,D3
                move.l  (A0)+,D4
L0711:          lea     L06B9(PC),A3
                btst    D0,D3
                beq.s   L0712
                lea     8(A3),A3
L0712:          btst    D0,D4
                beq.s   L0713
                lea     32(A3),A3
L0713:          add.w   #$0010,D0
                btst    D0,D3
                beq.s   L0714
                lea     4(A3),A3
L0714:          btst    D0,D4
                beq.s   L0715
                lea     16(A3),A3
L0715:          sub.w   #$0010,D0
                movea.l (A3),A3
                jmp     (A3)
L0716:          dbra    D7,L0710
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                move.w  6(A6),D2
                adda.w  D2,A4
                adda.w  20(A6),A5
                swap    D7
                dbra    D7,L070D
                bra     L0694
L0717:          movea.w 46(A6),A2
                movea.l 30(A6),A4
                movea.l 36(A6),A5
                move.w  6(A6),D2
                move.w  44(A6),D7
                dbra    D7,L0718
                bra     L0694
L0718:          swap    D7
L0719:          movea.l A4,A0
                movea.l A5,A1
                move.w  34(A6),D0
                move.w  40(A6),D1
                move.w  48(A6),D2
                move.l  (A0)+,D3
                move.l  (A0)+,D4
                move.l  (A1),D5
                move.l  4(A1),D6
                move.w  42(A6),D7
                dbra    D7,L071B
                bra     L0694
L071A:          dbra    D0,L071B
                moveq   #$0F,D0
                move.l  (A0)+,D3
                move.l  (A0)+,D4
L071B:          lea     L06B9(PC),A3
                btst    D0,D3
                beq.s   L071C
                lea     8(A3),A3
L071C:          btst    D0,D4
                beq.s   L071D
                lea     32(A3),A3
L071D:          add.w   #$0010,D0
                btst    D0,D3
                beq.s   L071E
                lea     4(A3),A3
L071E:          btst    D0,D4
                beq.s   L071F
                lea     16(A3),A3
L071F:          sub.w   #$0010,D0
                movea.l (A3),A3
                jmp     (A3)
L0720:          dbra    D7,L071A
                move.l  D5,(A1)+
                move.l  D6,(A1)+
                adda.w  20(A6),A5
                move.w  50(A6),D0
                add.w   D0,52(A6)
                bcc.s   L0719
                adda.w  6(A6),A4
                swap    D7
                dbra    D7,L0718
                bra     L0694
L0721:          dbra    D7,L071A
                move.l  D5,(A1)+
                move.l  D6,(A1)+
L0722:          move.w  50(A6),D0
                add.w   D0,52(A6)
                bcc.s   L0723
                adda.w  6(A6),A4
                adda.w  20(A6),A5
                swap    D7
                dbra    D7,L0718
                bra     L0694
L0723:          movea.l A5,A0
                adda.w  20(A6),A5
                movea.l A5,A1
                move.l  56(A6),D5
                move.l  60(A6),D6
                move.w  54(A6),D2
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D5,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D5,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                subq.w  #1,D2
                bcs.s   L0722
                subq.w  #1,D2
                bcs.s   L0725
L0724:          move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                dbra    D2,L0724
L0725:          move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D6,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                move.l  (A0)+,D3
                move.l  (A1),D4
                eor.l   D4,D3
                and.l   D6,D3
                eor.l   D4,D3
                move.l  D3,(A1)+
                bra.s   L0722
L0726:          lea     L0741(PC),A5
                move.l  A0,14(A5)
                move.l  A1,18(A5)
                move.l  A2,22(A5)
                move.w  D4,6(A5)
                move.w  D5,8(A5)
                move.w  D6,10(A5)
                move.w  D7,12(A5)
                moveq   #-1,D1
                move.w  #$0207,D0
                movea.l A2,A1
L0727:          move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                dbra    D0,L0727
                bsr     L0734
                tst.w   jack_mode
                bne     L0733B
                move.w  #3,-(SP)
                trap    #$0E
                move.l  D0,26(A5)
                addq.l  #2,SP
                linea   #0 [ Init ]
                movea.l A0,A4
                bsr     L0735
                bra     L0733
L0728:          lea     L0741(PC),A5
                move.w  D0,0(A5)
                move.l  A0,14(A5)
                move.l  A1,18(A5)
                move.l  A2,22(A5)
                move.l  A3,2(A5)
                move.w  (A3)+,D4
                move.w  D4,D6
                move.w  (A3)+,D5
                move.w  D5,D7
                dbra    D0,L072D
                rts
L0729:          move.w  (A3)+,D3
                cmp.w   D3,D4
                ble.s   L072A
                move.w  D3,D4
                bra.s   L072B
L072A:          cmp.w   D3,D6
                bge.s   L072B
                move.w  D3,D6
L072B:          move.w  (A3)+,D3
                cmp.w   D3,D5
                ble.s   L072C
                move.w  D3,D5
                bra.s   L072D
L072C:          cmp.w   D3,D7
                bge.s   L072D
                move.w  D3,D7
L072D:          dbra    D0,L0729
                move.w  D4,6(A5)
                move.w  D5,8(A5)
                move.w  D6,10(A5)
                move.w  D7,12(A5)
                bsr     L0734
                movea.l 22(A5),A2
                moveq   #-1,D6
                move.w  #$0207,D7
L072E:          move.l  D6,(A2)+
                move.l  D6,(A2)+
                move.l  D6,(A2)+
                move.l  D6,(A2)+
                dbra    D7,L072E
                move.w  #3,-(SP)
                trap    #$0E
                move.l  D0,26(A5)
                addq.l  #2,SP

                moveq   #-1,D0
                move.w  D0,-(SP)        ;Auflîsung beibehalten
                move.l  D0,-(SP)
                move.l  22(A5),-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                linea   #0 [ Init ]
                movea.l A0,A4
                lea     -2(A5),A0
                move.l  A0,4(A4)
                move.l  2(A5),12(A4)
                clr.w   24(A4)
                clr.w   36(A4)
                move.l  #L0740,46(A4)
                clr.w   50(A4)
                clr.w   52(A4)
                clr.w   54(A4)
                move.w  breite_bytes,D0
                lsr.w   #2,D0
                move.w  D0,2(A4)
                move.w  D0,-2(A4)
                move.w  #1,0(A4)
                move.w  8(A5),D0
                move.w  12(A5),D7
                sub.w   D0,D7
                move.w  D0,40(A4)
L072F:          linea   #6 [ Fillpoly ]
                addq.w  #1,40(A4)
                dbra    D7,L072F
                move.w  0(A5),D7
                movea.l 2(A5),A3
                clr.w   24(A4)
                clr.w   36(A4)
                move.w  #-1,34(A4)
                bra.s   L0731
L0730:          move.l  (A3)+,38(A4)
                move.l  (A3),42(A4)
                linea   #3 [ Line ]
L0731:          dbra    D7,L0730
                lea     L073C(PC),A6
                move.l  18(A5),18(A6)
                move.l  22(A5),32(A6)
                move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                move.w  D4,14(A6)
                move.w  D4,28(A6)
                move.w  D5,16(A6)
                move.w  D5,30(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                move.w  #1,4(A6)
                move.w  breite_bytes,D7
                lsr.w   #2,D7
                move.w  D7,24(A6)
                move.w  D7,38(A6)
                linea   #7 [ Bitblk ]
                tst.w   jack_mode
                bne.s   L0732
                bsr     L0735
L0732:          lea     L073E(PC),A6
                move.l  14(A5),18(A6)
                move.l  18(A5),32(A6)
                move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                move.w  D4,14(A6)
                move.w  D4,28(A6)
                move.w  D5,16(A6)
                move.w  D5,30(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                move.w  #4,4(A6)
                move.w  breite_bytes,D7
                move.w  D7,24(A6)
                move.w  D7,38(A6)
                linea   #7 [ Bitblk ]
                lea     L073F(PC),A6
                move.l  22(A5),18(A6)
                move.l  18(A5),32(A6)
                move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                move.w  D4,14(A6)
                move.w  D4,28(A6)
                move.w  D5,16(A6)
                move.w  D5,30(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                move.w  #4,4(A6)
                move.w  breite_bytes,D7
                move.w  D7,38(A6)
                lsr.w   #2,D7
                move.w  D7,24(A6)
                linea   #7 [ Bitblk ]
L0733:          moveq   #-1,D0
                move.w  D0,-(SP)        ;Auflîsung beibehalten
                move.l  D0,-(SP)
                move.l  26(A5),-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                clr.w   54(A4)
                move.w  #$00A0,D0
                move.w  D0,2(A4)
                move.w  D0,-2(A4)
                move.w  #4,0(A4)
L0733B:         move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                rts
L0734:          lea     L073A(PC),A6
                move.l  A0,18(A6)
                move.l  A1,32(A6)
                move.w  D4,14(A6)
                move.w  D4,28(A6)
                move.w  D5,16(A6)
                move.w  D5,30(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                clr.w   6(A6)
                move.w  #1,8(A6)
                move.w  #4,4(A6)
                move.w  breite_bytes,D7
                move.w  D7,24(A6)
                lsr.w   #2,D7
                move.w  D7,38(A6)
                linea   #7 [ Bitblk ]
                rts
L0735:          movea.l 18(A5),A2
                moveq   #-1,D6
                move.w  #$0233,D7
L0736:          move.l  D6,(A2)+
                move.l  D6,(A2)+
                move.l  D6,(A2)+
                move.l  D6,(A2)+
                dbra    D7,L0736
                lea     L073D(PC),A6
                move.l  22(A5),18(A6)
                move.l  18(A5),32(A6)
                move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                move.w  D4,14(A6)
                move.w  D5,16(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                move.w  #1,4(A6)
                move.w  breite_bytes,D7
                lsr.w   #2,D7
                move.w  D7,24(A6)
                addq.w  #2,D7
                move.w  D7,38(A6)
                move.w  D7,-(SP)
                linea   #7 [ Bitblk ]

                moveq   #-1,D0
                move.w  D0,-(SP)        ;Auflîsung beibehalten
                move.l  D0,-(SP)
                move.l  18(A5),-(SP)
                move.w  #5,-(SP)
                trap    #$0E
                lea     $000C(SP),SP

                move.w  (SP)+,D7
                move.w  D7,2(A4)
                move.w  D7,-2(A4)
                move.w  #1,0(A4)
                move.w  #$0142,-692(A4)
                move.w  #$0142,-690(A4)

                move.w  #-1,int_in      ;Clip_Flag
                lea     ptsin,A0
                clr.l   (A0)+           ;0/0
                move.w  10(A5),D6
                move.w  12(A5),D7
                sub.w   6(A5),D6
                sub.w   8(A5),D7
                addq.w  #2,D6
                move.w  D6,(A0)+
                addq.w  #2,D7
                move.w  D7,(A0)
                move.l  #vs_clip,D0
                jsr     _vdi

                clr.w   int_in
                move.l  #vsf_color,D0
                jsr     _vdi

                move.w  #-1,int_in      ;Farbindex
                clr.l   ptsin           ;0/0
                move.l  #v_contourfill,D0
                jsr     _vdi

                move.w  #$013F,-692(A4)
                move.w  #$00C7,-690(A4)
                jsr     clipping_aus
                lea     L073B(PC),A6
                move.l  18(A5),18(A6)
                move.l  22(A5),32(A6)
                move.w  6(A5),D4
                move.w  8(A5),D5
                move.w  10(A5),D6
                move.w  12(A5),D7
                move.w  D4,28(A6)
                move.w  D5,30(A6)
                sub.w   D4,D6
                addq.w  #1,D6
                move.w  D6,0(A6)
                sub.w   D5,D7
                addq.w  #1,D7
                move.w  D7,2(A6)
                move.w  #1,4(A6)
                move.w  breite_bytes,D7
                lsr.w   #2,D7
                move.w  D7,38(A6)
                addq.w  #2,D7
                move.w  D7,24(A6)
                linea   #7 [ Bitblk ]
                rts

L0737:          move.w  A4,D7
                add.w   D7,D7
                adda.w  D7,A0
                move.w  A5,D7
                mulu    D1,D7
                adda.l  D7,A1
                and.w   #-$0010,D0
                lsr.w   #1,D0
                adda.w  D0,A1
                addq.l  #2,A0
                lsr.w   #3,D0
                lsr.w   #4,D2
                sub.w   D0,D2
                move.w  D2,D0
                addq.w  #1,D2
                add.w   D2,D2
                suba.w  D2,A4
                add.w   D2,D2
                add.w   D2,D2
                suba.w  D2,A5
                sub.w   D1,D3
                move.w  D0,D2
                clr.w   D1
                move.w  (A2),D5
L0738:          move.w  (A0)+,D7
                beq.s   L0739
                move.w  D7,D6
                not.w   D7
                and.w   D5,D6
                and.w   D7,(A1)
                or.w    D6,(A1)+
                and.w   D7,(A1)
                or.w    D6,(A1)+
                and.w   D7,(A1)
                or.w    D6,(A1)+
                and.w   D7,(A1)
                or.w    D6,(A1)+
                dbra    D2,L0738
                move.w  D0,D2
                adda.w  A4,A0
                adda.w  A5,A1
                addq.w  #2,D1
                and.w   #$000E,D1
                move.w  0(A2,D1.w),D5
                dbra    D3,L0738
                rts

L0739:          addq.l  #8,A1
                dbra    D2,L0738
                move.w  D0,D2
                adda.w  A4,A0
                adda.w  A5,A1
                addq.w  #2,D1
                and.w   #$000E,D1
                move.w  0(A2,D1.w),D5
                dbra    D3,L0738
far_rts:        rts

;Diese Routine konvertiert ein Farbbild in der Atari-320x200-Auflîsung
;in hohe Atari 640x400 Auflîsung unter Benutzung von Graustufen....
;C-Definition: void convert(screen,breite,hîhe,palette)
convert:        link    A6,#0

                movem.l D1-A5,-(SP)     ;Register retten

                move.w  12(A6),D0       ;Breite in Pixeln
                lsr.w   #4,D0           ;Breite in BBs errechnen
                subq.w  #1,D0           ;-1
                move.w  D0,12(A6)       ;und wieder merken

                movea.l 16(A6),A0       ;Palette des Farbbildes
                lea     palette_mono(PC),A1 ;Hier wird pro Farbe Muster gespeichert
                lea     convert_muster(PC),A2 ;hier stehen die unterschiedlichen Muster
                moveq   #15,D7          ;16 Farbregister
pal_loop3:      move.w  (A0)+,D0        ;Farbwert holen
                move.w  D0,D1
                andi.w  #7,D1
                move.w  D0,D2
                lsr.w   #4,D2           ;RGB-Werte aufaddieren
                andi.w  #7,D2           ;=Helligkeit
                add.w   D2,D1
                lsr.w   #8,D0
                andi.w  #7,D0
                add.w   D0,D1
                muls    #3,D1           ;mal 3
                lsr.w   #2,D1           ;durch 4->0..15
                andi.w  #%0000000000001111,D1 ;Bits ausblenden
                moveq   #15,D0
                sub.w   D1,D0           ;von 15 abziehen
                lsl.w   #3,D0           ;mal 8
                move.l  0(A2,D0.w),(A1)+ ;und Muster holen
                move.l  4(A2,D0.w),(A1)+
                dbra    D7,pal_loop3    ;alle 15 Farben

                movea.l 8(A6),A0        ;zu bearbeitendes Bild
                movea.l A0,A3           ;hier wird nachher wieder hinkopiert
                movea.l A0,A4
                move.w  12(A6),D0       ;Breite in BBs
                addq.w  #1,D0           ;+1
                lsl.w   #2,D0
                move.w  D0,8(A6)        ;und merken in Screenadresse!
                adda.w  D0,A4

                lea     palette_mono(PC),A2 ;und entsprechende Muster

                movea.l #%11000000000000001100000000000000,A5 ;Zum Ausmaskieren

                move.w  14(A6),ycounter ;Anzahl an Scanlines
nxt_y:          move.w  12(A6),xcounter ;20 BBs
                lea     scrollspace(PC),A1 ;hier zwischenspeichern
nxt_x:          movem.w (A0)+,D0-D3     ;4 Planes holen
                move.l  A5,D7           ;Maske
                moveq   #7,D6           ;Bitcounter
                moveq   #0,D5           ;Hier Raster aufbauen
bit_loop2:      moveq   #0,D4           ;Hier Farbwert aufbauen
                addx.w  D3,D3
                addx.w  D4,D4
                addx.w  D2,D2
                addx.w  D4,D4           ;Farbwert des Pixels holen
                addx.w  D1,D1
                addx.w  D4,D4
                addx.w  D0,D0
                addx.w  D4,D4           ;Farbwert vom Bildschirm holen
                lsl.w   #3,D4           ;mal 8
                move.l  0(A2,D4.w),D4   ;Muster fÅr diese Farbe
                and.l   D7,D4           ;Maskieren
                or.l    D4,D5           ;und einknÅpfen
                lsr.l   #2,D7           ;und Maske weiterschieben
                dbra    D6,bit_loop2
                move.l  D5,(A1)+        ;Und Raster merken

                move.l  A5,D7           ;Maske wieder holen
                moveq   #7,D6           ;Bitcounter
                moveq   #0,D5           ;Hier Raster aufbauen
bit_loop1:      moveq   #0,D4           ;Hier Farbwert aufbauen
                addx.w  D3,D3
                addx.w  D4,D4
                addx.w  D2,D2
                addx.w  D4,D4
                addx.w  D1,D1           ;Getpixel
                addx.w  D4,D4
                addx.w  D0,D0
                addx.w  D4,D4           ;Farbwert vom Bildschirm holen
                lsl.w   #3,D4           ;mal 8
                move.l  0(A2,D4.w),D4   ;Muster fÅr diese Farbe
                and.l   D7,D4           ;Ausmaskieren
                or.l    D4,D5           ;und einknÅpfen
                lsr.l   #2,D7           ;und Maske runterschieben
                dbra    D6,bit_loop1
                move.l  D5,(A1)+        ;Muster merken

                subq.w  #1,xcounter     ;Alle BBs
                bpl.s   nxt_x

                move.w  12(A6),D7       ;Breite in BBs-1
                lea     scrollspace(PC),A1
chg:            move.w  (A1)+,(A4)+     ;und in Reihenfolge umkopieren
                move.w  (A1)+,(A3)+     ;zurÅck auf Bildschirm
                move.w  (A1)+,(A4)+
                move.w  (A1)+,(A3)+
                dbra    D7,chg
                adda.w  8(A6),A3
                adda.w  8(A6),A4

                btst    #0,ycounter+1   ;Y-Zeile gerade?
                beq.s   gerade78        ;ja
                subq.l  #4,A2           ;Alte Musterwerte nehmen
                bra.s   weiter22
gerade78:       addq.l  #4,A2           ;Neue Musterwerte benutzen
weiter22:       subq.w  #1,ycounter     ;Alle Scanlines bearbeiten
                bne     nxt_y

                movem.l (SP)+,D0-A5
                unlk    A6
                rts

;FÅllmuster fÅr Low->Mono Wandeln
convert_muster:         DC.W $0000,$0000,$0000,$0000
                        DC.W $8888,$0000,$8888,$0000
                        DC.W $8888,$0000,$2222,$0000
                        DC.W $8888,$0000,$AAAA,$0000
                        DC.W $AAAA,$0000,$AAAA,$0000
                        DC.W $AAAA,$4444,$AAAA,$4444
                        DC.W $AAAA,$4444,$AAAA,$1111
                        DC.W $AAAA,$4444,$AAAA,$5555
                        DC.W $AAAA,$5555,$AAAA,$5555
                        DC.W $5555,$BBBB,$5555,$EEEE
                        DC.W $5555,$BBBB,$5555,$FFFF
                        DC.W $5555,$FFFF,$5555,$FFFF
                        DC.W $7777,$FFFF,$5555,$FFFF
                        DC.W $7777,$FFFF,$DDDD,$FFFF
                        DC.W $7777,$FFFF,$FFFF,$FFFF
                        DC.W $FFFF,$FFFF,$FFFF,$FFFF

xcounter:               DS.W 1
ycounter:               DS.W 1
palette_mono:           DS.W 64


;Diese Routine kopiert einen rechteckigen Bildschirmbereich von einem Platz
;zu einem anderen. Dabei werden öberlappungen NICHT berÅcksichtigt.
;Der neue Bereich ersetzt den alten vollstÑndig (replace).
;Die Routine clippt den Zielbereich. Als Bildschirmbreite wird die
;Åbergebene genommen, als Bildschirmhîhe wird 200 angenommen.
;Diese Routine braucht ungefÑhr 52% der Rechenzeit von Line_A #7 ohne Blitter,
;d.h. sie ist ungefÑhr doppelt so schnell.
;Line_A #7 mit Blitter ist ca. 12 mal schneller als diese Routine (also ca. 24
;mal schneller als Line_A #7 ohne Blitter!).
;Ist keine Verschiebung notwendig, ist diese Routine ca. 5 mal schneller als
;Line_A #7 ohne Blitter.
;Diese Routine benîtigt ca. 65% der Rechenzeit von raster_transp.
; 30(a6): Breite einer Scanline in Pixel (Destination)
;  26(a6): Adresse des Bildschirms (Destination)
;  24(a6): y3 (Destination)
;  22(a6): x3 (Destination)
;  20(a6): Breite einer Scanline in Pixel (Source)
;  16(a6): Adresse des Bildschirms (Source)
;  14(a6): y2 (Source)
;  12(a6): x2 (Source)
;  10(a6): y1 (Source)
;   8(a6): x1 (Source)
raster_rplc:    link    A6,#-12

                movem.l D0-A5,-(SP)     ;Register retten

                move.w  8(A6),D0        ;Source X_Min
                move.w  10(A6),D1       ;Source Y_Min
                move.w  12(A6),D2       ;Source X_Max
                move.w  14(A6),D3       ;Source Y_Max
                move.w  22(A6),D4       ;Dest X_Min
                bpl.s   raster_rout1
                sub.w   D4,D0           ;neg->zu Source X_Min addieren
                move.w  D0,8(A6)        ;zurÅck in Parameter
                moveq   #0,D4           ;Clippen
                move.w  D4,22(A6)
raster_rout1:   move.w  24(A6),D5       ;Dest Y_Min
                bpl.s   raster_rout2
                sub.w   D5,D1           ;neg->zu Source Y_Min addieren
                move.w  D1,10(A6)       ;zurÅck in Parameter
                moveq   #0,D5
                move.w  D5,24(A6)
raster_rout2:   move.w  D2,D7           ;Source X_Max
                move.w  D4,D6           ;Dest X_Min
                sub.w   D0,D7           ;Source X_Max-Source X_min=Breite-1
                add.w   D7,D6           ;=Dest X_Max
                move.w  30(A6),D7       ;Breite in Pixel (Dest)
                subq.w  #1,D7           ;bis einschliesslich hier
                sub.w   D6,D7           ;von 320 abziehen
                bpl.s   raster_rout3
                add.w   D7,D6           ;von Dest X_Max abziehen
                add.w   D7,D2           ;und von Source X_Max
                move.w  D2,12(A6)       ;zurÅck in Parameter
raster_rout3:   sub.w   D1,D3           ;Hîhe-1
                add.w   D3,D5           ;=Dest Y_Max
                move.w  #199,D3         ;Unterer Rand
                sub.w   D5,D3
                bpl.s   raster_rout4
                add.w   D3,D5           ;von Dest Y_Max abziehen
                add.w   D3,14(A6)       ;von Source Y_Max abziehen
raster_rout4:   move.w  D6,-2(A6)       ;Dest X_Max merken
                move.w  D5,-4(A6)       ;Dest Y_Max merken

                move.w  12(A6),D5       ;Source X_Max
                sub.w   8(A6),D5        ;-Source X_Min
                bmi     raster_rout45
                move.w  14(A6),D5       ;Source Y_Max
                sub.w   10(A6),D5       ;-Source Y_Min
                bmi     raster_rout45

                moveq   #$0F,D5
                move.w  D0,D1           ;Source X_Min
                and.w   D5,D1
                move.w  D4,D3           ;Dest X_Min
                and.w   D5,D3
                lsr.w   #4,D0           ;# des BBs (Source X_Min)
                lsr.w   #4,D4           ;# des BBs (Dest X_Min)
                lsr.w   #4,D2           ;# des BBs (Source X_Max)
                lsr.w   #4,D6           ;# des BBs (Dest X_Max)
                sub.w   D0,D2           ;X_Max-X_Min=Breite in BBs-1 (Source)
                sub.w   D4,D6           ;-'- (Dest)
                move.w  D2,D5           ;Breite des Sourceblocks
                sub.w   D6,D5           ;-Breite des Zielblocks
                andi.w  #1,D5           ;NFSR?
                lsl.w   #2,D5           ;an richtige Position schieben
                sub.w   D3,D1           ;Skew
                move.w  D6,D0           ;Breite des Zielblocks in BBs
                subq.w  #1,D0
                move.w  D0,-6(A6)       ;und merken
                move.w  D2,D7           ;Breite des Sourceblocks in BBs-1
                move.w  D1,D4           ;Skew
                move.w  D1,D2           ;Skew
                tst.w   D4              ;Skew rechts oder links?
                bgt.s   raster_rout5    ;ja
                beq.s   raster_rout6
                neg.w   D4              ;Skew positiv machen
                addq.w  #1,D5           ;und merken
raster_rout5:   cmpi.w  #8,D4           ;Skew weniger als 8?
                blt.s   raster_rout6
                addq.w  #2,D5           ;und merken, besser andersrum shiften(!)
                neg.w   D4              ;Skew umdrehen, also
                addi.w  #16,D4          ;von 16 abziehen
raster_rout6:   move.w  12(A6),D0       ;Source X_Max
                move.w  14(A6),D1       ;Source Y_Max
                bsr     raster_rout16   ;von hinten reinkommen
                lsl.w   #3,D7
                sub.w   D3,D7           ;Breite einer Zeile in Bytes abziehen(?)
                move.w  D7,-8(A6)       ;Offsets am Zeilenende merken
                move.w  -2(A6),D0       ;Dest X_Max
                move.w  -4(A6),D1       ;Dest Y_Max
                bsr     raster_rout17   ;auch von hinten rein
                lsl.w   #3,D6           ;Breite in BBs->Breite in Bytes
                sub.w   D3,D6           ;Breite einer Zeile in Bytes abziehen(?)
                move.w  D6,-10(A6)      ;Offset am Zeilenende merken
                bsr     raster_rout13   ;Masken->D6
                swap    D6              ;Masken vertauschen
                asl.w   #3,D5           ;je nach Konstellation richtige Routine
                movea.l raster_rout10(PC,D5.w),A3
                movea.l raster_rout9(PC,D5.w),A4
                tst.w   -6(A6)          ;Breite des Zielblocks in BBs>=2?
                bgt     raster_rout12   ;ja
                blt.s   raster_rout11
                bclr    #3,D5           ;Skew nach rechts?
                beq     raster_rout12   ;Nein, dann okay
                lsr.w   #2,D5           ;nur noch mal 4
                movea.l raster_rout7(PC,D5.w),A4 ;Spezialroutine
                bra.s   raster_rout12

;Tabelle fÅr Objekte, die genau 2 BBs breit sind, und nach rechts geschoben
;werden, da es fÅr die nachfolgenden Routine (L0037) nicht mîglich war an
;bestimmte Informationen heranzukommen.
raster_rout7:           DC.L raster_rout28
                        DC.L raster_rout30
                        DC.L raster_rout29
                        DC.L raster_rout31

;Routinen fÅr nur einen BB breite Objekte:
raster_rout8:           DC.L raster_rout22
                        DC.L raster_rout23
                        DC.L raster_rout23
                        DC.L raster_rout22

;Routinen fÅr mindestens 2 BB breite Objekte
raster_rout9:           DC.L raster_rout27 ;4  = 0
raster_rout10:          DC.L raster_rout35
                        DC.L raster_rout24 ;5  = 1 -
                        DC.L raster_rout36
                        DC.L raster_rout25 ;6  = 2
                        DC.L raster_rout34
                        DC.L raster_rout26 ;7  = 3 -
                        DC.L raster_rout38
                        DC.L raster_rout26 ;12  = 4
                        DC.L raster_rout35
                        DC.L raster_rout25 ;13  = 5 -
                        DC.L raster_rout36
                        DC.L raster_rout24 ;14  = 6
                        DC.L raster_rout34
                        DC.L raster_rout27 ;15  = 7 -
                        DC.L raster_rout38

raster_rout11:  move.l  D6,D0           ;Maske
                swap    D0
                and.w   D0,D6           ;linker und rechter Rand verknÅpfen
                lea     raster_rout44(PC),A3
                btst    #5,D5           ;NFSR?
                bne.s   raster_rout12   ;Ja->Normal arbeiten
                lsr.w   #1,D5           ;nur noch mal 4
                andi.w  #%0000000000001100,D5
                movea.l raster_rout8(PC,D5.w),A4 ;Sonst andere Routine nehmen
raster_rout12:  move.w  14(A6),D5       ;y2
                sub.w   10(A6),D5       ;-y1=Hîhe in Pixeln-1
                addq.w  #1,D5           ;=Hîhe in Pixeln
                swap    D5
                move.w  -6(A6),D5       ;Breite des Zielblocks in BBs-2
                addq.l  #8,A0           ;Ans Ende des BB gehen
                addq.l  #8,A1           ;-'-
                tst.w   D4              ;Skew=0?
                beq.s   raster_rout18
                jmp     (A4)            ;und Plane bearbeiten

raster_rout13:  move.w  -2(A6),D0       ;Dest X_Max
                andi.w  #$000F,D0
                add.w   D0,D0
                move.w  raster_rout15(PC,D0.w),D6 ;Maske holen
                swap    D6
                move.w  22(A6),D0       ;Dest X_Min
                andi.w  #$000F,D0
                add.w   D0,D0
                move.w  raster_rout14(PC,D0.w),D6 ;Maske holen
                not.w   D6              ;und inverieren
                rts

raster_rout14:          DC.W %0000000000000000
raster_rout15:          DC.W %1000000000000000
                        DC.W %1100000000000000
                        DC.W %1110000000000000
                        DC.W %1111000000000000
                        DC.W %1111100000000000
                        DC.W %1111110000000000
                        DC.W %1111111000000000
                        DC.W %1111111100000000
                        DC.W %1111111110000000
                        DC.W %1111111111000000
                        DC.W %1111111111100000
                        DC.W %1111111111110000
                        DC.W %1111111111111000
                        DC.W %1111111111111100
                        DC.W %1111111111111110
                        DC.W %1111111111111111

;Routine berechnet die Startadresse des Quellrasters relativ zu:
; D0: X
;  D1: Y
; A0: Quellrasteradresse
raster_rout16:  movea.l 16(A6),A0       ;Anfangsadresse Quellraster
                move.w  20(A6),D3       ;Breite Quelle in Pixel
                lsr.w   #1,D3           ;Breite in Bytes
                lsr.w   #4,D0           ;# des BBs berechnen
                lsl.w   #3,D0
                muls    D3,D1           ;Y Offset ausrechnen
                adda.l  D1,A0
                adda.w  D0,A0           ;und dazuaddieren
                rts

;Routine berechnet die Startadresse des Zielrasters relativ zu:
; D0: X
;  D1: Y
; A1: Zielrasteradresse
raster_rout17:  movea.l 26(A6),A1       ;Anfangsadresse Zielraster
                move.w  30(A6),D3       ;Breite Ziel in Pixel
                lsr.w   #1,D3           ;Breite in Bytes berechnen
                lsr.w   #4,D0           ;# des BBs berechnen
                lsl.w   #3,D0
                muls    D3,D1           ;Y Offset berechnen
                adda.l  D1,A1
                adda.w  D0,A1           ;und dazuaddieren
                rts

;Spezialroutine falls Skew=0:
raster_rout18:  lea     raster_rout19(PC),A4 ;Bei nÑchster Scanline diese Routine
                move.l  D6,D0           ;Maske retten
                swap    D6
                move.w  D6,D7           ;obere Maske->D7
                swap    D7
                move.w  D6,D7           ;->D7
                move.w  D0,D6           ;untere Maske->D6

raster_rout19:  move.l  -(A0),D0        ;Plane 2 und 3 holen (12)
                move.l  -(A0),D1        ;Plane 0 und 1 holen (12)
                move.l  -(A1),D2        ;Screen holen   (12)
                move.l  -(A1),D3
                eor.l   D2,D0
                and.l   D6,D0
                eor.l   D2,D0
                eor.l   D3,D1
                and.l   D6,D1
                eor.l   D3,D1
                move.l  D0,4(A1)
                move.l  D1,(A1)
                tst.w   D5              ;nur ein BB?
                bmi     raster_rout43   ;ja, -> Weiter
                bra.s   raster_rout21

raster_rout20:  move.l  -(A0),-(A1)     ;Plane 2 und 3 holen (12)
                move.l  -(A0),-(A1)     ;Plane 0 und 1 holen (12)
raster_rout21:  dbra    D5,raster_rout20 ;zÑhlt bis auf 0 runter

                move.l  -(A0),D0        ;Plane 2 und 3 holen (12)
                move.l  -(A0),D1        ;Plane 0 und 1 holen (12)
                move.l  -(A1),D2        ;Screen holen   (12)
                move.l  -(A1),D3
                eor.l   D2,D0
                and.l   D7,D0
                eor.l   D2,D0
                eor.l   D3,D1
                and.l   D7,D1
                eor.l   D3,D1
                move.l  D0,4(A1)
                move.l  D1,(A1)
                bra     raster_rout43

raster_rout22:  move.w  -(A0),D0
                rol.w   D4,D0
                move.w  -(A1),D7
                eor.w   D7,D0
                and.w   D6,D0
                eor.w   D7,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                rol.w   D4,D0
                move.w  -(A1),D3
                eor.w   D3,D0
                and.w   D6,D0
                eor.w   D3,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                rol.w   D4,D0
                move.w  -(A1),D2
                eor.w   D2,D0
                and.w   D6,D0
                eor.w   D2,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                rol.w   D4,D0
                move.w  -(A1),D1
                eor.w   D1,D0
                and.w   D6,D0
                eor.w   D1,D0
                move.w  D0,(A1)
                jmp     (A3)

raster_rout23:  move.w  -(A0),D0
                ror.w   D4,D0
                move.w  -(A1),D7
                eor.w   D7,D0
                and.w   D6,D0
                eor.w   D7,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                ror.w   D4,D0
                move.w  -(A1),D3
                eor.w   D3,D0
                and.w   D6,D0
                eor.w   D3,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                ror.w   D4,D0
                move.w  -(A1),D2
                eor.w   D2,D0
                and.w   D6,D0
                eor.w   D2,D0
                move.w  D0,(A1)

                move.w  -(A0),D0
                ror.w   D4,D0
                move.w  -(A1),D1
                eor.w   D1,D0
                and.w   D6,D0
                eor.w   D1,D0
                move.w  D0,(A1)
                jmp     (A3)

raster_rout24:  move.w  -(A0),D7        ;Plane aus Objekt holen
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout25:  move.w  -(A0),D7        ;nÑchste Plane aus Objekt
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1

                move.l  D7,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D7        ;Screen holen
                eor.w   D7,D0
                and.w   D6,D0
                eor.w   D7,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  D3,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D3        ;Screen holen
                eor.w   D3,D0
                and.w   D6,D0
                eor.w   D3,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  D2,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                eor.w   D2,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  D1,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D1        ;Screen holen
                eor.w   D1,D0
                and.w   D6,D0
                eor.w   D1,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                jmp     (A3)

raster_rout26:  move.w  -(A0),D7        ;Plane aus Objekt holen
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout27:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                move.l  D7,D0           ;ins Schieberegister
                swap    D7
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D7        ;Screen holen
                eor.w   D7,D0
                and.w   D6,D0
                eor.w   D7,D0
                move.w  D0,(A1)

                move.l  D3,D0           ;ins Schieberegister
                swap    D3
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D3        ;Screen holen
                eor.w   D3,D0
                and.w   D6,D0
                eor.w   D3,D0
                move.w  D0,(A1)

                move.l  D2,D0           ;ins Schieberegister
                swap    D2
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                eor.w   D2,D0
                move.w  D0,(A1)

                move.l  D1,D0           ;ins Schieberegister
                swap    D1
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D1        ;Screen holen
                eor.w   D1,D0
                and.w   D6,D0
                eor.w   D1,D0
                move.w  D0,(A1)
                jmp     (A3)

raster_rout28:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout29:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  -(A1),D0
                eor.w   D0,D1
                and.w   D6,D1
                eor.w   D0,D1
                move.w  D1,(A1)
                bra     raster_rout40   ;und dort geht's weiter

raster_rout30:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout31:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  -(A1),D0
                eor.w   D0,D1
                and.w   D6,D1
                eor.w   D0,D1
                move.w  D1,(A1)
                bra     raster_rout40   ;dort geht's weiter

raster_rout32:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1

                move.l  D7,D0
                ror.l   D4,D0
                move.w  D0,-(A1)

                move.l  D3,D0
                ror.l   D4,D0
                move.w  D0,-(A1)

                move.l  D2,D0
                ror.l   D4,D0
                move.w  D0,-(A1)

                move.l  D1,D0
                ror.l   D4,D0
                move.w  D0,-(A1)

                jmp     (A3)

raster_rout33:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1

                move.l  D7,D0
                swap    D7
                rol.l   D4,D0
                move.w  D0,-(A1)

                move.l  D3,D0
                swap    D3
                rol.l   D4,D0
                move.w  D0,-(A1)

                move.l  D2,D0
                swap    D2
                rol.l   D4,D0
                move.w  D0,-(A1)

                move.l  D1,D0
                swap    D1
                rol.l   D4,D0
                move.w  D0,-(A1)
                jmp     (A3)

raster_rout34:  dbra    D5,raster_rout32

                move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1
                bra.s   raster_rout40

raster_rout35:  dbra    D5,raster_rout33

                move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1
                bra.s   raster_rout41

raster_rout36:  cmpi.w  #1,D5           ;Nur bis 0 runterzÑhlen
                beq.s   raster_rout37   ;bei eins Spezialroutine
                dbra    D5,raster_rout32
                bra.s   raster_rout40

raster_rout37:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1
                move.w  D7,-(A1)
                move.w  D3,-(A1)
                move.w  D2,-(A1)
                move.w  D1,-(A1)
                bra.s   raster_rout40

raster_rout38:  cmpi.w  #1,D5
                beq.s   raster_rout39
                dbra    D5,raster_rout33
                bra.s   raster_rout40

raster_rout39:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1
                move.w  D7,-(A1)
                move.w  D3,-(A1)
                move.w  D2,-(A1)
                move.w  D1,-(A1)

raster_rout40:  swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout41:  swap    D6
                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D7
                and.w   D6,D7
                eor.w   D0,D7
                move.w  D7,(A1)         ;und zurÅck auf Screen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D3
                and.w   D6,D3
                eor.w   D0,D3
                move.w  D3,(A1)         ;und zurÅck auf Screen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D2
                and.w   D6,D2
                eor.w   D0,D2
                move.w  D2,(A1)         ;und zurÅck auf Screen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D1
                and.w   D6,D1
                eor.w   D0,D1
                move.w  D1,(A1)         ;und zurÅck auf Screen

raster_rout42:  swap    D6
raster_rout43:  move.w  -6(A6),D5       ;Breite in BBs holen
raster_rout44:  swap    D5
                subq.w  #1,D5           ;Eine Scanline weniger
                beq.s   raster_rout45
                swap    D5              ;Wieder den BB-ZÑhler
                adda.w  -8(A6),A0       ;zur nÑchsten Scanline
                adda.w  -10(A6),A1      ;-'-
                addq.l  #8,A0
                addq.l  #8,A1
                jmp     (A4)            ;und von vorne starten
raster_rout45:  movem.l (SP)+,D0-A5
                unlk    A6
                rts                     ;und schultz

;Diese Routine kopiert einen rechteckigen Bildschirmbereich von einem Platz
;zu einem anderen. Dabei werden öberlappungen NICHT berÅcksichtigt.
;Der neue Bereich wird in den alten eingeknÅpft, d.h. dort wo der neue
;Bereich Hintergrundfarbe hat, scheint der alte Bereich durch. (transparent)
;Diese Routine clippt den Zielbereich. Als Breite werden die Åbergebene, als
;Hîhe 200 angenommen.
;Diese Routine ist ungefÑhr 6.8 mal schneller als Line_A #7 ohne Blitter
;Line_A #7 mit Blitter braucht ungefÑhr 85% der Rechenzeit dieser Routine.
;Ist keine Verschiebung notwendig, ist diese Routine ca. 13 mal schneller als
;Line_A #7 ohne Blitter!
; 30(a6): Breite einer Scanline in Pixel (Destination)
;  26(a6): Adresse des Bildschirms (Destination)
;  24(a6): y3 (Destination)
;  22(a6): x3 (Destination)
;  20(a6): Breite einer Scanline in Pixel (Source)
;  16(a6): Adresse des Bildschirms (Source)
;  14(a6): y2 (Source)
;  12(a6): x2 (Source)
;  10(a6): y1 (Source)
;   8(a6): x1 (Source)
raster_transp:  link    A6,#-12

                movem.l D0-A5,-(SP)     ;Register retten

                move.w  8(A6),D0        ;Source X_Min
                move.w  10(A6),D1       ;Source Y_Min
                move.w  12(A6),D2       ;Source X_Max
                move.w  14(A6),D3       ;Source Y_Max
                move.w  22(A6),D4       ;Dest X_Min
                bpl.s   raster_rout47
                sub.w   D4,D0           ;neg->zu Source X_Min addieren
                move.w  D0,8(A6)        ;zurÅck in Parameter
                moveq   #0,D4           ;Clippen
                move.w  D4,22(A6)
raster_rout47:  move.w  24(A6),D5       ;Dest Y_Min
                bpl.s   raster_rout48
                sub.w   D5,D1           ;neg->zu Source Y_Min addieren
                move.w  D1,10(A6)       ;zurÅck in Parameter
                moveq   #0,D5
                move.w  D5,24(A6)
raster_rout48:  move.w  D2,D7           ;Source X_Max
                move.w  D4,D6           ;Dest X_Min
                sub.w   D0,D7           ;Source X_Max-Source X_min=Breite-1
                add.w   D7,D6           ;=Dest X_Max
                move.w  30(A6),D7       ;Breite in Pixel (Dest)
                subq.w  #1,D7           ;bis einschliesslich hier
                sub.w   D6,D7           ;von 320 abziehen
                bpl.s   raster_rout49
                add.w   D7,D6           ;von Dest X_Max abziehen
                add.w   D7,D2           ;und von Source X_Max
                move.w  D2,12(A6)       ;zurÅck in Parameter
raster_rout49:  sub.w   D1,D3           ;Hîhe-1
                add.w   D3,D5           ;=Dest Y_Max
                move.w  #199,D3         ;Unterer Rand
                sub.w   D5,D3
                bpl.s   raster_rout50
                add.w   D3,D5           ;von Dest Y_Max abziehen
                add.w   D3,14(A6)       ;von Source Y_Max abziehen
raster_rout50:  move.w  D6,-2(A6)       ;Dest X_Max merken
                move.w  D5,-4(A6)       ;Dest Y_Max merken

                move.w  12(A6),D5       ;Source X_Max
                sub.w   8(A6),D5        ;-Source X_Min
                bmi     raster_rout45
                move.w  14(A6),D5       ;Source Y_Max
                sub.w   10(A6),D5       ;-Source Y_Min
                bmi     raster_rout45

                moveq   #$0F,D5
                move.w  D0,D1           ;Source X_Min
                and.w   D5,D1
                move.w  D4,D3           ;Dest X_Min
                and.w   D5,D3
                lsr.w   #4,D0           ;# des BBs (Source X_Min)
                lsr.w   #4,D4           ;# des BBs (Dest X_Min)
                lsr.w   #4,D2           ;# des BBs (Source X_Max)
                lsr.w   #4,D6           ;# des BBs (Dest X_Max)
                sub.w   D0,D2           ;X_Max-X_Min=Breite in BBs-1 (Source)
                sub.w   D4,D6           ;-'- (Dest)
                move.w  D2,D5           ;Breite des Sourceblocks
                sub.w   D6,D5           ;-Breite des Zielblocks
                andi.w  #1,D5           ;NFSR?
                lsl.w   #2,D5           ;an richtige Position schieben
                sub.w   D3,D1           ;Skew
                move.w  D6,D0           ;Breite des Zielblocks in BBs
                subq.w  #1,D0
                move.w  D0,-6(A6)       ;und merken
                move.w  D2,D7           ;Breite des Sourceblocks in BBs-1
                move.w  D1,D4           ;Skew
                move.w  D1,D2           ;Skew
                tst.w   D4              ;Skew rechts oder links?
                bgt.s   raster_rout51   ;ja
                beq.s   raster_rout52
                neg.w   D4              ;Skew positiv machen
                addq.w  #1,D5           ;und merken
raster_rout51:  cmpi.w  #8,D4           ;Skew weniger als 8?
                blt.s   raster_rout52
                addq.w  #2,D5           ;und merken, besser andersrum shiften(!)
                neg.w   D4              ;Skew umdrehen, also
                addi.w  #16,D4          ;von 16 abziehen
raster_rout52:  move.w  12(A6),D0       ;Source X_Max
                move.w  14(A6),D1       ;Source Y_Max
                bsr     raster_rout16   ;von hinten reinkommen
                lsl.w   #3,D7
                sub.w   D3,D7           ;Breite einer Zeile in Bytes abziehen(?)
                move.w  D7,-8(A6)       ;Offsets am Zeilenende merken
                move.w  -2(A6),D0       ;Dest X_Max
                move.w  -4(A6),D1       ;Dest Y_Max
                bsr     raster_rout17   ;auch von hinten rein
                lsl.w   #3,D6           ;Breite in BBs->Breite in Bytes
                sub.w   D3,D6           ;Breite einer Zeile in Bytes abziehen(?)
                move.w  D6,-10(A6)      ;Offset am Zeilenende merken
                bsr     raster_rout13   ;Masken->D6
                swap    D6              ;Masken vertauschen
                asl.w   #3,D5           ;je nach Konstellation richtige Routine
                movea.l raster_rout56(PC,D5.w),A3
                movea.l raster_rout55(PC,D5.w),A4
                tst.w   -6(A6)          ;Breite des Zielblocks in BBs>=2?
                bgt     raster_rout58   ;ja
                blt.s   raster_rout57
                bclr    #3,D5           ;Skew nach rechts?
                beq     raster_rout58   ;Nein, dann okay
                lsr.w   #2,D5           ;nur noch mal 4
                movea.l raster_rout53(PC,D5.w),A4 ;Spezialroutine
                bra.s   raster_rout58

;Tabelle fÅr Objekte, die genau 2 BBs breit sind, und nach rechts geschoben
;werden, da es fÅr die nachfolgenden Routine (L0037) nicht mîglich war an
;bestimmte Informationen heranzukommen.
raster_rout53:          DC.L raster_rout71
                        DC.L raster_rout73
                        DC.L raster_rout72
                        DC.L raster_rout74

;Routinen fÅr nur einen BB breite Objekte:
raster_rout54:          DC.L raster_rout65
                        DC.L raster_rout66
                        DC.L raster_rout66
                        DC.L raster_rout65

;Routinen fÅr mindestens 2 BB breite Objekte
raster_rout55:          DC.L raster_rout70 ;4  = 0
raster_rout56:          DC.L raster_rout78
                        DC.L raster_rout67 ;5  = 1 -
                        DC.L raster_rout79
                        DC.L raster_rout68 ;6  = 2
                        DC.L raster_rout77
                        DC.L raster_rout69 ;7  = 3 -
                        DC.L raster_rout81
                        DC.L raster_rout69 ;12  = 4
                        DC.L raster_rout78
                        DC.L raster_rout68 ;13  = 5 -
                        DC.L raster_rout79
                        DC.L raster_rout67 ;14  = 6
                        DC.L raster_rout77
                        DC.L raster_rout70 ;15  = 7 -
                        DC.L raster_rout81

raster_rout57:  move.l  D6,D0           ;Maske
                swap    D0
                and.w   D0,D6           ;linker und rechter Rand verknÅpfen
                lea     raster_rout44(PC),A3
                btst    #5,D5           ;NFSR?
                bne.s   raster_rout58   ;Ja->Normal arbeiten
                lsr.w   #1,D5           ;nur noch mal 4
                andi.w  #%0000000000001100,D5
                movea.l raster_rout54(PC,D5.w),A4 ;Sonst andere Routine nehmen
raster_rout58:  move.w  14(A6),D5       ;y2
                sub.w   10(A6),D5       ;-y1=Hîhe in Pixeln-1
                addq.w  #1,D5           ;=Hîhe in Pixeln
                swap    D5
                move.w  -6(A6),D5       ;Breite des Zielblocks in BBs-2
                addq.l  #8,A0           ;Ans Ende des BB gehen
                addq.l  #8,A1           ;-'-
                tst.w   D4              ;Skew=0?
                beq.s   raster_rout59   ;ja, dann Spezial-Routine nehmen
                jmp     (A4)            ;und Plane bearbeiten

;Spezialroutine falls Skew=0:
raster_rout59:  lea     raster_rout60(PC),A4 ;Bei nÑchster Scanline diese Routine
                move.l  D6,D0           ;Maske retten
                swap    D6
                move.w  D6,D7           ;obere Maske->D7
                swap    D7
                move.w  D6,D7           ;->D7
                move.w  D0,D6           ;untere Maske->D6

raster_rout60:  move.l  -(A0),D0        ;Plane 2 und 3 holen (12)
                move.l  -(A0),D1        ;Plane 0 und 1 holen (12)
                move.l  D0,D4           ;fÅr Maske      ( 4)
                or.l    D1,D4           ;               ( 8)
                swap    D0              ;               ( 4)
                swap    D1
                or.l    D0,D4           ;Maske in d4    ( 8)
                or.l    D1,D4
                swap    D0
                swap    D1
                and.l   D6,D4           ;maske_links
                move.l  -(A1),D2        ;Screen holen   (12)
                move.l  -(A1),D3
                eor.l   D2,D0
                and.l   D4,D0
                eor.l   D2,D0
                eor.l   D3,D1
                and.l   D4,D1
                eor.l   D3,D1
                move.l  D0,4(A1)
                move.l  D1,(A1)
                tst.w   D5              ;nur ein BB?
                bmi     raster_rout43   ;ja, -> Weiter
                bra.s   raster_rout63

raster_rout61:  move.l  -(A0),D0        ;Plane 2 und 3 holen (12)
                move.l  -(A0),D1        ;Plane 0 und 1 holen (12)
                move.l  D0,D4           ;fÅr Maske      ( 4)
                or.l    D1,D4           ;               ( 8)
                swap    D0              ;               ( 4)
                swap    D1
                or.l    D0,D4           ;Maske in d4    ( 8)
                or.l    D1,D4
                swap    D0
                swap    D1
                not.l   D4              ;Maske invertieren
                beq.s   raster_rout62
                move.l  -4(A1),D2       ;Screen holen   (12)
                move.l  -8(A1),D3
                and.l   D4,D2           ;               ( 8)
                or.l    D2,D0           ;               ( 8)
                and.l   D4,D3           ;               ( 8)
                or.l    D3,D1           ;               ( 8)
raster_rout62:  move.l  D0,-(A1)
                move.l  D1,-(A1)
raster_rout63:  dbra    D5,raster_rout61 ;zÑhlt bis auf 0 runter

raster_rout64:  move.l  -(A0),D0        ;Plane 2 und 3 holen (12)
                move.l  -(A0),D1        ;Plane 0 und 1 holen (12)
                move.l  D0,D4           ;fÅr Maske      ( 4)
                or.l    D1,D4           ;               ( 8)
                swap    D0              ;               ( 4)
                swap    D1
                or.l    D0,D4           ;Maske in d4    ( 8)
                or.l    D1,D4
                swap    D0
                swap    D1
                and.l   D7,D4           ;maske_rechts
                move.l  -(A1),D2        ;Screen holen   (12)
                move.l  -(A1),D3
                eor.l   D2,D0
                and.l   D4,D0
                eor.l   D2,D0
                eor.l   D3,D1
                and.l   D4,D1
                eor.l   D3,D1
                move.l  D0,4(A1)
                move.l  D1,(A1)
                bra     raster_rout43

raster_rout65:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.w   D4,D7
                rol.w   D4,D3
                rol.w   D4,D2
                rol.w   D4,D1

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1           ;Maske berechnen
                or.w    D7,D1

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                and.w   D1,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  A5,D7           ;d1 holen

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)
                jmp     (A3)

raster_rout66:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                ror.w   D4,D7
                ror.w   D4,D3
                ror.w   D4,D2
                ror.w   D4,D1

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1
                or.w    D7,D1

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                and.w   D1,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  A5,D7           ;d1 holen
                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)
                jmp     (A3)

raster_rout67:  move.w  -(A0),D7        ;Plane aus Objekt holen
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout68:  move.w  -(A0),D7        ;nÑchste Plane aus Objekt
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1

                movea.l D1,A5           ;d1 retten
                or.l    D2,D1
                or.l    D3,D1           ;Maske berechnen
                or.l    D7,D1

                move.l  D7,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                ror.l   D4,D1           ;Maske schieben
;                not.w   D1              ;Maske invertieren
                move.w  -(A1),D7        ;Screen holen
                eor.w   D7,D0
                and.w   D6,D0           ;ausblenden
                and.w   D1,D0           ;Maskieren
                eor.w   D7,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  D3,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D3        ;Screen holen
                eor.w   D3,D0
                and.w   D6,D0
                and.w   D1,D0           ;Maskieren
                eor.w   D3,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  D2,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D2,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  A5,D0           ;ins Schieberegister
                ror.l   D4,D0           ;runterschieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D2,D0
                move.w  D0,(A1)         ;und zurÅck auf Screen

                move.l  A5,D1           ;und richtiges d1 rausholen

                jmp     (A3)

raster_rout69:  move.w  -(A0),D7        ;Plane aus Objekt holen
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout70:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1

                movea.l D1,A5           ;d1 retten
                or.l    D2,D1
                or.l    D3,D1           ;Maske berechnen
                or.l    D7,D1

                move.l  D7,D0           ;ins Schieberegister
                swap    D7
                rol.l   D4,D0           ;schieben
                rol.l   D4,D1           ;Maske hinschieben
;                not.w   D1              ;Maske invertieren
                move.w  -(A1),D7        ;Screen holen
                eor.w   D7,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D7,D0
                move.w  D0,(A1)

                move.l  D3,D0           ;ins Schieberegister
                swap    D3
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D3        ;Screen holen
                eor.w   D3,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D3,D0
                move.w  D0,(A1)

                move.l  D2,D0           ;ins Schieberegister
                swap    D2
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D2,D0
                move.w  D0,(A1)

                move.l  A5,D0           ;ins Schieberegister
                rol.l   D4,D0           ;schieben
                move.w  -(A1),D2        ;Screen holen
                eor.w   D2,D0
                and.w   D6,D0
                and.w   D1,D0
                eor.w   D2,D0
                move.w  D0,(A1)

                move.l  A5,D1           ;d1 rausholen
                swap    D1              ;und auch noch umdrehen
                jmp     (A3)

raster_rout71:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout72:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1           ;Maske berechnen
                or.w    D7,D1
;               not.w   D1              ;und invertieren

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                and.w   D1,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  A5,D2           ;altes d1 holen

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.l  A5,D1           ;und nochmal her damit

                bra     raster_rout83   ;und dort geht's weiter

raster_rout73:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout74:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1           ;Maske berechnen
                or.w    D7,D1
;              not.w   D1              ;und invertieren

                move.w  -(A1),D0
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)

                move.w  -(A1),D0
                eor.w   D0,D3
                and.w   D6,D3
                and.w   D1,D3
                eor.w   D0,D3
                move.w  D3,(A1)

                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                move.w  A5,D2
                move.w  -(A1),D0
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)

                bra     raster_rout83   ;dort geht's weiter

raster_rout75:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1

                movea.l D1,A5           ;d1 retten
                or.l    D2,D1
                or.l    D3,D1
                or.l    D7,D1

                move.l  D7,D0
                ror.l   D4,D0
                ror.l   D4,D1           ;Maske auch schieben
                not.w   D1              ;Maske invertieren
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  D3,D0
                ror.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  D2,D0
                ror.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  A5,D0
                ror.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  A5,D1           ;und altes d1 rausholen
                jmp     (A3)

raster_rout76:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1

                movea.l D1,A5           ;d1 retten
                or.l    D2,D1
                or.l    D3,D1           ;Maske berechnen
                or.l    D7,D1

                move.l  D7,D0           ;ins Schieberegister
                swap    D7
                rol.l   D4,D0
                rol.l   D4,D1           ;Maske auch schieben
                not.w   D1
                and.w   D1,-(A1)        ;Maskieren
                or.w    D0,(A1)         ;und einknÅpfen

                move.l  D3,D0           ;ins Schieberegister
                swap    D3
                rol.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  D2,D0           ;ins Schieberegister
                swap    D2
                rol.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  A5,D0           ;ins Schieberegister
                rol.l   D4,D0
                and.w   D1,-(A1)
                or.w    D0,(A1)

                move.l  A5,D1           ;altes d1 holen
                swap    D1              ;und auch umdrehen
                jmp     (A3)

raster_rout77:  dbra    D5,raster_rout75

                move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1
                bra     raster_rout83

raster_rout78:  dbra    D5,raster_rout76

                move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1
                bra     raster_rout84

raster_rout79:  cmpi.w  #1,D5           ;Nur bis 0 runterzÑhlen
                beq.s   raster_rout80   ;bei eins Spezialroutine
                dbra    D5,raster_rout75
                bra.s   raster_rout83

raster_rout80:  move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                swap    D7
                swap    D3
                swap    D2
                swap    D1
                ror.l   D4,D7
                ror.l   D4,D3
                ror.l   D4,D2
                ror.l   D4,D1

                movea.l D1,A5           ;d1 merken
                or.w    D2,D1
                or.w    D3,D1           ;Maske bilden
                or.w    D7,D1
                not.w   D1

                and.w   D1,-(A1)
                or.w    D7,(A1)
                and.w   D1,-(A1)
                or.w    D3,(A1)
                and.w   D1,-(A1)
                or.w    D2,(A1)
                and.w   D1,-(A1)
                move.l  A5,D1           ;Altes D1 holen
                or.w    D1,(A1)

                bra.s   raster_rout83

raster_rout81:  cmpi.w  #1,D5
                beq.s   raster_rout82
                dbra    D5,raster_rout76
                bra.s   raster_rout83

raster_rout82:
                move.w  -(A0),D7
                move.w  -(A0),D3
                move.w  -(A0),D2
                move.w  -(A0),D1
                rol.l   D4,D7
                rol.l   D4,D3
                rol.l   D4,D2
                rol.l   D4,D1

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1           ;Maske bilden
                or.w    D7,D1
                not.w   D1

                and.w   D1,-(A1)
                or.w    D7,(A1)
                and.w   D1,-(A1)
                or.w    D3,(A1)
                and.w   D1,-(A1)
                or.w    D2,(A1)
                and.w   D1,-(A1)
                move.l  A5,D1
                or.w    D1,(A1)

raster_rout83:  swap    D7
                swap    D3
                swap    D2
                swap    D1
raster_rout84:  swap    D6

                movea.l D1,A5           ;d1 retten
                or.w    D2,D1
                or.w    D3,D1
                or.w    D7,D1           ;Maske berechnen
;                not.w   D1

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D7
                and.w   D6,D7
                and.w   D1,D7
                eor.w   D0,D7
                move.w  D7,(A1)         ;und zurÅck auf Screen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D3
                and.w   D6,D3
                and.w   D1,D3
                eor.w   D0,D3
                move.w  D3,(A1)         ;und zurÅck auf Screen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2
                eor.w   D0,D2
                move.w  D2,(A1)         ;und zurÅck auf Screen

                move.w  A5,D2           ;und altes d1 holen

                move.w  -(A1),D0        ;Screen holen
                eor.w   D0,D2
                and.w   D6,D2
                and.w   D1,D2           ;Maske
                eor.w   D0,D2
                move.w  D2,(A1)         ;und zurÅck auf Screen
                bra     raster_rout42   ;und nÑchste Scanline

;Diese Routine kopiert Speicherbereiche und berÅcksichtigt dabei evtl.
;öberlappungen.
; A0.L: Startadresse des zu verschiebenden Bereiches
;  A1.L: Endadresse -'-
;  D0.L: Anzahl an Bytes zu kopieren
memcpy:         movem.l D0-A6,-(SP)

                exg     A0,A1           ;Routine erwartet Paramter andersrum

                tst.l   D0              ;öberhaupt was zu kopieren?
                beq     memcpy21
                move.l  A0,-(SP)
                cmpa.l  A0,A1
                bhi     memcpy10
                beq     memcpy20
                adda.l  D0,A1
                adda.l  D0,A0
                move.w  A1,D1
                move.w  A0,D2
                btst    #0,D1
                beq.s   memcpy2
                btst    #0,D2
                bne.s   memcpy3
memcpy1:        move.b  -(A1),-(A0)
                subq.l  #1,D0
                bne.s   memcpy1
                bra     memcpy20
memcpy2:        btst    #0,D2
                bne.s   memcpy1
                bra.s   memcpy4
memcpy3:        move.b  -(A1),-(A0)
                subq.l  #1,D0
                beq     memcpy20
memcpy4:        move.l  D0,D1
                lsr.l   #5,D1
                lsr.l   #4,D1
                beq     memcpy6
                movem.l D2-D7/A3-A6,-(SP)
memcpy5:        movem.l -40(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -80(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -120(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -160(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -200(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -240(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -280(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -320(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -360(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -400(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -440(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -480(A1),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A0)
                movem.l -512(A1),D2-D7/A3-A4
                movem.l D2-D7/A3-A4,-(A0)
                suba.w  #$0200,A1
                subq.l  #1,D1
                bne     memcpy5
                movem.l (SP)+,D2-D7/A3-A6
memcpy6:        move.w  D0,D1
                and.w   #$01FF,D0
                lsr.w   #2,D0
                beq.s   memcpy8
                subq.w  #1,D0
memcpy7:        move.l  -(A1),-(A0)
                dbra    D0,memcpy7
memcpy8:        and.w   #3,D1
                beq     memcpy20
                subq.w  #1,D1
memcpy9:        move.b  -(A1),-(A0)
                dbra    D1,memcpy9
                bra     memcpy20
memcpy10:       move.w  A1,D1
                move.w  A0,D2
                btst    #0,D1
                beq.s   memcpy12
                btst    #0,D2
                bne.s   memcpy13
memcpy11:       move.b  (A1)+,(A0)+
                subq.l  #1,D0
                bne.s   memcpy11
                bra     memcpy20
memcpy12:       btst    #0,D2
                bne.s   memcpy11
                bra.s   memcpy14
memcpy13:       move.b  (A1)+,(A0)+
                subq.l  #1,D0
memcpy14:       move.l  D0,D1
                lsr.l   #5,D1
                lsr.l   #4,D1
                beq     memcpy16
                movem.l D2-D7/A3-A6,-(SP)
memcpy15:       movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,40(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,80(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,120(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,160(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,200(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,240(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,280(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,320(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,360(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,400(A0)
                movem.l (A1)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,440(A0)
                movem.l (A1)+,D2-D7/A3-A4
                movem.l D2-D7/A3-A4,480(A0)
                lea     $0200(A0),A0
                subq.l  #1,D1
                bne     memcpy15
                movem.l (SP)+,D2-D7/A3-A6
memcpy16:       move.w  D0,D1
                and.w   #$01FF,D0
                lsr.w   #2,D0
                beq.s   memcpy18
                subq.w  #1,D0
memcpy17:       move.l  (A1)+,(A0)+
                dbra    D0,memcpy17
memcpy18:       and.w   #3,D1
                beq.s   memcpy20
                subq.w  #1,D1
memcpy19:       move.b  (A1)+,(A0)+
                dbra    D1,memcpy19
memcpy20:       movea.l (SP)+,A0
memcpy21:
                movem.l (SP)+,D0-A6
                rts


********************************************************************************
**                                                                            **
** NEOchrome-Lupe                                               ##### ######  **
** ~~~~~~~~~~~~~~                                              ##     ##      **
**                                                              ####  ####    **
** Ω by Steffen Fischer, BrÑndstrîmweg 6, 7000 Stuttgart 50        ## ##      **
**                                                             #####  ##      **
** Entwickelt mit Turbo-Assembler                                             **
**                                                                            **
** Programmentwicklung begann am : 17.02.1991                                 **
**                                                                            **
** Aktuelles Datum               : 16.05.1991                                 **
**                                                                            **
********************************************************************************
; erweitert um Segmentierung (CHS)

big_lupe:
;
; Neue NEO-Lupe von Steffen Fischer
;
; zeichnet 4er, 8er oder 16er Lupe auf Bildschirm an feste Position
;
; 4er-Lupe:
; ---------
; x = 128 - 319 (48 KÑsten)
; y = 115 - 198 (21 KÑsten)
;
; 8er-Lupe:
; ---------
; x = 128 - 319 (24 KÑsten)
; y = 115 - 195 (10 KÑsten)
;
; 16er-Lupe:
; ----------
; x = 128 - 319 (12 KÑsten)
; y = 115 - 194 (5 KÑsten)
;
;
; öbergabeparameter:
; ------------------
; a0   = Pointer auf Screen
; d0.w = X-Position des Hotspots auf dem Screen
; d1.w = Y-Position ...........................
; d2.w = Grîûe der Lupenpixel (4, 8, 16)
;
; RÅckgabewerte:
; --------------
; keine
;
; Anmerkungen:
; ------------
; - Raster mÅssen noch gesetzt werden
; - beim VerÑndern der Vergrîûerung, Lupe mit clear_lupe lîschen
; - Kasten zeichnen, falls Lupe mit Cursorn bewegt wird
; - Rahmen um Lupe zeichnen (in Farbe 15)

                        >PART 'Paint Lupe'

clip_y_unten            EQU 100 ; dort wird geclipt bei ganzem Screen

                cmp.w   #clip_y_unten,D1
                bge.s   zu_groû
                cmp.w   #4,D2
                beq.s   draw_lupe4
                cmp.w   #8,D2
                beq     draw_lupe8
                cmp.w   #16,D2
                beq     draw_lupe16
zu_groû:        rts

draw_lupe4:
                movem.l D0-A6,-(SP)

                movea.l A0,A6           ; Screenadresse merken

                lea     lupe_work_buffer,A1 ; dort kommen Bitblocks rein
                moveq   #0,D2
                        REPT 21*6 ; 21*6 Longs
                move.l  D2,(A1)+        ; Buffer lîschen (wegen Clipping)
                        ENDR

                sub.w   #23,D0          ; wegen Hotspot linke obere Ecke
                sub.w   #10,D1          ; bestimmen

                moveq   #20,D5          ; 21 Zeilen auslesen (-1 wegen DBRA)

                lea     lupe_work_buffer,A1

                tst.w   D1              ; muû oben geclippt werden?
                bpl.s   no_clip4_oben
                move.w  D1,D2
                add.w   D1,D5           ; negative Zeilen abziehen
                neg.w   D2              ; Vorzeichen umdrehen
                move.w  D2,D3
                lsl.w   #4,D2           ; *16
                lsl.w   #3,D3           ; *8 = *24 (so breit ist Zeile)
                add.w   D3,D2
                adda.w  D2,A1           ; im Auslesebuffer tiefer
                moveq   #0,D1           ; auf Zeile 0 gehen
                bra.s   no_clip4_vert

no_clip4_oben:  cmp.w   #clip_y_unten-21,D1 ; muû unten geclippt werden?
                ble.s   no_clip4_vert
                move.w  #clip_y_unten-1,D5 ; Clipgrenze unten
                sub.w   D1,D5           ; soviele Zeilen auslesen

no_clip4_vert:  move.w  D1,D2
                lsl.w   #7,D2           ; y*128
                lsl.w   #5,D1           ; y*32
                add.w   D1,D2           ; =y*160
                adda.w  D2,A0           ; auf Screenadresse addieren

                tst.w   D0              ; muû links geclippt werden?
                bmi     clip_4_left

                move.w  D0,D1
                and.w   #-16,D1
                lsr.w   #1,D1
                adda.w  D1,A0

                cmp.w   #320-48,D0      ; rechts clippen?
                bge     clip_4_right

                and.w   #15,D0          ; Rest (0-15) zum Schieben

                moveq   #16,D6
                sub.w   D0,D6

make4_l1:
plane_off               SET 0
                        REPT 4  ; 4 Planes
                move.w  24+plane_off(A0),D1
                lsr.w   D6,D1
                moveq   #0,D2
                move.w  16+plane_off(A0),D2
                lsl.l   D0,D2
                or.w    D1,D2
                move.w  D2,16+plane_off(A1)
                swap    D2
                move.w  plane_off(A0),D1
                swap    D1
                move.w  8+plane_off(A0),D1
                lsl.l   D0,D1
                or.w    D2,D1
                move.w  D1,8+plane_off(A1)
                swap    D1
                move.w  D1,plane_off(A1)
plane_off               SET plane_off+2
                        ENDR

                lea     24(A1),A1       ; drei Bitblocks weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make4_l1

                bra     no_clip_4_hor


clip_4_right:
                cmp.w   #320-32,D0
                bge     clip_4_right2

                and.w   #15,D0

make4_l2:
plane_off               SET 0

                        REPT 4  ; 4 Planes
                moveq   #0,D2
                move.w  16+plane_off(A0),D2
                lsl.l   D0,D2
                move.w  D2,16+plane_off(A1)
                swap    D2
                move.w  plane_off(A0),D1
                swap    D1
                move.w  8+plane_off(A0),D1
                lsl.l   D0,D1
                or.w    D2,D1
                move.w  D1,8+plane_off(A1)
                swap    D1
                move.w  D1,plane_off(A1)

plane_off               SET plane_off+2
                        ENDR

                lea     24(A1),A1       ; drei Bitblocks weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make4_l2

                bra     no_clip_4_hor

clip_4_right2:
                and.w   #15,D0
make4_l3:

plane_off               SET 0
                        REPT 4  ; 4 Planes
                moveq   #0,D1
                move.w  plane_off(A0),D1
                swap    D1
                move.w  8+plane_off(A0),D1
                lsl.l   D0,D1
                move.w  D1,8+plane_off(A1)
                swap    D1
                move.w  D1,plane_off(A1)
plane_off               SET plane_off+2
                        ENDR

                lea     24(A1),A1       ; drei Bitblocks weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make4_l3

                bra     no_clip_4_hor



clip_4_left:
                neg.w   D0              ; x positiv machen

                cmp.w   #16,D0          ; zweite Cliproutine?
                bge     clip_4_left2


make4_l4:
plane_off               SET 0

                        REPT 4  ; 4 Planes

                moveq   #0,D2
                move.w  0+plane_off(A0),D2 ; erstes Wort holen
                ror.l   D0,D2
                move.w  D2,0+plane_off(A1)
                swap    D2              ; jetzt neuen Rest in d2
                moveq   #0,D1
                move.w  8+plane_off(A0),D1 ; zweites Wort holen
                ror.l   D0,D1
                or.w    D2,D1           ; alten Rest einodern
                move.w  D1,8+plane_off(A1)
                swap    D1              ; neuer Rest
                moveq   #0,D2
                move.w  16+plane_off(A0),D2 ; drittes Wort holen
                ror.l   D0,D2
                or.w    D1,D2           ; alten Rest einodern
                move.w  D2,16+plane_off(A1)


plane_off               SET plane_off+2
                        ENDR

                lea     24(A1),A1       ; drei Bitblocks weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make4_l4

                bra     no_clip_4_hor

clip_4_left2:
                and.w   #15,D0          ; nur Werte von 0-15
make4_l5:
plane_off               SET 0
; erstes Wort ist gelîscht
                        REPT 4  ; 4 Planes

                moveq   #0,D2
                move.w  0+plane_off(A0),D2 ; erstes Wort holen
                ror.l   D0,D2
                move.w  D2,8+plane_off(A1)
                swap    D2              ; jetzt neuen Rest in d2
                moveq   #0,D1
                move.w  8+plane_off(A0),D1 ; zweites Wort holen
                ror.l   D0,D1
                or.w    D2,D1           ; alten Rest einodern
                move.w  D1,16+plane_off(A1)

plane_off               SET plane_off+2
                        ENDR

                lea     24(A1),A1       ; drei Bitblocks weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make4_l5


no_clip_4_hor:

                lea     lupe_work_buffer,A0 ; dort sind aufbereitete Bitblocks
                movea.l A6,A1           ; Screenadresse
                lea     115*160+64(A1),A1 ; dort wird Lupe gezeichnet

                lea     lupen_gfx_preshift,A2
                lea     16*8(A2),A3     ; auf nÑchste Shiftphase
                lea     16*8(A3),A4
                lea     16*8(A4),A5     ; 4 Shiftphasen

                moveq   #20,D0          ; 21 KÑsten hoch
draw4l1:        move.w  D0,-(SP)

                moveq   #2,D0           ; 3*16=48 KÑsten

draw4l2:        move.w  D0,-(SP)

                movem.w (A0)+,D1-D4     ; 4 Worte holen (ein Bitblock)

                moveq   #3,D0           ; 4 mal = 16 KÑsten

draw4l3:        moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                move.l  0(A2,D5.w),D6   ; 2 Longs Grafik holen
                move.l  4(A2,D5.w),D7

                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                or.l    0(A3,D5.w),D6   ; 2 Longs Grafik holen
                or.l    4(A3,D5.w),D7

                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                or.l    0(A4,D5.w),D6   ; 2 Longs Grafik holen
                or.l    4(A4,D5.w),D7

                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                or.l    0(A5,D5.w),D6   ; 2 Longs Grafik holen
                or.l    4(A5,D5.w),D7

                move.l  D6,(A1)
                move.l  D7,4(A1)
                move.l  D6,160(A1)
                move.l  D7,164(A1)
                move.l  D6,320(A1)
                move.l  D7,324(A1)
                tst.b   segmentierung
                beq.s   no_seg7
                move.l  D6,480(A1)
                move.l  D7,484(A1)

no_seg7:        lea     8(A1),A1        ; einen Bitblock weiter

                dbra    D0,draw4l3

                move.w  (SP)+,D0
                dbra    D0,draw4l2

                lea     4*160-12*8(A1),A1
                move.w  (SP)+,D0
                dbra    D0,draw4l1


; hier wird der Hotspot (4er) gezeichnet. in Farbe 15

                movea.l A6,A0           ; Screenadresse
                lea     (115+39)*160(A0),A0
                lea     64+5*8(A0),A0

                move.l  #%00000000000100010000000000010001,D0 ; Werte fÅr Hotspot Rahmen
                move.l  #%00000000000111110000000000011111,D1

                tst.b   lupe_paint      ;Inside Fixierte Lupe?
                beq     no_hotspot4     ;ja->kein Hotspot
                btst    #0,mouse_pos    ;Maus im Board?
                beq.s   no_hotspot4     ;Ja->kein Hotspot zeichnen

                or.l    D1,(A0)+
                or.l    D1,(A0)+
                lea     152(A0),A0

                        REPT 3
                or.l    D0,(A0)+
                or.l    D0,(A0)+
                lea     152(A0),A0
                        ENDR

                or.l    D1,(A0)+
                or.l    D1,(A0)+
                bra     ende_4

no_hotspot4:    tst.b   segmentierung
                bne.s   ende_4

                clr.l   (A0)+
                clr.l   (A0)+
                lea     152+160*3(A0),A0 ;Hotspot weglîschen
                clr.l   (A0)+
                clr.l   (A0)+

ende_4:         movem.l (SP)+,D0-A6
                rts



draw_lupe8:     movem.l D0-A6,-(SP)

                movea.l A0,A6           ; Screenadresse merken

                lea     lupe_work_buffer,A1 ; dort kommen Bitblocks rein
                moveq   #0,D2
                        REPT 10*4 ; 9*4 Longs
                move.l  D2,(A1)+        ; Buffer lîschen (wegen Clipping)
                        ENDR

                sub.w   #11,D0          ; wegen Hotspot linke obere Ecke
                subq.w  #4,D1           ; bestimmen

                moveq   #9,D5           ; 10 Zeilen auslesen (-1 wegen DBRA)

                lea     lupe_work_buffer,A1

                tst.w   D1              ; muû oben geclippt werden?
                bpl.s   no_clip8_oben
                move.w  D1,D2
                add.w   D1,D5           ; negative Zeilen abziehen
                neg.w   D2              ; Vorzeichen umdrehen
                lsl.w   #4,D2           ; *16 (so breit ist Zeile)
                adda.w  D2,A1           ; im Auslesebuffer tiefer
                moveq   #0,D1           ; auf Zeile 0 gehen
                bra.s   no_clip8_vert

no_clip8_oben:  cmp.w   #clip_y_unten-10,D1 ; muû unten geclippt werden?
                ble.s   no_clip8_vert
                move.w  #clip_y_unten-1,D5 ; Clipgrenze unten
                sub.w   D1,D5           ; soviele Zeilen auslesen

no_clip8_vert:
                move.w  D1,D2
                lsl.w   #7,D2           ; y*128
                lsl.w   #5,D1           ; y*32
                add.w   D1,D2           ; =y*160
                adda.w  D2,A0           ; auf Screenadresse addieren

                tst.w   D0              ; muû links geclippt werden?
                bmi     clip_8_left

                move.w  D0,D1
                and.w   #-16,D1
                lsr.w   #1,D1
                adda.w  D1,A0

                cmp.w   #320-32,D0      ; rechts clippen?
                bge.s   clip_8_right

                and.w   #15,D0          ; Rest (0-15) zum Schieben

                moveq   #16,D6
                sub.w   D0,D6

make8_l1:
                movem.w (A0)+,D1-D4     ; ersten Bitblock holen
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                move.w  (A0)+,D1        ; zweiten Bitblock holen
                move.w  (A0)+,D2
                move.w  (A0)+,D3
                move.w  (A0)+,D4
                lsl.l   D0,D1
                lsl.l   D0,D2
                lsl.l   D0,D3
                lsl.l   D0,D4

                move.w  (A0)+,D7
                lsr.w   D6,D7
                or.w    D7,D1

                move.w  (A0)+,D7
                lsr.w   D6,D7
                or.w    D7,D2

                move.w  (A0)+,D7
                lsr.w   D6,D7
                or.w    D7,D3

                move.w  (A0)+,D7
                lsr.w   D6,D7
                or.w    D7,D4

                movem.w D1-D4,8(A1)
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                movem.w D1-D4,(A1)

                lea     16(A1),A1       ; zwei Bitblocks weiter
                lea     136(A0),A0      ; eine Scanline tiefer
                dbra    D5,make8_l1

                bra     no_clip_8_hor


clip_8_right:   cmp.w   #320-16,D0
                bge.s   clip_8_right2

                and.w   #15,D0

make8_l2:       movem.w (A0)+,D1-D4     ; ersten Bitblock holen
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                move.w  (A0)+,D1        ; zweiten Bitblock holen
                move.w  (A0)+,D2
                move.w  (A0)+,D3
                move.w  (A0)+,D4
                lsl.l   D0,D1
                lsl.l   D0,D2
                lsl.l   D0,D3
                lsl.l   D0,D4

                movem.w D1-D4,8(A1)
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                movem.w D1-D4,(A1)

                lea     16(A1),A1       ; zwei Bitblocks weiter
                lea     144(A0),A0      ; eine Scanline tiefer
                dbra    D5,make8_l2

                bra     no_clip_8_hor


clip_8_right2:  and.w   #15,D0          ; Rest (0-15) zum Schieben

                moveq   #16,D6
                sub.w   D0,D6

make8_l3:       movem.w (A0)+,D1-D4     ; ersten Bitblock holen
                lsl.w   D0,D1
                lsl.w   D0,D2
                lsl.w   D0,D3
                lsl.w   D0,D4

                movem.w D1-D4,(A1)

                lea     16(A1),A1       ; zwei Bitblocks weiter
                lea     152(A0),A0      ; eine Scanline tiefer
                dbra    D5,make8_l3

                bra.s   no_clip_8_hor


clip_8_left:    neg.w   D0              ; x positiv machen

make8_l4:       movem.w (A0)+,D1-D4     ; 1 Bitblock holen
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                move.w  (A0)+,D1        ; ins Lowword
                move.w  (A0)+,D2
                move.w  (A0)+,D3
                move.w  (A0)+,D4
                lsr.l   D0,D1
                lsr.l   D0,D2
                lsr.l   D0,D3
                lsr.l   D0,D4
                move.w  D1,8(A1)
                move.w  D2,10(A1)
                move.w  D3,12(A1)
                move.w  D4,14(A1)
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                move.w  D1,(A1)+
                move.w  D2,(A1)+
                move.w  D3,(A1)+
                move.w  D4,(A1)+
                lea     16-8(A1),A1     ; zwei Bitblock weiter
                lea     144(A0),A0      ; eine Scanline tiefer
                dbra    D5,make8_l4


no_clip_8_hor:

                lea     lupe_work_buffer,A0 ; dort sind aufbereitete Bitblocks
                movea.l A6,A1           ; Screenadresse
                lea     115*160+64(A1),A1 ; dort wird Lupe gezeichnet

                lea     lupen_gfx_preshift+4*16*8,A2
                lea     16*8(A2),A3     ; auf nÑchste Shiftphase

                moveq   #9,D0           ; 10 KÑsten hoch
draw8l1:        move.w  D0,-(SP)

                movem.w (A0)+,D1-D4     ; 4 Worte holen (ein Bitblock)

                moveq   #7,D0           ; 8*2 = 16 Blocks
draw8l2:
                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                move.l  0(A2,D5.w),D6   ; 2 Longs Grafik holen
                move.l  4(A2,D5.w),D7

                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                or.l    0(A3,D5.w),D6   ; 2 Longs Grafik holen
                or.l    4(A3,D5.w),D7

                move.l  D6,(A1)
                move.l  D7,4(A1)
                move.l  D6,160(A1)
                move.l  D7,164(A1)
                move.l  D6,320(A1)
                move.l  D7,324(A1)
                move.l  D6,480(A1)
                move.l  D7,484(A1)
                move.l  D6,640(A1)
                move.l  D7,644(A1)
                move.l  D6,800(A1)
                move.l  D7,804(A1)
                move.l  D6,960(A1)
                move.l  D7,964(A1)
                tst.b   segmentierung
                beq.s   seg8
                move.l  D6,1120(A1)
                move.l  D7,1124(A1)

seg8:           lea     8(A1),A1        ; einen Bitblock weiter
                dbra    D0,draw8l2

                movem.w (A0)+,D1-D4     ; 4 Worte holen (ein Bitblock)

                moveq   #3,D0           ; 4*2 = 8 Blocks
draw8l3:
                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                move.l  0(A2,D5.w),D6   ; 2 Longs Grafik holen
                move.l  4(A2,D5.w),D7

                moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                or.l    0(A3,D5.w),D6   ; 2 Longs Grafik holen
                or.l    4(A3,D5.w),D7

                move.l  D6,(A1)
                move.l  D7,4(A1)
                move.l  D6,160(A1)
                move.l  D7,164(A1)
                move.l  D6,320(A1)
                move.l  D7,324(A1)
                move.l  D6,480(A1)
                move.l  D7,484(A1)
                move.l  D6,640(A1)
                move.l  D7,644(A1)
                move.l  D6,800(A1)
                move.l  D7,804(A1)
                move.l  D6,960(A1)
                move.l  D7,964(A1)
                tst.b   segmentierung
                beq.s   seg9
                move.l  D6,1120(A1)
                move.l  D7,1124(A1)

seg9:           lea     8(A1),A1        ; einen Bitblock weiter
                dbra    D0,draw8l3

                lea     8*160-12*8(A1),A1 ; einen Kasten tiefer

                move.w  (SP)+,D0
                dbra    D0,draw8l1

; hier wird der Hotspot (8er) gezeichnet. in Farbe 15

                movea.l A6,A0           ; Screenadresse
                lea     (115+4*8-1)*160+104(A0),A0

                tst.b   lupe_paint      ;Inside Fixierte Lupe?
                beq     no_hotspot8     ;ja->kein Hotspot
                btst    #0,mouse_pos    ;Maus im Board?
                beq.s   no_hotspot8     ;Ja->kein Hotspot zeichnen

                move.l  #%00000001100000110000000110000011,D0 ; Werte fÅr Hotspot Rahmen
                move.l  #%00000001111111110000000111111111,D1

                or.l    D1,(A0)
                or.l    D1,4(A0)
                or.l    D1,160(A0)
                or.l    D1,164(A0)

off_count               SET 320
                        REPT 5
                or.l    D0,off_count(A0)
                or.l    D0,off_count+4(A0)
off_count               SET off_count+160
                        ENDR

                or.l    D1,off_count(A0)
                or.l    D1,off_count+4(A0)
                or.l    D1,off_count+160(A0)
                or.l    D1,off_count+164(A0)
                bra.s   ende_8

no_hotspot8:    tst.b   segmentierung
                bne.s   ende_8
                clr.l   (A0)
                clr.l   4(A0)
                clr.l   8*160(A0)
                clr.l   8*160+4(A0)

ende_8:         movem.l (SP)+,D0-A6
                rts

draw_lupe16:    movem.l D0-A6,-(SP)

                movea.l A0,A6           ; Screenadresse merken

                lea     lupe_work_buffer,A1 ; dort kommen Bitblocks rein
                moveq   #0,D2
                        REPT 5*2 ; 5*2 Longs
                move.l  D2,(A1)+        ; Buffer lîschen (wegen Clipping)
                        ENDR

                subq.w  #5,D0           ; wegen Hotspot linke obere Ecke
                subq.w  #2,D1           ; bestimmen

                moveq   #4,D5           ; 5 Zeilen auslesen (-1 wegen DBRA)

                lea     lupe_work_buffer,A1

                tst.w   D1              ; muû oben geclippt werden?
                bpl.s   no_clip16_oben
                move.w  D1,D2
                add.w   D1,D5           ; negative Zeilen abziehen
                neg.w   D2              ; Vorzeichen umdrehen
                lsl.w   #3,D2           ; *8 (so breit ist Zeile)
                adda.w  D2,A1           ; im Auslesebuffer tiefer
                moveq   #0,D1           ; auf Zeile 0 gehen
                bra.s   no_clip16_vert

no_clip16_oben: cmp.w   #clip_y_unten-5,D1 ; muû unten geclippt werden?
                ble.s   no_clip16_vert
                move.w  #clip_y_unten-1,D5 ; Clipgrenze unten
                sub.w   D1,D5           ; soviele Zeilen auslesen

no_clip16_vert:
                move.w  D1,D2
                lsl.w   #7,D2           ; y*128
                lsl.w   #5,D1           ; y*32
                add.w   D1,D2           ; =y*160
                adda.w  D2,A0           ; auf Screenadresse addieren

                tst.w   D0              ; muû links geclippt werden?
                bmi.s   clip_16_left

                move.w  D0,D1
                and.w   #-16,D1
                lsr.w   #1,D1
                adda.w  D1,A0

                cmp.w   #304,D0
                bge.s   clip_16_rechts

                and.w   #15,D0          ; Rest (0-15) zum Schieben

make16_l1:      movem.w (A0)+,D1-D4     ; ersten Bitblock holen
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                move.w  (A0)+,D1        ; zweiten Bitblock holen
                move.w  (A0)+,D2
                move.w  (A0)+,D3
                move.w  (A0)+,D4
                lsl.l   D0,D1
                lsl.l   D0,D2
                lsl.l   D0,D3
                lsl.l   D0,D4
                swap    D1
                swap    D2
                swap    D3
                swap    D4
                movem.w D1-D4,(A1)

                lea     8(A1),A1        ; ein Bitblock weiter
                lea     144(A0),A0      ; eine Scanline tiefer
                dbra    D5,make16_l1

                bra.s   no_clip_16_hor


clip_16_rechts:
                and.w   #15,D0          ; Rest (0-15) zum Schieben

make16_l2:      movem.w (A0)+,D1-D4     ; ersten Bitblock holen
                lsl.w   D0,D1
                lsl.w   D0,D2
                lsl.w   D0,D3
                lsl.w   D0,D4
                movem.w D1-D4,(A1)

                lea     8(A1),A1        ; ein Bitblock weiter
                lea     152(A0),A0      ; eine Scanline tiefer
                dbra    D5,make16_l2

                bra.s   no_clip_16_hor



clip_16_left:   neg.w   D0              ; x positiv machen

make16_l3:      movem.w (A0),D1-D4      ; 1 Bitblock holen
                lsr.w   D0,D1           ; Werte nach rechts schieben
                lsr.w   D0,D2
                lsr.w   D0,D3
                lsr.w   D0,D4
                movem.w D1-D4,(A1)
                lea     8(A1),A1        ; ein Bitblock weiter
                lea     160(A0),A0      ; eine Scanline tiefer
                dbra    D5,make16_l3


no_clip_16_hor:
                lea     lupe_work_buffer,A0 ; dort sind aufbereitete Bitblocks
                movea.l A6,A1           ; Screenadresse
                lea     115*160+64(A1),A1 ; dort wird Lupe gezeichnet
                lea     lupen_gfx_mit+2*16*8(PC),A2
                tst.b   segmentierung
                beq.s   seg3
                lea     lupen_gfx_ohne+2*16*8(PC),A2
seg3:           moveq   #4,D0           ; 5 Kasten hoch
draw16l1:       movem.w (A0)+,D1-D4     ; 4 Worte holen (ein Bitblock)

                moveq   #11,D7          ; 12 KÑsten

draw16l2:       moveq   #0,D5
                add.w   D4,D4           ; Farbwert ermitteln
                addx.w  D5,D5
                add.w   D3,D3
                addx.w  D5,D5
                add.w   D2,D2
                addx.w  D5,D5
                add.w   D1,D1
                addx.w  D5,D5
                lsl.w   #3,D5           ; *8

                move.l  0(A2,D5.w),D6   ; 2 Longs Grafik holen
                move.l  4(A2,D5.w),D5

                move.l  D6,(A1)
                move.l  D5,4(A1)
                move.l  D6,160(A1)
                move.l  D5,164(A1)
                move.l  D6,320(A1)
                move.l  D5,324(A1)
                move.l  D6,480(A1)
                move.l  D5,484(A1)
                move.l  D6,640(A1)
                move.l  D5,644(A1)
                move.l  D6,800(A1)
                move.l  D5,804(A1)
                move.l  D6,960(A1)
                move.l  D5,964(A1)
                move.l  D6,1120(A1)
                move.l  D5,1124(A1)
                move.l  D6,1280(A1)
                move.l  D5,1284(A1)
                move.l  D6,1440(A1)
                move.l  D5,1444(A1)
                move.l  D6,1600(A1)
                move.l  D5,1604(A1)
                move.l  D6,1760(A1)
                move.l  D5,1764(A1)
                move.l  D6,1920(A1)
                move.l  D5,1924(A1)
                move.l  D6,2080(A1)
                move.l  D5,2084(A1)
                move.l  D6,2240(A1)
                move.l  D5,2244(A1)
                tst.b   segmentierung
                beq.s   seg10
                move.l  D6,2400(A1)
                move.l  D5,2404(A1)

seg10:          lea     8(A1),A1        ; einen Bitblock weiter
                dbra    D7,draw16l2

                lea     16*160-12*8(A1),A1 ; einen Kasten tiefer

                dbra    D0,draw16l1


; hier wird der Hotspot (16er) gezeichnet. in Farbe 15 (alle 4 Planes)
; wenn Du Bock hast, kannst Du auch eine Schleife machen. (Nur wegen Rechenzeit
; hab ich die Repeats)
                movea.l A6,A0           ; Screenadresse
                lea     (115+31)*160+96(A0),A0
                move.l  #%00000000000000110000000000000011,D0 ; Werte fÅr Hotspot Rahmen
                moveq   #-1,D1

                tst.b   lupe_paint      ;Inside Fixierte Lupe?
                beq     no_hotspot16    ;ja->kein Hotspot
                btst    #0,mouse_pos    ;Maus im Board?
                beq     no_hotspot16    ;Ja->kein Hotspot zeichnen

                or.l    D0,(A0)
                or.l    D0,4(A0)
                or.l    D1,8(A0)
                or.l    D1,12(A0)
                or.l    D0,160(A0)
                or.l    D0,164(A0)
                or.l    D1,168(A0)
                or.l    D1,172(A0)

off_count               SET 320
                        REPT 13
                or.l    D0,off_count(A0)
                or.l    D0,off_count+4(A0)
                or.l    D0,off_count+8(A0)
                or.l    D0,off_count+12(A0)
off_count               SET off_count+160
                        ENDR

                or.l    D0,off_count(A0)
                or.l    D0,off_count+4(A0)
                or.l    D1,off_count+8(A0)
                or.l    D1,off_count+12(A0)
                or.l    D0,off_count+160(A0)
                or.l    D0,off_count+164(A0)
                or.l    D1,off_count+168(A0)
                or.l    D1,off_count+172(A0)
                bra.s   ende_16

no_hotspot16:   tst.b   segmentierung
                bne.s   ende_16
                clr.l   (A0)
                clr.l   4(A0)
                clr.l   8(A0)
                clr.l   12(A0)
                clr.l   16*160(A0)
                clr.l   16*160+4(A0)
                clr.l   16*160+8(A0)
                clr.l   16*160+12(A0)

ende_16:        movem.l (SP)+,D0-A6
                rts

                        ENDPART

                        >PART 'Lupe lîschen'

clear_lupe:
; bei Zoom-wechsel muû die Lupe gelîscht werden
;
; öbergabeparameter:
; ------------------
; a0 = Screenpointer
; d0 = Lupentyp (1,2,3)=(4,8,16)     <- CHS
;
; RÅckgabewerte:
; --------------
; keine

                movem.l D0-A6,-(SP)

                clr.b   lupe_an         ;Groûe Lupe ist im Moment zu sehen

                lea     200*160(A0),A0  ; auf letzte Zeile gehen
                moveq   #85,D0          ; 86 Scanlines lîschen
                moveq   #0,D1           ; Register lîschen
                moveq   #0,D2
                moveq   #0,D3
                moveq   #0,D4
                moveq   #0,D5
                moveq   #0,D6
                movea.l D6,A1
                movea.l D6,A2
                movea.l D6,A3
                movea.l D6,A4
                movea.l D6,A5
                movea.l D6,A6
                move.l  #%11111111111111001111111111111100,D7

clear_lupe_loop:movem.l D1-D6/A1-A6,-(A0) ; 12*4 = 48 Bytes lîschen
                movem.l D1-D6/A1-A6,-(A0) ; 12*4 = 48 Bytes lîschen
                and.l   D7,-(A0)
                and.l   D7,-(A0)
                lea     -160+104(A0),A0
                dbra    D0,clear_lupe_loop

                moveq   #127,D0
                moveq   #114,D1
                move.w  #319,D2
                move.w  D1,D3
                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                jsr     rahmen          ;Oberer Rand

                movem.l (SP),D0-A6      ;Lupentyp nach D0 holen
                subq.w  #1,D0
                lsl.w   #1,D0
                lea     lupen_grîûe,A0
                move.w  0(A0,D0.w),D3   ;Lupengrîûe aus Tabelle holen
                move.w  #319,D2
                moveq   #127,D0
                move.w  D3,D1
                moveq   #15,D4
                moveq   #0,D5
                moveq   #-1,D6
                jsr     rahmen          ;unterer Rand

                moveq   #114,D1
                move.w  D0,D2           ;Senkrechte Linie links
                jsr     rahmen

                movem.l (SP)+,D0-A6
                rts

lupen_grîûe:            DC.W 198,194,194

                        ENDPART

                        >PART 'Preshift-Lupe'
preshift_lupe:
; erstellt pregeshiftete 4er+8er Lupe im BSS

                movem.l D0-A6,-(SP)

                lea     lupen_gfx_preshift,A1
                moveq   #0,D0           ; Shiftcounter auf 0
shiftlupe4l0:   lea     lupen_gfx_mit,A0
                tst.b   segmentierung
                beq.s   seg1
                lea     lupen_gfx_ohne,A0
seg1:           moveq   #15,D1          ; 16 Zeilen
shiftlupe4l1:   moveq   #3,D2           ;4 Planes
shiftlupe4l2:   moveq   #0,D3
                move.w  (A0)+,D3        ; 4* eine Plane shiften
                ror.l   D0,D3
                move.w  D3,(A1)+
                dbra    D2,shiftlupe4l2
                dbra    D1,shiftlupe4l1
                addq.w  #4,D0           ; Shiftcounter+4
                cmp.w   #16,D0
                bne.s   shiftlupe4l0

                moveq   #0,D0           ; Shiftcounter auf 0
shiftlupe8l0:   lea     lupen_gfx_mit+16*8,A0 ; dort ist 8er Lupe
                tst.b   segmentierung
                beq.s   seg2
                lea     lupen_gfx_ohne+16*8,A0
seg2:           moveq   #15,D1          ; 16 Zeilen
shiftlupe8l1:   moveq   #3,D2
shiftlupe8l2:   moveq   #0,D3
                move.w  (A0)+,D3        ; 4* eine Plane shiften
                ror.l   D0,D3
                move.w  D3,(A1)+
                dbra    D2,shiftlupe8l2
                dbra    D1,shiftlupe8l1
                addq.w  #8,D0           ; Shiftcounter+8
                cmp.w   #16,D0
                bne.s   shiftlupe8l0

                movem.l (SP)+,D0-A6
                rts
                        ENDPART

                        >PART 'Lupen-Grafik'
lupen_gfx_mit:
; Grafik fÅr die Lupe mit Segementierung
; 4er,8er,16er Block mit Farben 0-15

                        DC.W $0000,$0000,$0000,$0000,$E000,$0000,$0000,$0000
                        DC.W $0000,$E000,$0000,$0000,$E000,$E000,$0000,$0000
                        DC.W $0000,$0000,$E000,$0000,$E000,$0000,$E000,$0000
                        DC.W $0000,$E000,$E000,$0000,$E000,$E000,$E000,$0000
                        DC.W $0000,$0000,$0000,$E000,$E000,$0000,$0000,$E000
                        DC.W $0000,$E000,$0000,$E000,$E000,$E000,$0000,$E000
                        DC.W $0000,$0000,$E000,$E000,$E000,$0000,$E000,$E000
                        DC.W $0000,$E000,$E000,$E000,$E000,$E000,$E000,$E000
                        DC.W $0000,$0000,$0000,$0000,$FE00,$0000,$0000,$0000
                        DC.W $0000,$FE00,$0000,$0000,$FE00,$FE00,$0000,$0000
                        DC.W $0000,$0000,$FE00,$0000,$FE00,$0000,$FE00,$0000
                        DC.W $0000,$FE00,$FE00,$0000,$FE00,$FE00,$FE00,$0000
                        DC.W $0000,$0000,$0000,$FE00,$FE00,$0000,$0000,$FE00
                        DC.W $0000,$FE00,$0000,$FE00,$FE00,$FE00,$0000,$FE00
                        DC.W $0000,$0000,$FE00,$FE00,$FE00,$0000,$FE00,$FE00
                        DC.W $0000,$FE00,$FE00,$FE00,$FE00,$FE00,$FE00,$FE00
                        DC.W $0000,$0000,$0000,$0000,$FFFE,$0000,$0000,$0000
                        DC.W $0000,$FFFE,$0000,$0000,$FFFE,$FFFE,$0000,$0000
                        DC.W $0000,$0000,$FFFE,$0000,$FFFE,$0000,$FFFE,$0000
                        DC.W $0000,$FFFE,$FFFE,$0000,$FFFE,$FFFE,$FFFE,$0000
                        DC.W $0000,$0000,$0000,$FFFE,$FFFE,$0000,$0000,$FFFE
                        DC.W $0000,$FFFE,$0000,$FFFE,$FFFE,$FFFE,$0000,$FFFE
                        DC.W $0000,$0000,$FFFE,$FFFE,$FFFE,$0000,$FFFE,$FFFE
                        DC.W $0000,$FFFE,$FFFE,$FFFE,$FFFE,$FFFE,$FFFE,$FFFE

;Ohne Segmentierung:
lupen_gfx_ohne:         DC.W $0000,$0000,$0000,$0000,$F000,$0000,$0000,$0000
                        DC.W $0000,$F000,$0000,$0000,$F000,$F000,$0000,$0000
                        DC.W $0000,$0000,$F000,$0000,$F000,$0000,$F000,$0000
                        DC.W $0000,$F000,$F000,$0000,$F000,$F000,$F000,$0000
                        DC.W $0000,$0000,$0000,$F000,$F000,$0000,$0000,$F000
                        DC.W $0000,$F000,$0000,$F000,$F000,$F000,$0000,$F000
                        DC.W $0000,$0000,$F000,$F000,$F000,$0000,$F000,$F000
                        DC.W $0000,$F000,$F000,$F000,$F000,$F000,$F000,$F000
                        DC.W $0000,$0000,$0000,$0000,$FF00,$0000,$0000,$0000
                        DC.W $0000,$FF00,$0000,$0000,$FF00,$FF00,$0000,$0000
                        DC.W $0000,$0000,$FF00,$0000,$FF00,$0000,$FF00,$0000
                        DC.W $0000,$FF00,$FF00,$0000,$FF00,$FF00,$FF00,$0000
                        DC.W $0000,$0000,$0000,$FF00,$FF00,$0000,$0000,$FF00
                        DC.W $0000,$FF00,$0000,$FF00,$FF00,$FF00,$0000,$FF00
                        DC.W $0000,$0000,$FF00,$FF00,$FF00,$0000,$FF00,$FF00
                        DC.W $0000,$FF00,$FF00,$FF00,$FF00,$FF00,$FF00,$FF00
                        DC.W $0000,$0000,$0000,$0000,$FFFF,$0000,$0000,$0000
                        DC.W $0000,$FFFF,$0000,$0000,$FFFF,$FFFF,$0000,$0000
                        DC.W $0000,$0000,$FFFF,$0000,$FFFF,$0000,$FFFF,$0000
                        DC.W $0000,$FFFF,$FFFF,$0000,$FFFF,$FFFF,$FFFF,$0000
                        DC.W $0000,$0000,$0000,$FFFF,$FFFF,$0000,$0000,$FFFF
                        DC.W $0000,$FFFF,$0000,$FFFF,$FFFF,$FFFF,$0000,$FFFF
                        DC.W $0000,$0000,$FFFF,$FFFF,$FFFF,$0000,$FFFF,$FFFF
                        DC.W $0000,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF

                        ENDPART


L073A:                  DS.W 2
                        DC.B $00,$04,$00,$00,$00,$01,$04,$0C
                        DC.B $04,$0C,$00,$00,$00,$00,$00,$00
                        DS.W 1
                        DC.B $00,$08,$00,$A0,$00,$02,$00,$00
                        DS.W 3
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DS.W 16
L073B:                  DS.W 2
                        DC.B $00,$01,$00,$00,$00,$00,$06,$06
                        DC.B $06,$06,$00,$01,$00,$01,$00,$00
                        DS.W 1
                        DC.B $00,$02,$00,'*',$00,$00,$00,$00
                        DS.W 3
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DS.W 16
L073C:                  DS.W 2
                        DC.B $00,$01,$00,$00,$00,$00,$07,$07
                        DC.B $07,$07,$00,$00,$00,$00,$00,$00
                        DS.W 1
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DS.W 3
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DS.W 16
L073D:                  DS.W 2
                        DC.B $00,$01,$00,$00,$00,$00,$03,$03
                        DC.B $03,$03,$00,$00,$00,$00,$00,$00
                        DS.W 1
                        DC.B $00,$02,$00,'(',$00,$00,$00,$01
                        DC.B $00,$01,$00,$00,$00,$00,$00,$02
                        DC.B $00,'*',$00,$00,$00,$00,$00,$00
                        DS.W 15
L073E:                  DS.W 2
                        DC.B $00,$04,$00,$00,$00,$00,$03,$03
                        DC.B $03,$03,$00,$00,$00,$00,$00,$00
                        DS.W 1
                        DC.B $00,$08,$00,$A0,$00,$02,$00,$00
                        DS.W 3
                        DC.B $00,$08,$00,$A0,$00,$02,$00,$00
                        DS.W 16
L073F:                  DS.W 2
                        DC.B $00,$04,$00,$00,$00,$00,$04,$04
                        DC.B $04,$04,$00,$00,$00,$00,$00,$00
                        DS.W 1
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DS.W 3
                        DC.B $00,$08,$00,$A0,$00,$02,$00,$00
                        DS.W 16
L0740:                  DC.B $FF,$FF
L0741:                  DS.W 15

zeiger_table:           DC.L jack_mouse ;Adressen der Mauspfeile (Jack Knife)
                        DC.L L0745 ;Grabber
                        DC.L L0746 ;Copy Box
                        DC.L L0748 ;Text
                        DC.L L0743
                        DC.L L0746
                        DC.L L0747 ;Fill
                        DC.L L0746 ;Cutter
                        DC.L raster_mouse ;&
                        DC.L shape_buff ;Brush
                        DC.L L0744 ;Disk+Eraser
                        DC.L animate_mouse ;Animate
                        DC.L L0746
user1_arrow:            DC.L L074A
user2_arrow:            DC.L L074A ;Pfeil bei User2
                        DC.L L074A ;Pfeil

;und jetzt die Mauszeigerdaten:
L0743:                  DS.W 2
                        DC.B $00,$01,$00,$00,$00,$01,'x',$00
                        DC.B $FC,$00,$FE,$00,$FF,$00,'',$80
                        DC.B '?',$C0,$1F,$E0,$0F,$F0,$07,$F8
                        DC.B $03,$FC,$01,$FE,$00,$FF,$00,'~'
                        DC.B $00,'<',$00,$18,$00,$00,$00,$00
                        DC.B 'x',$00,'t',$00,'b',$00,'1',$00
                        DC.B $18,$80,$0C,'@',$06,' ',$03,$10
                        DC.B $01,$88,$00,$C4,$00,'f',$00,'<'
                        DC.B $00,$18,$00,$00,$00,$00
L0744:                  DC.B $00,$05,$00,$07,$00,$01,$00,$00
                        DC.B $00,$01,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DS.W 1
                        DC.B $FF,$E0,$80,' ',$80,' ',$80,' '
                        DC.B $80,' ',$80,' ',$80,' ',$80,' '
                        DC.B $80,' ',$80,' ',$80,' ',$80,' '
                        DC.B $80,' ',$80,' ',$FF,$E0,$00,$00
L0745:                  DC.B $00,$07,$00,$07,$00,$01,$00,$00
                        DC.B $00,$01,$03,$00,$1F,$B0,'?',$F8
                        DC.B '?',$FC,'',$FE,$FF,$FE,$FF,$FE
                        DC.B '',$FF,'',$FF,$FF,$FF,$FF,$FF
                        DC.B '',$FF,'?',$FE,$0F,$FC,$01,$F8
                        DC.B $00,'0',$03,$00,$1C,$B0,'$H'
                        DC.B '"$q',$12,$98,$82,$84,$02
                        DC.B 'B',$01,'p',$01,$98,$01,$84,$01
                        DC.B '@',$00,'0',$00,$0E,$00,$01,$C0
                        DC.B $00,'0'
L0746:                  DC.B $00,$07,$00,$08,$00,$01,$00,$00
                        DC.B $00,$01,$00,$00,$00,$00,$00,$00
                        DC.B $01,$00,$01,$00,$01,$00,$01,$00
                        DC.B $01,$00,'>',$F8,$01,$00,$01,$00
                        DC.B $01,$00,$01,$00,$01,$00,$00,$00
                        DS.W 3
                        DC.B $01,$00,$02,$80,$02,$80,$02,$80
                        DC.B $02,$80,'>',$F8,'@',$04,'>',$F8
                        DC.B $02,$80,$02,$80,$02,$80,$02,$80
                        DC.B $01,$00,$00,$00
L0747:                  DC.B $00,$0E,$00,$0E,$00,$01,$00,$00
                        DC.B $00,$01,$01,$C0,$03,$F0,$07,$F8
                        DC.B $0F,$FC,$1F,$FE,'?',$FE,'',$FF
                        DC.B $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
                        DC.B '',$E7,'?',$C7,$1F,$82,$07,$07
                        DC.B $00,$02,$00,$00,$01,$C0,$03,'0'
                        DC.B $07,$08,$0C,$84,$18,'\0>'
                        DC.B '`',$1E,'@.@V`',$A6
                        DC.B '1B',$1A,$82,$07,$00,$00,$02
                        DS.W 1
L0748:                  DC.B $00,$06,$00,$0D,$00,$01,$00,$00
                        DC.B $00,$01,'',$F0,'',$F0,'',$F0
                        DC.B $07,$00,$07,$00,$07,$00,$07,$00
                        DC.B $07,$00,$07,$00,$07,$00,$07,$00
                        DC.B $07,$00,$07,$00,'',$F0,'',$F0
                        DC.B '',$F0,$00,$00,'=',$E0,$02,$00
                        DC.B $02,$00,$02,$00,$02,$00,$02,$00
                        DC.B $02,$00,$02,$00,$02,$00,$02,$00
                        DC.B $02,$00,$02,$00,$02,$00,'=',$E0
                        DS.W 1
shape_buff:             DS.W 2
                        DC.B $00,$01,$00,$00,$00,$01,$00,$00
                        DS.W 31

L074A:                  DC.W $0001,$0001
                        DC.W 1
                        DC.W 0,1
                        DC.W %1110000000000000
                        DC.W %1111000000000000
                        DC.W %1111100000000000
                        DC.W %1111110000000000
                        DC.W %1111111000000000
                        DC.W %1111111100000000
                        DC.W %1111111110000000
                        DC.W %1111111111000000
                        DC.W %1111111111000000
                        DC.W %1111111111000000
                        DC.W %1111111100000000
                        DC.W %1111111100000000
                        DC.W %1110111110000000
                        DC.W %0000111110000000
                        DC.W %0000011110000000
                        DC.W %0000011110000000

                        DC.W %0000000000000000
                        DC.W %0100000000000000
                        DC.W %0110000000000000
                        DC.W %0111000000000000
                        DC.W %0111100000000000
                        DC.W %0111110000000000
                        DC.W %0111111000000000
                        DC.W %0111111100000000
                        DC.W %0111111110000000
                        DC.W %0111110000000000
                        DC.W %0110110000000000
                        DC.W %0100011000000000
                        DC.W %0000011000000000
                        DC.W %0000001100000000
                        DC.W %0000001100000000
                        DC.W %0000000000000000

jack_mouse:             DC.W $0002,$000F ;Hot Spot
                        DC.W 1
                        DC.W 0,1
                        DC.W %0011100000000000
                        DC.W %0111110000000000
                        DC.W %1111111000000000
                        DC.W %1111111100000000
                        DC.W %1111111110000000
                        DC.W %0111111111000000
                        DC.W %0111111111100000
                        DC.W %0111111111110000
                        DC.W %0111111111111000
                        DC.W %0111111111111100
                        DC.W %0111111111111110
                        DC.W %0111111111111111
                        DC.W %0111111111111111
                        DC.W %0111110011111111
                        DC.W %0111100001111110
                        DC.W %0111000000111100

                        DC.W %0000000000000000
                        DC.W %0011100000000000
                        DC.W %0110010000000000
                        DC.W %0101001000000000
                        DC.W %0100010100000000
                        DC.W %0010101010000000
                        DC.W %0011010101000000
                        DC.W %0010101010100000
                        DC.W %0010110101010000
                        DC.W %0010011010101000
                        DC.W %0010001101010100
                        DC.W %0010010110100010
                        DC.W %0010010011001010
                        DC.W %0010100001100110
                        DC.W %0011000000111100
                        DC.W %0010000000000000

animate_mouse:          DC.W 7,8 ;Offset zum Hotspot
                        DC.W 1
                        DC.W 0,1


                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000011110000000
                        DC.W %0000011110000000
                        DC.W %0000011110000000
                        DC.W %0000011110000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000

                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000001100000000
                        DC.W %0000001100000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000

raster_mouse:           DC.W 1,8 ;Offset zum Hotspot
                        DC.W 1
                        DC.W 0,1

                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %1111111111111111
                        DC.W %1011111111111111
                        DC.W %1111111111111111
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000

                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0011111111111110
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000
                        DC.W %0000000000000000

;Welche Funktion hat welches Icon?
icon_func:              DC.B 15,7,8,9,6,10,11,91
                        DC.B 95,13,14,67
box_fill:               DC.B 19,0,0 ;vorher 18 (eraser), 12 (Nozzle)

;Welche Taste (Scancode) bewirkt Klick auf welche Koordinate?
;                       DC.B shift,scancode
;                       DC.W mkey,xkoord,ykoord
;                       DC.L routine
                        EVEN
taste_func:             DC.B 0,$17 ;'I'=Grid
                        DC.W %0000000000000101,118,145
                        DC.L return

                        DC.B 0,$2E ;'C'=Copybox
                        DC.W %0000000000000101,61,125
                        DC.L return

                        DC.B 0,$14 ;'T'=Text
                        DC.W %0000000000000101,81,125
                        DC.L return

                        DC.B 0,$26 ;'L'=Line
                        DC.W %0000000000000101,18,145
                        DC.L return

                        DC.B 0,$22 ;'G'=Grabber
                        DC.W %0000000000000101,40,126
                        DC.L return

                        DC.B 0,$21 ;'F'=Fill
                        DC.W %0000000000000101,40,145
                        DC.L return

                        DC.B 0,$19 ;'P'=Pencil
                        DC.W %0000000000000101,103,125
                        DC.L return

                        DC.B 0,$30 ;'B'=Brush
                        DC.W %0000000000000101,103,145
                        DC.L set_brush

                        DC.B 0,$1E ;'A'=Animate
                        DC.W %0000000000000101,40,167
                        DC.L return

                        DC.B 0,$31 ;'N'=Nozzle
                        DC.W %0000000000001010,103,145
                        DC.L set_nozzle

;                        DC.B 0,$12 ;'E'=Eraser
;                        DC.W %0000000000000101,81,167
;                        DC.L set_eraser

                        DC.B 0,$1F ;'S'=Shapes
                        DC.W %0000000000000101,60,167
                        DC.L return

                        DC.B 0,$24 ;'J'=Jack Knife
                        DC.W %0000000000000101,18,126
                        DC.L return

                        DC.B 0,$20 ;'D'=Disk
                        DC.W %0000000000000101,18,167
                        DC.L return

                        DC.B 0,$2D ;'X'=Cutter
                        DC.W %0000000000000101,60,145
                        DC.L return

                        DC.B 0,$13 ;'R'=Raster
                        DC.W %0000000000000101,81,145
                        DC.L return

                        DC.B 0,$32 ;'M'=Magnify on/off
                        DC.W %0000000000000000,64,191 ;ins Leere klicken
                        DC.L magnify_change

                        DC.B 4,$26 ;Ctrl+'L'=Laden
                        DC.W %0000000010000010,18,167 ;Doppelklick rechts
                        DC.L return

                        DC.B 4,$1F ;Ctrl+'S'=Speichern
                        DC.W %0000000001000001,18,167 ;Doppelklick links
                        DC.L return

                        DC.B 4,$2D ;Ctrl+'X'=Exit
                        DC.W %0000000000000000,64,191 ;ins Leere klicken
                        DC.L quit_from_board


                        DC.B 128,$01 ;Farbe 0
                        DC.W %0000000000000101,8,106
                        DC.L return

                        DC.B 0,$02 ;Farbe 1
                        DC.W %0000000000000101,28,106
                        DC.L return

                        DC.B 0,$03 ;Farbe 2
                        DC.W %0000000000000101,48,106
                        DC.L return

                        DC.B 0,$04
                        DC.W %0000000000000101,68,106
                        DC.L return

                        DC.B 0,$05
                        DC.W %0000000000000101,88,106
                        DC.L return

                        DC.B 0,$06
                        DC.W %0000000000000101,108,106
                        DC.L return

                        DC.B 0,$07
                        DC.W %0000000000000101,128,106
                        DC.L return

                        DC.B 0,$08
                        DC.W %0000000000000101,148,106
                        DC.L return

                        DC.B 0,$09
                        DC.W %0000000000000101,168,106
                        DC.L return

                        DC.B 0,$0A
                        DC.W %0000000000000101,188,106
                        DC.L return

                        DC.B 0,$0B
                        DC.W %0000000000000101,208,106
                        DC.L return

                        DC.B 0,$0C
                        DC.W %0000000000000101,228,106
                        DC.L return

                        DC.B 0,$0D
                        DC.W %0000000000000101,248,106
                        DC.L return

                        DC.B 0,$29
                        DC.W %0000000000000101,268,106
                        DC.L return

                        DC.B 0,$0E
                        DC.W %0000000000000101,288,106
                        DC.L return

                        DC.B 0,$62 ;Farbe 15
                        DC.W %0000000000000101,308,106
                        DC.L return

                        DC.B 4,$01 ;Hintergrundfarbe Ctrl+'Esc'
                        DC.W %0000000010001010,8,106
                        DC.L return

                        DC.B 4,$02 ;Hintergrundfarbe 1
                        DC.W %0000000010001010,28,106
                        DC.L return

                        DC.B 4,$03 ;Hintergrundfarbe 2
                        DC.W %0000000010001010,48,106
                        DC.L return

                        DC.B 4,$04
                        DC.W %0000000010001010,68,106
                        DC.L return

                        DC.B 4,$05
                        DC.W %0000000010001010,88,106
                        DC.L return

                        DC.B 4,$06
                        DC.W %0000000010001010,108,106
                        DC.L return

                        DC.B 4,$07
                        DC.W %0000000010001010,128,106
                        DC.L return

                        DC.B 4,$08
                        DC.W %0000000010001010,148,106
                        DC.L return

                        DC.B 4,$09
                        DC.W %0000000010001010,168,106
                        DC.L return

                        DC.B 4,$0A
                        DC.W %0000000010001010,188,106
                        DC.L return

                        DC.B 4,$0B
                        DC.W %0000000010001010,208,106
                        DC.L return

                        DC.B 4,$0C
                        DC.W %0000000010001010,228,106
                        DC.L return

                        DC.B 4,$0D
                        DC.W %0000000010001010,248,106
                        DC.L return

                        DC.B 4,$29
                        DC.W %0000000010001010,268,106
                        DC.L return

                        DC.B 4,$0E
                        DC.W %0000000010001010,288,106
                        DC.L return

                        DC.B 4,$62 ;Hintergrundfarbe 15
                        DC.W %0000000010001010,308,106
                        DC.L return

                        DC.B 0,$48 ;Cursor up und ins leere klicken
                        DC.W %0000000000000101,64,191
                        DC.L cursor_up

                        DC.B 0,$50 ;Cursor down
                        DC.W %0000000000000101,64,191
                        DC.L cursor_down

                        DC.B 0,$4B ;Cursor left
                        DC.W %0000000000000101,64,191
                        DC.L cursor_left

                        DC.B 0,$4D ;Cursor right
                        DC.W %0000000000000101,64,191
                        DC.L cursor_right

                        DC.B 0,$4E ;'+' zum LupenÑndern und ins Leere klicken
                        DC.W %0000000000000101,64,191
                        DC.L lupe_plus

                        DC.B 0,$4A ;'-' zum LupenÑndern
                        DC.W %0000000000000101,64,191
                        DC.L lupe_minus

                        DC.B 0,$33 ;',' fÅr Colorpickup
                        DC.W %0000000000000000,64,191
                        DC.L color_pickup

                        DC.B 0,$47 ;ClrHome fÅr Screen lîschen
                        DC.W %0000000000000000,64,191
                        DC.L clear_home

                        DC.W -1

                        EVEN

; 0..90
icons_offset:           DC.W 0
                        DC.B $00,$10,$00,$38,$00,$42,$00,$58
                        DC.B $01,$80,$01,$C8,$01,$A4,$01,$EC
                        DC.B $02,$10,$02,'4',$02,'X',$02,'|'
                        DC.B $02,$A0,$02,$C4,$03,'0',$00,$FC
                        DC.B $01,$80,$02,$E8,$03,$0C,$00,'n'
                        DC.B $00,$8A,$00,'|',$00,$C8,$00,$E2
                        DC.B $00,$98,$03,'T',$03,'\',$03,'f'
                        DC.B $03,'r',$03,$82,$03,$96,$03,$A0
                        DC.B $03,$AC,$03,$B8,$03,$C6,$03,$D8
                        DC.B $03,$E0,$03,$EA,$03,$F6,$04,$04
                        DC.B $04,$14,$04,$1C,$04,'&',$04,'2'
                        DC.B $04,'@',$04,'P',$04,'X',$04,'b'
                        DC.B $04,'n',$04,'|',$04,$8C,$04,$92
                        DC.B $04,$98,$04,$9E,$04,$A4,$04,$AA
                        DC.B $04,$B0,$04,$BA,$04,$C8,$04,$DA
                        DC.B $04,$F0,$05,$14,$05,'.',$05,'D'
                        DC.B $05,'d',$05,$84,$05,$A6,$05,$CA
                        DC.B $05,$FE,$05,$EE,$06,$0E,$06,'$'
                        DC.B $06,':',$06,'T',$06,$94,$06,$CC
                        DC.B $07,'$',$07,'|',$07,$D4,$08,','
                        DC.B $08,$84,$08,$DC,$09,'4',$09,$8C
                        DC.B $09,$E4,$0A,'<',$0A,'`',$0A,'h'
                        DC.B $0A,'v',$0A,$7C
                        DC.W schere_icon-icons ;Offset zur Schere
                        DC.W winkel_icon-icons ;Offset zum Winkel
                        DC.W links_icon-icons ;Links drehen bei Rotate
                        DC.W rechts_icon-icons ;Rechts drehen bei Rotate
                        DC.W rastr_icon-icons ;Raster
                        DC.W pal_icon-icons ;Mini-Palette
                        DC.W unten_icon-icons ;Pfeilspitze runter
                        DC.W oben_icon-icons ;Pfeilspitze rauf
                        DC.W hohl_icon-icons ;Hohles Dreieck fÅr Hintergrundfarbe
                        DC.W r_icon-icons ;Kleines 'R' fÅr Raster
                        DC.W undo_icon-icons ;Icon fÅr Undo
                        DC.W line_editor_icon-icons
                        DC.W box_unfill_icon-icons

;Icondaten:
icons:                  DC.B $00,$05,$00,$05,$00,$00,'|',$00
                        DC.B '|',$00,'|',$00,'|',$00,'|',$00
                        DC.B $00,$12,$00,$09,$FF,$FF,$C0,$00
                        DC.B $FF,$FF,$C0,$00,$FF,$FF,$C0,$00
                        DC.B $FF,$FF,$C0,$00,$FF,$FF,$C0,$00
                        DC.B $FF,$FF,$C0,$00,$FF,$FF,$C0,$00
                        DC.B $FF,$FF,$C0,$00,$FF,$FF,$C0,$00
                        DC.B $00,$05,$00,$03,' ',$00,'p',$00
                        DC.B $F8,$00,$00,$04,$00,$09,$F0,$00
                        DC.B $E0,$00,$C0,$00,$80,$00,$00,$00
                        DC.B $80,$00,$C0,$00,$E0,$00,$F0,$00
                        DC.B $00,$04,$00,$09,$F0,$00,'p',$00
                        DC.B '0',$00,$10,$00,$00,$00,$10,$00
                        DC.B '0',$00,'p',$00,$F0,$00,$00,$09
                        DC.B $00,$05,$08,$00,$18,$00,'?',$00
                        DC.B $18,$00,$08,$00,$00,$09,$00,$05
                        DC.B $08,$00,$0C,$00,'~',$00,$0C,$00
                        DC.B $08,$00,$00,$09,$00,$05,$14,$00
                        DC.B $14,$00,$14,$00,$14,$00,$14,$00
                        DC.B $00,$18,$00,$0B,$FF,$FF,$FF,$00
                        DC.B $FF,$FF,$FF,$00,$FF,$FF,$FF,$00
                        DC.B $FF,$FF,$FF,$00,$FF,$FF,$FF,$00
                        DC.B $FF,$FF,$FF,$00,$FF,$FF,$FF,$00
                        DC.B $FF,$FF,$FF,$00,$FF,$FF,$FF,$00
                        DC.B $FF,$FF,$FF,$00,$FF,$FF,$FF,$00
                        DC.B $00,$09,$00,$0B,$00,$00,$07,$00
                        DC.B $0F,$00,$1F,$00,'?',$00,'',$00
                        DC.B '?',$00,$1F,$00,$0F,$00,$07,$00
                        DS.W 1
                        DC.B $00,$09,$00,$0B,$00,$00,'p',$00
                        DC.B 'x',$00,'|',$00,'~',$00,'',$00
                        DC.B '~',$00,'|',$00,'x',$00,'p',$00
                        DS.W 1
                        DC.B $00,$08,$00,'@',$FF,$FF,$80,$01
                        DC.B $80,$01,$BE,$01,$84,$01,$88,$01
                        DC.B $90,$01,$BE,$01,$80,$01,$A2,$01
                        DC.B $AA,$01,$AA,'9',$BE,'E',$80,'E'
                        DC.B $A2,'E',$AA,'}',$AA,$01,$BE,$01
                        DC.B $80,$01,$92,$01,$AA,$01,$AC,$01
                        DC.B $A8,$01,$BE,$01,$80,'E',$A2,'}'
                        DC.B $A2,'E',$A2,$01,$A2,$01,$9C,$01
                        DC.B $80,$01,$A4,$01,$AA,$01,$AA,$01
                        DC.B $AA,$01,$92,'%',$80,'U',$80,'Y'
                        DC.B $80,'Q',$80,'}',$82,$01,$82,$01
                        DC.B $82,$01,$BE,$01,$80,$01,$82,$01
                        DC.B $82,$01,$82,']',$BE,'U',$80,'E'
                        DC.B $BE,'E',$82,'9',$82,$01,$82,$01
                        DC.B $BC,$01,$80,$01,$A0,$01,$A8,$01
                        DC.B $A8,$01,$A8,$01,$BE,$01,$80,$01
                        DC.B $80,$01,$FF,$FF,$00,$10,$00,$10
                        DS.W 4
                        DC.B $07,$F0,$0E,'8',$1A,',2&'
                        DC.B 'b#2&',$1A,',',$0E,'8'
                        DC.B $07,$F0,$00,$00,$00,$00,$00,$00
                        DC.B $00,$10,$00,$10,$03,$00,$1C,$B0
                        DC.B '$H"$q',$12,$98,$82
                        DC.B $84,$02,'B',$01,'p',$01,$98,$01
                        DC.B $84,$01,'@',$00,'0',$00,$0E,$00
                        DC.B $01,$C0,$00,'0',$00,$10,$00,$10
                        DC.B '',$B4,$00,$00,'x',$00,'t',$00
                        DC.B 'b',$00,'1',$00,$18,$80,$0C,'@'
                        DC.B $06,' ',$03,$10,$01,$88,$00,$C4
                        DC.B $00,'f',$00,'<',$00,$18,$00,$00
                        DC.B $00,$10,$00,$10,$00,$00,'m',$B0
                        DC.B '@',$10,$00,$00,'@',$10,'@',$10
                        DS.W 1
                        DC.B '@',$10,'@',$10,$00,$10,'@',$10
                        DC.B 'm',$EF,$00,$10,$00,$10,$00,$10
                        DC.B $00,$10,$00,$10,$00,$10,$00,$00
                        DC.B '',$FE,'@',$02,'^zbF'
                        DC.B $02,'@',$02,'@',$02,'@',$02,'@'
                        DC.B $02,'@',$02,'@',$02,'@',$06,'`'
                        DC.B $08,$10,$0F,$F0,$00,$00,$00,$10
                        DC.B $00,$10,$00,$00,'@',$00,' ',$00
                        DC.B $10,$00,$08,$00,$04,$00,$02,$00
                        DC.B $01,$10,$00,$90,$00,'P',$00,$10
                        DC.B $01,$EF,$00,$10,$00,$10,$00,$10
                        DC.B $00,$10,$00,$10,$00,$10,$00,$00
                        DC.B $01,$C0,$03,'0',$07,$08,$0C,$84
                        DC.B $18,'\0>`',$1E,'@.'
                        DC.B '@V`',$A6,'1B',$1A,$82
                        DC.B $07,$00,$00,$02,$00,$00,$00,$10
                        DC.B $00,$10,$0A,$A0,'Q',$14,$C0,'B'
                        DC.B $AF,$10,'v',$80,',',$C0,'Y '
                        DC.B 'r',$10,'a',$18,'0',$A4,$18,'N'
                        DC.B $0C,$1A,$06,'4',$03,'h',$01,$D0
                        DC.B $00,$E0,$00,$10,$00,$10,$1F,$DA
                        DC.B '*',$F0,'S`Q',$90,'H',$C0
                        DC.B $A4,'`',$92,'p',$89,$B0,$C5,'`'
                        DC.B 'b',$E0,'5',$D0,$1B,$E8,$0E,'t'
                        DC.B $00,':',$00,$1E,$00,$0C

                        DC.W 16,16 ;Icon der Diskfunktion
                        DC.W $0000,$3FFC,$4F12,$4F12,$4F12,$4F12,$4FF2,$4002
                        DC.W $4FF2,$500A,$500A,$500A,$700A,$500A,$3FFC,$0000

                        DC.W 16,16 ;Icon des Erasers
                        DC.W $0600,$0F00,$1980,$30C0,$6060,$6030,$7018,$580C
                        DC.W $4C1C,$2634,$1364,$09C8,$0490,$02A0,$01C0,$0080

                        DC.W 16,16 ;Icon der Boxes (gefÅllt)
                        DC.W $3808,$7C1C,$FE1C,$FE3E,$FE3E,$7C3E,$387F,$007F
                        DC.W $007F,$FE7F,$FE3E,$FE3E,$FE3E,$FE1C,$FE1C,$FE08

                        DC.B $00,$10,$00,$10,$00,$00,'8',$00
                        DC.B 'd',$00,'R',$00,'E',$00,'*',$80
                        DC.B '5@*',$A0,'-P&',$A8
                        DC.B '#T%',$A2,'$',$CA,'(f'
                        DC.B '0< ',$00,$00,$02,$00,$02
                        DC.B $C0,$00,$C0,$00,$00,$03,$00,$03
                        DC.B $E0,$00,$E0,$00,$E0,$00,$00,$04
                        DC.B $00,$04,$F0,$00,$F0,$00,$F0,$00
                        DC.B $F0,$00,$00,$06,$00,$06,$FC,$00
                        DC.B $FC,$00,$FC,$00,$FC,$00,$FC,$00
                        DC.B $FC,$00,$00,$08,$00,$08,$FF,$00
                        DC.B $FF,$00,$FF,$00,$FF,$00,$FF,$00
                        DC.B $FF,$00,$FF,$00,$FF,$00,$00,$03
                        DC.B $00,$03,'@',$00,$E0,$00,'@',$00
                        DC.B $00,$04,$00,$04,'`',$00,$F0,$00
                        DC.B $F0,$00,'`',$00,$00,$05,$00,$04
                        DC.B 'p',$00,$F8,$00,$F8,$00,'p',$00
                        DC.B $00,$05,$00,$05,'p',$00,$F8,$00
                        DC.B $F8,$00,$F8,$00,'p',$00,$00,$07
                        DC.B $00,$07,'8',$00,'|',$00,$FE,$00
                        DC.B $FE,$00,$FE,$00,'|',$00,'8',$00
                        DC.B $00,$02,$00,$02,'@',$00,$80,$00
                        DC.B $00,$03,$00,$03,' ',$00,'@',$00
                        DC.B $80,$00,$00,$04,$00,$04,$10,$00
                        DC.B ' ',$00,'@',$00,$80,$00,$00,$05
                        DC.B $00,$05,$08,$00,$10,$00,' ',$00
                        DC.B '@',$00,$80,$00,$00,$06,$00,$06
                        DC.B $04,$00,$08,$00,$10,$00,' ',$00
                        DC.B '@',$00,$80,$00,$00,$02,$00,$02
                        DC.B $80,$00,'@',$00,$00,$03,$00,$03
                        DC.B $80,$00,'@',$00,' ',$00,$00,$04
                        DC.B $00,$04,$80,$00,'@',$00,' ',$00
                        DC.B $10,$00,$00,$05,$00,$05,$80,$00
                        DC.B '@',$00,' ',$00,$10,$00,$08,$00
                        DC.B $00,$06,$00,$06,$80,$00,'@',$00
                        DC.B ' ',$00,$10,$00,$08,$00,$04,$00
                        DC.B $00,$01,$00,$02,$80,$00,$80,$00
                        DC.B $00,$01,$00,$03,$80,$00,$80,$00
                        DC.B $80,$00,$00,$01,$00,$04,$80,$00
                        DC.B $80,$00,$80,$00,$80,$00,$00,$01
                        DC.B $00,$05,$80,$00,$80,$00,$80,$00
                        DC.B $80,$00,$80,$00,$00,$01,$00,$06
                        DC.B $80,$00,$80,$00,$80,$00,$80,$00
                        DC.B $80,$00,$80,$00,$00,$02,$00,$01
                        DC.B $C0,$00,$00,$03,$00,$01,$E0,$00
                        DC.B $00,$04,$00,$01,$F0,$00,$00,$05
                        DC.B $00,$01,$F8,$00,$00,$06,$00,$01
                        DC.B $FC,$00,$00,$01,$00,$01,$80,$00
                        DC.B $00,$03,$00,$03,$A0,$00,'@',$00
                        DC.B $A0,$00,$00,$05,$00,$05,' ',$00
                        DS.W 1
                        DC.B $A8,$00,$00,$00,' ',$00,$00,$07
                        DC.B $00,$07,'(',$00,'T',$00,$AA,$00
                        DC.B 'T',$00,$AA,$00,'T',$00,'(',$00
                        DC.B $00,$07,$00,$09,$10,$00,$00,$00
                        DC.B $A2,$00,$08,$00,'P',$00,$08,$00
                        DC.B $92,$00,$00,$00,$10,$00,$00,$10
                        DC.B $00,$10,$01,$00,$10,$10,$00,$80
                        DC.B $04,$00,$80,'"',$02,$00,' ',$88
                        DC.B $04,' ',$90,$01,$01,$08,$08,'@'
                        DC.B 'B',$02,$00,' ',$11,$00,$00,$10
                        DC.B $02,$00,$00,$0D,$00,$0B,$02,$00
                        DC.B $08,$80,'" ',$88,$88,'" '
                        DC.B $88,$88,'" ',$88,$88,'" '
                        DC.B $08,$80,$02,$00,$00,$09,$00,$09
                        DC.B '*',$00,$00,$00,$AA,$80,$00,$00
                        DC.B $AA,$80,$00,$00,$AA,$80,$00,$00
                        DC.B '*',$00,$00,$0A,$00,$0E,$DD,$00
                        DC.B $81,$00,$01,$00,$80,$C0,$81,$C0
                        DC.B $81,$C0,$01,$C0,$80,$C0,$81,$C0
                        DC.B $81,$C0,$01,$C0,$EE,$C0,$1F,$C0
                        DC.B $1F,$C0,$00,$0A,$00,$0E,$DD,$00
                        DC.B $81,$00,$01,$00,$9E,$C0,$9F,$C0
                        DC.B $9F,$C0,$1F,$C0,$9E,$C0,$9F,$C0
                        DC.B $9F,$C0,$1F,$C0,$EE,$C0,$1F,$C0
                        DC.B $1F,$C0,$00,$0B,$00,$0F,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$FF,$E0,$FF,$E0
                        DC.B $FF,$E0,$FF,$E0,$00,$10,$00,$10
                        DC.B $01,$80,$03,$C0,$07,$E0,$07,$E0
                        DC.B $03,$D8,$01,$BC,'g',$FE,'',$FE
                        DC.B '',$BC,'g',$98,$03,$00,$04,$80
                        DC.B $04,$80,$08,'@',$08,'@',$00,$00
                        DC.B $00,$10,$00,$10,$00,$00,$07,$80
                        DC.B $0C,$C0,$18,'`',$18,'`',$0C,$C0
                        DC.B $07,$80,$0E,$00,$19,$9E,'0',$CC
                        DC.B '0h008x',$1F,$DC
                        DC.B $0F,$8E,$00,$00,$00,$05,$00,$06
                        DC.B ' ',$00,' ',$00,' ',$00,$F8,$00
                        DC.B 'p',$00,' ',$00,$00,$05,$00,$06
                        DC.B ' ',$00,'p',$00,$F8,$00,' ',$00
                        DC.B ' ',$00,' ',$00,$00,$05,$00,$09
                        DC.B $08,$00,$10,$00,' ',$00,'@',$00
                        DC.B $80,$00,'@',$00,' ',$00,$10,$00
                        DC.B $08,$00,$00,$05,$00,$09,$80,$00
                        DC.B '@',$00,' ',$00,$10,$00,$08,$00
                        DC.B $10,$00,' ',$00,'@',$00,$80,$00
                        DC.B $00,$0B,$00,$0B,$DB,$00,$81,$00
                        DS.W 1
                        DC.B $81,$00,$81,$00,$00,$00,$81,$00
                        DC.B $DA,$E0,$01,$00,$01,$00,$01,$00
                        DC.B $00,$14,$00,$0F,$00,'|',$00,$00
                        DC.B $01,$82,$80,$00,$02,$01,$80,$00
                        DC.B $04,$03,$80,$00,$00,$00,$00,$00
                        DC.B '=',$FB,$C0,$00,'}',$FB,$E0,$00
                        DC.B $FD,$FB,$F0,$00,'}',$FB,$E0,$00
                        DC.B '=',$FB,$C0,$00,$00,$00,$00,$00
                        DC.B $1C,$02,$00,$00,$18,$04,$00,$00
                        DC.B $14,$10,$00,$00,$01,'@',$00,$00
                        DC.B $00,$14,$00,$0D,$EE,$EE,$C0,$00
                        DS.W 2
                        DC.B $8F,$FC,'@',$00,$1E,$00,$00,$00
                        DC.B $8F,$FC,'@',$00,$00,$1E,$00,$00
                        DC.B $80,$1E,'@',$00,$00,$1E,$00,$00
                        DC.B $8F,$FC,'@',$00,$80,$00,'P',$00
                        DC.B $DD,$DD,$D0,$00,$00,$00,'0',$00
                        DS.W 1
                        DC.B $F0,$00,$00,$14,$00,$15,$00,$00
                        DS.W 5
                        DC.B $0F,$FF,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $0F,$FF,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $03,$FC,$00,$00,$06,$06,$00,$00
                        DC.B $0C,$03,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $0C,$03,$00,$00,$06,$06,$00,$00
                        DC.B $03,$FC,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$F0,$00,$00,$03,$0C,$00,$00
                        DC.B $04,$02,$00,$00,$08,$01,$00,$00
                        DC.B $08,$01,$00,$00,$10,$00,$80,$00
                        DC.B $10,$00,$80,$00,$10,$00,$80,$00
                        DC.B $10,$00,$80,$00,$10,$00,$80,$00
                        DC.B $08,$01,$00,$00,$08,$01,$00,$00
                        DC.B $04,$02,$00,$00,$03,$0C,$00,$00
                        DC.B $00,$F0,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,'x',$00,$00,$01,$84,$00,$00
                        DC.B $02,$02,$00,$00,$04,$02,$00,$00
                        DC.B $08,$0C,$00,$00,$08,$10,$00,$00
                        DC.B $10,$10,$00,$00,$10,$08,$00,$00
                        DC.B $10,$06,$00,$00,$10,$01,$00,$00
                        DC.B $08,$00,$80,$00,$08,$00,$80,$00
                        DC.B $04,$01,$00,$00,$03,$86,$00,$00
                        DC.B $00,'x',$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B '?',$F8,$00,$00,$10,$04,$00,$00
                        DC.B $08,$02,$00,$00,$04,$01,$00,$00
                        DC.B $02,$02,$00,$00,$04,$04,$00,$00
                        DC.B $08,$08,$00,$00,$10,$10,$00,$00
                        DC.B ' ',$08,$00,$00,$10,$04,$00,$00
                        DC.B $08,$02,$00,$00,$04,$01,$00,$00
                        DC.B $02,$00,$80,$00,$01,$FF,$C0,$00
                        DS.W 8
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $0F,$FF,$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0F,$FF,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $03,$FC,$00,$00,$06,$AA,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$0A,$AB,$00,$00
                        DC.B $0D,'U',$00,$00,$06,$AA,$00,$00
                        DC.B $03,$FC,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$F0,$00,$00,$03,'\',$00,$00
                        DC.B $06,$AA,$00,$00,$0D,'U',$00,$00
                        DC.B $0A,$AB,$00,$00,$15,'U',$80,$00
                        DC.B $1A,$AA,$80,$00,$15,'U',$80,$00
                        DC.B $1A,$AA,$80,$00,$15,'U',$80,$00
                        DC.B $0A,$AB,$00,$00,$0D,'U',$00,$00
                        DC.B $06,$AA,$00,$00,$03,'\',$00,$00
                        DC.B $00,$F0,$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,'x',$00,$00,$01,$D4,$00,$00
                        DC.B $02,$AA,$00,$00,$05,'V',$00,$00
                        DC.B $0A,$AC,$00,$00,$0D,'P',$00,$00
                        DC.B $1A,$B0,$00,$00,$15,'X',$00,$00
                        DC.B $1A,$AE,$00,$00,$15,'U',$00,$00
                        DC.B $0A,$AA,$80,$00,$0D,'U',$80,$00
                        DC.B $06,$AB,$00,$00,$03,$D6,$00,$00
                        DC.B $00,'x',$00,$00,$00,$00,$00,$00
                        DS.W 4
                        DC.B $00,$14,$00,$15,$00,$00,$00,$00
                        DS.W 4
                        DC.B '?',$F8,$00,$00,$15,'T',$00,$00
                        DC.B $0A,$AA,$00,$00,$05,'U',$00,$00
                        DC.B $02,$AA,$00,$00,$05,'T',$00,$00
                        DC.B $0A,$A8,$00,$00,$15,'P',$00,$00
                        DC.B '*',$A8,$00,$00,$15,'T',$00,$00
                        DC.B $0A,$AA,$00,$00,$05,'U',$00,$00
                        DC.B $02,$AA,$80,$00,$01,$FF,$C0,$00
                        DS.W 8
                        DC.B $00,$10,$00,$10,$0C,$00,'3',$00
                        DC.B '@',$80,$80,'@',$80,'@',$80,'_'
                        DC.B '@',$91,'3',$11,$0C,$11,$00,$11
                        DC.B '?',$91,'A',$11,$82,$11,'A',$1F
                        DC.B ' ',$80,$1F,$C0,$00,$13,$00,$01
                        DC.B $AA,$AA,$A0,$00,$00,$0E,$00,$05
                        DC.B $F9,'8',$83,'L',$F1,'T',$81,'d'
                        DC.B $81,'8',$00,$01,$00,$01,$00,$00
                        DC.B $00,$10,$00,$14,'a',$86,$92,'I'
                        DC.B $F3,$CF,$92,'I',$92,'I',$92,'I'
                        DC.B $92,'I',$92,'I',$92,'I',$92,'I'
                        DC.B $92,'I',$92,'I',$93,$C9,$94,'I'
                        DC.B $98,'I',$9F,$C9,$80,$09,$80,$0A
                        DC.B $80,$0C,$FF,$F8

schere_icon:            DC.W 16,16 ;Breite,Hîhe der Schere
                        DC.W $0000,$0000,$3806,$1C0C,$0E18,$0730,$0360,$01C0
                        DC.W $0140,$03E0,$0E38,$1A2C,$3636,$2C1A,$380E,$0000

winkel_icon:            DC.W 11,7 ;Breite, Hîhe des Winkels
                        DC.W $1300,$0C00,$3820,$C400,$3820,$0C00,$1300

links_icon:             DC.W 4,7 ;Breite, Hîhe, links rum
                        DC.W $E000,$C000,$A000,$1000,$1000,$2000,$C000

rechts_icon:            DC.W 4,7 ;Breite, Hîhe, rechts rum
                        DC.W $C000,$2000,$1000,$1000,$A000,$C000,$E000

rastr_icon:             DC.W 16,16 ;Breite, Hîhe
                        DC.W $0000,$7FFE,$4002,$4002,$7FFE,$4002,$4002,$4002
                        DC.W $4002,$4002,$7FFE,$4002,$7FFE,$4002,$7FFE,$0000

pal_icon:               DC.W 59,3
                        DC.W $77BD,$EF7B,$DEF7,$B9E0,$F7BD,$EF7B,$DEF7,$BDE0
                        DC.W $77BD,$EF7B,$DEF7,$B9E0

unten_icon:             DC.W 9,5
                        DC.W $8080,$4100,$2200,$1400,$0800

oben_icon:              DC.W 9,5
                        DC.W $0800,$1400,$2200,$4100,$8080

hohl_icon:              DC.W 5,3
                        DC.W $2000,$5000,$8800

r_icon:                 DC.W 3,4
                        DC.W $C000,$A000,$C000,$A000

undo_icon:              DC.W 36,15
                        DC.W $FFFF,$FFFF,$F000,$8000,$0000,$1000,$822C,$5E38
                        DC.W $1000,$822A,$5144,$1000,$8229,$5144,$1000,$81E8
                        DC.W $DE38,$1000,$8000,$0000,$1000,$FFFF,$FFFF,$F000
                        DC.W $8000,$0000,$1000,$879C,$41CF,$1000,$8822,$4228
                        DC.W $9000,$8822,$422F,$1000,$879C,$79C8,$9000,$8000
                        DC.W $0000,$1000,$FFFF,$FFFF,$F000

*    pixels/scanline    = $0051 (bytes/scanline: $000C)
*  # scanlines (height) = $0006
line_editor_icon:       DC.W 81,6
                        DC.W $7BDE,$F7BD,$EF7B,$DEF7,$BDEF,$0000,$8421,$0842
                        DC.W $1084,$2108,$4210,$8000,$8421,$0842,$1084,$2108
                        DC.W $4210,$8000,$8421,$0842,$1084,$2108,$4210,$8000
                        DC.W $8421,$0842,$1084,$2108,$4210,$8000,$7BDE,$F7BD
                        DC.W $EF7B,$DEF7,$BDEF,$0000

*    pixels/scanline    = $0010 (bytes/scanline: $0002)
*  # scanlines (height) = $0010
box_unfill_icon:        DC.W 16,16
                        DC.W $3808,$4414,$8214,$8222,$8222,$4422,$3841,$0041
                        DC.W $0041,$FE41,$8222,$8222,$8222,$8214,$8214,$FE08

df_logo:
*
*  NEOchrome V2.22 cut buffer contents (left justified):
*  by Chaos, Inc. of the Delta Force (member of The Union)
*
*    pixels/scanline    = $0080 (bytes/scanline: $0040)
*  # scanlines (height) = $003C
*
*  Hardware color pallet  (color 0 to 15):
*
*      $0000,$0700,$0730,$0750,$0770,$0470,$0070,$0075
*      $0077,$0057,$0027,$0007,$0507,$0707,$0704,$0777
*
*
                        DC.W $0001,$0001,$0001,$0001,$F3E3,$F3E3,$F3E3,$F3E3
                        DC.W $CCCF,$CCCF,$CCCF,$CCCF,$B37E,$B37E,$B37E,$B37E
                        DC.W $01F9,$01F9,$01F9,$01F9,$E00C,$E00C,$E00C,$E00C
                        DC.W $CF33,$CF33,$CF33,$CF33,$0000,$0000,$0000,$0000
                        DC.W $0001,$0001,$0001,$0001,$9B36,$9B36,$9B36,$9B36
                        DC.W $6CD8,$6CD8,$6CD8,$6CD8,$3318,$3318,$3318,$3318
                        DC.W $0063,$0063,$0063,$0063,$300C,$300C,$300C,$300C
                        DC.W $D9B3,$D9B3,$D9B3,$D9B3,$0000,$0000,$0000,$0000
                        DC.W $0001,$0001,$0001,$0001,$F3E6,$F3E6,$F3E6,$F3E6
                        DC.W $6CDB,$6CDB,$6CDB,$6CDB,$BF18,$BF18,$BF18,$BF18
                        DC.W $0063,$0063,$0063,$0063,$3007,$3007,$3007,$3007
                        DC.W $99B3,$99B3,$99B3,$99B3,$0000,$0000,$0000,$0000
                        DC.W $0001,$0001,$0001,$0001,$9B66,$9B66,$9B66,$9B66
                        DC.W $6CD9,$6CD9,$6CD9,$6CD9,$B318,$B318,$B318,$B318
                        DC.W $0063,$0063,$0063,$0063,$3003,$3003,$3003,$3003
                        DC.W $19B3,$19B3,$19B3,$19B3,$0000,$0000,$0000,$0000
                        DC.W $0001,$0001,$0001,$0001,$F333,$F333,$F333,$F333
                        DC.W $C7CF,$C7CF,$C7CF,$C7CF,$B318,$B318,$B318,$B318
                        DC.W $0061,$0061,$0061,$0061,$E003,$E003,$E003,$E003
                        DC.W $0F1F,$0F1F,$0F1F,$0F1F,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$00F9,$00F9,$00F9,$00F9
                        DC.W $9800,$9800,$9800,$9800,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$00CD,$00CD,$00CD,$00CD
                        DC.W $9800,$9800,$9800,$9800,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$00F8,$00F8,$00F8,$00F8
                        DC.W $F000,$F000,$F000,$F000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$00CC,$00CC,$00CC,$00CC
                        DC.W $6000,$6000,$6000,$6000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$00F8,$00F8,$00F8,$00F8
                        DC.W $6000,$6000,$6000,$6000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0FFF,$0FFF,$0FFF
                        DC.W $0000,$83FF,$83FF,$83FF,$0000,$FFDF,$FFDF,$FFDF
                        DC.W $0000,$FFFB,$FFFB,$FFFB,$0000,$C000,$C000,$C000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$07FF,$0800,$0800,$0800
                        DC.W $01FF,$E200,$E200,$E200,$EF8F,$1070,$1070,$1070
                        DC.W $FFF1,$000E,$000E,$000E,$8000,$4000,$4000,$4000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$03FF,$0C00,$0C00,$0C00
                        DC.W $C1FF,$3200,$3200,$3200,$EF9F,$1060,$1060,$1060
                        DC.W $FFF3,$000C,$000C,$000C,$8000,$6000,$6000,$6000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$01F3,$060C,$060C,$060C
                        DC.W $E1E1,$161E,$161E,$161E,$CF9C,$3063,$3063,$3063
                        DC.W $7CE7,$8318,$8318,$8318,$C000,$2000,$2000,$2000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$01F1,$020E,$020E,$020E
                        DC.W $E3E0,$1C13,$1C13,$1C13,$1F00,$E0FF,$E0FF,$E0FF
                        DC.W $F80F,$07F0,$07F0,$07F0,$C000,$2000,$2000,$2000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$01F0,$060B,$060B,$060B
                        DC.W $F3C0,$0C30,$0C30,$0C30,$1F00,$2081,$2081,$2081
                        DC.W $F80F,$0430,$0430,$0430,$C000,$3000,$3000,$3000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$03E0,$0419,$0419,$0419
                        DC.W $F3C0,$0C3F,$0C3F,$0C3F,$1E00,$6183,$6183,$6183
                        DC.W $F81F,$0460,$0460,$0460,$E000,$1000,$1000,$1000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$03E0,$0411,$0411,$0411
                        DC.W $F7FE,$0801,$0801,$0801,$3E01,$4102,$4102,$4102
                        DC.W $F03D,$0CC2,$0CC2,$0CC2,$E000,$1000,$1000,$1000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$03E0,$0C13,$0C13,$0C13
                        DC.W $F7FE,$0801,$0801,$0801,$3E01,$4102,$4102,$4102
                        DC.W $F078,$0887,$0887,$0887,$E000,$1800,$1800,$1800
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$07C1,$0832,$0832,$0832
                        DC.W $E780,$187F,$187F,$187F,$3C01,$C306,$C306,$C306
                        DC.W $F078,$0987,$0987,$0987,$F000,$0800,$0800,$0800
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$07C1,$0826,$0826,$0826
                        DC.W $EF80,$1040,$1040,$1040,$7C03,$8204,$8204,$8204
                        DC.W $E0FF,$1B00,$1B00,$1B00,$F000,$0800,$0800,$0800
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$07C3,$1824,$1824,$1824
                        DC.W $EF00,$10C0,$10C0,$10C0,$7C03,$8204,$8204,$8204
                        DC.W $E1FF,$1600,$1600,$1600,$F000,$0C00,$0C00,$0C00
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0F83,$106C,$106C,$106C
                        DC.W $CF00,$309F,$309F,$309F,$7803,$86FC,$86FC,$86FC
                        DC.W $E3C0,$143F,$143F,$143F,$7800,$8400,$8400,$8400
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0F87,$1058,$1058,$1058
                        DC.W $DF0E,$20F1,$20F1,$20F1,$F877,$0788,$0788,$0788
                        DC.W $C3C0,$3C30,$3C30,$3C30,$3800,$C400,$C400,$C400
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0F8F,$3070,$3070,$3070
                        DC.W $9FFE,$6001,$6001,$6001,$FFF7,$0008,$0008,$0008
                        DC.W $C780,$3860,$3860,$3860,$3800,$4600,$4600,$4600
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$1FFF,$2000,$2000,$2000
                        DC.W $1FFE,$E001,$E001,$E001,$FFF7,$0008,$0008,$0008
                        DC.W $CF00,$30C0,$30C0,$30C0,$3C00,$4200,$4200,$4200
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$1FFC,$2003,$2003,$2003
                        DC.W $0000,$BFFF,$BFFF,$BFFF,$0000,$FFFF,$FFFF,$FFFF
                        DC.W $0000,$FF80,$FF80,$FF80,$1C00,$6200,$6200,$6200
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$3FFE,$3FFE,$3FFE
                        DC.W $0000,$003F,$003F,$003F,$0000,$FF9F,$FF9F,$FF9F
                        DC.W $0000,$C3FF,$C3FF,$C3FF,$1C00,$E3FF,$E3FF,$E3FF
                        DC.W $0000,$FFFF,$FFFF,$FFFF,$0000,$C000,$C000,$C000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001F,$0020,$0020,$0020,$FF0F,$00F0,$00F0,$00F0
                        DC.W $81FF,$7200,$7200,$7200,$807F,$7F80,$7F80,$7F80
                        DC.W $EFFF,$1000,$1000,$1000,$8000,$4000,$4000,$4000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0030,$0030,$0030,$FF3F,$00C0,$00C0,$00C0
                        DC.W $E0FF,$1B00,$1B00,$1B00,$C1FF,$3600,$3600,$3600
                        DC.W $EFFF,$1000,$1000,$1000,$8000,$4000,$4000,$4000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0007,$0018,$0018,$0018,$E37C,$1C83,$1C83,$1C83
                        DC.W $F0F3,$090C,$090C,$090C,$E3FF,$1C00,$1C00,$1C00
                        DC.W $CF87,$3078,$3078,$3078,$0000,$C000,$C000,$C000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0007,$0008,$0008,$0008,$C0FC,$3703,$3703,$3703
                        DC.W $F0F1,$0F0E,$0F0E,$0F0E,$E7F1,$180E,$180E,$180E
                        DC.W $DF80,$204F,$204F,$204F,$0000,$8000,$8000,$8000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0007,$0008,$0008,$0008,$C0FC,$2303,$2303,$2303
                        DC.W $F9E1,$061E,$061E,$061E,$EFC0,$103B,$103B,$103B
                        DC.W $1F00,$E0C0,$E0C0,$E0C0,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0007,$0018,$0018,$0018,$C1F9,$2206,$2206,$2206
                        DC.W $F9E3,$061C,$061C,$061C,$EF80,$1060,$1060,$1060
                        DC.W $1F00,$60FC,$60FC,$60FC,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0010,$0010,$0010,$81F9,$7E06,$7E06,$7E06
                        DC.W $F9FF,$0600,$0600,$0600,$DF80,$2040,$2040,$2040
                        DC.W $3FF8,$4004,$4004,$4004,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0010,$0010,$0010,$FBF9,$0406,$0406,$0406
                        DC.W $FBFF,$0400,$0400,$0400,$9F00,$60C0,$60C0,$60C0
                        DC.W $3FF8,$4004,$4004,$4004,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0030,$0030,$0030,$FBF3,$040C,$040C,$040C
                        DC.W $FBFF,$0400,$0400,$0400,$1F00,$E080,$E080,$E080
                        DC.W $3E00,$C1FC,$C1FC,$C1FC,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001F,$0020,$0020,$0020,$03F3,$FC0C,$FC0C,$FC0C
                        DC.W $F3C7,$0C38,$0C38,$0C38,$9F00,$60C0,$60C0,$60C0
                        DC.W $7E00,$8100,$8100,$8100,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001F,$0020,$0020,$0020,$03F3,$840C,$840C,$840C
                        DC.W $F787,$0868,$0868,$0868,$9F80,$607F,$607F,$607F
                        DC.W $7C00,$8300,$8300,$8300,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001F,$0060,$0060,$0060,$03E7,$8418,$8418,$8418
                        DC.W $E783,$184C,$184C,$184C,$CFCE,$3031,$3031,$3031
                        DC.W $7C00,$827C,$827C,$827C,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $003E,$0041,$0041,$0041,$01E7,$8618,$8618,$8618
                        DC.W $E783,$1844,$1844,$1844,$CFFE,$3001,$3001,$3001
                        DC.W $FC38,$03C4,$03C4,$03C4,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $003E,$0041,$0041,$0041,$01E7,$0218,$0218,$0218
                        DC.W $CF01,$30C6,$30C6,$30C6,$E7FE,$1801,$1801,$1801
                        DC.W $FFF8,$0004,$0004,$0004,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $003E,$00C1,$00C1,$00C1,$00FF,$0300,$0300,$0300
                        DC.W $8F01,$7082,$7082,$7082,$E1FE,$1E01,$1E01,$1E01
                        DC.W $FFF8,$0004,$0004,$0004,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $007C,$0083,$0083,$0083,$003E,$01C1,$01C1,$01C1
                        DC.W $0000,$DF83,$DF83,$DF83,$0000,$F3FF,$F3FF,$F3FF
                        DC.W $0000,$FFFC,$FFFC,$FFFC,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $007C,$0082,$0082,$0082,$0000,$007F,$007F,$007F
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $007C,$0182,$0182,$0182,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $00F8,$0106,$0106,$0106,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $00F8,$0104,$0104,$0104,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $00F0,$030C,$030C,$030C,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $01C0,$0238,$0238,$0238,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0100,$02E0,$02E0,$02E0,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0380,$0380,$0380,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000


neo_logo:
*
*  NEOchrome V2.22 cut buffer contents (left justified):
*  by Chaos, Inc. of the Delta Force (member of The Union)
*
*    pixels/scanline    = $0080 (bytes/scanline: $0040)
*  # scanlines (height) = $003C
*
*  Hardware color pallet  (color 0 to 15):
*
*      $0000,$0700,$0730,$0750,$0770,$0470,$0070,$0075
*      $0077,$0057,$0027,$0007,$0507,$0707,$0704,$0777
*
*
                        DC.W $03F3,$0000,$03F3,$03F3,$FFFF,$0000,$FFFF,$FFFF
                        DC.W $DFF0,$0000,$DFF0,$DFF0,$003F,$0000,$003F,$003F
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FB,$0000,$021A,$021A,$FFFF,$0000,$0000,$0000
                        DC.W $FFFC,$0000,$701C,$701C,$003F,$0000,$0020,$0020
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$00C0,$020E,$02CE,$FF55,$E6EE,$0111,$E6EE
                        DC.W $FDFE,$0640,$4106,$46C6,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$0040,$02A6,$0246,$FFD5,$446E,$A3BB,$4444
                        DC.W $F57E,$0EE0,$1BB2,$0442,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$00E0,$0212,$02E2,$FF55,$E6EE,$0111,$E6EE
                        DC.W $D5FE,$2E40,$1112,$2EEA,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03BF,$0040,$02B8,$0240,$BBFF,$4400,$A300,$4400
                        DC.W $D3BE,$2C68,$383A,$0442,$0031,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03AB,$00FC,$0210,$02EC,$BAFF,$E700,$017F,$E67F
                        DC.W $C7EE,$3810,$9112,$A92A,$0031,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03AB,$0054,$02BA,$0244,$BAFF,$4500,$A300,$4400
                        DC.W $C7EE,$3838,$BBBA,$8382,$FFB1,$0004,$FFA0,$FFAE
                        DC.W $FFFF,$0000,$FFFF,$FFFF,$C7FD,$0000,$C7FD,$C7FD
                        DC.W $FFFE,$0000,$FFFE,$FFFE,$7FC0,$0000,$7FC0,$7FC0
                        DC.W $02EE,$01BB,$0201,$02EE,$E644,$BBBB,$0110,$E6EE
                        DC.W $82AB,$7C54,$9293,$AAAB,$80E4,$7F11,$80E0,$80EE
                        DC.W $0300,$FCFF,$0300,$0300,$7C07,$83F8,$7C07,$7C07
                        DC.W $0003,$FFFC,$0003,$0003,$C070,$3F80,$C070,$C070
                        DC.W $02E6,$0119,$02A3,$0244,$E6C4,$193B,$A3BA,$4444
                        DC.W $82AA,$7C7D,$BABA,$8282,$2E24,$FBD1,$3A20,$042E
                        DC.W $4146,$1699,$1111,$E966,$10E1,$EF1E,$1111,$10E1
                        DC.W $4009,$BFFE,$1111,$6289,$1B18,$EEE0,$0418,$1B18
                        DC.W $02E3,$01BF,$0201,$02E2,$E754,$BBBB,$0110,$E6EE
                        DC.W $92B8,$7C57,$9290,$AAA8,$FF05,$1171,$1101,$EE8E
                        DC.W $547F,$13BB,$103B,$EC44,$C7D4,$BBBB,$83B8,$4444
                        DC.W $555C,$BBB3,$3BB8,$4444,$7FC8,$C470,$6EC8,$1108
                        DC.W $02A9,$0117,$02A9,$0248,$A300,$19FF,$A300,$4400
                        DC.W $92B9,$7C7F,$BAB9,$8280,$BB81,$BBB1,$BB81,$444E
                        DC.W $101B,$1191,$1011,$EE6E,$ABB0,$111B,$0110,$EEEE
                        DC.W $1118,$BBBB,$1110,$6EEC,$EEE8,$EEF0,$4448,$BBA8
                        DC.W $02AC,$01B3,$020C,$02EC,$A37F,$BB80,$017F,$E67F
                        DC.W $92B9,$7C57,$9291,$AAA8,$A301,$1D31,$0101,$E2CE
                        DC.W $1038,$F1BF,$1038,$0E40,$AB10,$BBFB,$AB1A,$4404
                        DC.W $1118,$BFF3,$3398,$4004,$E0E8,$4E50,$E0E8,$1108
                        DC.W $02AE,$0111,$02AE,$024E,$A340,$1980,$A340,$4440
                        DC.W $92B9,$7C7F,$BAB9,$8280,$8980,$B7B1,$8980,$484E
                        DC.W $4012,$B19D,$4012,$4E62,$0A40,$F1BB,$0040,$0E4E
                        DC.W $1118,$BFFB,$1110,$628C,$E4E8,$FBF0,$4448,$A4A8
                        DC.W $00A0,$01B1,$020A,$02EA,$A200,$BA80,$0040,$E740
                        DC.W $0028,$6C46,$8280,$BAB9,$8000,$2231,$1C00,$DDCE
                        DC.W $0020,$11A8,$E027,$EE57,$0A00,$1B1B,$EAEA,$E4E4
                        DC.W $0008,$AEE3,$2288,$5114,$A0A0,$1F10,$A0A8,$4048
                        DC.W $01F1,$0151,$02EA,$020A,$FE80,$5C80,$E640,$0140
                        DC.W $446E,$6C6E,$AAA8,$9291,$E3F5,$E3F5,$D404,$140A
                        DC.W $15C8,$15C8,$A444,$AA34,$1F15,$151F,$24A4,$2AAA
                        DC.W $CC6F,$EEEF,$4004,$3398,$BBB0,$BBB0,$1108,$EEE8
                        DC.W $01F1,$01F1,$024A,$02AA,$FE80,$FE80,$4440,$A340
                        DC.W $446E,$6C46,$8280,$BAB9,$E015,$6015,$57E4,$97EA
                        DC.W $15E8,$15E8,$A464,$AA14,$1F15,$1F1F,$2EAE,$20A0
                        DC.W $CC6F,$EEE7,$628C,$1110,$BBB0,$1110,$BBA8,$4448
                        DC.W $01F1,$0151,$02EA,$020A,$FE80,$5C80,$E640,$0140
                        DC.W $446E,$6C6E,$AAA8,$9291,$E015,$E015,$D024,$102A
                        DC.W $15C8,$15C8,$A444,$AA34,$1F15,$151F,$24A4,$2AAA
                        DC.W $CC6F,$EEEF,$4004,$3398,$BBB0,$BBB0,$1108,$EEE8
                        DC.W $01F1,$01F1,$024A,$02AA,$FF80,$FE80,$4440,$A340
                        DC.W $547F,$6C46,$8280,$BAB9,$E015,$6015,$5024,$902A
                        DC.W $15F8,$15E8,$A464,$AA14,$1F15,$1F1F,$2EAE,$20A0
                        DC.W $DD7F,$EEE7,$628C,$1110,$FFF0,$1FF0,$A008,$4008
                        DC.W $01B1,$0151,$02EA,$020A,$BB80,$5C80,$E640,$0140
                        DC.W $547F,$6C6E,$AAA8,$9291,$A011,$E015,$D024,$102A
                        DC.W $1198,$15C8,$A444,$AA34,$1B11,$151F,$24A4,$2AAA
                        DC.W $9D7B,$EEEF,$4004,$3398,$F000,$B000,$0FF8,$EFF8
                        DC.W $01B1,$01F1,$024A,$02AA,$BB80,$FE80,$4440,$A340
                        DC.W $547F,$6C46,$8280,$BAB9,$A011,$6015,$5024,$902A
                        DC.W $11B8,$15E8,$A464,$AA14,$1B11,$1F1F,$2EAE,$20A0
                        DC.W $9D7B,$EEE7,$628C,$1110,$F000,$1000,$A800,$4800
                        DC.W $03BB,$035B,$00E0,$020A,$BAC0,$5DC0,$E600,$0140
                        DC.W $C7EE,$FFFF,$2828,$9391,$B831,$F835,$C004,$182A
                        DC.W $B18C,$B5DC,$0440,$AA34,$3BF1,$35FF,$0404,$2AEA
                        DC.W $8C6B,$FFFF,$4004,$3398,$BC00,$FC00,$0000,$EC00
                        DC.W $02AA,$02EA,$0151,$02AA,$A27F,$E77F,$5C80,$A37F
                        DC.W $8128,$B911,$46C6,$B939,$8FE0,$4FE4,$7015,$8FEA
                        DC.W $A024,$A474,$15E8,$AA14,$2A40,$2E4E,$1FBF,$2040
                        DC.W $0008,$7394,$EEEF,$1110,$A7FC,$47FC,$B800,$47FC
                        DC.W $02EA,$020A,$01F1,$020A,$E600,$0100,$FEFF,$0100
                        DC.W $0468,$3839,$EFEE,$1011,$E004,$A000,$FFF5,$000A
                        DC.W $A444,$A014,$15C8,$AA34,$2E04,$211A,$14E5,$2B1A
                        DC.W $400C,$3398,$CC67,$3398,$B004,$E004,$1FF8,$E004
                        DC.W $02EA,$02AA,$0151,$02AA,$E755,$A3BB,$5C44,$A3BB
                        DC.W $15F9,$3B11,$C446,$3BB9,$FF44,$1100,$4475,$BB8A
                        DC.W $A474,$A034,$15E8,$AA14,$2FD4,$2BBA,$1EEF,$2110
                        DC.W $511C,$3390,$EEEF,$1110,$FFF4,$4444,$BBB8,$4444
                        DC.W $02EA,$020A,$01F1,$020A,$E7D5,$013B,$FEEE,$0111
                        DC.W $1570,$1BB0,$EEEF,$1110,$FFC4,$BB80,$EEF5,$110A
                        DC.W $A454,$A014,$15C8,$AA34,$27F4,$2118,$1C47,$23B8
                        DC.W $511C,$3398,$CC67,$3398,$7FF4,$6EE4,$9118,$6EE4
                        DC.W $02EA,$02AA,$0151,$02AA,$E755,$A3BB,$5C44,$A3BB
                        DC.W $45C6,$4306,$BC79,$4386,$3F44,$1100,$C475,$3B8A
                        DC.W $A474,$A034,$15E8,$AA14,$31D1,$31B1,$0EEE,$3111
                        DC.W $511D,$3391,$EEEE,$1111,$1FF4,$0444,$FBB8,$0444
                        DC.W $020A,$020A,$01F1,$020A,$0000,$0000,$FFFF,$0000
                        DC.W $701F,$701F,$8FE0,$701F,$8000,$8000,$7FFF,$8000
                        DC.W $A004,$A004,$1FF8,$A004,$1C07,$1C07,$03F8,$1C07
                        DC.W $0001,$0001,$FFFE,$0001,$C004,$C004,$3FF8,$C004
                        DC.W $03FB,$03FB,$0000,$03FB,$FFFF,$FFFF,$0000,$FFFF
                        DC.W $DFF0,$DFF0,$0000,$DFF0,$FFFF,$FFFF,$0000,$FFFF
                        DC.W $BFFC,$BFFC,$0000,$BFFC,$07FD,$07FD,$0000,$07FD
                        DC.W $FFFF,$FFFF,$0000,$FFFF,$7FFC,$7FFC,$0000,$7FFC
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$2000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$4000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$C000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0001,$0000,$0000,$0000,$8000,$4000,$4000,$4000
                        DC.W $0000,$0000,$0000,$0000,$0FC7,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0003,$0000,$0000,$0000,$0000,$8000,$8000,$8000
                        DC.W $0000,$0000,$0000,$0000,$FFFE,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0002,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0187,$0000,$0000,$0000,$0638,$8000,$8000,$8000
                        DC.W $700F,$0000,$0000,$0000,$FFF8,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0406,$0000,$0000,$0000,$00D0,$0000,$0000,$0000
                        DC.W $072E,$0001,$0001,$0001,$3CFD,$0000,$0000,$0000
                        DC.W $E03F,$0000,$0000,$0000,$C070,$1F8E,$1F8E,$1F8E
                        DC.W $0000,$0000,$0000,$0000,$0004,$0000,$0000,$0000
                        DC.W $0C0C,$0000,$0000,$0000,$03B0,$0000,$0000,$0000
                        DC.W $1E7F,$0000,$0000,$0000,$F98D,$0000,$0000,$0000
                        DC.W $C0FC,$0001,$0001,$0001,$0000,$FFFC,$FFFC,$FFFC
                        DC.W $0000,$0000,$0000,$0000,$001C,$0000,$0000,$0000
                        DC.W $181C,$0000,$0000,$0000,$07B0,$0000,$0000,$0000
                        DC.W $7CFF,$0300,$0300,$0300,$F31B,$0C60,$0C60,$0C60
                        DC.W $C3E0,$201F,$201F,$201F,$0000,$FFF0,$FFF0,$FFF0
                        DC.W $0000,$0000,$0000,$0000,$0078,$0000,$0000,$0000
                        DC.W $3838,$0004,$0004,$0004,$0F60,$0080,$0080,$0080
                        DC.W $F1FC,$0E00,$0E00,$0E00,$2633,$59C8,$59C8,$59C8
                        DC.W $8F00,$407F,$407F,$407F,$0000,$80E0,$80E0,$80E0
                        DC.W $0000,$0000,$0000,$0000,$01F8,$0000,$0000,$0000
                        DC.W $7078,$0800,$0800,$0800,$1961,$0600,$0600,$0600
                        DC.W $C3B0,$3C4F,$3C4F,$3C4F,$4CE7,$B318,$B318,$B318
                        DC.W $9C00,$01F8,$01F8,$01F8,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$07F0,$0008,$0008,$0008
                        DC.W $F0D0,$0028,$0028,$0028,$32C3,$0D20,$0D20,$0D20
                        DC.W $C070,$398F,$398F,$398F,$FF8F,$0030,$0030,$0030
                        DC.W $7000,$87C0,$87C0,$87C0,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0FF1,$0000,$0000,$0000
                        DC.W $A1B0,$5040,$5040,$5040,$60C3,$1E00,$1E00,$1E00
                        DC.W $E063,$0398,$0398,$0398,$FE1B,$0064,$0064,$0064
                        DC.W $C000,$1E00,$1E00,$1E00,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$3E63,$0190,$0190,$0190
                        DC.W $2360,$C090,$C090,$C090,$C181,$3242,$3242,$3242
                        DC.W $F0E0,$0700,$0700,$0700,$3077,$8988,$8988,$8988
                        DC.W $0000,$3800,$3800,$3800,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$7866,$0781,$0781,$0781
                        DC.W $6660,$8180,$8180,$8180,$8380,$6407,$6407,$6407
                        DC.W $70C0,$8021,$8021,$8021,$30E6,$CF18,$CF18,$CF18
                        DC.W $0000,$E000,$E000,$E000,$0000,$0000,$0000,$0000
                        DC.W $0001,$0000,$0000,$0000,$E0CC,$1F23,$1F23,$1F23
                        DC.W $4CC1,$0320,$0320,$0320,$C717,$0080,$0080,$0080
                        DC.W $F1C0,$0007,$0007,$0007,$338C,$CC33,$CC33,$CC33
                        DC.W $0000,$8000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0003,$0000,$0000,$0000,$C0D8,$3C06,$3C06,$3C06
                        DC.W $D8C3,$0600,$0600,$0600,$9F67,$0000,$0000,$0000
                        DC.W $E380,$0040,$0040,$0040,$3F0C,$40E2,$40E2,$40E2
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0000,$0000,$0000,$01B0,$F04C,$F04C,$F04C
                        DC.W $F18F,$0C40,$0C40,$0C40,$FBCF,$0400,$0400,$0400
                        DC.W $C78C,$2000,$2000,$2000,$1C1E,$61C0,$61C0,$61C0
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001C,$0003,$0003,$0003,$01E1,$C018,$C018,$C018
                        DC.W $E1BD,$1802,$1802,$1802,$F39F,$0C20,$0C20,$0C20
                        DC.W $07F0,$E000,$E000,$E000,$001C,$6700,$6700,$6700
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0030,$0007,$0007,$0007,$03C1,$8030,$8030,$8030
                        DC.W $C3F0,$3007,$3007,$3007,$C100,$3ECF,$3ECF,$3ECF
                        DC.W $0F80,$C000,$C000,$C000,$0038,$7E00,$7E00,$7E00
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0060,$001E,$001E,$001E,$0383,$0060,$0060,$0060
                        DC.W $83C0,$601F,$601F,$601F,$0000,$F79F,$F79F,$F79F
                        DC.W $0E00,$8118,$8118,$8118,$0030,$380C,$380C,$380C
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0080,$0038,$0038,$0038,$0703,$00C0,$00C0,$00C0
                        DC.W $0700,$C07B,$C07B,$C07B,$0000,$E73E,$E73E,$E73E
                        DC.W $1800,$07E0,$07E0,$07E0,$0060,$0018,$0018,$0018
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0100,$0060,$0060,$0060,$0706,$0081,$0081,$0081
                        DC.W $0600,$81E1,$81E1,$81E1,$0000,$8200,$8200,$8200
                        DC.W $1000,$0F00,$0F00,$0F00,$0040,$0030,$0030,$0030
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$00C0,$00C0,$00C0,$0E0C,$0103,$0103,$0103
                        DC.W $0C00,$0380,$0380,$0380,$0000,$0000,$0000,$0000
                        DC.W $2000,$1C00,$1C00,$1C00,$0080,$0060,$0060,$0060
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0100,$0100,$0100,$0C08,$0206,$0206,$0206
                        DC.W $0800,$0600,$0600,$0600,$0000,$0000,$0000,$0000
                        DC.W $0000,$3000,$3000,$3000,$0000,$00C0,$00C0,$00C0
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0200,$0200,$0200,$1810,$060C,$060C,$060C
                        DC.W $0000,$0C00,$0C00,$0C00,$0000,$0000,$0000,$0000
                        DC.W $0000,$2000,$2000,$2000,$0000,$0080,$0080,$0080
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$1020,$0C18,$0C18,$0C18
                        DC.W $0000,$1800,$1800,$1800,$0000,$0000,$0000,$0000
                        DC.W $0000,$4000,$4000,$4000,$0000,$0100,$0100,$0100
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$3000,$0810,$0810,$0810
                        DC.W $0000,$1000,$1000,$1000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$2000,$1020,$1020,$1020
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$2040,$2040,$2040
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$4000,$2000,$2000,$2000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000



                        IF 1=2
*    pixels/scanline    = $0080 (bytes/scanline: $0040)
*  # scanlines (height) = $003D
                        DC.W $03F3,$0000,$03F3,$03F3,$FFFF,$0000,$FFFF,$FFFF
                        DC.W $DFF0,$0000,$DFF0,$DFF0,$003F,$0000,$003F,$003F
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FB,$0000,$021A,$021A,$FFFF,$0000,$0000,$0000
                        DC.W $FFFC,$0000,$701C,$701C,$003F,$0000,$0020,$0020
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$00C0,$020E,$02CE,$FF55,$E6EE,$0111,$E6EE
                        DC.W $FDFE,$0640,$4106,$46C6,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$0040,$02A6,$0246,$FFD5,$446E,$A3BB,$4444
                        DC.W $F57E,$0EE0,$1BB2,$0442,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03FF,$00E0,$0212,$02E2,$FF55,$E6EE,$0111,$E6EE
                        DC.W $D5FE,$2E40,$1112,$2EEA,$0035,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03BF,$0040,$02B8,$0240,$BBFF,$4400,$A300,$4400
                        DC.W $D3BE,$2C68,$383A,$0442,$0031,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03AB,$00FC,$0210,$02EC,$BAFF,$E700,$017F,$E67F
                        DC.W $C7EE,$3810,$9112,$A92A,$0031,$0004,$0020,$002E
                        DC.W $8000,$0000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $03AB,$0054,$02BA,$0244,$BAFF,$4500,$A300,$4400
                        DC.W $C7EE,$3838,$BBBA,$8382,$FFB1,$0004,$FFA0,$FFAE
                        DC.W $FFFF,$0000,$FFFF,$FFFF,$C7FD,$0000,$C7FD,$C7FD
                        DC.W $FFFE,$0000,$FFFE,$FFFE,$7FC0,$0000,$7FC0,$7FC0
                        DC.W $02EE,$01BB,$0201,$02EE,$E644,$BBBB,$0110,$E6EE
                        DC.W $82AB,$7C54,$9293,$AAAB,$80E4,$7F11,$80E0,$80EE
                        DC.W $0300,$FCFF,$0300,$0300,$7C07,$83F8,$7C07,$7C07
                        DC.W $0003,$FFFC,$0003,$0003,$C070,$3F80,$C070,$C070
                        DC.W $02E6,$0119,$02A3,$0244,$E6C4,$193B,$A3BA,$4444
                        DC.W $82AA,$7C7D,$BABA,$8282,$2E24,$FBD1,$3A20,$042E
                        DC.W $4146,$1699,$1111,$E966,$10E1,$EF1E,$1111,$10E1
                        DC.W $4009,$BFFE,$1111,$6289,$1B18,$EEE0,$0418,$1B18
                        DC.W $02E3,$01BF,$0201,$02E2,$E754,$BBBB,$0110,$E6EE
                        DC.W $92B8,$7C57,$9290,$AAA8,$FF05,$1171,$1101,$EE8E
                        DC.W $547F,$13BB,$103B,$EC44,$C7D4,$BBBB,$83B8,$4444
                        DC.W $555C,$BBB3,$3BB8,$4444,$7FC8,$C470,$6EC8,$1108
                        DC.W $02A9,$0117,$02A9,$0248,$A300,$19FF,$A300,$4400
                        DC.W $92B9,$7C7F,$BAB9,$8280,$BB81,$BBB1,$BB81,$444E
                        DC.W $101B,$1191,$1011,$EE6E,$ABB0,$111B,$0110,$EEEE
                        DC.W $1118,$BBBB,$1110,$6EEC,$EEE8,$EEF0,$4448,$BBA8
                        DC.W $02AC,$01B3,$020C,$02EC,$A37F,$BB80,$017F,$E67F
                        DC.W $92B9,$7C57,$9291,$AAA8,$A301,$1D31,$0101,$E2CE
                        DC.W $1038,$F1BF,$1038,$0E40,$AB10,$BBFB,$AB1A,$4404
                        DC.W $1118,$BFF3,$3398,$4004,$E0E8,$4E50,$E0E8,$1108
                        DC.W $02AE,$0111,$02AE,$024E,$A340,$1980,$A340,$4440
                        DC.W $92B9,$7C7F,$BAB9,$8280,$8980,$B7B1,$8980,$484E
                        DC.W $4012,$B19D,$4012,$4E62,$0A40,$F1BB,$0040,$0E4E
                        DC.W $1118,$BFFB,$1110,$628C,$E4E8,$FBF0,$4448,$A4A8
                        DC.W $00A0,$01B1,$020A,$02EA,$A200,$BA80,$0040,$E740
                        DC.W $0028,$6C46,$8280,$BAB9,$8000,$2231,$1C00,$DDCE
                        DC.W $0020,$11A8,$E027,$EE57,$0A00,$1B1B,$EAEA,$E4E4
                        DC.W $0008,$AEE3,$2288,$5114,$A0A0,$1F10,$A0A8,$4048
                        DC.W $01F1,$0151,$02EA,$020A,$FE80,$5C80,$E640,$0140
                        DC.W $446E,$6C6E,$AAA8,$9291,$E3F5,$E3F5,$D404,$140A
                        DC.W $15C8,$15C8,$A444,$AA34,$1F15,$151F,$24A4,$2AAA
                        DC.W $CC6F,$EEEF,$4004,$3398,$BBB0,$BBB0,$1108,$EEE8
                        DC.W $01F1,$01F1,$024A,$02AA,$FE80,$FE80,$4440,$A340
                        DC.W $446E,$6C46,$8280,$BAB9,$E015,$6015,$57E4,$97EA
                        DC.W $15E8,$15E8,$A464,$AA14,$1F15,$1F1F,$2EAE,$20A0
                        DC.W $CC6F,$EEE7,$628C,$1110,$BBB0,$1110,$BBA8,$4448
                        DC.W $01F1,$0151,$02EA,$020A,$FE80,$5C80,$E640,$0140
                        DC.W $446E,$6C6E,$AAA8,$9291,$E015,$E015,$D024,$102A
                        DC.W $15C8,$15C8,$A444,$AA34,$1F15,$151F,$24A4,$2AAA
                        DC.W $CC6F,$EEEF,$4004,$3398,$BBB0,$BBB0,$1108,$EEE8
                        DC.W $01F1,$01F1,$024A,$02AA,$FF80,$FE80,$4440,$A340
                        DC.W $547F,$6C46,$8280,$BAB9,$E015,$6015,$5024,$902A
                        DC.W $15F8,$15E8,$A464,$AA14,$1F15,$1F1F,$2EAE,$20A0
                        DC.W $DD7F,$EEE7,$628C,$1110,$FFF0,$1FF0,$A008,$4008
                        DC.W $01B1,$0151,$02EA,$020A,$BB80,$5C80,$E640,$0140
                        DC.W $547F,$6C6E,$AAA8,$9291,$A011,$E015,$D024,$102A
                        DC.W $1198,$15C8,$A444,$AA34,$1B11,$151F,$24A4,$2AAA
                        DC.W $9D7B,$EEEF,$4004,$3398,$F000,$B000,$0FF8,$EFF8
                        DC.W $01B1,$01F1,$024A,$02AA,$BB80,$FE80,$4440,$A340
                        DC.W $547F,$6C46,$8280,$BAB9,$A011,$6015,$5024,$902A
                        DC.W $11B8,$15E8,$A464,$AA14,$1B11,$1F1F,$2EAE,$20A0
                        DC.W $9D7B,$EEE7,$628C,$1110,$F000,$1000,$A800,$4800
                        DC.W $03BB,$035B,$00E0,$020A,$BAC0,$5DC0,$E600,$0140
                        DC.W $C7EE,$FFFF,$2828,$9391,$B831,$F835,$C004,$182A
                        DC.W $B18C,$B5DC,$0440,$AA34,$3BF1,$35FF,$0404,$2AEA
                        DC.W $8C6B,$FFFF,$4004,$3398,$BC00,$FC00,$0000,$EC00
                        DC.W $02AA,$02EA,$0151,$02AA,$A27F,$E77F,$5C80,$A37F
                        DC.W $8128,$B911,$46C6,$B939,$8FE0,$4FE4,$7015,$8FEA
                        DC.W $A024,$A474,$15E8,$AA14,$2A40,$2E4E,$1FBF,$2040
                        DC.W $0008,$7394,$EEEF,$1110,$A7FC,$47FC,$B800,$47FC
                        DC.W $02EA,$020A,$01F1,$020A,$E600,$0100,$FEFF,$0100
                        DC.W $0468,$3839,$EFEE,$1011,$E004,$A000,$FFF5,$000A
                        DC.W $A444,$A014,$15C8,$AA34,$2E04,$211A,$14E5,$2B1A
                        DC.W $400C,$3398,$CC67,$3398,$B004,$E004,$1FF8,$E004
                        DC.W $02EA,$02AA,$0151,$02AA,$E755,$A3BB,$5C44,$A3BB
                        DC.W $15F9,$3B11,$C446,$3BB9,$FF44,$1100,$4475,$BB8A
                        DC.W $A474,$A034,$15E8,$AA14,$2FD4,$2BBA,$1EEF,$2110
                        DC.W $511C,$3390,$EEEF,$1110,$FFF4,$4444,$BBB8,$4444
                        DC.W $02EA,$020A,$01F1,$020A,$E7D5,$013B,$FEEE,$0111
                        DC.W $1570,$1BB0,$EEEF,$1110,$FFC4,$BB80,$EEF5,$110A
                        DC.W $A454,$A014,$15C8,$AA34,$27F4,$2118,$1C47,$23B8
                        DC.W $511C,$3398,$CC67,$3398,$7FF4,$6EE4,$9118,$6EE4
                        DC.W $02EA,$02AA,$0151,$02AA,$E755,$A3BB,$5C44,$A3BB
                        DC.W $45C6,$4306,$BC79,$4386,$3F44,$1100,$C475,$3B8A
                        DC.W $A474,$A034,$15E8,$AA14,$31D1,$31B1,$0EEE,$3111
                        DC.W $511D,$3391,$EEEE,$1111,$1FF4,$0444,$FBB8,$0444
                        DC.W $020A,$020A,$01F1,$020A,$0000,$0000,$FFFF,$0000
                        DC.W $701F,$701F,$8FE0,$701F,$8000,$8000,$7FFF,$8000
                        DC.W $A004,$A004,$1FF8,$A004,$1C07,$1C07,$03F8,$1C07
                        DC.W $0001,$0001,$FFFE,$0001,$C004,$C004,$3FF8,$C004
                        DC.W $03FB,$03FB,$0000,$03FB,$FFFF,$FFFF,$0000,$FFFF
                        DC.W $DFF0,$DFF0,$0000,$DFF0,$FFFF,$FFFF,$0000,$FFFF
                        DC.W $BFFC,$BFFC,$0000,$BFFC,$07FD,$07FD,$0000,$07FD
                        DC.W $FFFF,$FFFF,$0000,$FFFF,$7FFC,$7FFC,$0000,$7FFC
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$4000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0001,$0000,$0000,$0000,$8000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0003,$0000,$0000,$0000,$8000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0003,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0FC7,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0183,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$7FFE,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0002,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0706,$0000,$0000,$0000,$1E3E,$0000,$0000,$0000
                        DC.W $380F,$0000,$0000,$0000,$FFF8,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0006,$0000,$0000,$0000,$00C0,$0000,$0000,$0000
                        DC.W $0F0E,$0000,$0000,$0000,$7C7E,$0000,$0000,$0000
                        DC.W $F01F,$0000,$0000,$0000,$E070,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$000C,$0000,$0000,$0000
                        DC.W $040C,$0000,$0000,$0000,$03B0,$0000,$0000,$0000
                        DC.W $3E7F,$0000,$0000,$0000,$F8CC,$0000,$0000,$0000
                        DC.W $E0FC,$0000,$0000,$0000,$0000,$0004,$0004,$0004
                        DC.W $0000,$0000,$0000,$0000,$001C,$0000,$0000,$0000
                        DC.W $0C1C,$0000,$0000,$0000,$07B0,$0000,$0000,$0000
                        DC.W $7CFF,$0000,$0000,$0000,$9119,$0000,$0000,$0000
                        DC.W $C3E0,$0000,$0000,$0000,$0000,$3F3C,$3F3C,$3F3C
                        DC.W $0000,$0000,$0000,$0000,$0078,$0000,$0000,$0000
                        DC.W $3838,$0000,$0000,$0000,$0F60,$0000,$0000,$0000
                        DC.W $E1F8,$0C00,$0C00,$0C00,$0663,$1810,$1810,$1810
                        DC.W $8F00,$600F,$600F,$600F,$0000,$FFF0,$FFF0,$FFF0
                        DC.W $0000,$0000,$0000,$0000,$01F8,$0000,$0000,$0000
                        DC.W $7878,$0000,$0000,$0000,$1D61,$0000,$0000,$0000
                        DC.W $83B0,$3C08,$3C08,$3C08,$4CC3,$3030,$3030,$3030
                        DC.W $9E00,$403F,$403F,$403F,$0000,$FFC0,$FFC0,$FFC0
                        DC.W $0000,$0000,$0000,$0000,$07F0,$0000,$0000,$0000
                        DC.W $E8F0,$1000,$1000,$1000,$30C1,$0600,$0600,$0600
                        DC.W $C061,$391E,$391E,$391E,$FF0F,$00F0,$00F0,$00F0
                        DC.W $7000,$81FC,$81FC,$81FC,$0000,$0080,$0080,$0080
                        DC.W $0000,$0000,$0000,$0000,$0FF1,$0000,$0000,$0000
                        DC.W $D1B0,$2000,$2000,$2000,$30C1,$0E00,$0E00,$0E00
                        DC.W $E060,$1B9F,$1B9F,$1B9F,$FE1B,$0160,$0160,$0160
                        DC.W $E000,$07E0,$07E0,$07E0,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$3E63,$0180,$0180,$0180
                        DC.W $3330,$40C0,$40C0,$40C0,$4380,$3C01,$3C01,$3C01
                        DC.W $F0E0,$0710,$0710,$0710,$30E7,$4800,$4800,$4800
                        DC.W $0000,$1E00,$1E00,$1E00,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$7866,$0380,$0380,$0380
                        DC.W $6660,$8180,$8180,$8180,$C790,$3803,$3803,$3803
                        DC.W $70C0,$0720,$0720,$0720,$39E7,$0008,$0008,$0008
                        DC.W $0000,$3C00,$3C00,$3C00,$0000,$0000,$0000,$0000
                        DC.W $0001,$0000,$0000,$0000,$E0CC,$0F03,$0F03,$0F03
                        DC.W $6861,$8380,$8380,$8380,$EDA7,$0200,$0200,$0200
                        DC.W $F1C0,$0002,$0002,$0002,$3F0C,$8032,$8032,$8032
                        DC.W $0000,$E000,$E000,$E000,$0000,$0000,$0000,$0000
                        DC.W $0003,$0000,$0000,$0000,$C0DC,$1F03,$1F03,$1F03
                        DC.W $D8C7,$0700,$0700,$0700,$DD26,$0209,$0209,$0209
                        DC.W $E380,$0007,$0007,$0007,$3F0C,$C061,$C061,$C061
                        DC.W $0000,$C000,$C000,$C000,$0000,$0000,$0000,$0000
                        DC.W $000F,$0000,$0000,$0000,$01B1,$7C0E,$7C0E,$7C0E
                        DC.W $E1DF,$0C00,$0C00,$0C00,$FB8F,$0400,$0400,$0400
                        DC.W $C79C,$0003,$0003,$0003,$381E,$C1C0,$C1C0,$C1C0
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $001E,$0000,$0000,$0000,$01E1,$F01C,$F01C,$F01C
                        DC.W $E1BD,$0802,$0802,$0802,$F39F,$0C00,$0C00,$0C00
                        DC.W $8730,$4000,$4000,$4000,$003C,$C380,$C380,$C380
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0038,$0003,$0003,$0003,$03C1,$C038,$C038,$C038
                        DC.W $83F1,$3006,$3006,$3006,$C380,$3C11,$3C11,$3C11
                        DC.W $0780,$C000,$C000,$C000,$0038,$FF00,$FF00,$FF00
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0070,$000F,$000F,$000F,$0383,$8470,$8470,$8470
                        DC.W $83E1,$2006,$2006,$2006,$8100,$3E9F,$3E9F,$3E9F
                        DC.W $0600,$8001,$8001,$8001,$0020,$FC50,$FC50,$FC50
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0080,$001E,$001E,$001E,$0706,$00C0,$00C0,$00C0
                        DC.W $0780,$C03F,$C03F,$C03F,$0000,$EF1F,$EF1F,$EF1F
                        DC.W $1800,$0610,$0610,$0610,$0000,$F0E8,$F0E8,$F0E8
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0100,$003C,$003C,$003C,$0706,$0081,$0081,$0081
                        DC.W $0300,$847F,$847F,$847F,$0000,$CE7F,$CE7F,$CE7F
                        DC.W $1000,$0C60,$0C60,$0C60,$0000,$C0F0,$C0F0,$C0F0
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$00F0,$00F0,$00F0,$0E0C,$0102,$0102,$0102
                        DC.W $0C00,$03CF,$03CF,$03CF,$0000,$9E38,$9E38,$9E38
                        DC.W $0000,$3F00,$3F00,$3F00,$0000,$0070,$0070,$0070
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$01E0,$01E0,$01E0,$0C08,$0306,$0306,$0306
                        DC.W $1800,$078F,$078F,$078F,$0000,$0E00,$0E00,$0E00
                        DC.W $0000,$1C00,$1C00,$1C00,$0000,$00C0,$00C0,$00C0
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0300,$0300,$0300,$1810,$060C,$060C,$060C
                        DC.W $0000,$1E00,$1E00,$1E00,$0000,$0000,$0000,$0000
                        DC.W $0000,$7000,$7000,$7000,$0000,$0100,$0100,$0100
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0200,$0200,$0200,$1820,$0418,$0418,$0418
                        DC.W $0000,$1C00,$1C00,$1C00,$0000,$0000,$0000,$0000
                        DC.W $0000,$6000,$6000,$6000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0400,$0400,$0400,$3000,$0830,$0830,$0830
                        DC.W $0000,$1800,$1800,$1800,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$2000,$1020,$1020,$1020
                        DC.W $0000,$7000,$7000,$7000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$6040,$6040,$6040
                        DC.W $0000,$C000,$C000,$C000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0008,$0008,$0008,$4000,$2000,$2000,$2000
                        DC.W $0000,$8000,$8000,$8000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$C080,$C080,$C080
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000

                        ENDC

;Die 512 Farben in der Lupe...
color512:               DC.B $00,$70,$00,$71,$01,$71,$02,'q'
                        DC.B $03,'q',$04,'q',$05,'q',$06,'q'
                        DC.B $07,'q',$07,'a',$07,'Q',$07,'A'
                        DC.B $07,'1',$07,'!',$07,$11,$07,$01
                        DC.B $01,'p',$00,'`',$00,'a',$01,'a'
                        DC.B $02,'a',$03,'a',$04,'a',$05,'a'
                        DC.B $06,'a',$06,'Q',$06,'A',$06,'1'
                        DC.B $06,'!',$06,$11,$06,$01,$07,$02
                        DC.B $02,'p',$01,'`',$00,'P',$00,'Q'
                        DC.B $01,'Q',$02,'Q',$03,'Q',$04,'Q'
                        DC.B $05,'Q',$05,'A',$05,'1',$05,'!'
                        DC.B $05,$11,$05,$01,$06,$02,$07,$12
                        DC.B $03,'p',$02,'`',$01,'P',$00,'@'
                        DC.B $00,'A',$01,'A',$02,'A',$03,'A'
                        DC.B $04,'A',$04,'1',$04,'!',$04,$11
                        DC.B $04,$01,$05,$02,$06,$12,$07,'"'
                        DC.B $04,'p',$03,'`',$02,'P',$01,'@'
                        DC.B $00,'0',$00,'1',$01,'1',$02,'1'
                        DC.B $03,'1',$03,'!',$03,$11,$03,$01
                        DC.B $04,$02,$05,$12,$06,'"',$07,'2'
                        DC.B $05,'p',$04,'`',$03,'P',$02,'@'
                        DC.B $01,'0',$00,' ',$00,'!',$01,'!'
                        DC.B $02,'!',$02,$11,$02,$01,$03,$02
                        DC.B $04,$12,$05,'"',$06,'2',$07,'B'
                        DC.B $06,'p',$05,'`',$04,'P',$03,'@'
                        DC.B $02,'0',$01,' ',$00,$10,$00,$11
                        DC.B $01,$11,$01,$01,$02,$02,$03,$12
                        DC.B $04,'"',$05,'2',$06,'B',$07,'R'
                        DC.B $07,'p',$06,'`',$05,'P',$04,'@'
                        DC.B $03,'0',$02,' ',$01,$10,$00,$00
                        DC.B $00,$01,$01,$02,$02,$12,$03,'"'
                        DC.B $04,'2',$05,'B',$06,'R',$07,'b'
                        DC.B $07,'`',$06,'P',$05,'@',$04,'0'
                        DC.B $03,' ',$02,$10,$01,$00,$00,$03
                        DC.B $00,$02,$01,$12,$02,'"',$03,'2'
                        DC.B $04,'B',$05,'R',$06,'b',$07,'r'
                        DC.B $07,'P',$06,'@',$05,'0',$04,' '
                        DC.B $03,$10,$02,$00,$01,$03,$01,$13
                        DC.B $00,$13,$00,$12,$01,'"',$02,'2'
                        DC.B $03,'B',$04,'R',$05,'b',$06,'r'
                        DC.B $07,'@',$06,'0',$05,' ',$04,$10
                        DC.B $03,$00,$02,$03,$02,$13,$02,'#'
                        DC.B $01,'#',$00,'#',$00,'"',$01,'2'
                        DC.B $02,'B',$03,'R',$04,'b',$05,'r'
                        DC.B $07,'0',$06,' ',$05,$10,$04,$00
                        DC.B $03,$03,$03,$13,$03,'#',$03,'3'
                        DC.B $02,'3',$01,'3',$00,'3',$00,'2'
                        DC.B $01,'B',$02,'R',$03,'b',$04,'r'
                        DC.B $07,' ',$06,$10,$05,$00,$04,$03
                        DC.B $04,$13,$04,'#',$04,'3',$04,'C'
                        DC.B $03,'C',$02,'C',$01,'C',$00,'C'
                        DC.B $00,'B',$01,'R',$02,'b',$03,'r'
                        DC.B $07,$10,$06,$00,$05,$03,$05,$13
                        DC.B $05,'#',$05,'3',$05,'C',$05,'S'
                        DC.B $04,'S',$03,'S',$02,'S',$01,'S'
                        DC.B $00,'S',$00,'R',$01,'b',$02,'r'
                        DC.B $07,$00,$06,$03,$06,$13,$06,'#'
                        DC.B $06,'3',$06,'C',$06,'S',$06,'c'
                        DC.B $05,$63,$04,'c',$03,'c',$02,'c'
                        DC.B $01,'c',$00,'c',$00,'b',$01,'r'
                        DC.B $07,$03,$07,$13,$07,'#',$07,'3'
                        DC.B $07,'C',$07,'S',$07,'c',$07,'s'
                        DC.B $06,'s',$05,'s',$04,'s',$03,'s'
                        DC.B $02,'s',$01,'s',$00,'s',$00,'r'
                        DC.B $07,$07,$07,$04,$07,$14,$07,'$'
                        DC.B $07,'4',$07,'D',$07,'T',$07,'d'
                        DC.B $07,'t',$06,'t',$05,'t',$04,'t'
                        DC.B $03,'t',$02,'t',$01,'t',$00,'t'
                        DC.B $07,$17,$06,$07,$06,$04,$06,$14
                        DC.B $06,'$',$06,'4',$06,'D',$06,'T'
                        DC.B $06,'d',$05,'d',$04,'d',$03,'d'
                        DC.B $02,'d',$01,'d',$00,'d',$00,'u'
                        DC.B $07,$27,$06,$17,$05,$07,$05,$04
                        DC.B $05,$14,$05,'$',$05,'4',$05,'D'
                        DC.B $05,'T',$04,'T',$03,'T',$02,'T'
                        DC.B $01,'T',$00,'T',$00,'e',$01,'u'
                        DC.B $07,'7',$06,$27,$05,$17,$04,$07
                        DC.B $04,$04,$04,$14,$04,'$',$04,'4'
                        DC.B $04,'D',$03,'D',$02,'D',$01,'D'
                        DC.B $00,'D',$00,'U',$01,'e',$02,'u'
                        DC.B $07,'G',$06,'7',$05,$27,$04,$17
                        DC.B $03,$07,$03,$04,$03,$14,$03,'$'
                        DC.B $03,'4',$02,'4',$01,'4',$00,'4'
                        DC.B $00,'E',$01,'U',$02,'e',$03,'u'
                        DC.B $07,'W',$06,'G',$05,'7',$04,$27
                        DC.B $03,$17,$02,$07,$02,$04,$02,$14
                        DC.B $02,'$',$01,'$',$00,'$',$00,'5'
                        DC.B $01,'E',$02,'U',$03,'e',$04,'u'
                        DC.B $07,'g',$06,'W',$05,'G',$04,'7'
                        DC.B $03,$27,$02,$17,$01,$07,$01,$04
                        DC.B $01,$14,$00,$14,$00,'%',$01,'5'
                        DC.B $02,'E',$03,'U',$04,'e',$05,'u'
                        DC.B $07,'w',$06,'g',$05,'W',$04,'G'
                        DC.B $03,'7',$02,$27,$01,$17,$00,$07
                        DC.B $00,$04,$00,$15,$01,'%',$02,'5'
                        DC.B $03,'E',$04,'U',$05,'e',$06,'u'
                        DC.B $06,'w',$05,'g',$04,'W',$03,'G'
                        DC.B $02,'7',$01,$27,$00,$17,$00,$06
                        DC.B $00,$05,$01,$15,$02,'%',$03,'5'
                        DC.B $04,'E',$05,'U',$06,'e',$07,'u'
                        DC.B $05,'w',$04,'g',$03,'W',$02,'G'
                        DC.B $01,'7',$00,$27,$00,$16,$01,$16
                        DC.B $01,$06,$01,$05,$02,$15,$03,'%'
                        DC.B $04,'5',$05,'E',$06,'U',$07,'e'
                        DC.B $04,'w',$03,'g',$02,'W',$01,'G'
                        DC.B $00,'7',$00,'&',$01,'&',$02,'&'
                        DC.B $02,$16,$02,$06,$02,$05,$03,$15
                        DC.B $04,'%',$05,'5',$06,'E',$07,'U'
                        DC.B $03,'w',$02,'g',$01,'W',$00,'G'
                        DC.B $00,'6',$01,'6',$02,'6',$03,'6'
                        DC.B $03,'&',$03,$16,$03,$06,$03,$05
                        DC.B $04,$15,$05,'%',$06,'5',$07,'E'
                        DC.B $02,'w',$01,'g',$00,'W',$00,'F'
                        DC.B $01,'F',$02,'F',$03,'F',$04,'F'
                        DC.B $04,'6',$04,'&',$04,$16,$04,$06
                        DC.B $04,$05,$05,$15,$06,'%',$07,'5'
                        DC.B $01,'w',$00,'g',$00,'V',$01,'V'
                        DC.B $02,'V',$03,'V',$04,'V',$05,'V'
                        DC.B $05,'F',$05,'6',$05,'&',$05,$16
                        DC.B $05,$06,$05,$05,$06,$15,$07,'%'
                        DC.B $00,'w',$00,'f',$01,'f',$02,'f'
                        DC.B $03,'f',$04,'f',$05,'f',$06,'f'
                        DC.B $06,'V',$06,'F',$06,'6',$06,'&'
                        DC.B $06,$16,$06,$06,$06,$05,$07,$15
                        DC.B $00,'v',$01,'v',$02,'v',$03,'v'
                        DC.B $04,'v',$05,'v',$06,'v',$07,'v'
                        DC.B $07,'f',$07,'V',$07,'F',$07,'6'
                        DC.B $07,'&',$07,$16,$07,$06,$07,$05
                        DC.W 0

effektflag:             DC.W 0

                        DATA

;Hier beginnen die Options, die NEOchrome abspeichert:
options:

line_pattern:           DC.W %0101010101010101 ;An/Aus..

lade_adresse:           DC.W 0,0
palette:                DC.W $0000,$0700,$0730,$0750,$0770
                        DC.W $0470,$0070,$0075,$0077
                        DC.W $0057,$0027,$0007,$0507
                        DC.W $0707,$0704,$0777

                        DC.W $2020
                        DC.B $20,$20,$20,$20,$20,$20,$2E,$20 ;Filename?
                        DC.B $20,$20
L0754:                  DS.W 1  ;Left+Right-col_mark
L0755:                  DS.W 1
L0756:                  DS.W 3
                        DC.W 320,200,0,0 ;Breite und Hîhe des Bildes
                        DS.W 29 ;und das war's
                        DC.L 'NEO!' ;Neo-Flag

zeichenfarbe:           DC.W $0001 ;auch in Col_Tab Ñndern!
hintergrundfarbe:       DC.W 0  ;auch in Col_Tab Ñndern
left_col_mark:          DC.W 1  ;-'-
right_col_mark:         DC.W 14 ;-'-

colorx:                 DC.B 8  ;x der Zeichen-Farbe im Colorfenster
colory:                 DC.B 7  ;y der Zeichen-Farbe im Colorfenster
pos_color512:           DC.B 0  ;Wo steht das Fenster gerade?
                        DC.B 0,2
pal_flag:               DC.B 0  ;Flag, ob im Fullscreen Palette da ist
beschriftung:           DC.B -1 ;Farbpalette nicht beschriften
synchronisation:        DC.B 0  ;60Hz Synchronisation
magnify:                DC.B 0  ;0=Lupe im Fullscreen zu sehen
magtyp:                 DC.W 1  ;Typ der Lupe (0=Normale Lupe,1=4x, 2=8x, 3=16x)
segmentierung:          DC.B 0  ;Ist Lupe segmentiert
porta:                  DC.B 0  ;Port A Bit gelîscht (Cache aus)
screen_saver:           DC.B 0  ;Screen Saver ist an
music:                  IF disk_version=0
                        DC.B 0  ;Musik an?
                        ELSE
                        DC.B -1
                        ENDC
music_nr:               DC.W 2  ;Nummer der Musik
music_path:             DC.B 'D:\MUZAKS\*.IMG',0 ;Pfad der Musik
                        DS.B 100
music_fn:               DC.B 'J1_TITL.IMG',0,0

user_prg_wished:        DC.L 20*1024 ;StandardlÑnge 20 Kbyte

user_path:              DC.B 'E:\NEOCHROM\*.PRG',0
                        DS.B 100
user1_fn:               DC.B 'CBHD.SYS',0,0
user2_fn:               DC.B 'J1_TITL.MOD',0,0

blitter_an:             DC.W 0  ;Flag, ob Blitter an ist
lupe_y_60:              DC.W 4  ;Hîhe der Lupe in KÑstchen
nop_60:                 DC.W 8  ;Anzahl der Nops zum Randaufklappen
lupe_y_50:              DC.W 8  ;Hîhe der Lupe bei 50Hz
nop_50:                 DC.W 8  ;Achtung! Reihenfolge nicht verÑndern!
ste_support:            DC.W -1 ;Kein STE unterstÅtzen
rotate_winkel:          DC.W 90 ;Es wird um 90¯ bei jedem Rotate gedreht
rotate_direct:          DC.W 93 ;Richtung, in die gedreht wird, aber nur Save-Wert
just_rahmen:            DC.W -1 ;Flag, ob Box gefÅllt oder nur ein Rahmen
randstÑrke:             DC.W 0  ;Startwert der StrickstÑrke
box_typ:                DC.W 0  ;Typ (Rechteck, Kreis, etc.)
akt_brush:              DC.W 7  ;Aktueller Brushtyp
akt_nozzle:             DC.W 35 ;Aktueller Nozzletyp
linestÑrke:             DC.W 1  ;Dicke der Line-Linie
copy_mode:              DC.W -1 ;Welcher Modus bei VerknÅpfung
jack_mode:              DC.W -1 ;-'-
text_align:             DC.W 0  ;Ausrichtung des Textes
text_style:             DC.W 0  ;Fett, Underline,...
L0799                   EQU text_style+1
text_height:            DC.W 4
L079B                   EQU text_height+1
load_typ:               DC.W 3  ;0=Neo,1=PI1,..
save_typ:               DC.W 3  ;-'-

options_end:

overscan:               DC.W -1 ;Flag, kein Autoswitch-Overscan vorhanden
overmode:               DC.W 0  ;Alter Autoswitch-Overscan Modus

druck_pal:              DC.W -1

;FÅr Undo der gesamten Palette
palette_all_undo:       DC.W $0000,$0700,$0730,$0750,$0770
                        DC.W $0470,$0070,$0075,$0077
                        DC.W $0057,$0027,$0007,$0507
                        DC.W $0707,$0704,$0777

rasters:                DC.L rasters1 ;Aktive Rastertabelle
raster_aus:             DC.B 1  ;Raster sind an

pal_titel_s:            DC.B ';Palette of ',0
pal_titel2_s:           DC.B ': Saved by NEOchrome V'
                        DC.B release_1+'0','.',release_2+'0',release_3+'0',' by Chaos, Inc.',0

pal_titel_c:            DC.B '/* Palette of ',0
pal_titel2_c:           DC.B ': Saved by NEOchrome V'
                        DC.B release_1+'0','.',release_2+'0',release_3+'0'
                        DC.B ' by Chaos, Inc. */',13,10
                        DC.B 'int _pal[16] = { ',0
neue_zeile:             DC.B 13,10,9,'0x',0
neuer_wert:             DC.B ',0x',0
eol_c:                  DC.B ',',0
eof_c:                  DC.B ' };',13,10,0

bootsektor:             DC.B $EB,$34,$90 ;Hier fÅr einseitige Disk:
                        DC.B 'IBM  '
seriennummer:           DC.B 'xxx' ;Seriennummer
                        DC.B 0,2 ;512 Bytes pro Sektor
                        DC.B 2  ;Sektoren pro Cluster
                        DC.B 1,0 ;reservierte Sektoren
                        DC.B 2  ;Anzahl der FATs
                        DC.B $70,0 ;Anzahl der Directory-EintrÑge
disk_size:              DC.B $D0,2 ;Anzahl der Sektoren
media_byte:             DC.B $F8 ;Media-Byte
spf:                    DC.B 2,0 ;Sektoren pro FAT
                        DC.B 9,0 ;Sektoren pro Track
sides:                  DC.B 1,0 ;Anzahl der Seiten
                        DC.B 0,0 ;versteckte Sektoren
                        DC.B 0,0 ;Filler

                        DC.B 'This disk is formatted by NEOchrome'
                        DC.B ' on an ATARI ST.   '
                        DC.B 'written by Chaos, Inc. of the Delta Force.  '
                        DC.B 'May the Force be with you...always.'
                        EVEN

scrollfont:
*
*  NEOchrome cut buffer contents (left justified):
*
*    pixels/scanline    = $0100 (bytes/scanline: $0020)
*  # scanlines (height) = $001A
*
*  Monochrome mask (1 plane; background=0/non-background=1)
*
*
*
                        DC.W $0000,$0000,$1800,$1C00,$0000,$0000,$0000,$0006
                        DC.W $7C38,$7C7E,$1CFE,$7CFE,$7C7C,$3800,$0600,$6000
                        DC.W $0018,$6666,$3E66,$3638,$0E70,$6618,$0000,$000C
                        DC.W $E678,$CE06,$3CE0,$E00E,$EEE6,$3800,$0C00,$303C
                        DC.W $0018,$66FF,$606C,$1C38,$1C38,$3C18,$0000,$0018
                        DC.W $EE38,$1C1C,$7CFC,$FC1E,$7C7E,$3818,$18FE,$1866
                        DC.W $0018,$6666,$3C18,$3838,$1818,$FF7E,$007E,$0030
                        DC.W $F638,$78C6,$DC06,$E63C,$EE0E,$0018,$30FE,$0C0C
                        DC.W $0018,$0066,$0630,$6F18,$1818,$3C18,$0000,$0060
                        DC.W $FEFE,$FEFE,$FEE6,$FE7C,$FEFE,$3800,$1800,$1818
                        DC.W $0000,$00FF,$7C66,$6630,$1C38,$6618,$1800,$1840
                        DC.W $FEFE,$FEFE,$FEFE,$FEF8,$FEFC,$3818,$0CFE,$3000
                        DC.W $0018,$0066,$1846,$3B00,$0E70,$0000,$1800,$1800
                        DC.W $7CFE,$FE7C,$1C7C,$7CF8,$7CF8,$3818,$06FE,$6018
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$3000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0030,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $3C38,$F87C,$F8F0,$FE7C,$E6FE,$06E4,$C0C6,$E67C
                        DC.W $FC7C,$FC7C,$FEE6,$E6E6,$E6E6,$7E1E,$C078,$0800
                        DC.W $667C,$CCE6,$ECC0,$F0E0,$E638,$06EC,$C0EE,$E6E6
                        DC.W $E6E6,$E6E0,$FEE6,$E6E6,$E6E6,$1C18,$E018,$1C00
                        DC.W $6E6C,$F8C0,$E6F8,$FCEC,$E638,$E6F8,$C0FE,$F6E6
                        DC.W $E6E6,$E67C,$FEE6,$E6E6,$3CFE,$3818,$7018,$3600
                        DC.W $6EC6,$CCE6,$EEC0,$F0E6,$FE38,$E6F8,$C0FE,$FEE6
                        DC.W $FEEE,$FE0E,$38E6,$E6FE,$3C7C,$7018,$3818,$6300
                        DC.W $60DE,$FEFE,$FEFE,$F0FE,$E6FE,$FEFC,$FEFE,$FEFE
                        DC.W $FCFC,$FCFE,$38FE,$7CFE,$FE38,$FE18,$1C18,$2000
                        DC.W $7EDE,$FEFE,$FEFE,$F0FE,$E6FE,$FEEE,$FEE6,$EEFE
                        DC.W $F0FE,$EEFE,$38FE,$7CEE,$E638,$FE1E,$0E78,$00FF
                        DC.W $3EDE,$FC7C,$FCFE,$F07C,$E6FE,$7CEE,$FEE6,$E67C
                        DC.W $F07E,$EEFC,$38FE,$38C6,$E638,$FE1E,$0678,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                        DC.W $0000,$E000,$0600,$1E00,$E018,$06E0,$7800,$0000
                        DC.W $0000,$0000,$1800,$0000,$0000,$0000,$0000,$0000
                        DC.W $003C,$E07C,$067C,$383E,$E000,$00E6,$38C6,$E67C
                        DC.W $FC7E,$FE7C,$7EE6,$E6E6,$66E6,$3E00,$0000,$0000
                        DC.W $000E,$FCE0,$7EE6,$7E66,$FC78,$06FC,$38EE,$F6E6
                        DC.W $E6CE,$E660,$7EE6,$E6E6,$7CE6,$0C00,$0000,$0000
                        DC.W $007E,$E6E0,$E6FE,$383E,$E638,$06F8,$38FE,$FEE6
                        DC.W $E6CE,$E00C,$38E6,$E6FE,$18E6,$3000,$0000,$0000
                        DC.W $00EE,$FEFC,$E6E0,$3806,$E638,$66EC,$38E6,$FEFE
                        DC.W $FC7E,$E0FC,$38FE,$7CEE,$7C7E,$7E00,$0000,$0000
                        DC.W $007E,$FC7C,$7E7C,$387E,$E67C,$7EEE,$7CE6,$E67C
                        DC.W $F01E,$E0FC,$3EFE,$38C6,$660C,$7E00,$0000,$0000
                        DC.W $0000,$0000,$0000,$007C,$0000,$7C00,$0000,$0000
                        DC.W $F01E,$0000,$0000,$0000,$0078,$0000,$0000,$0000

scrollpos:              DC.L scrolltext ;Position des Scrollers
scrollshift:            DC.W 8  ;Wieviel geshiftet?
scroll_aktiv:           DC.B 1  ;Scroller aus!
back_saved:             DC.B 1  ;Wurde der Hintergrund schon gerettet?

hbls:                   DC.L hbl_system ;Adresse der HBL-Systeme der Screens

repeat_control:         DC.W -1 ;Bisher kein Repeat
akt_work:               DC.W 0  ;Nummer des aktiven Workscreens (0..3)
akt_str:                DC.B '0',0

copycut:                DC.W 1  ;Bisher kein Transfer von Copybox

;Tabelle zum Umrechnen Scancode->Ziffernnummer:
zehnerblock:            DC.B 7,8,9,4,5,6,1,2,3,0

low_mem:                DC.B 'LESS MEMORY...',0

mouseoff:               DC.B $12
mouseon:                DC.B $08
board_gerettet:         DC.B -1 ;Bisher ist Board nicht gerettet

lupe_an:                DC.B -1 ;Flag, ob groûe Lupe zu sehen ist oder nicht
maus_lupex:             DC.W -1,-1 ;Mausx/y Koordinaten

                        IF disk_version=1 ;Nur bei Assemblerversion:
fn:                     DC.B "a:\demos\demo2.iff",0
                        ENDC

akt_cut_shape:          DC.W -20 ;Aktuelles Shape im Auschneidemittelteil
;Texte fÅr die Erweiterten Fileselektoren unter TOS 1.4:
cut_sext:               DC.B 'Save CUTTER Object File',0
cut_lext:               DC.B 'Load CUTTER Object File',0
save_ext:               DC.B 'Save '
save_str:               DC.B 'NEO-picture',0
load_ext:               DC.B 'Load '
load_str:               DC.B 'NEO-picture',0
del_ext:                DC.B 'Delete File',0
ani_lext:               DC.B 'Load Animate File',0
ani_sext:               DC.B 'Save Animate File',0
rst_lext:               DC.B 'Load Rasters',0
rst_sext:               DC.B 'Save Rasters',0
rst_used_sext:          DC.B 'Save used Rasters',0
cpybox_sext1:           DC.B 'Save Copybox source (Data)',0
cpybox_sext2:           DC.B 'Save Copybox source (Mask)',0
cpybox_sext3:           DC.B 'Save Copybox (Image)',0
music_lext:             DC.B 'Load Music',0
user_lext:              DC.B 'Load Usermodule',0
pal_lext:               DC.B 'Load Spectrum color palette',0
save_pal_ext:           DC.B 'Save palette '
save_pal_typ:           DC.B 'S-Source',0
pos_cursor:             DC.B 27,'E',27,'Y',32+2,32+32,0

copyboxes:              DC.L cpybox_sext1,cpybox_sext2,cpybox_sext3

tos_screen:             DC.B 0  ;Ist Tos-Screen aktiv? (0=Ja)

;filenamen der max. 10 Workscreens:
fn_screens:             DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0
                        DC.B 'PICTURE.NEO',0,0

picture_old:            DC.B 'PICTURE.NEO',0,0

grab_tab:               DC.W 0,0,0,0,0,0,0,0,0,0 ;Bei allen 10 Screens auf Null

;Hintergrund, Zeichenfarbe, Left+ right color mark
col_tab:                DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14
                        DC.B 0,1,1,14

lupe_build:             DC.B -1 ;0=Lupe im Buffer fertig zum kopieren

old_mk:                 DC.B $F8

paket_tabelle:
; hier steht die LÑnge der Tastaturpakete in Bytes
                        DC.B 7  ; $f6 Status-Meldung
                        DC.B 5  ; $f7 (absolute Mausposition)
                        DC.B 2  ; $f8 - $fb (relative Mausposition)
                        DC.B 2  ; $f9
                        DC.B 2  ; $fa
                        DC.B 2  ; $fb
                        DC.B 6  ; $fc (Uhrzeit abfragen)
                        DC.B 2  ; $fd (?)
                        DC.B 1  ; $fe-$ff (Joystick)
                        DC.B 1  ; $ff

abs_maus_an:            DC.B $09,320/256,320%256,199/256,199%256
rel_maus_an:            DC.B $08

;Bei zentriertem Zeichnen, dann an diese Position
ani_centerx:            DC.W 160
ani_centery:            DC.W 100

wrg_frmt:               DC.B 'WRONG FORMT',0
memerr:                 DC.B 'LESS MEMORY',0
what:                   DC.B 'BUFF EMPTY ',0
fileerror:              DC.B 'FILE ERROR ',0
spaces:                 DC.B '           ',0

maûe:                   DC.B 'x:'
maûex:                  DC.B '000 y:000',0

breite_cb:              DC.B 'w:000 '
hoehe_cb:               DC.B 'h:000',0

invertiert:             DC.B 0  ;Flag, ob Button invertiert ist oder nicht


board_da:               DS.W 2

copyr_atari:            DC.B ' Ω 1990 '
                        DC.B 'ATARI  ',$00
picture_neo:            DC.B 'PICTURE.'
                        DC.B 'NEO',$00,$00,$00,$00,$00
                        DS.W 14
NEO_MCP:                DC.B 'NEO.MCP',$00
                        DS.W 16

function:               DC.B $04 ;gerade aktive Funktion (pencil)
old_function:           DC.B $04 ;Zuletzt aktive Funktion
L076B:                  DC.B $00
copyr_work:             DC.B $08 ;verschiedene Copyright-Meldungen ZÑhler
changed:                DC.B $FF
changes:                DC.B $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ;Die 4 Changed-Variablen der 4 Screens
less_memory:            DC.B $00
fun_key:                DC.B $00
print_koord_stat:       DC.B $00
aktion_nach_save:       DS.W 1
grab_y:                 DC.W 0  ;Zeile im Zeichenbild, die in Zeile 0 erscheint
ani_bb:                 DS.W 2
                        DC.B $00,$04,$00,$00,$00,$00,$03,$03
                        DC.B $03,$03,$00,$00,$00,$00
                        DC.L L0776
                        DS.W 7
                        DC.B $00,$08,$00,$A0,$00,$02
                        DC.L L0777
                        DC.B $00,$02,$00,$00,$00,$0E,$00,$00
                        DS.W 11
pos_ani_box:            DC.L L0777 ;Wo ist er gerade in der Animation
L0776:                  DC.B $FF,$FF

;fÅr Animation der Copybox:
L0777:                  DC.W %1111000111110001
                        DC.W %1110001111100011
                        DC.W %1100011111000111
                        DC.W %1000111110001111
                        DC.W %0001111100011111
                        DC.W %0011111000111110
                        DC.W %0111110001111100
                        DC.W %1111100011111000
                        DC.W %1111000111110001
                        DC.W %1110001111100011
                        DC.W %1100011111000111
                        DC.W %1000111110001111
                        DC.W %0001111100011111
                        DC.W %0011111000111110
                        DC.W %0111110001111100
                        DC.W %1111100011111000

L0778:                  DS.W 2
                        DC.B $00,$01,$00,$00,$00,$00,$03,$03
                        DC.B $03,$03,$00,$00,$00,$00
                        DC.L mask_buff
                        DC.B $00,$02,$00,'(',$00,$00,$00,$00
                        DC.B $00,$02,$00,$00,$00,$00,$00,$02
                        DC.B $00,'(',$00,$00,$00,$00,$00,$00
                        DS.W 15
;Status: Bit 0: Fertig geschnitten
;            1: Rahmen ist zu sehen
;            2: Verschiebe
;            3: Maus innerhalb
copy_status:            DC.B $00
jack_status:            DC.B $00
no_resize:              DC.B $00
pfad_gebastelt:         DC.B $00
L077F:                  DC.B '[2][ |Sa'
                        DC.B 've chang'
                        DC.B 'es|befor'
                        DC.B 'e Procee'
                        DC.B 'ding?][Y'
                        DC.B 'es|No]',$00
erase_alert:            DC.B '[2][ |Era'
                        DC.B 'se entir'
                        DC.B 'e pictur'
                        DC.B 'e?| |(UN'
                        DC.B 'DO canno'
                        DC.B 't restor'
                        DC.B 'e)][Yes|'
                        DC.B 'No]',$00
L0781:                  DC.B 'x:'
L0782:                  DC.B '000 y:'
L0783:                  DC.B '000',$00
L0784:                  DC.B $00
L0785:                  DC.B '         '
L0786:                  DC.B '  ',$00
L0787:                  DC.B $00
taste:                  DS.W 2
rot_col_speed:          DC.B $00,$14
                        EVEN
rot_col_direct:         DC.B $00 ;Richtung der Farbanimation (2=Rechts,1=Links)
rot_col_directlow:      DC.B $00 ;Lowbyte der Farbanimations-richtung
ani_obj_direct:         DC.W 0  ;Richtung der Objekt-Animation (2=Rechts,1=Links)
L078C:                  DS.W 1
acia_irq_sr:            DC.W $2600
vbl_pal:                DC.L palette ;Pointer auf die VBL-Palette (urspr. tos_pal)
board_y:                DC.W 100
mousex:                 DS.W 1
mousey:                 DS.W 2
L0796:                  DC.B $00,$06
L079C:                  DC.B $00
L079D:                  DC.B $00
L079E:                  DC.B $00
L079F:                  DC.B $00
mouse_pos:              DC.B $00 ;Bit 0=0 -> Maus im Board =1->Maus im Work
L07A1:                  DC.B $00
text_status:            DC.B $00
L07A3:                  DC.B $00
any_shift:              DC.B $00 ;Wird 128, wenn irgendeine Shift gedrÅckt
right_shift:            DC.B $00 ;Wird 128, wenn NUR rechte Shift gedrÅckt
L07A6:                  DS.W 1

seq_akt:                DC.W 0  ;Aktuelle Sequenz
rst_akt:                DC.W 0  ;Aktueller Raster

zeros:                  DS.L 15 ;15 mal long zum lîschen der Register

cheat_modus:            DC.B -1 ;Kein Cheat-Modus

tastatur_read:          DC.L tastatur_buffer ;NÑchste Position zum Lesen
tastatur_write          EQU $00000140 ;NÑchste Position zum Schreiben
overrun:                DC.B 1  ;Flag, das ein Overrun aufgetreten ist

;*****************************************************************************
;Achtung, nachher kommt hier die Commandline hin, d.h. der Beginn des BSS wird
;öberschrieben!
;*****************************************************************************
neo_prg:                DC.B 'NEOCHROM.PRG',0 ;Zum Suchen mit Shel-Read

                        BSS

scrollspace:            DS.B 42*8 ;8 Scanlines fÅr den Scroller
scrollwabbel:           DS.B 42*8 ;Zum Wabbeln des Scrollers
scroll_save:            DS.B 160*8 ;8 Scanlines Hintergrund retten

tastatur_buffer:        DS.B 500 ;Platz fÅr den Tastaturbuffer
pseudo_acia:            DS.B 4  ;Platz fÅr den ACIA, der der Keyb-IRQ bekommt
neu_mk:                 DS.B 1  ;Neuer Maustastenstatus
offx:                   DS.W 1
offy:                   DS.W 1
sende_buffer:           DS.B 30 ;Neuer Sendebuffer
maus_paket:             DS.B 30 ;Buffer fÅr rel. Mausbewegung
mausrout:               DS.L 1  ;Adresse der Mauspaketroutine
ende_auswert:           DS.L 1  ;Ende des Auswertung bei neue_tastatur
ende_sende:             DS.L 1  ;Ende des Sendbuffers bei neue_tastatur
old_tastatur:           DS.L 1  ;Alter Vektor fÅr Tastaturauswertung
sondertasten:           DS.W 1  ;nach Kbshift

lupe_y:                 DS.W 1  ;TatsÑchliche Hîhe der Lupe jetzt
nop_zahl:               DS.W 1  ;Zahl der NOPs zum Aufklappen des Randes

pfadname:               DS.B 128 ;128 bytes fÅr Pfadnamen auf NEOCHROM.PRG
neue_sync:              DS.B 1  ;Neue Synchronisationsfreq bei set_sync

reg_board:              DS.L 16 ;Platz zum Retten der Register bei raster_board
register:               DS.L 16 ;Platz zum Retten bei sync_hbl
rst_tab:                DS.W 10 ;FÅr alle max. 10 Bildschirme

start_y:                DS.W 1  ;FÅr Sammelraster
end_y:                  DS.W 1  ;-'-
raster_platz:           DS.W 1  ;Platzbedarf der Raster eines Objektes
pal_nr:                 DS.W 1  ;Hilfsvariable fÅr Bau_lupe
first_pal:              DS.W 1  ;internes Flag fÅr calc_offsets
raster_count:           DS.W 1  ;ZÑhlervariable fÅr Raster

                        DS.W 12 ;fÅr Clippen der Lupe
lupen_pal:              DS.W 200 ;In welcher Scanline ist welche Palette? Nummer im hbl-system
                        DS.W 20 ;Platz fÅr unteres Clippen der Lupe
raster_big_lupe:        DS.W 16*21 ;fÅr Raster in der groûen Lupe

vbl_raster:             DS.W 1  ;Der Offset zum 1. Raster, wenn Raster abgeschaltet

hbl_system:             DS.W anz_raster*(1+16) ;Y-Position+Paletten
hbl_put_get:            DS.W anz_raster*(1+16) ;Zum Zwischenspeichern eines Rastersystems

rasters1:               DS.W anz_raster*(1+16) ;dargestellte Rasterpalette
rasters2:               DS.W anz_raster*(1+16) ;Aufbaurastertabelle
raster_palette:         DS.W 16 ;Zum Zwischenspeichern mit Pfeil hoch und runter

picture_neu:            DS.B 20 ;Neuer Filenamen beim Laden von Bildern

ste_machine:            DS.W 1  ;Flag ob STE am Werk?
old_sync:               DS.B 1  ;Alte Synchrnoisationsfrequenz
old_porta:              DS.B 1  ;Alter PortA Wert
screen_counter:         DS.W 1  ;fÅr Screensaver
music_prg:              DS.W hippel_len/2 ;16 Kbyte fÅr Hippelsound

user_prg_len:           DS.L 1  ;tatsÑchliche LÑnge der Userprogramme
user_prg1:              DS.L 1  ;Pointer auf Userprogramme
user_prg2:              DS.L 1

;-------------------- BSS fÅr MJAR

mjar_palpointer:        DS.L 1  ; Pointer auf alte Palette
mjar_destpointer:       DS.L 1  ; Pointer auf neu erstellte Grafik
mjar_planespointer:     DS.L 5  ; 5 Pointer fÅr Sourcegrafik
dest_cols_anzahl:       DS.W 1
offset_plane1:          DS.W 1  ; Abstand in Bytes von einer Plane zur selben Plane
offset_plane2:          DS.W 1  ; Abstand in Bytes von einer Plane zur selben Plane
offset_plane3:          DS.W 1  ; Abstand in Bytes von einer Plane zur selben Plane
offset_plane4:          DS.W 1  ; Abstand in Bytes von einer Plane zur selben Plane
offset_plane5:          DS.W 1  ; Abstand in Bytes von einer Plane zur selben Plane
anzahl_pixel_pro_color: DS.W 32 ; fÅr max. 32 Farben die HÑufigkeit im Bild
col_number_tab:         DS.B 32 ; dort stehen die Farbnummern drin (0-31)
shorten_palette:        DS.W 16 ; neue gekÅrzte Palette
mjar_transfer_numbers:  DS.B 32 ; dort steht drin welche Farbe auf welche Farbe angepasst wird
mjar_scanline:          DS.B 320 ; dort kommen 320 Farbwerte rein
plot_data_preshiftet:   DS.B 2048 ; pregeshiftete Plotdaten

;BSS fÅr jack_remap
pos_objektx:            DS.W 1  ;Position, an der Copybox ausgeschnitten wurde
pos_objekty:            DS.W 1  ;Aber unter BerÅcksichtigung von grab_y
objekt_palette:         DS.W 16 ;Palette des aktuellen Objekts
stefflcolmark:          DS.W 1  ; Linke Schranke der Palette
steffrcolmark:          DS.W 1  ; Rechte Schranke
anzbitblocks:           DS.W 1  ; Anzahl der Bitblocks der Copybox
anzscanlines:           DS.W 1  ; soviele Scanlines hoch
anzcolors:              DS.W 1  ; Anzahl der zu bearbeitenden Farben
colpos:                 DS.W 1  ; dort ist die gefundene Farbe

rÅcksprungadr:          DS.L 1  ;RÅcksprungadr bei set_box

ani_obj_vbl:            DS.W 1  ;Alter VBL-Wert bei letztem Objekt
sequenzen:              DS.W seq_max*4 ;Linker, rechter Rand, speed (animate),pos

plotx:                  DS.W 1
ploty:                  DS.W 1

linea_base:             DS.L 1  ;Basisadresse der Linea-Variablen
old_logbase:            DS.L 1  ;Alte Logische Bildschirmadresse

font6x6:                DS.L 1  ;Pointer auf den 6x6-Font
font8x8:                DS.L 1  ;Pointer auf den 8x8-Font

bb:                     DS.W 66 ;Platz fÅr eine BITBLT

tos_version:            DS.W 1  ;Hier steht z.B. $0104 fÅr TOS 1.4

mem_cutter:             DS.L 1  ;Adresse des Cut-Buffers
mem_lÑnge:              DS.L 1  ;LÑnge des Cut-Buffers

load_flag:              DS.B 1  ;0=Laden, 1=Speichern fÅr Fileselector
fsel_path:              DS.B 130 ;Pfad, den der Fileselctor zurÅckgibt
old_fn:                 DS.B 14 ;Alter Filename bei Fileselector

oldvblvotze:            DS.L 1  ; Kurzspeicher fÅr Setres.
newrez:                 DS.W 1  ; ditto
cut_path:               DS.B 120 ;Pfad des Cutters
cut_file:               DS.B 20 ;Filename des Cutters
load_path:              DS.B 120 ;Pfad zum Laden eines Neochrome-Bildes
save_path:              DS.B 120 ;Pfad zum Speichern eines Neochrome-Bildes
umsort_buff:            DS.W 21 ;Buffer zum Umsortieren der Planes
just_palette:           DS.B 1  ;Nur Palette geladen?
filenamen:              DS.L 1  ;Zeiger auf den Filenamen des aktuellen Ladebildes

                        EVEN
dta:                    DS.B 21 ;Internal Use of Gemdos
dta_attrib:             DS.B 1  ;attrib
dta_time:               DS.W 1  ;Uhrzeit
dta_date:               DS.W 1  ;Datum
dta_size:               DS.L 1  ;Size
dta_filename:           DS.B 14 ;Filenamen

                        EVEN
chunk_header:                           ;fÅr IFF-Laderoutine
chunk_id:               DS.L 1  ;Namen des Chunks
chunk_len:              DS.L 1  ;LÑnge des Chunks


** benîtigte Variablen fÅr IFF-Loader Part 2

iff_breite:             DS.W 1  ;Breite des gespeicherten Bildes
iff_hoehe:              DS.W 1  ;Hîhe des gespeicherten Bildes
iff_planes:             DS.B 1  ;Anzahl Planes
iff_mask:               DS.B 1  ;Wurde Maske gespeichert ? (1 = ja / 0 = nein )
iff_compression:        DS.B 1  ;Compression eingeschalten ? ( 0 = aus)

                        EVEN

iff_colormap:           DS.B 4*32 ;32 RGB color (1 dummy byte)
iff_ataricolor:         DS.B 4*16 ;16 RGB color (1 dummy byte)


iff_farbtabelle:        DS.B 128 ;(128 freie Bytes) ???

iff_converttab:         DS.B 32 ;(Zielfarben)

                        EVEN

iff_countcolor:         DS.L 32 ;Hier wird Anzahl der Punkte pro
*                                Farbe festgehalten !


***  Ende ***  benîtigte Variablen fÅr IFF-Loader Part 2


old_timer_b:            DS.L 1

maus_status:            DS.B 1  ;Alter Wert der Mausbutton fÅr Save Copybox
fernsteuerung:          DS.B 1  ;Flag, ob Mausklick durch tastatur gesteuert wird.
old_mx:                 DS.W 1  ;Alte Position der Maus, vor Fernsteuerung
old_my:                 DS.W 1  ;-'-
old_mkey:               DS.W 1  ;-'-
old_conterm:            DS.B 1  ;Alter Status von $484.w
mausposx:               DS.W 1
mausposy:               DS.W 1  ;Position der Maus bei der letzten Abfrage
mauskeys:               DS.W 1
and_modus:              DS.B 1  ;Welcher Modus bei AND-Funktion
step_rot:               DS.W 1
step_gruen:             DS.W 1  ;FÅr Calc_colors
step_blau:              DS.W 1
start_rot:              DS.W 1
start_gruen:            DS.W 1
start_blau:             DS.W 1
logo_typ:               DS.W 1  ;Type des Logos, 0=keins,1=Big,2=Small

brush:                  DS.W 1  ;Brush(=0) oder Nozzle(!=0) aktiv
stackpointer:           DS.L 1  ;Stackpointer in mainloop

a_alias_palpoint:       DS.L 1  ; Pointer auf aktuelle Palette
a_alias_graphpoint:     DS.L 1  ; Pointer auf zu antialiasende Grafik
breite_in_pixel:        DS.W 1
breite2_in_worte:       DS.W 1
bytes_pro_scanline:     DS.W 1
hoehe_in_scanlines:     DS.W 1
bitblocks_pro_scanline: DS.W 1
a_alias_ste_flag:       DS.W 1

colbytes1:              DS.B 322 ; Daten fÅr Zeile 1
colbytes2:              DS.B 322 ; Daten fÅr Zeile 2
colbytes3:              DS.B 322 ; Daten fÅr Zeile 3
work_colbytes:          DS.B 322 ; dortdrin wird die Scanline erstellt

similar_colstab:        DS.B 4096 ; Platz fÅr 4096 éhnlichekeitswerte
rgb_nibbletab:          DS.W 4*16 ; dort wird die Palette in R,G,B aufgespalten

used:                   DS.B 10 ;Welcher Screen wird fÅr Objecte benutzt
anz_screens:            DS.W 1  ;Anzahl der Workscreens
start_screens:          DS.L 1  ;Adresse des Speicherblocks der Screens
work_tab:               DS.L 10 ;Platz fÅr die Pointer auf die Screens
scancode:               DS.W 1  ;PLatz fÅr speichern des Scancodes bei Screensabfrage
;workscreens:    DS.B 256+32000*4 ;Die weiteren Workscreens+Rotatebuffer
platz_screen:           DS.B 256+32000 ;Platz fÅr den Rotate Buffer
rotate_buffer:          DS.L 1  ;Zeiger auf den Rotierbuffer hinter den Workscreens

hîhe_old:               DS.W 1  ;Alte Ausmaûe der Rotatebox
breite_old:             DS.W 1
akt_winkel:             DS.W 1  ;Aktueller Winkel bei Rotate
rotate_gefÅllt:         DS.B 1  ;Ist der Buffer gefÅllt?

scrollpointer1:         DS.L 1  ; Pointer auf Panel
scrollpointer2:         DS.L 1
kamm_screen1:           DS.L 1
kamm_counter:           DS.W 1  ; ZÑhler fÅr Intro
aufzieh_typ:            DS.W 1  ;Art des Vergrîûerns des Rahmens bei do_cutter:
; -----------------
; |    |     |    |
; | 0  |  1  | 2  |
; -----------------
; |    |     |    |
; | 3  | 4   | 5  |     ;Feld in das zur Vergrîûerung geklickt wurde
; |    |     |    |
; -----------------
; |    |     |    |
; | 6  |  7  |  8 |
; -----------------
pos_x:                  DS.W 1  ;position der Maus vor Verschieben
pos_y:                  DS.W 1  ;-'-

ohne_raster:            DS.B 1  ;Objekt mit Raster abspeichern?
ani_x2:                 DS.W 1  ;Rechte Obere Ecke der Ani-Box
ani_y2:                 DS.W 1
ani_x3:                 DS.W 1  ;Linke untere Ecke der Ani-Box
ani_y3:                 DS.W 1

board:                  DS.B 16000
lupe_paint:             DS.B 1  ;Wird innerhalb der Lupe gezeichnet?
lupe_voll:              DS.W 20 ;Platz fÅr ausgefÅllte Lupenzeile
lupe_leer:              DS.W 20 ;Platz fÅr leere Zeile in der Lupe

lupen_gfx_preshift:     DS.B 4*8*16 ; Pregeshiftete Grafik fÅr die 4er Lupe
                        DS.B 2*8*16 ; Platz fÅr 8er Lupe

lupe_work_buffer:       DS.B 21*24 ; dort kommen korrigierte Bitblocks rein (Lupe)

                        EVEN
maus_print_x:           DS.B 2
maus_print_y:           DS.B 2
old_critic:             DS.B 4
rot_col_counter:        DS.B 2  ;Counter fÅr Geschwindigkeit der Color Animation

ap_id:                  DS.W 1  ;ID von NEOchrome
vdi_handle:             DS.W 1  ;Handle der virtuellen Workstation
control:                DS.W 16
int_in:                 DS.W 128
ptsin:                  DS.W 128
int_out:                DS.W 128 ;AES/VDI-Parameter
ptsout:                 DS.W 128
global:                 DS.W 15
addr_in:                DS.L 3
addr_out:               DS.L 1

komplettbild:           DS.B 4
scr1:                   DS.B 4
scr2:                   DS.B 4
cut_buff:               DS.B 4
irgend_copy:            DS.B 4
copybox_screen:         DS.B 4
mid_width:              DS.B 2
mid_height:             DS.B 2
mid_#_colors:           DS.B 2
old_rez:                DS.B 6
no_pic_load:            DS.B 2
old_ssp:                DS.B 4
fhandle:                DS.B 2
tos_pal:                DS.B 32
;save_path       DS.B 70
fsel_filename:          DS.B 64
L07CB:                  DS.B 2
L07CC:                  DS.B 2
stack:                  DS.B 1026
stackp:
mask_buff:              DS.B 8320
screen_mem:             DS.W (135936+7424*2)/2
L07D0:                  DS.B 2
L07D1:                  DS.B 2
L07D2:                  DS.B 2
L07D3:                  DS.B 2
L07D4:                  DS.B 2
L07D5:                  DS.B 2
L07D6:                  DS.B 2
L07D7:                  DS.B 2
objekt_x1:              DS.B 2  ;Position des Objektes (incl. grab_y)
objekt_y1:              DS.B 2
objekt_pointer:         DS.B 4
breite_bytes:           DS.B 2
cpy_buff_breite_bytes:  DS.B 2
objekt_x2:              DS.B 2  ;Dasselbe wie objekt_x1 (?)
objekt_y2:              DS.B 2
breite:                 DS.B 2  ;Darf keinesfalls kleiner als ani_x4-ani_x1+1 sein
hîhe:                   DS.B 2  ;-'-
breite_o1:              DS.B 2
hîhe_o1:                DS.B 2
breite_o2:              DS.B 2
hîhe_o2:                DS.B 2
L07E5:                  DS.B 2
L07E6:                  DS.B 2
L07E7:                  DS.B 68
L07E8:                  DS.B 2
L07E9:                  DS.B 2
L07EA:                  DS.B 2
L07EB:                  DS.B 2
L07EC:                  DS.B 2
L07ED:                  DS.B 2
old_vblcount:           DS.B 2
L07EF:                  DS.B 2
L07F0:                  DS.B 2
L07F1:                  DS.B 4
L07F2:                  DS.B 2
L07F3:                  DS.B 2
build_path:             DS.B 1024
L07F5:                  DS.B 2
L07F6:                  DS.B 6
vblcounter:             DS.B 2
rot_col_vbl:            DS.B 2
counter_box:            DS.B 2
L07FA:                  DS.B 2
L07FB:                  DS.B 2
bitblit:                DS.B 76
ani_x1:                 DS.B 2  ;linke obere Ecke der Ani-Box
ani_y1:                 DS.B 2  ;Hier erscheint bei Rotate das Objekt (Bildschirm)
ani_x4:                 DS.B 2  ;Rechte untere Ecke der Ani-Box
ani_y4:                 DS.B 2  ;tatsÑchliche Koordinaten auf scr1 (!)
L0801:                  DS.B 2
evt_timer_aus:          DS.B 2
get_mouse_button:       DS.B 2
mouseirq_x:             DS.B 2
mouseirq_y:             DS.B 2
L0806:                  DS.B 2
L0807:                  DS.B 2
lupe_hîhe:              DS.B 2
hbl_counter:            DS.B 2
;hbl_pos         DS.B 4
color:                  DS.B 2
save_grid:              DS.B 2
lupe:                   DS.B 416
last_hbl_pal:           DS.B 26 ;Zeile unter dem Rand
L080F:                  DS.B 2
L0810:                  DS.B 2
L0811:                  DS.B 2
right_line_color:       DS.B 2
left_line_color:        DS.B 2
L0814:                  DS.B 4
L0815:                  DS.B 2
L0816:                  DS.B 2
L0817:                  DS.B 2
L0818:                  DS.B 2
L0819:                  DS.B 2
L081A:                  DS.B 2
L081B:                  DS.B 2
L081C:                  DS.B 2
palette_undo:           DS.B 32 ;Zum Undo einzelner Farben
save_sp:                DS.B 4
L081F:                  DS.B 2
handle:                 DS.B 2
button_klicked:         DS.B 2  ;Der Button, der z.B. bei Save_data angeklickt
akt_shape:              DS.L 1  ;Pointer auf aktiven Brush
filename:               DS.B 40
L0824:                  DS.B 2
L0825:                  DS.B 2
L0826:                  DS.B 2
L0827:                  DS.B 2
L0828:                  DS.B 2
L0829:                  DS.B 2
L082A:                  DS.B 2
L082B:                  DS.B 2
L082C:                  DS.B 2
L082D:                  DS.B 4
L082E:                  DS.B 4
L082F:                  DS.B 4
L0830:                  DS.B 4
L0831:                  DS.B 4
L0832:                  DS.B 4
L0833:                  DS.B 70
L0834:                  DS.B 60


                        END

;Fileformat des Objekt-Files:

; char header[6];           /* Header des Files 'NEOOBJ' */
; int version;              /* Versionsnummer des Files */
; int anzahl_pics;          /* Anzahl der benîtigten NEO-Screens */
; struct pic {
;   char bild_nr;           /* Diese Struktur kommt so oft, wie anzahl_pics */
;   char filename[13];      /* angibt */
;   } fn[anzahl_pics];
; long dateilaenge;         /* LÑnge der nachfolgenden Daten */
; int anzahl;               /* Zahl der Objekte in der Datei */

;Dann kommt fÅr soviel Objekte wie es hat die folgende Struktur:
; ( 0) long offset;              /* Offset auf Objekt relativ zu Objektheader[0] */
; ( 4) int breite;               /* Breite des Objekts in Pixeln */
; ( 6) int hoehe;                /* Hîhe des Objekts in Pixeln */
; ( 8) unsigned char maske;      /* Hat Objekt eine Maske (unbenÅtzt) */
; ( 9) unsigned char planes;     /* Wieviel Planes hat Objekt */
; (10) int breite_bytes;         /* Breite des Objekts in Bytes */
; (12) int x_neo;                /* Position innerhalb Neochrom-Bild */
; (14) int y_neo;                /* -'- */
; (16) long reserved;            /* Reserved for future use
;                              Bit 0-1: Bildnummer, in der Ob
                        END
