








                 ENhanCed Hisoft ApplicatioN toolkiT (ENCHANT)
                    Developed by Matthew Bacon & Paul Jones

           ENCHANT is Copyright 1997-1999 Matthew Bacon & Paul Jones
                          Revision 12th September 1999














תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת ENCHANT Modules

  \ENCHANT\MODULES\
  ת Global variables
  ת BUBBLE.BAS                         ת MIDI.BAS
  ת CALC.BAS                           ת NVDI.BAS
  ת CLIPBORD.BAS                       ת PRINTER.BAS
  ת CURSOR.BAS                         ת PROTOCOL.BAS
  ת CYPHER.BAS                         ת SAMPLES.BAS
  ת DATETIME.BAS                       ת SORT.BAS
  ת DISK.BAS                           ת ST-GUIDE.BAS
  ת ERROR.BAS                          ת SYSTEM.BAS
  ת FILE.BAS

  For your program to use any of the routines within the ENCHANT modules
  (see above), the required modules file/s must first be declared at the
  start of your program. This is achieved by including the following line of
  code at the start of your source code.

                           REM $include ????????.BAS

  Where ???????? is the name of the file defind by the routines described
  below, i.e. REM $include BUBBLE.BAS etc.

  NB: The instructions and command list for NVDI.BAS are located in the
      file NVDI_MAN.TXT

          תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת Global variables
  The term 'global variable' applies to a variable that can be accessed from
  anywhere within the source code, thus a static or local variable (or
  resource object label) should NOT be one of the following.

  junk,junk!,MyProgram$,err_advice$,dummy,dummy!,dummy$,temp,temp!,temp$

  ת MyProgram$ is a string which should contain the name of your program. It
    is used in alert boxes and window title bars.

    Example: MyProgram$="ENCHANT"

ת FUNCTION BubbleGEM()
  - Include the file: BUBBLE.BAS

  - Syntax:
    BubbleGEM (message$)

  - Effect:
    Display's a help bubble using the BubbleGEM protocol by Thomas Much.

  - Comments:
    BubbleGEM provides you the programmer, with a protocol through which you
    can add speech bubbles to improve your programs interface and usability.
    BubbleGEM requires a multitasking operating system such as MagiC,
    MultiTOS, N.AES or Geneva.

    BubbleGEM aware programs send a message and pass a character string to
    BubbleGEM if the user right mouse button clicks on an icon, button or
    window area. BubbleGEM then displays the character string (message$)
    formatted in a cute speech bubble which remains displayed until the user
    presses a key or another event. Of course, BubblGEM must first be
    installed by the user. Please read the BubbleGEM documentation for all
    the latest conventions of use!

  - See Also:
    BubbleGEM_Font()

  - Example:
    result=BubbleGEM ("Welcome to ENCHANT!")

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The help bubble was successfully displayed                 |
    |     0     | The help bubble could not be displayed                     |
     ------------------------------------------------------------------------


ת FUNCTION BubbleGEM_Font()
  - Include the file: BUBBLE.BAS

  - Syntax:
    BubbleGEM_Font (font_no,point_size)

  - Effect:
    Changes the font used by the BubbleGEM protocol by Thomas Much.

  - Comments:
    BubbleGEM provides you the programmer, with a protocol through which you
    can add speech bubbles to improve your programs interface and usability.
    BubbleGEM requires a multitasking operating system such as MagiC,
    MultiTOS, N.AES or Geneva.

    BubbleGEM aware programs send a message and pass a character string to
    BubbleGEM if the user right mouse button clicks on an icon, button or
    window area. The example below shows how to reset to the system font (0)
    and point size (10). Really and truly, this function should only be used
    by the desktop as it effects BubbleGEM globally when used within a
    multitasking OS.

    Of course, BubblGEM must first be installed by the user. A copy of the
    BubbleGEM is available from the public domain.

  - See Also:
    BubbleGEM()

  - Example:
    result=BubbleGEM_Font (0,10)

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The font was successfully changed                          |
    |     0     | The font could not be changed                              |
     ------------------------------------------------------------------------


ת FUNCTION calculate#()
  - Include the file: CALC.BAS

  - Syntax:
    calculate# (a#,b#,calc_type)

  - Effect:
    Allows quick access to those everyday calculations.

  - Comments:
    The example below would add the variables '10' and '2.35' together
    resulting in the variable 'result#' equalling '12.35'. For a full list of
    supported calculation commands see file CALC.BAS (feel free to include new
    calculations (formulas etc.)).

  - See Also:

  - Example:
    result#=calculate# (10,2.35,calc_add)


ת FUNCTION Valid_Text()
  - Include the file: CALC.BAS

  - Syntax:
    Valid_Text (text$,dummy)

  - Effect:
    Routine returns the value zero if the string variable, text$, is not
    'dummy' characters in length.

  - Comments:

  - See Also:

  - Example:
	text$="12345" : dummy=4
    result=Valid_Text (text$,dummy)

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The string variable, text$ is 'dummy' characters in length |
    |     0     | The string variable, text$ is not 'dummy' characters in    |
    |           | length                                                     |
     ------------------------------------------------------------------------


ת FUNCTION Valid_Digit()
  - Include the file: CALC.BAS

  - Syntax:
    Valid_Digit (text$,dummy)

  - Effect:
    Routine returns the value zero if the string variable, text$, is not
    'dummy' characters in length.

  - Comments:

  - See Also:

  - Example:
	text$="12345" : dummy=4
    result=Valid_Text (text$,dummy)

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The string variable, text$ is 'dummy' characters in length |
    |     0     | The string variable, text$ is not 'dummy' characters in    |
    |           | length                                                     |
     ------------------------------------------------------------------------


ת FUNCTION GetClipboard$
  - Include the file: CLIPBRD.BAS

  - Syntax:
    GetClipboard$

  - Effect:
    Locates the systems clipboard/scrap folder in which the files SCRAP.TXT,
    SCRAP.RTF, SCRAP.IMG may be held.

  - Comments:
    result$ contains the full drive and path (A, B, C etc.) to which your
    program can save data.

  - See Also:
    SetClipboard$, scrp_read()

  - Example:
    result$=GetClipboard$


ת FUNCTION SetClipboard()
  - Include the file: CLIPBRD.BAS

  - Syntax:
    SetClipboard (path$)

  - Effect:
    Sets the systems clipboard/scrap directory to which the files SCRAP.TXT,
    SCRAP.RTF, SCRAP.IMG should be located.

  - Comments:
    path$ should contain the full drive and path (A, B, C etc.).

  - See Also:
    GetClipboard$, scrp_write()

  - Example:
    result=SetClipboard ("C:\CLIPBRD\")

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The directory was successfully changed                     |
    |     0     | The directory could not be changed                         |
     ------------------------------------------------------------------------


ת SUB update_mouse
  - Include the file: CURSOR.BAS

  - Syntax:
    update_mouse

  - Effect:
    Changes the form of the mouse pointer to a groovy spinning wheel! - try it
    and see!

  - Comments:
    With the likes of Papyrus and the HiSoft Editor using the flashy revolving
    mouse pointer (when the Editor compiles) instead of the boring bumble bee
    used by GEM, this routine allows you to do the same!  The only limitation
    is that a GEM window must always be displayed when using this call.

    Of course the example above is not really practical as you cannot access
    any other routines, therefore it is suggested that this call should be
    interspersed within your own source code when needed (like loading a file
    etc.), see examples - Have fun!

  - See Also:

  - Example:
    i=0
    DO
        INCR i
        IF i=1 THEN CALL update_mouse
        IF i=600 THEN CALL update_mouse
        IF i=1200 THEN CALL update_mouse
        IF i=1800 THEN CALL update_mouse
        IF i=1900 THEN CALL update_mouse : i=0
    LOOP UNTIL INKEY$<>""


ת FUNCTION ENCODE_ULTIMO$()
ת FUNCTION DECODE_ULTIMO$()
  - Include the file: CYPHER.BAS

  - Syntax:
    ENCODE_ULTIMO$ (source$,keyword$,range_frm$,range_too$)
    DECODE_ULTIMO$ (source$,keyword$,range_frm$,range_too$)

  - Effect:
    To transform normal text into unreadable text and back again!!

  - Comments:
    Cyphers are machines or routines that transform ordinary text into
    unreadable/scrambled text making it totally unreadable!!  There are many
    ways in which text can be cyphered (also known as encrypted). Cyphers have
    existed since the Roman Empire, being mainly used for military purposes to
    keep important information from being understood if intercepted.

    Since the early 70's encryption has been used for other purposes and by
    other organisations such as banks and governments. ENCHANT contains two
    cyphering routines, ULTIMO & ENIGMA (both developed specifically for
    ENCHANT).

    - 'source$' contains the text you would like to encrypt
    - 'keyword$' contains a unique keyword (min. 3 characters)
    - 'range_frm$' contains a single ASCII character defining the far left
       ASCII character to use within the encryption process
    - 'range_too$' contains a single ASCII character defining the far right
       ASCII character to use within the encryption process (needs to be
       higher in ASCII value than 'range_frm$')

    * For any ASCII character (value 0 to 255) that lays outside the range set
      by 'range_frm$' - 'range_too$' in source$ will be ignored!

    e.g. source$="I love my Atari!"
         keyword$="Atari"
         range_frm$=" "
         range_too$="z"

    result$=FUNCTION ENCODE_ULTIMO$ (source$,keyword$,range_frm$,range_too$)

    would produce... /9r+)K9s5.'2g.wb

    "/9r+)K9s5.'2g.wb" = encrypted version of "I love my Atari!"

    source$="/9r+)K9s5.'2g.wb"
    keyword$="Atari"
    range_frm$=" "
    range_too$="z"

    result$=FUNCTION DECODE_ULTIMO$ (source$,keyword$,range_frm$,range_too$)

    would produce... I love my Atari!

    Although it may initially look hard to crack (break the code and workout
    the original text of "I love my Atari!"), I can assure you that it would
    still be possible... eventually!

  - See Also:

  - Example:
    result$=ENCODE_ULTIMO$ ("I love my Atari!","Atari"," ","z")
    result$=DECODE_ULTIMO$ ("/9r+)K9s5.'2g.wb","Atari"," ","z")


ת SUB CreateENIGMA()
  - Include the file: CYPHER.BAS

  - Syntax:
    CreateENIGMA (from_char$,too_char$,exceptions$,frequency!)

  - Effect:
    Creates a file ENIGMA.DAT file of ruse of FUNCTION ENIGMA$()

  - Comments:
    Before you can use the ENIGMA cypher routine, an ENIGMA.DAT file is
    required.

    - 'from_char$' contains a single ASCII character defining the far left
       ASCII character to use within the encryption process
    - 'too_char$' contains a single ASCII character defining the far right
       ASCII character to use within the encryption process (needs to be
       higher in ASCII value than 'from_char$')
    - 'exceptions$' contains any other ASCII characters not within the range
       (such as spacebar etc.)
    - 'frequency!' contains a variable 0 to 0.99, the higher the value the
       more random the rotor created!!

    * You can only use ASCII characters 14 to 255 (excluding 26)

    e.g. CALL CreateENIGMA ("A","Z"," 1234567890",0.95)

    might produce... (no randomly generated rotor should be the same)

    ABCDEFGHIJKLMNOPQRSTUVWXYZ 123456790  ' Characters to use
    34KLGHTUZ ABFPQMNXYSVWO5120CDRI67E9J  ' rotor 1 (random order)
    QR67DEGHNOBCSMTUZ JK90IL45VF23APW1XY  ' rotor 2 (random order)
    WX90DEOPYKLNUV23MST4IJ1RZ 567ABQFHGC  ' rotor 3 (random order)
     CBEDGFQJI1MLONVHSR90PXW23AKYZ5476TU  ' reflector (0=U & U=0 etc.)

 - See Also:
   ENIGMA$()

  - Example:
    CALL CreateENIGMA (from_char$,too_char$,exceptions$,frequency!)


ת FUNCTION ENIGMA$()
  - Include the file: CYPHER.BAS

  - Syntax:
    ENIGMA$(source$,rotor1$,rotor2$,rotor3$,currot,r1out$,r2out$,r3out$,currotout)

  - Effect:
    To transform normal text into unreadable text and back again!!

  - Comments:
    Based on the ENIGMA machine (principles) used during World War II by the
    German armed forces, using a series of rotors (that move - the first rotor
    moves on a step until it reaches its original position at which point the
    next rotor moves on a step etc.) each time a character has been
    entered/read, ENIGMA (ENCHANT version) offers a maximum of 1,679,702,520
    possible permutations per character!!!, that's correct over 1 and a half
    billion!!  Now if you think that it's easy to break, think again!!

    Unlike the ULTIMO cypher which requires a separate encoding and decoding
    routine, ENIGMA is a self-inverse cypher. What that means is that if the
    character "A" was encyphered and produced the character "Z", then in the
    same rotor positions, "Z" would have produced "A".

    Before you can using the ENIGMA routine, you need to create a data file
    (ENIGMA.DAT) using the sub-routine CreateENIGMA(). Once the ENIGMA.DAT
    file has been created, the encryption of data can now begin.

    - 'source$' contains the original text you would like to encrypt
    - 'rotor1$' contains a single ASCII character (used in the DAT file) at
       which you would like the rotor to start
    - 'rotor2$' contains a single ASCII character (used in the DAT file) at
       which you would like the rotor to start
    - 'rotor3$' contains a single ASCII character (used in the DAT file) at
       which you would like the rotor to start
    - 'currot' contains the current turning rotor (this should be 1 the first
      time the routine is called)
    - 'r1out$' contains the ASCII character at which the rotor stopped
    - 'r2out$' contains the ASCII character at which the rotor stopped
    - 'r3out$' contains the ASCII character at which the rotor stopped
    - 'currotout' contains the value of the rotor which should move next
       (1,2,3)

    e.g. result$=ENIGMA$ ("I love my Atari!","3","Q","W",1,r1out$,r2out$,r3out$,currotout)

    might produce... 2GGYBOTJDM7XM7WZ

    "2GGYBOTJDM7XM7WZ" = encrypted version of "I love my Atari!"

    result$=ENIGMA$ (result$,r1out$,r2out$,r3out$,currotout,"","","",0)

    would then produce... I love my Atari!

    I know it looks difficult, but try it a few times and you'll soon be
    sending secret messages to everyone you know (of course they won't have a
    clue what your on about unless they have the same ENIGMA.DAT file!!)

  - See Also:
    CreateENIGMA()

  - Example:
    result$=ENIGMA$(source$,rotor1$,rotor2$,rotor3$,currot,r1out$,r2out$,r3out$,currotout)


ת FUNCTION dateform$()
  - Include the file: DATETIME.BAS

  - Syntax:
    dateform$ (form,separator$)

  - Effect:
    Returns the correct current date!

  - Comments:
    'form' uses the following values to provide the correct format of the
    date:

     ------------------------------------------------------------------------
    |   form   | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Uses _IDT cookie value                                      |
    |     0    | MM DD YYYY                                                  |
    |     1    | DD MM YYYY                                                  |
    |     2    | YYYY MM DD                                                  |
    |     3    | YYYY DD MM                                                  |
     ------------------------------------------------------------------------

    To overwrite the IDT separator, make separator$ equal to the ASCII
    character of the separator.

    e.g. separator$="/"

    * The _IDT cookie howeveris only available from AES v3.30 or above!

  - See Also:

  - Example:
    result$=dateform$ (form,separator$)


ת FUNCTION timeform$()
  - Include the file: DATETIME.BAS

  - Syntax:
    timeform$ (form)

  - Effect:
    Returns the correct current time (2000 compliant!)

  - Comments:
    'form' uses the following values to provide the correct format of the
    time:

     ------------------------------------------------------------------------
    |   form   | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Uses _IDT cookie value                                      |
    |     0    | 12 hours                                                    |
    |     1    | 24 hours                                                    |
     ------------------------------------------------------------------------

    If the option is for 12 hour, the clock time will be returned with either
    "am" or "pm" attached at the end of the string. This will no occur for the
    24 hour clock.

    * The _IDT cookie howeveris only available from AES v3.30 or above!

  - See Also:

  - Example:
    result$=timeform$ (form)


ת FUNCTION freediskspace&()
  - Include the file: DISK.BAS

  - Syntax:
    freediskspace& (drive)

  - Effect:
    Returns the free disk space on the requested drive.

  - Comments:
    'drive' must use the following value when passed in this function.

     ------------------------------------------------------------------------
    |  drive  | Meaning                                                      |
     ------------------------------------------------------------------------
    |    0    | Current drive                                                |
    |    1    | Drive A (internal)                                           |
    |    2    | Drive B                                                      |
    |    3    | Drive C                                                 etc. |
     ------------------------------------------------------------------------

  - See Also:

  - Example:
    result&=freediskspace& (0)

    'result&' contains the value of the total free space on the drive
    requested.


ת FUNCTION ConvDisk()
  - Include the file: DISK.BAS

  - Syntax:
    ConvDisk (drive$)

  - Effect:
    Converts the string 'drive$' into the variable value used for the
    function CopyDisk (see below).

  - Comments:

  - See Also:
    CopyDisk()

  - Example:
    result=ConvDisk ("A")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    0     | Drive A (internal)                                          |
    |    1     | Drive B                                                     |
    |    2     | Drive C                                                etc. |
     ------------------------------------------------------------------------


ת FUNCTION CopyDisk()
  - Include the file: DISK.BAS

  - Syntax:
    CopyDisk (drvsrc$,drvdest$,format,verify,copies)

  - Effect:
    Copies a disk in drive 'drvsrc$' (source disk) to drive 'drvdest$'
    (destination disk)

  - Comments:
    If 'format' or 'verify' is passed with a value other than 0, then the
    routine will format/verify the destination disk (optional). If the
    destination disk is required to be formatted or verified, the copying
    process will be slowed down. 'copies' default value should be 1.

    The status of the copy process is relayed to the sub-routines...

    SUB RelaySourceProgress (drive$,no_sectors,track,side)
     and
    SUB RelayDestProgress (drive$,no_sectors,track,side,copy)

    These routines should be included in YOUR source code, to inform the user
    of YOUR program, to the status/progress of the copying.  A crude example
    of these routines is shown below.

    SUB RelaySourceProgress (drive$,no_sectors,track,side)
    STATIC dummy

    LOCATE 1 : PRINT track
    FOR dummy=1 TO no_sectors
        LOCATE 2 : PRINT dummy
    NEXT dummy
    LOCATE 3 : PRINT side
    END SUB

    SUB RelayDestProgress (drive$,no_sectors,track,side,copy)
    STATIC dummy

    LOCATE 1 : PRINT track
    FOR dummy=1 TO no_sectors
        LOCATE 2 : PRINT dummy
    NEXT dummy
    LOCATE 3 : PRINT side
    LOCATE 4 : PRINT copy
    END SUB

    * The file CURSOR.BAS is also required / or a dummy sub-routine called
      update_mouse.

    * The Esc. key may be used at any time to abort the copying procedure

  - See Also:
    ConvDisk(), FormatDisk()

  - Example:
    result=CopyDisk ("A","B",1,0,1)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The disk was successfully copied                            |
    |     0    | The disk could not be copied                                |
     ------------------------------------------------------------------------


ת FUNCTION FormatDisk()
  - Include the file: DISK.BAS

  - Syntax:
    FormatDisk (drvdest$,frmsectors,frmtracks,frmsides,verify)

  - Effect:
    Formats a disk.

  - Comments:
    If 'verify' is passed with a value other than 0, then the routine will
    check if the file successfully reached its destination (optional).

    The disk structure requires a minimum of 1 sector, 1 track and 1 side.
    However, a SD disk may hold safely a max. 11 sectors/82 tracks/1 side
    only, DD disk a max. 11 sectors/82 tracks/2 sides and HD disk a max. 22
    sectors/82 tracks/2 sides. The MS-DOS standard format is 9 sectors and 80
    tracks. This will allow you to use your disks in a PC drive (other
    combinations may not be so successful).

    * The file CURSOR.BAS is also required / or a dummy sub-routine called
      update_mouse.

    * The Esc. key may be used at any time to abort the formatting procedure

  - See Also:
    CopyDisk()

  - Example:
    result=FormatDisk ("A",9,80,2,0)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The destination disk was successfully formatted             |
    |     0    | The destination disk could not be formatted                 |
     ------------------------------------------------------------------------


ת FUNCTION ReportError$()
  - Include the file: ERROR.BAS

  - Syntax:
    ReportError$ (error_no)

  - Effect:
    Returns a meaningful explanation of the error that has occurred rather
    than the operating system returning a none descriptive error number.

  - Comments:
    The global string err_advice$ returns in most cases comprehensive advice
    for the fault that occurred (but really should not be used in an alert
    box as they tend to be too long!).

  - See Also:
    ERR

  - Example:
    ErrorString$=ReportError$ (ERR)
    read_advice$=err_advice$

    button=form_alert(1,"[1][  ERROR: "+ErrorString$+" ][ Abort ]")


ת FUNCTION CopyFile()
  - Include the file: FILE.BAS

  - Syntax:
    CopyFile (source$,dest$,verify)

  - Effect:
    Copy a file from 'source$' to 'dest$'

  - Comments:
    source$ & dest$ must contain the full directory path, not just the file
    name, otherwise an error will be returned.

    e.g. FUNCTION CopyFile("COPYME.TXT","TOHERE.TXT",1)          is wrong!

         FUNCTION CopyFile("A:\COPYME.TXT","B:\TOHERE.TXT",1)    is correct!

    If 'verify' is passed with a value other than 0, then the routine will
    check if the file successfully reached its destination (optional). The
    result of this request is returned in the global variable 'VerifyCopy'.

     ------------------------------------------------------------------------
    |  VerifyCopy  | Meaning                                                 |
     ------------------------------------------------------------------------
    |      -1      | The file was successfully verified                      |
    |       0      | The file could not be verified                          |
     ------------------------------------------------------------------------

  - See Also:

  - Example:
    result=CopyFile ("A:\EXAMPLE.TXT","B:\FOLDER\EXAMPLE.TXT",1)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The file was successfully copied                            |
    |     0    | The file could not be copied to its destination             |
     ------------------------------------------------------------------------


ת FUNCTION DeleteFile()
  - Include the file: FILE.BAS

  - Syntax:
    DeleteFile (source$)

  - Effect:
    Delete a file safely!

  - Comments:
    source$ must contain the full directory path, not just the file name,
    otherwise an error will be returned.

    e.g. FUNCTION DeleteFile("COPYME.TXT")       is wrong!

         FUNCTION DeleteFile("A:\COPYME.TXT")    is correct!

  - See Also:

  - Example:
    result=DeleteFile ("A:\ANY_FILE.TXT")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The file was successfully deleted                           |
    |     0    | The file could not be deleted                               |
     ------------------------------------------------------------------------


ת FUNCTION DeleteFolder()
  - Include the file: FILE.BAS

  - Syntax:
    DeleteFolder (source$,extension$)

  - Effect:
    Delete a folders contents safely!

  - Comments:
    source$ must contain the full directory path, as shown in the example
    above. This routine may also be used to delete a particular file extension
    within the directory given, see below.

    e.g. FUNCTION DeleteFolder("A:\LETTERS\*.BAK")

    This would delete all the files with the file extension .BAK in the folder
    'LETTERS' on drive A (Note: The folder 'LETTERS' is NOT deleted!).
    However, if you pass the extension as "", the extension "*.*" is assumed
    thus deleting everything (including the folder).

    From experimentation, I have found that the use of wildcards such as
    *.BA? deletes both files with extentions *.BAS and *.BAD!

  - See Also:

  - Example:
    result=DeleteFolder ("A:\FOLDER\","*.*")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The folder was successfully deleted                         |
    |     0    | The folder could not be deleted                             |
     ------------------------------------------------------------------------


ת FUNCTION CreateFolder()
  - Include the file: FILE.BAS

  - Syntax:
    CreateFolder (source$)

  - Effect:
    Create a folder safely!

  - Comments:
    source$ must contain the full directory path, as shown in the example
    above otherwise an error will be returned.

  - See Also:

  - Example:
    result=CreateFolder ("A:\FOLDER\")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The folder was successfully created                         |
    |     0    | The folder could not be created                             |
     ------------------------------------------------------------------------


ת FUNCTION RenameFile()
  - Include the file: FILE.BAS

  - Syntax:
    RenameFile (source$)

  - Effect:
    Rename a file safely!

  - Comments:
    source$ must contain the full directory path, not just the file name,
    otherwise an error will be returned.

    e.g. FUNCTION RenameFile("COPYME.TXT")       is wrong!

         FUNCTION RenameFile("A:\COPYME.TXT")    is correct!

  - See Also:

  - Example:
    result=RenameFile ("A:\ANY_FILE.TXT")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The file was successfully renamed                           |
    |     0    | The file could not be renamed                               |
     ------------------------------------------------------------------------


ת FUNCTION FileAttributes()
  - Include the file: FILE.BAS

  - Syntax:
    FileAttributes (source$,attribute,assign)

  - Effect:
    Get/Set the file attributes of file 'source$'.

  - Comments:
    If 'assign' is passed with a value other than 0, then the routine will set
    the file 'source$' with the attributes (see below), or read the attributes
    of the file 'source$'.

    'attribute' uses the following values.

     ------------------------------------------------------------------------
    |  attribute  | Meaning                                                  |
     ------------------------------------------------------------------------
    |      0      | Read Only                                                |
    |      1      | Hidden                                                   |
    |      2      | System                                                   |
    |      3      | Volume Label                                             |
    |      4      | Subdirectory                                             |
     ------------------------------------------------------------------------

    If reading the attributes of the file 'source$', the attributes are
    returned in a global variable 'FileAttr', which correspond the following
    values.

     ------------------------------------------------------------------------
    |  FileAttr  | Meaning                                                   |
     ------------------------------------------------------------------------
    |      1     | Read Only                                                 |
    |      2     | Hidden                                                    |
    |      4     | System                                                    |
    |      8     | Volume Label                                              |
    |     16     | Subdirectory                                              |
    |     32     | Archive                                                   |
     ------------------------------------------------------------------------

  - See Also:

  - Example:
    result=FileAttributes ("A:\FILE.TXT",attribute,1)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The file attributes were successfully set/read              |
    |     0    | The file attributes could not be set/read                   |
     ------------------------------------------------------------------------


ת FUNCTION memfree&
  - Include the file: FILE.BAS

  - Syntax:
    memfree&

  - Effect:
    Returns the amount of free memory of the system in bytes

  - Comments:

  - See Also:
	malloc&()

  - Example:
    result&=memfree&
    PRINT "Total memory free:"+str$(result&)


ת SUB clear_midi_buffer
  - Include the file: MIDI.BAS

  - Syntax:
    clear_midi_buffer

  - Effect:
    Clears any MIDI messages contained within the system MIDI buffer. The MIDI
    buffers address can be located by calling result&=iorec&(2).

  - Comments:

  - See Also:
    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    CALL clear_midi_buffer


ת SUB redirect_midi_buffer ()
  - Include the file: MIDI.BAS

  - Syntax:
    redirect_midi_buffer (midibuffer(),buffer_size)

  - Effect:
    Due to the 128 byte limitation of the systems MIDI buffer. This routine
    allows you to incease the MIDI buffer by setting up a new array.

  - Comments:

  - See Also:
    restore_midi_buffer

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
	DIM new_array(512)
    CALL redirect_midi_buffer (new_array(),512)


ת SUB restore_midi_buffer
  - Include the file: MIDI.BAS

  - Syntax:
    restore_midi_buffer

  - Effect:
    Restores the system MIDI buffer.

  - Comments:

  - See Also:
    redirect_midi_buffer()

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    CALL restore_midi_buffer


ת SUB play_s_midi ()
  - Include the file: MIDI.BAS

  - Syntax:
    play_s_midi (midi_byte(),midi_time!())

  - Effect:
    Plays back a single track of MIDI data, recorded by the call
    record_s_midi().

  - Comments:

  - See Also:
    record_s_midi()

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    CALL play_s_midi (midi_byte(),midi_time!())


ת SUB record_s_midi ()
  - Include the file: MIDI.BAS

  - Syntax:
    record_s_midi(midi_byte(),midi_time!(),rec_bytes)

  - Effect:
    Records a single track with a maximum of rec_bytes events of MIDI data,
    storing them in the array's midi_byte() & midi_time!() (these are defind
    by you).

  - Comments:

  - See Also:
    play_s_midi()

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    DIM midi_byte(512),midi_time!(512)
    CALL record_s_midi(midi_byte(),midi_time!(),512)


ת SUB play_all_midi ()
  - Include the file: MIDI.BAS

  - Syntax:
    play_all_midi (midi_byte(),midi_time!())

  - Effect:
    Plays back a maximum of 16 tracks of MIDI data simultaneously, recorded by
    the call record_all_midi().

  - Comments:
    You may wish to modify this routine as currently only note on and off MIDI
    messages are recognised.

  - See Also:
    record_all_midi()

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    CALL play_all_midi (midi_byte(),midi_time!())


ת SUB record_all_midi ()
  - Include the file: MIDI.BAS

  - Syntax:
    record_all_midi(midi_byte(),midi_time!(),channel,rec_bytes)

  - Effect:
    Records a single track at a time (maximum of 16), with of maximum of
    rec_bytes events of MIDI data, storing them in the array's midi_byte() &
    midi_time!() (these are defind by you).  Any previously recorded data on
    other MIDI channels is performed whilst recording!!

  - Comments:
    Plays back a maximum of 16 tracks of MIDI data simultaneously, recorded by
    the call record_all_midi().

  - Comments:
    You may wish to modify this routine as currently only note on and off MIDI
    messages are recognised.

  - See Also:
    play_all_midi()

    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    DIM midi_byte(512),midi_time!(512)
    CALL record_all_midi(midi_byte(),midi_time!(),1,512)


ת SUB midi_monitor
  - Include the file: MIDI.BAS

  - Syntax:
    midi_monitor

  - Effect:
    This routine waits for any MIDI message received by the computer and
    displays a list of those messages in both decimal and hex. I found this
    routine extremely useful when trying to find odd MIDI messages sent by
    my CASIO keyboard.

  - Comments:

  - See Also:
    ASCII documents within the "MIDI" folder on an ENCHANT master disk.

  - Example:
    CALL midi_monitor


ת For the following routines, please refer to the documentation on MIDI
  located in the "MIDI" folder on one of your ENCHANT master disks. As these
  calls are only really required when constructing MIDI files/MIDI
  programming, detailed knowledge (which can be gained for supplied texts) is
  first required.

  ת SUB midi_text (dummy$)
  ת SUB midi_copyright (dummy$)
  ת SUB midi_trackname (dummy$)
  ת SUB midi_instrument (dummy$)
  ת SUB midi_lyric (dummy$)
  ת SUB midi_marker (dummy$)
  ת SUB midi_cuepoint (dummy$)
  ת SUB midi_channel (dummy)
  ת SUB midi_port (dummy)
  ת SUB midi_EOT
  ת SUB note_off (channel,note,velocity)
  ת SUB note_on (channel,note,velocity)
  ת SUB aftertouch (channel,note,pressure)
  ת SUB controller (channel,cntrl,dummy)
  ת SUB program_change (channel,program)
  ת SUB channel_pressure (channel,dummy)
  ת SUB pitch_wheel (channel,dummy)
  ת SUB midi_start
  ת SUB midi_continue
  ת SUB midi_stop
  ת SUB midi_reset
  ת SUB cntrl_bank_select (channel,dummy)
  ת SUB cntrl_mod (channel,dummy)
  ת SUB cntrl_breath (channel,dummy)
  ת SUB cntrl_footpedal (channel,dummy)
  ת SUB cntrl_portamento (channel,dummy)
  ת SUB cntrl_data_entry (channel,dummy)
  ת SUB cntrl_volume (channel,dummy)
  ת SUB cntrl_balance (channel,dummy)
  ת SUB cntrl_pan (channel,dummy)
  ת SUB cntrl_expression (channel,dummy)
  ת SUB cntrl_FX1 (channel,dummy)
  ת SUB cntrl_FX2 (channel,dummy)
  ת SUB cntrl_sustain (channel,dummy)
  ת SUB cntrl_sustenuto (channel,dummy)
  ת SUB cntrl_softpedal (channel,dummy)
  ת SUB cntrl_chorus (channel,dummy)
  ת SUB all_notes_off
  ת SUB notes_off (channel)
  ת SUB omni_on (channel)
  ת SUB omni_off (channel)


ת FUNCTION ONLINE
  - Include the file: PRINTER.BAS

  - Syntax:
    ONLINE

  - Effect:
    Find out whether the printer is on or not!?

  - Comments:

  - See Also:

  - Example:
    result=ONLINE

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The printer is ON and reading to receive data               |
    |     0    | The printer is switched OFF                                 |
     ------------------------------------------------------------------------


ת FUNCTION printer_send()
  - Include the file: PRINTER.BAS

  - Syntax:
    printer_send (code$)

  - Effect:
    Send control codes to the printer.

  - Comments:
    A printers internal settings can be set by the user either by dip
    switches, found on pre-inkjet printers (generally), or by sending 'control
    codes' to the printer from the computer. For a list of control codes
    consult your printers manual or consult your dealer.

    PRINTER.BAS contains some control codes for EPSON printers and
    compatibles.

  - See Also:

  - Example:
    result=printer_send (prt_draft$)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The printer received the control codes                      |
    |     0    | The printer is switched OFF                                 |
     ------------------------------------------------------------------------


ת FUNCTION Protocol_send()
  - Include the file: PROTOCOL.BAS

  - Syntax:
    Protocol_send (application$,messtype,message$)

  - Effect:
    Send messages to other applications using the various protocols
    available for Atari computers (AV, ST-Guide, Kobold, OLGA etc.)

  - Comments:
    A "protocol", allows one program to communicate with another (this is
    extremely useful on a machine running a multi-tasking O/S). The protocols
    available at the present time include, displaying help bubbles
    (BubbleGEM), executing programs (AV), online hypertext information
    (ST-Guide)...

    For a full list of protocols supported, consult the latest GEMAES.BH file.
    Included with ENCHANT is example source code for a program that uses
    protocols.

    * the string application$ should be 8 characters long!

  - See Also:

  - Example:
    result=Protocol_send ("BUBBLE  ",bubblegem_show,"A help bubble!")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Protocol sent successfully                                  |
    |     0    | Protocol could not be sent/received                         |
     ------------------------------------------------------------------------



ת FUNCTION Protocol_receive()
  - Include the file: PROTOCOL.BAS

  - Syntax:
    Protocol_receive (id,message&,message$)

  - Effect:
    Receives a message from another application.

  - Comments:
    'id' contains the application number which sent the message
    'message&' contains the type of protocol message (see GEMAES.BH file)
    'message$' contains the string message sent

  - See Also:

  - Example:
    result=Protocol_receive (id,message&,message$)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Protocol has been received                                  |
    |     0    | Protocol has not been received                              |
     ------------------------------------------------------------------------


ת FUNCTION SampleInfoAVR ()
  - Include the file: SAMPLES.BAS

  - Syntax:
    SampleInfoAVR (BYVAL file$,sampleinfo$())

  - Effect:
    Provides information about AVR audio sample file, file$.  The
    information about the sample is placed into the string array
    sampleinfo$() which needs to be setup by you first! (see example)

    sampleinfo$(0)= Name of sample (if any)
    sampleinfo$(1)= "Mono" or "Stereo"
    sampleinfo$(2)= "8", "12" or "16" bit sample resolution
    sampleinfo$(3)= "Signed" or "Unsigned"
    sampleinfo$(4)= "Looped" or "Not looped"
    sampleinfo$(5)= "No midinote defined" or a string containing note value
    sampleinfo$(6)= "No reply speed defined" or a string containing replay
                    speed
    sampleinfo$(7)= String containing hertz of sample (i.e. 16000Hz)
    sampleinfo$(8)= Size of sample in bytes
    sampleinfo$(9)= "No loop start defined" or a string containing a pointer
                    to the location in memory of the start of the loop
    sampleinfo$(10)=String containing a pointer to the location in memory
                    of the end of the loop or the sample size again
    sampleinfo$(11)=User data (if any) (i.e. Clarity Falcon)

  - Comments:

  - See Also:
    PlaySample

  - Example:
    DIM sampleinfo$(15)
    result=SampleInfoAVR ("A:\SAMPLE.AVR",sampleinfo$())

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | No error occurred                                           |
    |     0    | Error occurred, information not provided - out of memory!   |
    |     1    | Error occurred, not an AVR file after all!                  |
     ------------------------------------------------------------------------


ת FUNCTION SampleHeader ()
  - Include the file: SAMPLES.BAS

  - Syntax:
    SampleHeader (BYVAL file1$,BYVAL file2$,BYVAL file3$)

  - Effect:
    Combines the samples header from file$ with the sample data of file2$,
    which is then saved in file3$ (all paths must be provided and in full!)

  - Comments:

  - See Also:

  - Example:
    SampleHeader ("A:\SAMPLE.AVR","A:\SAMPLE2.AVR","A:\SAMPLE3.AVR")

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | No error occurred                                           |
    |     0    | Error occurred, information not provided - out of memory!   |
     ------------------------------------------------------------------------


ת FUNCTION SamplePlay ()
  - Include the file: SAMPLES.BAS

  - Syntax:
    SamplePlay (BYVAL file$,BYVAL flags,freq&,BYVAL over_rate)

  - Effect:
    Plays any WAV, RAW, SAM (provided the Sound Audio Manager - SAM is
    available,  see the library named "WAVEPLAY" for details) or AVR samples
    on any STe/TT/Falcon.

    file$ should contain the full path including drive and directory

    FLAGS:
      WP_STEREO  =01 - stereo
      WP_MONO    =00 - mono

      WP_8BIT    =00 - 8bit
      WP_16BIT   =02 - 16bit

      WP_NOUSEDSP=00 - don't use the DSP (with AFM)
      WP_USEDSP  =04 - use the DSP (with AFM)

    FREQ& is the speed of playback:
      ACT_CLK50K&=49170              TT_CLK50K&=50066
      ACT_CLK33K&=33880              TT_CLK25K&=25033
      ACT_CLK25K&=24585              TT_CLK12K&=12517
      ACT_CLK20K&=20770              TT_CLK6K& =6258
      ACT_CLK16K&=16490
      ACT_CLK12K&=12292
      ACT_CLK10K&=9834
      ACT_CLK8K& =8195

    NB: TT_CLK6K& is not Falcon compatable.
    NB: When playing an AVR file, you may choose any frequency rate as
        ENCHANT can workout the necessary maths (as such does not need SAM
        to be installed!). However, this means there is a small delay while
        the "new sample" is worked!

    OVER_RATE is used when working out weird frequency rates for AVR
    files (see above):
    This can be any value you like, but I'd suggest you keep to below 24
    over sampling for time reasons!

  - Comments:

  - See Also:

  - Example:
    result= SamplePlay ("A:\SAMPLE.AVR",0,16689,16)   ' This uses ENCHANT
                                                        own AVR playback
    or                                                  routines

    result=SamplePlay ("A:\SAMPLE.AVR",WP_MONO+WP_8BIT,ACT_CLK16K&,0)

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1     | Error occurred, bad parameter (out of memory?)             |
    |     0     | No error, sample played                                    |
    |     1     | No error occurred, but was not played (SAM doesn't exist?) |
      ------------------------------------------------------------------------


ת SUB sort()
  - Include the file: SORT.BAS

  - Syntax:
    sort (array$(),start_index,stop_index)

  - Effect:
    This routine sorts a string array's contents from A-Z very quickly.

  - Comments:
    It is very important TO specify the 'start_index' and 'stop_index'
    positions for your array.

  - See Also:
    sort_multi()

  - Example:
    DIM myarray$(100)

    '... fill myarrary$() with data

    CALL sort (myarray$(),0,99) ' data in myarray$() is now sorted A-Z!


ת SUB sort_multi()
  - Include the file: SORT.BAS

  - Syntax:
    sort (array$(),array_index,start_index,stop_index)

  - Effect:
    This routine sorts a string array's contents from A-Z very quickly.

  - Comments:
    It is very important TO specify the 'start_index' and 'stop_index'
    positions for your array. This sort routine differs from sort() above
    as it can handle array's with more than one dimension.

  - See Also:
    sort()

  - Example:
    DIM myarray$(100,2)

    '... fill myarrary$() with data

    CALL sort (myarray$(),1,0,99) ' data in myarray$(,1) is now sorted A-Z!


ת FUNCTION STGuide()
  - Include the file: ST-GUIDE.BAS

  - Syntax:
    STGuide (path$,node$)

  - Effect:
    Display a help hypertext page using the ST-Guide protocol by
    Thomas Much.

  - Comments:
    ST-Guide provides you the programmer, with a protocol through which you
    can call context sensitive help without the user having to leave your
    program (as long as ST-Guide is running as an accessory or application). A
    must for every program you write!!!

    I'm sure you have all heard of ST-Guide with a majority of the top
    software (in particular, Public Domain) supporting it!  If you'd like
    further information, point you web browser at...
    http://www.cix.co.uk/~inactive/

    Before you can use this routine, you will first have to create a ST-Guide
    HYP file (see ST-Guide documentation). Included with ENCHANT is example
    source code for a program that uses ST-Guide.

    path$ must contain the full directory path, not just the file name,
    otherwise an error will be returned. node$ should contain the string of a
    node you have defined in your *.STG file (see ST-Guide documentation for
    further details).

  - See Also:

  - Example:
    result=STGuide ("C:\ENCHANT.HYP","Contents")

    IF result=0 THEN
        dummy$="ST-Guide help could not be provided"
        dummy2$="Check that ST-Guide is installed?"
        button=form_alert(1,"[1][  "+dummy$+" |  "+dummy2$+" ][ OK ]")
    END IF

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | ST-Guide successfully displayed the hypertext               |
    |     0    | ST-Guide could not display the hypertext                    |
     ------------------------------------------------------------------------


ת FUNCTION scr_x
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_x

  - Effect:
    Returns the screens furthest left position in pixels, usually 0.

  - Comments:

  - See Also:
	scr_y, scr_w, scr_h, scr_xywh

  - Example:
    result=scr_x
    PRINT result


ת FUNCTION scr_y
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_y

  - Effect:
    Returns the pixel position of the top of the screen, usually 0.

  - Comments:

  - See Also:
	scr_x, scr_w, scr_h, scr_xywh

  - Example:
    result=scr_y
    PRINT result


ת FUNCTION scr_w
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_w

  - Effect:
    Returns the physical screens width pixels.

  - Comments:

  - See Also:
	scr_x, scr_y, scr_h, scr_xywh

  - Example:
    result=scr_w
    PRINT result


ת FUNCTION scr_h
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_h

  - Effect:
    Returns the physical screens height in pixels.

  - Comments:

  - See Also:
	scr_x, scr_y, scr_w, scr_xywh

  - Example:
    result=scr_h
    PRINT result


ת SUB scr_xywh()
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_xywh (x,y,w,h)

  - Effect:
    x Returns the screens furthest left position in pixels, usually 0.
    y Returns the pixel position of the top of the screen, usually 0.
    w Returns the physical screens width pixels.
    h Returns the physical screens height in pixels.

  - Comments:

  - See Also:
	scr_x, scr_y, scr_w, scr_h

  - Example:
    CALL scr_xywh (x,y,w,h)
    PRINT x,y,w,h


ת FUNCTION scr_colours&
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_colours&

  - Effect:
    Returns the number of colours available on screen.

  - Comments:

  - See Also:

  - Example:
    result&=scr_colours&
    PRINT result&


ת FUNCTION scr_planes
  - Include the file: SYSTEM.BAS

  - Syntax:
    scr_planes

  - Effect:
    Returns the number of planes required to display the colours on screen.

  - Comments:

  - See Also:

  - Example:
    result=scr_planes
    PRINT result


ת FUNCTION cookie_cpu&
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_cpu&

  - Effect:
    Returns the type of CPU available in the computer.

  - Comments:

     ------------------------------------------------------------------------
    |   CPU   | Computer                                                     |
     ------------------------------------------------------------------------
    |  68000  | ST & STe                                                     |
    |  68020  | ST or STe upgraded                                           |
    |  68030  | Falcon030 & TT030                                            |
    |  68040  | Falcon040 (Afterburner upgraded) or TT030 upgraded           |
    |  68040  | Hades040 & Mendusa & Milan                                   |
    |  68060  | Hades040 & Mendusa                                           |
     ------------------------------------------------------------------------

  - See Also:

  - Example:
    result&=cookie_cpu&
    PRINT result&


ת FUNCTION cookie_vshift$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_vshift$

  - Effect:
    Returns the major/minor part number of the video shifter.

  - Comments:

  - See Also:

  - Example:
    result$=cookie_vshift$
    PRINT result$


ת FUNCTION cookie_fpu$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_fpu$

  - Effect:
    Returns the type of FPU (Floating Point Unit) fitted.

  - Comments:

  - See Also:

  - Example:
    result$=cookie_fpu$


ת FUNCTION cookie_fdc$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_fdc$

  - Effect:
    Returns the type of drive fitted (i.e. "1.44 Mb")

  - Comments:

  - See Also:

  - Example:
    result$=cookie_fdc$
    PRINT "This computer is fitted with a "+result$+" capacity drive."


ת FUNCTION cookie_machine$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_machine$

  - Effect:
    Returns the type of computer.

  - Comments:

  - See Also:

  - Example:
    result$=cookie_machine$
    PRINT "This is an Atari "+result$+" machine."


ת SUB cookie_lang$()
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_lang$ (lang_key$,lang_desk$)

  - Effect:
    Returns in lang_key$ the language used by the machine for the keyboard
    layout (i.e. USA or Turkey) Returns in lang_desk$ the language used by the
    machine for the desktop (i.e. Holland or Spain)

  - Comments:
    * The _AKP cookie howeveris only available from AES v3.30 or above!

  - See Also:

  - Example:
    CALL cookie_lang$ (lang_key$,lang_desk$)
    PRINT lang_key$
    PRINT lang_desk$


ת FUNCTION cookie_fsmc$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_fsmc$

  - Effect:
    Returns a string confirming whether or not SpeedoGDOS (or NVDI v3 and
    above) is available to the system.

  - Comments:

  - See Also:
    cookie_fsmc

  - Example:
    result$=cookie_fsmc$
    PRINT result$


ת FUNCTION cookie_fsmc
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_fsmc

  - Effect:
    Returns whether or not SpeedoGDOS (or NVDI v3 and above) is available to
    the system.

  - Comments:

  - See Also:
    cookie_fsmc$

  - Example:
    result=cookie_fsmc
    PRINT result

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | SpeedoGDOS is available                                     |
    |     0    | SpeedoGDOS is NOT available                                 |
     ------------------------------------------------------------------------


ת FUNCTION cookie_tasking$
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_tasking$

  - Effect:
    Returns whether a multitasking operating system is available or just plain
    vanilla singletasking TOS.

  - Comments:

  - See Also:

  - Example:
    result$=cookie_tasking$


ת FUNCTION max_progs
  - Include the file: SYSTEM.BAS

  - Syntax:
    max_progs

  - Effect:
    Returns the number of programs that can be run simultaneously within a
    multitasking environment.

  - Comments:
    A singletasking environment will only return the result '1'.

  - See Also:

  - Example:
    result=max_progs


ת FUNCTION cookie_sound()
  - Include the file: SYSTEM.BAS

  - Syntax:
    cookie_sound (result$)

  - Effect:
    Returns the type of sound support offered by the system.

  - Comments:
    result$ will contain a string 5 characters long. result$ can be
    interpreted as described below.

     ------------------------------------------------------------------------
    |  result$ char no.  | value | Meaning                                   |
     ------------------------------------------------------------------------
    |          1         |   0   | No ST style GI/Yamaha chip                |
    |          1         |   1   | ST style GI/Yamaha chip                   |
    |          2         |   0   | No 8-bit TT/STe style DMA sound           |
    |          2         |   1   | 8-bit TT/STe style DMA sound              |
    |          3         |   0   | No 16-bit Falcon030 style CODEC           |
    |          3         |   1   | 16-bit Falcon030 style CODEC              |
    |          4         |   0   | No 56001 DSP                              |
    |          4         |   1   | 56001 DSP                                 |
    |          5         |   0   | No Switch (connection matrix              |
    |          5         |   1   | Switch (connection matrix                 |
     ------------------------------------------------------------------------

    Therefore is result$="11000" then the Yamaha chip and DMA sound are
    available, but not the 16-bit CODEC, DSP and Switch connections.

  - See Also:

  - Example:
    result=cookie_sound (result$)
    PRINT result,result$

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Cookie is available                                         |
    |     0    | Cookie is NOT available, ignore result$                     |
     ------------------------------------------------------------------------


ת FUNCTION howmanydrives
  - Include the file: SYSTEM.BAS

  - Syntax:
    howmanydrives

  - Effect:
    Returns the number of floppy drives attached to the system. i.e. if there
    is only the internal floppy drive, this function will return the value
    '1'.

  - Comments:

  - See Also:

  - Example:
    result=howmanydrives


ת SUB set_howmanydrives()
  - Include the file: SYSTEM.BAS

  - Syntax:
    set_howmanydrives (drives)

  - Effect:
    Sets the number of floppy drives attached to the system. i.e. if there
    is only the internal floppy drive, it should be set to '1'. However if
    you don't want the user to have access to the disk drive (I can't think
    why!), it is possible to set it to '0'.

  - Comments:

  - See Also:

  - Example:
    CALL set_howmanydrives(1)


ת FUNCTION tosversion$()
  - Include the file: SYSTEM.BAS

  - Syntax:
    tosversion$ (tosdate$)

  - Effect:
    Returns a string, result$, containing the version number of the current
    operating system (TOS). The string in tosdate$ returns the date in which
    the operating system originated.

  - Comments:
    As it is possible for two completely different machines to upgrade to the
    same version of the operating system (such as the STFM & STe to TOS
    version 2.06), it is wise to use one or more of the other cookie routines
    described above to double check the status of the machine!

  - See Also:

  - Example:
    result$=tosversion$ (tosdate$)
    PRINT result$,tosdate$


ת FUNCTION autoGEM
  - Include the file: SYSTEM.BAS

  - Syntax:
    autoGEM

  - Effect:
    Returns whether the application has been run from the desktop or the AUTO
    folder.

  - Comments:

  - See Also:

  - Example:
    result=autoGEM

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | The application has been executed from the AUTO folder      |
    |     0    | The application has been executed from the desktop          |
     ------------------------------------------------------------------------


ת FUNCTION seekrate
  - Include the file: SYSTEM.BAS

  - Syntax:
    seekrate

  - Effect:
    Returns the seek rate used for the floppy drives in 'result'.

  - Comments:

  - See Also:

  - Example:
    result=seekrate


ת FUNCTION fverify
  - Include the file: SYSTEM.BAS

  - Syntax:
    fverify

  - Effect:
    Returns in 'result' whether disk verify is on or off.

  - Comments:

  - See Also:

  - Example:
    result=fverify

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    -1    | Verify is on                                                |
    |     0    | Verify is off                                               |
     ------------------------------------------------------------------------


ת FUNCTION bootdev
  - Include the file: SYSTEM.BAS

  - Syntax:
    bootdev

  - Effect:
    Returns the default boot device (drive) in 'result'.

  - Comments:

  - See Also:

  - Example:
    result=bootdev

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |     0    | Drive A                                                     |
    |     1    | Drive B                                                     |
    |     2    | Drive C                                                etc. |
     ------------------------------------------------------------------------


ת FUNCTION palmode
  - Include the file: SYSTEM.BAS

  - Syntax:
    palmode

  - Effect:
    Returns the screen refresh rate in 'result'.

  - Comments:

  - See Also:

  - Example:
    result=palmode

     ------------------------------------------------------------------------
    |  result  | Meaning                                                     |
     ------------------------------------------------------------------------
    |    60    | The screen refresh is 60Hz                                  |
    |    50    | The screen refresh is 50Hz                                  |
     ------------------------------------------------------------------------


ת SUB conterm()
  - Include the file: SYSTEM.BAS

  - Syntax:
    conterm (bell,click,key_repeat)

  - Effect:
    Through this sub-routine it is possible to set the system's bell, click
    and key_repeat on or off! Passing 0 turns the bell/click/key_repeat off,
    any other value turns them on.

  - Comments:

  - See Also:

  - Example:
    CALL conterm (0,0,-1) ' in this example, the bell and key click are off
                            while the key_repeat remains on


ת FUNCTION appl_id
  - Include the file: SYSTEM.BAS

  - Syntax:
    appl_id

  - Effect:
    This call returns the programs application 'id' number.

  - Comments:

  - See Also:

  - Example:
    result=appl_id


ת SUB MultiTOS_name ()
  - Include the file: SYSTEM.BAS

  - Syntax:
    MultiTOS_name (name$)

  - Effect:
    This call registers desk accessories in the 'Desk' menu and renames
    MultiTOS applications which appear there. name$ contains the title which
    is to appear in the 'Desk' menu for the accessory or application.

  - Comments:

  - See Also:

  - Example:
    CALL MultiTOS_name ("ENCHANT ")

תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת Updates from 12/11/1998 to 09/12/1998
  ת CALC.BAS
    - FUNCTION Valid_Text()

[END OF FILE]