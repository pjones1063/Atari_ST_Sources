








                 ENhanCed Hisoft ApplicatioN toolkiT (ENCHANT)
                    Developed by Matthew Bacon & Paul Jones

           ENCHANT is Copyright 1997-1999 Matthew Bacon & Paul Jones
                          Revision 12th September 1999














תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת GEM Toolkit

  \ENCHANT\TOOLKIT\
  ת Global variables
  ת ACCSHELL.BAS                       ת POPUP.BAS
  ת ACC_TBOX.BAS                       ת SHELL.BAS
  ת DIALOG.BAS                         ת TEXTWIND.BAS
  ת EXEC.BAS                           ת TOOLBX_A.BAS
  ת FORMWIND.BAS                       ת TOOLBX_B.BAS
  ת FSELECT.BAS                        ת TOOLBX_C.BAS
  ת GEMAES.BH                          ת TOOLBX_D.BAS
  ת GEMTKIT.TXT                        ת WINDOW.BAS
  ת MENU.BAS                           ת XALERT.BAS
  ת NEWDESK.BAS                        ת XDIALOG.BAS
  ת OBJECT.BAS

תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת ENCHANT GEM Toolkit

The ENCHANT GEM Toolkit (EGT) is a collection of BASIC source code modules
that, together, allow you to access and control GEM easily from within your
programs. This allows quick and easy (as possible) development of upto date
GEM programs for your Atari.

The GEM Toolkit has been written as a collection of modules rather than one
big file for several good reasons. Firstly, you'd need a map to find your
way around otherwise, secondly so that you can use just the parts that you
need for your particular program and finally so that you can appreciate how
GEM works.

Over the years, both Paul and myself have managed to build up quite a
collection of routines that "do this and do that". While these were used as
the driving force behind the development of the EGT, we'd like to thank
David Nutkins and Ofir Gal who did a fantastic job with the original HGT
(HiSoft GEM Toolbox).

Until you have a better understanding of the GEM Toolkit, we suggest that
you follow the GEM program and desk accessory shells that we have provided
(ACC_SHELL.BAS & SHELL.BAS). These call all the GEM Toolkit routines (which
may increase the size of your program a little) and the error catchment
module. As your confidence grows, experiment with calling only the Toolkit
modules you actually require, you may find that this decreases the
compilation time and improves your programs overall speed.

Alternatively, you could use a pre-tokenised version of TOOLBX_A.BAS to cut
down the compilation time (see your HiSoft BASIC manuals for details on how
to do this). Remember that you can, pre-tokenise any combination of the
toolkit (and ENCHANT Modules) routines to speed up your compilation times.

Please take the time to look at the example programs that have been provided
with ENCHANT. These show how to implement many of the features found in the
ENCHANT GEM Toolkit. If in doubt, experiment or give us a call!

Happy programming,

Matthew & Paul

          תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת Global variables
  The term 'global variable' applies to a variable that can be acessed from
  anywhere within the source code, thus a static or local variable (or
  resource object label) should NOT be one of the following.

  junk,junk!,junk$,tree&,menutree&,desktree&,MyProgram$,allchange,supress_byte_align
  resource_loaded,Finished_Flag,Finished_DFlag,CommonObj,CommonClose,err_advice$
  menu_exititem,clicks_enabled,keys_enabled,menus_enabled,reset_dialog,debug_enabled
  HowManyButtons,CommonButton,forms_enabled,userclose_enabled,dummy,dummy!,dummy$
  hook_enabled

  ת 'tree&' contains the memory address of the current resource objects root object

  ת 'menutree&' contains the memory address of the Toolkit's menu

  ת 'desktree&' contains the memory address of the Toolkit's desktop object

  ת 'MyProgram$' is a string which should contain the name of your program. It
    is automatically used in alert boxes and window title bars.

    Example: MyProgram$="ENCHANT"

  ת If 'allchange' does not equal zero (0), then an alert box will be
    displayed if AP_TERM is called by the user.

  ת 'resource_loaded' returns the value zero, if no resource file has been
    loaded using the GEM Toolkit routine: LoadRSC (rscname$)

  ת If 'Finished_Flag' is equal to zero, the GEM Toolkit program loop,
    'ENCHANTloop' will not exit.

  ת If 'Finished_DFlag' is equal to zero, the GEM Toolkit dialog loop
    (found in XDIALOG.BAS), 'dialog_formdo' will exit.

  ת 'CommonObj' is passed by the FORMWIND routines to the users FORMWIND
    exit routine and contains which object was selected by the user.

  ת 'CommonClose' is used by the users FORMWIND exit routine to
    determine, should the FORMWIND be exited!?

  ת 'CommonButton' returns which button was last clicked (right or left).

  ת 'menu_exititem' contains the object number of the exit item in the
    menubar.

  ת If 'clicks_enabled' does not return the value zero, the routine
    'HandleUserClicks' is executed.

  ת If 'keys_enabled' does not return the value zero, the routine
    'HandleUserKeys' is executed.

  ת If 'menu_enabled' does not return the value zero, the routine
    'CreateshortCut' is executed.

  ת If 'forms_enabled' does not return the value zero, the routine
	'HandleFormClicks' is executed.

  ת If 'userclose_enabled' does not return the value zero, the routine
	'HandleUserClose' is executed.

  ת If 'reset_dialog' does not return the value zero, when displaying a
    dialog using the routine 'xdialog', it's text & strings will all be
    set to "".

  ת If 'HowManyButtons' is equal to one, only the left mouse button can be
    used to select an object. If 'HowManyButtons' is equal to two, both the
    left and right mouse buttons can be used to select an object.

  ת If 'hook_enabled' does not return the value zero, the routine
	'HandleUserHook' is executed.

תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

ת ACCSHELL.BAS
  ת FUNCTION HandleUserClose(BYVAL WindowHandle)
    This routine is called when a window is closed and the global variable
    'userclose_enabled' does not equal zero. This routine should be written
    by you! and must always be present!

    'WindowHandle' parameter contains the windows AES handle

    - Example:
      result=HandleUserClose(WindowHandle)

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The window should be closed                                |
    |     0     | The window shuold not be closed                            |
     ------------------------------------------------------------------------

  ת SUB HandleUserMessages
    This routine is called if an AES message is not understood by the
    routine 'HandleMessage'. This routine should be written by you! and must
    always be present!

    - Comment:
      This routine should be used by you to handle protocol messages that
      your program receives! (BubbleGEM, OLGA etc.)

  ת SUB HandleUserKeys (ASCII$,key_pressed,kstate)
    This routine is called if the global variable 'keys_enabled' does not
    equal zero. It should be written by you to handle any key presses that
    you wish to process that are not merely menu or object keyboard shortcuts.
    This routine must always be present!

    'ASCII$' parameter contains the ASCII value of the character that has
             been selected

    'key_pressed' parameter contains the scan_code of the character that has
                  been selected

    'kstate' parameter contains the shift state (see the HB Technical
             Manual p249)

  ת SUB HandleUserClicks (clicks,kstate,mx,my)
    This routine is called if the global variable 'clicks_enabled' does not
    equal zero. It should be written by you to handle any mouse clicks
    yourself. This routine must always be present!

    'clicks' parameter contains the number of clicks by the mouse button

    'kstate' parameter contains the shift state (see the HB Technical
             Manual p249)

    'mx' parameter contains the mouse's x pixel position

    'my' parameter contains the mouse's y pixel position

  ת SUB	HandleUserMenu (WindowHandle,item,title)
    This routine is called whenever a menu item or shortcut is selected and
    must always be present and should be written by you!

    'WindowHandle' parameter is the AES handle of the top window

    'item' parameter contains the object number of the item selected

    'title' parameter contains the object number of the title of this menu

  ת SUB	HandleUserHook
    This routine is called is the variable hook_enabled does not enqual
    zero. The contents of the routine are user dependant and must always be
    present and should be written by you!

  ת SUB ACCOpened
    This routine is called each and every time your desk accesory is
    requested by the user. This routine should be written by you and as such
    should always be present!

ת ACC_TBOX.BAS
  ת SUB Init_Menu (treeno,exititem)
    This is a dummy routine and is not needed when writing a desk accessory.

  ת FUNCTION CreateShortCut (key_pressed,kstate)
    This is a dummy routine and is not needed when writing a desk accessory.

  ת SUB	HandleUserMenu (WindowHandle,item,title)
    This is a dummy routine and is not needed when writing a desk accessory.

  ת SUB Handle_ACCMessage
    This routine is called if an AES message occurs, such as AC_OPEN or
    wm_redraw TO wm_toolbar. If any other message is encountered, it passed
    onto the routine 'HandleUserMessages'.

  ת SUB StartAccessory(BYVAL daname$,BYVAL rscfile$,BYVAL icontreeno)
    This routine should be called by you (see ACC_SHELL.BAS for example) at
    the start of you source code when writing a desk accessory. You should
    provide...

    'daname$' parameter should contain the name of your desk accesory

    'rscfile$' parameter should contain the full path of the resource file
               you wish to load into memory

    'icontreeno' parameter should contain the object tree you wish to use
                 when a window is iconified or zero

  ת SUB ENCHANT_ACCloop
    This routine should be called by you directly after calling the routine
    'StartAccessory', above. This is the desk accessories program loop.

ת DIALOG.BAS
  ת FUNCTION Cstring_alertaddr(BYVAL button,BYVAL addr&)
  ת FUNCTION Cstring_alert(BYVAL object,BYVAL button)
    These two routines allow C-type strings (as found in resource files)
    to used for alert's. The routine 'Cstring_alertaddr' provides the
    memory address of the C-type string while 'Cstring_alert' takes the
    alert's index from the resource file (as providid in the BH file).

    - Example:
      result=Cstring_alert(ALERT1,0)

      'result' returns the button selected by the user

  ת FUNCTION alert(BYVAL button,BYVAL dummy$)
    This routine display's an alert box.

    'button' parameter should contain the default button

    'dummy$' parameter should contain the type of alert, then text contents
             and finally buttons

    - Example:
      result=alert(2,"[1][This is an alert!][OK|Cancel]")

      'result' returns the button selected by the user

  ת FUNCTION getobj_tednumber# (BYVAL object)
    This routine returns a numerical value from a tedinfo field.

  ת FUNCTION get_groupbutton(BYVAL parent)
    This routine returns which object of group of radio buttons is
    currently selected.

  ת SUB setobj_tednumber (BYVAL object,BYVAL value#)
    This routines sets a tedinfo field to a numeric value. The format used
    is the same as would be used if the value were printed as a double. For
    more control use the FORMATX$ functions and 'setobj_text'.

  ת SUB set_groupbutton (BYVAL parent,BYVAL button)
    This routine selects a particular radio button within a group,
    de-selecting all others in that group.

    'parent' parameter should contain the box/parent object containing the
             radio buttons

    'button' parameter should contain the object to be selected (this
             should be the object number within the tree!)

  ת FUNCTION dialog(BYVAL treeno,BYVAL edit_obj)
    This routine displays a dialog box and handles user interaction. The
    result returned is the exit object number.

    'treeno' parameter should contain an object number that you wish to
             display as a dialog (which can be found in the *.BH file).

    'edit_obj' parameter should contain the text field (object number of
               editable text field) where the cursor will initially be
               positioned, else zero.

ת EXEC.BAS
  ת FUNCTION Environment$
    This function returns the entire environment string of the 'current
    program' which can be passed on to a 'child process' using the sub-
    program 'Execute'.

  ת SUB Execute(file$,commandline$)
    This routine executes the application/child process 'file$' with a
    command line of 'commandline$'. In a singletasking environment, the
    application is executed under pexec&(), if a menu bar is present it is
    removed and all windows are closed (not deleted!). These are then
    re-displayed when the application/child process terminates!

    In a multitasking environment, the application is executed using the
    VA_START command (see AV protocol docs).

ת FORMWIND.BAS
  ת SUB InitFormWindows
    This routine is automatically called when an objectformwindow is opened.
    It initialises all the global variables and arrays used by the
    objectformwindow routines.

  ת FUNCTION getobj_ptmplt$(BYVAL object)
    This routine returns the string used of an editable object field.

  ת FUNCTION getcur_offset(BYVAL object,BYVAL index)
    This routine returns the current cursor offset of an editable object field.

  ת FUNCTION OpenFormWindow(WindowName$,BYVAL treeno,BYVAL edit_obj,BYVAL cancel_obj,BYVAL closeproc&)
    This routine opens an objectformwindow (dialog in a window - a non-modal
    dialog!). The window is automatically centred on the screen and can be
    treated like any other window (redraw, iconify etc.). See example
    programs provided for further insight.

    'WindowName$' parameter should contain the title window string

    'treeno' parameter should contain the resource file index of the object
             to be displayed in the window

    'edit_obj' parameter should contain the text object (must be editable)
               to be edited when the objectformwindow is opened or zero

    'cancel_obj' parameter should contain the object that will be returned
                 if the window close box (top left-hand corner of window) or
                 zero

    'closeproc&' parameter should contain the address of a sub-routines that
                 will be called when the window is closed or an exit button
                 (or it's shortcut) is selected by the user or zero

    - Example:
      result=OpenFormWindow("ENCHANT",maindialog,dialogftext,dialogcancel,VARPTRS(close_maindialog))

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |     0     | An error occurred, window not opened                       |
    |    else   | The window's AES handle is returned                        |
     ------------------------------------------------------------------------

  ת FUNCTION OpenDoubleFormWindow(WindowName$,BYVAL treeno,treeno2,BYVAL edit_obj,BYVAL cancel_obj,BYVAL closeproc&,BYVAL closeproc2&)
    This routine opens an objectformwindow that contains two objects.
    The window is automatically centred on the screen and can be treated
    like any other window (redraw, iconify etc.). See example programs
    provided for further insight.

    'WindowName$' parameter should contain some the title of the window

    'treeno' parameter should contain the resource file index of the first
             object to be displayed in the window (ideal for a toolbar etc.)

    'treeno2' parameter should contain the resource file index of a second
              object to be displayed in the window (under the first)

    'edit_obj' parameter should contain the text object (must be editable
               and within treeno2) to be edited when the objectformwindow is
               opened or zero

    'cancel_obj' parameter should contain the object (this must be within
                 treeno2) that will be returned if the window close box (top
                 left-hand corner of window) or zero

    'closeproc&' parameter should contain the address of a sub-routines that
                 will be called when an exit button (from the first object
                 tree) or it's shortcut is selected by the user or zero

    'closeproc2&' parameter should contain the address of a sub-routines that
                 will be called when the window is closed or an exit button
                 (from the second object tree), or it's shortcut is selected
                 by the user or zero

    - Example:
      result=OpenDoubleFormWindow("ENCHANT",toolbar,maindialog,dialogftext,dialogcancel,VARPTRS(close_toolbar),VARPTRS(close_maindialog))

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |     0     | An error occurred, window not opened                       |
    |    else   | The window's AES handle is returned                        |
     ------------------------------------------------------------------------

  ת FUNCTION ObjectWatch(BYVAL WindowHandle,BYVAL object)
    This routine is used by 'xENCHANTloop' to handle user interaction with
    the mouse. You should have no need to call this routine directly.

  ת FUNCTION reset_radio(VAL WindowHandle,VAL object)
    This routine selects the radio button 'object', de-selecting all others
    with the same parent object.

    'WindowHandle' parameter should contain an AES handle (returned when a
                   window is opened by the GEM Toolkit routines)

    'object' parameter should contain the object to be selected. It's
             parent name is not required

  ת FUNCTION xform_button(BYVAL WindowHandle,BYVAL object,next_object)
    This routine is used by 'xENCHANTloop' to handle user interaction with
    the mouse. You should have no need to call this routine directly.

  ת FUNCTION HandleFormObject (BYVAL treeno,BYVAL object,BYVAL closedialog&,BYVAL mode)
    This routine is used by 'xENCHANTloop' to handle user interaction of
    modern radio buttons and check boxes available in dialogs and
    objectformwindows (thanks to ENCHANT). You should have no need to call
    this routine directly.

  ת FUNCTION HandleFormClicks(BYVAL button,BYVAL clicks,BYVAL kstate,BYVAL x,BYVAL y)
    This routine is used by 'xENCHANTloop' to handle user interaction with
    the mouse. You should have no need to call this routine directly.

  ת FUNCTION HandleFormKeys(BYVAL key_pressed,BYVAL kstate)
    This routine is used by 'xENCHANTloop' to handle user interaction with
    the keyboard. You should have no need to call this routine directly.

  ת FUNCTION CloseFormWind
    This routine is used by objectformwindow routines to handle the safe
    closure of an objectfromwindow. You should have no need to call this
    routine directly.

  ת SUB RedrawFormWind
    This routine is used by objectformwindow routines to handle the safe
    redraw of an objectfromwindow. You should have no need to call this
    routine directly.

  ת SUB DeleteFormWind
    This routine is used by objectformwindow routines to handle the safe
    deletion of an objectfromwindow. You should have no need to call this
    routine directly.

  ת SUB xENCHANTloop
    This routine is used by objectformwindow routines to handle user
    interaction of the mouse, keyboard, message passing etc. It is basically
    an upgraded version of ENCHANTloop found in TOOLBX_D.BAS to handle
    objectformwindows.

  ת SUB HandleCursor(BYVAL WindowHandle,BYVAL mode)
    This routine is used by objectformwindow routines to handle tedinfo
    cursor redraw within an objectfromwindow. You should have no need to
    call this routine directly.

  ת SUB MoveCursor(index,BYVAL object,BYVAL x_position,BYVAL mode)
    This routine is used by objectformwindow routines to handle tedinfo
    cursor movement within an objectfromwindow. You should have no need to
    call this routine directly.

  ת SUB Object_Redraw(WindowHandle,BYVAL object)
    This routine is used by objectformwindow routines to redraw a single
    object, 'object' currectly and safely within the window with handle
    'WindowHandle'.

  ת SUB MultiObject_Redraw(BYVAL WindowHandle,BYVAL object)
    This routine is used by objectformwindow routines to redraw several
    objects starting with 'object' within a window with the handle
    'WindowHandle'. It is unlikely that you'll need to call this routine!?

  ת SUB HandleKeyboardEvent(BYVAL key_pressed,BYVAL kstate)
    This routine is used by 'xENCHANTloop' to handle user interaction with
    the keyboard. You should have no need to call this routine directly.

ת FSELECT.BAS
  ת FUNCTION FileSelect$ (fsname$,BYVAL fsmode)
    This routine is used to call the systems FileSelector. The global
    variables fspath$, fsname$ and fsmessage$ should be used to set the
    path, the file name and the message (respectively) displayed when the
    FileSelector is called.

    If 'fsmode' =0 then only the name of the file selected is returned.
    If 'fsmode' =1 then only the path of the file selected is returned.
    If 'fsmode' =2 then both the path and name of the file selected is
                   returned.

    - Example:
      fsmode=2
      file$=FileSelect$ (fsname$,fsmode)
      PRINT file$

  ת SUB InitFileSelector
    This routine is used to initialise the global variables fspath$,fsname$
    and fsmessage$ and is automatically called if fpath$=""

ת MENU.BAS
  ת SUB Init_Menu(BYVAL treeno,BYVAL exititem)
    This routine displays the menu given by 'treeno' from the  resource file
    and scans that menu for any keyboard shortcuts. You should have no need
    to call this routine directly.

    'exititem' parameter should be the object number of the item to be used
               to terminate the program or pass -1 as the exititem if you
               wish to handle the exit item yourself.

    Note: When designing your menu, use  should be used for 'Shift key
          shortcuts', ^ for 'Control key shortcuts' and  for 'Alternate key
          shortcuts'.

          As well as all ASCII characters, F1 to FI0 and their Shift
          variants or one of the following special keys can be used:

          BS (for Backspace)  Clr       Esc
          Help                Home      Ins (for Insert)
          Tab                 Undo

  ת FUNCTION menu_checkitem (BYVAL item,BYVAL flag)
    This routine is used to display a tick (check mark) in the menu item,
    'item'.

    If 'flag' parameter equals 1, then the tick is displayed

    If 'flag' parameter equals 0, then the tick is removed

  ת FUNCTION menu_disableitem (BYVAL item,BYVAL flag)
    This routine is used to disable the menu item, 'item'.

    If 'flag' parameter equals 1, then the menu item is disabled

    If 'flag' parameter equals 0, then the menu item is not disabled

  ת FUNCTION menu_selectitem (BYVAL item,BYVAL flag)
    This routine is used to select the menu item, 'item'.

    If 'flag' parameter equals 1, then the menu item is selected

    If 'flag' parameter equals 0, then the menu item is not selected

  ת FUNCTION menu_changetext (BYVAL item,BYVAL text$)
    This routine is used to modify the string in the menu item, 'item'.

  ת FUNCTION CreateShortCut(BYVAL Scancode,BYVAL kstate)
  ת SUB ScanMenu
  ת SUB Record(BYVAL ascii,BYVAL char,BYVAL item,BYVAL title)
  ת SUB ConsiderString(BYVAL item,BYVAL title,BYVAL text$)
  ת SUB RecordSpecial(BYVAL dummy$,BYVAL ScanCode)
    The above five routines are used by the GEM Toolkit to handle keyboard
    shortcuts for the menu bar. You should have no need to call these
    routines directly.

ת NEWDESK.BAS
  ת SUB SetDeskAddr (BYVAL dummy&)
  ת SUB SetDesk (BYVAL treeno,BYVAL object)
    These routines allows you to customise the desktop in your program.

    'treeno' parameter should contain the resource file index of the object
             to be displayed as the desktop or -1 to remove it

    'object' parameter should contain the resuorce file index of the object
             to be centred on the desktop (i.e. child object of 'treeno')

ת OBJECT.BAS
  ת SUB ObjectExtent(BYVAL object,x,y,w,h)
    This routine returns a rectangle which corresponds to the visual
    representation of the object (on screen) taking into account any 3D
    effects applied. You should have no need to call this routine directly.

ת POPUP.BAS
  ת FUNCTION getobj_poptext$(BYVAL treeno,BYVAL object)
    This routine is used by the popup routines to extract a text string from
    the popup item selected by the user. You should have no need to call
    this routine directly.

  ת FUNCTION popable(BYVAL object,BYVAL poptreeno)
    This routine is used by the popup routines to make sure, a popup item
    is suitable to be selected by the user. You should have no need to call
    this routine directly.

  ת FUNCTION getobj_popparent(BYVAL object)
    This routine is used by the popup routines to find out the popup
    object's parent object. You should have no need to call this routine
    directly.

  ת FUNCTION popup_keyboard(BYVAL key_pressed,Finished_PFlag,BYVAL poptreeno)
    This routine is used by the popup routines to handle keyboard input
    (cursor keys and shortcuts). You should have no need to call this
    routine directly.

  ת SUB DeselectObject(BYVAL object)
    This routine is used by the popup routines to deselect a previously
    selected popup item. You should have no need to call this routine
    directly.

  ת SUB SelectObject(BYVAL object)
    This routine is used by the popup routines to select a new popup item.
    You should have no need to call this routine directly.

  ת SUB objc_rect(BYVAL object,x,y,w,h)
    This routine is used by the popup routines to workout a popup items
    co-ordinates. You should have no need to call this routine directly.

  ת FUNCTION handlepopup(BYVAL old_object,poptreeno)
    This routine is used by the popup routines to handle user interaction.
    You should have no need to call this routine directly.

  ת FUNCTION popup(BYVAL WindowHandle,BYVAL CommonObj,BYVAL treeno,BYVAL poptreeno,BYVAL old_object)
    This routine should be called to display a popup tree.

    'WindowHandle' parameter should contain the AES window handle of the
                   window from which the popup tree should appear or zero if
                   the popup should appears from a normal dialog

    'CommonObj' parameter should contain the resource file index of the
                object to be popped (so to speak!)

    'treeno' parameter should contain the resource file index of the popup
             object tree

    'poptreeno' parameter should contain the resource file index of the
                popup object within the popup object tree (see GEM_T.KIT
                example!)

    'old_object' parameter should contain the resource file index of the
                 object previously selected by the user

  ת FUNCTION getobj_popshortcut(BYVAL object)
    This routine is used by the popup routines to workout the keyboard
    shortcut for the popup item, 'object'. You should have no need to call
    this routine directly.

  ת SUB save_popscr(BYVAL x,BYVAL y,BYVAL w,BYVAL h,BYVAL mode)
    This routine is used by the popup routines to blit the popup to and from
    the screen. You should have no need to call this routine directly.

  ת SUB substitute_image (BYVAL treeno,BYVAL object,BYVAL s_treeno,BYVAL s_object)
    This routine is used by the popup routines to replace a popup item,
    'object' for a image object (G_IMAGE), 's_object'. You should have no
    need to call this routine directly.

  ת SUB setobj_poptext(BYVAL object,BYVAL dummy$)
    This routine is used by the popup routines to replace a string within a
    popup item, 'object' for the text within 'dummy$'. You should have no
    need to call this routine directly.

  ת SUB setobj_popshortcut(BYVAL object,BYVAL dummy$)
    This routine is used by the popup routines to set the keyboard shortcut
    for the popup item, 'object'. You should have no need to call this
    routine directly.

  ת SUB radio_poptext(BYVAL object,BYVAL poptreeno,BYVAL popparent,popobject)
    This routine should be used to scroll through a popup tree (text only)
    an item at a time (see GEM_T.KIT example!).

    'object' parameter should contain the resource file index of the object
             to be popped (so to speak!)

    'poptreeno' parameter should contain the resource file index of the
                popup object tree

    'popparent' parameter should contain the resource file index of the
                popup object within the popup object tree (see GEM_T.KIT
                example!)

    'popobject' parameter should contain the resource file index of the
                popup item where the scroll begins (see GEM_T.KIT example!)
                'popobject' will return the popup item that is scrolled too

  ת SUB radio_popimage(BYVAL treeno,BYVAL object,BYVAL poptreeno,BYVAL popparent,popobject)
    This routine should be used to scroll through a popup tree (image only)
    an item at a time (see GEM_T.KIT example!).

    'object' parameter should contain the resource file index of the object
             to be popped (so to speak!)

    'poptreeno' parameter should contain the resource file index of the
                popup object tree

    'popparent' parameter should contain the resource file index of the
                popup object within the popup object tree (see GEM_T.KIT
                example!)

    'popobject' parameter should contain the resource file index of the
                popup item where the scroll begins (see GEM_T.KIT example!)
                'popobject' will return the popup item that is scrolled too

ת SHELL.BAS
  ת Top Tips to creating a GEM program
    - Follow program shell as set out in SHELL.BAS or ACCSHELL.BAS
    - If using a resource file, use RSCSHELL.RSC (in EXAMPLES folder) as a
      starting block! as the GEM Toolkit require the object tree's:

      - FORM_ALERTBOX   = Used for XALERT.BAS
      - ICONS           = Used for XDIALOG.BAS & FORMWIND.BAS
      - FORM_ICON       = Used for WINDOW.BAS, TEXTWIND.BAS & FORMWIND.BAS

  ת FUNCTION HandleUserClose(BYVAL WindowHandle)
    This routine is called when a window is closed and the global
    variable 'userclose_enabled' does not equal zero. This routine should be
    written by you! and must always be present!

    'WindowHandle' parameter contains the windows AES handle

    - Example:
      result=HandleUserClose(WindowHandle)

     ------------------------------------------------------------------------
    |   result  | Meaning                                                    |
     ------------------------------------------------------------------------
    |    -1     | The window should be closed                                |
    |     0     | The window shuold not be closed                            |
     ------------------------------------------------------------------------

  ת SUB HandleUserMessages
    This routine is called if an AES message is not understood by the
    routine 'HandleMessage'. This routine should be written by you! and must
    always be present!

    - Comment:
      This routine should be used by you to handle protocol messages that
      your program receives! (BubbleGEM, OLGA etc.)

  ת SUB HandleUserKeys (ASCII$,key_pressed,kstate)
    This routine is called if the global variable 'keys_enabled' does not
    equal zero. It should be written by you to handle any key presses that
    you wish to process that are not merely menu or object keyboard shortcuts.
    This routine must always be present!

    'ASCII$' parameter contains the ASCII value of the character that has
             been selected

    'key_pressed' parameter contains the scan_code of the character that has
                  been selected

    'kstate' parameter contains the shift state (see the HB Technical
             Manual p249)

  ת SUB HandleUserClicks (clicks,kstate,mx,my)
    This routine is called if the global variable 'clicks_enabled' does not
    equal zero. It should be written by you to handle any mouse clicks
    yourself. This routine must always be present!

    'clicks' parameter contains the number of clicks by the mouse button

    'kstate' parameter contains the shift state (see the HB Technical
             Manual p249)

    'mx' parameter contains the mouse's x pixel position

    'my' parameter contains the mouse's y pixel position

  ת SUB	HandleUserMenu (WindowHandle,item,title)
    This routine is called whenever a menu item or shortcut is selected and
    must always be present and should be written by you!

    'WindowHandle' parameter is the AES handle of the top window

    'item' parameter contains the object number of the item selected

    'title' parameter contains the object number of the title of this menu

  ת SUB	HandleUserHook
    This routine is called is the variable hook_enabled does not enqual
    zero. The contents of the routine are user dependant and must always be
    present and should be written by you!

ת TEXTWIND.BAS
  ת SUB InitTextSystem(BYVAL MaxFiles,BYVAL MaxLines)
    This routine sets the textwindow global variables and arrays. This
    routine should be called, by you, before any text windows are opened.

  ת FUNCTION OpenTextWindow(BYVAL WindowName$,BYVAL WindComp)
    This routine opens a text window with composition of 'WindComp' (see HB
    Tech manual page 203) and with name 'WindowName$'. The text within this
    window is loaded by routine 'LoadTextFile'.

  ת SUB LoadTextFile(BYVAL file$,BYVAL index,TotalLines)
    This routine loads a file from disk into memory to be displayed with the
    routine 'OpenTextWindow'.

    'file$' parameter should contain a full path to a file you want loaded

    'index' parameter should contain the index of the text window either
            opened or to be opened (starting with 0)

    'TotalLines' parameter should contain the total number of lines to be
                 read from 'file$'

  ת SUB ExpandTabs(BYVAL source$,dest$)
    This routine expands any tabs in the string 'source$' and writes the
    expanded text to 'dest$'. You should have no need to call this routine
    directly.

  ת SUB TextWindSlid
    This routine is used by the textwindow routines to handle window slider
    movement. You should have no need to call this routine directly.

  ת SUB TextWindArrowed(BYVAL WindowHandle,BYVAL which)
    This routine is used by the textwindow routines to handle window arrow
    input. You should have no need to call this routine directly.

  ת SUB FastTextWindRedraw
    This routine is used by the textwindow routines to handle fast redraw
    of a text window. You should have no need to call this routine directly.

  ת SUB TextWindRedraw
    This routine is used by the textwindow routines to handle standard redraw
    of a text window. You should have no need to call this routine directly.

  ת SUB TextWindClose
    This routine is used by the textwindow routines to handle closure of a
    text window. You should have no need to call this routine directly.

  ת SUB TextWindLoop (BYVAL key_pressed)
    This routine is used by the textwindow routines to handle user input.
    You should have no need to call this routine directly.

ת TOOLBX_B.BAS
  ת SUB SelectTreeAddr (BYVAL addr&)
    This routine selects a new tree given the address of the root.

  ת SUB SelectTree (BYVAL treeno)
    This routine selects a new tree given the tree number from the resource
    file. The resource file must have been loaded using the routine
    'StartProgram' or 'LoadRSC'. To call this routine and you should use the
    constants in the BH file that is created by WERCS (see HB technical
    manual for further details).

  ת FUNCTION getobj_head (BYVAL object)
    This routine returns the value of the ob_head field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_tail (BYVAL object)
    This routine returns the value of the ob_tail field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_spec& (BYVAL object)
    This routine returns the value of the ob_spec field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_state (BYVAL object)
    This routine returns the value of the ob_state field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_flags (BYVAL object)
    This routine returns the value of the ob_flags field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_type (BYVAL object)
    This routine returns the value of the ob_type field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_next (BYVAL object)
    This routine returns the value of the ob_next field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_x (BYVAL object)
    This routine returns the value of the ob_x field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_y (BYVAL object)
    This routine returns the value of the ob_y field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_width (BYVAL object)
    This routine returns the value of the ob_width field in the given
    'object' of the currently selected tree.

  ת FUNCTION getobj_height (BYVAL object)
    This routine returns the value of the ob_height field in the given
    'object' of the currently selected tree.

  ת SUB getobj_xywh (BYVAL object,valuex,valuey,valuew,valueh)
    'valuex' parameter returns the value of the ob_x field in the given
             'object' of the currently selected tree.

    'valuey' parameter returns the value of the ob_y field in the given
             'object' of the currently selected tree.

    'valuew' parameter returns the value of the ob_width field in the given
             'object' of the currently selected tree.

    'valueh' parameter returns the value of the ob_height field in the given
             'object' of the currently selected tree.

  ת SUB setobj_spec (BYVAL object,BYVAL value&)
    This routine sets the 'value&' of the ob_spec field in the given
    'object' of the current tree.

  ת SUB setobj_state (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_state field in the given
    'object' of the current tree.

  ת SUB setobj_flags (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_flags field in the given
    'object' of the current tree.

  ת SUB setobj_type (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_type field in the given
    'object' of the current tree.

  ת SUB setobj_x (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_x field in the given
    'object' of the current tree.

  ת SUB setobj_y (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_y field in the given
    'object' of the current tree.

  ת SUB setobj_width (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_width field in the given
    'object' of the current tree.

  ת SUB setobj_height (BYVAL object,BYVAL value)
    This routine sets the 'value' of the ob_height field in the given
    'object' of the current tree.

  ת SUB setobj_xywh (BYVAL object,BYVAL valuex,BYVAL valuey,BYVAL valuew,BYVAL valueh)
    'valuex' parameter sets the value of the ob_x field in the given
             'object' of the currently selected tree.

    'valuey' parameter sets the value of the ob_y field in the given
             'object' of the currently selected tree.

    'valuew' parameter sets the value of the ob_width field in the given
             'object' of the currently selected tree.

    'valueh' parameter sets the value of the ob_height field in the given
             'object' of the currently selected tree.

  ת SUB remove_state (BYVAL object,BYVAL flag_mask)
    This routine removes a mask (e.g. mask_selected, mask_disable) from the
    ob_state field in the given 'object' of the current tree.

  ת SUB include_state (BYVAL object,BYVAL flag_mask)
    This routine includes a mask (e.g. mask_selected, mask_disable) from the
    ob_state field in the given 'object' of the current tree.

  ת FUNCTION enquire_state (BYVAL object,BYVAL flag_mask)
    This routine returns a non-zero if the mask (e.g. mask_selected,
    mask_disable) from the ob_state field is set.

  ת SUB remove_flags (BYVAL object,BYVAL flag_mask)
    This routine removes a mask (e.g. mask_selectable, mask_exit) from the
    ob_flags field in the given 'object' of the current tree.

  ת SUB include_flags (BYVAL object,BYVAL flag_mask)
    This routine includes a mask (e.g. mask_selectable, mask_exit) from the
    ob_flags field in the given 'object' of the current tree.

  ת FUNCTION enquire_flags (BYVAL object,BYVAL flag_mask)
    This routine returns a non-zero if the mask (e.g. mask_selected,
    mask_disable) from the ob_flags field is set.

  ת SUB setobj_text (BYVAL object,BYVAL text$)
    This routine sets the string data in the tedinfo record of the given
    'object' to be 'text$'. (G_TEXT, G_BOXTEXT, G_FTEXT, G_FBOXTEXT)

  ת FUNCTION getobj_spec$ (BYVAL object)
    This routine returns the string data in the tedinfo record of the given
    'object'. (G_STRING, G_BOXCHAR, G_BUTTON)

  ת FUNCTION getobj_text$ (BYVAL object)
    This routine returns the string data in the tedinfo record of the given
    'object'. (G_TEXT, G_BOXTEXT, G_FTEXT, G_FBOXTEXT)

  ת FUNCTION getaddr_text$ (BYVAL addr&)
    This routine returns the string data found at an address of 
    memory which begins at addr&.

  ת SUB setobj_spec_str (BYVAL object,BYVAL spec$)
    This routine sets the string data in the tedinfo record of the given
    'object' to be 'text$'. (G_STRING, G_BOXCHAR, G_BUTTON)

  ת FUNCTION aes_version
    This routine returns the AES version currently running in memory.

ת TOOLBX_C.BAS
  ת SUB dummy_routine
    This routine is a termed a 'dummy routine' as it does not do anything.
    You'll find your own use for this routine!

  ת SUB AbortProgram (dummy$)
    This routine is display's the message 'dummy$' before terminating the
    application. This can be useful when tracking down bugs in your program.

  ת SUB Debug (BYVAL dummy$)
    This routine is display's the message 'dummy$'. This can be useful when
    tracking down bugs in your program.

  ת FUNCTION ConvertAlt (ScanCode)
    This routine converts 'ScanCode' and returns a variable for the GEM
    Toolkit routines to understand. You should have no need to call this
    routine directly.

  ת FUNCTION byte_align (BYVAL x)
    This routine returns the nearest value of eight to 'x' which can be used
    to improve screen redraws. You should have no need to call this routine
    directly.

  ת SUB LoadRSC (rscname$)
    This routine loads the resource file, 'rscname$' into memory. You should
    have no need to call this routine directly.

  ת SUB StartProgram (BYVAL rscfile$,BYVAL treeno,BYVAL exititem,BYVAL icontreeno)
    This routine should be called, by you, at the beginning of your programs
    that are going to use the GERM Toolkit (menu, resource file and window
    facilities etc.), see SHELL.BAS.

    'rscfile$' parameter should contain the resource file to be loaded

    'treeno' parameter should contain the resource file index of the
             menu tree to be used as the menu bar

    'exititem' parameter should contain the resource file index of the
               exit item (i.e. Quit item) on the menu

    'icontreeno' parameter should contain the resource file index of the
                 object tree you wish to display whenever a window is
                 'iconified' or zero

    If you have a program that uses the window and file selector facilities
    without a menu, use " " for the resource file$ string. If you want to do
    your own handling of the Quit item, perhaps to request confirmation from
    the user, you should pass -1 as the 'exititem'. To load a resource file
    without displaying a menu pass 0 as the 'exititem' parameter.

  ת SUB StopProgram
    This routine must be called, by you, before a GEM program is terminated (see
    SHELL.BAS).

ת TOOLBX_D.BAS
  ת FUNCTION WhichWindow(BYVAL AEShandle)
    This routine is used by the GEM Toolkit to return the window handle
    corresponding to the AES window parameter, 'AEShandle' that is supplied
    as a parameter. You should have no need to call this routine directly.

  ת FUNCTION IsMyWindow(BYVAL WindowHandle)
    This routine is used by the GEM Toolkit to make sure that the window
    handle, 'WindowHandle' supplied as a parameter was not opened by another
    application. You should have no need to call this routine directly.

  ת SUB HandleMessage
    This routine is used by the GEM Toolkit to handle and redirect AES
    messages passed by the program loop. You should have no need to call
    this routine directly. In turn, this routine calls 'HandleUserMessages'
    for any AES message it does not understand.

  ת SUB ENCHANTloop
    This routine is used by GEM Toolkit routines to handle user
    interaction of the mouse, keyboard, message passing etc. You should call
    this routine after the routine 'StartProgram' and after your own
    initialisation code (see SHELL.BAS). ENCHANTloop in turn, calls the
    routines 'HandleUserClicks', 'HandeUserKeys' and 'HandleUserMenus' as
    appropriate which must be written by you. Setting the global variable
    'Finished_Flag' to -1 within one of these routines will cause the
    program loop to be exited.

ת WINDOW.BAS
  ת SUB	InitWindowSystem
    This routine is called the first time a window is opened. It initialises
    all the global variables and arrays used by the window routines.  You
    should have no need to call this routine directly.

  ת FUNCTION WindInter(BYVAL x1,BYVAL y1,BYVAL w1,BYVAL h1,BYVAL x2,BYVAL y2,BYVAL w2,BYVAL h2,outx,outy,outw,outh)
    This routine is used by the window routines to find the intersection of
    two windows for update purposes. The parameters 'outx', outy', 'outw'
    and 'outh' return the intersection of 'x1', 'y1', 'w1', 'h1' and 'x2',
    'y2', 'w2', 'h2'. You should have no need to call this routine directly.

  ת FUNCTION OpenAWindow(WindowName$,BYVAL WindComp,BYVAL x,BYVAL y,BYVAL w,BYVAL h,BYVAL redrawproc&,BYVAL slidermaxaddr&,BYVAL closeproc&)
    This routine is used to create, open a GEM window and clears to a white
    background.

    'WindowName$' parameter should contain the title window string

    'WindComp' parameter should contain the composition for the window as
               described in the HB Tech manual on page 203.

    'x','y','w','h' parameters should contain the position on screen the
                    window is first displayed

    'redrawproc&' parameter should contain the address of a sub-routines that
                  will be called whenever the window needs to be redrawn.

    'slidermaxaddr&' parameter should contain the address of a sub-routines
                     to return the current maximum values for the window's
                     sliders.  The global variables used are:

                     CommonHandle   The AES handle of the window to be re-
                                    drawn.

                     CommonIndex    The index within the window system's
                                    internal tables (as returned by
                                    WhichWindow).

                     The 'slidermaxaddr&' sub-program should return the
                     maximum possible size of the scrollable area in pixels
                     in the following variables:

                     CommonMaxX     The maximum slider value in the
                                    x-direction.

                     CommonMaxY     The maximum slider value in the
                                    y-direction.

    'closeproc&' parameter should contain the address of a sub-routines that
                 will be called just before the window is to be closed.

  ת FUNCTION GetOffset(BYVAL TotalHeight,BYVAL value)
    This routine is used by the window routines to workout a sliders
    offset. You should have no need to call this routine directly.

  ת SUB CloseAWindow(WindowHandle)
    This routine is used by the window routines to close a window opened by
    'OpenAWindow' with the AES handle, 'WindowHandle'. You should have no
    need to call this routine directly.

  ת SUB OneSlider(BYVAL Horizontal,BYVAL TotalSize,BYVAL cur_pos,BYVAL size)
  ת SUB WindowSlid(BYVAL Horizontal,BYVAL WindowHandle,BYVAL value)
  ת SUB WindowArrowed(BYVAL WindowHandle,BYVAL which)
    The three routines above are used by the window routines to update a GEM
    windows slider. You should have no need to call these routines directly.

  ת SUB RenameWindow(WindowHandle,WindowName$)
    This routine is used by the window routines to change the title of the
    window whose AES is 'WindowHandle' to be 'WindowName$'.

  ת SUB ReDraw(WindowHandle,BYVAL x,BYVAL y,BYVAL w,BYVAL h)
    This routine is used by the window routines to redraw the section
    'x','y','w','h' of the window whose AES is 'WindowHandle' to be
    'WindowName$'.

  ת SUB FullReDraw(BYVAL WindowHandle)
    This routine is used by the window routines to redraw the entire
    window whose AES is 'WindowHandle' to be 'WindowName$'.

  ת SUB ChangeWindow(BYVAL WindowHandle,BYVAL x,BYVAL y,BYVAL w,BYVAL h)
    This routine is used by the window routines to change the window whose
    AES is 'WindowHandle' position on screen, to be 'x','y','w','h'.

  ת SUB UpdateSliders
    This routine is used by the window routines to update a GEM windows
    slider. You should have no need to call this routine directly.

  ת SUB TopAWindow(VAL WindowHandle)
    This routine is used by the window routines to bring the window whose
    AES is 'WindowHandle' to the top (of any other windows on screen).
    You should have no need to call this routine directly.

  ת SUB UnTopAWindow(BYVAL WindowHandle)
    This routine is used by the window routines to send the window whose
    AES is 'WindowHandle' to the back (of any other windows on screen).
    You should have no need to call this routine directly.

  ת SUB WindowMessage
    This routine is used by the window routines to handle any AES window
    messages received/generated (close, redraw etc.). You should have no
    need to call this routine directly.

ת XALERT.BAS
  ת FUNCTION init_alert (default_button,text$)
    This routine takes the string, 'text$' and converts it into something
    that the xalert routine can use (don't worry about it! - treat the text
    like any other alert string). You should have no need to call this
    routine directly.

  ת FUNCTION xalert(BYVAL default_button,BYVAL text$)
    This routine display's a flydial alert box (you can move it around the
    screen by clicking with the left mouse button anywhere on the alert).

    'default_button' parameter should contain the default button (1,2,3 etc.)

    'text$' parameter should contain the type of alert, then text contents
            and finally buttons

    - Example:
      result=xalert(2,"[1][This is an alert!][OK|Cancel]")

      'result' returns the button selected by the user

  ת SUB save_scralert (BYVAL x,BYVAL y,BYVAL w,BYVAL h,BYVAL mode)
    This routine is used by the alert routines to blit the alert box to,
    from and around the screen. You should have no need to call this routine
    directly.

ת XDIALOG.BAS
  ת FUNCTION getobj_just(BYVAL object)
    This routine returns the value of the te_just offset in the tedinfo
    structure of the given 'object'. (see HB Tech manual page 300)

  ת FUNCTION getobj_font(BYVAL object)
    This routine returns the value of the te_font offset in the tedinfo
    structure of the given 'object'. (see HB Tech manual page 300)

  ת FUNCTION getobj_parent(BYVAL object)
    This routine returns the resource file index of the object's parent or
    -1 if it is the root. You should have no need to call this routine
    directly.

  ת FUNCTION getobj_child(BYVAL parent,BYVAL child)
    This routine returns -1 (true) if 'child' is a child of (or the same as)
    the $ject 'parent'. You should have no need to call this routine
    directly.

  ת FUNCTION getobj_depth (BYVAL startobj,BYVAL object,BYVAL depth)
    This routine returns -1 (true) if 'object' is within a 'depth' from
    'startobj' or (the same object as) 'parent'. You should have no need to
    call this routine directly.

  ת FUNCTION HandleKeyboard(BYVAL cur_edit,BYVAL kstate,new_edit,key_pressed,index)
    This routine is used by the xdialog routines to handle user input. You
    should have no need to call this routine directly.

  ת FUNCTION formcuts(BYVAL key_pressed,BYVAL undo_obj)
    This routine is used by the xdialog routines to workout the keyboard
    shortcuts (and match) of any objects within the current xdialog. You
    should have no need to call this routine directly.

  ת FUNCTION getobj_shortcut(BYVAL object)
    This routine is used by the xdialog routines to workout the keyboard
    shortcut of 'object'. You should have no need to call this routine
    directly.

  ת SUB save_scrdialog (BYVAL x,BYVAL y,BYVAL w,BYVAL h,BYVAL mode)
    This routine is used by the xdialog routines to blit the alert box to,
    from and around the screen. You should have no need to call this routine
    directly.

  ת SUB draw_shortcuts (BYVAL object,BYVAL depth)
  ת SUB workout_underline(BYVAL object,BYVAL type)
  ת SUB draw_underline(BYVAL object,BYVAL x1,BYVAL y1,BYVAL x2)
    The three routines above are used by the xdialog routines to workout and
    draw the keyboard shortcuts of each object from 'object' to 'depth'. You
    should have no need to call these routines directly.

  ת SUB change_object(BYVAL object,BYVAL x,BYVAL y,BYVAL w,BYVAL h,BYVAL newstate,BYVAL flag)
    This routine modifies the ob_state field of the 'object' to be
    'newstate'. If flag=1 then 'object' is redrawn using the clipping
    x,y,w,h. If flag=0 then 'object' is modified but not redrawn. You should
    have no need to call this routine directly.

  ת SUB draw_object(BYVAL object,BYVAL depth,BYVAL x,BYVAL y,BYVAL w,BYVAL h)
    This routine redraws 'object' with clipping x,y,w,h to 'depth' along
    with its keyboard shortcut. You should have no need to call this routine
    directly.

  ת SUB redraw_object(BYVAL object)
    This routine redraws a single 'object' with clipping x,y,w,h along with
    its keyboard shortcut. You should have no need to call this routine
    directly.

  ת SUB sub_icon (BYVAL treeno,BYVAL object,BYVAL s_treeno,BYVAL s_object)
    This routine is used by the xdialog routines to replace an 'object'
    within the object tree, 'treeno' with 's_object' within object tree
    's_treeno'. You should have no need to call this routine directly.

  ת SUB set_grouprbutton (BYVAL treeno,BYVAL parent,BYVAL button)
    This routine selects a particular radio button within a group,
    de-selecting all others in that group.

    'parent' parameter should contain the box/parent object containing the
             radio buttons

    'button' parameter should contain the object to be selected (this
             should be the object number within the tree!)

  ת SUB init_dialog (BYVAL treeno)
    This routine is called before a xdialog is displayed to substitute any
    modern radio button, check box or null terminate strings. You should
    have no need to call this routine directly.

  ת SUB setobj_shortcut(BYVAL object,BYVAL dummy$)
    This routine is used by the xdialog routines to set the keyboard
    shortcut for 'object' or the shortcut used by the xdialog routines to
    recognise a modern radio button or check box. Study GEM_T.KIT example
    program and resource file supplied to see how this works in practise!

    Shortcut value (dummy$)       Substituted object

           CHR$(10)               popup radio button
           CHR$(11)               modern circular radio button, not selected
           CHR$(12)               modern circular radio button, selected
           CHR$(13)               modern check box, not selected
           CHR$(14)               modern check box, selected

  ת SUB HandleObject (BYVAL treeno,BYVAL object,BYVAL closedialog&,BYVAL mode)
  ת FUNCTION dialog_formdo (BYVAL treeno,x,y,w,h,BYVAL object,BYVAL exit_obj,button,BYVAL closedialog&)
    These two routines

  ת FUNCTION xdialog(BYVAL treeno,BYVAL edit_obj,BYVAL exit_obj,button,BYVAL closedialog&)
    This routine displays a flydial dialog which can be moved around the
    screen, have keyboard shortcuts and use modern circular radio buttons
    and check boxes.

    'treeno' parameter should contain the resource file index for the
             dialog you want displayed (which can be found in the *.BH file)

    'edit_obj' parameter should contain the text field (object number of
               editable text field) where the cursor will initially be
               positioned, else zero

    'exit_obj' parameter should contain the object that will be returned
               if 'Undo' key is selected by the user.

    'button' parameter returns the mouse button used by the user

    'closeproc&' parameter should contain the address of a sub-routines that
                 will be called when any object within the dialog is
                 selected by the user (i.e. an exit button or it's shortcut)
                 or zero

תתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתתת

[END OF FILE]