\section{ MAS Arbitrary Precision Floating Point  } 
\proc{APCOMP} (ML,EL: LIST): LIST; \eproc
\bcom Arbitrary precision floating point composition. e is the
exponent, m is the mantissa of the arbitrary precision
floating point number A. \ecom 
\proc{APMANT} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point mantissa. m is the mantissa
of the arbitrary precision floating point number A. \ecom 
\proc{APEXPT} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point exponent. e is the
exponent of the arbitrary precision floating point number A. \ecom 
\proc{ILOG10} (N: LIST): LIST; \eproc
\bcom Integer logarithm base 10.
N is an integer, l is a beta integer. l=LOG10(ABS(N)). \ecom 
\proc{APSPRE} (N: LIST); \eproc
\bcom Arbitrary precision floating point set precision.
N is the desired precision of the floating point numbers. \ecom 
\proc{APFINT} (N: LIST): LIST; \eproc
\bcom Arbitrary precision floating point from integer.
The integer N is converted to the arbitrary precision
floating point number A. \ecom 
\proc{APSHFT} (B,EL: LIST): LIST; \eproc
\bcom Arbitrary precision floating point shift.
The arbitrary precision floating point number B is multiplied by 2**e.
A is an arbitrary precision floating point number. \ecom 
\proc{APSIGN} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point sign. A is an arbitrary precision
floating point number, s is the sign of A. \ecom 
\proc{APWRIT} (A: LIST); \eproc
\bcom Arbitrary precision floating point write.
The arbitrary precision floating point number A is written to
the output stream. \ecom 
\proc{APNEG} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point negative.
The arbitrary precision floating point number A is negated.
B= -A. \ecom 
\proc{APABS} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point absolute value.
A is a arbitrary precision floating point number.
B is the absolute value of A. \ecom 
\proc{APCMPR} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point compare.
A and B are arbitrary precision floating point numbers.
s is the sign of the difference of A and B. s=SIGN(A-B). \ecom 
\proc{APNELD} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point number of equal leading digits.
A and B are arbitrary precision floating point numbers.
l is the number of equal leading digits of A and B. \ecom 
\proc{APPROD} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point product.
A, B and C are arbitrary precision floating point numbers.
C is the product of A and B. C=A*B. \ecom 
\proc{APQ} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point quotient.
A, B and C are arbitrary precision floating point numbers.
C is the quotient of A and B. C=A/B. \ecom 
\proc{APSUM} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point sum.
A, B and C are arbitrary precision floating point numbers.
C is the sum of A and B. C=A+B. \ecom 
\proc{APDIFF} (A,B: LIST): LIST; \eproc
\bcom Arbitrary precision floating point difference.
A, B and C are arbitrary precision floating point numbers.
C is the difference of A and B. C=A-B. \ecom 
\proc{APLG10} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point logarithm base 10.
A is an arbitrary precision floating point number,
l is a beta integer, l=LOG10(ABS(A)).  \ecom 
\proc{APEXP} (A,NL: LIST): LIST; \eproc
\bcom Arbitrary precision floating point exponentiation.
A and B are arbitrary precision floating point numbers.
n is a beta-integer. B=A**n. \ecom 
\proc{APFRN} (A: LIST): LIST; \eproc
\bcom Arbitrary precision floating point from rational number.
B is an arbitrary precision floating point number.
A is a rational number. \ecom 
\proc{RNFAP} (A: LIST): LIST; \eproc
\bcom Rational number from arbitrary precision floating point.
A is an arbitrary precision floating point number.
B is a rational number. \ecom 
\proc{RNDRD} (): LIST; \eproc
\bcom Rational number decimal read. The rational number R is read
from the input stream. Any preceding blanks are skipped. \ecom 
\proc{APROOT} (A,NL: LIST): LIST; \eproc
\bcom Arbitrary precision floating point n-th root.
A and B are arbitrary precision floating point numbers.
B is the n-th root of A. \ecom 
\proc{APPI} (): LIST; \eproc
\bcom Arbitrary precision floating point pi.
pi is an arbitrary precision floating point number.  \ecom 
\section{ MAS Floating Point  } 
\proc{FFGI} (N: GAMMAINT): MFLOAT; \eproc
\bcom Floating point from gamma integer.
The gamma integer N is converted to the floating point number A.  \ecom 
\proc{IFF} (F: MFLOAT): LIST; \eproc
\bcom Integer from floating point.
The floating point number F is converted to the integer A.  \ecom 
\proc{FEXP} (F, N: MFLOAT): MFLOAT; \eproc
\bcom Floating point exponentiation.
The floating point number F raised to the n-th power.  \ecom 
\proc{FLOG10} (F: MFLOAT): MFLOAT; \eproc
\bcom Floating point logarithm base 10.
The logarithm of the floating point number F with base 10 is returned.  \ecom 
\proc{FFINT} (N: LIST): MFLOAT; \eproc
\bcom Floating point from integer.
The integer N is converted to the floating point number f.  \ecom 
\proc{FFRN} (A: LIST): MFLOAT; \eproc
\bcom Floating point from rational number.
The rational number A is converted to the floating point number f.  \ecom 
\proc{RNFF} (F: MFLOAT): LIST; \eproc
\bcom Rational number from floating point.
The floating point number F is converted to the rational number R.  \ecom 
\proc{SIN} (A: LIST): LIST; \eproc
\bcom Sinus. A is a rational number, the sinus of A is returned.  \ecom 
\proc{COS} (A: LIST): LIST; \eproc
\bcom Cosinus. A is a rational number, the cosinus of A is returned.  \ecom 
\proc{TAN} (A: LIST): LIST; \eproc
\bcom Tangens. A is a rational number, the tangens of A is returned.  \ecom 
\proc{ARCTAN} (A: LIST): LIST; \eproc
\bcom Arcus tangens. A is a rational number, the arctangens of A is returned.  \ecom 
\proc{EXPF} (A: LIST): LIST; \eproc
\bcom Exponential. A is a rational number, the exponential of A is returned.  \ecom 
\proc{LN} (A: LIST): LIST; \eproc
\bcom Ln. A is a rational number, the natural logarithm of A is returned.  \ecom 
\proc{LOG} (A: LIST): LIST; \eproc
\bcom Log. A is a rational number, the logarithm base 10 of A is returned.  \ecom 
\proc{SQRT} (A: LIST): LIST; \eproc
\bcom Sqrt. A is a rational number, the square root of A is returned.  \ecom 
\section{ MAS Integer  } 
\proc{IPROD} (A,B: LIST): LIST; \eproc
\bcom Integer product. A and B are integers. C=A*B. For long
integers Karatsubas method is used.  \ecom 
\section{ MAS Rational Number  } 
\proc{RNDRD} (): LIST; \eproc
\bcom Rational number decimal read. The rational number R is read
from the input stream. Any preceding blanks are skipped. \ecom 
\proc{RNDWR} (R,NL: LIST); \eproc
\bcom Rational number decimal write. R is a rational number. n is a
non-negative integer.  R is approximated by a decimal fraction D with
n decimal digits following the decimal point and D is written in the
output stream.  The inaccuracy of the approximation is at most
(1/2)*10**-n.  \ecom 
\proc{RNDWRS} (A,S: LIST); \eproc
\bcom Rational number decimal write special.
Call RNDWR.  \ecom 
\proc{RNEXP} (A,NL: LIST): LIST; \eproc
\bcom Rational number exponentiation. A is a rational number,
n is a non-negative beta-integer. B=A**n. \ecom 
\proc{RNMAX} (AL,BL: LIST): LIST; \eproc
\bcom Rational number maximum. a and b are rational numbers.
c is the maximum of a and b. \ecom 
\proc{RNONE} (R: LIST): LIST; \eproc
\bcom Rational number one. R is a rational number. s=1 if R=1,
s=0 else.  \ecom 
\section{ SAC Combinatorical System  } 
\proc{ASSPR} (A: LIST; VAR PL,ML: LIST); \eproc
\bcom Assignment problem. A is a square matrix of beta-integers, say
n by n.  p is an n-permutation for which the sum on i of
A(i,p(i)) is maximal, and m is this maximal sum.  All matrix
elements A(i,j) must be less than beta in absolute value. \ecom 
\proc{CSFPAR} (L: LIST): LIST; \eproc
\bcom Characteristic set from partition. L is a list of non-negative beta-
integers (l sub 1, ...,l sub n).  C is a characteristic set, with j
belonging to C if and only if there is a subset I of the integers from
1 to n such that the sum of the l sub i with i in I=j. \ecom 
\proc{CSINT} (A,B: LIST): LIST; \eproc
\bcom Characteristic set intersection. A and B are characteristic sets.
C is the intersection of A and B. \ecom 
\proc{CSSUB} (A,B: LIST): LIST; \eproc
\bcom Characteristic set subset. A and B are characteristic sets. t=1 if
A is a subset of B and otherwise t=0. \ecom 
\proc{CSUN} (A,B: LIST): LIST; \eproc
\bcom Characteristic set union. A and B are characteristic sets. C is the
union of A and B. \ecom 
\proc{DAND} (AL,BL: LIST): LIST; \eproc
\bcom Digit and. a and b are non-negative beta-digits. c is the
bit-wise and of a and b. \ecom 
\proc{DNIMP} (AL,BL: LIST): LIST; \eproc
\bcom Digit non-implication. a and b are non-negative beta-digits. c
is the bit-wise non-implication of a and b. \ecom 
\proc{DNOT} (AL: LIST): LIST; \eproc
\bcom Digit not. a is a non-negative beta-digit. b is the bit-wise
not of a. \ecom 
\proc{DOR} (AL,BL: LIST): LIST; \eproc
\bcom Digit or. a and b are non-negative beta-digits. c is the
bit-wise or of a and b. \ecom 
\proc{IBCIND} (A,NL,KL: LIST): LIST; \eproc
\bcom Integer binomial coefficient induction. n and k are beta-integers
with 0 less than or equal to k less than or equal to n.  A is the
binomial coefficient n over k.  B is the binomial coefficient n
over k+1. \ecom 
\proc{IBCOEF} (NL,KL: LIST): LIST; \eproc
\bcom Integer binomial coefficient. n and k are beta-integers with
0 less than or equal to k less than or equal to n.  A is the binomial
coefficient n over k. \ecom 
\proc{IBCPS} (NL,KL: LIST): LIST; \eproc
\bcom Integer binomial coefficient partial sum. n and k are
beta integers, 0 le k le n.  A is the sum on i, from 0 to k, of the
binomial coefficient n over i. \ecom 
\proc{IFACTL} (NL: LIST): LIST; \eproc
\bcom Integer factorial. n is a non-negative beta-integer. A is
n factorial. \ecom 
\proc{LEXNEX} (A: LIST): LIST; \eproc
\bcom Lexicographically next. A is a non-null list (a sub 1, ...,a sub m)
such that a sub i is a non-null reductant of a sub i+1 for each
1 le i lt m.  B is the lexicographically next such list of the same
length, if one exists, and is () otherwise. \ecom 
\proc{LPERM} (L,P: LIST): LIST; \eproc
\bcom List permute. L is a list (a sub 1, ...,a sub n). P is a list
(p sub 1, ...,p sub n) of integers in the range 1, ...,n.  LP is the
list (a sub p sub 1, ...,a sub p sub n). \ecom 
\proc{PARTN} (NL,P: LIST): LIST; \eproc
\bcom Partition, next. n is a positive beta-integer. P is a partition of
n.  Q is the next partition of n after P in lexicographical order,
if any. Otherwise Q=(). \ecom 
\proc{PARTR} (NL: LIST): LIST; \eproc
\bcom Partition, random. n is a positive beta-integer, n less than or
equal to 100.  P is a partition of n whose elements are the cycle
lengths of a random n-permutation. \ecom 
\proc{PARTSS} (PL: LIST): LIST; \eproc
\bcom Partition sumset. p is a partition. A is the sum set of p,
a characteristic set. \ecom 
\proc{PERMR} (NL: LIST): LIST; \eproc
\bcom Permutation, random. n is a positive integer, n le 100. L is a
list of the first n positive integers in random order. \ecom 
\proc{SDR} (S: LIST; VAR A,I: LIST); \eproc
\bcom System of distinct representatives. S is a list (s(1), ...,s(n)),
n ge 1, where each s(i) is a set of beta-integers represented as a
list.  Either A is a list (a(1), ...,a(n)) of distinct
representatives for (s(1), ...,s(n)) and I=(), or else A=() and
I=(i(1), ...,i(k)) is a subsequence of (1, ...,n) such that
(s(i(1)), ...,s(i(k))) has no system of distinct representatives. \ecom 
\proc{SFCS} (A: LIST): LIST; \eproc
\bcom Set from characteristic set. A is a characteristic set. B is the
same set represented as an increasing list of beta-integers. \ecom 
\section{ SAC Digit  } 
\proc{BITRAN} (): LIST; \eproc
\bcom Bit, random. b is a random bit, 0 or 1. \ecom 
\proc{DEGCD} (AL,BL: LIST; VAR CL,UL,VL: LIST); \eproc
\bcom Digit extended greatest common divisor. a and b are beta-integers,
a ge b ge 0.  c=GCD(a,b), a beta-integer.  a*u+b*v=c, with
ABS(u) le b/2c, ABS(v) le a/2c. \ecom 
\proc{DGCD} (AL,BL: LIST): LIST; \eproc
\bcom Digit greatest common divisor. a and b are beta-integers,
a ge b ge 0. c=GCD(a,b). \ecom 
\proc{DLOG2} (AL: LIST): LIST; \eproc
\bcom Digit logarithm, base 2. a is a beta-digit. If a=0 then n=0.
otherwise n=FLOOR(LOG2(ABS(a)))+1. \ecom 
\proc{DPCC} (AL1,AL2: LIST; VAR UL,ULP,VL,VLP: LIST); \eproc
\bcom Digit partial cosequence calculation. a1 and a2 are beta-integers,
a1 ge a2 gt 0.  u, up, v and vp are the last cosequence elements
of a1 and a2 which can be guaranteed to correspond to correct
quotient digits. \ecom 
\proc{DPR} (AL,BL: LIST; VAR CL,DL: LIST); \eproc
\bcom Digit product. a and b are beta-digits. c and d are the unique
beta-digits such that a*b=c*beta+d and c*d ge 0. \ecom 
\proc{DQR} (AL1,AL0,BL: LIST; VAR QL,RL: LIST); \eproc
\bcom Digit quotient and remainder. a1, a0 and b are beta-integers with
a1*a0 ge 0 and ABS(b) gt ABS(a1).  q is the integral part of
(a1*beta+a0)/b and r is (a1*beta+a0)-b*q.  q and r are
beta-integers. \ecom 
\proc{DRAN} (): LIST; \eproc
\bcom Digit, random. a is a random beta-digit. \ecom 
\proc{DRANN} (): LIST; \eproc
\bcom Digit, random non-negative. a is a random non-negative beta-digit.
Caution, the low-order bits of a are not very random. \ecom 
\proc{DSQRTF} (AL: LIST; VAR BL,TL: LIST); \eproc
\bcom Digit square root function. a is a non-negative beta-integer.
b is the floor function of the square root of a and t is the sign
of a-b*b. \ecom 
\section{ SAC Integer  } 
\proc{AADV} (L: LIST; VAR AL,LP: LIST); \eproc
\bcom Arithmetic advance. L is a list. If L ne () then a=FIRST(L) and
LP=RED(L). Otherwise a=0 and LP=(). \ecom 
\proc{IABSF} (A: LIST): LIST; \eproc
\bcom Integer absolute value function. A is an integer. B=ABS(A). \ecom 
\proc{ICOMP} (A,B: LIST): LIST; \eproc
\bcom Integer comparison. A and B are integers. s=SIGN(A-B). \ecom 
\proc{IDEGCD} (AL,BL: LIST; VAR CL,UL1,VL1,UL2,VL2: LIST); \eproc
\bcom Integer doubly extended greatest common divisor algorithm. a and b
are integers.  c=GCD(a,b).  a*u1+b*v1=c and a*u2+b*v2=0.
If a ne 0 and b ne 0 then ABS(u1) le ABS(b)/(2*c), ABS(v1) le
ABS(a)/(2*c), u2=-b/c and v2=a/c.  Otherwise u1=v2=SIGN(a),
v1=SIGN(b) and u2=-SIGN(b). \ecom 
\proc{IDIF} (A,B: LIST): LIST; \eproc
\bcom Integer difference. A and B are integers. C=A-B. \ecom 
\proc{IDIPR2} (A,B,AL,BL: LIST): LIST; \eproc
\bcom Integer digit inner product, length 2. A and B are integers.
a and b are beta-integers. C=A*a+B*b. \ecom 
\proc{IDPR} (A,BL: LIST): LIST; \eproc
\bcom Integer-digit product. A is an integer. b is a beta-digit.
C=A*b. \ecom 
\proc{IDP2} (A,KL: LIST): LIST; \eproc
\bcom Integer division by power of 2. A is an integer. k is a
non-negative beta-digit. B is the integral part of A/2**k. \ecom 
\proc{IDQ} (A,BL: LIST): LIST; \eproc
\bcom Integer-digit quotient. A is an integer. b is a non-zero
beta-digit. C=INTEGER(A/b). \ecom 
\proc{IDQR} (A,BL: LIST; VAR Q,RL: LIST); \eproc
\bcom Integer-digit quotient and remainder. A is an integer. b is a
non-zero beta-digit. Q is the integral part of A/b and r=A-b*Q. \ecom 
\proc{IDREM} (A,BL: LIST): LIST; \eproc
\bcom Integer-digit remainder. A is an integer. b is a non-zero
beta-digit. r=A-b*INTEGER(A/b). \ecom 
\proc{IEGCD} (AL,BL: LIST; VAR CL,UL1,VL1: LIST); \eproc
\bcom Integer extended greatest common divisor algorithm. a and b are
integers.  c=GCD(a,b).  a*u1+b*v1=c.  If a ne 0 and b ne 0
then ABS(u1) le ABS(b)/(2*c) and ABS(v1) le ABS(a)/(2*c).
Otherwise u1=SIGN(a) and v1=SIGN(b). \ecom 
\proc{IEVEN} (A: LIST): BOOLEAN; \eproc
\bcom Integer even. A is an integer. If A is even then true is returned
and otherwise false.  \ecom 
\proc{IEXP} (A,NL: LIST): LIST; \eproc
\bcom Integer exponentiation. A is an integer. n is a non-negative
beta-integer. B=A**n. \ecom 
\proc{IFCL2} (AL: LIST; VAR ML,NL: LIST); \eproc
\bcom Integer, floor and ceiling, logarithm, base 2. a is a non-zero
integer.  m and n, gamma-integers, are the floor and ceiling of
LOG2(ABS(a)) respectively. \ecom 
\proc{IGCD} (A,B: LIST): LIST; \eproc
\bcom Integer greatest common divisor. A and B are integers. C=GCD(A,B). \ecom 
\proc{IGCDCF} (A,B: LIST; VAR C,AB,BB: LIST); \eproc
\bcom Integer greatest common divisor and cofactors. A and B are integers.
C eq GCD(A,B).  If C eq 0 then AB eq BB eq 0 and otherwise
AB eq A/C,BB eq B/C. \ecom 
\proc{IHEGCD} (A,B: LIST; VAR C,V: LIST); \eproc
\bcom Integer half-extended greatest common divisor. A and B are integers.
C=GCD(A,B).  If A ne 0, B*V=C(mod A), with ABS(V) le ABS(A)/2C.  If
A=0,V=SIGN(B). \ecom 
\proc{ILCM} (A,B: LIST): LIST; \eproc
\bcom Integer least common multiple. A and B are integers.
C=LCM(A,B), a nonnegative integer. \ecom 
\proc{ILCOMB} (A,B,UL,VL: LIST): LIST; \eproc
\bcom Integer linear combination. A and B are non-negative integers.
u and v are beta-integers such that A*u+B*v ge 0. C=A*u+B*v. \ecom 
\proc{ILOG2} (A: LIST): LIST; \eproc
\bcom Integer logarithm, base 2. A is an integer. If A=0 then n=0.
Otherwise n=FLOOR(LOG2(ABS(A)))+1, a beta-integer. \ecom 
\proc{ILWRIT} (L: LIST); \eproc
\bcom Integer list write. L is a list of integers. The list L is written
in the output stream. \ecom 
\proc{IMAX} (AL,BL: LIST): LIST; \eproc
\bcom Integer maximum. a and b are integers. c is the maximum of a
and b. \ecom 
\proc{IMIN} (AL,BL: LIST): LIST; \eproc
\bcom Integer minimum. a and b are integers. c is the minimum of a
and b. \ecom 
\proc{IMP2} (A,HL: LIST): LIST; \eproc
\bcom Integer multiplication by power of 2. A is an integer. h is a
non-negative beta-integer. B=A*(2**h). \ecom 
\proc{INEG} (A: LIST): LIST; \eproc
\bcom Integer negation. A is an integer. B=-A. \ecom 
\proc{IODD} (A: LIST): BOOLEAN; \eproc
\bcom Integer odd. A is an integer. If a is odd then true is returned
and otherwise false.  \ecom 
\proc{IORD2} (AL: LIST): LIST; \eproc
\bcom Integer, order of 2. a is a non-zero integer. n is the largest
integer such that 2**n divides a. \ecom 
\proc{IPOWER} (A,L: LIST; VAR B,NL: LIST); \eproc
\bcom Integer power. A, greater than or equal to 3, is an odd positive
integer.  L is a list (p(1),p(2), ...,p(k)) of the first k prime
numbers, with p(k) greater than or equal to the base 3 logarithm of A.
If A=B**m for some m greater than or equal to 2 then n is the least
such m and B=A**(1/n). Otherwise B=0 and n=0. \ecom 
\proc{IPROD} (A,B: LIST): LIST; \eproc
\bcom Integer product. A and B are integers. C=A*B. \ecom 
\proc{IPRODK} (A,B: LIST): LIST; \eproc
\bcom Integer product, Karatsuba algorithm. A and B are integers. C=A*B. \ecom 
\proc{IQ} (A,B: LIST): LIST; \eproc
\bcom Integer quotient. A and B are integers, B ne 0. C is the integral
part of A/B. \ecom 
\proc{IQR} (A,B: LIST; VAR Q,R: LIST); \eproc
\bcom Integer quotient and remainder. A and B are integers, B ne 0. Q is
the quotient, integral part of A/B, and R is the remainder A-B*Q. \ecom 
\proc{IRAND} (NL: LIST): LIST; \eproc
\bcom Integer, random. n is a positive beta-integer. A is an integer
with random sign and random absolute value less than 2**n. \ecom 
\proc{IREAD} (): LIST; \eproc
\bcom Integer read. The integer A is read from the input stream. Any
preceding blanks are skipped. \ecom 
\proc{IREM} (A,B: LIST): LIST; \eproc
\bcom Integer remainder. A and B are integers, B non-zero. C is the
remainder of A and B. \ecom 
\proc{IROOT} (A,NL: LIST; VAR B,TL: LIST); \eproc
\bcom Integer root. A is a positive integer. n, greater than or equal
to 2, is a beta-integer. B=FLOOR(A**(1/n)) and t=SIGN(A-B**n). \ecom 
\proc{ISEG} (A,NL: LIST; VAR A1,A0: LIST); \eproc
\bcom Integer segmentation. A is an integer. n is a positive beta-
integer. A1 is the integral part of A/beta**n. A0=A-A1*beta**n. \ecom 
\proc{ISIGNF} (A: LIST): LIST; \eproc
\bcom Integer sign function. A is an integer. s=SIGN(A). \ecom 
\proc{ISQRT} (A: LIST; VAR B,TL: LIST); \eproc
\bcom Integer square root. A is a non-negative integer. B is the floor
function of the square root of A and t is the sign of A-B*B. \ecom 
\proc{ISSUM} (NL,L: LIST): LIST; \eproc
\bcom Integer shifted sum. n is a positive integer. L is a list
(c(0),c(1), ...,c(k)), k non-negative, of integers c(i) with
ABS(c(i)) less than beta**(2*n+1).  Either each c(i) is
non-negative or each c(i) is non-positive.  C is the sum on i,
from 0 to k, of c(i)*(beta**(i*n)). \ecom 
\proc{ISUM} (A,B: LIST): LIST; \eproc
\bcom Integer sum. A and B are integers. C=A+B. \ecom 
\proc{ITRUNC} (A,NL: LIST): LIST; \eproc
\bcom Integer truncation. A is an integer. n is a beta-integer.
B=INTEGER(A/2**n). \ecom 
\proc{IWRITE} (A: LIST); \eproc
\bcom Integer write. The input integer A is converted to decimal and
written in the output stream. \ecom 
\section{ SAC Modular Digit and Integer  } 
\proc{MDCRA} (ML1,ML2,MLP1,AL1,AL2: LIST): LIST; \eproc
\bcom Modular digit chinese remainder algorithm. m1 and m2 are positive
beta-integers, with GCD(m1,m2)=1 and m=m1*m2 less than beta.
mp1 is the inverse of m1 in Z(m2).  a1 and a2 are elements of
Z(m1) and Z(m2) respectively.  a is the unique element of Z(m) such
that a is congruent to a1 modulo m1 and a is congruent to a2
modulo m2. \ecom 
\proc{MDDIF} (ML,AL,BL: LIST): LIST; \eproc
\bcom Modular digit difference. m is a positive beta-integer. a and b
belong to Z sub m. c=a-b. \ecom 
\proc{MDEXP} (ML,AL,NL: LIST): LIST; \eproc
\bcom Modular digit exponentiation. m is a positive beta-integer.
a belongs to Z sub m. n is a non-negative beta-integer. b=a**n. \ecom 
\proc{MDHOM} (ML,A: LIST): LIST; \eproc
\bcom Modular digit homomorphism. m is a positive beta-integer. A is an
integer. b is the image of A under the homomorphism H sub m. \ecom 
\proc{MDINV} (ML,AL: LIST): LIST; \eproc
\bcom Modular digit inverse. m is a positive beta-integer. a is a unit
of Z sub m. b=a**-1. \ecom 
\proc{MDLCRA} (ML1,ML2,L1,L2: LIST): LIST; \eproc
\bcom Modular digit list chinese remainder algorithm. m1 and m2 are
positive beta-integers, with GCD(m1,m2)=1 and m=m1*m2 less than
beta.  L1 and L2 are lists of elements of Z(m1) and Z(m2)
respectively.  L is a list of all a in Z(m) such that a is congruent
to a1 modulo m1 and a is congruent to a2 modulo m2 with a1 in L1
and a2 in L2. \ecom 
\proc{MDNEG} (ML,AL: LIST): LIST; \eproc
\bcom Modular digit negative. m is a positive beta-integer. a belongs
to Z sub m. b=-a. \ecom 
\proc{MDPROD} (ML,AL,BL: LIST): LIST; \eproc
\bcom Modular digit product. m is a positive beta-integer. a and b
belong to Z sub m. c=a*b. \ecom 
\proc{MDQ} (ML,AL,BL: LIST): LIST; \eproc
\bcom Modular digit quotient. m is a positive beta-integer. a and b
belong to Z sub m. b is a unit. c=a/b. \ecom 
\proc{MDRAN} (ML: LIST): LIST; \eproc
\bcom Modular digit, random. m is a positive beta-digit. a is a random
element of Z(m). \ecom 
\proc{MDSUM} (ML,AL,BL: LIST): LIST; \eproc
\bcom Modular digit sum. m is a positive beta-integer. a and b belong
to Z sub m. c=a+b. \ecom 
\proc{MIDCRA} (M,ML,MLP,A,AL: LIST): LIST; \eproc
\bcom Modular integer digit chinese remainder algorithm. M is a positive
integer.  m is an odd positive beta-integer.  GCD(M,m)=1.  mp is the
inverse of the image of M under the homomorphism H sub m.  A and a
are elements of Z prime sub M and Z sub m respectively.  AS is the
unique element of Z prime sub MS which is congruent to A modulo M and
congruent to a modulo m, where MS=M*m. \ecom 
\proc{MIDIF} (M,A,B: LIST): LIST; \eproc
\bcom Modular integer difference. M is a positive integer. A and B
belong to Z sub M. C=A-B. \ecom 
\proc{MIEXP} (M,A,N: LIST): LIST; \eproc
\bcom Modular integer exponentiation. M is a positive integer. A is an
element of Z(M). N is a non-negative integer. B=A**N in Z(M). \ecom 
\proc{MIHOM} (M,A: LIST): LIST; \eproc
\bcom Modular integer homomorphism. M is a positive integer. A is an
integer. AS=H sub M(A). \ecom 
\proc{MIINV} (M,A: LIST): LIST; \eproc
\bcom Modular integer inverse. M is a positive integer. A is a unit of
Z sub M. B=A**-1. \ecom 
\proc{MINEG} (M,A: LIST): LIST; \eproc
\bcom Modular integer negation. M is a positive integer. A belongs to
Z sub M. B=-A. \ecom 
\proc{MIPROD} (M,A,B: LIST): LIST; \eproc
\bcom Modular integer product. M is a positive integer. A and B belong to
Z(M). C=A*B in Z(M). \ecom 
\proc{MIQ} (M,A,B: LIST): LIST; \eproc
\bcom Modular integer quotient. M is a positive integer. A and B belong
to Z sub M. B is a unit. C=A/B. \ecom 
\proc{MIRAN} (M: LIST): LIST; \eproc
\bcom Modular integer, random. M is a positive integer. R is a uniformly
distributed random element of Z sub M. \ecom 
\proc{MISUM} (M,A,B: LIST): LIST; \eproc
\bcom Modular integer sum. M is a positive integer. A and B belong to
Z sub M. C=A+B. \ecom 
\proc{SMFMI} (M,A: LIST): LIST; \eproc
\bcom Symmetric modular from modular integer. M is a positive integer.
A belongs to Z sub M. B belongs to Z prime sub M with B=A(modulo M). \ecom 
\section{ SAC Factorization and Prime Number  } 
\proc{DPGEN} (ML, K: LIST): LIST; \eproc
\bcom Digit prime generator. K and m are positive beta-integers.
L is the list (p(1),...,p(r)) of all prime numbers p such that 
m le p lt m+2*K, with p(1) lt p(2) lt ... lt p(r).  
A local array is used. \ecom 
\proc{FRESL} (NL: LIST; VAR ML,L: LIST); \eproc
\bcom Fermat residue list. n is a positive integer with no prime divisors
less than 17.  m is a positive beta-integer and L is an ordered list
of the elements of Z(m) such that if x**2-n is a square then x is
congruent to a (modulo m) for some a in L. \ecom 
\proc{FRLSM} (ML,AL: LIST): LIST; \eproc
\bcom Fermat residue list, single modulus. m is a positive beta-integer.
a belongs to Z(m).  L is a list of the distinct b in Z(m) such
that b**2-a is a square in Z(m). \ecom 
\proc{GDPGEN} (ML: LIST; KL: INTEGER): LIST; \eproc
\bcom Gaussian digit prime generator. m and k are positive beta-integers.
L is the list (p(1),...,p(r)) of all prime numbers p such that m is 
less than or equal to p, p is less than m+4*k and p is congruent to 
3 mod 4, with p(1) lt p(2) lt ... lt p(r). A local array is used. \ecom 
\proc{IFACT} (NL: LIST): LIST; \eproc
\bcom Integer factorization. n is a positive integer. F is a list
(q(1), q(2),...,q(h)) of the prime factors of n, q(1) le q(2) le ...
le q(h), with n equal to the product of the q(i). \ecom 
\proc{ILPDS} (NL,AL,BL: LIST; VAR PL,NLP: LIST); \eproc
\bcom Integer large prime divisor search. n is a positive integer with
no prime divisors less than 17.  1 le a le b le n.  A search is made
for a divisor p of the integer n, with a le p le b.  If such a p
is found then np=n/p, otherwise p=1 and np=n.  A modular version
of fermats method is used, and the search goes from a to b. \ecom 
\proc{IMPDS} (NL,AL,BL: LIST; VAR PL,QL: LIST); \eproc
\bcom Integer medium prime divisor search. n, a and b are positive
integers such that a le b le n and n has no
positive divisors less than a.  If n has a prime
divisor in the closed interval from a to b then p is the least
such prime and q=n/p. Otherwise p=1 and q=n. \ecom 
\proc{ISPD} (NL: LIST; VAR F,ML: LIST); \eproc
\bcom Integer small prime divisors. n is a positive integer.
F is a list of primes (q(1),q(2),...,q(h)), h non-negative,
q(1) le q(2) le ... lt q(h), such that n is equal to m times the
product of the q(i) and m is not divisible by any prime in SMPRM.
Either m=1 or m gt 1,000,000. \ecom 
\proc{ISPT} (ML,MLP,F: LIST): LIST; \eproc
\bcom Integer selfridge primality test. m is an integer greater than or
equal to 3.  mp=m-1.  F is a list (q(1),q(2),...,q(k)),
q(1) le q(2) le ... le q(k), of the prime factors of mp, with
mp equal to the product of the q(i). An attempt is made to find a 
root of unity modulo m of order m-1.  If the existence of such a root 
is discovered then m is prime and s=1.  If it is discovered that no such
root exists then m is not a prime and s=-1.  Otherwise the primality
of m remains uncertain and s=0. \ecom 
\section{ SAC Rational Number  } 
\proc{RIRNP} (I,CL: LIST): LIST; \eproc
\bcom Rational interval rational number product. I is an interval with
rational endpoints. c is a rational number. J is the interval I*c. \ecom 
\proc{RNABS} (R: LIST): LIST; \eproc
\bcom Rational number absolute value. R is a rational number. S is the
absolute value of R. \ecom 
\proc{RNCEIL} (RL: LIST): LIST; \eproc
\bcom Rational number, ceiling of. r is a rational number. a=CEILING(r),
an integer. \ecom 
\proc{RNCOMP} (R,S: LIST): LIST; \eproc
\bcom Rational number comparison. R and S are rational numbers.
t=SIGN(R-S). \ecom 
\proc{RNDEN} (R: LIST): LIST; \eproc
\bcom Rational number denominator. R is a rational number. b is the
denominator of R, a positive integer. \ecom 
\proc{RNDIF} (R,S: LIST): LIST; \eproc
\bcom Rational number difference. R and S are rational numbers. T=R-S. \ecom 
\proc{RNDWR} (R,NL: LIST); \eproc
\bcom Rational number decimal write. R is a rational number. n is a
non-negative integer.  R is approximated by a decimal fraction D with
n decimal digits following the decimal point and D is written in the
output stream.  The inaccuracy of the approximation is at most
(1/2)*10**-n.  If ABS(D) is greater than ABS(R) then the last digit is
followed by a minus sign, if ABS(D) is less than ABS(R) then by a
plus sign. \ecom 
\proc{RNFCL2} (AL: LIST; VAR ML,NL: LIST); \eproc
\bcom Rational number floor and ceiling of logarithm, base 2. a is a non-
zero rational number.  m=FLOOR(LOG2(ABS(a))) and n=CEILING(LOG2(ABS(a))) 
are gamma-integers. \ecom 
\proc{RNFLOR} (RL: LIST): LIST; \eproc
\bcom Rational number, floor of. r is a rational number. a=FLOOR(r),
an integer. \ecom 
\proc{RNINT} (A: LIST): LIST; \eproc
\bcom Rational number from integer. A is an integer. R is the rational
number A/1. \ecom 
\proc{RNINV} (R: LIST): LIST; \eproc
\bcom Rational number inverse. R is a non-zero rational number. S=1/R. \ecom 
\proc{RNNEG} (R: LIST): LIST; \eproc
\bcom Rational number negative. R is a rational number. S=-R. \ecom 
\proc{RNNUM} (R: LIST): LIST; \eproc
\bcom Rational number numerator. R is a rational number. a is the
numerator of R, an integer. \ecom 
\proc{RNPROD} (R,S: LIST): LIST; \eproc
\bcom Rational number product. R and S are rational numbers. T=R*S. \ecom 
\proc{RNP2} (KL: LIST): LIST; \eproc
\bcom Rational number power of 2. k is a gamma-integer. r=2**k, a
rational number. \ecom 
\proc{RNQ} (R,S: LIST): LIST; \eproc
\bcom Rational number quotient. R and S are rational numbers, S non-zero.
T=R/S. \ecom 
\proc{RNRAND} (NL: LIST): LIST; \eproc
\bcom Rational number, random. n is a positive beta-integer. Random
integers A and B are generated using IRAND(n).  Then R=A/(ABS(B)+1),
reduced to lowest terms. \ecom 
\proc{RNREAD} (): LIST; \eproc
\bcom Rational number read. The rational number R is read from the input
stream. Any preceding blanks are skipped. \ecom 
\proc{RNRED} (A,B: LIST): LIST; \eproc
\bcom Rational number reduction to lowest terms. A and B are integers,
B non-zero. R is the rational number A/B in canonical form. \ecom 
\proc{RNSIGN} (R: LIST): LIST; \eproc
\bcom Rational number sign. R is a rational number. s=SIGN(R). \ecom 
\proc{RNSUM} (R,S: LIST): LIST; \eproc
\bcom Rational number sum. R and S are rational numbers. T=R+S. \ecom 
\proc{RNWRIT} (R: LIST); \eproc
\bcom Rational number write. R is a rational number. R is converted
to decimal and written in the output stream. \ecom 
\section{ SAC Set  } 
\proc{LBIBMS} (L: LIST): LIST; \eproc
\bcom List of beta-integers bubble-merge sort. L is an arbitrary list of
beta-integers, possibly with repetitions.  M is the result of sorting
L into non-decreasing order.  A combination of bubble-sort and merge-
sort is used. The list L is modified to produce M. \ecom 
\proc{LBIBS} (L: LIST); \eproc
\bcom List of beta-integers bubble sort. L is an arbitrary list of
beta-integers, with possible repetitions.  L is sorted into
non-decreasing order by the bubble-sort method.  The list L, though not
its location, is modified. \ecom 
\proc{LBIM} (L1,L2: LIST): LIST; \eproc
\bcom List of beta-integers merge. L1 and L2 are arbitrary lists of
beta-integers in non-decreasing order.  L is the merge of L1 and L2.
L1 and L2 are modified to produce L. \ecom 
\proc{SCOMP} (AL,L: LIST): LIST; \eproc
\bcom Set composition. a is a beta-integer, L is a set of beta-integers.
LP is the union of SET(a) and L.  \ecom 
\proc{SDIFF} (A,B: LIST): LIST; \eproc
\bcom Set difference. A and B are sets of beta-integers. C=A-B. \ecom 
\proc{SINTER} (A,B: LIST): LIST; \eproc
\bcom Set intersection. A and B are sets of beta-integers. C is the
intersection of A and B. \ecom 
\proc{SUNION} (A,B: LIST): LIST; \eproc
\bcom Set union. A and B are sets of beta-integers. C is the union of
A and B. \ecom 
\proc{USCOMP} (AL,L: LIST): LIST; \eproc
\bcom Unordered set composition. a is an object, L is an unordered set.
LP is the union of SET(a) and L.  \ecom 
\proc{USDIFF} (A,B: LIST): LIST; \eproc
\bcom Unordered set difference. A and B are unordered sets. C is the
difference A-B. \ecom 
\proc{USINT} (A,B: LIST): LIST; \eproc
\bcom Unordered set intersection. A and B are unordered sets. C is the
intersection of A and B. \ecom 
\proc{USUN} (A,B: LIST): LIST; \eproc
\bcom Unordered set union. A and B are unordered sets. C is the union
of A and B. \ecom 
