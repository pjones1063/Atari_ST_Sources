\section{ MAS Basic I/O System  } 
\proc{BKSP} ; \eproc
\bcom Backspace. Reread the last character from the input stream.  \ecom 
\proc{BLINES} (N: GAMMAINT); \eproc
\bcom Blank lines. N is a positive integer. N records of one blank each
are output.  \ecom 
\proc{CREAD} (): GAMMAINT; \eproc
\bcom Character read. Returns next character from the input stream.  \ecom 
\proc{CREADB} (): GAMMAINT; \eproc
\bcom Character read, skipping blanks. Returns next character from the
input stream.  \ecom 
\proc{CWRITE} (C: GAMMAINT); \eproc
\bcom Character write. The character c is transmitted to the output
stream.  \ecom 
\proc{CloseBIOS} ; \eproc
\bcom Close BIOS. Close all streams and write summary.  \ecom 
\proc{CUNIT} (S: ARRAY OF CHAR): GAMMAINT; \eproc
\bcom Close unit. The unit S is closed, with S as the external name.
CUNIT returns 0 on successful completion, ne 0 else. \ecom 
\proc{DIBUFF} ; \eproc
\bcom Display input buffer. The input buffer status is displayed. \ecom 
\proc{DIGIT} (C: GAMMAINT): BOOLEAN; \eproc
\bcom Digit. c is a character. If c is a digit then TRUE is returned
otherwise FALSE is returned.  \ecom 
\proc{GREAD} (): GAMMAINT; \eproc
\bcom Gamma-integer read. A gamma-integer is read from the input
stream. any preceding blanks are skipped.  \ecom 
\proc{GWRITE} (a: GAMMAINT); \eproc
\bcom Gamma-integer write. The gamma-integer a is written in the output
stream. \ecom 
\proc{LETTER} (C: GAMMAINT): BOOLEAN; \eproc
\bcom Letter. c is a character. If c is a letter then TRUE is returned
otherwise FALSE is returned.  \ecom 
\proc{LISTS} (VAR S: ARRAY OF CHAR): LIST; \eproc
\bcom List from string. S is a character string with respect to local
character code. A list if the corresponding ALDES character codes
is returned. \ecom 
\proc{SLIST} (A: LIST; VAR S: ARRAY OF CHAR); \eproc
\bcom String from list. A is a list of ALDES character codes.
S is a the corresponding character string with respect to local
character codes.  \ecom 
\proc{MASCHR} (C: GAMMAINT): CHAR; \eproc
\bcom MAS character. Returns the local character for the aldes character c.  \ecom 
\proc{MASORD} (C: CHAR): GAMMAINT; \eproc
\bcom MAS order. Returns the aldes code for the character c.  \ecom 
\proc{MASORDI} (C: GAMMAINT): GAMMAINT; \eproc
\bcom MAS order integer. Returns the aldes code for the integer c. \ecom 
\proc{SILINE} (VAR S, L, R: GAMMAINT); \eproc
\bcom Set input line. The input line length is set to S, the left margin is
set to L and the right margin is set to R. If any of the values of 
S, L or R is negative, then the corresponding value is left unchanged. 
The values in effect are returned.  \ecom 
\proc{SIUNIT} (S: ARRAY OF CHAR): GAMMAINT; \eproc
\bcom Set input unit. iunit is set to n, with s as the external name.
siunit returns 0 on successful completion, ne 0 else. \ecom 
\proc{SOLINE} (VAR S, L, R: GAMMAINT); \eproc
\bcom Set output line. The output line length is set to S, the left margin is
set to L and the right margin is set to R. If any of the values of 
S, L or R is negative, then the corresponding value is left unchanged. 
The values in effect are returned.  \ecom 
\proc{SOUNIT} (S: ARRAY OF CHAR): GAMMAINT; \eproc
\bcom Set output unit. ounit is set to n, with s as the external name.
sounit returns 0 on successful completion, ne 0 else.
the current output buffer is emptied. \ecom 
\proc{Summary} ; \eproc
\bcom Summary of stream IO.  \ecom 
\proc{StorSummary} (); \eproc
\bcom MASSTOR Summary.  \ecom 
\proc{SWRITE} (VAR S: ARRAY OF CHAR); \eproc
\bcom String write. S is a character string with respect to local
character codes. The single characters are converted to ALDES codes
and written to the output stream.  \ecom 
\proc{TAB} (n: GAMMAINT); \eproc
\bcom Tabulate. n is a positive integer. if lmarg le n le rmarg then
blanks are inserted in obuff until opos eq n. \ecom 
\section{ MAS BIOS Utility  } 
\proc{INP} (A: LIST): LIST; \eproc
\bcom Input. Set input unit to stream A, A is an SAC-2 character list.  \ecom 
\proc{OUT} (A: LIST): LIST; \eproc
\bcom Output. Set output unit to stream A, A is an SAC-2 character list.  \ecom 
\proc{SHUT} (A: LIST): LIST; \eproc
\bcom Shut. Close stream A, A is an SAC-2 character list.  \ecom 
\proc{EDIT} (A: LIST): LIST; \eproc
\bcom Edit. Call editor for file A, A is an SAC-2 character list.  \ecom 
\proc{DOS} (A: LIST): LIST; \eproc
\bcom DOS. Call DOS program with parameters. A is an SAC-2 character list.  \ecom 
\proc{CLTIS} (A: LIST); \eproc
\bcom Character list to input stream. A is an SAC-2 character list.  \ecom 
\section{ MAS Configuration  } 
\section{ MAS Elementary Functions  } 
\proc{MASABS} (a: GAMMAINT): GAMMAINT; \eproc
\bcom Absolute value. a is a gamma-integer. Returns the absolute value
of a.  \ecom 
\proc{MASEVEN} (a: GAMMAINT): BOOLEAN; \eproc
\bcom Even. a is a gamma-integer. Returns TRUE if a is even and
FALSE otherwise.  \ecom 
\proc{MASEXP} (a,b: GAMMAINT): GAMMAINT; \eproc
\bcom Exponential function. a and b are gamma-integers, b non-negative.
Returns $a^b$, with $0^0=1$.  \ecom 
\proc{MASMAX} (a,b: GAMMAINT): GAMMAINT; \eproc
\bcom Maximum. a and b are gamma-integers. Returns the maximum of
a and b.  \ecom 
\proc{MASMIN} (a,b: GAMMAINT): GAMMAINT; \eproc
\bcom Minimum. a and b are gamma-integers. Returns the minimum
of a and b.  \ecom 
\proc{MASODD} (a: GAMMAINT): BOOLEAN; \eproc
\bcom Odd. a is a gamma-integer. Returns TRUE if a is odd and
FALSE otherwise.  \ecom 
\proc{MASQREM} (a,b: GAMMAINT; VAR q,r: GAMMAINT); \eproc
\bcom Quotient and remainder. a and b are gamma-integers, b non-zero.
$q=integer(a/b)$ and $r=a-b*q$.  \ecom 
\proc{MASREM} (a,b: GAMMAINT): GAMMAINT; \eproc
\bcom Remainder. a and b are gamma-integers, b non-zero.
Returns $a-b*integer(a/b)$.  \ecom 
\proc{MASSIGN} (a: GAMMAINT): GAMMAINT; \eproc
\bcom Sign. a is a gamma-integer. Returns the sign of a.  \ecom 
\section{ MAS GEM  } 
\proc{NextParm} (VAR s: ARRAY OF CHAR): BOOLEAN; \eproc
\bcom Next Parameter. The next parameter from the GEM environement is
placed in string s. If no parameter was found, FALSE is returned
and s is undefined, else TRUE is returned. The separator for the 
parameters is the blank character.  \ecom 
\proc{DOS} (s: ARRAY OF CHAR): INTEGER; \eproc
\bcom Call DOS program.  \ecom 
\proc{EDIT} (s: ARRAY OF CHAR): INTEGER; \eproc
\bcom Edit file with name s.  \ecom 
\section{ MAS Storage  } 
\proc{ADV} (L: LIST; VAR a, LP: LIST); \eproc
\bcom Advance. L is a non-null list. a=FIRST(L) and LP=RED(L).  \ecom 
\proc{CELLS} (): GAMMAINT; \eproc
\bcom Cells. Returns the used cells since storage initialization.  \ecom 
\proc{CLOCK} (): GAMMAINT; \eproc
\bcom Clock. Returns the current CPU clock reading in seconds.
At ATARI ST the clock is in 2 seconds intervalls.  \ecom 
\proc{COMP} (a,L: LIST): LIST; \eproc
\bcom Composition. a is an object. L is a list. Returns the
composition of a and L.  \ecom 
\proc{DEQUE} (L: LIST): LIST; \eproc
\bcom Dequeue. L is a non empty queue representing list. Returns a, the
first object from the queue. L is updated.  \ecom 
\proc{EMPTYQUE} (M: LIST): BOOLEAN; \eproc
\bcom Empty Queue. Tests if a queue is empty.  \ecom 
\proc{ENQUE} (a,L: LIST); \eproc
\bcom Enqueue. a is an object. L is a queue representing list. Appends a
to the quque L.  \ecom 
\proc{ERROR} (a: GAMMAINT; s: ARRAY OF CHAR); \eproc
\bcom Error. An error of severity a and indication s is reported.  \ecom 
\proc{ErrorHandler} (a: P0): GAMMAINT; \eproc
\bcom Error handler. Any error reported by the ERROR procedure is catched.  \ecom 
\proc{FIRST} (L: LIST): LIST; \eproc
\bcom First. L is a non-null list. a is the first element of L.  \ecom 
\proc{NEWQUE} (): LIST; \eproc
\bcom New Queue. Returns a new empty queue.  \ecom 
\proc{GENPROCESS} (P: PROC; VAR S: ADDRESS; n: BOOLEAN); \eproc
\bcom Generate a new process. The process working space is allocated unter
control of the garbage collector if n is TRUE, else it is assumed that 
the last working space is reused. P is a parameter less procedure,
S is the address of the generated process. If not enough space is 
available an error ocours.  \ecom 
\proc{INV} (L: LIST): LIST; \eproc
\bcom Inverse. L is a list. The inverse of L is returned. The list L is
modified.  \ecom 
\proc{LENGTH} (L: LIST): GAMMAINT; \eproc
\bcom Length. L is a list. Returns length(L). \ecom 
\proc{LIST1} (a: LIST): LIST; \eproc
\bcom List, 1 element. a is an object. L is the list (a).  \ecom 
\proc{LISTVAR} (VAR L: LIST); \eproc
\bcom List variable. L is a list. The address of L is made accessible
to the garbage collector.  \ecom 
\proc{RED} (L: LIST): LIST; \eproc
\bcom Reductum. L is a non-null list. Returns the reductum of L.  \ecom 
\proc{SFIRST} (L, a: LIST); \eproc
\bcom Set first. L is a non-null list. a is an object. The first
element of L is changed to a.  \ecom 
\proc{SRED} (L, LP: LIST); \eproc
\bcom Set reductum. L is a non-null list. LP is a list. The reductum
of L is changed to LP.  \ecom 
\proc{SAVEPROCESS} ; \eproc
\bcom Save current process. Prepare transfer of two processes
unter the control of the garbage collector.  \ecom 
\proc{TIME} (): GAMMAINT; \eproc
\bcom Time. Returns the CLOCK minus the garbage collection time TAU.
At ATARI ST the clock is in 2 seconds intervalls.  \ecom 
\section{ SAC Basic I/O System  } 
\proc{CWRIT2} (C1,C2: GAMMAINT); \eproc
\bcom Character write, 2 characters. C1 and C2 are sequentially
transmitted to the output stream using CWRITE. \ecom 
\proc{CWRIT3} (C1,C2,C3: GAMMAINT); \eproc
\bcom Character write, 3 characters. C1, C2 and C3 are sequentially
transmitted to the output stream using CWRITE. \ecom 
\proc{CWRIT4} (C1,C2,C3,C4: GAMMAINT); \eproc
\bcom Character write, 4 characters. C1, C2, C3, and C4 are sequentially
transmitted to the output stream using CWRITE. \ecom 
\proc{CWRIT5} (C1,C2,C3,C4,C5: GAMMAINT); \eproc
\bcom Character write, 5 characters. C1, C2, C3, C4 and C5 are
sequentially transmitted to the output stream using CWRITE. \ecom 
\proc{CWRIT6} (C1,C2,C3,C4,C5,C6: GAMMAINT); \eproc
\bcom Character write, 6 characters. C1, C2, C3, C4, C5 and C6 are
sequentially transmitted to the output stream using CWRITE. \ecom 
\section{ SAC List Processing  } 
\proc{ADV2} (L: LIST; VAR AL,BL,LP: LIST); \eproc
\bcom Advance 2. L is a list of length two or more. a=FIRST(L),
b=SECOND(L) and LP=RED(RED(L)). \ecom 
\proc{ADV3} (L: LIST; VAR AL1,AL2,AL3,LP: LIST); \eproc
\bcom Advance 3. L is a list of length 3 or more. a1, a2 and a3 are
the first three elements of L. LP is the third reductum of L. \ecom 
\proc{ADV4} (L: LIST; VAR AL1,AL2,AL3,AL4,LP: LIST); \eproc
\bcom Advance 4. L is a list of length 4 or more. a1, a2, a3, and a4
are the first 4 elements of L. LP is the fourth reductum of L. \ecom 
\proc{AREAD} (): LIST; \eproc
\bcom Atom read. An atom A is read from the input stream. Any preceding
blanks are skipped. \ecom 
\proc{AWRITE} (A: LIST); \eproc
\bcom Atom write. The atom A is written in the output stream. \ecom 
\proc{CCONC} (L1,L2: LIST): LIST; \eproc
\bcom Constructive concatenation. L1 and L2 are lists. L is the
concatenation of L1 and L2. The list L is constructed. \ecom 
\proc{CINV} (L: LIST): LIST; \eproc
\bcom Constructive inverse. L is a list. M=INV(L). M is constructed
using comp. \ecom 
\proc{CLOUT} (L: LIST); \eproc
\bcom Character list out. The input is a character list L=(C(1),C(2),...,
C(n)).  The C(i) are sequentially transmitted to the output stream 
using CWRITE. \ecom 
\proc{COMP2} (AL,BL,L: LIST): LIST; \eproc
\bcom Composition 2. a and b are objects. L is a list.
M=COMP(a,COMP(b,L)). \ecom 
\proc{COMP3} (AL1,AL2,AL3,L: LIST): LIST; \eproc
\bcom Composition 3. a1, a2 and a3 are objects. L is a list.
M=COMP(a1,COMP(a2,COMP(a3,L))). \ecom 
\proc{COMP4} (AL1,AL2,AL3,AL4,L: LIST): LIST; \eproc
\bcom Composition 4. a1, a2, a3 and a4 are objects. L is a list.
M=COMP(a1,COMP(a2,COMP(a3,COMP(a4,l)))). \ecom 
\proc{CONC} (L1,L2: LIST): LIST; \eproc
\bcom Concatenation. L1 and L2 are lists. L=CONC(L1,L2). The list L1 is
modified. \ecom 
\proc{EQUAL} (AL,BL: LIST): LIST; \eproc
\bcom Equal. a and b are objects. t=1 if a and b are equal and
otherwise t=0. \ecom 
\proc{EXTENT} (AL: LIST): LIST; \eproc
\bcom Extent. a is an object. n=EXTENT(a). \ecom 
\proc{FIRST2} (L: LIST; VAR AL,BL: LIST); \eproc
\bcom First 2. L is a list of length 2 or more. a=FIRST(L) and
b=SECOND(L). \ecom 
\proc{FIRST3} (L: LIST; VAR AL1,AL2,AL3: LIST); \eproc
\bcom First 3. L is a list of length 3 or more. a1=FIRST(L),
a2=SECOND(L) and a3=THIRD(L). \ecom 
\proc{FIRST4} (L: LIST; VAR AL1,AL2,AL3,AL4: LIST); \eproc
\bcom First 4. L is a list of length 4 or more. a1=FIRST(L),
a2=SECOND(L), a3=THIRD(L) and a4=FOURTH(L). \ecom 
\proc{FOURTH} (L: LIST): LIST; \eproc
\bcom Fourth. L is a list of length 4 or more. a is the fourth element
of L. \ecom 
\proc{LAST} (L: LIST): LIST; \eproc
\bcom Last. L is a non-null list. LP is the location of the last cell
of L. \ecom 
\proc{LEINST} (A,IL,AL: LIST): LIST; \eproc
\bcom List element insertion. A is the list (a(1), ...,a(n)) of objects.
i is a beta-integer, 0 le i le n.  a is an object.  If i=0, then
L=(a,a(1), ...,a(n)).  If i=n, then L=(a(1), ...,a(n),a).
otherwise, L=(a(1), ...,a(i),a,a(i+1), ...,a(n)). A is modified. \ecom 
\proc{LELT} (A,IL: LIST): LIST; \eproc
\bcom List element. A is a list. 1 le i le LENGTH(A). a is the i-th
element of A. \ecom 
\proc{LEROT} (L,IL,JL: LIST): LIST; \eproc
\bcom List element rotation. L is a list (a(1), ...,a(n)) of objects, n
gt 0.  i and j, 1 le i le j le n, are beta-integers.  If i=j
then M=L.  Otherwise M=(a(1), ...,a(i-1),a(j),a(i), ...,a(j-1),
a(j+1), ...,a(n)). L is modified. \ecom 
\proc{LINS} (AL,L: LIST); \eproc
\bcom List insertion. L is a non-null list (a(1), ...,a(n)). a is an
object.  a is inserted in L after a(1) (suffixed to L if n=1),
producing a modified list L=(a(1),a,a(2), ...,a(n)). \ecom 
\proc{LINSRT} (AL,A: LIST): LIST; \eproc
\bcom List insertion. A is a list (a(1), ...,a(n)) of beta-integers,
n ge 0, with a(1) lt a(2) lt  ...lt a(n).  If n=0 then B=(a).
If a lt a(1) then B=(a,a(1), ...,a(n)).  If a ge a(n) then
B=(a(1), ...,a(n),a).  Otherwise B=(a(1), ...,a(i),a,a(i+1),
 ...,a(n)) where a(i) le a lt a(i+1).  The list A is modified
to produce B. \ecom 
\proc{LIST10} (AL1,AL2,AL3,AL4,AL5,AL6,AL7,AL8,AL9,AL10: LIST): LIST; \eproc
\bcom List, 10 elements. a1, a2, a3, a4, a5, a6, a7, a8, a9 and a10 are
objects. L is the list (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10). \ecom 
\proc{LIST2} (AL,BL: LIST): LIST; \eproc
\bcom List, 2 elements. a and b are objects. L is the list (a,b). \ecom 
\proc{LIST3} (AL1,AL2,AL3: LIST): LIST; \eproc
\bcom List, 3 elements. a1, a2 and a3 are objects. L=(a1,a2,a3). \ecom 
\proc{LIST4} (AL1,AL2,AL3,AL4: LIST): LIST; \eproc
\bcom List, 4 elements. a1, a2, a3 and a4 are objects. L is the list
(a1,a2,a3,a4). \ecom 
\proc{LIST5} (AL1,AL2,AL3,AL4,AL5: LIST): LIST; \eproc
\bcom List, 5 elements. a1,a2,a3,a4 and a5 are objects. L is the list
(a1,a2,a3,a4,a5). \ecom 
\proc{LREAD} (): LIST; \eproc
\bcom List read. The list L is read from the input stream. Any preceding
blanks are skipped. \ecom 
\proc{LSRCH} (AL,A: LIST): LIST; \eproc
\bcom List search. A is a list of beta-integers, (a(1), ...,a(n)),
n ge 0.  If there is a j such that a=a(j) then i is the least
such j. Otherwise i=0. \ecom 
\proc{LWRITE} (L: LIST); \eproc
\bcom List write. The input list L is written in the output stream. \ecom 
\proc{MEMBER} (AL,L: LIST): LIST; \eproc
\bcom Membership test. a is an object, L a list. t=1 if a is a
member of L and otherwise t=0. \ecom 
\proc{ORDER} (AL: LIST): LIST; \eproc
\bcom Order. a is an object. n=ORDER(a). \ecom 
\proc{OREAD} (): LIST; \eproc
\bcom Object read. The object B is read from the input stream. Any
preceding blanks are skipped. \ecom 
\proc{OWRITE} (B: LIST); \eproc
\bcom Object write. The input object B is written in the output stream. \ecom 
\proc{PAIR} (A,B: LIST): LIST; \eproc
\bcom Pair. A=(a(1), ...,a(m)) and B=(b(1), ...,b(n)) are lists with
m and n non-negative.  C is the list (a(1),b(1), ...,a(r),b(r))
where r=MIN(m,n). \ecom 
\proc{REDUCT} (A,IL: LIST): LIST; \eproc
\bcom Reductum. A is a list. i is a non-negative beta-integer not less
than LENGTH(A).  B=A, if i=0.  Otherwise, B is the i-th reductum of
A. \ecom 
\proc{RED2} (L: LIST): LIST; \eproc
\bcom Reductum 2. L is a list of length 2 or more. LP=RED(RED(L)). \ecom 
\proc{RED3} (L: LIST): LIST; \eproc
\bcom Reductum 3. L is a list of length 3 or more. M is the third
reductum of L. \ecom 
\proc{RED4} (L: LIST): LIST; \eproc
\bcom Reductum 4. L is a list of length 4 or more. M is the fourth
reductum of L. \ecom 
\proc{SECOND} (L: LIST): LIST; \eproc
\bcom Second. L is a list of length 2 or more. a is the second element
of L. \ecom 
\proc{SLELT} (A,IL,AL: LIST); \eproc
\bcom Set list element. A is a list. 1 le i le LENGTH(A). The i-th
element of A is changed to a. \ecom 
\proc{SUFFIX} (L,BL: LIST): LIST; \eproc
\bcom Suffix. L is a list (a(1), ..., a(n)), n non-negative. b is an
object. LP=(a(1), ..., a(n),b). L is modified. \ecom 
\proc{THIRD} (L: LIST): LIST; \eproc
\bcom Third. L is a list of length 3 or more. a is the third element
of L. \ecom 
