\section{ Aldes Parser  } 
\proc{Aparse} (): LIST \eproc
\bcom  Parse a set of ALDES-2 declarations and algorithms.  \ecom 
\section{ MAS Lisp  } 
\proc{ECENV} (ENV: LIST): LIST; \eproc
\bcom Encode environment. The encoded environment E is returned.  \ecom 
\proc{DCENV} (E: LIST): LIST; \eproc
\bcom Decode environment. The encoded environment E is decoded.  \ecom 
\proc{SETV} (V, A: LIST; VAR ENV: LIST); \eproc
\bcom Set variable. V is a symbol and A is an S-expression.
A is associated to V in the environment ENV.  \ecom 
\proc{EXTENDENV} (A, X: LIST; VAR ENV: LIST): BOOLEAN; \eproc
\bcom Extend environement. A is a list of symbols. X is a list
of values. The environment ENV is extented by the bindings
of the symbols in A to the values in X. If the binding
is possible, then TRUE is returned else FALSE.  \ecom 
\proc{COPYTOENV} (V, EP: LIST; VAR ENV: LIST); \eproc
\bcom Copy to environement. V is a list of symbols. EP is an
environment. The environment ENV is extented by the bindings
of the symbols in V to the values in EP.  \ecom 
\proc{SPECIALFORM} (S: LIST): BOOLEAN; \eproc
\bcom Test if expression S is a special form.  \ecom 
\proc{LAMBDAP} (S: LIST): BOOLEAN; \eproc
\bcom Test if expression S is a lambda form.  \ecom 
\proc{SEXPRP} (X: LIST): BOOLEAN; \eproc
\bcom Test if X is a S-expression function.  \ecom 
\proc{DEFE} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define expr function. X is a DE expression. A LAMBDA expression
generated from X is associated to name(X) in the environment ENV.  \ecom 
\proc{DEFF} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define fexpr function. X is a DF expression. A FLAMBDA expression
generated from X is associated to name(X) in the environment ENV. \ecom 
\proc{DEFM} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define macro function. X is a DM expression. A MLAMBDA expression
generated from X is associated to name(X) in the environment ENV. \ecom 
\proc{DEFMAP} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define generic map function. X is a MAP expression. A
GLAMBDA expression generated from X is associated to name(X) 
in the environment ENV.  \ecom 
\proc{DEFPROC} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define generic proc function. X is a DE expression.
A GLAMBDA expression generated from X is associated to 
name(X) in the environment ENV. \ecom 
\proc{DEFRULE} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define generic rule function. X is a RULE expression.
A GLAMBDA expression generated from X is associated to 
name(X) in the environment ENV. \ecom 
\proc{DSPEC} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define specification. X is a SPEC expression. An UNIT expression
generated from X is associated to name(X) in the environment ENV. \ecom 
\proc{DMIA} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Define model, implementation or axioms. X is a MODEL,
IMPLEMENTATION or AXIOMS expression. An UNIT expression 
associated to name(X) is modified by a generated expression 
of X.  \ecom 
\proc{TYPEOF} (X: LIST): LIST; \eproc
\bcom Type of S-expression. X is an S-expression. A list of types,
values and descriptors of X is returend.  \ecom 
\proc{TAG} (V,T: LIST): LIST; \eproc
\bcom Tag object. V is an S-expression, T is a type expression.
A tagged TYPEINFO S-expression is returned.  \ecom 
\proc{VALOFTAG} (L: LIST): LIST; \eproc
\bcom Value of tagged object. L is a tagged S-expression.
The value component of L is returned.  \ecom 
\proc{TYPOFTAG} (L: LIST): LIST; \eproc
\bcom Type of tagged object. L is a tagged S-expression.
The type component of L is returned. \ecom 
\proc{DECOFTAG} (L: LIST): LIST; \eproc
\bcom Descriptor of tagged object. L is a tagged S-expression.
The descriptor component of L is returned.  \ecom 
\proc{GENPL} (P,V,T,D: LIST): LIST; \eproc
\bcom Generate parameter list. P is a list of patterns.
V is a list of values. T is a list of types and D is a 
list of descriptors. A parameter list is returned.  \ecom 
\proc{GENTE} (Z,N,D: LIST): LIST; \eproc
\bcom Generate typed expression. Z is an S-expression,
N is a function name, D is a descriptor. A typed S-expression 
for evaluation is returned.  \ecom 
\section{ MAS Lisp Utility  } 
\proc{CallCompiled} (F, PI: LIST; VAR PO: LIST; VAR fu: BOOLEAN); \eproc
\bcom Call compiled function or procedure. F is a function or procedure
symbol. PI is the list of input parameters. fu is TRUE if F is a 
function and FALSE if F is a procedure. PO is a list of output 
parameters if F is a procedure and PO is the output parameter if 
F is a function.  \ecom 
\proc{Compiledp0} (F: PROCP0; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p0. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp1} (F: PROCP1; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p1. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp2} (F: PROCP2; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p2. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp3} (F: PROCP3; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p3. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledf0} (F: PROCF0; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration f0. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledf1} (F: PROCF1; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration f1. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledf2} (F: PROCF2; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration f2. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledf3} (F: PROCF3; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration f3. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledf4} (F: PROCF4; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration f4. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp1v2} (F: PROCP1V2; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p1v2. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp1v3} (F: PROCP1V3; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p1v3. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp2v2} (F: PROCP2V2; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p2v2. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp2v3} (F: PROCP2V3; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p2v3. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp3v2} (F: PROCP3V2; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p3v2. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{Compiledp3v3} (F: PROCP3V3; VAR S: ARRAY OF CHAR); \eproc
\bcom Compiled function declaration p3v3. F is a Modula-2 procedure, S is
the print name of F.  \ecom 
\proc{CompSummary} ; \eproc
\bcom Compiled function and procedure summary. Write out all
compiled functions with their signature from symbol table SYMTB.  \ecom 
\proc{Declare} (VAR X: LIST; VAR S: ARRAY OF CHAR); \eproc
\bcom Declare. X is declared as symbol with print name S.  \ecom 
\proc{PROCP} (X: LIST): BOOLEAN; \eproc
\bcom Procedure Pointer. Test if the symbol X is a compiled function.  \ecom 
\proc{Signature} (F: LIST; VAR PI, PO: LIST; VAR def: BOOLEAN); \eproc
\bcom Signature of a compiled function or procedure. F is a function or
procedure symbol. PI is the number of input parameters. def is TRUE if 
F is defined as compiled function or procedure else def is FALSE. 
PO is the number of output parameters if F is a procedure, 
PO = -1 if F is a function.  \ecom 
\section{ MAS Load  } 
\proc{InitExternals} ; \eproc
\bcom Initialize external compiled procedures.  \ecom 
\section{ MAS Load A. } 
\proc{InitExternalsA} ; \eproc
\bcom Initialize external compiled arithmetic procedures.  \ecom 
\section{ MAS Load B. } 
\proc{InitExternalsB} ; \eproc
\bcom Initialize external compiled polynomial procedures.  \ecom 
\section{ MAS Load C. } 
\proc{InitExternalsC} ; \eproc
\bcom Initialize external compiled non-commutative polynomial procedures.  \ecom 
\section{ MAS Load D. } 
\proc{InitExternalsD} ; \eproc
\bcom Initialize external compiled ideal decomposition and root procedures.  \ecom 
\section{ MAS Load L. } 
\proc{InitExternalsL} (); \eproc
\bcom Initialize external compiled linear algebra procedures.  \ecom 
\section{ MAS Parser  } 
\proc{Parse} (): LIST; \eproc
\bcom Parse program and generate code.  \ecom 
\proc{SwitchParse} (g: BOOLEAN); \eproc
\bcom Switch parsing between generic / non-generic parse.
If g = TRUE then the parser generates code for generic names, 
if g = FALSE then the parser generates code for the builtin LISP 
arithmetic functions.  \ecom 
\section{ MAS Representation  } 
\proc{NewRep} (): LIST; \eproc
\bcom New representation. A new representation is returned.  \ecom 
\proc{SetRep} (n,e,r: LIST); \eproc
\bcom Set representation. r is a representation. n is a unique
label, e is an expression.  \ecom 
\proc{GetRep} (n,r: LIST): LIST; \eproc
\bcom Get representation. r is a representation. n is a unique
label, An expression e stored under n is returned.  \ecom 
\proc{CopyRep} (r: LIST): LIST; \eproc
\bcom Copy representation. r is a representation. A copy of r is
returned. Step counters are reset.  \ecom 
\proc{StepRep} (r: LIST): LIST; \eproc
\bcom Step through representation. r is a representation.
The next expression e and its label n are returned as pair (n,e). 
If all pairs (n,e) of representation r have been processed, 
then NIL is returned.  \ecom 
\proc{ForEachinRep} (r, f, E: LIST): LIST; \eproc
\bcom For each pair (n,e) in r apply function f. r is a representation.
(n, e) is a pair in r, where e is an expression and n is its label.
f is applied to (n, e) such that p = f(n,e) with p = (n', e') or p = NIL. 
If p <> NIL, then the pair (n', e') is added to the returned 
representation r' = { n' e' : f(n,e) <> NIL, n e in r }. E is a 
LISP environment, if E = NIL, then the top level environment is used.  \ecom 
\proc{FullRep} (r: LIST): LIST; \eproc
\bcom Full representation. Test for non-empty representation.
r is a representation.  \ecom 
\proc{ForEachinList} (r, f, E: LIST): LIST; \eproc
\bcom For each element e in r apply function f. r is a list. e is an
element in r. f is applied to e such that e' = f(e). 
E is a LISP environment, if E = NIL, then the top level environment 
is used.  \ecom 
\section{ MAS Sepcification  } 
\proc{EVALUATE} (X: LIST; VAR ENV: LIST): LIST; \eproc
\bcom Lisp evaluator. X is an S-expression, ENV is an environment.  \ecom 
\section{ MAS Symbol  } 
\proc{ATOM} (X: LIST): BOOLEAN; \eproc
\bcom Atom. Test if X is an atom.  \ecom 
\proc{ELEMP} (X: LIST): BOOLEAN; \eproc
\bcom Elementary Pointer. Test if X is an elementary SAC-2 structure.  \ecom 
\proc{MEMQ} (AL,L: LIST): BOOLEAN; \eproc
\bcom Membership test equal pointers. a is an object, L a list. t=1 if
the pointer or atom a occurs in L and otherwise t=0. \ecom 
\proc{OCCURQ} (AL,L: LIST): BOOLEAN; \eproc
\bcom Occurs test equal pointers. a and L are objects. t=TRUE if
the pointer or atom a occurs in L and otherwise t=FALSE.  \ecom 
\proc{UREAD} (): LIST; \eproc
\bcom Universal read. The next atom, symbol, string or list over atoms,
strings and symbols is read and stored under L. Blanks may occur 
anywhere. Elements of a list may or may not be separated by a comma. \ecom 
\proc{UWRITE} (L: LIST); \eproc
\bcom Universal write. L is an atom, symbol or a list over
atoms and symbols. L is written in the output stream,
followed by blines.  \ecom 
\proc{UWRIT1} (L: LIST); \eproc
\bcom Universal write, 1. subalgorithm. L is an atom, a symbol
or a list over atoms or symbols. L is written in the output
stream.  \ecom 
\proc{UNIFY} (A,B: LIST; VAR S: LIST): BOOLEAN; \eproc
\bcom Unification. A and B are objects. If there exists a
most general unificator of A and B, then S is the list of 
substitutions. In this case TRUE is returned. If no unificator
exists, then FALSE is returned and S is undefined.  \ecom 
\proc{GENARRAY} (A: LIST): LIST; \eproc
\bcom Generate array reference symbol. S is a generated symbol.  \ecom 
\proc{GENINDEX} (A: LIST): LIST; \eproc
\bcom Generate index set. I is an index set.  \ecom 
\proc{ARRAYDEC} (A: LIST): LIST; \eproc
\bcom Generate array name declarations. A is an array reference.  \ecom 
\section{ MAS/SAC Symbol System 2. } 
\proc{ACOMP} (A,B: LIST): LIST; \eproc
\bcom Alphabetic comparison. A and B are symbols. t=+1,0,-1 according
to whether A preceds, is equal, or follows B alphabetically. \ecom 
\proc{ACOMP1} (A,B: LIST): LIST; \eproc
\bcom Alphabetic comparison, 1. subalgorithm. A and B are packed strings.
s=-1,0,1 according to whether a preceds, is equal, or succeeds B
alphabetically. \ecom 
\proc{ASSOC} (AL,L: LIST): LIST; \eproc
\bcom Associate. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a=a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=(). \ecom 
\proc{ASSOCQ} (AL,L: LIST): LIST; \eproc
\bcom Associate equal. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a is equal to a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=(). \ecom 
\proc{ATTRIB} (L: LIST): LIST; \eproc
\bcom Attribute. L is a symbol. Returns the attributes of L. \ecom 
\proc{EXPLOD} (S: LIST): LIST; \eproc
\bcom Explode symbol. S is a symbol, L its character list. \ecom 
\proc{ENTER} (L: LIST): LIST; \eproc
\bcom Enter into symbol table. L is a character list, S the pointer
to the corresponding symbol. If the symbol is not yet in the
symbol table SYMTB, then a new node is created. \ecom 
\proc{GENSYM} (): LIST; \eproc
\bcom Generate symbol. S is a newly generated symbol. NAM is advanced. \ecom 
\proc{GET} (S,AL: LIST): LIST; \eproc
\bcom Get property. The property list of the symbol S is searched
under indicator a. A is the property under a, if any, otherwise
A is set to beta. \ecom 
\proc{NAME} (L: LIST): LIST; \eproc
\bcom Name. L is a symbol. Returns the name of L. \ecom 
\proc{PACK} (L: LIST): LIST; \eproc
\bcom Pack character list. L is a non-empty character list. B is the
packed list. \ecom 
\proc{PUT} (S,AL,A: LIST); \eproc
\bcom Put. The property A is stored on the property list of
the symbol S under the indicator a. \ecom 
\proc{REMPRP} (S,AL: LIST); \eproc
\bcom Remove property. Under indicator a on the property list of
symbol S the property is removed. \ecom 
\proc{SMEMB} (S,L: LIST): LIST; \eproc
\bcom Symbol membership. S is a symbol, L a list containing possibly
also symbols. b=1 if S or a copy of S occurs in L, b=0 otherwise. \ecom 
\proc{SREAD} (): LIST; \eproc
\bcom Symbol read. The next symbol is read from input. S is the symbol in
the symbol table SYMTB. \ecom 
\proc{SREAD1} (): LIST; \eproc
\bcom Symbol read, 1. The first non-alphanumeric character of the
input stream terminates the symbol.  L is the character list of 
the symbol, which is not entered in the symbol table. \ecom 
\proc{STCNT} (T: LIST; VAR S,P: LIST); \eproc
\bcom Symbol table tree count. T is a symbol tree, S is the number
of symbols in T, P the number of properties of all symbols of the tree.
Since every symbol has a name property, P ge S. \ecom 
\proc{STINS} (B: LIST): LIST; \eproc
\bcom Symbol tree insertion. B is a packed list of characters. S is a
pointer to the corresponding symbol in the symbol table. If
it is not yet in, a new node is created. \ecom 
\proc{STLST} (T: LIST): LIST; \eproc
\bcom Symbol tree list. T is a symbol tree, L is the list of its symbols
in alphabetic order. \ecom 
\proc{STLSTI} (T: LIST): LIST; \eproc
\bcom Symbol tree list, in-order. T is a binary tree of symbols, L is a
list of its symbols, with the root symbol appearing first. \ecom 
\proc{STSRCH} (T,AP: LIST): LIST; \eproc
\bcom Symbol tree search. T is a binary tree of symbols, AP is a packed
list of characters. If the symbol with the name AP occurs already
in the symbol table T then S=() and otherwise S points to the entry. \ecom 
\proc{STWRT} (T: LIST); \eproc
\bcom Symbol tree write. T is a binary tree of symbols. The symbols
followed by their properties are printed in alphabetic order. \ecom 
\proc{SYMBOL} (AP: LIST): BOOLEAN; \eproc
\bcom Symbol. AP is an object. Returns true if it is a symbol and
false else. \ecom 
\proc{SymSummary} (); \eproc
\bcom Summary of symbol system. The number of symbols in SYMTB and
the number of their properties is written. \ecom 
\proc{SYWRIT} (S: LIST); \eproc
\bcom Symbol write. The symbol S is written in the output stream. \ecom 
\proc{SUBLIS} (L,A: LIST): LIST; \eproc
\bcom Substitution with list. L=(x1 e1, ...,x sub n e sub n),
a and e sub i are objects. The x sub i are beta-digits
or pointers to uniquely stored lists like symbols. B is A
with the x sub i substituted by the e sub i. \ecom 
\proc{UREAD} (): LIST; \eproc
\bcom Universal read. The next atom, symbol or list over atoms
and symbols is read and stored under L. Blanks may occur anywhere,
elements of a list may or may not be separated by a comma. \ecom 
\proc{UWRITE} (L: LIST); \eproc
\bcom Universal write. L is an atom, symbol or a list over
atoms and symbols. L is written in the output stream,
followed by BLINES(0).  \ecom 
\proc{UWRIT1} (L: LIST); \eproc
\bcom Universal write, 1. subalgorithm. L is an atom, a symbol
or a list over atoms or symbols. L is written in the output
stream followed by a blank character, but not by BLINES.  \ecom 
\section{ MAS Utility  } 
\proc{InitExternalsU} (); \eproc
\bcom Initialize external compiled utility procedures.  \ecom 
\proc{DoParse} (): LIST; \eproc
\bcom Do parse. Call specific Parser.  \ecom 
\proc{DoWrite} (Y: LIST); \eproc
\bcom Do Write. Write according to Parser.  \ecom 
\proc{MWRITE} (Y: LIST); \eproc
\bcom Output in modula like syntax.  \ecom 
\proc{MWRIT1} (Y: LIST; top: BOOLEAN); \eproc
\bcom Output in modula like syntax.  \ecom 
\section{ MAS Symbol to DIP  } 
\proc{DIPVDEF} (V: LIST): LIST; \eproc
\bcom DIP define distributive polynomial variable list.
V is a variable list. The old variable list is returned.  \ecom 
\proc{DIPTODEF} (T: LIST): LIST; \eproc
\bcom DIP define distributive polynomial term order.
V is a term order indicator. The old term order indicator 
is returned.  \ecom 
\proc{SYM2DIP} (T: LIST): LIST; \eproc
\bcom Symbol term to distributive polynomial.  \ecom 
\proc{DIP2SYM} (D: LIST): LIST; \eproc
\bcom Distributive polynomial to symbol term.  \ecom 
\proc{TVARS} (T: LIST): LIST; \eproc
\bcom Term variables. T is a term. The list of variables
occuring in T is returned.  \ecom 
\proc{DIRPFT} (T, V: LIST): LIST; \eproc
\bcom Distributive rational polynomial from term. T is a term,
V is a variable list. A distributive rational polynomial 
A in r variables, where r=length(V), r ge 0, is formed 
from term T.  \ecom 
\proc{TFDIRP} (A, V: LIST): LIST; \eproc
\bcom Term from distributive rational polynomial. A is a distributive
rational polynomial in r variables, where r=length(V), r ge 0,
V is a symbol list. A term T is formed from A.  \ecom 
\proc{InitExternalsI} ; \eproc
\bcom Initialize external compiled interface procedures.  \ecom 
\section{ SAC Symbol System  } 
\proc{ACOMP} (A,B: LIST): LIST; \eproc
\bcom Alphabetic comparison. A and B are symbols. t=+1,0,-1 according
to whether A preceds, is equal, or follows B alphabetically. \ecom 
\proc{ACOMP1} (A,B: LIST): LIST; \eproc
\bcom Alphabetic comparison, 1. subalgorithm. A and B are packed strings.
s=-1,0,1 according to whether a preceds, is equal, or succeeds B
alphabetically. \ecom 
\proc{ASSOC} (AL,L: LIST): LIST; \eproc
\bcom Associate. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a=a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=(). \ecom 
\proc{ASSOCQ} (AL,L: LIST): LIST; \eproc
\bcom Associate equal. L=(a1 b1, a2 b2, ...,a sub n b sub n), n ge 0,
a is an object. If there is an i such that a is equal to a sub i then
P=(b sub i, ...,a sub n b sub n), otherwise P=(). \ecom 
\proc{ATTRIB} (L: LIST): LIST; \eproc
\bcom Attribute. L is a symbol. Returns the attributes of L. \ecom 
\proc{EXPLOD} (S: LIST): LIST; \eproc
\bcom Explode symbol. S is a symbol, L its character list. \ecom 
\proc{ENTER} (L: LIST): LIST; \eproc
\bcom Enter into symbol table. L is a character list, S the pointer
to the corresponding symbol. If the symbol is not yet in the
symbol table SYMTB, then a new node is created. \ecom 
\proc{GENSYM} (): LIST; \eproc
\bcom Generate symbol. S is a newly generated symbol. NAM is advanced. \ecom 
\proc{GET} (S,AL: LIST): LIST; \eproc
\bcom Get property. The property list of the symbol S is searched
under indicator a. A is the property under a, if any, otherwise
A is set to beta. \ecom 
\proc{NAME} (L: LIST): LIST; \eproc
\bcom Name. L is a symbol. Returns the name of L. \ecom 
\proc{PACK} (L: LIST): LIST; \eproc
\bcom Pack character list. L is a non-empty character list. B is the
packed list. \ecom 
\proc{PUT} (S,AL,A: LIST); \eproc
\bcom Put. The property A is stored on the property list of
the symbol S under the indicator a. \ecom 
\proc{REMPRP} (S,AL: LIST); \eproc
\bcom Remove property. Under indicator a on the property list of
symbol S the property is removed. \ecom 
\proc{SMEMB} (S,L: LIST): LIST; \eproc
\bcom Symbol membership. S is a symbol, L a list containing possibly
also symbols. b=1 if S or a copy of S occurs in L, b=0 otherwise. \ecom 
\proc{SREAD} (): LIST; \eproc
\bcom Symbol read. The next symbol is read from input. S is the symbol in
the symbol table SYMTB. \ecom 
\proc{SREAD1} (): LIST; \eproc
\bcom Symbol read, 1. The first non-alphanumeric character of the
input stream terminates the symbol.  L is the character list of 
the symbol, which is not entered in the symbol table. \ecom 
\proc{STCNT} (T: LIST; VAR S,P: LIST); \eproc
\bcom Symbol table tree count. T is a symbol tree, S is the number
of symbols in T, P the number of properties of all symbols of the tree.
Since every symbol has a name property, P ge S. \ecom 
\proc{STINS} (B: LIST): LIST; \eproc
\bcom Symbol tree insertion. B is a packed list of characters. S is a
pointer to the corresponding symbol in the symbol table. If
it is not yet in, a new node is created. \ecom 
\proc{STLST} (T: LIST): LIST; \eproc
\bcom Symbol tree list. T is a symbol tree, L is the list of its symbols
in alphabetic order. \ecom 
\proc{STLSTI} (T: LIST): LIST; \eproc
\bcom Symbol tree list, in-order. T is a binary tree of symbols, L is a
list of its symbols, with the root symbol appearing first. \ecom 
\proc{STSRCH} (T,AP: LIST): LIST; \eproc
\bcom Symbol tree search. T is a binary tree of symbols, AP is a packed
list of characters. If the symbol with the name AP occurs already
in the symbol table T then S=() and otherwise S points to the entry. \ecom 
\proc{STWRT} (T: LIST); \eproc
\bcom Symbol tree write. T is a binary tree of symbols. The symbols
followed by their properties are printed in alphabetic order. \ecom 
\proc{SYMBOL} (AP: LIST): BOOLEAN; \eproc
\bcom Symbol. AP is an object. Returns true if it is a symbol and
false else. \ecom 
\proc{SymSummary} (); \eproc
\bcom Summary of symbol system. The number of symbols in SYMTB and
the number of their properties is written. \ecom 
\proc{SYWRIT} (S: LIST); \eproc
\bcom Symbol write. The symbol S is written in the output stream. \ecom 
\proc{SUBLIS} (L,A: LIST): LIST; \eproc
\bcom Substitution with list. L=(x1 e1, ...,x sub n e sub n),
a and e sub i are objects. The x sub i are beta-digits
or pointers to uniquely stored lists like symbols. B is A
with the x sub i substituted by the e sub i. \ecom 
\proc{UREAD} (): LIST; \eproc
\bcom Universal read. The next atom, symbol or list over atoms
and symbols is read and stored under L. Blanks may occur anywhere,
elements of a list may or may not be separated by a comma. \ecom 
\proc{UWRITE} (L: LIST); \eproc
\bcom Universal write. L is an atom, symbol or a list over
atoms and symbols. L is written in the output stream,
followed by BLINES(0).  \ecom 
\proc{UWRIT1} (L: LIST); \eproc
\bcom Universal write, 1. subalgorithm. L is an atom, a symbol
or a list over atoms or symbols. L is written in the output
stream followed by a blank character, but not by BLINES.  \ecom 
\section{ SAC Symbol 2  } 
\proc{STBAL} (L,n: LIST): LIST; \eproc
\bcom Symbol tree balance. L is an alphabetical list of n symbol-tree
nodes (n gt 0), out of which a balanced binary tree S is constructed.  \ecom 
\proc{STBALS} (VAR A: ARRAY OF LIST; l, r: INTEGER): INTEGER; \eproc
\bcom Symbol tree balance subroutine. The array A contains symbol-tree
nodes in alphabetical order. The binary tree of the symbols in
A[l..r] is constructed and A[m] is its root.  \ecom 
\proc{STNLST} (T: LIST; VAR L,n: LIST); \eproc
\bcom Symbol tree nodes list. T is a non-empty symbol tree.
L is the list of its nodes in alphabetical order of the 
corresponding symbols and n the number of nodes. This algorithm
is normally used for creating the data as required for STBAL.  \ecom 
\proc{SSYTBAL} ; \eproc
\bcom System symbol tree balance. SYMTB is balanced.  \ecom 
