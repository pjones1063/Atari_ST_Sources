\section{ MAS Linear Algebra Integer  } 
\proc{IUM} (m, n : LIST): LIST; \eproc
\bcom Integer unit matrix. m, n integer. An (m x n) integer unit
matrix is returned.  \ecom 
\proc{IVWRITE} (A : LIST); \eproc
\bcom Integer vector write. A is an integer vector. A is written
to the output stream.  \ecom 
\proc{IMWRITE} (A : LIST); \eproc
\bcom Integer matrix write. A is an integer matrix. A is written
to the output stream.  \ecom 
\proc{IVVDIF} (A, B : LIST): LIST; \eproc
\bcom Integer vector difference. A and B are integer vectors.
The integer vector C = A - B is returned.  \ecom 
\proc{IKM} (A, B : LIST): LIST; \eproc
\bcom Integer vector component product. IKM returns the difference of
the product of the integer vector A with FIRST(B) and the product of 
the integer vector B with FIRST(A). C = A * FIRST(B) - B * FIRST(A).
C is an integer vector.  \ecom 
\proc{IVVSUM} (A, B : LIST): LIST; \eproc
\bcom Integer vector vector sum. A and B are integer vectors.
An integer vector C = A + B is returned.  \ecom 
\proc{IVSVSUM} (A, B : LIST): LIST; \eproc
\bcom Integer vector scalar and vector sum. A and B are integer vectors.
An integer vector C = A + FIRST(B) is returned.  \ecom 
\proc{IVSSUM} (A : LIST): LIST; \eproc
\bcom Integer vector scalar sum. A is an integer vector. An integer
C = a1 + a2 + ... + an is returned.  \ecom 
\proc{IVSVPROD} (A, B : LIST): LIST; \eproc
\bcom Integer vector scalar and vector product. A and B are integer vectors.
An integer vector C = (a1*FIRST(B), ..., an*FIRST(B) ) is returned.  \ecom 
\proc{IVVPROD} (A, B : LIST): LIST; \eproc
\bcom Integer vector vectors product. A and B are integer vectors.
An integer vector C = (a1*b1, ..., an*bn) is returned.  \ecom 
\proc{IVSPROD} (A, B : LIST): LIST; \eproc
\bcom Integer vector scalar product. A and B are integer vectors.
An integer C = a1*b1 + ... + an*bn is returned.  \ecom 
\proc{IVMAX} (M : LIST): LIST; \eproc
\bcom Integer vector maximum norm. M is an integer vector.
An integer a = maximum absolute value M(i) is returned.  \ecom 
\proc{IVLC} (a, A, b, B : LIST): LIST; \eproc
\bcom Integer vector linear combination. A and B are integer vectors.
a and b are integers. An integer vector C = a*A + b*B is returned.  \ecom 
\proc{IVSQ} (a, A: LIST): LIST; \eproc
\bcom Integer vector scalar quotient. A is an integer vector.
a is an integer. An integer vector C = A/a is returned. 
a must divide each element of A exactly.  \ecom 
\proc{IVFRNV} (A: LIST): LIST; \eproc
\bcom Integer vector from rational number vector. A is a rational
number vector. A is muliplied by a common multiple of its 
denominators, then the denominators are removed. An integer 
vector C = lcm(denom(A)) * A is returned.  \ecom 
\proc{IVFRNV1} (A, B : LIST; VAR C, D: LIST); \eproc
\bcom Integer vector from rational number vector. A and B are
rational number vectors. A and B are muliplied by a common 
multiple of their denominators, then the denominators are 
removed. C and D are integer vectors, such that 
C = lcm(denom(A),denom(B))*A and D = lcm(denom(A),denom(B))*B.  \ecom 
\proc{IMPROD} (A, B : LIST): LIST; \eproc
\bcom Integer matrix product. A and B are integer matrices.
An integer matrix C = A * B is returned, if the number of 
coloums of A is equal to the number of rows of B, 
otherwise the empty matrix is returned.  \ecom 
\proc{IMSUM} (A, B : LIST): LIST; \eproc
\bcom Integer matrix sum. A and B are integer matrices.
An integer matrix C = A + B is returned.  \ecom 
\proc{IMDIF} (A, B : LIST): LIST; \eproc
\bcom Integer matrix difference. A and B are integer matrices.
An integer matrix C = A - B is returned.  \ecom 
\proc{ISMPROD} (A, B : LIST): LIST; \eproc
\bcom Integer scalar and matrix product. B is an integer matrix.
A is an integer. An integer matrix C = A * B is returned.  \ecom 
\proc{IMMAX} (M : LIST): LIST; \eproc
\bcom Integer matrix maximum norm. M is an integer matrix.
An integer a = maximum absolute value M(i,j) is returned.  \ecom 
\proc{IMFRNM} (A : LIST): LIST; \eproc
\bcom Integer matrix from rational number matrix. A is a rational
number row matix. The rows of A are muliplied by a common 
multiple of its denominators, then the denominators are 
removed. An integer matix C is returned, such that for 
all rows C(i) = lcm(denom(A(i))) * A(i).  \ecom 
\proc{IMFRNM1} (A, B : LIST; VAR C, D: LIST); \eproc
\bcom Integer matrix from rational number matrix. A is a rational
number row matix. B is a rational number column matix. 
The rows of A and the rows of B are muliplied by
a common multiple of their denominators, then the 
denominators are removed. C and D are integer matices,
such that C(i) = lcm(denom(A(i)),B(i)) * A(i) and
D(i) = lcm(denom(A(i)),B(i)) * B(i).  \ecom 
\proc{IMGELUD} (M : LIST; VAR L, U: LIST); \eproc
\bcom Integer matrix Gaussian elimination LU-decomposition.
M is an integer matrix represented rowwise. L is a lower 
triangular integer matrix represented columnwise.
U is an upper triangular integer matrix represented rowwise.
M = L * U for appropriate modifications of L and U. The pivot 
operations and exact division factors are also recorded in L.  \ecom 
\proc{IMLT} (L, b : LIST): LIST; \eproc
\bcom Integer lower triangular matrix transformation.
L is a lower triangular integer matrix represented 
columnwise as generated by IMGELUD. b is an integer vector. 
An integer vector u = L * b is returned, such that 
if M * x = b and M = L * U, then U * x = u.  \ecom 
\proc{IMUT} (U, b : LIST): LIST; \eproc
\bcom Integer upper triangular matrix transformation.
U is an upper triangular integer matrix represented rowwise
as generated by IMGELUD. b is an integer vector 
b = L * b' as generated by IMLT. A rational number (!) vector x, 
such that U * x = b is returned. If no such x exists, then an 
empty vector is returned. If more than one such x exists, then 
for free x(i), x(i) = 0 is taken.  \ecom 
\proc{IMGE} (M : LIST): LIST; \eproc
\bcom Integer matrix Gaussian elimination. M is a (n x m) integer
matrix. A (n x m) integer matrix resulting from Gaussian 
elimination is returned. IMGELUD is called.  \ecom 
\proc{IMSDS} (L, U, b : LIST): LIST; \eproc
\bcom Integer matrix solve decomposed system. L is a lower
triangular integer matrix represented columnwise, U is an upper 
triangular integer matrix represented rowwise. L and U as 
generated by IMGELUD. If M = L * U, then a rational number (!) 
vector x, such that M * x = b is returned. If no such x exists, 
then an empty vector is returned. If more than one such x exists, 
then for free x(i), x(i) = 0 is taken.  \ecom 
\proc{RNMINVI} (A : LIST): LIST; \eproc
\bcom Rational number matrix inversion, integer algorithm. A is a
rational number matrix represented rowwise. If it exists, 
the inverse matrix of A is returned, otherwise an empty matrix 
is returned. The integer Gaussian elimination IMGELUD is used.  \ecom 
\proc{IMUNS} (U : LIST): LIST; \eproc
\bcom Integer matrix upper triangular matrix solution null space.
U is an upper triangular integer matrix represented rowwise
as generated by IMGELUD. A matrix X of linear independent rational 
number vectors x is returned, such that for each x in X, U * x = 0 holds. 
If only x = 0 satisfies the condition U * x = 0, then the 
matrix X is empty.  \ecom 
\proc{IMDETL} (M : LIST): LIST; \eproc
\bcom Integer matrix determinant, using Laplace expansion.
M is an integer matrix. The determinant of M is returned.  \ecom 
\proc{IMDET} (M : LIST): LIST; \eproc
\bcom Integer matrix determinant, using Gaussian elimination.
M is an integer matrix. The determinant of M is returned.  \ecom 
\section{ MAS Linear Algebra Rational Number  } 
\proc{MDIM} (M : LIST): LIST; \eproc
\bcom Matrix dimension. M is a matrix. MDIM returns
max( row, column) of M.  \ecom 
\proc{MGET} (M, k, l : LIST): LIST; \eproc
\bcom Matrix get. M is a matrix. k, l are integers, 0 le k le rows(M),
0 le l le columns(M). MGET returns the element M(k,l) of matrix M.  \ecom 
\proc{MSET} (M, k, l, x : LIST): LIST; \eproc
\bcom Matrix set. M is a matrix. k, l are integers, 0 le k le rows(M),
0 le l le  columns(M). MSET sets the element M(k,l) to x. 
The new matrix is returned.  \ecom 
\proc{VDELEL} (V, i : LIST): LIST; \eproc
\bcom Vector delete element. V is a vector. The i-th element of V
is deleted. 0 le i le length(V).  \ecom 
\proc{MDELCOL} (M, i : LIST): LIST; \eproc
\bcom Matrix delete column. M is a vector of row vectors. In each
row the i-th element is deleted, 0 le i le  columns(M). The new 
matrix is returned.  \ecom 
\proc{MMINOR} (M, i, j : LIST): LIST; \eproc
\bcom Matrix minor. M is a vector of row vectors. The i-th column,
0 le i le  rows(M), and in each remaining row the j-th element,
0 le j le columns(M), is deleted.  \ecom 
\proc{MTRANS} (M : LIST): LIST; \eproc
\bcom Matrix transpose. M is a matrix. The transposed matrix is returned.  \ecom 
\proc{VEL} (a, n : LIST): LIST; \eproc
\bcom Vector elements. A vector of length n with elements a is returned.  \ecom 
\proc{MFILL} (M, m, n: LIST): LIST; \eproc
\bcom Matrix fill. M is an upper triangular matrix. A (m x n) matrix
with zeros in the lower triangular part is returned.  \ecom 
\proc{MRANG} (U: LIST): LIST; \eproc
\bcom Matrix rang. U is an upper triangular matrix from a
LU-decomposition. The rang of U is returned.  \ecom 
\proc{RNMHILBERT} (m, n : LIST): LIST; \eproc
\bcom Rational number matrix Hilbert. m, n integer. A (m x n) rational
number Hilbert matrix is returned.  \ecom 
\proc{RNUM} (m, n : LIST): LIST; \eproc
\bcom Rational number unit matrix. m, n integer. A (m x n) rational
number unit matrix is returned.  \ecom 
\proc{RNVWRITE} (A : LIST); \eproc
\bcom Rational number vector write. A is a rational number vector.
A is written to the output stream.  \ecom 
\proc{RNVREAD} (): LIST; \eproc
\bcom Rational number vector read. A rational number vector is
read from the input stream, and returned.  \ecom 
\proc{RNMWRITE} (A : LIST); \eproc
\bcom Rational number matrix write. A is a rational number matrix.
A is written to the output stream.  \ecom 
\proc{RNMREAD} (): LIST; \eproc
\bcom Rational number matrix read. A rational number matrix is
read from the input stream, and returned.  \ecom 
\proc{RNVFIV} (A : LIST): LIST; \eproc
\bcom Rational number vector from integer vector. A is an integer
vector. A rational number vector with denominators 1 
and nominators equal to the elements of A is returned.  \ecom 
\proc{RNMFIM} (M : LIST): LIST; \eproc
\bcom Rational number matrix from integer matrix. A is an integer
matrix. A rational number matrix with denominators 1 
and nominators equal to the elements of A is returned.  \ecom 
\proc{RNVDIF} (A, B : LIST): LIST; \eproc
\bcom Rational number vector difference. A and B are rational number
vectors. The rational number vector C = A - B is returned.  \ecom 
\proc{RNVQ} (A, B : LIST): LIST; \eproc
\bcom Rational number vector quotient. A and B are rational number vectors.
The rational number vector C = A / FIRST(B) is returned.  \ecom 
\proc{RNVQF} (A : LIST): LIST; \eproc
\bcom Rational number vector quotient. A is a rational number vector.
The rational number vector C = A / FIRST(A) is returned.  \ecom 
\proc{RNVVSUM} (A, B : LIST): LIST; \eproc
\bcom Rational number vector vector sum. A and B are rational number vectors.
A rational number vector C = A + B is returned.  \ecom 
\proc{RNVSVSUM} (A, B : LIST): LIST; \eproc
\bcom Rational number vector scalar sum. A and B are rational number vectors.
A rational number vector C = A + FIRST(B) is returned.  \ecom 
\proc{RNVSSUM} (A : LIST): LIST; \eproc
\bcom Rational number vector scalar sum. A is a rational number vector.
A rational number C = a1 + a2 + ... + an is returned.  \ecom 
\proc{RNVSVPROD} (A, B : LIST): LIST; \eproc
\bcom Rational number vector scalar vector product. A and B are
rational number vectors. A rational number vector 
C = (a1*FIRST(B), ..., an*FIRST(B)) is returned.  \ecom 
\proc{RNVVPROD} (A, B : LIST): LIST; \eproc
\bcom Rational number vector vector product. A and B are
rational number vectors. A rational number vector 
C = (a1*b1, ..., an*bn) is returned.  \ecom 
\proc{RNVSPROD} (A, B : LIST): LIST; \eproc
\bcom Rational number vector scalar product. A and B are rational
number vectors. A rational number C = a1*b1 + ... + an*bn is
returned.  \ecom 
\proc{RNVMAX} (M : LIST): LIST; \eproc
\bcom Rational number vector maximum norm. M is a rational number
vector. A rational number a = maximum absolute value M(i) 
is returned.  \ecom 
\proc{RNVLC} (a, A, b, B : LIST): LIST; \eproc
\bcom Rational number vector linear combination. A and B are rational
number vectors. a and b are rational numbers. A rational number vector 
C = a*A + b*B is returned.  \ecom 
\proc{RNSVPROD} (a, A : LIST): LIST; \eproc
\bcom Rational number vector product with scalar. A is a rational
number vector. a is a rational number. A rational number vector
C = a*A is returned.  \ecom 
\proc{RNMSUM} (A, B : LIST): LIST; \eproc
\bcom Rational number matrix sum. A and B are rational number
matrices. A rational number matrix C = A + B is returned.  \ecom 
\proc{RNMDIF} (A, B : LIST): LIST; \eproc
\bcom Rational number matrix difference. A and B are rational number
matrices. A rational number matrix C = A - B is returned.  \ecom 
\proc{RNMPROD} (A, B : LIST): LIST; \eproc
\bcom Rational number matrix product. A and B are rational number
matrices. A rational number matrix C = A * B is returned, if 
the number of coloums of A is equal to the number of rows of B, 
otherwise the empty matrix is returned.  \ecom 
\proc{RNSMPROD} (A, B : LIST): LIST; \eproc
\bcom Rational number scalar and matrix product. B is a rational
number matrix. A is a rational number. A rational number matrix 
C = A * B is returned.  \ecom 
\proc{RNMMAX} (M : LIST): LIST; \eproc
\bcom Rational number matrix maximum norm. M is a rational number
matrix. A rational number a = maximum absolute value M(i,j) 
is returned.  \ecom 
\proc{RNMGE} (M : LIST): LIST; \eproc
\bcom Rational number matrix Gaussian elimination. M is a (n x m)
rational number matrix. A (n x m) rational number matrix
resulting from Gaussian elimination is returned.  
RNMGELUD is called.  \ecom 
\proc{RNMDET} (M : LIST): LIST; \eproc
\bcom Rational number matrix determinant, using Gaussian elimination.
M is a rational number matrix. The determinant of M is returned.  \ecom 
\proc{RNMDETL} (M : LIST): LIST; \eproc
\bcom Rational number matrix determinant, using Laplace expansion.
M is a rational number matrix. The determinant of M is returned.  \ecom 
\proc{RNMGELUD} (M : LIST; VAR L, U: LIST); \eproc
\bcom Rational number matrix Gaussian elimination LU-decomposition.
M is a rational number matrix represented rowwise. L is a lower 
triangular rational number matrix represented columnwise.
U is an upper triangular rational number matrix represented rowwise.
M = L * U for appropriate modifications of L and U. 
The pivot operations are also recorded in L.  \ecom 
\proc{RNMLT} (L, b : LIST): LIST; \eproc
\bcom Rational matrix lower triangular matrix transformation.
L is a lower triangular rational number matrix represented 
columnwise as generated by RNMGELUD. b is a rational number 
vector. A rational number vector u = L * b is returned, 
such that if M * x = b and M = L * U, then U * x = u.  \ecom 
\proc{RNMUT} (U, b : LIST): LIST; \eproc
\bcom Rational matrix upper triangular matrix transformation.
U is an upper triangular rational number matrix represented rowwise
as generated by RNMGELUD. b is a rational number vector 
b = L * b' as generated by RNMLT. A rational number vector x, 
such that U * x = b is returned. If no such x exists, then an 
empty vector is returned. If more than one such x exists, then 
for free x(i), x(i) = 0 is taken.  \ecom 
\proc{RNMSDS} (L, U, b : LIST): LIST; \eproc
\bcom Rational number matrix solve decomposed system.
L is a lower triangular rational number matrix represented 
columnwise, U is an upper triangular rational number matrix 
represented rowwise. L and U as generated by RNMGELUD.
If M = L * U, then a rational number vector x, such that 
M * x = b is returned. If no such x exists, then an empty 
vector is returned. If more than one such x exists, then 
for free x(i), x(i) = 0 is taken.  \ecom 
\proc{RNMINV} (A : LIST): LIST; \eproc
\bcom Rational number matrix inversion. A is a rational number matrix
represented rowwise. If it exists, the inverse matrix of A is 
returned, otherwise an empty matrix is returned.  \ecom 
\proc{RNMUNS} (U : LIST): LIST; \eproc
\bcom Rational number matrix upper triangular matrix solution null space.
U is an upper triangular rational number matrix represented rowwise
as generated by RNMGELUD. A matrix X of linear independent rational 
number vectors x is returned, such that for each x in X, U * x = 0 holds. 
If only x = 0 satisfies the condition U * x = 0, then the 
matrix X is empty.  \ecom 
\section{ SAC Linear Diophantine Equation System  } 
\proc{LDSMKB} (A,BL: LIST; VAR XLS,N: LIST); \eproc
\bcom Linear diophantine system solution, modified Kannan and Bachem algorithm.
A is an m by n integral matrix.  A is represented
column-wise.  b is an integral m-vector.  If the diophantine
system A*x=b is consistent, then xs is a particular
solution and N is a list of basis vectors of the solution
module of A*x=0.  Otherwise, xs and N are null lists.  A and b are
modified. \ecom 
\proc{LDSSBR} (A,BL: LIST; VAR XLS,N: LIST); \eproc
\bcom Linear diophantine system solution, based on Rosser ideas. A is an
m by n integral matrix.  A is represented column-wise.  b is
an integral m-vector.  If the diophantine system A*x=b
is consistent, then xs is a particular solution and N is
a list of basis vectors of the solution module of A*x=0.  Otherwise,
xs and N are null lists. A and b are modified. \ecom 
\proc{MAIPDE} (RL,M: LIST): LIST; \eproc
\bcom Matrix of integral polynomials determinant, exact division algorithm.
M is a square matrix of integral polynomials in r variables, r ge 0,
represented as a list. D is the determinant of M. \ecom 
\proc{MAIPDM} (RL,M: LIST): LIST; \eproc
\bcom Matrix of integral polynomials determinant, modular algorithm. M is
a square matrix of integral polynomials in r variables, r non-negative.
D is the determinant of M. \ecom 
\proc{MAIPHM} (RL,ML,A: LIST): LIST; \eproc
\bcom Matrix of integral polynomials homomorphism. A is a matrix of
integral polynomials in r variables, r non-negative.  m is a
positive beta-integer.  B is the matrix B(i,j) of polynomials in r
variables over Z sub m such that B(i,j)=H(m)(A(i,j)). \ecom 
\proc{MAIPP} (RL,A,B: LIST): LIST; \eproc
\bcom Matrix of integral polynomials product. A and B are matrices of
integral polynomials in r variables, r ge 0, for which the matrix
product A*B is defined. C=A*B. \ecom 
\proc{MIAIM} (A: LIST): LIST; \eproc
\bcom Matrix of integers, adjoin identity matrix, A is an m by n matrix
of integers.  A is represented column-wise.  B is the matrix obtained
by adjoining an n by n identity matrix to the bottom of A.  A is
modified. \ecom 
\proc{MICINS} (A,V: LIST): LIST; \eproc
\bcom Matrix of integers column insertion. A is an m by n integral
matrix represented by the list (a(1),a(2), ...,a(n)), where a(i) is the
list (a(1,i), ...,a(m,i)) representing column i of A and a(1,1)
ge a(1,2) ge  ... ge a(1,m).  V=(v(1), ...,v(m)) is an integral
vector with v(1) lt a(1,1). Let i be the largest integer such that
a(1,i) ge v(1).  Then B is the matrix represented by the list (a(1), ...,
a(i),V,a(i+1), ...,a(n)). A is modified. \ecom 
\proc{MICS} (A: LIST): LIST; \eproc
\bcom Matrix of integers column sort. A is an integral matrix with non-
negative elements in first row.  A is represented column-wise.  B is an
integral matrix obtained by sorting columns of A such that elements
of the first row are in descending order. A is modified. \ecom 
\proc{MINNCT} (A: LIST): LIST; \eproc
\bcom Matrix of integers, non-negative column transformation.
A=(a(i,j)) is an m by n integral matrix.  A is represented
column-wise. B=(b(i,j)) is the m by n integral matrix
with b(i,j)=a(i,j) if a(1,j) ge 0 and b(i,j)=-a(i,j) if
a(1,j) lt 0. A is modified. \ecom 
\proc{MMDDET} (PL,M: LIST): LIST; \eproc
\bcom Matrix of modular digits determinant. p is a prime beta-integer.
M is a square matrix over GF(p), represented as a list.  d is the
determinant of M. \ecom 
\proc{MMDNSB} (PL,M: LIST): LIST; \eproc
\bcom Matrix of modular digits null space basis. p is a prime beta-
integer.  M is an m by n matrix over Z sub p.  B is a list (b(1), ...,
b(r)) representing a basis for the null space of M, consisting of all
x such that M*x=0.  r is the dimension of the null space.  B=() if
the null space of M is 0.  Each b(i) is a list representing an
m-vector.  M is modified.  Alternatively, if M represents a matrix by
columns, then B is a basis for the null space consisting of all x such
that x*M=0. \ecom 
\proc{MMPDMA} (RL,PL,M: LIST): LIST; \eproc
\bcom Matrix of modular polynomials determinant, modular algorithm. M is a
square matrix of modular polynomials in r variables over Z sub p,
r non-negative, p a prime beta-integer. D is the determinant of M. \ecom 
\proc{MMPEV} (RL,ML,A,KL,AL: LIST): LIST; \eproc
\bcom Matrix of modular polynomials evaluation. A is a matrix of
polynomials in r variables over Z sub m, m a positive beta-integer.
1 le k le r and a is an element of Z sub m.  B is the matrix of
polynomials b(i,j) where b(i,j)(x(1), ...,x(k-1),x(k+1), ...,x(r))=
a(i,j)(x(1), ...,x(k-1),a,x(k+1), ...,x(r)). \ecom 
\proc{VIAZ} (A,NL: LIST): LIST; \eproc
\bcom Vector of integers, adjoin zeros. A is the vector (a(1), ...,a(m)).
n is a non-negative beta-integer.  B is the vector (a(1), ...,a(m),
0, ...,0) of m+n components. A is modified. \ecom 
\proc{VIDIF} (A,B: LIST): LIST; \eproc
\bcom Vector of integers difference. A and B are vectors in Z sup n.
C=A-B. \ecom 
\proc{VIERED} (U,V,IL: LIST): LIST; \eproc
\bcom Vector of integers, element reduction. U=(u(1), ...,u(n)) and
V=(v(1), ...,v(n)) are integral n-vectors.  1 le i le n.  v(i)
ne 0. W=U-q*V, where q=INTEGER(u(i)/v(i)). \ecom 
\proc{VILCOM} (AL,BL,A,B: LIST): LIST; \eproc
\bcom Vector of integers linear combination. a and b are integers. A
and B are integral vectors in Z sup n. C=a*A+b*B. \ecom 
\proc{VINEG} (A: LIST): LIST; \eproc
\bcom Vector of integers negation. A is an integral vector. B=-A. \ecom 
\proc{VISPR} (AL,A: LIST): LIST; \eproc
\bcom Vector of integers scalar product. a is an integer. A is an
integral vector. C=a*A. \ecom 
\proc{VISUM} (A,B: LIST): LIST; \eproc
\bcom Vector of integers sum. A and B are vectors in Z sup n. C=A+B. \ecom 
\proc{VIUT} (U,V,IL: LIST; VAR UP,VP: LIST); \eproc
\bcom Vector of integers, unimodular transformation. U=(u(1), ...,u(n))
and V=(v(1), ...,v(n)) are vectors in Z sup n with u(i) ne 0.
(UP,VP)=(U,V)*K where K is a unimodular matrix, depending on u(i)
and v(i), whose elements are obtained from IDEGCD. \ecom 
\section{ Symmetric functions definition module. } 
\proc{DIRPSR} (Q,PL: LIST; VAR P1,P2: LIST); \eproc
\bcom Distributive rational polynomial symmetric function reduction.
Q is a list of the rl elementary symmetric functions in rl 
variables. pl is reduced modulo Q to p2, the reduction relation 
is p1.  \ecom 
\proc{DIRPSE} (Q,U: LIST; VAR PL,V: LIST); \eproc
\bcom Distributive rational polynomial symm. function exponent reduction.
Q is a list of the rl elementary symmetric functions in rl 
variables. pl is a product of elemenatry symmetric polynomials such 
that head term pl = u. v is the exponent vector of the product.  \ecom 
\proc{DIRPES} (RL: LIST): LIST; \eproc
\bcom Distributive rational polynomial elementary symmetric functions.
Q is a list of the rl elementary symmetric functions in rl 
variables.  \ecom 
\proc{EVASC} (U: LIST): LIST; \eproc
\bcom Exponent vector ascending. U is an exponent vector of length rl,
U=(u1, ... ,url). tl = 1 if u1 le ... le url, else tl = 0.  \ecom 
