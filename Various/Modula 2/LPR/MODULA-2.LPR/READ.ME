-------------------------------
Dokumentation zum Modula-System                         Stand 12.04.89
-------------------------------

Vorwort:
========
Dieses Modula-2-System wurde fÅr Ausbildungszwecke konzipiert und wird
zur Programmierausbildung fÅr Studenten der FakultÑt Elektrotechnik und
Informationstechnik eingesetzt.

Mit dieser Public-Domain-Version soll nun allen an Modula-2 Interessierten
die Mîglichkeit geboten werden, sich mit dieser Sprache zu beschÑftigen.

Allerdings muû an dieser Stelle erwÑhnt werden, daû von Seiten des
Lehrstuhls keine Dokumentation oder ausfÅhrliche Anleitung zur VerfÅgung
steht und daû keinerlei Beratung (weder telefonisch noch schriftlich)
durchgefÅhrt werden kann.


Die folgenden Hinweise kînnen natÅrlich kein komplettes Handbuch ersetzen,
sollten aber fÅr die normale Bedienung des Systems ausreichen.


1.0 Zusammenstellung der Diskette :
-----------------------------------

   - AUTO         (Ordner, mit RAM-Disk)
   - DEF          (Ordner, mit den DEFINITION-Modulen zur Bibliothek)
   - GEMLIB       (Ordner, mit SBM- & OBM-Files fÅr GEM)
   - STDLIB       (Ordner, mit SBM- & OBM-Files der Standardmodule)
   - SYSTEM       (Ordner, mit SBM- & OBM-Files der Systemumgebung)
   - STANDALO.NE  (Ordner, mit OBM-Files, die der Linker benîtigt)
   - SBM          (Ordner, mit SBM-Files, die in die RAM-Disk kopiert
                   werden)
   - OBM          (Ordner, mit OBM-Files,            -"-              )
   - WORK         (Ordner, mit den Files, die bearbeitet werden sollen)
   - COPY.LST     (Liste der Files die in die Ramdisk Åberspielt werden)
   - RAMDISK.INF  (Infodatei der RAM-Disk, Grîûe, Laufwerksbuchstabe ...)
   - (EDITOR.PRG) (eigener Editor z.B. Tempus)
   - M2PATH.TXT   (Suchpfade der MODULA-SHELL)
   - ERROR.IND    (Fehlermeldungen fÅr den Compiler)
   - MK_COPY.PRG  (Kopierprogramm. Es wird von der RAM-Disk aufgerufen)
   - M2LOADER.PRG (hiermit wird die Shell gestartet)
   - DEBUG.RSC
   - M2SHELL.RSC
   - DESKTOP.INF
   - READ.ME
   - COPYRIGH.T


2.0 Modula-Shell :
------------------

2.1 Hochfahren des Systems

    - ATARI einschalten
    - Modula-Diskette einlegen
      ... Der ATARI bootet und installiert die RAM - Disk
      ... Einige Files entsprechend der Datei COPY.LST werden in die
          RAM - Disk geladen
      Jetzt wird der M2LOADER durch Sie auf der RAM-DISK gestartet.
      (Der M2LOADER liest M2Paths.txt; man kann daher auch M2Loader als
       Anwendung anmelden und dann M2LOADER durch Doppelklick auf M2Paths
       starten. Dazu braucht M2LOADER.PRG nicht auf der RAM-Disk sein)
      Im LOADER starten Sie M2SHELL.OBM durch betÑtigen der RETURN-Taste.
      ...Die Modula-Shell wird nun geladen.
      Jetzt mÅssen Sie nur noch das DATUM eingeben, falls dies noch nicht
      geschehen ist und schon kann's losgehen.


2.1 Bedienung der Shell

    - Das MenÅ 'Desk':
      - M2-Shell: ein paar Informationen zum Modula-2 System.
    - Das MenÅ 'Modul':
      - Editieren, öbersetzen & Starten bezieht sich jeweils auf die
      Arbeitsdatei (wird in der Desktop-Box angezeigt). Ist noch keine
      Arbeitsdatei ausgewÑhlt, so geschieht dies nach dem AnwÑhlen Åber
      die Fileselectorbox. Entsprechend wird nun der Editor, der Com-
      piler oder die Datei selbst geladen und ausgefÅhrt.
      Diese Funktionen kînnen auch Åber die Tastenkombinationen
      <control> E, ö & S erreicht werden.
      - Editiere ..., öbersetze ... & Starte ... beziehen sich jeweils
      auf eine Datei, die erst noch mit der Fileselectorbox ausgewÑhlt
      wird. Diese Funktionen kînnen auch Åber die Tastenkombinationen
      <alternate> E, ö & S erreicht werden.
      - PRG erzeugen bezieht sich auf die aktuelle Arbeitsdatei und ruft
      den Linker auf, der die importierten Module zusammenbindet und ein
      lauffÑhiges Programm erzeugt. Erraten, das geht auch mit <control> L.
      - Ende oder <control> X und die Shell wird verlassen, in der File-
      selectorbox des M2LOADER muû dann <Abbruch> gewÑhlt werden.
    - Das MenÅ 'Optionen':
      - Mit Modul auswÑhlen oder <control> A kann die Arbeitsdatei festge-
      legt werden.
      - Mit Suchpfade Ñndern oder <control> P kînnen die Pfade auf welchen
      die Shell oder der Compiler die benîtigten SBM- bzw. OBM-Files sucht
      geÑndert werden.
      - Mit Terminal îffnen bzw. <control> T kînnen z.B. die letzten
      Ausgaben eines Programms noch einmal untersucht werden, dazu wird das
      Terminal-Window geîffnet.
      - Compiler, Debug: ein paar Parameter kînnen hier geÑndert werden,
      die voreingestellten Werte sind Erfahrungswerte und mÅssen in den
      wenigsten FÑllen geÑndert werden.
      - Editor: Hier kann der verwendete Editor gewÑhlt werden, wobei gilt:
                linker  Eintrag: Editor als PRG-File
                rechter Eintrag: Editor als OBM-File
                Der gewÑhlte Editor wird unter dem angezeigten Namen
                gesucht. Beim 'PRG-Editor' wird er auf dem Pfad erwartet,
                von dem aus der M2LOADER gestartet wurde.
                Editor resident bezieht sich auf den 'OBM-Editor'.
      - Backup: Der gerade bearbeitete Text (beim Aufruf des Editors) wird
        auf dem angegebenen Pfad noch einmal abgespeichert, wenn ein Backup
        gewÅnscht wird. Das ist besonders zu empfehlen, wenn sich die
        Arbeitsdatei in der RAM-Disk befindet.
      - mit *.DEF, *.MOD bearbeiten (<control> D, M) kann man einstellen ob
      ein DEFINITION oder (IMPLEMANTATION) MODUL bearbeitet werden soll.
      Das bezieht sich im besonderen auf den Compiler (existiert TEST.DEF
      und TEST.MOD und soll TEST.DEF Åbersetzt werden, dann *.DEF bearbeiten
      wÑhlen und den Compiler aufrufen), auûerdem werden dann in der File-
      selectorbox nur *.DEF bzw. *.MOD angezeigt.
    - Das MenÅ 'Datei':
      - Kopieren, Lîschen & Umbenennen: Es wird jeweils Åber die File-
      selectorbox das entsprechende File ausgewÑhlt und danach entweder
      das Zieldirectory oder der neue Name bestimmt.
      - AusfÅhren: Es kann ein Programm (*.PRG) gestartet werden.



3.0 Informationen Åber Linker, Debugger und Compiler :
------------------------------------------------------

3.1 Allgemeines:

- Die Arbeitsumgebung ist in Schichten aufgebaut. Unterste Schicht ist
  der M2LOADER. Auf M2LOADER liegt dann (normalerweise) M2SHELL. Dies
  ist ein Objektmodul d.h. es kann nicht ohne den M2LOADER laufen.
  M2SHELL ruft dann ihrerseits Editor und Compiler auf.
  Wird ein compiliertes Programm gestartet, so lÑuft es, wenn es
  noch nicht gelinkt ist, wie alle ".OBM"- Programme unter Kontrolle
  von M2LOADER, der bei Laufzeitfehlern den Debugger starten kann.
  M2SHELL, der Compiler, der Editor und der Debugger bleiben, wenn sie
  einmal geladen sind, resident.

- M2PATHS.TXT.
  Diese Datei kann wie jede Textdatei mit dem Editor bearbeitet werden.
  In ihr stehen Suchpfade, die der Compiler, der Debugger, die Shell
  und M2LOADER auf der Suche nach Dateien benutzen.
  Auûerdem kann der Defaultaufruf des M2LOADER eingetragen werden. D.h.
  diejenige Objekt-Datei, deren Name in der letzten Zeile nach @M steht,
  wird vom M2LOADER vorgewÑhlt und kann durch Anklicken von [OK] gestartet
  werden.
  In der vorletzten Zeile dieser Datei steht der Suchpfad (der letzte
  Suchpfad) der als Default fÅr Funktionen wie Modul auswÑhlen usw.
  verwendet wird.
  Der vorletzte Suchpfad wird als Voreinstellung fÅr den Backup-Pfad
  verwendet und sollte sinnigerweise keine RAM-Disk als Ziel haben.
  Fehlt die Angabe des Laufwerkes in einem Pfad, so bezieht sich dieser
  auf den aktuellen Pfad des GEMDOS, im allgemeinen der Pfad von dem aus
  der M2LOADER gestartet wurde.
  Jeder Pfad muû mit '\' enden, denn intern wird nur noch der Filename an
  den Pfad angehÑngt.
  Maximal 15 Pfadnamen kînnen angegeben werden.


3.2 Der Linker (Standalone Programme):

- Da man, wenn man "ernsthaft" programmieren will Programme ohne
  den Schutz von M2LOADER laufen lassen will, muû man die compi-
  lierten Objektmodule binden (linken). Dazu muû sich der Ordner
  STANDALO.NE auf dem Laufwerk befinden, von dem M2LOADER geladen
  wurde, d.h. Benutzer einer RAM-Disk mÅssen diesen Ordner mit Inhalt
  per Maus, oder per COPY.LST automatisch, in die RAM-Disk kopieren.
  Der Inhalt von STANDALO.NE sollte auf keinen Fall verÑndert werden!
  Der Linker wird durch "PRG erzeugen" gestartet. Er sucht sich
  dann alles zusammen, was er braucht (GEMX.OBM, PATH.OBM, HEAP.OBM, ...)
  und erzeugt dann ein lauffÑhiges PRG-File aus allen nîtigen OBM-Files.
  (Diese mÅssen dann auch auf den Suchpfaden vorhanden sein). Der Linker
  ÅberprÅft dabei die Module auch auf Versionskonflikte.  Findet der
  Linker ein OBM-File nicht, so gibt er dem Benutzer die Chance,
  per "Hand" die gesuchten Module zu finden. Die fertigen Programme
  werden, wenn keine Fehler auftraten, im gleichen Ordner wie das
  OBM-File abgelegt.
  Wichtig: Programme kînnen nach dem Linken ein anderes Verhalten zeigen
           wie beim Aufruf aus der Shell. Das liegt daran, daû von der
           Shell bzw. Loader (vom Programmierer oft nicht wahrgenommen)
           eine Reihe von Funktionen zur VerfÅgung gestellt werden, die nun
           fehlen bzw. selbst eingerichtet werden mÅssen (z.B. Textausgabe,
           Exceptionbehandlung usw.).


3.3 Der Debugger:

- Der Debugger ist ein Source-Level-Debugger, der nach einem "Programm-
  absturz" aktiv wird (Post-Mortem-Debugger). Dazu wird er nach einem
  Laufzeitfehler vom M2LOADER gestartet und zeigt im Textfenster den
  Programmsourcetext; die Fehlerzeile ist dabei  fett gedruckt.
  Alle beim Fehlerauftritt sichtbaren Variablen kînnen angezeigt werden.
  Sichtbar sind alle gobalen Variablen und die lokalen Variablen aller
  Prozeduren der aktuellen Prozeduraufrufkette.
  Dazu bedarf es aber der RFM-Files der entsprechenden Module.
  Es gibt fÅnf Fenster:

    - Quelltext:
    Da steht (hoffentlich) der Quelltext drin, in dem der Fehler auf-
    trat. Ist das Fenster leer, so ist der Quelltext zum entsprechenden
    Modul nicht erreichbar. Wenn der Quelltext in einem der Suchpfade
    liegt, fÅhrt das Anklicken des Modulnamens im Modulfenster (meistens)
    zum Erfolg.

    - Prozeduraufrufkette und Datenfenster 1:
    Diese beiden Fenster gehîren zusammen. Das linke Fenster (Proze-
    duraufrufkette) zeigt, in welcher Reihenfolge die Prozeduren auf-
    gerufen wurden. Die oberste ist die Prozedur in der der Fehler auf-
    getreten ist. Im rechten Fenster kînnen die Variablen, die in der
    ausgewÑhlten Prozedur sichtbar sind, auf ihren Inhalt hin untersucht
    werden.

    - Modulliste und Datenfenster 2:
    Hier gilt gleiches wie oben, nur daû hier alle Module angezeigt werden,
    die sich gerade im Speicher befinden. Sofern die RFM-Files der Module
    auf den Suchpfaden liegen, kînnen die dort sichtbaren Variablen
    untersucht werden.

  - Durch Anklicken von Prozedur bzw. Modulnamen kann man diese
  Prozedur bzw. dieses Modul betrachten, d.h. die dort sichtbaren
  Variablen.

  - Zu den Datenfenstern ist die Darstellung strukturierten Datentypen
  (Arrays , Records) und die Darstellung der Pointer auf diese Datentypen
  zu erwÑhnen. Beide sind durch "*" gekenzeichnet. Klickt  man diesen an,
  so "betritt" man das Array/Record. In der ersten Zeile des Fensters
  erscheint nach einem "." der Name der angeklickten  Variablen. Bei
  tiefer strukturierten Datentypen kînnen dort durchaus mehrere Bezeichner
  durch "." getrennt hintereinander stehen (z.B. bei der Analyse einer
  verketteten Liste ). Durch Anklicken der Bezeichner kann man dann
  wieder "herauf"steigen.

  - Variablen vom Typ BITSET, SET OF ... bzw. ADDRESS werden in hexa-
  dezimaler Form ausgegeben.

  - Die MenÅeintrÑge erklÑren sich, wenn ein wenig mit ihnen 'gespielt'
  wird, bald von selbst.

  Hinweis: Error Process
  Modula bietet eine Schnittstelle zum Arbeiten mit Coroutinen
  (= Multitasking). Dazu wird der Datentyp "PROCESS" verwendet. Der
  Debugger analysiert beim Doppelklick auf eine Variable vom Typ PROCESS
  den lokalen Stack dieser Task. Soll auf den Stack der "abgestÅrzten" Task
  zurÅckgekehrt werden, so muû der MenÅpunkt Error Process angewÑhlt werden.


  - FEHLER: Wenn in einer WITH-Anweisung der Programmablauf gestoppt wird,
  stÅrzt der Rechner beim Fortsetzen des Programmes ab, sofern auf die
  dereferenzierte Variable noch innerhalb dieser WITH-Anweisung zugegriffen
  wird.
  Nach Aufruf des Debuggers kann es passieren, daû anschlieûend mit Tempus
  abgespeicherte Dateien mehrfach unter dem gleichen Namen abgelegt werden.
  Bei der RÅckkehr in die Shell werden diese in *.X?? umbenannt, wobei X fÅr
  den ursprÅnglichen Buchstaben der Extension steht und ? fÅr eine Ziffer,
  Es wird durch eine Alertbox darauf hingewiesen.
  Dieser Test beschrÑnkt sich allerdings auf das aktuelle File das vor dem
  Aufruf des Editors bestimmt wurde.
  (Dieser Fehler sollte nun behoben sein!)

3.3 Der Compiler:

  - Der Compiler ist ein Single-Pass-Compiler, alle Bezeichner mÅssen vor
  ihrer Verwendung deklariert werden. Sollte dies fÅr Prozeduren nicht
  mîglich sein, so ist eine FORWARD Anweisung zu verwenden, die auf der
  gleichen Schachtelungstiefe wie die anschliessende Deklaration selbst
  erfolgen muû. Syntax: wie bei der Prozedur-Deklaration und dabei
  den BEGIN-END; - Block durch FORWARD; ersetzen.
  - Werden beim Åbersetzten einer Datei importierte Module nicht auf den
  Suchpfaden gefunden, so kînnen Sie diese von Hand aufsuchen.
  - Wenn Fehler gefunden wurden, so wird eine Datei *.ERR erzeugt, in der
  neben Zeile und Spalte des Fehlers auch die Fehlermeldung zu finden ist.
  - Die SBM-, RFM- und OBM-Files werden im gleichen Ordner wie die
  Quelltexte abgelegt.
  - Wird der Compiler mit einer Datei mit Extension *.CM? (? = beliebiges
  Zeichen) aufgerufen, so erwartet er darin eine Liste von Modulnamen
  (mit Extension). Die Module werden dann in dieser Reihenfolge Åber-
  setzt. Dies eignet sich, wenn in einem grîûeren Programmpaket ein
  DEFINITION MODUL geÑndert werden muûte, um ein komplettes Update zu er-
  zeugen (Ñhnlich einem Make).



4.0 Allgemeine Hinweise:
------------------------

  - Diese Diskette enthÑlt einen zum Modula-System passenden Editor
    (M2Editor). Da aber zum einen dieser Editor noch nicht 100 % ausge-
    testet ist und zum anderen ein Editor Geschmacksache ist, kann jeder
    andere Editor verwendet werden.
  - Als Editor eignet sich (neben dem beiliegenden Editor) Tempus ausge-
    zeichnet.
  - Die Voreinstellungen kînnen mit einem Resource-Construction-Set leicht
  an eigene WÅnsche angepaût werden. Es ist nur darauf zu achten, daû der
  Objektbaum nicht neu konstruiert wird (die Shell geht natÅrlich weiter-
  hin von ihrer Objektstruktur aus).
  Der Name des Editors kann ebenfalls geÑndert werden (max. 8 Zeichen).
  Der Editor wird dann unter diesem Namen mit Extension *.PRG (linker
  Eintrag) bzw. *.OBM (rechter Eintrag) gesucht.
  - Wenn ein 1040'er verwendet wird, empfiehlt es sich das System wie folgt
  einzurichten:
    - Die RAM-Disk mit etwa 200 kByte installieren.
    - Die SBM-Files in den Ordner SBM in der RAM-Disk.
    - Die oft benîtigten OBM-Files in den Ordner OBM in der RAM-Disk
    - den Ordner WORK mit den Files die gerade von Ihnen bearbeitet werden
    auf die RAM-Disk.
    - ohne Ordner auf der RAM-Disk den Editor (mit *.RSC), die Datei
    ERROR.IND sowie M2PATH.TXT.
    - Nun auf M2LOADER.PRG eine Anwendung mit Extension *.TXT anmelden.
    - DESKTOP.INF sichern.
    - nun kann durch Doppelklick auf M2PATH.TXT in der RAM-Disk der M2LOADER
    gestartet werden.
    - M2LOADER glaubt sich von der RAM-Disk gestartet, und es werden
    zusÑtzlich 25 kByte in der RAM-Disk frei.

  - Das Pseudo-Modul SYSTEM exportiert folgende Bezeichner:
    VAL, ADR, ADDRESS, LONG, SHORT, BYTE, WORD,
    SETREG, REG, INLINE, CODE.
    In aller KÅrze:
    - VAL und ADR wie bei N. Wirth.
    - LONG und SHORT wandeln zwischen den verschiedenen DatenlÑngen um.
      Bsp. mit Typen: LONG(CARDINAL) = LONGCARD.
    - BYTE und WORD sind 'Universaltypen' der entsprechenden LÑnge.
    - SETREG und REG setzen und lesen die Register des MC68000
      dabei gilt die Zuordnung der Registernummern:
        D0 -> 0, D1 -> 1, ... A0 -> 8, ... A7 -> 15.
      In die Register werden nur 32 Bit Worte geschrieben.
      Aufruf: SETREG( RegisterNummer, 32BitWort )
              32BitWort := REG( RegisterNummer )
      als 32 BitWort wird LONGINT und ADDRESS akzeptiert.
    - INLINE es kann Maschinensprache Code integriert werden.
      Bsp. INLINE( Zahl1, Zahl2, Zahl3 ) oder INLINE( Zahl1 ).
      Zahl? muû vom Typ CARDINAL und eine Konstante sein.

  - LONG-Konstanten mÅssen durch AnfÅgen von D als solche gekennzeichnet
  werden (323.0E23D ist eine LONGREAL-Konstante).

  - Zahlen in hexadezimaler Form kînnen durch AnfÅgen von H gekennzeichnet
  werden, die erste Ziffer muû dennoch eine Zahl sein, also nicht FFH,
  sondern 0FFH

  - AufzÑhlungstypen haben maximal 256 Elemente.
  - Die Set-Grîsse ist auf 16 (Wortgrîûe) beschrÑnkt.

Zum Schluû wÅnsch' ich allen Benutzern viel Spaû.

                                                    M.Bayer

===========================================================================

Kurze Anleitung des beiliegenden Editors :
==========================================

Editorfunktionen                                    Referenzliste
==================================================================

Funktionsname ! MenÅ   ! Code     ! Beschreibung
--------------+--------+----------+------------------------------------
ProgInfo      ! Desk   ! CA ~ I   ! Infobildschirm zeigen
ProgQuit      ! File   ! CA ~ Q   ! Programm verlassen
FileOpen      ! File   ! CA ~ O   ! Datei in neues Fenster laden
FileLoad      ! File   ! CA ~ L   ! Datei in aktuelles Fenster laden
FileMerge     ! File   ! CA ~ M   ! Datei im aktuellen Fenster einfÅgen
FileSave      ! File   ! CA ~ S   ! Text mit neuem Namen speichern
FileUpdate    ! File   ! CA ~ U   ! Text direkt speichern
FileBackup    ! File   ! CA ~ B   ! Text speichern, altes File -> .BAK
FileDelete    ! File   ! CA ~ D   ! Datei lîschen
--------------+--------+----------+------------------------------------
WindowOpen1   ! Window !  C ~ (   ! Fenster 1 îffnen
WindowOpen2   ! Window !  C ~ )   ! Fenster 2 îffnen
WindowOpen3   ! Window !  C ~ /   ! Fenster 3 îffnen
WindowOpen4   ! Window !  C ~ *   ! Fenster 4 îffnen
WindowFull1   ! -      !  S ~ (   ! Fenster 1 auf volle Grîûe bringen
WindowFull2   ! -      !  S ~ )   ! Fenster 2 auf volle Grîûe bringen
WindowFull3   ! -      !  S ~ /   ! Fenster 3 auf volle Grîûe bringen
WindowFull4   ! -      !  S ~ *   ! Fenster 4 auf volle Grîûe bringen
WindowClose1  ! Window !  A ~ (   ! Fenster 1 schlieûen
WindowClose2  ! Window !  A ~ )   ! Fenster 2 schlieûen
WindowClose3  ! Window !  A ~ /   ! Fenster 3 schlieûen
WindowClose4  ! Window !  A ~ *   ! Fenster 4 schlieûen
--------------+--------+----------+------------------------------------
TextDelete    ! Edit   ! CA ~ DEL ! Text eliminieren, Fenster schlieûen
SearchDefine  ! Edit   ! SC ~ S   ! Suchparameter definieren
SearchStart   ! Edit   !  C ~ S   ! Suchen starten
ReplaceDefine ! Edit   ! SC ~ R   ! Ersetzparameter definieren
ReplaceStart  ! Edit   !  C ~ R   ! Ersetzen starten
--------------+--------+----------+------------------------------------
TextStart     ! Jump   ! SC ~ CU  ! Textanfang anspringen
TextEnd       ! Jump   ! SC ~ CD  ! Textende anspringen
TextLine      ! Jump   !  C ~ G   ! Textzeile anspringen
ErrorFirst    ! Jump   !  C ~ F   ! ersten Fehler anspringen
ErrorLast     ! Jump   !  C ~ L   ! letzten Fehler anspringen
ErrorNext     ! Jump   !  C ~ N   ! nÑchsten Fehler anspringen
ErrorPrevious ! Jump   !  C ~ P   ! vorherigen Fehler anspringen
--------------+--------+----------+------------------------------------
BlockMark     ! Block  !  A ~ B   ! Zeilenblock markieren
BlockHide     ! Block  !  A ~ H   ! Markierung lîschen
BlockDelete   ! Block  !  A ~ D   ! Block lîschen
BlockMove     ! Block  !  A ~ M   ! Block verschieben
BlockCopy     ! Block  !  A ~ C   ! Block kopieren
--------------+--------+----------+------------------------------------
ModeIndent    ! Mode   !  C ~ I   ! Indentmodus ein/ausschalten
ModeInsert    ! Mode   !  S ~ INS ! Insertmodus ein/ausschalten
ModeTab       ! Mode   !  C ~ TAB ! Tab-Weite definieren
--------------+--------+----------+------------------------------------
CharRight     ! -      !      CR  ! ein Zeichen nach rechts
CharLeft      ! -      !      CL  ! ein Zeichen nach links
CharReduce    ! -      !      BSP ! ein Zeichen links lîsch.
CharDelete    ! -      !      DEL ! ein Zeichen auslîschen
CharInsert    ! -      !      INS ! ein Zeichen einfÅgen
--------------+--------+----------+------------------------------------
LineRight     ! -      !  S ~ CR  ! an das Zeilenende
LineLeft      ! -      !  S ~ CL  ! an den Zeilenanfang
LineDown      ! -      !      CD  ! Zeile runter
LineUp        ! -      !      CU  ! Zeile rauf
LineTailDelete! -      !  S ~ DEL ! Zeile ab Cursor lîschen
LineReduce    ! -      !  C ~ BSP ! Zeile vorher lîschen
LineDelete    ! -      !  C ~ DEL ! Zeile herauslîschen
LineInsert    ! -      !  C ~ INS ! Zeile einfÅgen
LineDownSwap  ! -      !  C ~ +   ! Zeile runter schieben
LineUpSwap    ! -      !  C ~ -   ! Zeile rauf schieben
LineDouble    ! -      !  C ~ ENT ! Zeile verdoppeln
LineUndo      ! -      !     UNDO ! Zeile restaurieren
--------------+--------+----------+------------------------------------
Eol           ! -      !      RET ! Zeile abschlieûen
EolLineInsert ! -      !  S ~ RET ! Return + neue Zeile
EolBackspace  !        ! SC ~ BSP ! Zeile(n)+Zeile(n-1)
EolDelete     !        ! SC ~ DEL ! Zeile(n)+Zeile(n+1)
EolInsert     !        ! SC ~ INS ! (C~RET) Zeilenrest in neue Zeile
--------------+--------+----------+------------------------------------
TabRight      ! -      !      TAB ! nÑchste TAB-Position anspringen
TabLeft       ! -      !  S ~ TAB ! vorherige TAB-Position anspringen
ScrollUp      ! -      !  S ~ CU  ! Text nach unten schieben
ScrollDown    ! -      !  S ~ CD  ! Text nach oben schieben
ScreenUp      ! -      !  C ~ CU  ! ein Bildschirm rauf
ScreenDown    ! -      !  C ~ CD  ! ein Bildschirm runter




         M o d u l a - U n t e r s t Å t z u n g :



Da der Altex-Editor speziell fÅr das Modula-2-System entwickelt
wurde, enthÑlt er einige Besonderheiten, die das Schreiben von
Modula-Programmen erleichtern.


Modula-Assistent:


Bei der Eingabe eines Modula-Programmes befindet man sich wegen
der Variablen und Kommentare normalerweise im Kleinschriftmodus.
Soll nun ein Modula-SchlÅsselwort eingegeben werden, so muû man
entweder in den Groûschriftmodus umschalten, oder die SHIFT-Taste
gedrÅckt halten. Dieses und die Eingabe des SchlÅsselwortes
selbst kann man sich nun vom 'Modula-Assistenten' abnehmen
lassen. FÅr jedes bekannte SchlÅsselwort existiert eine maximal
zwei Buchstaben lange AbkÅrzung, die nach DrÅcken der HELP-Taste
(Der Cursor muû dazu genau hinter der eingegebenen AbkÅrzung
stehen!) in die korrekte, ausfÅhrliche Modula-Schreibweise umge-
wandelt wird.

Beispiel: p <HELP> wird zu 'PROCEDURE' expandiert ...
Beispiel: ew <HELP> wird zu 'END(*WHILE*);' umgewandelt ...

Nachfolgend eine Liste der Modula-SchlÅsselwîrter und ihrer
AbkÅrzungen:

SchlÅsselwort         | KÅrzel      SchlÅsselwort | KÅrzel
 -----------------------+--------   --------------+--------
ABS(                  | AB          LONGINT;_     | LI
ADDRESS;_             | AS          LONGREAL;_    | LR
ADR(                  | AD          LOOP_         | L
AND_                  | A           MOD_          | M
ARRAY_                | AR          MODULE_       | MO
BEGIN                 | B           NEW(          | NE
BITSET;_              | BS          NIL_          | NI
BOOLEAN;_             | BL          NOT_          | N
BY_                   | BY          ODD(          | OD
BYTE;_                | BT          OF_           | OF
CAP(                  | CP          OR_           | O
CARDINAL;_            | CD          ORD(          | OR
CASE_                 | CS          POINTER_TO_   | PT
CHAR;_                | C           PROC;_        | PR
CHR(                  | CR          PROCEDURE_    | P
CONST_                | CN          QUALIFIED_    | Q
DEC(                  | DC          REAL;_        | RA
DEFINITION_MODULE_    | DM          RECORD        | RE
DISPOSE(              | DP          REG(          | RG
DIV_                  | DV          REPEAT_       | RP
DO_                   | D           RETURN_       | R
ELSE_                 | E           Read(         | RD
ELSIF_                | ES          ReadCard(     | RC
END_                  | EN          ReadInt(      | RI
END(*CASE*);_         | EC          ReadReal(     | RR
END(*FOR*);_          | EF          ReadStr(      | RS
END(*IF*);_           | EI          SET_OF_       | S
END(*LOOP*);_         | EL          SETREG(       | SR
END(*RECORD*);_       | ER          SHIFT(        | SF
END(*WHILE*);_        | EW          SHORT(        | SH
END(*WITH*);_         | EH          SIZE(         | SI
EXCL(                 | EX          THEN_         | TH
EXIT;_                | ET          TO_           | TO
EXPORT_               | EP          TRUE          | T
FALSE                 | F           TRUNC(        | TC
FLOAT(                | FL          TSIZE(        | TS
FOR_                  | FO          TYPE_         | TY
FROM_                 | FR          UNTIL_        | U
HALT;_                | H           VAL(          | V
HIGH(                 | HI          VAR_          | VR
IF_                   | I           WHILE_        | W
IMPLEMENTATION_MODULE_| IM          WITH_         | WT
IMPORT_               | IP          WORD;_        | WO
IN_                   | IN          Write(        | WE
INC(                  | IC          WriteCard(    | WC
INCL(                 | IL          WriteInt(     | WI
INLINE(               | II          WriteLn;_     | WL
INTEGER;_             | IT          WriteReal(    | WR
LONG(                 | LO          WriteStr(     | WS
LONGCARD;_            | LC                        |


Compiler aufrufen:


Um den Zyklus 'bearbeiten, Åbersetzen, bearbeiten' zu beschleuni-
gen, besteht die Mîglichkeit, den Compiler vom Editor aus zu
starten.


Exit 0........: Altex verlassen und Text speichern
Tastatur......: CTRL + ALT + 0 (Ziffernblock)

Altex wird ohne Sicherheitsabfrage verlassen und der aktuelle
Text (nur dieser!) unter seinem augenblicklichen Namen auf
Diskette gespeichert.


Exit 1........: Altex verlassen und Åbersetzen
Tastatur......: CTRL + ALT + 1 (Ziffernblock)

'Exit 1' funktioniert wie 'Exit 0', nur daû nach dem Verlassen
des Editors automatisch der Compiler zum öbersetzen des Textes
gestartet wird. öbersetzt wird allerdings nur ein Text, der
bereits in der Shell als aktueller Text angewÑhlt wurde!


Exit 2........: Altex verlassen, Åbersetzen und starten
Tastatur......: CTRL + ALT + 2 (Ziffernblock)

'Exit 2' lÑuft genauso ab wie 'Exit 1'. ZusÑtzlich wird das
bearbeitete Programm nach dem (fehlerfreien!) öbersetzen sofort
gestartet.

Anmerkung: Sollte beim öbersetzen ein Fehler auftreten, so wird
automatisch wieder in den Editor gesprungen.

Fehler bearbeiten:

Auch bei der sorgfÑltigsten Programmierung ist man nicht vîllig
gegen 'Fehler beim öbersetzen' gefeit. Um das Auffinden der
Fehlerstellen zu erleichtern, erhielt Altex vier spezielle Funk-
tionen.

FirstError.: zeige erste Fehlermeldung
MenÅ.......: Jump / FirstError
Tastatur...: CTRL + F

LastError..: zeige letzte Fehlermeldung
MenÅ.......: Jump / LastError
Tastatur...: CTRL + L

NextError..: zeige nÑchste Fehlermeldung
MenÅ.......: Jump / NextError
Tastatur...: CTRL + N

PrevError..: zeige vorherige Fehlermeldung
MenÅ.......: Jump / PreviousError
Tastatur...: CTRL + P



Beim Aufruf des Editors mit Angabe eines Dateinamens wird eine
evtl. vorhandene Fehlerdatei automatisch mitgeladen. Diese befin-
det sich dann im Fenster 1, die eigentliche Quellcode-Datei im
Fenster 2.
Sobald in das Fenster 1 eine Datei mit der Endung .ERR geladen
wird, wechselt Altex in den Fehlermodus. Nun erscheint in der
Infozeile von Fenster 2 die aktuelle Zeile aus der Fehlerdatei.
Mit den vorhandenen Funktionen kann man sich nun in der Fehlerda-
tei bewegen, wÑhrend man die Sourcecode-Datei bearbeitet (ohne
dabei das Fenster wechseln zu mÅssen!). Wenn sich in der
aktuellen Zeile der Fehlerdatei eine Positionierungsangabe befin-
det, so wird diese Position im Sourcetext automatisch angesprun-
gen.



Versions-Update:


FÅr die tÑgliche Arbeit bei der Programmentwicklung wÑre es oft
sehr nÅtzlich, wenn man wÅûte, wann man in welchem Programmteil
zuletzt énderungen vorgenommen hat. Einige Programmierer schrei-
ben sich deshalb einen sauberen Programmkopf, in dem sie das
Datum der letzten énderung eintragen. Das Problem bei dieser
Methode liegt nun darin, daû man leider in schîner RegelmÑûigkeit
vergiût, dieses Datum zu aktualisieren.

Um diesem Miûstand wirkungvoll zu begegnen, besitzt Altex eine
spezielle Funktion.

Wenn innerhalb der ersten zehn Zeilen eines Programmtextes die
Zeichenfolge

'Version*:'

gefunden wird, so ersetzt Altex diese Zeichenfolge durch

'Version*: TT.MM.JJJJ   SS:MM'

'*'          steht fÅr beliebig viele beliebige Zeichen.
'TT.MM.JJJJ' steht fÅr das aktuelle Datum (z.B. 23.05.1989).
'SS:MM'      steht fÅr die aktuelle Zeit (z.B. 22:17).

Achtung: Hinter 'Version*:' sollte genÅgend Platz vorhanden sein,
da das Datum und die Zeit einfach Åberschreibend in den Text
plaziert werden.

