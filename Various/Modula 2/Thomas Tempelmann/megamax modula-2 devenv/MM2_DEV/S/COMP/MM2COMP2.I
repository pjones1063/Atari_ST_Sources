 IMPLEMENTATION MODULE MM2Comp2; (*$Z+,J+,R-,F-*)  (*$M- !!!!  >>> Am Ende $M- und Safety auf FALSE! <<< *)  (*$S-  Stackcheck erst bei komplexeren Routinen *)  (* IMPORT TOSDebug; IMPORT TOSIO, InOut; (*$E+*) *)  (* REPORT#------  ~~~ mîglichst oft WITH verwenden, damit neuer Comp mehr rausholt  ~ebenso, wie loadReg auch storeReg einfÅhren - das kînnte oft statt 'moveTo'"benutzt werden  Beginn: 23.11.89  26.1.90: Beginn Real-Codierung; Subversion: 'û/2' 27.1.90: Fehler behoben, daû z.B. bei MULU die source ein Adr-Reg sein konnte.)WITH wird in diesem Modul codiert)FOR mit konst. lower/upper bound wird optimiert codiert)Procs ohne F-Ergebnis belassen Parms auf A3-Stack 31.1.90: Reals fertig (bisher nur LONGREAL bei softReal, REAL bei externalFPU*noch nicht getestet))BY in Array-Constr. nun auch in ConstExpr anwendbar)Stack wird bei Value-Constr. und Parm-öbergabe geprÅft ('stackCheck'))genANDI benutzte immer D0, statt das verlangte Reg. -> MOD-Op funktio-+nierte teilw. nicht.)Bei "IMPORT SYSTEM" stÅrzt Compiler nicht mehr ab. 11.2.90: Word-Mul mit INTEGER macht richtigen Overflow-Check 08.5.90: CASE lîscht nicht D0, wenn Wert vorher schon in D0 ist 14.6.90: Version 'û/5')'+' als StrCat-Symbol;)"IF TRUE OR f() THEN" lîst keinen internen A3-Fehler mehr aus)FLOAT/LFLOAT erlauben Reals als Argument)LENGTH liefert auch bei String-Literals CARDINAL/LONGCARD statt ZZ)CHR liefert nun CHAR statt SS bei Literals)SS-Literale werden in CONST nicht mehr abgeschnitten, wenn mit "&&"+bzw. "+" zusammengesetzt.)SS-Typen nun genau nach ISO (7C ist SS, '1' auch, '' auch) 30.6.90: CAST erlaubt keine SETs mehr, wenn Grîûen unterschiedlich; 03.7.90: Kennung 45 zeigt nun 'regset' an; 'constMul' erweitert Byte auf)Word bei MULU/MULS. 20.7.90: Gleich/Ungleich auf Sets nun Word- statt Byteweise; kein 'rBranch')mehr, wenn z.B. IF FALSE THEN WriteString ('bla') vorkommt 23.7.90: loadRegExt lÑdt nun mit Sicherheit den Wert in ein 'niceRegs'; bisher)blieben INTEGERs ggf. im geschÅtzten Register.)CAST (CARDINAL, ByteSet) geht nun 12.9.90: Compiler lÑuft nun mit beiden Real-Formaten; bei constantFold wird)bei Cross-Compile kurz ins akt. Format gewandelt - geht aber noch nicht)bei ShortReals!)Subranges kînnen nicht mehr an Base-Type-VAR-Parms Åbergeben werden 21.9.90: LENGTH (REF-Open-Array) nochmal korrigiert; extractConstPtr arbeitet)nun richtig, Record-Const-Selektionen gehen auch bei constPtr.)Kennung v. Rec-Variante von 16 nach 47 geÑndert. 26.9.90: CADR() geht auf TABLE 18.10.90: Read-Only-Vars werden auch bei INC/DEC geprÅft; "FOR c:= d+1 TO f()"*vertauscht Werte nicht mehr auf dem Stack; Reg-Vars auch bei ST-FPU. 01.11.90: Sets, die nicht bei Null beginnen, verÑndern bei INCL usw. nicht mehr)den Orignal-Index-Wert, falls er in einer Reg-Var steht.)Busfehler bei groûen Aggregaten behoben. Kein SP-Inkonsistent)mehr bei ungeraden LÑngen groûer Daten (>256 Byte) 11.11.90: Bei Moves auf den Stack wird mîglichst ein extra ADDQ #1,A3 vermieden,)indem aus einem MOVE.B ein MOVE.W/L wird ("moveTo"). Direktive ^+)lÑût Open Array-/REF/VAR-Parameter immer auf geraden Adr. beginnend)annehmen (hat aber z.Zt. bei Open Arrays keinen Effekt). 20.11.90: accessArray setzt "mayBeOdd" nun auch bei Zugriffen in Byte-Arrays.)addIdxReg erhÑlt neuen Parm, um "ADD Dn,An" statt "0(An,Dn)" zu gen.)ARRAY OF BYTE/CHAR erlauben nur noch 32768 Elemente. 08.12.90: Bei A7-Parm-öbergabe nun pauschal alle Value-Args an Open Arrays)verboten, weil 1. u.U. Spilling z.Zt. Fehler macht, 2. das mit)mehreren Parms auf dem A7 sowieso nicht klappen wÅrde, weil z.Zt.)die Pointer/High-Werte sich mit den Value-Kopien auf dem selben)Stack (A7) mischen wÅrden. 19.12.90: Beim Array-Zugriff mit CARDINALs auf CARDINAL-Subranges wird kein*CHK mehr erzeugt, bei INTEGER-Index auf CARDINAL-Subranges wird*auch die Untergrenze geprÅft. 01.02.91: accessArray meldet nun "] erwartet", wenn zu viele Indices auftauchen;*runtimeLength kommt nun auch mit Arrays klar (der Index in D0 wurde*vom High-Wert zu frÅh Åberschrieben); extractConstPtr korrigiert auch*'start', wenn die Const dabei kleiner als 128 Byte wird, so daû nicht*mehr die ersten 2 Byte verloren gehen; richtige Fehlermeldung statt*Internem Fehler, wenn Par-Daten > 32KB; Kein Fehler mehr bei*FOR x:= 1 TO ORD(10) DO END; $W- funktioniert wieder bei REF- an*VAR-Parms; $A+ wirkt nun auf alle "designator". 27.02.91: Bei TT-FPU wird bei Conversion Real->WholeNumber der Real-Wert, wenn*er im Reg steht, zur richtigen Zeit auf den Stack geladen - wurde*zuvor vor dem Spilling auf den Stack gebracht, was zu Fehlern mit*der Stack-Reihenfolge fÅhren konnte. 02.03.91: Vergleich von Procs mit Proc-Vars sowie alle Vergl. mit localProcTypes*nun mîglich, nur Vergl. von lokalen Prozeduren (beide const.) geht*noch nicht; varComp meldet nicht mehr InkompatibilitÑt, wenn viele*Importe vorkommen (durch MOVEM.W wurde Item-Ptr ggf. verÑndert). 11.03.91: Nicht-Arrays als akt. Parm. von Open Arrays fÅhren nicht mehr zu*internen Fehlern; accessArray kommt auch klar, wenn auf Array-Elem*eines Open Arrays zugegriffen wird; runtimeRealOp: erzeugt keinen*falschen Code mehr, wenn bei Soft-Reals ein REAL-Operand im Register*steht. 12.03.91: Mehrdim. Open Arrays; Debug-Ausgabe wieder in simpleExpression,*zusÑtzlich am Ende von BOOLEAN-Ergebnissen; Bool-Expr korrigiert*fÅr Bool-Zuweisungen (kein IF/WHILE/UNTIL). 26.03.91: "0 - expr" wird nicht mehr zu "expr"; Kein int. Fehler mehr bei*Verw. von Std-Procs in Exprs. 08.04.91: Bei Word-Division wird Divisor nun bei $R+ extra auf Null geprÅft,*damit der Exc-Vektor nicht mehr verbogen werden braucht; Daten >*32KB auf dem A3-Stack werden korrekt runterkopiert; Wenn A7Hidden ist,*wird Ptr auf Proc-Adr bei Proc-Var trotzdem korrekt geholt; SHIFT/*ROTATE erlauben nun variable Weite, wenn das Set ein vollst. Byte/*Word/Long ist. 01.08.91: Nun auch Spaces hinter "." (Records) erlaubt. Allerdings ist nicht*sicher, ob der FetNoSp-Aufruf beim evtl. Nachladen das 1. Zeichen*verschwinden lassen kann. Daher dort eine Sicherheitsabfrage.*Kein Verif.Error mehr, wenn cutConst bei $D+ vorkommt (z.B. durch*"WriteString (VT52.Seq[VT52.wrapOn])". 09.08.91: Wenn FOR Reg-Vars benutzt, werden die vorigen Reg-Werte _immer_ LONG*gesichert, da evtl. ein MOVEQ das gesamte Reg zerstîrt. 15.09.91: CAST () lîscht unbenutzte Upper-Bytes & over-Flag (damit CARDINAL(-1)*DIV 2 $7FFF ergibt); Bei TC-Parm-öbergabe klappen nun mehrere ADDRESS-*Parms und Args fÅr Regs werden ggf. auf Ziel-Typ angepaût.*Record-Aggregate werden am Ende von Varianten besser aufgefÅllt,*letztes Feld einer Variante wird korrekt aufgefÅllt. 26.10.91: "const IN const" geht; Funcresults v. LONGREAL bei $D+ gehen. 17.11.91: sizedAt6 ignoriert nun Bit 8, dafÅr wird f. BTST nun genarSized (..-1)*statt genar aufgerufen - damit erzeugt nun genar (EOR.. den korrekten*Wert fÅr die Opsize: '/'-Operator bei SETs geht nun auch bei Sets*mit mehr als 1 Byte. 20.11.91: String-Consts an ARRAY OF CHAR werden nun immer Null-terminiert und*auch der High-Wert ist entsprechend um eins hîher (der Einfachheit*halber). 04.02.92: 'const': PushExpr (fact) vor checkCall(), sodaû es 1. klappen kînnte*und 2. kein bong mehr in funcCall/LookExpr kommt. 13.02.92: 'constOp': wenn Divisor >= 65536, klappts nun auch mit LONGINTs*(bisher wurde hier immer nur unsigned per SWAP geteilt). 09.03.92: kein Arithm. öberlauf mehr bei Indizierung mit LONGs auf Arrays mit*Feldgrîûe > 1 Byte. 30.05.93: Kein Stack-Check bei REF-Parms mehr. 13.12.93: Konstant-Argumente werden nur noch bis 8 (bisher 16) Byte direkt*statt Åber eine Referenz im RAM erzeugt.*Konstanten werdem im DATA-Puffer statt im Code abgelegt. 24.01.94: MaxLabels von 20 auf 50 erhîht (erlaubte bisher nur 20 OR-VerknÅp-*fungen, nun eben 50). 15.02.94: accessArray und stdFunction verbrauchen nun weniger Stack in*Rekursion.*Neue Label-Behandlung, die weniger Speicher auf dem Stack belegt.*Es sind nun 256 Sprungziele mîglich. 04.04.94: Keine internen AbstÅrze (Bus-/Addr-Error) bei CONSTs, die aus*zwei CONSTs zusammengesetzt werden, die einzeln < 16, zusammen > 16*Bytes sind (addToConstPar). 18.08.94: Korrektur bei neuer Label-Verwaltung, erzeugte teils Assert-Error*bei IF-AusdrÅcken, wo altes Lbl-Verfahren noch klappte. *)  (*!* Markierungen:!*  "!!!" fÅr dringende Korrekturen,!*  "~~~" fÅr mîgl. Optimierungen und Verbesserungen (z.B. Sicherheits-Checks)!*  "&&&" fÅr Erweiterungen, bzw. Lîsung von EinschrÑnkungen!*)  (*~~~ 'deallocExpr' einfÅhren:!*    sorgt z.B. fÅr das RÅcksetzen von 'ConstItem.itemNo', wie in!*    'addToConst' geschehen.!*)  (*~~~ adapt-Aufrufe durch fitValue mit erledigen! -> nur fitValue wird!*    fÅr assignments, usw, aufgerufen!*)  (*~~~!* Value Constructors mit Variablen werden erstmal immer auf dem Stack!* angelegt, egal, was danach mit ihnen geschieht.!* Da solche konstruierten Werte aber - bis auf Sets - nicht in Expressions!* vorkommen kînnen, kînnte man sie auch gleich in der Ziel-Var anlegen;!* dann spart man sich ggf. das Umkopieren vom Stack auf die Var.!* Damit das geht, mÅûte schon der Expression-Routine mitgeteilt werden,!* wohin der Wert am Ende geht: Auf den Stack als Parm oder in eine Var.!*!* Wenn man diese Information mit Åbergibt, kînnte daraufhin auch an vielen!* anderen Stellen eine Optimierung vorgenommen werden: Beispielsweise!* bei Expressions mit groûen Sets: Statt das Erg. auf den Stack zu laden,!* kînnte es gleich in die Ziel-Var. Allerdings muû hier erkannt werden,!* daû die Expr nicht weitergeht -- nee! braucht gar nicht! Denn schlieûlich!* ist es wohl egal, ob die Weiterrechnung mit den Sets dann auf dem Stack!* oder Åber die Var geht -- ist ja nur ein anderer Speicherbereich?!!* Oh! es kînnte doch schiefgehen: wenn ein Zw-Ergebnis schon in die Var kommt!* und dann mit dem eigentlichen alten Wert der Var noch weitergerechnet!* werden soll.!* Also: Es muû doch erkannt werden, daû die Expr zu ende ist. Das kînnte!* man sicher durch das PrÅfen des Folgezeichens erreichen: wenn es keins!* der mîgl. Operatoren ist, wÅrde die Expr-Routine ja dann auch Schluû machen.!*)  (*!* Reg-Var-Handhabung!* ------------------!*!*   Pro Modul- oder Procedure-Block wird zuerst 'freeRegs' auf alle!* Regs, bis auf A3 & A7 gesetzt. Bei Procs (Main.ProcDec) werden dann ggf.!* noch A5 & A6 rausgenommen. In 'varRegs' sind Åbrigens alle theoretischen!* Reg f. Vars definiert ({D3..D7,A3..A7,F3..F7}).!*!*   Werden dann Parameter oder Vars deklariert, die vor oder nach ihrem!* Bezeichner die Option "$Reg" haben, werden sie geprÅft, ob sie von!* ihrem Typ her als Reg-Var tauglich sind (Symbol.allocReg). Wenn ja, werden!* sie mit Expr.getRegVar alloziert. Ist kein Reg mehr frei, wird die!* Var normal Åber Memory angesprochen. Ist ein Reg frei, wird das Reg!* belegt und die Reg-Nr bei der Var-Beschreibung eingetragen (Symbol.VarDec!* & Main.SetPar).!*!*   Bei Code-Beginn werden dann die Regs fÅr die Vars nochmal freigegeben!* (In ProcDec & ModDec).!* Wird nun auf eine Reg-Var zugegriffen (designator), wird sie, wenn sie!* noch nicht im Reg liegt, dahin geladen, falls ihr Reg unbelegt ist.!* Belegt kann es dann sein, wenn durch FOR oder WITH eine temp. Reg-!* Var benîtigt wird: Dann wird, wenn kein Var-Reg mehr frei ist, eine!* Reg-Var wieder ins Memory gelegt und stattdessen nun fÅr die temp.!* Var benutzt. Am Ende von FOR/WITH wird dann das Reg. wieder als unbelegt!* gekennzeichnet, so daû beim nÑchsten Zugriff auf diese Reg-Var sie wieder!* ins Reg geladen werden kann.!*!*   Damit eine Reg-Var, die als Parameter Åbergeben wurde, beim ersten!* Zugriff und einer Wert-Ermittelung (also nicht Zuweisung darauf) erstmal!* ihr Wert vom Stack geladen wird, wÑhrend bei einer Zuweisung nicht erst!* ggf. der Wert geladen wird und bei Wert-Ermittelung einer lok. Var!* sogar erkannt werden kann, daû sie noch nicht init. wurde, wird!* bei Deklaration von Vars ein 'dirty'-Flag gesetzt. Das Flag wird erst!* bei einem Schreibzugriff auf die Var gelîscht. Wird auf eine 'dirty'!* Var. lesend zugegriffen, wird ein Fehler ausgelîst.!* >> Leider geht das doch nicht so einfach, daû bei Zuweisung auf eine!*   Reg-Var ggf. erst gar nicht der alte Wert geladen wird: denn bei einem!*   deref. Pointer muû dann erkannt werden, daû nicht auf den Pointer, sondern!*   auf den deref. Wert zugewiesen wird, weshalb natÅrlich der Pointer-Wert!*   geladen werden muû. Das geht aber z.Zt. noch gar nicht. Das ist ein!*   Ñhnliches Problem, wie mit Proc-Vars: Da sie auch nicht von vornherein!*   erkannt werden, ruft 'assignment' erstmal designator mit der Information!*   auf, es wÅrde eine Zuweisung erfolgen - erst hinterher stellt sich heraus,!*   daû ein Proc-Call, bei dem der Wert doch gelesen wird, stattfindet.!*!* Folgendes geht noch nicht:!*   Wird eine Var benutzt, wird die jeweils grîûte Proc-Tiefe, in der!* es benutzt wird, in der Var-Beschreibung vermerkt. Wird dann eine!* Proc aufgerufen, die LOKAL zur eigenen ist (Expr.call), wird geprÅft,!* welche der eigenen lok. Variablen z.Zt. in Regs liegen und von der!* aufzurufenden Proc oder einer tieferen Proc benutzt werden. Solche!* Vars werden dann in Memory zurÅckgespeichert, so daû sie erst beim!* nÑchsten Zugriff im eigenen Level wieder geladen werden.!* Es muû noch ausgearbeitet werden, wie mit dem 'dirty'-Flag bei lok.!* Procs zu verfahren ist: Es kann sowohl sein, daû in der lok. Proc!* die Var gelesen wird, jedoch korrekt in der umgebenden Proc der Wert!* vor dem lok. Proc-Aufruf init. wird, als es auch mîglich ist, daû!* der Wert in der lok. Proc init. wird, und die lok. Proc auch vor dem!* Zugriff in der Ñuûeren Proc aufgerufen wird. In beiden FÑllen darf es!* keinen Fehler wg. Zugriff auf uninit. Var geben.!*)  (*!* Real-Generierung!* ----------------!*!*   Es gibt drei Arten der Code-Erzeugung fÅr Reals:!* a) keine FPU vorhanden -> mit Pseudo-Regs in Runtime arbeiten; Runtime-!*   Routinen fÅr Real-Operationen (+, -, *, /, <, >, usw)!* b) externe FPU vorhanden -> Regs der FPU werden verwendet. Es werden!*   andere Runtime-Routinen verwendet, die bei monadischen Ops die!*   Reg-Nr erhalten, bei duadischen Ops eine Reg-Nr sowie die Adr. der!*   andern '<ea>' erhalten.!* c) interne FPU vorhanden -> nix Runtime-Aufrufe!*!*   Fall a) verlangt, daû meist alle temp. Regs gesichert werden mÅssen,!* weil die Routinen sehr aufwendig sind.!*!*   FÅr Fall b) brauchen ggf. nicht so viele Regs gesichert werden, auch!* kann man hier vielleicht den Op-Code fÅr bestimmte Gruppen von Operationen!* mit Åbergeben, anstatt f. jede Operation eine einzelne Routine zu haben.!* Allerdings muû hier bei duad. Ops auch jew. eine Routine vorgesehen werden!* fÅr den Fall, daû beide Werte schon im Reg stehen, denn dann kann keine!* Adr. sondern es muû eine Reg-Nr Åbergeben werden.!*!*   Das Verfahren von b), fÅr den zu verÑndernden Ziel-Operanden eine!* Reg-Nr anzugeben, kann auch fÅr a) verwendet werden, um dies einfacher!* handhaben zu kînnen. Allerdings wÑre es vom Zeitverhalten gÅnstiger,!* wenn die Adr. des Regs direkt Åbergeben wird, weil die hier ggf. direkt!* bestimmt werden kann, im Runtime mÅûte sie aus der Reg-Nr berechnet werden.!*!*   Allen FÑllen ist eins gemeinsam: bei duadischen Ops wird der rechte!* Wert in ein Reg geladen, deshalb wird dies vor der Fallunterscheidung!* vorgenommen.!*!*   WÑhrend bei a) die Vergleiche durch verschiedene Runtime-Routinen!* durchgefÅhrt werden, die dann jew. ein T/F-Flag liefern, wird bei!* b) und c) eine CMP-Instr. gen. und dann ein Bcc, wie bei nicht-Real-!* Vergleichen.!*!*   Werden die Pseudo-Regs im Runtime benutzt, werden 4-Byte-Reals!* linksbÅndig, also im Longword mit der kleineren Adr. abgelegt.!*!* Real-Formate!* ------------!*   Die Runtime-Routinen, die f. MM2-Reals benutzt werden, sind immer!* benutzbar, also auch fÅr 68881-Betrieb. Das Runtime muû allerdings!* fÅr die entsprechende Benutzung Åbersetzt sein. Der Vorteil liegt!* nun darin, daû es z.B. zwei Shells gibt: Eine mit MM2-Reals, eine!* mit IEEE-Reals. öbersetzte Module, die zwar Reals benutzen, dazu!* aber ausschlieûlich die MM2-Real-Routinen des Runtime aufrufen,!* laufen mit beiden Shells. Dies ist besonders beim Compiler von!* Vorteil. So brauchen nicht zwei Compiler f. jedes Format existieren.!* Nachteil ist nur, daû dann eben nicht die schnelleren IEEE-Zugriffe!* geschehen.!*   Werden Real-Konstanten abgelegt, ist allerdings das Format sofort!* festgeschrieben. Deshalb dÅrfen hier im Compiler keine Real-Konstanten!* vorkommen, sondern sie mÅssen ggf. von integer-Werten umgewandelt werden.!*   Das fÅhrt zu folgenden Kombinationen:!* - Wird eine Real-Konst. verwendet, ist das Format sofort festgelegt und!*   wird im Modulheader festgehalten.!* - Werden Runtime-Aufrufe fÅr die externe FPU getÑtigt, ist das Format!*   ebenfalls festgelegt.!* - Werden keine Real-Konst. benutzt und nur Runtime-Aufrufe der MM2-Reals!*   gemacht, bleibt das Real-Format frei. Das heiût: Wird ein Modul mit!*   $F- Åbersetzt, kann es formatfrei bleiben, so wie der Compiler.!*)  (*!* Wichtige Hinweise:!* - Zwischenergebnisse dÅrfen nicht auf den A7-Stack, sondern mÅssen dann!*   immer auf den A3-Stack geladen werden. WÅrde ein Wert auf den A7 kommen,!*   kînnte ein vorher auf den A7 gespillter Pointer, z.B. fÅr die Ziel-Adr,!*   nicht mehr direkt runtergeladen werden, um dann den Ergebniswert vom!*   Stack zu laden.!*)  FROM SYSTEM IMPORT"CompilerVersion, ASSEMBLER, ADDRESS, ADR, TSIZE, BYTE, WORD, LONGWORD;  FROM MM2Comp IMPORT"SBothTyp, ZZTyp, BothTyp, CardPtr, SCardPtr, IntPtr, SIntPtr,$SSTyp, BytIPtr, UndefTyp, CardRel, IntRel, BSetPtr, RealPtr, SRealPtr,$BoolPtr, StrPtr, CharPtr,"SerVal0, SerVal1, SerLead0, SerLead1, SerCnt1, SerOffset1,"DataPtr, DataEnd, Accu, AccuPtr, AccuSize,"NumConst, StrConst, SymNot, SymAnd, SymOr,"StackReserve, Options, Tiefe, CodeStart, Header, EvalStk, Peephole,"ConFact, CSP, compatRR, compat, PushInt, PullInt, SyntaxErr, GetSbl,"LocalSearch, Global, fpu, RealConstIsUsed, IEEERuntimeCall, FPUType,"TreSpc, TreSrc, StatSeq, BadId, ROScope, StrLen, STRBUF, TextOffset,"AsmMode, WithScope, VarReg, A3Offset, A7Offset, HaltOnError, FetNoSp,"StatLinkOffs, AsComp20;  IMPORT SysUtil0, Block;  IMPORT GEMScan,"BIOS, SysCtrl, SysTypes, HdlError, ErrBase, MOSGlobals, SysBuffers;  FROM Strings IMPORT Assign, Append, String; FROM StrConv IMPORT StrToReal, CardToStr, LHexToStr; FROM Convert IMPORT ConvCard; FROM RealCtrl IMPORT AnyReal, UsedFormat, AnyRealFormat, Conv, SmallREAL,(RealFormat, LargeREAL, SmallLONGREAL, LargeLONGREAL; FROM SFP004 IMPORT FPUError;   CONST Safety = FALSE;   (* TRUE: alle mîglichen asserts kodieren *)&Safety2 = TRUE;   (* f. kritische asserts (z.B. Codegen)   *)&Test = FALSE;     (* dann geht 'showExpr' usw./ InOut importieren! *)  (*$? Safety: (*$R+*) *) &InternalVersion = 'V#3592'; &constBufSize = 8; (* Wenn Const grîûer, wird sie im DATA-Buf abgelegt *) &CompileWithNewCompiler = (CompilerVersion > 3);  CONST CompileWithOldCompiler = NOT CompileWithNewCompiler;  (* nur zur Verifikation, daû richtiger Modus gewÑhlt ist: *) (*$? CompileWithOldCompiler:"PROCEDURE testProc;"VAR testStr1: ARRAY [0..2] OF CHAR; testStr2: ARRAY [0..5] OF CHAR;"BEGIN testStr2:= testStr1 END testProc; *) (*$? CompileWithNewCompiler:"CONST testChar = CHR (0); *)  TYPE"PtrItem = ADDRESS;  CONST"anyFloatReg = RegSet {F0..F7};"anyCPUReg = anyDataReg + anyAddrReg;  (*$I CompErr.ICL *)  MODULE MM2Comp3; "(*$FROM InOut (*!!!*) IMPORT WriteCard, WriteString, WritePg, WriteLn, Write, Read;"*)"FROM GEMScan IMPORT ChainDepth, CallingChain, InputScan, InitChain;"FROM SysCtrl IMPORT GetScanAddr, ScanBack;  FROM SysTypes IMPORT ScanDesc, ExcDesc; FROM HdlError IMPORT CatchErrors, GetErrorMsg; FROM ErrBase IMPORT ErrResp, RtnCond;  FROM MOSGlobals IMPORT DivByZero, OutOfRange, Overflow, HALTInstr, MemArea; FROM SysBuffers IMPORT HdlErrorStack;  IMPORT ASSEMBLER, ADR, TSIZE, CompilerVersion, BYTE, WORD, LONGWORD, ADDRESS; IMPORT String, Append, StrToReal, CardToStr, PtrItem;  (* FROM MM2Comp *) IMPORT"ZZTyp, SBothTyp, BothTyp, CardPtr, SCardPtr, IntPtr, SIntPtr,$CardRel, IntRel, BoolPtr, StrPtr, RealPtr, CharPtr,"DataPtr, DataEnd, NumConst, StrConst, SymNot, SymAnd, SymOr,"BadId, Options, Tiefe, CodeStart, Header, EvalStk, Peephole, FetNoSp,"ConFact, CSP, compatRR, compat, LocalSearch, PushInt, SyntaxErr, GetSbl,"TreSpc, TreSrc, StatSeq, TextOffset, StrLen, STRBUF, HaltOnError, AsComp20;  (* FROM outer *) IMPORT SuppressCode, InternalVersion, RegType, RelocCount,4Assign;  EXPORT"OptimizedCompile, MaxStringConst, StringTerminator, DebugTrapNo, ErrorTrapNo,"DivByZeroTrap, StackOverflowTrap, OverflowTrap, RangeTrap, DisplayTrap,"bong, assert, entryC, entryL,"FoldingConst, varParm, refParm, scalar, refVar, rtnD0, rtnTC, global, typeDesc,"indirVar, extVar, parmA7, imported, exported, userDef, ByteSet, IFS,"Symbol, TextPointer, TreeBase, CurrentSymbol, SyntaxError, CodeSpace,"OpenScope, CloseScope, CodePtr, SetCodePtr, GetTextPtr, SetTextPtr, Entry,"Exit, GetSymbol, TreeSearch, StatementSequence, ConstantFactor, DataSpace,"SearchLocalItem, CallRuntimeProc, AsnComp, ExprComp, VarComp, PutCode, plus,"minus, becomes, lparen, rparen, lbrack, rbrack, lbrace, rbrace, tilde, dot,"arrow, comma, endSym, doSym, toSym, bySym, asterisk, strConc, dblpoint,"ParmRegNo, ParmToReg, SetVarLink, LastVarLink, SetProcLink, PutData,"LastProcLink, VarAddress, IndexType, ParmType, FirstParm, NextParm,"LocalTree, RefType, ElementType, BaseType, SetBaseType, OpenArrayType,"VarParm, NoOfElems, LowBound, HighBound, ItemNo, ItemFlag, SetItemFlag,"ParmFlag, IsRegVar, MakeRegVar, MakeMemVar, IsInReg, IsInMem, UsedReg,"SetReg, UseReg, UseMem, IsDirty, ClearDirt, SetDirt, SetAccessDepth,"NewAccessDepth, AccessDepth, TypeLength, AnyTypeLength, SetTypeLength,"BooleanType, StrConstType, ByteType, CharType, StdProcNo, StdProcParms,"StdParmType, NextStdParm, StdParmRes, HostType, FirstRecField, NextRecField,"SetTableLink, LastTableLink, SetConstLink, LastConstLink, NextTagField, TagFieldList,"SignalOverflow, HasOverflown;   (*$I COMPERR.ICL *)  CONST  OptimizedCompile = CompilerVersion > 3;  (*$? NOT OptimizedCompile: Arghhh! Das geht nicht! Zuerst 'Ret6L' usw anpassen*)""MaxStringConst = 256; (* Max. LÑnge einer String-Konstante *)"StringTerminator = 0C;""DebugTrapNo = 5;      (* kînnte durch Var. ersetzt werden~~~ *)"ErrorTrapNo = 6;           (* kînnte durch Var. ersetzt werden~~~ *)"StackOverflowTrap = $FFF6;"OverflowTrap = $FFF9;"RangeTrap    = $FFFA;"DisplayTrap  = $FFE7;"DivByZeroTrap= $FFFB;   VAR FoldingConst: BOOLEAN;"(* Diese Var setzt M2Expr.constantFold temporÑr auf TRUE *) $SignalOverflow: BOOLEAN;$HasOverflown: BOOLEAN;  (* ----------------------------------------------------------------------- *)  CONST "varParm  = 0;       (* Bei Parameter-Beschreibungen von Prozeduren *)"refParm  = 1;       (* Bei Parameter-Beschreibungen von Prozeduren *)""scalar   = 0;"refVar   = 0;       (* Read Only; nur bei gÅltig, wenn nicht 'typeDesc' *)"rtnD0    = 0;       (* Function-Return via D0 statt (A3) *)"rtnTC    = 0;       (* Function-Return a la TC (nur, wenn Bit 3 gesetzt) *)"global   = 1;"typeDesc = 2;"indirVar = 3;       (* VAR-Parameter bei lokalen Variablen,     *7* auch IMMER gesetzt bei Open Array-Parms! *)"parmA7   = 3;       (* Bei Procs: Parameter auf A7 oder in Regs Åbergeben *)"extVar   = 4;"imported = 5;"exported = 6;"userDef  = 7;  TYPE "ByteSet = SET OF [0..7]; "IFS = SET OF [0..7]; "Symbol = RECORD-CASE : BOOLEAN OF/TRUE:  flags: IFS; typ: BYTE|/FALSE: itemNo: CARDINAL-END;-item: PtrItem;+END; "TextPointer = RECORD2ptr: ADDRESS;2ofs: LONGCARD0END;  VAR"TreeBase: ADDRESS;"CurrentSymbol: Symbol;  (* ----------------------------------------------------------------------- *)  (*!* Auswertung der Symbole & Tree-Daten!*)  CONST"plus   = 2;"minus  = 3;"becomes= 6;"lparen = 14;"rparen = 26;"lbrack = 15;"rbrack = 27;"lbrace = 16;"rbrace = 28;"tilde  = 12;"dot    = 9;"arrow  = 17;"comma  = 10;"endSym = 35;   (* END *)"doSym  = 40;   (* DO *)"toSym  = 43;   (* TO *)"bySym  = 44;   (* BY *)"asterisk = 4;"strConc  = plus; (* '+': Verkettungs-Zeichen f. String-Consts *)"dblpoint = 8;  (* .. *)   (*$Z-*) (*$? OptimizedCompile: (*$Z+*) *)  VAR globalScan: ScanDesc;$errorMsg: ARRAY [0..31] OF CHAR;  PROCEDURE scanPrep (depth: CARDINAL);"BEGIN$IF depth # 0 THEN&GetScanAddr (globalScan);&WHILE depth > 0 DO(DEC (depth);(IF ScanBack (globalScan) THEN END;&END$END;$InitChain (globalScan);"END scanPrep;  PROCEDURE scanner;"VAR c: CARDINAL;"BEGIN$c:= 0;$InputScan (errorMsg, c)"END scanner; "(*#* Schnittstelle zu externen Routinen#*) "VAR regs: ARRAY [0..11] OF LONGWORD;"CONST A1 = 6; A2 = 7; rA4 = 9; A6 = 11; "VAR n: CARDINAL;&ok: BOOLEAN;  PROCEDURE GetKBShift (): BITSET;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    #-1,-(A7)(MOVE    #11,-(A7)(TRAP    #13(ADDQ.L  #4,A7((*$? NOT OptimizedCompile:(MOVE.W  D0,(A3)+(*)$END"END GetKBShift;"(*$L=*)  PROCEDURE SyntaxError (n: INTEGER);"(*$L-*)"BEGIN$ASSEMBLER(; damit Scanning mîglich ist:(LINK    A5,#0$END;$scanPrep (2);$ASSEMBLER(UNLK    A5$END;$ASSEMBLER&TST     HaltOnError&BEQ.W   noHalt$END;$errorMsg:= ' Syntax-Fehler! ';$scanner;$IF 2 IN GetKBShift () THEN&(* ignore error *)&ASSEMBLER(BRA     ende&END;$END;$ASSEMBLER$noHalt&MOVE.W  -(A3),D0&MOVE.L  A3,EvalStk&MOVEM.L regs,D1/D4-D7/A0-A6&MOVE    D0,D5&JMP     SyntaxErr$ende&SUBQ.L  #2,A3$END"END SyntaxError;"(*$L=*)  PROCEDURE appendScanDesc;"VAR i: INTEGER;"BEGIN$IF BadId[0] # 0C THEN&Append (' >', BadId,ok);$END;$Append (InternalVersion + ":", BadId,ok);$FOR i:= 0 TO 3 DO&WITH CallingChain[i] DO(IF (ChainDepth >= i) & (modName[0] # 0C) THEN*IF i # 0 THEN Append (",", BadId, ok) END;*Append (CardToStr (relAddr, 0), BadId, ok);(END&END$END;"END appendScanDesc;  PROCEDURE bong ();"(* diese Routine ist nur fÅr interne verifikationen gedacht, nicht fÅr#* syntax-fehlermeldungen! *)"BEGIN$scanPrep (2);$IF HaltOnError THEN&errorMsg:= ' Interner Fehler! ';&scanner;&IF 2 IN GetKBShift () THEN (* ignore error *) RETURN END;&HaltOnError:= FALSE;$ELSE&appendScanDesc;$END;$SyntaxError (rIntEr)"END bong;  PROCEDURE assert (ok: BOOLEAN);"(*$L-*)"BEGIN$ASSEMBLER(TST.W   -(A3)(BNE     ok0(JMP     bong&ok0$END"END assert;"(*$L=*)   (*$L-*) PROCEDURE compat4 (); BEGIN ASSEMBLER)CMP.L   ZZTyp,D0)BEQ     compatzz       ; ZZ ist zu allen Ordinalen kompat.)CMP.L   BothTyp,D0)BEQ     compat1)CMP.L   SBothTyp,D0)BEQ     compat7)CMP.L   CardPtr,D0)BEQ     compat5)CMPI.B  #20,-1(A1,D0.L) ;POINTER?)BEQ     compat5       ; ist kompat. mit Adr)BRA     compat2 compat7  CMP.L   SIntPtr,D2)BEQ     compat2)CMP.L   SCardPtr,D2)BEQ     compat2)CMPI.B  #41,-1(A1,D2.L)        ;Bitnum?)RTS compatzz CMP.L   SIntPtr,D2)BEQ     compat2)CMP.L   SCardPtr,D2)BEQ     compat2)CMPI.B  #41,-1(A1,D2.L)        ;Bitnum?)BEQ     compat2 compat1  CMP.L   CardPtr,D2)BEQ     compat2)CMP.L   IntPtr,D2)BEQ     compat2 compat5  CMPI.B  #23,-1(A1,D2.L)        ;Address? compat2 END END compat4;  (*!*   Pruefen, ob zwei Typen Assignment-kompatibel sind.!*    (D2 = Source, D0 = Destination)!*!*   Ergebnis in D1!*)  (*$L-*) PROCEDURE asComp; BEGIN ASSEMBLER)CMP.L   D0,D2)BEQ.L   isCompat         ;gleiche Typen  ->)CMPI.B  #11,-1(A1,D2.L) ;Source Subr ?)BNE     AsComp12)MOVE.L  -18(A1,D2.L),D2 ;ja: durch Basetype ersetzen AsComp12 MOVE.W  -2(A1,D0.L),D1  ;Dest-Kennung )CMPI.B  #44,D1          ;local Proc Type?)BEQ     NOTAC22         ; dann passen alle Proc-Types/Procs)CMPI.B  #19,D1          ;Proc Type?)BNE     NOTAC20         ; nein, dann weiter mit scalaren...))MOVE.W  -2(A1,D2.L),D1  ;Source-Kennung)CMPI.B  #44,D1          ;local Proc type?)BEQ     NOTAC21         ; dann erstmal OK, Check zur Runtime)CMPI.B  #6,D1           ;Procedure?)BNE.W   noCompat        ;nein -> nicht compatibel)BTST    #9,D1           ; nur globale Procs erlaubt)BEQ.W   noGlobls !NOTAC21 JMP     AsComp20 !NOTAC22 MOVE.L  -10(A1,D0.L),D0 ;bei lok.Proctypes ^19er-Kennung laden)JMP     AsComp20  noGlobls MOVE    #rBdPro,D1)RTS  !NOTAC20 CMPI.B  #11,D1)BEQ     isSub)CMPI.B  #12,D1          ;Dest Array ... of Char ?)BNE.L   asComp1         ;leider nicht: nicht kompatibel)MOVE.L  -14(A1,D0.L),D1 ;Elementtyp holen)CMP.L   CharPtr,D1      ;sollte CHAR sein)BEQ.L   AsComp10        ;behandeln wie String)BRA.L   asComp1         ;bleibt nur Int/Card-Kompat.  ;   Destination ist Subrange  isSub    MOVE.L  -18(A1,D0.L),D0 ;BaseTyp)BRA     asComp1       ;kompatibel?)); Assignment-kompatible Typen:); Aufbau: Source-Kennung, Dest-Kennung) AsTab    ; LONGINT:=)DC.B    22,  1)DC.B    30,  1)DC.B    33,  1)DC.B    34,  1)DC.B    35,  1)DC.B    41,  1); LongBoth:=)DC.B     1, 30)DC.B    22, 30)DC.B    33, 30)DC.B    34, 30)DC.B    35, 30)DC.B    41, 30); LONGCARD:=)DC.B     1, 22)DC.B    30, 22)DC.B    33, 22)DC.B    34, 22)DC.B    35, 22)DC.B    41, 22); INTEGER:=)DC.B    34, 33)DC.B    35, 33)DC.B    41, 33); CARDINAL:=)DC.B    33, 34)DC.B    35, 34)DC.B    41, 34); ShortBoth:=)DC.B    33, 35)DC.B    34, 35)DC.B    41, 35); ADDRESS:=)DC.B    33, 23         ; address := shortint)DC.B    34, 23         ; address := shortcard)DC.B    35, 23         ; address := shortboth); BITNUM:=)DC.B    33, 41         ; BITNUM:= shortint)DC.B    34, 41         ; BITNUM:= shortcard)DC.B    35, 41         ; BITNUM:= shortboth); REALs)DC.B     2, 40)DC.B    40,  2))DC.W     0) AsTab2   ; Diese Tabelle erlaubt auch LONG-Types auf SHORT-Types); INTEGER:=)DC.B     1, 33)DC.B    30, 33)DC.B    22, 33); CARDINAL:=)DC.B     1, 34)DC.B    30, 34)DC.B    22, 34); ShortBoth:=)DC.B     1, 35)DC.B    30, 35)DC.B    22, 35); BITNUM:=)DC.B     1, 41         ; BITNUM:= shortint)DC.B    30, 41         ; BITNUM:= shortcard)DC.B    22, 41         ; BITNUM:= shortboth))DC.W     0)); Kompatibilitaet Int/Card pruefen mit Subrange-Check,); Kompatibilitaet LongInt/Int, LongCard/Card  !asComp1 CMP.L   D0,D2)BEQ.L   isCompat       ;DIREKT GLEICH)JSR     compat4)BEQ.L   isCompat)EXG     D0,D2)JSR     compat4)EXG     D0,D2)BEQ.L   isCompat))MOVE.L  Options,D1)BTST    #11,D1         ;$K+ ?)BEQ     noLongs))LEA     AsTab2(PC),A0)BSR     checkTab)BEQ     isCompat) noLongs  LEA     AsTab(PC),A0)BRA     checkTab) search   ADDQ.L  #1,A0 checkTab MOVE.B  (A0)+,D1)BEQ.L   noCompat)CMP.B   -1(A1,D2.L),D1)BNE     search         ;Sourcetyp falsch)MOVE.B  (A0),D1)CMP.B   -1(A1,D0.L),D1)BNE     search         ;Desttyp falsch)); Types sind kompatibel) isCompat CLR.W   D1)RTS  noCompat MOVEQ   #-1,D1)RTS  ;   Destination ist ARRAY OF CHAR  AsComp10  CMPI.B  #27,-1(A1,D2.L) ;Source String-Const ?*BEQ     AsString3*CMPI.B  #12,-1(A1,D2.L) ;Source Array ... of Char ?*BNE     noCompat        ;leider nicht: nicht kompatibel*MOVE.L  -14(A1,D2.L),D1 ;Elementtyp holen*CMP.L   CharPtr,D1      ;sollte CHAR sein*BNE     noCompat        ;keine weiteren Moeglichkeiten*MOVE.L  -6(A1,D0.L),D1  ;Dest-LÑnge holen*CMP.L   -6(A1,D2.L),D1  ;Source-LÑnge abziehen*BEQ     isCompat*BRA     noCompat AsString3 MOVE.L  -6(A1,D0.L),D1  ;Dest-LÑnge holen*CMP.L   -6(A1,D2.L),D1  ;Source-LÑnge abziehen*BCC     isCompat        ;bei Stringconst darf Source auch kleiner sein*MOVE    #rSCoOv,D1$END"END asComp;  (*!*   ALS VARPAR KOMPATIBLE TYPEN (KENNUNGEN):!*)  (*$L-*) PROCEDURE VCTAB; BEGIN ASSEMBLER)DC.B    35,33         ;SBOTH/SINT)DC.B    35,34         ;SBOTH/SCARD)DC.B     4,1          ;ZZ/INT)DC.B     4,22         ;ZZ/CARD)DC.B     4,23         ;ZZ/ADR)DC.B    30,1          ;BOTH/INT)DC.B    30,22         ;BOTH/CARD)DC.B    30,23         ;BOTH/ADR)DC.B    23,22         ;ADR/CARD)DC.B    22,23         ;CARD/ADR)DC.B    20,23         ;PTR/ADR)DC.B    23,20         ;ADR/PTR)DC.B    0)SYNC END END VCTAB;   (*$L-*) PROCEDURE varComp; BEGIN ASSEMBLER vc7       CMP.L   D0,D2*BEQ.L   VarComp5*MOVE.B  -1(A1,D0.L),D1 ;DEST KNG*BNE     VarComp9*MOVE.L  -6(A1,D0.L),D0 ; INZW. NACHDEKLARIERTER OPAQUE*BRA     vc7 VarComp9  CMPI.B  #27,D1        ;DEST String?*BEQ     VarComp6*CMPI.B  #19,D1        ;PROC.TYPE?*BNE     notAC20*; Daû keine Procs (Kennung 6) als Arg. gehen, wird schon vorher durch*;  designator-Aufruf bei VAR-Parms geregelt*JMP     AsComp20 notAC20 (* Das lÑût PIM3 nicht mehr zu:*CMPI.B  #11,-1(A1,D2.L) ;SOURCE SUBR?*BNE     VarComp4*MOVE.L  -18(A1,D2.L),D2*BRA     vc7 *) VarComp4  MOVEM.L D0/D1/D2,-(A7)*MOVE.B  -1(A1,D0.L),D0        ;Dest Kennung*MOVE.B  -1(A1,D2.L),D2        ;Source Kennung*CMPI.B  #21,D0                ;Word ?*BEQ     VarComp8*CMPI.B  #38,D0                ;Byte ?*BEQ     VarComp8*CMPI.B  #26,D0                ;Long ?*BEQ     VarComp8*LEA     VCTAB,A0 VarComp2  MOVE.B  (A0)+,D1*BEQ     VarComp1b     ;ENDMARKE*CMP.B   (A0)+,D0*BNE     VarComp2*CMP.B   D1,D2*BNE     VarComp2*MOVEM.L (A7)+,D0/D1/D2*RTS  VarComp1b MOVEM.L (A7)+,D0/D1/D2 VarComp1  ANDI    #$00,CCR    ;CLEAR ZERO FLAG*RTS VarComp8  MOVEM.L (A7)+,D0/D1/D2*BRA     VarComp3        ;Laengenvergleich  VarComp6  CMPI.B  #27,-1(A1,D2.L) ;Dest ist String - Source auch ?*BNE     VarComp5 VarComp3  MOVE.L  -6(A1,D2.L),D1  ;Laenge muss uebereinstimmen!*CMP.L   -6(A1,D0.L),D1 VarComp5)END END varComp;   (*$L+*) ""PROCEDURE CodeSpace;$BEGIN&(*$R-*)&IF LONGCARD (regs [A1]) + LONGCARD (TreSpc) - LONGCARD (regs [rA4]) < $400L THEN(SyntaxError (rSpace)&END&(*$R=*)$END CodeSpace;""PROCEDURE DataSpace;$BEGIN&IF DataPtr > DataEnd THEN(SyntaxError (rDaSpc)&END$END DataSpace; "PROCEDURE OpenScope (t: PtrItem);$VAR (*$Reg*)p: POINTER TO PtrItem;$BEGIN&(* MOVE.L  t,-(A6) *)&DEC (regs [A6], 4);&p:= ADDRESS (regs [A6]);&p^:= t$END OpenScope; "PROCEDURE CloseScope ();$BEGIN&(* ADDQ.L  #4,A6 *)&INC (regs [A6], 4)$END CloseScope; "PROCEDURE CodePtr (): ADDRESS;$BEGIN&RETURN ADDRESS (regs [rA4])$END CodePtr; "PROCEDURE SetCodePtr (p: ADDRESS);$BEGIN&assert ((p # NIL) & NOT ODD (p));&regs [rA4]:= LONGWORD (p)$END SetCodePtr; "PROCEDURE GetTextPtr (VAR p: TextPointer);$BEGIN&p.ptr:= ADDRESS (regs [A2]);&p.ofs:= TextOffset$END GetTextPtr; "PROCEDURE SetTextPtr (p: TextPointer);$VAR l: LONGCARD;$BEGIN&(*'* Vorsicht'* Das Setzen funktioniert nicht im 'singleLine'-Mode, also beim'* Compile im GME, weil dann die Zeile sicher lÑngst nicht mehr'* vorhanden ist.'*)&SyntaxError (rNImpY);&(*&assert (p.ptr # NIL);&IF p.ofs # TextOffset THEN SyntaxError (rTxtLg) END;&regs [A2]:= LONGWORD (p.ptr)&*)$END SetTextPtr; "PROCEDURE Entry;$(* Einsprung, bei dem D2/D3 nicht mehr relevant sind *)$(*$L-*)$BEGIN&ASSEMBLER(MOVE.L  A1,TreeBase(MOVEM.L D1/D4-D7/A0-A6,regs(LEA     CurrentSymbol,A0(MOVE    D3,Symbol.itemNo(A0)(MOVE.L  D2,Symbol.item(A0)(MOVE.L  EvalStk,A3&END$END Entry;$(*$L=*) "PROCEDURE Exit;$(* Aussprung, bei dem D2/D3 von CurrentSymbol zurÅckgegeben werden *)$(*$L-*)$BEGIN&ASSEMBLER(LEA     CurrentSymbol,A0(MOVE    Symbol.itemNo(A0),D3(MOVE.L  Symbol.item(A0),D2(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0-A6&END$END Exit;$(*$L=*)""PROCEDURE GetSymbol0 (VAR s: Symbol);$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0-A6(JSR     GetSbl(MOVEM.L D1/D4-D7/A0-A6,regs(MOVE.L  EvalStk,A3(MOVE.L  -(A3),A0(MOVE    D3,Symbol.itemNo(A0)(MOVE.L  D2,Symbol.item(A0)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END GetSymbol0;$(*$L=*) "PROCEDURE GetSymbol ();$(*$L-*)$BEGIN&ASSEMBLER(MOVE.L  #CurrentSymbol,(A3)+(JMP     GetSymbol0&END$END GetSymbol;$(*$L=*) "PROCEDURE TreeSearch (text: ADDRESS);$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -(A3),D0(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(MOVE.L  A2,-(A7)(MOVE.L  D0,A2(MOVE.B  (A2),D2(JSR     TreSrc(MOVE.L  (A7)+,A2(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(LEA     CurrentSymbol,A0(MOVE    D3,Symbol.itemNo(A0)(MOVE.L  D2,Symbol.item(A0)(MOVE.L  EvalStk,A3(MOVEM.L (A7)+,D3-D7/A4-A6&END$END TreeSearch;$(*$L=*) "PROCEDURE StatementSequence;$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     StatSeq(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(LEA     CurrentSymbol,A0(MOVE    D3,Symbol.itemNo(A0)(MOVE.L  D2,Symbol.item(A0)(MOVE.L  EvalStk,A3(MOVEM.L (A7)+,D3-D7/A4-A6&END$END StatementSequence;$(*$L=*) "PROCEDURE ConstantFactor (): BOOLEAN;$(* IN/OUT: CurrentSymbol! *)$(* RETURN FALSE: Fehler in Faktor?! *)$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0-A6(LEA     CurrentSymbol,A0(MOVE    Symbol.itemNo(A0),D3(MOVE.L  Symbol.item(A0),D2(JSR     ConFact(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(SCC     D0(MOVE.L  EvalStk,A3(LEA     CurrentSymbol,A0(MOVE    D3,Symbol.itemNo(A0)(MOVE.L  D2,Symbol.item(A0)(ANDI    #1,D0 (*$? NOT OptimizedCompile:(MOVE    D0,(A3)+ *)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END ConstantFactor;$(*$L=*) "PROCEDURE SearchLocalItem (VAR tree: PtrItem): BOOLEAN;$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -4(A3),A0(MOVE.L  (A0),D2(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(MOVE.L  D2,-(A7)(JSR     FetNoSp(MOVE.B  D2,D1(MOVE.L  (A7)+,D2(CMP.B   -(A2),D1(BEQ     ok0(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(MOVE.L  EvalStk,A3(MOVE    #rFetch,(A3)+(JMP     SyntaxError#ok0: JSR     LocalSearch(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(SCC     D0(ANDI    #1,D0(MOVE.L  EvalStk,A3(MOVE.L  -(A3),A0(MOVE.L  D2,(A0)((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END SearchLocalItem;$(*$L=*)  (*"PROCEDURE ConstantSet (type: PtrItem);$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -(A3),D2(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     ConSet(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(MOVE.L  EvalStk,A3(MOVEM.L (A7)+,D3-D7/A4-A6&END$END ConstantSet;$(*$L=*) *) "PROCEDURE CallRuntimeProc (n: CARDINAL);$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.W  -(A3),D3(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     CSP(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(MOVE.L  EvalStk,A3(MOVEM.L (A7)+,D3-D7/A4-A6(ADDQ.L  #1,RelocCount&END$END CallRuntimeProc;$(*$L=*) "PROCEDURE AsnComp (left, right: PtrItem): INTEGER;$(* RETURN: 0: OK, >0: errorCode, <0: not compat *)$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -(A3),D2        ; right(MOVE.L  -(A3),D0        ; left(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     asComp(MOVE    D1,D0(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(MOVE.L  EvalStk,A3((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END AsnComp;$(*$L=*) "PROCEDURE ExprComp (VAR type: PtrItem; left, right: PtrItem): BOOLEAN;$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -(A3),D2        ; right(MOVE.L  -(A3),D0        ; left(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     compatRR(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(SEQ     D0(ANDI    #1,D0(MOVE.L  EvalStk,A3(MOVE.L  -(A3),A0(MOVE.L  D2,(A0)((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END ExprComp;$(*$L=*) "PROCEDURE VarComp (left, right: PtrItem): BOOLEAN;$(*$L-*)$BEGIN&ASSEMBLER(MOVEM.L D3-D7/A4-A6,-(A7)(MOVE.L  -(A3),D2        ; right(MOVE.L  -(A3),D0        ; left(MOVE.L  A3,EvalStk(MOVEM.L regs,D1/D4-D7/A0/A1/A2/A3/A4-A6(JSR     varComp(MOVEM.L D1/D4-D7/A0/A1/A2/A3/A4-A6,regs(SEQ     D0(ANDI    #1,D0(MOVE.L  EvalStk,A3((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)(MOVEM.L (A7)+,D3-D7/A4-A6&END$END VarComp;$(*$L=*) "PROCEDURE PutCode (d: ARRAY OF WORD);$(*$L-*)$BEGIN&ASSEMBLER(LEA     regs,A1(MOVE.L  rA4*4(A1),A2(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(&luup((*(CMPI    #$485F,(A0)(BNE     ok0(LINK    A5,#0(JSR     HALT(UNLK    A5(BREAK&ok0(*)(MOVE.W  (A0)+,(A2)+(DBRA    D0,luup(MOVE.L  A2,rA4*4(A1)&END$END PutCode;$(*$L=*) "PROCEDURE PutData (d: ARRAY OF WORD);$(*$L-*)$BEGIN&ASSEMBLER(MOVE.L  DataPtr,A2(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0&luup(MOVE.W  (A0)+,(A2)+(DBRA    D0,luup(MOVE.L  A2,DataPtr&END$END PutData;$(*$L=*)  (* ----------------------------------------------------------------------- *) "(*#* Auswertung der Symbole & Tree-Daten#*)  "PROCEDURE enterL (p: ADDRESS; offset: INTEGER; v: LONGWORD);$(*$L-*)$BEGIN&ASSEMBLER(MOVE.L  -(A3),D1(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D1,0(A0,D0.W)&END$END enterL;$(*$L=*) "PROCEDURE enterB (p: ADDRESS; offset: INTEGER; v: BYTE);$(*$L-*)$BEGIN&ASSEMBLER(SUBQ.L  #1,A3(MOVE.B  -(A3),D1(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  D1,0(A0,D0.W)&END$END enterB;$(*$L=*) "PROCEDURE entryL (p: ADDRESS; offset: INTEGER): LONGINT;$(*$L-*)$BEGIN&ASSEMBLER(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0((*$? NOT OptimizedCompile:(MOVE.L  0(A0,D0.W),(A3)+(*)((*$? OptimizedCompile:(MOVE.L  0(A0,D0.W),D0(*)&END$END entryL;$(*$L=*) "PROCEDURE entryI (p: ADDRESS; offset: INTEGER): INTEGER;$(*$L-*)$BEGIN&ASSEMBLER(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0((*$? NOT OptimizedCompile:(MOVE.W  0(A0,D0.W),(A3)+(*)((*$? OptimizedCompile:(MOVE.W  0(A0,D0.W),D0(*)&END$END entryI;$(*$L=*) "PROCEDURE entryC (p: ADDRESS; offset: INTEGER): CARDINAL;$(*$L-*)$BEGIN&ASSEMBLER(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0((*$? NOT OptimizedCompile:(MOVE.W  0(A0,D0.W),(A3)+(*)((*$? OptimizedCompile:(MOVE.W  0(A0,D0.W),D0(*)&END$END entryC;$(*$L=*) "PROCEDURE entryB (p: ADDRESS; offset: INTEGER): BYTE;$(*$L-*)$BEGIN&ASSEMBLER(MOVE.W  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0((*$? NOT OptimizedCompile:(MOVE.B  0(A0,D0.W),(A3)+(CLR.B   (A3)+(*)((*$? OptimizedCompile:(MOVE.B  0(A0,D0.W),D0(*)&END$END entryB;$(*$L=*)  "(*#* Reg-Var-Verwaltung#*) "TYPE VarInfo = (dum0, dum1, dum2, dum3, dum4, dirty, inReg, regVar);'VarSet = SET OF VarInfo;"CONST RegSet = VarSet {dum0..dum4}; "PROCEDURE IsRegVar (item: PtrItem): BOOLEAN;$BEGIN&RETURN regVar IN VarSet (entryB (item, -15))$END IsRegVar; "PROCEDURE IsInReg (item: PtrItem): BOOLEAN;$BEGIN&RETURN inReg IN VarSet (entryB (item, -15))$END IsInReg; "PROCEDURE IsInMem (item: PtrItem): BOOLEAN;$BEGIN&RETURN NOT IsInReg (item)$END IsInMem;""PROCEDURE UsedReg (item: PtrItem): CARDINAL;$BEGIN&RETURN ORD (BYTE (VarSet (entryB (item, -15)) * RegSet))$END UsedReg;""PROCEDURE SetReg (item: PtrItem; reg: CARDINAL);$VAR (*$Reg*)r: VarSet;$BEGIN&r:= VarSet (entryB (item, -15));&enterB (item, -15, r - RegSet + VarSet (SHORT (WORD (reg))))$END SetReg;""PROCEDURE MakeRegVar (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) + VarSet {regVar})$END MakeRegVar; "PROCEDURE MakeMemVar (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) - VarSet {regVar})$END MakeMemVar;""PROCEDURE UseReg (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) + VarSet {inReg})$END UseReg;""PROCEDURE UseMem (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) - VarSet {inReg})$END UseMem; "PROCEDURE IsDirty (item: PtrItem): BOOLEAN;$BEGIN&RETURN dirty IN VarSet (entryB (item, -15))$END IsDirty; "PROCEDURE ClearDirt (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) - VarSet {dirty})$END ClearDirt; "PROCEDURE SetDirt (item: PtrItem);$BEGIN&enterB (item, -15, VarSet (entryB (item, -15)) + VarSet {dirty})$END SetDirt; "PROCEDURE SetAccessDepth (item: PtrItem; n: CARDINAL);$BEGIN&enterB (item, -16, SHORT (WORD (n)))$END SetAccessDepth; "PROCEDURE NewAccessDepth (item: PtrItem; n: CARDINAL);$BEGIN&IF n > ORD (entryB (item, -16)) THEN(enterB (item, -16, SHORT (WORD (n)))&END$END NewAccessDepth;  (*$L-*) "PROCEDURE Ret6L (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -6(A0),D0&END;$END Ret6L; "PROCEDURE Ret10L (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -10(A0),D0&END;$END Ret10L; "PROCEDURE Ret14L (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -14(A0),D0&END;$END Ret14L; "PROCEDURE AccessDepth (item: PtrItem): CARDINAL;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(CLR.W   D0(MOVE.B  -16(A0),D0&END;$END AccessDepth; "PROCEDURE SetTableLink (item: PtrItem; v: LONGWORD);$BEGIN&ASSEMBLER(MOVE.L  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D0,-10(A0)&END;$END SetTableLink; "PROCEDURE LastTableLink (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END LastTableLink; "PROCEDURE SetConstLink (item: PtrItem; v: LONGWORD);$BEGIN&ASSEMBLER(MOVE.L  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D0,-14(A0)&END;$END SetConstLink; "PROCEDURE LastConstLink (item: PtrItem): ADDRESS;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END LastConstLink; "PROCEDURE SetVarLink (item: PtrItem; v: LONGWORD);$BEGIN&ASSEMBLER(MOVE.L  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D0,-14(A0)&END;$END SetVarLink; "PROCEDURE LastVarLink (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END LastVarLink; "PROCEDURE SetProcLink (item: PtrItem; v: LONGWORD);$BEGIN&ASSEMBLER(MOVE.L  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D0,-18(A0)&END;$END SetProcLink; "PROCEDURE LastProcLink (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -18(A0),D0&END;$END LastProcLink; "PROCEDURE IndexType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END IndexType; "PROCEDURE ParmType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END ParmType; "PROCEDURE FirstParm (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END FirstParm; "PROCEDURE NextParm (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret6L/&END;$END NextParm; "PROCEDURE LocalTree (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END LocalTree; "PROCEDURE RefType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END RefType; "PROCEDURE ElementType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END ElementType; "PROCEDURE BaseType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -18(A0),D0&END;$END BaseType; "PROCEDURE SetBaseType (item: PtrItem; t: PtrItem);$BEGIN&ASSEMBLER(MOVE.L  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  D0,-18(A0)&END;$END SetBaseType; "PROCEDURE OpenArrayType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret6L/&END;$END OpenArrayType; "PROCEDURE VarParm (item: PtrItem): BOOLEAN;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.W  -12(A0),D0&END;$END VarParm; "PROCEDURE NoOfElems (item: PtrItem): LONGCARD;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END NoOfElems; "PROCEDURE LowBound (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END LowBound; "PROCEDURE HighBound (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END HighBound; "PROCEDURE SetItemFlag (item: PtrItem; f:IFS);$BEGIN&ASSEMBLER(SUBQ.L  #1,A3(MOVE.B  -(A3),D0(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  D0,-2(A0)&END;$END SetItemFlag; "PROCEDURE ParmFlag (item: PtrItem): IFS;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  -12(A0),D0&END;$END ParmFlag; "PROCEDURE ParmToReg (item: PtrItem): BOOLEAN;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(TST.B   -11(A0)(SMI     D0(ANDI    #1,D0&END;$END ParmToReg; "PROCEDURE ParmRegNo (item: PtrItem): RegType;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  -11(A0),D0(ANDI    #11111%,D0&END;$END ParmRegNo; "PROCEDURE VarAddress (item: PtrItem): LONGINT;$BEGIN&ASSEMBLER(JMP     Ret6L/&END;$END VarAddress; "PROCEDURE AnyTypeLength (item: PtrItem): LONGCARD;$BEGIN&ASSEMBLER(JMP     Ret6L/&END;$END AnyTypeLength; "PROCEDURE StdProcNo (item: PtrItem): CARDINAL;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.W  -4(A0),D0&END;$END StdProcNo; "PROCEDURE StdProcParms (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -8(A0),D0&END;$END StdProcParms; "PROCEDURE StdParmType (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret6L/&END;$END StdParmType; "PROCEDURE NextStdParm (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END NextStdParm; "PROCEDURE StdParmRes (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END StdParmRes; "PROCEDURE FirstRecField (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret10L/&END;$END FirstRecField; "PROCEDURE NextRecField (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(JMP     Ret14L/&END;$END NextRecField; "PROCEDURE NextTagField (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -18(A0),D0&END;$END NextTagField; "PROCEDURE TagFieldList (item: PtrItem): PtrItem;$BEGIN&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.L  -22(A0),D0&END;$END TagFieldList;  (*$L+*) "PROCEDURE ItemNo (item: PtrItem): CARDINAL;$(*$L-*)$BEGIN&ASSEMBLER(; RETURN ORD (entryB (item, -1))(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVEQ   #0,D0(MOVE.B  -1(A0),D0((*$? NOT OptimizedCompile:(MOVE.W  D0,(A3)+(*)&END$END ItemNo;$(*$L=*) "PROCEDURE ItemFlag (item: PtrItem): IFS;$(*$L-*)$BEGIN&ASSEMBLER(; RETURN IFS (entryB (item, -2))(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0((*$? NOT OptimizedCompile:(MOVE.B  -2(A0),(A3)+(CLR.B   (A3)+(*)((*$? OptimizedCompile:(MOVE.B  -2(A0),D0(*)&END$END ItemFlag;$(*$L=*) "PROCEDURE TypeLength (item: PtrItem): LONGCARD;$(*$L-*)$TYPE itemSet = SET OF [0..47];$BEGIN&(*(n:= ORD (entryB (item, -1));(IF (n IN itemSet {1,2,3,5,8,9,11,12,13,14,19..26,:30,33,34,35,38,39,40,41,4,44,45}) THEN*RETURN LONGCARD (entryL (item, -6))(ELSIF n = 6 THEN*RETURN 4(ELSIF n = 32 (* OPEN ARRAY *) THEN*RETURN $10000(ELSIF n = 42 (* OPEN ARRAY *) THEN*RETURN $FFFFFFFE (* muû gerade sein! *)(ELSE*WriteLn; WriteCard (n, 0); WriteLn;*bong;*RETURN 1(END&*)&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVEQ   #0,D0(MOVE.B  -1(A0),D0(CMPI.B  #60,D0(BCC     error(LEA     itemTab(PC),A1(TST.B   0(A1,D0.W)(BEQ     error(BMI     special((*$? NOT OptimizedCompile:(MOVE.L  -6(A0),(A3)+(*)((*$? OptimizedCompile:(MOVE.L  -6(A0),D0(*)(RTS&itemTab(; {1,2,3,4,5,8,9,11,12,13,14,19..26,30,33,34,35,38,39,40,41,44,45}(DC.B    0,1,1,1,1,1,-1,0,1,1,0,1,1,1,1,0,0,0,0,1(DC.B    1,1,1,1,1,1,1,0,0,0,1,0,-1,1,1,1,0,0,1,1(DC.B    1,1,-1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0&special(CMPI.B  #6,D0(BEQ     isProc(CMPI.B  #32,D0(BEQ     isOpn(CMPI.B  #42,D0(BNE     error(MOVEQ   #-2,D0((*$? NOT OptimizedCompile:(MOVE.L  D0,(A3)+(*)(RTS&isOpn((*$? NOT OptimizedCompile:(MOVE.L  #$10000,(A3)+(*)((*$? OptimizedCompile:(MOVE.L  #$10000,D0(*)(RTS&isProc(MOVEQ   #4,D0((*$? NOT OptimizedCompile:(MOVE.L  D0,(A3)+(*)(RTS&error(MOVE    D0,n(LINK    A5,#0&END;&BadId:= 'TypeLength of #';&Append (CardToStr (n, 0), BadId, ok);&scanPrep (2);&appendScanDesc;&SyntaxError (rFatlR)$END TypeLength;$(*$L=*) "PROCEDURE SetTypeLength (item: PtrItem; l: LONGCARD);$BEGIN&enterL (item, -6, l)$END SetTypeLength; "PROCEDURE BooleanType (item: PtrItem): BOOLEAN;$(*$L-*)$BEGIN&ASSEMBLER(; RETURN ADDRESS (item) = BoolPtr(MOVE.L  -(A3),D0(CMP.L   BoolPtr,D0(SEQ     D0(ANDI    #1,D0((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)&END$END BooleanType;$(*$L=*) "PROCEDURE StrConstType (item: PtrItem): BOOLEAN;$(*$L-*)$BEGIN&ASSEMBLER(; RETURN ADDRESS (item) = StrPtr(MOVE.L  -(A3),D0(CMP.L   StrPtr,D0(SEQ     D0(ANDI    #1,D0((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)&END$END StrConstType;$(*$L=*) "PROCEDURE ByteType (item: PtrItem): BOOLEAN;$(*%* Liefert FALSE, wenn Datum keinesfalls auf ungeraden Adressen liegt%*)$(*$L-*)$VAR n: CARDINAL;$TYPE itemSet = SET OF [0..47];$BEGIN&(*(n:= ORD (entryB (item, -1));(IF n = 12 (* ARRAY *) THEN*RETURN TypeLength (ElementType (item)) = 1L(ELSE*RETURN ODD (AnyTypeLength (item))(END&*)&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(CMPI.B  #12,-1(A0)(BNE     noArray(MOVE.L  -14(A0),A0(ADDA.L  TreeBase,A0(CMPI.L  #1,-6(A0)(SEQ     D0(BRA     rtn&noArray(BTST    #0,-6+3(A0)(SNE     D0&rtn(ANDI    #1,D0((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)&END$END ByteType;$(*$L=*) "PROCEDURE HostType (item: PtrItem): PtrItem;$(*$L-*)$BEGIN&(*(IF ORD (entryB (item, -1)) = 11 (* SUBRANGE *) THEN*RETURN PtrItem (entryL (item, -18))(ELSE*RETURN item(END&*)&ASSEMBLER((*$? NOT OptimizedCompile:(MOVE.L  -4(A3),A0(ADDA.L  TreeBase,A0(CMPI.B  #11,-1(A0)(BNE     noSubrg(MOVE.L  -18(A0),-4(A3)(*)((*$? OptimizedCompile:(MOVE.L  -(A3),D0(MOVE.L  TreeBase,A0(CMPI.B  #11,-1(A0,D0.L)(BNE     noSubrg(MOVE.L  -18(A0,D0.L),D0(*)&noSubrg&END$END HostType;$(*$L=*) "PROCEDURE CharType (item: PtrItem): BOOLEAN;$(*$L-*)$VAR n: CARDINAL;$BEGIN&(*(n:= ORD (entryB (item, -1));(RETURN (n = 3   (* CHAR *)),(* geht nicht wg. TypeLength:.OR (n = 27) (* SS-Type *) & (TypeLength (item) = 1L),*)&*)&ASSEMBLER(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(CMPI.B  #3,-1(A0)(SEQ     D0(ANDI    #1,D0((*$? NOT OptimizedCompile:(MOVE    D0,(A3)+(*)&END$END CharType;$(*$L=*)   (*$Z-*) PROCEDURE fatalError (no: INTEGER; msg: ARRAY OF CHAR; causer: ErrResp;6cont: RtnCond; VAR excData: ExcDesc ): BOOLEAN; (*$Z=*)"VAR ok: BOOLEAN; foldConst: BOOLEAN;"BEGIN$foldConst:= FALSE;$IF ~SignalOverflow & (no = Overflow) THEN&HasOverflown:= TRUE;&RETURN FALSE$ELSIF FoldingConst$AND ( (no = DivByZero) OR*(no = OutOfRange) OR*(no = Overflow)      ) THEN&(* normalen Fehler melden wÑhrend Constant-Folding *)&(* Versuchsweise ignorieren, wenn SuppressCode = TRUE,'* damit "TRUE OR (1/0)" keinen Fehler bringt. *)&IF SuppressCode THEN(RETURN FALSE&END;&foldConst:= TRUE$END;$IF msg[0] = '' THEN&GetErrorMsg (no, BadId)$ELSE&Assign (msg, BadId, ok)$END;$IF foldConst THEN&(* normalen Fehler (kein interner Fehler) melden wÑhrend Constant-Folding *)&HaltOnError:= FALSE;&SyntaxError (rCExpr)$END;$(* wenn hier Backtrace mîgl. sein soll, darf kein HALT ausgelîst werden,%* weil dann >Laufzeitfehler wÑhrend Deinit< auftritt. Stattdessen%* hier selbst GEMScan aufrufen *)$errorMsg:= ' Interner Fehler! ';$WITH globalScan DO&pc:= excData.regPC;&link:= excData.regA5.ad;&stack:= excData.regUSP$END;$scanPrep (0);$IF HaltOnError THEN&scanner;&IF 2 IN GetKBShift () THEN (* ignore error *) RETURN FALSE END;&HaltOnError:= FALSE;$ELSE&appendScanDesc;$END;$SyntaxError (rFatlR);$RETURN TRUE"END fatalError;  VAR wsp: MemArea;  PROCEDURE Tracer;"(*$L-*)"BEGIN$ASSEMBLER(CMPI.W  #$FFFF,ZZTyp(SNE     D0$END"END Tracer;"(*$L=*)  BEGIN"(*#* Und nun fÅr alle FÑlle die Laufzeitfehler abfangen.#*)"wsp.bottom:= ADR (HdlErrorStack);"wsp.length:= SIZE (HdlErrorStack);"ok:= CatchErrors (fatalError, wsp);""ASSEMBLER(LEA     Tracer,A0(; BREAK"END; END MM2Comp3;   VAR FP: ARRAY [F0..F7],BOOLEAN,[0..5] OF CHAR;$ASM: ARRAY [0..11] OF CHAR;  CONST $SizeOfLongReal = 8;$SizeOfShortReal = 4;$$$LADD = 7;$LSUB = 8;$LMUL = 11;$LDIV = 14;$LREQ = 0;$LRNE = 1;$LRLE = 2;$LRGE = 3;$LRLT = 4;$LRGT = 5;$LNEG = 6;$LABS = 91;$$SNEG = 92;$SABS = 93;$SADD = 94;$SSUB = 95;$SMUL = 96;$SDIV = 97;$SRLE = 98;$SRGE = 99;$SRLT = 100;$SRGT = 101;$$RXPD = 24;$RSHT = 25;$$FNUL = 18;  (* Float-Operation ohne <ea>, opcode in D0 *)$FOPS = 26;  (* Float-Operation mit <ea>.S in D1, opcode in D0 *)$FOPD = 27;  (* Float-Operation mit <ea>.D in (A0), opcode in D0 *)$FMVS = 85;  (* Float-Move <ea>.S nach (A0), opcode in D0 *)$FMVD = 86;  (* Float-Move <ea>.D nach (A0), opcode in D0 *)$$FCPN = 87;  (* Float-Operation & Bcc (D2) ohne <ea>, opcode in D0 *)$FCPS = 88;  (* Float-Operation & Bcc (D2) mit <ea>.S in D1, opcode in D0 *)$FCPD = 89;  (* Float-Operation & Bcc (D2) mit <ea>.D in (A0), opcode in D0 *)$$(* diverse Push/Pop-Operationen fÅr FPU-Reals *)$FP7S = 113;$FP7D = 114;$FP3S = 115;$FP3D = 116;$FG7S = 117;$FG7D = 118;$FG3S = 119;$FG3D = 120;$FP7M = 121;$FG7M = 122;$$SINCL= 22;$SEXCL= 23;$SIRG = 110;$SMEM = 28;$SEQU = 29;$SNEQ = 30;$SLEQ = 31; $IMLW = 50;$CMLW = 51;$IMLL = 56;$CMLL = 57;$IDVL = 58;$CDVL = 59;$IMDL = 60;$CMDL = 61;$$PS3B = 62;$PS3W = 63;$PS3L = 64;$PS7B = 65;$PS7W = 66;$PS7L = 67;$$CWOP = 111;$CLOP = 112;$$COPYW= 68;$COPYL= 69;$$CAPI = 70;$LENW = 71;$LENL = 72; $LC2S = 102;$LI2S = 103;$LC2D = 104;$LI2D = 105;$S2LC = 106;$S2LI = 107;$D2LC = 108;$D2LI = 109; $CMP8 = 43; (* RES1 *) $SAND = 73;$SXOR = 74;$SSUM = 75;$SDIF = 76;$(* Es folgen zwei weitere 4er-Blîcke mit den selben Set-Operatoren *)$$ROTA = 123;$SHFT = 124;   VAR"GlobalA7Hidden, LocalA7Hidden: BOOLEAN;"LocalA7WhenHidden: LONGINT;  PROCEDURE coding (): BOOLEAN;"BEGIN$IF InConstExpr THEN SyntaxError (rConXp) ELSE RETURN NOT SuppressCode END"END coding;  PROCEDURE activateCodeSuppression (VAR last: BOOLEAN);"BEGIN$last:= SuppressCode;$SuppressCode:= TRUE"END activateCodeSuppression;  PROCEDURE restoreCodeSuppression (last: BOOLEAN);"BEGIN$SuppressCode:= last"END restoreCodeSuppression;   (* ----------------------------------------------------------------------- *)  CONST"strConstSize = constBufSize-1;   TYPE  (*$? CompileWithNewCompiler:"LongREAL = LONGREAL;"ShortREAL = REAL; *) (*$? CompileWithOldCompiler:"LongREAL = LONGREAL;"ShortREAL = LONGINT; *) "RR = ARRAY [0..1] OF LONGWORD;  (* quasi ZZ-Type fÅr Reals *)"SR = ARRAY [0..0] OF LONGWORD;  "convBits = (signChange, expand, shorten, signedConv, realConv,.procShorten, procExpand, subCheck);"convSet  = SET OF convBits; "ConvDesc = RECORD/boundsCheck: BOOLEAN;/signedBounds: BOOLEAN;/boundSize: CARDINAL;/lowerBound, upperBound: LONGWORD;/sizeFlags: convSet;/sourceSize, destSize: CARDINAL;/destType: PtrItem;-END;""Directions = (noDir, up, down); "Operator = (add, sub, mul, div, rdiv, mod, rem, or, and,.lt, eq, gt, ge, le, ne, cc, pl, vc, in);"OpSet    = SET OF Operator;"Relation = [lt..gt]; "BS       = SET OF [0..7];"ShortSet = SET OF [0..31];"LongSet  = SET OF [0..(constBufSize * 8 -1)];"FullSet  = SET OF [0..MaxCard];"PtrSet   = POINTER TO BS;"PtrFullSet = POINTER TO FullSet; "PtrStr   = POINTER TO CHAR; "ItemSet = SET OF [0..63]; "Label    = ADDRESS;"ZZ       = RECORD/over: BOOLEAN;/CASE : CARDINAL OF/| 0: b3: INTEGER; b1: BYTE; b: BYTE;/| 1: c2: CARDINAL; c: CARDINAL;/| 2: i2: INTEGER; i: INTEGER;/| 3: v: LONGINT;/| 4: l: LONGCARD/END;-END; "LW = LONGWORD;""ConstValue = RECORD1(*2* Alle Daten sind rechtsbÅndig (constBufSize Byte)!2*)1CASE : CARDINAL OF30: lw:ARRAY [0..1] OF LW|39: d0:LW;b4,b3,b2:BYTE; ch: CHAR|31: d8:LW;b5,b6,b7:BYTE; b: BYTE|32: d1:LW;w2:WORD;       w: WORD|34: d2:LW;               l: LONGWORD|35: d4:WORD;             zz: ZZ|36: d5:LW;               ss: ShortSet|37:                      ws: LongSet|33: d7:LW;               sr: SR|211:                      rr: RR|210:                      str: ARRAY [0..strConstSize] OF CHAR;1END/END;  "ExprKind = (unused, jmp, condFlags, constant, constRef, constImm,.register, memory, stack, spilledSP); "MemModes = (extL, relConst, pcRel, relRef, immRef, absRef,.(* der Rest sind nur indir. Adr-Arten (wg. 'indir'-Routine): *).d16An, d8AnXn, ptrOnA3, ptrOnA7);#(*$* 'ptrOnA3/A7': ist eigentlich der Modus 'd16n', das Base-Reg steht$* jedoch temporÑr auf dem Stack. Wird dort z.B. bei Proc-Aufruf hingeladen.$* Nach Proc-Aufruf muû vor einem 'gen...'-Aufruf der Wert in ein$* Base-Reg zurÅckgeladen werden, weil es sonst zum Deadlock kommen kînnte.$*) #(*$* In 'ExprDesc' wird die Adressierung beschrieben, mit der ohne$* Weiteres auf das Datum (typ in 'item') zugegriffen werden kann.$* Also sind alle Zugriffswege bis auf den letzten, der das Datum$* ÅbertrÑgt, schon codiert.$*$* 'register' kommt nur bei Scalaren, SETs (<=32 Elems) und Reals vor,$* jedoch nicht bei strukturierten Typen, denn nur sie werden Åberhaupt in$* Regs benîtigt, um Operationen mit ihnen zu machen. FÅr die Float-Register$* werden die Regs des 68881 oder entsprechender Runtime-Variablen verwendet.$* Im letzteren Fall wird trotzdem so getan, als stÅnden sie in den echten$* FFP-Regs - erst die Code-generierenden Routinen erzeugen dann doch$* den Speicher-Zugriff.$* Einziger Fall, wo dies schwieriger ist, sind groûe Sets. Sie kînnen$* bei Operationen nicht in Registern zwischengespeichert werden, sondern$* mÅssen auf den A3-Stack. Deshalb muû bei den Set-Operationen eine$* Sonderauswertung fÅr die Stack-Ablage vorgenommen werden. Schade ist$* nur, daû dadurch immer schon eine Kopie auf den Stack kommt, obwohl$* vielleicht danach sofort eine Zuweisung kommt, so daû das gleich hÑtte$* kombiniert werden kînnen.$* Die restlichen Typen passen immer in ein Register (ggf. die Pseuso-Real-$* Regs) und kînnen somit auch von Åberall, also auch vom A3-Stack, direkt$* ohne Sonderbehandlung geladen werden. Bei Long-Reals muû lediglich das$* Umladen von einer Var/dem Stack zu den Pseudo-Regs (und umgekehrt)$* sonderbehandelt werden. Dies wird wohl auch bei den Real-Operationen$* direkt berÅcksichtigt.$*$* Neben den Operationen sind nur noch Zuweisungen grîûerer Datentypen$* mîglich. FÅr diesen Fall, besonders beim Laden vom A3-Stack, wird$* Sorge getragen in 'moveTo'.$*$* Einfache Variablen bis 32 Bit sind meist mit 'memory' beschrieben.$*$* mode = 'immRef' wird fÅr Adressen von globalen Variablen und Prozeduren$* verwendet. Sie mÅssen reloziert werden und sind daher immer Long.$* Sie dÅrfen nicht als Konstante ausgewertet und dann durch$* constantFold bei einer Adreû-Differenz wegoptimiert werden,$* sondern mÅssen letztendlich unbedingt im Code erscheinen, weil$* sonst Fehler durch optimiertes Linken entstehen kînnten.$* Adr. von lokalen Procs sind ja auch quasi Konstanten, weshalb sie$* nicht mit 'relRef' gekennzeichnet werden dÅrfen. Stattdessen wird$* dann 'relConst' verwendet. Diese Adressierung ist allerdings bei$* der 68000 nicht vorgesehen, weshalb sie bei Zugriff ggf. durch$* einen LEA-Befehl und der 'relRef'-Adressierung zu ersetzen ist.$*$* Adressen von relativen Variablen werden gleich in ein Register geladen,$* wÑhrend relative Code-Adressen mit mode = 'pcRel' (ohne Relozieren)$* oder 'relRef' (mit Relozieren) gekennzeichnet werden.$*$* Daten kînnen NIEMALS als Wert/Referenz einer Expression auf dem$* A7-Stack stehen! Der dient lediglich zum Retten bei 'spillReg'$* und bei der ParameterÅbergabe.$*$* Andererseits kînnen Werte aber schon auf dem A3-Stack stehen,$* so daû dies bei Zuweisungen und anderen Operationen beachtet$* werden muû (dazu dient 'bothOnStack')!$*$* Groûe SET- (und solche mit neg. Lowbound oder Highbound > 31) und$* String-Literals werden immer im DATA-Puffer abgelegt und mit$* kind = 'constRef' gekennzeichnet.$* SET-Literals kînnen aber wieder gekÅrzt werden, falls sie durch$* constantFold zusammengefaût werden. Allerdings bleibt letztendlich$* immer eine Konstante im Code zurÅck. Bei Const-Expression werden$* sie daher wie Prozeduren angelegt, so daû auf sie mehrfach zugegriffen$* werden kann und vom Linker korrekt behandelt/reloziert/entfernt$* werden kînnen.$*&&& offen ist noch, wie genau die einbindung stattfindet: es muû schon$* im Deklarationsteil (CONST) der Code abgelegt werden, und zwar$* je nach Tiefe global oder lokal. bei lokalen muû gesichert sein,$* daû der bereich schon zur proc gehîrt, so daû er nicht vom linker$* falsch wegoptimiert wird, bei globalen muû Åberlegt werden, ob bei$* aktiver $M-option die verkettung mitgefÅhrt werden muû, auûerdem$* muû wie bei glob. procs die lÑngenliste mit aufgebaut werden.$*$* 'ExprDesc.varItem': Zeigt auf die Item-Beschreibung der Variablen$* oder Konstante.$* Kann z.B. verwendet werden, um Reg-Var zu markieren oder$* ref-Flag zum Schreibschutz zu setzen.$* Ist bei 'kind=constant' 'varItem=NIL', dann bedeutet dies,$* daû die Konst als Konstruktor zusammengesetzt wurde, aber noch$* nicht im Code sondern nur in 'exprConst' vorliegt -> sie muû$* dann noch im Data-Puffer abgelegt werden, falls sie referenziert$* werden soll.$*$* Werden Daten auf die Stacks (A3, A7) geladen, werden entsprechend die$* glob. Vars 'A7Offset' & 'A3Offset' angepaût. In 'ExprDesc.stackPtr'$* kann dann ggf. der Stack-Offset gesichert werden, so daû, wenn spÑter$* auf die Werte auf dem Stack zugegriffen werden soll (z.B. bei WITH-$* Pointern), aus der Differenz zum aktuellen A3/7Offset ein direkter$* Zugriff erfolgen kann. Das Erhîhen/Erniedrigen von A3/7Offset geschieht$* generell in den Low-Level-Codegen-Routinen (gen...). Allerdings ist$* zu beachten, daû dann teilweise die Werte nicht angepaût werden, so$* z.B., wenn eine Runtime-Routine den Wert verÑndert. Auch muû aufge-$* paût werden, wenn die Werte nach 'stackPtr' gesichert werden: Es darf$* erst definiert vor/nach dem Codegen-Aufruf geschehen und bei A3 muû die$* TyplÑnge ggf. noch abgezogen werden. Bei Proc-Calls wird ja ggf. schon$* im Voraus der SP (A7) fÅr alle Parms erniedrigt, was ebenso zu beachten$* ist.$*) "ExprDesc = RECORD/item: PtrItem;   (* Beschreibt TYPE des Datums *)/CASE : CARDINAL OF/0: exprSize: LONGCARD| (* z.Zt. nur bei ItemNo 27 & 43 benutzt *)/1: not: BOOLEAN|       (* Nur bei Booleans verwendet *)/2: regset: BOOLEAN;    (* Nur SETs: Bit-Ordnung wie in Reg *)2zerobased: BOOLEAN| (* Nur SETs: Kein lowbound-Abzug *)/3: highReg: RegType;   (* Open Array: ^ auf High-Wert *)2highOfs: INTEGER;   (* Open Array: Offs. High-Wert zum ^ *)/END;/typeChecked: BOOLEAN;/regVar: BOOLEAN;   (* TRUE: Expr kann in Reg liegen *)/readOnly: BOOLEAN; (* TRUE: Var ist z.B. REF-Parm *)/varItem: PtrItem;  (* ^Var/Const/Proc-Beschreibung *)/constHead: ADDRESS; (* Adr. d. Konst. im DATA-Puffer *)/CASE kind: ExprKind OF/| jmp:/| constImm,1constRef: (* 'varItem' zeigt auf CONST-Eintrag im Tree     *<* oder ist NIL, wenn Datum im DATA-Puffer liegt *);(* wenn varItem#NIL, ist constHead=NIL und umgekehrt! *);constOfs: LONGCARD; (* Ofs. zu Konst-Beginn *);constAddr: ADDRESS; (* Adr. im DATA-Puffer *);(* constHead nicht hier einfÅgen, weil es auch<* vorkommt, daû constHead zum Relozieren benîtigt<* wird, wenn bereits kind<>constRef ist. *)/| constant: (* auch bei SET bis 4 Byte *);(* & Strings <= constBufSize Zeichen *);exprConst: ConstValue;/| condFlags:relOp: Operator;;signed: BOOLEAN;;fpuFlags: BOOLEAN;/| register: exprReg: RegType;/| memory:   mode: MemModes;;mayBeOdd: BOOLEAN; (* FALSE: MOVE.W bei Byte-Daten *);baseReg, idxReg: RegType;;idxL: BOOLEAN; (* TRUE: idxReg ist .L *);CASE : CARDINAL OF;|1: tiefe: CARDINAL;   (* fÅr Procs *);|2: extAddr: ADDRESS   (* bei 'extL' *);|3: disp: LONGINT;     (* bei 'd16An', 'd8AnXn' *);|4: depth: LONGINT;    (* bei 'ptrOnA3/A7' *);|5: absAddr: ADDRESS;  (* bei 'pcRel' *);END;/| stack,1spilledSP:spillReg: RegType;      (* nur bei 'spilledSP' *);spillOfs: LONGINT;      (* n.b. spilledSP: A3/A7 *);stackReg: RegType;;up: BOOLEAN;           (* FALSE bei A7, sonst TRUE *);stackedSize: LONGCARD; (* Platz v. Datum auf Stack *);restoreAfterUse: LONGCARD; (* Freigeben bei dealloc*);stackPtr: LONGINT;     (* SP-Offset bei Push *)/END;-END; "NumberSize = (unspecSize, ord2, ord4, real4, real8);"NumberType = (unspecType, realType, intType, cardType, bothType);   CONST"maxDepth  = 99;  TYPE ExprSP = [-1..maxDepth];  VAR"exprStack : ARRAY [0..maxDepth] OF RECORD0expr: ExprDesc;0maySpill: BOOLEAN (* FALSE: nicht auf den Stack laden *).END;"exprSp    : ExprSP;      (* -1 means empty *)"spillSp   : ExprSP;      (* everything below that doesn't use a reg *)"spilling  : BOOLEAN;     (* prevents recursion *)"spillDestReg: RegType;   (* dies ist der Ziel-Stack *)"spillDestDir: Directions;(* und das seine Richtung *)"helpExpr2, helpExpr: ExprDesc;   PROCEDURE Size (REF expr: ExprDesc): LONGCARD;"(*#* Liefert Grîûe des Datums#*)"(*$L-*)"BEGIN$(*&IF (expr.item = SSTyp) OR (expr.item = UndefTyp) THEN(RETURN expr.exprSize&ELSE(RETURN TypeLength (expr.item)&END$*)$ASSEMBLER(MOVE.L  -(A3),A0(MOVE.L  ExprDesc.item(A0),D0(CMP.L   SSTyp,D0(BEQ     ok(CMP.L   UndefTyp,D0(BEQ     ok(MOVE.L  D0,(A3)+ (*$? OptimizedCompile:(JMP     TypeLength/%ok MOVE.L  ExprDesc.exprSize(A0),D0 *) (*$? NOT OptimizedCompile:(JMP     TypeLength%ok MOVE.L  ExprDesc.exprSize(A0),(A3)+ *)$END"END Size;"(*$L=*)   PROCEDURE XOR (a,b: BOOLEAN): BOOLEAN;"BEGIN$RETURN a AND NOT b OR b AND NOT a"END XOR;  (*$? Test: PROCEDURE showZZ (zz: ZZ);"BEGIN$InOut.WriteLn;$IF zz.over THEN&InOut.WriteCard (zz.l, 0);$ELSE&InOut.WriteInt (zz.v, 0)$END;$InOut.WriteLn;"END showZZ;  PROCEDURE writeReg (r: RegType);"BEGIN$IF r >= F0 THEN&InOut.Write ('F')$ELSIF r >= A0 THEN&InOut.Write ('A')$ELSE&InOut.Write ('D')$END;$InOut.WriteCard (r MOD 8, 1);"END writeReg;  PROCEDURE showRegs (regs: RegSet; set: BOOLEAN; txt: ARRAY OF CHAR);"VAR r: RegType;"BEGIN$InOut.WriteLn;$InOut.WriteString (txt);$FOR r:= MIN (RegType) TO MAX (RegType) DO&IF XOR (NOT set, r IN regs) THEN(writeReg (r);(InOut.WriteString (' ')&END$END;$InOut.WriteLn;"END showRegs;  PROCEDURE showExpr (REF expr: ExprDesc);"VAR ch: CHAR; i: CARDINAL;"BEGIN$InOut.WriteLn;$InOut.WriteString ('A3Offset: ');$InOut.WriteInt (A3Offset, 0);$InOut.WriteString ('  //  A7Offset: ');$InOut.WriteInt (A7Offset, 0);$InOut.WriteLn;$InOut.WriteString ('itemNo: ');$InOut.WriteCard (ItemNo (expr.item), 2);$InOut.WriteString (',  size: ');$InOut.WriteCard (Size (expr), 0);$InOut.WriteString (',  varItem: ');$InOut.WriteLHex (expr.varItem, 9);$InOut.WriteString (', constHead: '); InOut.WriteLHex (expr.constHead, 7);$InOut.WriteLn;$$WITH expr DO&InOut.WriteString ('kind: ');&CASE kind OF&| jmp:      InOut.WriteString ('jmp.');&| constRef: InOut.WriteString ('constRef.');2InOut.WriteString ('constOfs: '); InOut.WriteCard (constOfs, 0); InOut.WriteLn;2InOut.WriteString ('constAddr: '); InOut.WriteLHex (constAddr, 7); InOut.WriteLn;&| constant: InOut.WriteString ('constant.'); InOut.WriteLn;2InOut.WriteString ('exprConst: ');2IF BooleanType (item) THEN4IF BOOLEAN (exprConst.w) THEN InOut.WriteString ('TRUE'); ELSE InOut.WriteString ('FALSE'); END;2ELSIF item = SSTyp THEN4FOR i:= 0 TO strConstSize DO6InOut.Write (exprConst.str [i])4END2ELSIF exprConst.zz.over THEN4InOut.WriteCard (exprConst.zz.l, 0);2ELSE4InOut.WriteInt (exprConst.zz.v, 0)2END;&| condFlags:InOut.WriteString ('condFlags.');2(* relOp signed *)&| register: InOut.WriteString ('register.'); InOut.WriteLn;2InOut.WriteString ('exprReg: '); writeReg (exprReg);&| memory:   InOut.WriteString ('memory.'); InOut.WriteLn;2InOut.WriteString ('mode: ');2CASE mode OF2| relConst, absRef, immRef, relRef:4CASE mode OF4|relConst: InOut.WriteString ('relConst.');4|absRef:   InOut.WriteString ('absRef.');4|immRef:   InOut.WriteString ('immRef.');4|relRef:   InOut.WriteString ('relRef.')4END;4InOut.WriteLn;4InOut.WriteString ('tiefe: '); InOut.WriteCard (tiefe, 0);2|d16An, d8AnXn:4IF mode = d16An THEN6InOut.WriteString ('d16An.')4ELSE6InOut.WriteString ('d8AnXn.')4END;4InOut.WriteLn;4InOut.WriteString ('disp: '); InOut.WriteInt (disp, 0); InOut.WriteLn;4InOut.WriteString ('baseReg: '); writeReg (baseReg);4IF mode = d8AnXn THEN6InOut.WriteLn;6InOut.WriteString ('idxReg: '); writeReg (idxReg); InOut.WriteLn;6InOut.WriteString ('idxL: '); IF idxL THEN InOut.WriteString ('TRUE'); ELSE InOut.WriteString ('FALSE'); END;4END;2|extL:4InOut.WriteString ('extL.')4(* extAddr *)2|ptrOnA3:4InOut.WriteString ('ptrOnA3.')4(* depth *)2|ptrOnA7:4InOut.WriteString ('ptrOnA7.')4(* depth *)2|pcRel:4InOut.WriteString ('pcRel.')4(* absAddr *)2ELSE4InOut.WriteString ('???')2END;2InOut.WriteLn;2InOut.WriteString ('mayBeOdd: '); IF mayBeOdd THEN InOut.WriteString ('TRUE'); ELSE InOut.WriteString ('FALSE'); END;&| stack,(spilledSP:IF kind = stack THEN4InOut.WriteString ('stack.'); InOut.WriteLn;2ELSE4InOut.WriteString ('spilledSP.'); InOut.WriteLn;4InOut.WriteString ('spillReg: '); writeReg (spillReg); InOut.WriteLn;2END;2InOut.WriteString ('stackReg: '); writeReg (stackReg); InOut.WriteLn;2InOut.WriteString ('up: '); IF up THEN InOut.WriteString ('TRUE'); ELSE InOut.WriteString ('FALSE'); END; InOut.WriteLn;2InOut.WriteString ('stackPtr: '); InOut.WriteInt (stackPtr, 0); InOut.WriteLn;2InOut.WriteString ('stackedSize: '); InOut.WriteCard (stackedSize, 0);2(* restoreAfterUse *)&ELSE(InOut.WriteString ('???')&END;$END;$InOut.WriteLn;$IF BooleanType (expr.item) THEN&IF expr.not THEN(InOut.WriteString ('not = TRUE!'); InOut.WriteLn;&END;$ELSIF (ItemNo (expr.item) = 5) OR (ItemNo (expr.item) = 5) THEN&InOut.WriteString ('SET:'); InOut.WriteLn;&IF NOT expr.typeChecked THEN(InOut.WriteString ('  not typeChecked!'); InOut.WriteLn;&ELSE(IF expr.regset THEN*InOut.WriteString ('  regset'); InOut.WriteLn;(END;(IF expr.zerobased THEN*InOut.WriteString ('  zerobased'); InOut.WriteLn;(END&END$END;$$InOut.Read (ch)"END showExpr;  PROCEDURE showExprStack;"VAR ch: CHAR; c: ExprSP;"BEGIN$InOut.WriteLn;$InOut.WriteString ('** exprStack Begin **'); InOut.WriteLn;$c:= exprSp;$WHILE c >= 0 DO&showExpr (exprStack[c].expr);&DEC (c)$END;$InOut.WriteString ('** exprStack End **'); InOut.WriteLn;$InOut.Read (ch)"END showExprStack; *)  PROCEDURE Move (s, d: ADDRESS; n: LONGCARD);"BEGIN$(* diese Routine muû in beiden Richtungen mit öberlappungen klarkommen *)$Block.Copy (s, n, d) (* <- die hier tut's *)"END Move;  PROCEDURE Clear (d: ADDRESS; n: CARDINAL);"BEGIN$ASSEMBLER(MOVE    n(A6),D0(MOVE.L  d(A6),A0(BRA     c&l CLR.B   (A0)+&c DBRA    D0,l$END"END Clear;  PROCEDURE swapBytes (VAR set: ShortSet; n: CARDINAL);"BEGIN$ASSEMBLER(CMPI.W  #1,n(A6)(BEQ     ok(MOVE.L  set(A6),A0(CMPI.W  #2,n(A6)(BEQ     wd(MOVE.L  (A0),D0(ROR.W   #8,D0(SWAP    D0(ROR.W   #8,D0(MOVE.L  D0,(A0)(RTS%wd MOVE.W  2(A0),D0(ROR.W   #8,D0(MOVE.W  D0,2(A0)%ok$END"END swapBytes;   PROCEDURE bitInOptions (n: CARDINAL): BOOLEAN;"VAR rangeCheck: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(MOVE.W  n(A6),D1(BTST    D1,D0(SNE     D0(ANDI    #1,D0(MOVE    D0,rangeCheck(A6)$END;$RETURN rangeCheck"END bitInOptions;  PROCEDURE warningsActive (): BOOLEAN;"VAR w: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #23,D0          ; $W(SNE     D0(ANDI    #1,D0(MOVE    D0,w(A6)$END;$RETURN w"END warningsActive;  PROCEDURE suppressOpt (): BOOLEAN;"VAR b: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #10,D0          ; $J(SEQ     D0(ANDI    #1,D0(MOVE    D0,b(A6)$END;$RETURN b"END suppressOpt;  PROCEDURE stackCheckActive (): BOOLEAN;"VAR rangeCheck: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #19,D0          ; $S(SNE     D0(ANDI    #1,D0(MOVE    D0,rangeCheck(A6)$END;$RETURN rangeCheck"END stackCheckActive;  PROCEDURE rangeCheckActive (): BOOLEAN;"VAR rangeCheck: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #18,D0          ; $R(SNE     D0(ANDI    #1,D0(MOVE    D0,rangeCheck(A6)$END;$RETURN rangeCheck"END rangeCheckActive;  PROCEDURE overflowCheckActive (): BOOLEAN;"BEGIN$RETURN rangeCheckActive ()"END overflowCheckActive;  PROCEDURE generateDebugCode (): BOOLEAN;"VAR flag: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #04,D0          ; $D(SNE     D0(ANDI    #1,D0(MOVE    D0,flag(A6)$END;$RETURN flag"END generateDebugCode;  PROCEDURE extendedSyntax (): BOOLEAN;"VAR flag: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #01,D0          ; $A(SNE     D0(ANDI    #1,D0(MOVE    D0,flag(A6)$END;$RETURN flag"END extendedSyntax;   PROCEDURE makeUndef (VAR expr: ExprDesc);"BEGIN$expr.exprSize:= Size (expr);$expr.item:= UndefTyp"END makeUndef;   PROCEDURE SetSize (VAR expr: ExprDesc; size: LONGCARD);"(*#* Setzt Grîûe des Datums, wandelt ggf. nach UndefTyp (ist nîtig,#* wenn Aufruf von syncConstant, wenn ein CHAR als Parm Åbergeben wird).#*)"BEGIN$IF (expr.item # SSTyp) & (expr.item # UndefTyp) THEN&makeUndef (expr)$ELSE&expr.exprSize:= size$END"END SetSize;   PROCEDURE isOpenArray (type: PtrItem): BOOLEAN;"(*$L-*)"BEGIN$ASSEMBLER(; RETURN (ItemNo (type) = 32) OR (ItemNo (type) = 42)(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  -1(A0),D0(CMPI.B  #32,D0(BEQ     OK(CMPI.B  #42,D0%OK SEQ     D0(ANDI    #1,D0$END"END isOpenArray;"(*$L=*)  PROCEDURE isLongOpenArray (type: PtrItem): BOOLEAN;"(*$L-*)"BEGIN$ASSEMBLER(; RETURN ItemNo (type) = 42(MOVE.L  -(A3),A0(ADDA.L  TreeBase,A0(MOVE.B  -1(A0),D0(CMPI.B  #42,D0(SEQ     D0(ANDI    #1,D0$END"END isLongOpenArray;"(*$L=*)   PROCEDURE card16ZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert in CARDINAL paût *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (x.v <= LONG (MAX (CARDINAL))) & (x.v >= 0L)(MOVE.L  -(A3),D1        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     false(CMPI.L  #$FFFF,D1(SLS     D0(ANDI    #1,D0(RTS&false:(CLR     D0$END"END card16ZZ;"(*$L=*)  PROCEDURE int16ZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert in INTEGER paût *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (x.v <= LONG (MaxInt)) & (x.v >= LONG (MinInt))(MOVE.L  -(A3),D1        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     false(MOVE.W  D1,A0(CMPA.L  D1,A0(SEQ     D0(ANDI    #1,D0(RTS&false:(CLR     D0$END"END int16ZZ;"(*$L=*)  PROCEDURE int8ZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert in Byte paût *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (x.v <= 127L) & (x.v >= -128L)(MOVE.L  -(A3),A0        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     false(ADDA.W  #128,A0(CMPA.W  #$FF,A0(SLS     D0(ANDI    #1,D0(RTS&false:(CLR     D0$END"END int8ZZ;"(*$L=*)  PROCEDURE int3ZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert fÅr ADDQ paût#* Vorsicht! Damit ist auch der Wert +8 zugelassen, Null aber auch! *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (ABS (x.v) <= 8L)(MOVE.L  -(A3),A0        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     false(ADDQ.L  #8,A0(CMPA.W  #16,A0(SLS     D0(ANDI    #1,D0(RTS&false:(CLR     D0$END"END int3ZZ;"(*$L=*)  PROCEDURE card8ZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert in Byte paût *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (x.v <= 255L) & (x.v >= 0L)(MOVE.L  -(A3),A0        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     false(CMPA.W  #$FF,A0(SLS     D0(ANDI    #1,D0(RTS&false:(CLR     D0$END"END card8ZZ;"(*$L=*)  PROCEDURE nullZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert Null ist *)"(*$L-*)"BEGIN$ASSEMBLER(;RETURN NOT x.over & (x.v = 0L)(MOVE.L  -(A3),D1        ;x.v(BNE     falsev(MOVE.W  -(A3),D0        ;x.over(BNE     false(MOVEQ   #1,D0(RTS&falsev:(SUBQ.L  #2,A3&false:(CLR     D0$END"END nullZZ;"(*$L=*)  PROCEDURE sizeZZ (x: ZZ): CARDINAL;"(*$L-*)"BEGIN$(*&IF x.over THEN(RETURN 4&ELSIF (x.v <= 255L) & (x.v >= -128L) THEN(RETURN 1&ELSIF (x.v <= LONGINT (LONG (MaxCard))) & (x.v >= LONG (MinInt)) THEN(RETURN 2&ELSE(RETURN 4&END$*)$ASSEMBLER(MOVE.L  -(A3),A0        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     four(CMPA.W  #255,A0(BGT     noone(CMPA.W  #-128,A0(BGE     one&noone:(CMPA.L  #65535,A0(BGT     four(CMPA.W  #-32768,A0(BLT     four(MOVEQ   #2,D0(RTS&one:(MOVEQ   #1,D0(RTS&four:(MOVEQ   #4,D0$END"END sizeZZ;"(*$L=*)  PROCEDURE sizeZZeven (x: ZZ): CARDINAL;"(*#* wie 'sizeZZ', nur wird nie 1 geliefert, sondern dann 2#*)"(*$L-*)"BEGIN$(*&IF x.over THEN(RETURN 4&ELSIF (x.v <= LONGINT (LONG (MaxCard))) & (x.v >= LONG (MinInt)) THEN(RETURN 2&ELSE(RETURN 4&END$*)$ASSEMBLER(MOVE.L  -(A3),A0        ;x.v(MOVE.W  -(A3),D0        ;x.over(BNE     four(CMPA.L  #65535,A0(BGT     four(CMPA.W  #-32768,A0(BLT     four(MOVEQ   #2,D0(RTS&four:(MOVEQ   #4,D0$END"END sizeZZeven;"(*$L=*)" PROCEDURE toZZ (l: LONGWORD; signed: BOOLEAN): ZZ;"VAR x: ZZ;"(*$L-*)"BEGIN$ASSEMBLER(; x.v:= LONGINT (l);(; x.over:= NOT signed & (x.v < 0L);(; RETURN x(MOVE.W  -(A3),D0        ;signed(BNE     notOver(MOVE.L  -(A3),D1        ;l(BPL     notOver2(MOVE    #1,(A3)+        ;x.over(MOVE.L  D1,(A3)+        ;x.v(RTS&notOver:(MOVE.L  -(A3),D1        ;l&notOver2:(CLR     (A3)+           ;x.over(MOVE.L  D1,(A3)+        ;x.v$END"END toZZ;"(*$L=*)  PROCEDURE expandToZZ (itemNo: CARDINAL; VAR x: ZZ);"(* setzt bei nicht-LONGINTs das over-Flag, falls Wert > 2^31 *)"BEGIN$IF itemNo # 4 THEN&x.over:= (itemNo # 1) & (x.v < 0)$END"END expandToZZ;  PROCEDURE posZZ (x: ZZ): BOOLEAN;"(* TRUE, wenn Wert positiv *)"(*$L-*)"BEGIN$ASSEMBLER(; RETURN x.over OR (x.v >= 0L)(MOVE.L  -(A3),D1(MOVE.W  -(A3),D0(BNE     over(TST.L   D1(SPL     D0(ANDI    #1,D0&over:$END"END posZZ;"(*$L=*)  PROCEDURE negZZ (VAR x: ZZ);"(*$L-*)"BEGIN$ASSEMBLER(; IF x.over THEN SyntaxError (rAriOv) END;(; x.v:= -x.v;(MOVE.L  -(A3),A0(TST.W   ZZ.over(A0)(BNE     over(NEG.L   ZZ.v(A0)(RTS&over:$END;$SyntaxError (rAriOv)"END negZZ;"(*$L=*)  PROCEDURE intZZ (x: ZZ): LONGINT;"(*$L-*)"BEGIN$ASSEMBLER(; IF x.over THEN SyntaxError (rAriOv) END;(; RETURN x.v(MOVE.L  -(A3),D0        ;x.v(TST.W   -(A3)           ;x.over(BNE     over(RTS&over:$END;$SyntaxError (rAriOv)"END intZZ;"(*$L=*)  PROCEDURE cardZZ (x: ZZ): LONGCARD;"(*$L-*)"BEGIN$ASSEMBLER(; IF NOT x.over & (x.v < 0L) THEN SyntaxError (rAriOv) END;(; RETURN x.l(MOVE.L  -(A3),D0        ;x.v(BPL     ok(TST.W   -(A3)           ;x.over(BEQ     over(RTS&ok:(SUBQ.L  #2,A3(RTS&over:$END;$SyntaxError (rAriOv)"END cardZZ;"(*$L=*)  PROCEDURE shortInt (x: LONGWORD): BOOLEAN;"(* TRUE, wenn Wert in INTEGER paût *)"(*$L-*)"BEGIN$ASSEMBLER(; RETURN (LONGINT (x) <= LONG (MaxInt)) & (LONGINT (x) >= LONG (MinInt))(MOVE.L  -(A3),D0        ;x(MOVE.W  D0,A0(CMPA.L  D0,A0(SEQ     D0(AND     #1,D0$END"END shortInt;"(*$L=*)  PROCEDURE byteVal (x: LONGWORD): BOOLEAN;"(* TRUE, wenn Wert in BYTE (mit Vorzeichen!) paût *)"(*$L-*)"BEGIN$ASSEMBLER(; RETURN (LONGINT (x) <= 127L) & (LONGINT (x) >= -128L)(MOVE.L  -(A3),A0        ;x(ADDA.W  #128,A0(CMPA.W  #255,A0(SLS     D0(ANDI    #1,D0$END"END byteVal;"(*$L=*)  PROCEDURE lowByte (x: LONGINT): CARDINAL;"(* Returns Low-Byte: 0-255 *)"(*$L-*)"BEGIN$ASSEMBLER(MOVE.L  -(A3),D0(ANDI    #$FF,D0$END"END lowByte;"(*$L=*)  PROCEDURE addZZ (VAR l: ZZ; r: ZZ);"VAR overflow: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  l(A6),A0(LEA     r(A6),A1(MOVE.W  ZZ.over(A1),D1(BNE     ok10(TST.L   ZZ.v(A1)(BPL     ok1&ok10(SUBQ    #1,D1&ok1(MOVE.L  ZZ.v(A0),D2(MOVE.W  ZZ.over(A0),D0(BNE     ok20(TST.L   D2(BPL     ok2&ok20(SUBQ    #1,D0&ok2(ADD.L   ZZ.v(A1),D2(MOVE.L  D2,ZZ.v(A0)(ADDX.W  D1,D0(BPL     ok3(ADDQ    #1,D0           ; wenn Erg neg, muû high-Word $FFFF sein(BNE     over(TST.L   D2              ; ZZ.v muû natÅrlich auch neg. sein(BPL     over(BRA     ok&ok3(TST     D0(BNE     over            ; High-word muû sonst erstmal Null sein(TST.L   D2(BPL     ok(MOVEQ   #1,D0&ok(MOVE.W  D0,ZZ.over(A0)(CLR     overflow(A6)(BRA     ende&over(MOVE    #1,overflow(A6)&ende$END;$IF overflow THEN SyntaxError (rAriOv) END"END addZZ;  PROCEDURE subZZ (VAR l: ZZ; r: ZZ);"VAR overflow: BOOLEAN;"BEGIN$ASSEMBLER(MOVE.L  l(A6),A0(LEA     r(A6),A1(MOVE.W  ZZ.over(A1),D1(BNE     ok10(TST.L   ZZ.v(A1)(BPL     ok1&ok10(SUBQ    #1,D1&ok1(MOVE.L  ZZ.v(A0),D2(MOVE.W  ZZ.over(A0),D0(BNE     ok20(TST.L   D2(BPL     ok2&ok20(SUBQ    #1,D0&ok2(SUB.L   ZZ.v(A1),D2(MOVE.L  D2,ZZ.v(A0)(SUBX.W  D1,D0(BPL     ok3(ADDQ    #1,D0           ; wenn Erg neg, muû high-Word $FFFF sein(BNE     over(TST.L   D2              ; ZZ.v muû natÅrlich auch neg. sein(BPL     over(BRA     ok&ok3(TST     D0(BNE     over            ; High-word muû sonst erstmal Null sein(TST.L   D2(BPL     ok(MOVEQ   #1,D0&ok(MOVE.W  D0,ZZ.over(A0)(CLR     overflow(A6)(BRA     ende&over(MOVE    #1,overflow(A6)&ende$END;$IF overflow THEN SyntaxError (rAriOv) END"END subZZ;  PROCEDURE cmpZZ (l: ZZ; r: ZZ): Relation;"(* liefert 'eq', 'lt' oder 'gt' *)"VAR rel: Relation;"BEGIN$ASSEMBLER(LEA     l(A6),A0(LEA     r(A6),A1(MOVE.W  ZZ.over(A1),D1(BNE     ok10(TST.L   ZZ.v(A1)(BPL     ok1&ok10(SUBQ    #1,D1&ok1(MOVE.L  ZZ.v(A0),D2(MOVE.W  ZZ.over(A0),D0(BNE     ok20(TST.L   D2(BPL     ok2&ok20(SUBQ    #1,D0&ok2(SUB.L   ZZ.v(A1),D2(SUBX.W  D1,D0(BPL     ok3(MOVEQ   #lt,D0(BRA     ok&ok3(BNE     plu(MOVEQ   #eq,D0(BRA     ok&plu(MOVEQ   #gt,D0&ok(MOVE    D0,rel(A6)&ende$END;$RETURN rel"END cmpZZ;  PROCEDURE inZZ (x, lo, hi: ZZ): BOOLEAN;"(* TRUE, wenn  lo <= x <= hi  *)"BEGIN$(*$? Safety: assert (ORD (x.over) < 2); *)$(*$? Safety: assert (ORD (lo.over) < 2); *)$(*$? Safety: assert (ORD (hi.over) < 2); *)$RETURN (cmpZZ (x, lo) # lt) & (cmpZZ (hi, x) # lt)"END inZZ;" PROCEDURE diffZZ (l: ZZ; r: ZZ): LONGCARD;"BEGIN$(*$? Safety: assert (ORD (l.over) < 2); *)$(*$? Safety: assert (ORD (r.over) < 2); *)$subZZ (l, r);$IF NOT posZZ (l) THEN SyntaxError (rAriOv) END;$RETURN l.l"END diffZZ;  PROCEDURE mulZZ (VAR l: ZZ; r: ZZ);"BEGIN$(*$? Safety: assert (ORD (l.over) < 2); *)$(*$? Safety: assert (ORD (r.over) < 2); *)$IF nullZZ (l) OR (cmpZZ (r, toZZ (1L, FALSE)) = eq) THEN&(* l bleibt *)$ELSIF nullZZ (r) OR (cmpZZ (l, toZZ (1L, FALSE)) = eq) THEN&l:= r$ELSIF r.over OR l.over THEN&IF SignalOverflow THEN(SyntaxError (rAriOv)&ELSE(HasOverflown:= TRUE&END$ELSE&l.v:= l.v * r.v;$END;"END mulZZ;  PROCEDURE divZZ (VAR l: ZZ; r: ZZ);"BEGIN$(*$? Safety: assert (ORD (l.over) < 2); *)$(*$? Safety: assert (ORD (r.over) < 2); *)$IF r.over THEN&IF NOT l.over THEN(l:= toZZ (0L, FALSE)&ELSE(l.l:= l.l DIV r.l;(l.over:= l.v < 0L&END$ELSIF l.over THEN&IF (NOT r.over & (r.l < 0L)) THEN(l.v:= l.l DIV LONGCARD (ABS (r.v)); (* hier ist Range-Error mîglich *)(l.over:= FALSE&ELSE(l.l:= l.l DIV r.l;(l.over:= l.v < 0L&END$ELSE&l.v:= l.v DIV r.v$END;"END divZZ;  PROCEDURE modZZ (VAR l: ZZ; r: ZZ);"(* Achtung bei neg. Werten!!! Da wird ggf. falsch gerundet?!#* >> auch remZZ und entspr. div-routine erstellen! *)"VAR z: ZZ;"BEGIN$(*$? Safety: assert (ORD (l.over) < 2); *)$(*$? Safety: assert (ORD (r.over) < 2); *)$(* l:= l - l / r * r *)$z:= l;$divZZ (z, r);$mulZZ (z, r);$subZZ (l, z);"END modZZ;  PROCEDURE makeMask (lo, hi: CARDINAL): LONGCARD;"VAR res: LONGCARD;"BEGIN$ASSEMBLER(MOVEQ   #0,D2(MOVE.W  lo(A6),D0(MOVE.W  hi(A6),D1&L CMP.W   D1,D0(BHI     E(BSET    D0,D2(ADDQ    #1,D0(BRA     L&E MOVE.L  D2,res(A6)$END;$RETURN res"END makeMask;  PROCEDURE makeInvMask (lo, hi: CARDINAL): LONGCARD;"VAR res: LONGCARD;"BEGIN$res:= makeMask (lo, hi);$ASSEMBLER(MOVE.L  res(A6),D0(NOT.L   D0(MOVE.L  D0,res(A6)$END;$RETURN res"END makeInvMask;  PROCEDURE longSignedType (type: PtrItem): BOOLEAN;"(*#* TRUE, wenn Type Long oder ShortCard ist;#* FALSE, wenn ShortInt, ShortBoth oder Byte; Error, wenn grîûer#*)"BEGIN$(*$? Safety: assert (TypeLength (type) <= 4); *)$RETURN (TypeLength (type) = 4) OR (ItemNo (HostType (type)) = 34)"END longSignedType;   PROCEDURE constSize (VAR expr: ExprDesc): CARDINAL;"(* liefert die Grîûe der Konstanten in Bytes. *)"VAR (*$Reg*)l: LONGCARD;"BEGIN$(*$? Safety: assert (expr.kind = constant); *)$IF expr.item = ZZTyp THEN&WITH expr.exprConst DO(IF card8ZZ (zz) OR int8ZZ (zz) THEN*RETURN 1(ELSIF card16ZZ (zz) OR int16ZZ (zz) THEN*RETURN 2(ELSE*RETURN 4(END&END$ELSE&RETURN SHORT (Size (expr))$END"END constSize;  PROCEDURE exprSize (VAR expr: ExprDesc): LONGCARD;"BEGIN$IF expr.kind = constant THEN&RETURN LONG (constSize (expr))$ELSE&RETURN Size (expr)$END"END exprSize;  PROCEDURE signedType (type: PtrItem): BOOLEAN;"VAR (*$Reg*)n: CARDINAL;"BEGIN$n:= ItemNo (HostType (type));$(*$? Safety: assert (n # 4); (* hier hÑngt's vom Wert ab.. *) *)$RETURN (n=1) OR (n=33) OR (n=39)"END signedType;  PROCEDURE signedConst (type: PtrItem; const: ZZ): BOOLEAN;"VAR (*$Reg*)n: CARDINAL;"BEGIN$n:= ItemNo (HostType (type));$IF n = 4 THEN&RETURN NOT posZZ (const)$ELSE&RETURN (n=1) OR (n=33) OR (n=39)$END"END signedConst;  PROCEDURE signedExpr (REF expr: ExprDesc): BOOLEAN;"VAR (*$Reg*)n: CARDINAL;"BEGIN$n:= ItemNo (HostType (expr.item));$IF n = 4 THEN&(*$? Safety: assert (expr.kind = constant); *)&RETURN NOT posZZ (expr.exprConst.zz)$ELSE&RETURN (n=1) OR (n=33) OR (n=39)$END"END signedExpr;    (*!* allg. Routinen, z.B. fÅr 'ExprDesc'!*)   PROCEDURE sizedItem (n: CARDINAL; signed: BOOLEAN): PtrItem;"VAR (*$Reg*)r: PtrItem;"BEGIN$CASE n OF$| 1: IF signed THEN r:= BytIPtr ELSE r:= CharPtr END$| 2: IF signed THEN r:= SIntPtr ELSE r:= SCardPtr END$| 4: IF signed THEN r:= IntPtr ELSE r:= CardPtr END$END;$RETURN r"END sizedItem;   PROCEDURE isJoker (t: PtrItem): BOOLEAN;"BEGIN$RETURN ItemNo (t) IN ItemSet {21,26,38,39};"END isJoker;  PROCEDURE jokerSize (itemNo: CARDINAL): CARDINAL;"BEGIN$IF (itemNo = 38 (* BYTE *)) OR (itemNo = 39 (* signed BYTE *)) THEN&RETURN 1$ELSIF itemNo = 21 (* WORD *) THEN&RETURN 2$ELSIF itemNo = 26 (* LONG *) THEN&RETURN 4$END;$RETURN 0"END jokerSize;   PROCEDURE roundedUp (l: LONGCARD): LONGCARD;"BEGIN$IF ODD (l) THEN RETURN l+1L ELSE RETURN l END"END roundedUp;  PROCEDURE roundUp (VAR l: LONGCARD);"BEGIN$IF ODD (l) THEN INC (l) END"END roundUp;  PROCEDURE roundUpCard (VAR l: CARDINAL);"BEGIN$IF ODD (l) THEN INC (l) END"END roundUpCard;"  PROCEDURE roundedSize (VAR expr: ExprDesc): LONGCARD;"VAR (*$Reg*)n: LONGCARD;"BEGIN$n:= Size (expr);$IF ODD (n) & (expr.kind = stack) THEN&INC (n)$END;$RETURN n"END roundedSize;   (* ----------------------------------------------------------------------- *) (*   Code erzeugende Routinen  *)  (*"MODULE codeGen;""IMPORT$ASSEMBLER, ADDRESS, ADR, TSIZE, BYTE, WORD, LONGWORD,$Operator, ExprDesc, BS, TypeLength, BoolPtr, PtrSet,$PtrFullSet, rOpTyp, SyntaxError, ItemNo,$SuppressCode, toZZ, addZZ, subZZ, divZZ, mulZZ, modZZ, ExprKind,$OpSet, CodePtr, SetCodePtr, assert, bong, shortInt, MemModes,$Label, PutCode, coding, PtrItem, RegType, lowByte, byteVal,$ZZ, rStruc, LastVarLink, SetVarLink, Code, LastProcLink, SetProcLink,$BooleanType, CardPtr, rBranc, rExOvr, Directions,$D0,D1,D2,D7,A0,A2,A3,A4,A5,A6,A7,F0,F2,F7;""EXPORT$EXTW, EXTL, ADDA, TST, TRAPV, Bcc, SWAP, ADD, ASLI, MULS, MULU, BRA,$CHK, NEGL, LastDataRelocAdr,$genMOVEir, ToHere, genClrReg, genMOVEQ, genMOVEar,$genMOVErr, genADDA, genADDAL, genia, genPEA, gena, genar, genarSized,$gen, genr, genir, genBool, genbcc, genQ, genPush, genPullReg, genMOVErind,$genPushAddress, genLEA, genLEAabs, genLEApcrel, genLEArel, genMOVELIndTo; *)  VAR"LastDataRelocAdr: POINTER TO LONGCARD;  CONST "ADD   = $D000;"ADDA  = $D000;"ADDI  = $0600;"ADDQ  = $5000;"AND_  = $C000;"ANDI  = $0200;"ASR   = $E020;"ASRI  = $E000;"ASLI  = $E100;"BRA   = $6000;"Bcc   = $6000;"BCLR  = $0180;"BCLRI = $0880;"BSET  = $01C0;"BSETI = $08C0;"BSR   = $6100;"BTST  = $0100;"BTSTI = $0800;"CHK   = $4180;"CLR   = $4200;"CLRW  = $4240;"CMP   = $B000;"CMPAL = $B1C0;"CMPI  = $0C00;"DBcc  = $50C8;"DIVS  = $81C0;"DIVU  = $80C0;"EOR   = $B100;"EORI  = $0A00;"EXG   = $C100;"EXTW  = $4880;"EXTL  = $48C0;"JSR   = $4E00;"LEA   = $4000; (* $01C0 wird z.B. in 'genar' addiert *)"LSLI  = $E108;"LSRI  = $E008;"MOVE  = $0000;"MOVEML= $48C0;"MULS  = $C1C0;"MULU  = $C0C0;"NEG   = $4400;"NEGL  = $4480;"NOP   = $4E71;"NOT_  = $4600;"OR_   = $8000;"OR2   = $8100;"PEA   = $4840;"ROL   = $E138;"ROLI  = $E118;"RORI  = $E018;"SCC   = $50C0;"SUB   = $9000;"SUBI  = $0400;"SUBQ  = $5100;"SWAP  = $4840;"TRAP  = $4E40;"TRAPV = $4E76;"TST   = $4A00; "FGET  = $0000; (* FMOVE <ea>,FPn *)"FPUT  = $2000; (* FMOVE FPn,<ea>, $4000 wird durch 'Fea' addiert *)"FMOVEM= $C000;"FABS  = $0018;"FNEG  = $001A;"FADD  = $0022;"FSUB  = $0028;"FMUL  = $0023;"FDIV  = $0020;"FCMP  = $0038;"FBEQ  = 000001%;"FBNE  = 001110%;"FBLE  = 010101%;"FBGE  = 010011%;"FBLT  = 010100%;"FBGT  = 010010%;   PROCEDURE mapCC (op: Operator; signed, negate: BOOLEAN): CARDINAL;"(*#* Vorsicht: wenn 'op = cc' und 'signed = TRUE', wird VC generiert!#* Das ist also fÅr echte öberlauf-Tests gedacht (z.B. bei Addition, usw)!#* Wenn dagegen eigentlich ein grîûer/kleiner-Test erfolgen soll,#* muû ein op aus le, ge, lt, gt ausgewÑhlt werden. Dann wird#* bei NOT signed ggf. zwar auch CC erzeugt, bei signed Test dafÅr#* dann aber GE.#*)"VAR x: CARDINAL;"BEGIN$CASE op OF$| eq: x:= $700$| ne: x:= $600$| cc: IF signed THEN x:= $800 ELSE x:= $400 END$| pl: x:= $A00$| le: IF signed THEN x:= $F00 ELSE x:= $300 END$| ge: IF signed THEN x:= $C00 ELSE x:= $400 END$| lt: IF signed THEN x:= $D00 ELSE x:= $500 END$| gt: IF signed THEN x:= $E00 ELSE x:= $200 END$ELSE&bong$END;$IF negate THEN&ASSEMBLER(MOVE    x(A6),D0(BCHG    #8,D0(MOVE    D0,x(A6)&END$END;$RETURN x"END mapCC;  PROCEDURE mapFPUcc (op: Operator; negate: BOOLEAN): CARDINAL;"(*#* FÅr FPU. Mit Exception, wenn unordered.#*)"VAR m: CARDINAL;"BEGIN$CASE op OF&eq:  m:= FBEQ|&ne:  m:= FBNE|&le:  m:= FBLE|&ge:  m:= FBGE|&lt:  m:= FBLT|&gt:  m:= FBGT|$ELSE&bong$END;$IF negate THEN&ASSEMBLER(MOVE    m(A6),D0(EORI    #$F,D0(MOVE    D0,m(A6)&END$END;$RETURN m"END mapFPUcc;  PROCEDURE mapAlways (): CARDINAL;"(*$L-*)"BEGIN$ASSEMBLER(;RETURN 0(CLR     D0$END"END mapAlways;"(*$L=*)  PROCEDURE mapNever(): CARDINAL;"(*$L-*)"BEGIN$ASSEMBLER(;RETURN $100(MOVE    #$100,D0$END"END mapNever;"(*$L=*)  PROCEDURE mapTRUE (negate: BOOLEAN): CARDINAL;"(*$L-*)"BEGIN$ASSEMBLER(;IF negate THEN x:= $700 ELSE x:= $600 END;(;RETURN x(TST     -(A3)(BNE     neg(MOVE    #$600,D0(RTS#neg: MOVE    #$700,D0$END"END mapTRUE;"(*$L=*)  PROCEDURE mapFALSE (negate: BOOLEAN): CARDINAL;"(*$L-*)"BEGIN$ASSEMBLER(;IF negate THEN x:= $600 ELSE x:= $700 END;(;RETURN x(TST     -(A3)(BNE     neg(MOVE    #$700,D0(RTS#neg: MOVE    #$600,D0$END"END mapFALSE;"(*$L=*)   PROCEDURE Fea (REF expr: ExprDesc; VAR ea: BOOLEAN): CARDINAL;"VAR (*$Reg*)size: CARDINAL;"BEGIN$IEEERuntimeCall;$IF (expr.kind = register) & (expr.exprReg >= F0) THEN&ea:= FALSE;&RETURN (expr.exprReg - F0) * $400$ELSE&ea:= TRUE;&size:= SHORT (Size (expr));&IF size = SizeOfShortReal THEN(RETURN $4400&ELSE((*$? Safety: assert (size = SizeOfLongReal); *)(RETURN $5400&END$END"END Fea;  PROCEDURE Freg (reg: RegType): CARDINAL;"BEGIN$(*$? Safety: assert (reg >= F0); *)$IEEERuntimeCall;$RETURN (reg - F0) * $80"END Freg;  PROCEDURE getFPUop (VAR source: ExprDesc; destReg: RegType;4op: Operator; isrel: BOOLEAN;4VAR n, m: CARDINAL; VAR ea: BOOLEAN);"BEGIN$IEEERuntimeCall;$IF isrel THEN&n:= FCMP$END;$CASE op OF&add: n:= FADD|&sub: n:= FSUB|&mul: n:= FMUL|&rdiv:n:= FDIV|&eq:  m:= FBEQ|&ne:  m:= FBNE|&le:  m:= FBLE|&ge:  m:= FBGE|&lt:  m:= FBLT|&gt:  m:= FBGT|$ELSE&SyntaxError (rOpTyp)$END;$INC (n, Fea (source, ea) + Freg (destReg));"END getFPUop;   PROCEDURE updateStackOffsets (stackReg: RegType; up: BOOLEAN; size: LONGINT);"BEGIN$(*$? Safety: assert (size # 0L); *)$IF stackReg = A7 THEN&IF ODD (size) THEN INC (size) END;&IF up THEN(INC (A7Offset, size)&ELSE(DEC (A7Offset, size)&END$ELSIF stackReg = A3 THEN&IF up THEN(INC (A3Offset, size)&ELSE(DEC (A3Offset, size)&END$END;"END updateStackOffsets;   TYPE codeDesc = RECORD2extSize: INTEGER;2CASE : CARDINAL OF42: extWord: WORD|44: extLong: LONGWORD|48: extDouble: RR|2END;2reloc: BOOLEAN0END;  PROCEDURE getSrcEA (VAR src: ExprDesc;4size: INTEGER;4VAR opcode: CARDINAL;4VAR code: codeDesc);"VAR (*$Reg*)l: LONGINT;"BEGIN$WITH src DO&WITH code DO(reloc:= FALSE;(extSize:= 0;(CASE kind OF(| constRef:,bong () (* sollte nach 'constImm' gewandelt sein *)(| constImm:,INC (opcode, 111100%);   (* immediate mode *),reloc:= TRUE;(| constant:,INC (opcode, 111100%);,IF size <= 0 THEN size:= SHORT (Size (src)) END;,extSize:= size;,IF size <= 2 THEN.extSize:= 2;.extWord:= exprConst.w,ELSIF size = 4 THEN.extLong:= exprConst.l,ELSIF size = 8 THEN.extDouble:= exprConst.rr,ELSE.bong,END(| register:,(*$? Safety: assert (exprReg < F0); *),INC (opcode, exprReg)(| memory:,CASE mode OF,| pcRel:  INC (opcode, 111010%);   (* pc-rel *)6extSize:= 2;6l:= LONGINT (absAddr) - LONGINT (CodePtr ());6IF coding() & (l < LONG (MinInt)) THEN8(* branch too long *)8SyntaxError (rBranc)6END;6extWord:= WORD (SHORT (l));,| relRef: INC (opcode, 111010%);   (* pc-rel m. Reloc *)6reloc:= TRUE;,| immRef: INC (opcode, 111100%);   (* immediate m. Reloc *)6reloc:= TRUE;,| absRef: INC (opcode, 111001%);   (* absolut long m. Reloc *)6reloc:= TRUE;,| extL:   IF shortInt (extAddr) THEN8INC (opcode, 111000%); (* absolute word *)8extSize:= 2;8extWord:= WORD (SHORT (LONGINT (extAddr)))6ELSE8INC (opcode, 111001%); (* absolute long *)8extSize:= 4;8extLong:= LONGWORD (extAddr)6END,| d16An:  (*$? Safety2: assert (shortInt (disp)); *)6IF disp = 0L THEN8INC (opcode, 010000% + baseReg - A0);6ELSE8INC (opcode, 101000% + baseReg - A0);8extSize:= 2;8extWord:= WORD (SHORT (disp))6END,| d8AnXn: (*$? Safety2: assert (byteVal (disp)); *)6INC (opcode, 110000% + baseReg - A0);6extSize:= 2;6extWord:= WORD (lowByte (disp)K+ (idxReg) * $1000K+ $800 * ORD (idxL)),ELSE.bong (* dann ist's ptrOnA3/A7 -- muû schon vorher4*                          ausgewertet werden! *),END(| stack:,IF size = 0 THEN size:= SHORT (Size (src)) END;,(*$? Safety: assert (stackReg IN (tempRegs + RegSet {A3,A7})); *),updateStackOffsets (stackReg, up, ABS (size));,IF up THEN.INC (opcode, 011000%),ELSE.INC (opcode, 100000%),END;,INC (opcode, stackReg-A0);(END&END$END"END getSrcEA;   PROCEDURE sizedAt6 (opcode: CARDINAL): BOOLEAN;"(* TRUE, wenn bereits Size-Angabe in Bits 6&7 enthalten *)"BEGIN$RETURN (opcode DIV 64 MOD 4) # 0"END sizedAt6;  PROCEDURE sizeAt6 (size: CARDINAL): CARDINAL;"BEGIN$IF size = 2 THEN&RETURN 40H$ELSIF size = 4 THEN&RETURN 80H$ELSIF size = 1 THEN&RETURN 00H$END;"END sizeAt6;  PROCEDURE getSizeAt6 (size: LONGINT; VAR opcode: CARDINAL);"BEGIN$IF size < 0L THEN&(* nix *)$ELSIF size = 2L THEN&INC (opcode, 40H)$ELSIF size = 4L THEN&INC (opcode, 80H)$ELSIF size # 1L THEN&bong ();$END;"END getSizeAt6;  PROCEDURE getAnSize (VAR dest: ExprDesc; VAR opcode: CARDINAL);"(* size f. Instr. wie ADDA, LEA, usw. ermitteln *)"VAR (*$Reg*)size: LONGCARD;"BEGIN$size:= Size (dest);$IF size = 2L THEN&INC (opcode, $C0)$ELSIF size = 4L THEN&INC (opcode, $1C0)$ELSE&bong;$END;"END getAnSize;  PROCEDURE AnSized (size: LONGCARD): CARDINAL;"(* size f. Instr. wie ADDA, LEA, usw. ermitteln *)"BEGIN$IF size = 2L THEN&RETURN $C0;$ELSIF size = 4L THEN&RETURN $1C0;$ELSE&bong;$END;"END AnSized;  PROCEDURE sizedMOVE (size: LONGCARD): CARDINAL;"VAR (*$Reg*)opcode: CARDINAL;"BEGIN$IF    size = 2L THEN opcode:= $3000$ELSIF size = 4L THEN opcode:= $2000$ELSIF size = 1L THEN opcode:= $1000$ELSE bong END;$RETURN opcode"END sizedMOVE;  PROCEDURE getSizeForMOVE (VAR dest: ExprDesc; VAR opcode: CARDINAL);"BEGIN$INC (opcode, sizedMOVE (Size (dest)))"END getSizeForMOVE;  PROCEDURE getDestReg (reg: RegType; VAR opcode: CARDINAL);"BEGIN$IF reg < A0 THEN&INC (opcode, reg * $200)$ELSE&(*$? Safety: assert (reg < F0); *)&INC (opcode, (reg-A0) * $200 + $40)$END;"END getDestReg;   PROCEDURE RelocRef (REF expr: ExprDesc);"(* sieht Ref. f. Table/Proc/Var-Relozierung vor *)""PROCEDURE putw (l: LONGWORD);$BEGIN&(*$? Safety: assert (LONGINT (l) < 0L); *)&IF LONGINT (l) < LONG (MinInt) THEN SyntaxError (rBranc) END;&PutCode (SHORT (LONGINT (l)))$END putw;""PROCEDURE pokeL (addr: ADDRESS; l: LONGWORD);$VAR pl: POINTER TO LONGWORD;$BEGIN&pl:= addr;&pl^:= l$END pokeL;""PROCEDURE peekL (addr: ADDRESS): LONGCARD;$VAR pl: POINTER TO LONGCARD;$BEGIN&pl:= addr;&RETURN pl^$END peekL;""VAR (*$Reg*)l: LONGCARD; (*$Reg*)item: PtrItem; p: ADDRESS;""BEGIN$IF coding () THEN&p:= CodePtr () - CodeStart;&item:= expr.varItem;&IF item = NIL THEN((* Verweis auf Konstante im DATA-Puffer *)((*$? Safety: assert (expr.constHead # NIL); *)(INC (RelocCount);(l:= peekL (expr.constHead+2);(IF l = 0 THEN LastDataRelocAdr:= expr.constHead+2 END;(PutCode (l);(pokeL (expr.constHead+2, p);&ELSIF ItemNo (item) = 50 THEN(INC (RelocCount);(PutCode (LastConstLink (item));(SetConstLink (item, p)&ELSIF ItemNo (item) = 28 THEN(INC (RelocCount);(PutCode (LastTableLink (item));(SetTableLink (item, p)&ELSIF ItemNo (item) = 17 THEN(INC (RelocCount);(PutCode (LastVarLink (item));(SetVarLink (item, p)&ELSIF ItemNo (item) = 6 THEN(IF global IN ItemFlag (item) THEN*INC (RelocCount);*PutCode (LastProcLink (item));*SetProcLink (item, p)(ELSE*(*$R-*)*IF VarAddress (item) = 0L THEN,l:= LastProcLink (item);,SetProcLink (item, CodePtr ());,IF l = 0L THEN.PutCode (CARDINAL(0)),ELSE.putw (l - CodePtr ());,END*ELSE,putw (LONGCARD (VarAddress (item)) - CodePtr () + CodeStart);*END*(*$R=*)(END&ELSE(bong&END$END;"END RelocRef;  PROCEDURE ForwardRef (VAR target: Label);"(* sieht Sprung-Adr. f. "Bcc.W" vor *)"BEGIN$IF coding () THEN&target:= CodePtr ();&PutCode ( CARDINAL(0) );$ELSE&target:= NIL$END"END ForwardRef;  PROCEDURE ToHere (target: Label);"(* fÅr BYTE/WORD-Offsets *)"VAR (*$Reg*)ofs: LONGCARD; (*$Reg*)p: POINTER TO CARDINAL; pb: POINTER TO CHAR;"BEGIN$IF target # NIL THEN&ofs:= CodePtr () - target;&IF ODD (ofs) THEN(DEC (ofs);(IF ofs >= $80L THEN*SyntaxError (rStruc)(END;(pb:= target;(pb^:= CHR (SHORT (ofs));&ELSE(IF ofs >= $8000L THEN*SyntaxError (rStruc)(END;(p:= target;(p^:= SHORT (ofs);&END;$END"END ToHere;  PROCEDURE encodeTail (VAR dest: ExprDesc; code: codeDesc);"(* 'encode' ohne Ablegen des Op-Codes *)"BEGIN$IF code.reloc THEN&RelocRef (dest)$ELSIF code.extSize = 2 THEN&PutCode (code.extWord)$ELSIF code.extSize = 4 THEN&PutCode (code.extLong)$ELSIF code.extSize = 8 THEN&PutCode (code.extDouble)$END;"END encodeTail;  PROCEDURE encode (VAR dest: ExprDesc; opcode: CARDINAL; code: codeDesc);"BEGIN$PutCode (opcode);$encodeTail (dest, code);"END encode;  PROCEDURE genClrReg (dest: RegType);"(* Erz. MOVEQ #0,dest-Reg *)"VAR opcode: CARDINAL;"BEGIN$opcode:= $7000;$getDestReg (dest, opcode);$IF coding () THEN&PutCode (opcode)$END"END genClrReg;  PROCEDURE genMOVEQ (x: ZZ; dest: RegType);"(* Erz. MOVEQ #x,dest-Reg *)"VAR opcode: CARDINAL;"BEGIN$opcode:= $7000 + ORD (x.b);$getDestReg (dest, opcode);$IF coding () THEN&PutCode (opcode)$END"END genMOVEQ;  PROCEDURE genMOVEir (x: ZZ; size: CARDINAL; dest: RegType);"(* Erz. MOVE.size #v,dest-Reg *)"VAR opcode: CARDINAL;"BEGIN$opcode:= $003C + sizedMOVE (size);$getDestReg (dest, opcode);$IF coding () THEN&PutCode (opcode);&IF size > 2 THEN PutCode (x.v) ELSE PutCode (x.i) END$END"END genMOVEir;  PROCEDURE genMOVEimmind (source: ADDRESS; dest: RegType; size: CARDINAL; inc: BOOLEAN);"(* Erz. MOVE.x #source,(dest-Reg)+ *)"VAR (*$Reg*)n, (*$Reg*)opcode: CARDINAL;&(*$Reg*)p: POINTER TO BYTE;"BEGIN$updateStackOffsets (dest, inc, size);$opcode:= $003C + sizedMOVE (size);$IF inc THEN INC (opcode, $00C0) ELSE INC (opcode, $0080) END;$INC (opcode, (dest-A0) * $200);$IF coding () THEN&PutCode (opcode);&IF size = 1 THEN(p:= source;(PutCode (ORD (p^))&ELSE(REPEAT*p:= source;*n:= ORD (p^) * 256;*INC (p);*PutCode (n + ORD (p^));*INC (source, 2);*DEC (size, 2)(UNTIL size = 0&END$END"END genMOVEimmind;  PROCEDURE genMOVErind (source, dest: RegType; size: CARDINAL; inc: BOOLEAN);"(* Erz. MOVE.x source-Reg,(dest-Reg)+ *)"VAR (*$Reg*)opcode: CARDINAL;"BEGIN$updateStackOffsets (dest, inc, size);$opcode:= sizedMOVE (size);$IF inc THEN INC (opcode, $00C0) ELSE INC (opcode, $0080) END;$INC (opcode, source);$INC (opcode, (dest-A0) * $200);$IF coding () THEN&PutCode (opcode)$END"END genMOVErind;  PROCEDURE genMOVEaind (VAR source: ExprDesc; dest: RegType;7size: CARDINAL; inc: BOOLEAN);"(* Erz. MOVE.x source,(dest-Reg)+ *)"VAR opcode: CARDINAL; code: codeDesc;"BEGIN$updateStackOffsets (dest, inc, size);$IF size = 0 THEN size:= SHORT (Size (source)) END;$opcode:= sizedMOVE (size);$IF inc THEN&IF dest = A7 THEN(INC (opcode, $0100) (* ~~~ ggf. PEA verwenden bei aufrufer *)&ELSE(INC (opcode, $00C0)&END$ELSE&INC (opcode, $0080)$END;$INC (opcode, (dest-A0) * $200);$getSrcEA (source, size, opcode, code);$IF coding () THEN&encode (source, opcode, code);$END"END genMOVEaind;  PROCEDURE genCLRind (dest: RegType; size: CARDINAL; inc: BOOLEAN);"(* Erz. CLR.x (dest-Reg)+ *)"VAR opcode: CARDINAL;"BEGIN$updateStackOffsets (dest, inc, size);$IF inc THEN&IF dest = A7 THEN(opcode:= CLR + $0020&ELSE(opcode:= CLR + $0018&END$ELSE opcode:= CLR + $0010 END;$getSizeAt6 (size, opcode);$INC (opcode, dest-A0);$IF coding () THEN&PutCode (opcode)$END"END genCLRind;  PROCEDURE genMOVEindind (source, dest: RegType; size: CARDINAL; inc: BOOLEAN);"(* Erz. MOVE.x (source-Reg)+,(dest-Reg)+ *)"VAR (*$Reg*)opcode: CARDINAL;"BEGIN$updateStackOffsets (source, inc, size);$updateStackOffsets (dest, inc, size);$opcode:= sizedMOVE (size);$IF inc THEN INC (opcode, $00D8) ELSE INC (opcode, $0090) END;$INC (opcode, source-A0);$INC (opcode, (dest-A0) * $200);$IF coding () THEN&PutCode (opcode)$END"END genMOVEindind;  PROCEDURE genMOVEar (VAR source: ExprDesc; dest: RegType);"(* Erz. MOVE.x source,dest-Reg *)"VAR opcode: CARDINAL; code: codeDesc;"BEGIN$opcode:= MOVE;$getDestReg (dest, opcode);$getSizeForMOVE (source, opcode);$getSrcEA (source, 0, opcode, code);$IF coding () THEN&encode (source, opcode, code);$END"END genMOVEar;  PROCEDURE genMOVEaa (VAR source, dest: ExprDesc; size: CARDINAL);"(* Erz. MOVE.x source,dest *)"VAR opcode: CARDINAL; VAR code, code2: codeDesc;"BEGIN$IF size = 0 THEN size:= SHORT (Size (source)) END;$(*$? Safety2: assert ( (dest.kind#stack) OR (source.kind#stack)<OR (source.stackReg#dest.stackReg) ); *)$opcode:= 0;$getSrcEA (dest, size, opcode, code2);$ASSEMBLER ; versch. SrcEA nach DestEA&MOVE    opcode(A6),D0&MOVE    D0,D1&ANDI    #7,D0&ANDI    #$38,D1&LSL     #3,D1&ROR     #7,D0&OR      D1,D0&MOVE    D0,opcode(A6)$END;$INC (opcode, sizedMOVE (size));$getSrcEA (source, size, opcode, code);$IF coding () THEN&encode (source, opcode, code);&encodeTail (dest, code2)$END"END genMOVEaa;  PROCEDURE genMOVErr (source, dest: RegType; size: CARDINAL);"(* Erz. MOVE.L source-Reg,dest-Reg *)"VAR n: CARDINAL;"BEGIN$n:= sizedMOVE (size) + source;$getDestReg (dest, n);$IF coding () THEN&PutCode (n)$END"END genMOVErr;  PROCEDURE genMOVELIndTo (source, dest: RegType; offset: INTEGER);"(* Erz. MOVE.L [offset](source-Reg),dest-Reg *)"VAR (*$Reg*)n: CARDINAL;"BEGIN$n:= 0010000000010000% + source - A0;$IF dest < A0 THEN&INC (n, dest * $200)$ELSE&INC (n, (dest-A0) * $200 + $40)$END;$IF coding () THEN&IF offset = 0 THEN(PutCode (n)&ELSE(PutCode (n - $10 + $28);(PutCode (offset)&END$END"END genMOVELIndTo;  PROCEDURE genADDA (long: BOOLEAN; sourceReg, destReg: RegType);"(* Erz. ADDA.size Xn,An *)"VAR (*$Reg*)n: CARDINAL;"BEGIN$IF coding () THEN&IF long THEN(n:= $D1C0&ELSE(n:= $D0C0&END;&PutCode (n + sourceReg + $200 * (destReg-A0))$END"END genADDA;  PROCEDURE genSUBA (long: BOOLEAN; sourceReg, destReg: RegType);"(* Erz. SUBA.size Xn,An *)"VAR (*$Reg*)n: CARDINAL;"BEGIN$IF coding () THEN&IF long THEN(n:= $91C0&ELSE(n:= $90C0&END;&PutCode (n + sourceReg + $200 * (destReg-A0))$END"END genSUBA;  PROCEDURE genADDAL (ofs: LONGINT; reg: RegType);"(* Erz. ADDA.L #n,An *)"BEGIN$updateStackOffsets (reg, TRUE, ofs);$IF coding () THEN&PutCode ($D1FC + $200 * (reg-A0));&PutCode (ofs)$END"END genADDAL;  PROCEDURE genia (opcode: CARDINAL; data: ARRAY OF WORD; VAR dest: ExprDesc;1size: LONGINT);"(* z.B. ANDI #data,dest *)"(* ist die Type-Grîûe Byte oder Word und 'data' ein Long, wird nur das#* 2. Word als Konstante abgelegt. *)"VAR code: codeDesc;"BEGIN$(*$? Safety2: assert ((dest.kind # register) OR (dest.exprReg < A0)); *)$IF size = 0L THEN size:= Size (dest) END;$getSizeAt6 (size, opcode);$CASE dest.kind OF$| condFlags, constant: bong$ELSE&getSrcEA (dest, SHORT (size), opcode, code);$END;$IF coding () THEN&PutCode (opcode);&IF ABS(size)<=2L THEN(PutCode (data [HIGH (data)])&ELSE(PutCode (data [0]);(PutCode (data [1])&END;&encodeTail (dest, code)$END"END genia;  PROCEDURE genra (opcode: CARDINAL; sourceReg: RegType; VAR dest: ExprDesc);"(* z.B. ADD Dn,dest *)"(* wenn 'dest' ein Reg ist, wird automatisch die andere Adr-Art "<ea>,Dn"#* codiert *)"VAR code: codeDesc; (*$Reg*)size: INTEGER;"BEGIN$(*$? Safety2: assert (sourceReg < A0); *)$IF dest.kind = register THEN&(*$? Safety2: assert (dest.exprReg < A0); *)&INC (opcode, $200 * dest.exprReg + sourceReg);&getSizeAt6 (SHORT (Size (dest)), opcode);&IF coding () THEN(PutCode (opcode)&END$ELSE&INC (opcode, $100 + $200 * sourceReg);&size:= SHORT (Size (dest));&getSizeAt6 (size, opcode);&getSrcEA (dest, size, opcode, code);&IF coding () THEN(encode (dest, opcode, code)&END$END"END genra;  PROCEDURE genPEA ( VAR dest: ExprDesc );"VAR code: codeDesc; opcode: CARDINAL;"BEGIN$opcode:= PEA;$updateStackOffsets (A7, FALSE, 4);$getSrcEA (dest, 0, opcode, code);$IF coding () THEN&encode (dest, opcode, code);$END"END genPEA;  PROCEDURE gena ( opcode: CARDINAL; VAR dest: ExprDesc; size: INTEGER );"(* generiere Instruktion mit Addressmode, z.B. "TST" *)"VAR code: codeDesc;"BEGIN$(*$? Safety2: assert ((dest.kind # register) OR (dest.exprReg < A0)); *)$IF size = 0 THEN&getSizeAt6 (Size (dest), opcode)$ELSIF size > 0 THEN&getSizeAt6 (size, opcode)$END;$CASE dest.kind OF$| condFlags, constant: bong$ELSE&getSrcEA (dest, size, opcode, code);$END;$IF coding () THEN&encode (dest, opcode, code);$END"END gena;  PROCEDURE genarSized ( opcode: CARDINAL; VAR source: ExprDesc; dest: RegType;7size: LONGINT );"(* wenn 'dest' ein Adreû-Reg, wird Size nach ADDA/LEA, usw. bestimmt *)"VAR code: codeDesc;"BEGIN$IF dest < A0 THEN&IF NOT sizedAt6 (opcode) THEN(getSizeAt6 (size, opcode);&END;&getDestReg (dest, opcode);$ELSE&(*$? Safety2: assert ((dest # A3) & (dest # A7)); *) (* wg. updateStackOffset *)&INC (opcode, (dest-A0) * $200 + AnSized (size))$END;$getSrcEA (source, SHORT (size), opcode, code);$IF coding () THEN&encode (source, opcode, code);$END"END genarSized;  PROCEDURE genar ( opcode: CARDINAL; VAR source: ExprDesc; dest: RegType );"(* wenn 'dest' ein Adreû-Reg, wird Size nach ADDA/LEA, usw. bestimmt *)"BEGIN$genarSized (opcode, source, dest, Size (source));"END genar;  PROCEDURE genEXG (r1, r2: RegType);"VAR (*$Reg*)opcode: CARDINAL; (*$Reg*)r: RegType;"BEGIN$(*$? Safety: assert ((r1 < F0) & (r2 < F0));*)$opcode:= EXG;$IF r1 >= A0 THEN&DEC (r1,A0);&IF r2 >= A0 THEN(INC (opcode, 01001000%);(DEC (r2,A0);&ELSE(INC (opcode, 10001000%);&END$ELSIF r2 >= A0 THEN&INC (opcode, 10001000%);&DEC (r2,A0);&r:= r1; r1:= r2; r2:= r$ELSE&INC (opcode, 01000000%);$END;$IF coding () THEN&PutCode (opcode + r1 + $200 * r2);$END"END genEXG;" PROCEDURE gen ( opcode: WORD );"BEGIN$IF coding () THEN&PutCode (opcode);$END"END gen;  PROCEDURE setByte (at: ADDRESS; b: BYTE);"(* z. B. fÅr Setzen eines Short-BRA-Offsets *)"VAR (*$Reg*)p: POINTER TO BYTE;"BEGIN$IF coding () THEN&p:= at;&p^:= b$END"END setByte;  PROCEDURE genr ( opcode: CARDINAL; dest: RegType );"(* f. EXT (Reg. ab Bit 0), Achtung: Keine Size-Bestimmung! *)"BEGIN$(*$? Safety2: assert (dest < A0); *)$gen (opcode + dest);"END genr;  PROCEDURE genANDI (size: CARDINAL; data: ARRAY OF WORD; dest: RegType);"VAR opcode: CARDINAL;"BEGIN$(*$? Safety2: assert (dest < A0); *)$opcode:= ANDI + dest;$getSizeAt6 (size, opcode);$IF coding () THEN&PutCode (opcode);&IF size = 4 THEN(PutCode (data [0]);(PutCode (data [1])&ELSE(PutCode (data [HIGH (data)])&END$END"END genANDI;  PROCEDURE genir (opcode: CARDINAL; long: BOOLEAN; data: ARRAY OF WORD; dest: RegType);"(* z.B. f. MULU, der ea-code immediate-adressierung wird hier generiert *)"(* dest-Reg muû Dn, nicht An, sein! *)"VAR code: codeDesc;"BEGIN$IF coding () THEN&INC (opcode, $3C + dest * $200);&PutCode (opcode);&IF long THEN(PutCode (data [0]);(PutCode (data [1])&ELSE(PutCode (data [HIGH (data)])&END;$END"END genir;  PROCEDURE genBool ( cc: CARDINAL; int_fpu: BOOLEAN; VAR dest: ExprDesc );"(* gen. Scc und anschlieûendem AND #1 *)"(* geht nicht bei REALs! *)"VAR code: codeDesc; opcode: CARDINAL;"BEGIN$(*$? Safety: assert (BooleanType (dest.item)); *)$(* Scc bzw. FScc erzeugen *)$IF int_fpu THEN&(*$? Safety: assert (fpu () = internalFPU); *)&opcode:= $F240$ELSE&opcode:= SCC + cc;$END;$getSrcEA (dest, 0, opcode, code);$IF coding () THEN&PutCode (opcode);&IF int_fpu THEN PutCode (cc) END;&encodeTail (dest, code)$END;$(* ANDI #1 erzeugen *)$opcode:= ANDI;$getSizeAt6 (2, opcode);$getSrcEA (dest, 2, opcode, code);$IF coding () THEN&PutCode (opcode);&PutCode (CARDINAL(1));&encodeTail (dest, code)$END"END genBool;   PROCEDURE genbcc ( cc: CARDINAL; int_fpu: BOOLEAN; VAR target: Label );"(* Gen. Bcc.W mit VorwÑrts-Ref., Ansprung durch 'ToHere (target)' *)"BEGIN$IF coding () THEN&IF int_fpu THEN(PutCode ($F280 + cc);&ELSE(PutCode (Bcc + cc);&END;&ForwardRef (target);$ELSE&target:= NIL$END"END genbcc;  PROCEDURE genbccs ( cc: CARDINAL; VAR target: Label );"(* Gen. Bcc.B mit VorwÑrts-Ref., Ansprung durch 'ToHere (target)' *)"BEGIN$IF coding () THEN&PutCode (Bcc + cc);&target:= CodePtr () - 1L;$ELSE&target:= NIL$END"END genbccs;  PROCEDURE genDBcc ( cc: CARDINAL; reg: RegType; distance: LONGINT );"(* Gen. DBcc _ohne_ offene VorwÑrts-Ref. *)"BEGIN$(*$? Safety: assert ((distance < 0L) & NOT ODD (distance)); *)$IF coding () THEN&IF distance <= -32768L THEN((*~~~ long-bra *) SyntaxError (rBranc)&END;&PutCode (DBcc + cc + reg);&PutCode (SHORT (distance));$END"END genDBcc;  PROCEDURE bccBackTo (cc: CARDINAL; target: ADDRESS);"VAR (*$Reg*)diff: LONGINT;"BEGIN$diff:= LONGINT (target) - LONGINT (CodePtr () + 2L);$(*$? Safety: assert ((diff < 0L) & NOT ODD (diff)); *)$IF diff > -128L THEN&gen (Bcc + cc + lowByte (diff))$ELSIF diff > -32768L THEN&gen (Bcc + cc);&gen (SHORT (diff))$ELSIF coding () THEN&(*~~~ long-bra *) SyntaxError (rBranc)$END"END bccBackTo;  PROCEDURE dbccBackTo (cc: CARDINAL; reg: RegType; target: ADDRESS);"VAR (*$Reg*)diff: LONGINT;"BEGIN$diff:= LONGINT (target) - LONGINT (CodePtr () + 2L);$(*$? Safety: assert ((diff < 0L) & NOT ODD (diff)); *)$IF diff > -32768L THEN&gen (DBcc + reg + cc);&gen (SHORT (diff))$ELSIF coding () THEN&(*~~~ long-dbra *) SyntaxError (rBranc)$END"END dbccBackTo;   PROCEDURE genLEA (VAR expr: ExprDesc; dest: RegType);"VAR (*$Reg*)t: PtrItem;"BEGIN$(*$? Safety2: assert (dest >= A0); *)$t:= expr.item; expr.item:= CardPtr;$genar (LEA, expr, dest);$expr.item:= t;"END genLEA;  (* PROCEDURE genLEAabs (VAR x: ADDRESS; dest: RegType);"(* LEA $xxxxxxxx,An *)"BEGIN$(*$? Safety2: assert (dest >= A0);*)$IF coding () THEN&PutCode (LEA + $01C0 + 111001% + $200 * dest);&RelocRef (x)$END"END genLEAabs; *)  PROCEDURE genLEApcrel (x: ADDRESS; dest: RegType);"(* LEA y(PC),An   'y' wird aus 'CodePtr - x' berechnet *)"(* 'x' muû schon eine existente Adr. vorher im Code sein! *)"VAR (*$Reg*)diff: LONGINT;"BEGIN$(*$? Safety2: assert (dest >= A0);*)$IF coding () THEN&(* diff-PrÅfung darf nur bei coding() erfolgen, sonst Fehler bei IF FALSE...! *)&diff:= LONGINT (x) - LONGINT (CodePtr () + 2L);&IF diff < LONG (MinInt) THEN(SyntaxError (rBranc) (* branch too long *)((*~~~ hier und auch bei anderen relativen sprÅngen dann ggf. mit)*    hilfsreg. arbeiten, damit auch procs > 32K werden kînnen! *)&END;&PutCode (LEA + $01C0 + 111010% + $200 * (dest-A0));&PutCode (SHORT (diff))$END"END genLEApcrel;   PROCEDURE genLEArel (c: INTEGER; source,dest: RegType);"(* LEA c(An),Am *)"BEGIN$(*$? Safety2: assert ((dest >= A0) & (source >= A0)); *)$updateStackOffsets (dest, TRUE, c);$IF coding () THEN&PutCode (LEA + $01C0 + source + 100000% + $200 * (dest-A0));&PutCode (c)$END"END genLEArel;   PROCEDURE genQr (ofs: INTEGER; size: CARDINAL; reg: RegType);"(* gen. ADDQ/SUBQ je nach 'ofs' *)"VAR opcode: CARDINAL;"BEGIN$updateStackOffsets (reg, TRUE, ofs);$IF ofs < 0 THEN&ofs:= -ofs;&opcode:= SUBQ$ELSE&opcode:= ADDQ$END;$(*$? Safety: assert ( (ofs>=1) & (ofs<=8) & (size > 0) );*)$getSizeAt6 (size, opcode);$IF coding () THEN&PutCode (opcode + CARDINAL (ofs) MOD 8 * $200 + reg)$END;"END genQr;  PROCEDURE genQ (ofs: INTEGER; VAR expr: ExprDesc);"(* gen. ADDQ/SUBQ je nach 'ofs' *)"VAR (*$Reg*)opcode: CARDINAL;"BEGIN$IF expr.kind = register THEN&genQr (ofs, SHORT (Size (expr)), expr.exprReg)$ELSE&IF ofs < 0 THEN(ofs:= -ofs;(opcode:= SUBQ&ELSE(opcode:= ADDQ&END;&(*$? Safety: assert ( (ofs>=1) & (ofs<=8) );*)&gena (opcode + CARDINAL (ofs) MOD 8 * $200, expr, 0)$END"END genQ;  PROCEDURE syncStack (size: LONGCARD; destReg: RegType; dir: Directions);"BEGIN$IF ODD (size) & (destReg # A7) THEN&IF dir = up THEN(genQr (1, 4, destReg)&ELSIF dir = down THEN(genQr (-1, 4, destReg)&END$END"END syncStack;   PROCEDURE genPushReg (source: RegType; long: BOOLEAN; destReg: RegType);"(* packt Reg auf A3- oder A7-Stack *)"VAR (*$Reg*)size, (*$Reg*)opcode: CARDINAL;"BEGIN$IF long THEN size:= 4 ELSE size:= 2 END;$CASE destReg OF$| A3: (* "(A3)+" *)*IF long THEN opcode:= 0010011011000000% ELSE opcode:= 0011011011000000% END;$| A7: (* "-(A7)" *)*IF long & (source >= A0) THEN,opcode:= PEA + 010000%;,DEC (source, A0);*ELSE,IF long THEN opcode:= 0010111100000000% ELSE opcode:= 0011111100000000% END;*END$ELSE&bong$END;$updateStackOffsets (destReg, (destReg = A3), size);$IF coding () THEN&PutCode (opcode + source)$END"END genPushReg;  PROCEDURE genPush (VAR source: ExprDesc; size: CARDINAL;3destReg: RegType; dir: Directions);"(* packt Datum auf A3- oder A7-Stack *)"(* ACHTUNG: vorher prÅfen, ob es sich schon dort befindet! *)"(* wenn size = 0, wird sie aus 'source' ermittelt *)"VAR code: codeDesc; opcode: CARDINAL;"BEGIN$IF size = 0 THEN size:= SHORT (Size (source)) END;$IF dir = noDir THEN&(* "(An)"  *)&opcode:= 0000000010000000%$ELSE&IF dir = up THEN((* "(An)+" *)(opcode:= 0000000011000000%;(updateStackOffsets (destReg, TRUE, size);&ELSE((* "-(An)" *)(IF (source.kind = register) & (source.exprReg >= A0) & (destReg = A7) THEN*(*$? Safety2: assert (size # 1); *)*genPushReg (source.exprReg, size = 4, A7);*RETURN(END;(opcode:= 0000000100000000%;(updateStackOffsets (destReg, FALSE, size);&END$END;$INC (opcode, (destReg-A0) * $200);$INC (opcode, sizedMOVE (size));$getSrcEA (source, size, opcode, code);$IF coding () THEN&encode (source, opcode, code);$END"END genPush;  PROCEDURE genPushConst (const: LONGCARD; size: CARDINAL;8destReg: RegType; dir: Directions);"(* packt Konst. auf A3- oder A7-Stack *)"VAR code: codeDesc; (*$Reg*)opcode: CARDINAL;"BEGIN$CASE dir OF$| up:   (* "(An)+" *) opcode:= 0000000011111100%;,updateStackOffsets (destReg, TRUE, size);$| down: (* "-(An)" *) opcode:= 0000000100111100%;,updateStackOffsets (destReg, FALSE, size);$| noDir:(* "(An)"  *) opcode:= 0000000010111100%$END;$INC (opcode, (destReg-A0) * $200);$INC (opcode, sizedMOVE (size));$IF coding () THEN&PutCode (opcode);&IF size < 4 THEN((*$R-*)(PutCode (SHORT (const));((*$R=*)&ELSE(PutCode (const)&END$END"END genPushConst;  PROCEDURE genPopReg (reg: RegType; long: BOOLEAN; stack: RegType);"(* lÑdt Reg vom A3- oder A7-Stack *)"VAR (*$Reg*)size, opcode: CARDINAL;"BEGIN$CASE stack OF$| A3: (* "-(A3)" *) opcode:= 0011000000100011%$| A7: (* "(A7)+" *) opcode:= 0011000000011111%$END;$IF long THEN size:= 4 ELSE size:= 2 END;$updateStackOffsets (stack, (stack = A7), size);$IF long THEN DEC (opcode, $1000) END;$getDestReg (reg, opcode);$IF coding () THEN&PutCode (opcode)$END"END genPopReg;  PROCEDURE genPullReg (VAR source: ExprDesc; long: BOOLEAN; to: RegType);"(* lÑdt Reg vom A3- oder A7-Stack *)"VAR (*$Reg*)reg, (*$Reg*)size, opcode: CARDINAL;"BEGIN$IF source.kind = memory THEN&CASE source.mode OF&| ptrOnA3: reg:= A3&| ptrOnA7: reg:= A7&END;$ELSE&(*$? Safety2: assert (source.kind = spilledSP);*)&reg:= source.spillReg;$END;$IF reg = A3 THEN&(* "-(A3)" *) opcode:= 0011000000100011%$ELSE&(*$? Safety2: assert (reg = A7); *)&(* "(A7)+" *) opcode:= 0011000000011111%$END;$IF long THEN size:= 4 ELSE size:= 2 END;$updateStackOffsets (reg, (reg = A7), size);$IF long THEN DEC (opcode, $1000) END;$getDestReg (to, opcode);$IF coding () THEN&PutCode (opcode)$END"END genPullReg;  PROCEDURE genPushAddress (VAR source: ExprDesc; destReg: RegType);"(*#* kann in dieser Form nur von spillReg() verwendet werden!#*)"VAR code: codeDesc;"BEGIN$(*$? Safety2: assert (source.kind = memory);*)$IF destReg = A3 THEN&genLEA (source, source.baseReg);&genPushReg (source.baseReg, TRUE, destReg)$ELSIF destReg = A7 THEN&genPEA (source)$ELSE&bong$END"END genPushAddress;  PROCEDURE addConstToAddrReg (c: LONGINT; reg: RegType);"BEGIN$(*$? Safety2: assert (reg IN (RegSet {A0..A7}));*)$IF ABS (c) <= 8L THEN&genQr (SHORT (c), 4, reg)$ELSIF ABS (c) <= 32767L THEN&genLEArel (SHORT (c), reg, reg)$ELSE&genADDAL (c, reg)$END"END addConstToAddrReg;  FORWARD initConstExpr (VAR expr: ExprDesc; size: CARDINAL; const: ZZ);  PROCEDURE incReg (reg: RegType; i: ZZ; size: CARDINAL);"(*#* erhîht oder erniedrigt ein Register um einen konstanten Wert#*)"VAR const: ExprDesc; (*$Reg*)opcode: CARDINAL;"BEGIN$IF NOT nullZZ (i) THEN&IF int3ZZ (i) THEN(genQr (i.i, size, reg)&ELSE(IF reg >= A0 THEN*addConstToAddrReg (i.v, reg)(ELSE*IF posZZ (i) THEN,opcode:= ADD*ELSE,opcode:= SUB;,negZZ (i)*END;*initConstExpr (const, size, i);*genar (opcode, const, reg)(END&END$END"END incReg;   PROCEDURE dropNewConstant (addr: ADDRESS; size: LONGCARD; VAR oldexpr: ExprDesc);"(*#* Legt Daten von 'addr' als eigene Konstante im DATA-Puffer an.#* 'size' darf auch Null sein (3.6.94).#*)"VAR pc: POINTER TO CHAR; (*$Reg*)origSize: LONGCARD;&expr: ExprDesc;"BEGIN$(*%* Const ab 'addr' wird im DATA-Puffer abgelegt - ggf. kann sie von%* constantFold wieder weggekÅrzt werden.%*)$expr:= oldexpr; (* kopie anlegen, weil ggf. 'addr' auf selbe expr zeigt *)$origSize:= size;$WITH expr DO&varItem:= NIL; (* nun keine Tree-Referenz mehr *)&IF ItemNo (item) = 27 THEN((* String 0-terminieren *)(pc:= addr + size - 1L;(IF pc^ # 0C THEN INC (size) END&END;&IF ODD (size) THEN INC (size) END;&IF size >= LONG (MaxInt) THEN  (* das wÑre nicht mehr besonders sinnvoll... *)(SyntaxError (rConLg)&END;&kind:= constRef;&constOfs:= 0;&constAddr:= NIL;&constHead:= NIL;&IF NOT SuppressCode THEN(constHead:= DataPtr;(PutData (VAL (CARDINAL, size));(PutData (LONGCARD (0));(constAddr:= DataPtr;(Move (addr, constAddr, SHORT (size));(Clear (constAddr + origSize, SHORT (size - origSize));(INC (DataPtr, size);&ELSE((*$? Safety: assert (NOT InConstExpr)*)&END;$END;$oldexpr:= expr;$DataSpace;"END dropNewConstant; (*$D-*)  PROCEDURE constantAtEnd (VAR expr: ExprDesc): BOOLEAN;"(*#* Liefert TRUE, wenn Const am Ende vom Data-Puffer abgelegt ist.#*)"VAR pc: POINTER TO CARDINAL;"BEGIN$(*$? Safety: assert (expr.kind = constRef);*)$pc:= expr.constHead;$RETURN (pc # NIL) AND (DataPtr = expr.constAddr + LONG(pc^));"END constantAtEnd;  (* nicht benîtigt$PROCEDURE constantFollows (REF second, first: ExprDesc): BOOLEAN;&(*'* Liefert TRUE, wenn 'second' genau hiner 'first' liegt'*)&VAR pc: POINTER TO CARDINAL;&BEGIN((*$? Safety: assert (first.kind = constRef);*)((*$? Safety: assert (first.constHead # NIL);*)((*$? Safety: assert (second.kind = constRef);*)((*$? Safety: assert (second.constHead # NIL);*)(pc:= first.constHead;(RETURN (second.constHead = first.constAddr + LONG(pc^));&END constantFollows; *)  PROCEDURE extendConstant (newSize: LONGCARD; VAR expr: ExprDesc);"(*#* erweitert Konstante im Puffer (muû mit dropNewConstant erzeugt sein).#*)"VAR pc: POINTER TO CARDINAL; (*$Reg*)origSize: LONGCARD;"BEGIN$(*$? Safety: assert (newSize > 0L);*)$origSize:= newSize;$WITH expr DO&(*$? Safety: assert (kind = constRef);*)&IF ODD (newSize) THEN INC (newSize) END;&IF newSize >= LONG (MaxInt) THEN  (* das wÑre nicht mehr besonders sinnvoll... *)(SyntaxError (rConLg)&END;&IF NOT SuppressCode THEN((*$? Safety: assert (constHead # NIL); *)((*$? Safety: pc:= constHead; assert (DataPtr = constAddr + LONG(pc^)); *)(DataPtr:= constAddr + newSize;(pc:= constHead;(pc^:= SHORT(newSize);&ELSE((*$? Safety: assert (NOT InConstExpr)*)&END;$END;$DataSpace;"END extendConstant;  PROCEDURE addNewConstant (addr: ADDRESS; dataSize, addSize: LONGCARD;7VAR expr: ExprDesc);"(*#* FÅgt weitere Werte an die mit 'dropNewConstant' im DATA-Puffer abgelegte#* Konstante an.#* Es wird kein Null-Zeichen mehr bei String-Consts angefÅgt! Das ist#* nur nîtig, falls man CADR auf eine String-Const anwendet und das ist#* bei einer zusammengesetzten Const sowieso nicht mehr sinnvoll.#* Achtung: Es kann vorkommen (in addToConstPar), daû die Konstante#* innerhalb des neu zu belegenden Speichers liegt, also nur ein StÅck#* zurÅckverschoben wird. Somit sicherstellen, daû vor dem Move() der#* vermeintlich freie Speicher hinter 'DataPtr' nicht verÑndert wird!#*)"VAR (*$Reg*)oldSize, (*$Reg*)newSize: LONGCARD; pc: POINTER TO CARDINAL;"BEGIN$WITH expr DO&(*$? Safety: assert (kind = constRef);3assert ((addSize > 0) & (dataSize > 0));*)&oldSize:= Size (expr);&newSize:= oldSize + addSize;&IF ODD (newSize) THEN INC (newSize) END;&IF newSize >= LONG (MaxInt) THEN((* das wÑre nicht mehr besonders sinnvoll... *)(SyntaxError (rConLg)&END;&IF NOT SuppressCode THEN((*$? Safety: assert (constHead # NIL); *)((*$? Safety: pc:= constHead; assert (DataPtr = constAddr + LONG(pc^)); *)(Move (addr, constAddr + oldSize, SHORT (dataSize));(Clear (constAddr + oldSize + dataSize, SHORT (addSize-dataSize));(DataPtr:= constAddr + newSize;(pc:= constHead;(pc^:= SHORT(newSize);&ELSE((*$? Safety: assert (NOT InConstExpr) *)&END;$END;$DataSpace"END addNewConstant;  PROCEDURE cutConst (VAR expr: ExprDesc);"(*#* Im DATA-Puffer erzeugte Konstante wieder verwerfen#*)"VAR pc: POINTER TO CARDINAL;"BEGIN$WITH expr DO&(*$? Safety: assert (kind = constRef);*)&IF constHead # NIL THEN(pc:= constHead;(IF DataPtr = constAddr + LONG(pc^) THEN*DataPtr:= constHead;(ELSE*(* Konst bleibt unbenutzt im Puffer, wird spÑter beim DATA-Segment-+* Erzeugen ignoriert *)(END;(constAddr:= NIL;(constHead:= NIL;&END$END"END cutConst; (*$D-*)  PROCEDURE reduceConstant (VAR expr: ExprDesc);"(* verkÅrzt Konst im Puffer auf die wirklich benîtigte LÑnge *)"VAR pc: POINTER TO CARDINAL; newSize: LONGCARD;"BEGIN$WITH expr DO&IF NOT SuppressCode THEN(newSize:= Size (expr);(IF ODD (newSize) THEN INC (newSize) END;((*$? Safety: assert (kind = constRef);*)((*$? Safety: assert (constHead # NIL);*)((*$? Safety: pc:= constHead; assert (DataPtr = constAddr + LONG(pc^)); *)(IF constOfs > 0 THEN+Move (constAddr + constOfs, constAddr, newSize);+constOfs:= 0(END;(DataPtr:= constAddr + newSize;(pc:= constHead;(pc^:= SHORT(newSize);&END;$END"END reduceConstant; (*$D-*)  PROCEDURE dropConstantFromTree (VAR expr: ExprDesc);"(*#* Legt eine Konstante aus dem Tree in den DATA-Puffer.#* Achtung: Dabei geht die Referenz auf die evtl. benamte Konstante#* verloren, so daû dann eine Kopie der Konstante im Puffer erzeugt wird!#* Sollte daher nur aufgerufen werden, wenn dabei eine neue zusammengesetzte#* Konstante erzeugt wird oder sie gleich danach wieder mit "cutConst"#* entfernt wird!#*)"VAR os: INTEGER; pd: POINTER TO LONGINT; n: INTEGER; vi: PtrItem; ofs: LONGCARD;"BEGIN$WITH expr DO&IF NOT SuppressCode THEN((*$? Safety: assert (kind = constRef);*)((*$? Safety: assert (constHead = NIL);*)((*$? Safety: assert (varItem # NIL);*)(n:= entryC (varItem, -16);(vi:= varItem; (* varItem wird gleich auf NIL gesetzt *)(ofs:= constOfs;(dropNewConstant (ADR(Accu)(*dummy*), n, expr); (* erstmal vollen Platz reservieren *)(constOfs:= ofs;(os:= -20;(pd:= constAddr; (* Zieladr. *)(REPEAT*pd^:= entryL (vi, os);*INC (pd, 4);*DEC (os, 4);*DEC (n, 4);(UNTIL n <= 0;(IF constOfs > 0 THEN*(* nur ein Teil der Konst wird benîtigt -> kÅrzen *)*reduceConstant (expr)(END&END$END"END dropConstantFromTree; (*$D-*)   PROCEDURE genTrap (trapCode: CARDINAL);"BEGIN$gen (TRAP + ErrorTrapNo);$gen (trapCode)"END genTrap;   PROCEDURE pushInt (l: LONGWORD);"BEGIN$ASSEMBLER(MOVE.L  l(A6),D0(JSR     PushInt$END"END pushInt;  (* ----------------------------------------------------------------------- *)  (*"Label-Verwaltung.""Als "Label" wird hier nicht das Sprungziel sondern der Sprung-Zeiger"verstanden. "Labels" ist somit eine Liste von Byte- und Word-Adressen,"wo Zeiger auf das bei Aufruf von "Solve" stehende Ziel (CodePtr)"einzutragen sind. So kommt jedes "Label" auch nur einmal vor, wÑhrend"alle "Labels" auf ein gemeinsames Ziel zeigen werden. "15.02.94."Neue Label-Behandlung, die weniger Speicher auf dem Stack belegt: Statt"alle Labels jeweils lokal in einem groûen Array zu speichern, wird nun"ein gemeinsamer Label-Pool verwaltet, der jeweils einen Eintrag und einen"Index auf den VorgÑnger (ist nicht unbedingt stetig auf-/absteigend!)"enthÑlt. In "Labels" wird dann nur noch der Index auf den Anfang der"Liste vermerkt."LabelPoolIdx ist ein Hilfszeiger, der, solange er nicht am Ende des Pools"angekommen ist, immer das nÑchste Feld vergibt. Am Ende wird dann geprÅft"(langsamer), ob noch freie Felder im Array vorhanden sind, die wg. "Solve"-"Aufrufen zwischenzeitlich frei wurden. *)  CONST"LabelPoolSize = 256;  TYPE"Labels = RECORD-(* dies spÑter Åber Compiler-interne-Jmp-List lîsen *)-root, tail: [0..LabelPoolSize]; (* Index in Pool *)+END;  VAR"LabelPool: ARRAY [1..LabelPoolSize] OF RECORD$used: BOOLEAN;$addr: Label;$next: [0..LabelPoolSize]"END;"LabelPoolIdx, LabelsInPool: [0..LabelPoolSize];  PROCEDURE InitLabels (VAR list: Labels);"BEGIN$list.root:= 0"END InitLabels;  PROCEDURE PopLabel (VAR list: Labels);"BEGIN$(*$? Safety: assert (list.root # 0);*)$WITH LabelPool[list.root] DO&used:= FALSE;&DEC (LabelsInPool);&list.root:= next$END"END PopLabel;  PROCEDURE MarkRef (target: Label; VAR list: Labels);"VAR idx, i: INTEGER;"BEGIN$IF LabelsInPool = LabelPoolSize THEN SyntaxError (rLblOv); RETURN END;$IF LabelsInPool = 0 THEN&LabelPoolIdx:= 0 (* bei leerem Pool auch Hilfszeiger rÅcksetzen *)$END;$IF LabelPoolIdx < LabelPoolSize THEN&INC (LabelPoolIdx);&idx:= LabelPoolIdx$ELSE&(* nach leeren Feldern in Pool suchen *)&LOOP FOR i:= 1 TO LabelPoolSize DO(IF NOT LabelPool [i].used THEN*idx:= i;*EXIT(END&END END;&SyntaxError (rLblOv); RETURN$END;$INC (LabelsInPool);$WITH LabelPool [idx] DO&addr:= target;&next:= list.root;&used:= TRUE;&IF next = 0 THEN(list.tail:= idx&END;$END;$list.root:= idx;"END MarkRef;  PROCEDURE AddLabelsTo (VAR from: Labels; VAR to: Labels);"BEGIN$(* TT 18.8.94: das geht nicht - baut Mist bei "IF (a OR b) OR (c OR d) THEN..."&IF from.root # 0 THEN(IF to.root = 0 THEN*to:= from;(ELSE*(* 'from' an Schwanz von 'to' anhÑngen *)*LabelPool [to.tail].next:= from.root;(END;(from.root:= 0&END$*)$WHILE from.root # 0 DO&WITH LabelPool [from.root] DO(MarkRef (addr, to);(used:= FALSE;(DEC (LabelsInPool);(from.root:= next&END$END"END AddLabelsTo;  PROCEDURE Solve (VAR list: Labels);"BEGIN$WHILE list.root # 0 DO&WITH LabelPool [list.root] DO(ToHere (addr);(used:= FALSE;(DEC (LabelsInPool);(list.root:= next&END$END"END Solve;  PROCEDURE PushLabels (VAR list: Labels; VAR no: CARDINAL);"BEGIN$no:= 0;$WHILE list.root # 0 DO&WITH LabelPool [list.root] DO(IF addr # NIL THEN*pushInt (addr);*INC (no)(END;(used:= FALSE;((*$?Safety2: assert (LabelsInPool # 0);*)(DEC (LabelsInPool);(list.root:= next&END$END"END PushLabels;  PROCEDURE unSolved (VAR list: Labels): BOOLEAN;"BEGIN$RETURN list.root # 0"END unSolved;  (*alt: "CONST$MaxLabels = 50;$"TYPE$Labels = RECORD/(* dies spÑter Åber Compiler-interne-Jmp-List lîsen *)/n: CARDINAL;/t: ARRAY [1..MaxLabels] OF Label (* ~~~ die ist z.Zt. begrenzt! *)-END;""VAR$dummyLbl1, dummyLbl2: Labels;""PROCEDURE InitLabels (VAR list: Labels);$BEGIN&list.n:= 0$END InitLabels;""PROCEDURE PopLabel (VAR list: Labels);$BEGIN&(*$? Safety: assert (list.n > 0);*)&DEC (list.n)$END PopLabel;""PROCEDURE MarkRef (target: Label; VAR list: Labels);$BEGIN&IF list.n = MaxLabels THEN SyntaxError (rLblOv) END;&INC (list.n);&list.t [list.n]:= target$END MarkRef;""PROCEDURE AddLabelsTo (VAR from: Labels; VAR to: Labels);$BEGIN&WHILE from.n > 0 DO(MarkRef (from.t [from.n], to);(DEC (from.n)&END$END AddLabelsTo;""PROCEDURE Solve (VAR list: Labels);$BEGIN&WHILE list.n > 0 DO(ToHere (list.t [list.n]);(DEC (list.n)&END$END Solve;""PROCEDURE PushLabels (VAR list: Labels; VAR no: CARDINAL);$BEGIN&no:= 0;&WHILE list.n > 0 DO(IF list.t [list.n] # NIL THEN*pushInt (list.t [list.n]);*INC (no)(END;(DEC (list.n)&END$END PushLabels;""PROCEDURE unSolved (VAR list: Labels): BOOLEAN;$BEGIN&RETURN list.n > 0$END unSolved; *)  (* ----------------------------------------------------------------------- *)   (*$S+  ab hier Stackcheck *)   (* --- Routinen zum Setzen/Auswerten von 'ExprDesc'-Variablen --- *)   FORWARD deallocRegs ( VAR expr: ExprDesc ); FORWARD loadReg ( VAR expr: ExprDesc; niceRegs: RegSet ); FORWARD allocReg ( desiredRegs: RegSet ) : RegType; FORWARD makeIndir (VAR expr: ExprDesc; ofs: LONGINT; odd: BOOLEAN); FORWARD loadAddress ( VAR expr: ExprDesc ); FORWARD loadAddressTo ( VAR expr: ExprDesc; niceRegs: RegSet ); FORWARD loadAllocedReg ( VAR expr: ExprDesc; r: RegType );  PROCEDURE changeToStackTo (VAR dest: ExprDesc; niceRegs: RegSet);"(*#* Formt dest in (An)+ um#*)"VAR t: PtrItem;"BEGIN$IF (dest.kind # stack) OR NOT (dest.stackReg IN niceRegs) THEN&t:= dest.item;&loadAddressTo (dest, niceRegs);&WITH dest DO(item:= t;          (* wurde von loadAdress auf CardPtr gesetzt *)(kind:= stack;(stackReg:= exprReg;(up:= TRUE;(restoreAfterUse:= 0;(stackedSize:= 0&END$END"END changeToStackTo;  PROCEDURE changeToStack (VAR dest: ExprDesc);"(*#* Formt dest in (An)+ um#*)"BEGIN$changeToStackTo (dest, addrRegs + RegSet {A3,A7})"END changeToStack;  PROCEDURE changeToIndir (VAR dest: ExprDesc; r: RegType);"(*#* Formt alles in (An) um.#*)"BEGIN$WITH dest DO&kind:= memory;&mode:= d16An;&baseReg:= r;&mayBeOdd:= FALSE;&disp:= 0;$END"END changeToIndir;  PROCEDURE changeStackToIndir (VAR dest: ExprDesc);"(*#* Formt (An)+ oder -(An) in (An) um.#* Vorsicht: Bei -(An) wird keine Stack-Korrektur (SUB) vorgenommen#*)"BEGIN$WITH dest DO&(*$? Safety2: assert ((kind = stack) & (restoreAfterUse = 0L));*)&changeToIndir (dest, stackReg);$END"END changeStackToIndir;  PROCEDURE changeConstantToConstRef (VAR expr: ExprDesc; destSize: LONGCARD);"(*#* Sorgt dafÅr, daû Konstante auf Wert in DATA-Segment zugreifen wird.#* Nicht mit dropConstantFromTree zu verwechseln, wo die Konstante fÅr#* einen Compile-Time-Zugriff in den DATA-Puffer gelegt wird.#*)"VAR fl: IFS;"BEGIN$WITH expr DO&(*$? Safety: assert (kind = constant); *)&IF varItem # NIL THEN(kind:= constRef;(constOfs:= 0;(constHead:= NIL&ELSE(dropNewConstant (ADR (exprConst.b)+1L-Size (expr), destSize, expr);&END$END"END changeConstantToConstRef;  PROCEDURE oddAccess (VAR fact: ExprDesc): BOOLEAN;"BEGIN$(*$? Safety2: assert (fact.kind = memory);*)$RETURN fact.mayBeOdd"END oddAccess;  PROCEDURE loadIndir (VAR fact: ExprDesc; ofs: LONGINT; odd: BOOLEAN);"(* LÑdt den Pointer in 'fact' und macht indir. Zugriff draus;#* verÑndert den Typ aber nicht.#* z.B. f. VAR-Parameter-Vars und WITH-Zugriff Åber (A6).#*)"VAR t: PtrItem;"BEGIN$WITH fact DO&(* kurzzeitig LONG-Type aus Datum machen *)&t:= item; item:= CardPtr;&odd:= oddAccess (fact) OR odd;&loadReg (fact, addrRegs);&item:= t;&makeIndir (fact, ofs, odd)$END;"END loadIndir;  PROCEDURE makeInd0An (VAR expr: ExprDesc);"(* macht aus einer beliebigen Adressierung eine mit 0(An) *)"VAR t: PtrItem;"BEGIN$t:= expr.item;$loadAddress (expr);$makeIndir (expr, 0, FALSE);$expr.item:= t"END makeInd0An;  PROCEDURE initOpenArrayAccess (VAR expr: ExprDesc; needHigh: BOOLEAN);"(* IN:  'expr' mit Open-Array - Variable#*      'needHigh': TRUE -> auf HIGH-Werte soll zugegriffen werden.#* OUT: 'expr' enthÑlt Pointer auf Open Array,#*      'expr.highReg/highOfs' werden intialisiert, mit initHighExpr kann#*      eine Expr zum Zugriff darauf erzeugt werden.#* Achtung: 'deallocReg (expr.highReg)' nicht vergessen!#* Achtung: wenn 'needHigh' = FALSE, kann auch nicht mehr auf weitere#*          High-Werte (mehrdim. OpArr) zugegriffen werden!#*)"VAR t: PtrItem; r, r2: RegType;"BEGIN$WITH expr DO&(*$? Safety: assert (isOpenArray (item));*)&IF highReg = 0 THEN(t:= item;(IF needHigh THEN*changeToStack (expr);        (* "(An)+"           *)*r2:= stackReg;*item:= sizedItem (4, FALSE);*r:= allocReg (addrRegs);*loadAllocedReg (expr, r);    (* "MOVE.L (An)+,Ap" *),(* loadReg nicht mîglich, weil dann expr-Reg freigegeben wÅrde *)*makeIndir (expr, 0, FALSE);  (* expr: (Ap) *)*highReg:= r2;                (* high: (An) *)*highOfs:= 0(ELSE*loadIndir (expr, 0, FALSE);  (* "MOVE.L x(A6),An" *)(END;(item:= t&ELSE((* 'expr' enthÑlt bereits den benîtigten Pointer auf das Array *)&END$END"END initOpenArrayAccess;  PROCEDURE initExpr (VAR desc: ExprDesc; item: PtrItem; kind: ExprKind);"VAR i: CARDINAL;"BEGIN$SysUtil0.ClearVar (desc);$desc.item:= item;$desc.kind:= kind;"END initExpr;  PROCEDURE initStackExpr (VAR expr: ExprDesc; type: PtrItem; reg: RegType);"BEGIN$initExpr (expr, type, stack);$WITH expr DO&stackReg:= reg;&up:= (stackReg # A7);&restoreAfterUse:= 0;&stackedSize:= 0;&stackPtr:= 0$END"END initStackExpr;  PROCEDURE initMemExpr (VAR desc: ExprDesc; item: PtrItem; mod: MemModes;7odd: BOOLEAN);"BEGIN$initExpr (desc, item, memory);$WITH desc DO&idxL:= FALSE;&mayBeOdd:= odd;&mode:= mod;$END;"END initMemExpr;  PROCEDURE initHighExpr (REF from: ExprDesc; VAR high: ExprDesc);"VAR t: PtrItem;"BEGIN$WITH from DO&IF isLongOpenArray (item) THEN t:= CardPtr ELSE t:= SCardPtr END;&initMemExpr (high, t, d16An, FALSE);&high.baseReg:= highReg;&high.disp:= highOfs;&makeInd0An (high);&changeToStack (high)$END"END initHighExpr;  PROCEDURE adjustHighPtr (REF from: ExprDesc; VAR high: ExprDesc);"(* wenn 'high' bereits benutzt wurde, kann hiermit der Offset#* ggf. korrigiert werden *)"VAR stacked: INTEGER;"BEGIN$WITH high DO&stacked:= SHORT(stackedSize);&changeStackToIndir (high);&IF isLongOpenArray (from.item) THEN item:= CardPtr ELSE item:= SCardPtr END;&disp:= from.highOfs-stacked;&makeInd0An (high);&changeToStack (high);&stackedSize:= from.highOfs$END;"END adjustHighPtr;  PROCEDURE initPseudoRegExpr (VAR expr: ExprDesc; item: PtrItem;=r: RegType; upper: BOOLEAN);"VAR lastSymbol: Symbol; ok: BOOLEAN;"(*#* 'upper': TRUE -> 2. LONGWORD ansprechen#* Achtung: Bei Shortreals steht Wert immer im 1. LONGWORD, d.h. dann muû#* 'upper' FALSE sein!#* Damit diese Routine von 'pushRealReg' benutzbar ist, darf hier kein#* Register alloziert werden!#*)"BEGIN$(*$? Safety: assert ((r >= F0) & (fpu () = softReal));*)$lastSymbol:= CurrentSymbol;$TreeSearch (ADR (FP[r,upper]));$IF ORD (CurrentSymbol.typ) # 17 (* VAR *) THEN&Assign (FP[r,upper],BadId,ok); SyntaxError (rNoRun)$END;$initMemExpr (expr, item, absRef, FALSE);$expr.varItem:= CurrentSymbol.item;$CurrentSymbol:= lastSymbol;"END initPseudoRegExpr;   PROCEDURE initRegExpr (VAR expr: ExprDesc; size: CARDINAL; reg: RegType);"BEGIN$initExpr (expr, sizedItem (size, FALSE), register);$expr.exprReg:= reg"END initRegExpr;   PROCEDURE makeIndir (VAR expr: ExprDesc; ofs: LONGINT; odd: BOOLEAN);"(* IN: expr Adr. des Datums in Reg#* OUT: expr adressiert Datum mit Offset als "ofs(An)"#*      oder "ADDA ofs,An; (An)"#*)"VAR t: PtrItem;"BEGIN$WITH expr DO&IF kind = register THEN((*$? Safety2: assert (exprReg > D7); *)(IF (ofs > LONG (MaxInt))(OR (ofs < LONG (MinInt)) THEN*t:= expr.item;*expr.item:= CardPtr; (* f. Long-MOVE *)*loadReg (expr, addrRegs); (* falls Reg = A6 *)*expr.item:= t;*genADDAL (ofs, exprReg);*ofs:= 0;(END;(baseReg:= exprReg;(kind:= memory;(mode:= d16An;(mayBeOdd:= odd;(disp:= ofs;&ELSE((*$? Safety:*assert ((ofs = 0L) & ~odd);*assert (kind = memory);(*)(IF mode = immRef THEN (* globale Proc *)*mode:= absRef(ELSIF mode = relConst THEN (* lokale Proc *)*mode:= relRef(ELSE*bong(END&END$END"END makeIndir;  PROCEDURE makeIndirIdx (VAR expr: ExprDesc; index: RegType; long: BOOLEAN;8odd: BOOLEAN);"(*#* Vorsicht: long=FALSE nur Åbergeben, wenn index in INTEGER paût,#*   aber nicht, wenn index zwar 2 Byte groû ist, aber > MaxInt#*   werden kann!#*)"BEGIN$WITH expr DO&(*$? Safety: assert (kind = register);*)&kind:= memory;&mayBeOdd:= odd;&baseReg:= exprReg;&idxReg:= index;&idxL:= long;&mode:= d8AnXn;&disp:= 0$END;"END makeIndirIdx;  PROCEDURE initConstExpr (VAR expr: ExprDesc; size: CARDINAL; const: ZZ);"BEGIN$initExpr (expr, sizedItem (size, FALSE), constant);$expr.exprConst.zz:= const"END initConstExpr;  (*$D-*) PROCEDURE getLink (tiefe: CARDINAL): RegType;"VAR baseReg: RegType; count: ExprDesc;"BEGIN$IF tiefe = 0 THEN&(*$? Safety: assert (VarReg # 0); *)&baseReg:= VarReg;$ELSE&baseReg:= allocReg (addrRegs);&genMOVELIndTo (VarReg, baseReg, StatLinkOffs);&IF tiefe > 4 THEN((*!!! Der StatLinkOffs muû pro Scope einzeln gemerkt und hier)*   berÅcksichtigt werden, weil es sonst schieffgeht, wenn eine)*   lokale Proc keine Parms hat oder die Parms auf dem A3 erwartet!)*)(initConstExpr (count, 2, toZZ (LONG(tiefe)-1L, FALSE));(loadReg (count, dataRegs);(genMOVELIndTo (baseReg, baseReg, StatLinkOffs);(genDBcc (mapNever (), count.exprReg, -4);(deallocRegs (count);&ELSE(WHILE tiefe > 1 DO*genMOVELIndTo (baseReg, baseReg, StatLinkOffs);*DEC (tiefe)(END&END$END;$RETURN baseReg"END getLink; (*$D-*)  PROCEDURE indir (VAR fact: ExprDesc): BOOLEAN;"BEGIN$WITH fact DO&RETURN (kind = memory) & (mode >= d16An)$END"END indir;   MODULE stackedRegs; "IMPORT SyntaxError, rBlkOv, RegType, A7, assert, tempRegs, A7Offset,)Safety, genPushReg, genPopReg, toZZ, incReg;""EXPORT pushNonTemp, popNonTemp, releaseNonTemp;""CONST max = 40;""VAR discardFromA7Stk: ARRAY [1..max] OF RECORD:reg: RegType;:long: BOOLEAN;:ofs: LONGINT8END;&discardFromA7SP: CARDINAL; "PROCEDURE pushNonTemp (regToPush: RegType; longReg: BOOLEAN);$(* ist nur fÅr nicht-temporÑre Regs gedacht! *)$BEGIN&(*$? Safety: assert (NOT (regToPush IN tempRegs));*)&IF discardFromA7SP = max THEN SyntaxError (rBlkOv) END;&INC (discardFromA7SP);&WITH discardFromA7Stk [discardFromA7SP] DO(reg:= regToPush;(long:= longReg;(genPushReg (reg, long, A7);(ofs:= A7Offset;&END;$END pushNonTemp; "PROCEDURE popNonTemp (regToPop: RegType);$BEGIN&(*$? Safety: assert (discardFromA7SP # 0);*)&WITH discardFromA7Stk [discardFromA7SP] DO((*$? Safety:*assert (ofs = A7Offset);*assert (reg = regToPop);(*)(genPopReg (reg, long, A7);&END;&DEC (discardFromA7SP);$END popNonTemp; "PROCEDURE releaseNonTemp (to: LONGINT);$VAR a7: LONGINT; n: CARDINAL;$BEGIN&a7:= A7Offset;&n:= discardFromA7SP;&WHILE A7Offset # to DO(IF n # 0 THEN*WITH discardFromA7Stk [n] DO,incReg (A7, toZZ (ofs - A7Offset, TRUE), 4);,genPopReg (reg, long, A7)*END;*DEC (n);(ELSE*incReg (A7, toZZ (to - A7Offset, TRUE), 4)(END&END;&A7Offset:= a7$END releaseNonTemp;""END stackedRegs;  (* --- Code erzeugende Routinen --- *)   FORWARD spillReg (desiredRegs: RegSet); FORWARD spillRegByMove (desiredRegs: RegSet): BOOLEAN;  PROCEDURE getReg (from: RegSet): RegType;"VAR r: RegType;"BEGIN$from:= from * freeRegs;$FOR r:= MIN (RegType) TO MAX (RegType) DO&IF r IN from THEN(EXCL (freeRegs,r);(RETURN r&END$END;$bong"END getReg;  PROCEDURE getHiReg (from: RegSet): RegType;"VAR r: RegType;"BEGIN$from:= from * freeRegs;$FOR r:= MAX (RegType) TO MIN (RegType) BY -1 DO&IF r IN from THEN(EXCL (freeRegs,r);(RETURN r&END$END;$bong"END getHiReg;  PROCEDURE getThisReg (r: RegType): BOOLEAN;"BEGIN$IF r IN freeRegs THEN&EXCL (freeRegs, r);&RETURN TRUE$ELSE&RETURN FALSE$END"END getThisReg;  PROCEDURE allocReg ( desiredRegs: RegSet ) : RegType;"BEGIN$IF desiredRegs - varRegs # RegSet {} THEN&desiredRegs:= desiredRegs * tempRegs;&(* wenn nicht ausschlieûlich Regs f. Reg-Vars gewÅnscht werden, bedeutet'* das, daû eigentlich ausschlieûlich temp. gewÅnscht sein, die andern'* wurden nur z.B. bei loadReg zugelassen, falls der Wert schon in einer'* Reg-Var steht *)&IF desiredRegs * freeRegs = RegSet {} THEN(IF NOT spillRegByMove (desiredRegs) THEN*REPEAT,spillReg (desiredRegs)*UNTIL desiredRegs * freeRegs # RegSet {};(END&END;&RETURN getReg (desiredRegs)$ELSE&RETURN getHiReg (desiredRegs * varRegs)$END;"END allocReg;  PROCEDURE allocRegVar (desired: VarType; VAR r: RegType): BOOLEAN;"VAR (*$Reg*)regs: RegSet;"BEGIN$IF desired = dataVar THEN&regs:= RegSet {D0..D7}$ELSIF desired = ptrVar THEN&regs:= RegSet {A0..A7}$ELSE&regs:= RegSet {F0..F7}$END;$regs:= regs * freeVarRegs * varRegs;$IF regs * freeRegs # RegSet {} THEN&r:= getHiReg (regs);&RETURN TRUE$ELSE&RETURN FALSE$END"END allocRegVar;  PROCEDURE allocAddrRegIfAllowed ( desiredRegs: RegSet ) : RegType;"(*#* wie 'allocReg', nur wird, wenn gewÅnscht, ein Adreûreg. alloziert,#* sofern eins frei ist#*)"BEGIN$IF (desiredRegs * addrRegs # RegSet {})$&  (freeRegs * addrRegs # RegSet {}) THEN&RETURN allocReg (addrRegs)$ELSE&RETURN allocReg (desiredRegs)$END;"END allocAddrRegIfAllowed;  PROCEDURE deallocReg ( reg: RegType );"BEGIN$IF reg IN tempRegs THEN&(*$? Safety: assert (~(reg IN freeRegs));*)&INCL (freeRegs, reg);$END"END deallocReg;  PROCEDURE deallocRegVar ( reg: RegType );"BEGIN$(*$? Safety: assert (reg IN varRegs);1assert (~(reg IN freeRegs));*)$INCL (freeRegs, reg);"END deallocRegVar;  PROCEDURE deallocRegs ( VAR expr: ExprDesc );"(* deallocate the registers that were used by expr *)"BEGIN$WITH expr DO&CASE kind OF&| register: deallocReg (exprReg);&| memory:   CASE mode OF2| d16An:  deallocReg (baseReg);2| d8AnXn: deallocReg (baseReg); deallocReg (idxReg);2ELSE2END&| stack:    deallocReg (stackReg);&ELSE&END;$END;"END deallocRegs;  PROCEDURE deallocHighReg ( VAR expr: ExprDesc );"BEGIN$IF expr.highReg >= A0 THEN deallocReg (expr.highReg) END"END deallocHighReg;   PROCEDURE exclRegs (REF expr: ExprDesc; VAR regs: RegSet);"(* IN: expr, regs; OUT: regs *)"(* fÅgt Register aus 'regs' aus, die von 'expr' benutzt werden *)"BEGIN$WITH expr DO&CASE kind OF&| register: EXCL (regs, exprReg);&| stack:    EXCL (regs, stackReg);&| memory:2CASE mode OF2| d16An:  EXCL (regs, baseReg);2| d8AnXn: EXCL (regs, baseReg); EXCL (regs, idxReg);2ELSE2END&ELSE&END;$END;"END exclRegs;  PROCEDURE exprUsesRegs (VAR expr: ExprDesc; regs: RegSet): BOOLEAN;"(* TRUE, wenn die Expr eines der 'regs' belegt *)"BEGIN$WITH expr DO&CASE kind OF&| register: RETURN exprReg IN regs;&| memory:   CASE mode OF2| d16An:  RETURN baseReg IN regs;2| d8AnXn: RETURN (baseReg IN regs) OR (idxReg IN regs);2ELSE2END&| stack:    RETURN stackReg IN regs;&ELSE&END;$END;$RETURN FALSE"END exprUsesRegs;  PROCEDURE usesTempRegs ( VAR expr: ExprDesc ): BOOLEAN;"(* return TRUE if temp. Regs are allocated by expr *)"BEGIN$RETURN exprUsesRegs (expr, tempRegs)"END usesTempRegs;   PROCEDURE cancelExpr (VAR expr: ExprDesc);"(*#* muû aufgerufen werden, wenn eine Expr verworfen wird.#* denn hier wird dann ggf. der Stack von dem noch drauf befindlichen#* Datum gesÑubert.#* 'restoreStack' und 'deallocRegs' mÅssen zusÑtzlich noch aufgerufen werden!#*)"BEGIN$WITH expr DO&IF kind = stack THEN(IF stackReg = A3 THEN*incReg (A3, toZZ (-LONGINT (stackedSize), TRUE), 4)(ELSE*(*$? Safety: assert (stackReg = A7);*)*incReg (A7, toZZ (stackedSize, FALSE), 4)(END;(stackedSize:= 0&ELSE((*$? Safety:*assert ((kind # memory) OR ((mode # ptrOnA3) & (mode # ptrOnA7)))(*)&END$END"END cancelExpr;   PROCEDURE clearExpr (VAR expr: ExprDesc);"(* Ergebnis lîschen. *)"VAR r: RegType;"BEGIN$cancelExpr (expr);$deallocRegs (expr);$expr.kind:= constant;$expr.exprConst.zz:= toZZ (0L, FALSE)"END clearExpr;  PROCEDURE restoreStack (VAR expr: ExprDesc);"BEGIN$WITH expr DO&IF (kind = stack) & (restoreAfterUse # 0L) THEN(bong; (*&&& sollte wohl z.Zt. nicht auftreten *)((**(*$? Safety: assert (stackReg = A3);*)*incReg (A3, toZZ (-LONGINT (restoreAfterUse), TRUE), 4);*restoreAfterUse:= 0(*)&END$END"END restoreStack;  PROCEDURE noDataAccess (VAR expr: ExprDesc);"(*#* LÑdt expr in ein Datenreg, falls es in einem Adreû-Reg liegt.#* Dies ist z.B. bei den MUL-Instr. nîtig, weil diese kein Adr-Reg#* als source erlauben, jedoch ggf. durch vorigen Expand oder Spill#* der Wert in ein Adr-Reg kam.#*)"BEGIN$IF (expr.kind = register) & (expr.exprReg >= A0) THEN&loadReg (expr, dataRegs)$END"END noDataAccess;   PROCEDURE reloadPtr (VAR expr: ExprDesc);"(* reloads baseReg, if mode = ptrOnA3/A7 *)"VAR r: RegType;"BEGIN$WITH expr DO&IF (kind = memory) & ( (mode = ptrOnA3) OR (mode = ptrOnA7) ) THEN(r:= allocReg (addrRegs);((* verifizieren, daû richtiger Wert vom Stack geholt wird: *)((*$? Safety: assert ((mode # ptrOnA7) OR (depth = A7Offset));*)(genPullReg (expr, TRUE, r);((*$? Safety: assert ((mode # ptrOnA3) OR (depth = A3Offset));*)(mode:= d16An;(disp:= 0;(baseReg:= r&ELSIF kind = spilledSP THEN(stackReg:= allocReg (addrRegs);((*$? Safety: IF spillReg = A7 THEN assert (spillOfs = A7Offset) END;*)(genPullReg (expr, TRUE, stackReg);((*$? Safety: IF spillReg = A3 THEN assert (spillOfs = A3Offset) END;*)(kind:= stack&END;$END;"END reloadPtr;  PROCEDURE swapExpr (VAR left, right: ExprDesc);"VAR temp: ExprDesc;"BEGIN$temp:= left;$left:= right;$right:= temp"END swapExpr;  PROCEDURE PushExpr ( expr: ExprDesc );"BEGIN$IF exprSp < maxDepth THEN&INC (exprSp);&exprStack[exprSp].expr:= expr;&exprStack[exprSp].maySpill:= TRUE;$ELSE&SyntaxError (rExOvr)$END;"END PushExpr;  PROCEDURE PushExprNoSpill ( expr: ExprDesc );"BEGIN$PushExpr (expr);$exprStack[exprSp].maySpill:= FALSE"END PushExprNoSpill;  PROCEDURE LookExpr ( VAR expr: ExprDesc );"BEGIN$IF exprSp >= 0 THEN&expr:= exprStack[exprSp].expr;$ELSE&bong$END;"END LookExpr;  PROCEDURE PopExpr ( VAR expr: ExprDesc );"BEGIN$LookExpr (expr);$DEC (exprSp);$IF spillSp > exprSp THEN spillSp:= exprSp END;"END PopExpr;   FORWARD pushRealReg (VAR expr: ExprDesc; to: RegType);  PROCEDURE pushReg (VAR expr: ExprDesc; sp: RegType);"(*#* lÑdt ein Reg auf den Stack#*#* ACHTUNG: dabei darf nicht rekursiv ein neues Spilling ausgelîst#*  werden!#*)"VAR dir: Directions;"BEGIN$(*$? Safety: assert ((sp = A7) OR (sp = A3));*)$IF sp = A7 THEN dir:= down ELSE dir:= up END;$WITH expr DO&deallocReg (exprReg);&IF sp = A3 THEN stackPtr:= A3Offset END;&IF exprReg >= F0 THEN(pushRealReg (expr, sp)&ELSE(genPush (expr, 0, sp, dir)&END;&kind:= stack;&stackReg:= sp;&up:= (sp = A7);&restoreAfterUse:= 0;&stackedSize:= roundedSize (expr);&IF sp = A7 THEN stackPtr:= A7Offset END;$END"END pushReg;  (*$E-*)  PROCEDURE spillRegByMove (desiredRegs: RegSet): BOOLEAN;"(*#* Anwendung vor spillReg-Aufruf: Wenn TRUE, konnte ein Reg freigemacht#* werden, indem das vorige in ein anderes Reg umgeladen wurde.#*)""VAR (*$Reg*)unused: RegSet; (*$Reg*)mySpillSp: ExprSP; "BEGIN$desiredRegs:= desiredRegs - RegSet {F0..F7};$mySpillSp:= spillSp;$WHILE mySpillSp < exprSp DO&INC (mySpillSp);&WITH exprStack[mySpillSp].expr DO(CASE kind OF(| register:  IF exprReg IN desiredRegs THEN7unused:= (freeRegs - desiredRegs) * (dataRegs+addrRegs);7IF exprStack[mySpillSp].maySpill THEN9IF exprReg IN dataRegs THEN;unused:= unused * addrRegs9ELSE;unused:= unused * dataRegs9END;7END;7IF (unused # RegSet {}) & (TypeLength (item) # 1L) THEN9(* das neu belegte Register ist also keins,:* was genîtigt wird::* Es wird in ein anderes, freies Reg umgeladen *)9loadAllocedReg (exprStack[mySpillSp].expr, getReg (unused));9RETURN TRUE7END5END; (| memory:    IF (mode = d16An) OR (mode = d8AnXn) THEN7IF NOT (baseReg IN desiredRegs)7AND (mode = d8AnXn) & (idxReg IN desiredRegs) THEN9(* wenn ein Datenreg aber kein AddrReg benîtigt:* wird, braucht nur der Index aufaddiert werden *)9IF baseReg IN tempRegs THEN;genADDA (idxL, idxReg, baseReg);;deallocReg (idxReg);;mode:= d16An;;RETURN TRUE9END7END;5END(ELSE(END;&END;$END;$RETURN FALSE"END spillRegByMove;  PROCEDURE spillReg (desiredRegs: RegSet);"(*#* Wenn nur ein Reg freigemacht werden soll, wird ggf. das Reg durch einen#* MOVE zu einem freien Reg freigemacht.#*)""PROCEDURE outOfRegs;$BEGIN&BadId:= 'out of registers';&SyntaxError (rFatlR)$END outOfRegs;$"VAR (*$Reg*)unused: RegSet; (*$Reg*)r: RegType; "BEGIN$IF spilling THEN bong END;$spilling:= TRUE;$IF spillSp >= exprSp THEN&outOfRegs;$ELSE&INC (spillSp);&WITH exprStack[spillSp] DO(WITH expr DO*CASE kind OF*| register:  IF exprReg IN tempRegs THEN9IF NOT maySpill THEN outOfRegs END;9pushReg (expr, spillDestReg);7END;"*| memory:    IF (mode = d16An) OR (mode = d8AnXn) THEN9IF (baseReg IN tempRegs)9OR (mode = d8AnXn) & (idxReg IN tempRegs) THEN;IF spillDestReg = A3 THEN=depth:= A3Offset;;END;;IF NOT maySpill THEN outOfRegs END;;genPushAddress (expr, spillDestReg);;deallocRegs (expr);;IF spillDestReg = A7 THEN=depth:= A7Offset;=mode:= ptrOnA7;ELSE=mode:= ptrOnA3;END9END;7END**| stack:     IF stackReg IN tempRegs THEN9IF spillDestReg = A3 THEN spillOfs:= A3Offset END;9IF NOT maySpill THEN outOfRegs END;9genPushReg (stackReg, TRUE, spillDestReg);9deallocReg (stackReg);9IF spillDestReg = A7 THEN spillOfs:= A7Offset END;9kind:= spilledSP;9spillReg:= spillDestReg;7END*ELSE*END;(END;&END;$END;$spilling:= FALSE"END spillReg;  PROCEDURE spillRegs (desiredRegs: RegSet);"(* sichert die benîtigten Regs *)"VAR ok: BOOLEAN;"BEGIN$IF desiredRegs * freeRegs # desiredRegs THEN&LOOP(IF NOT spillRegByMove (desiredRegs) THEN EXIT END;(IF desiredRegs * freeRegs = desiredRegs THEN RETURN END&END;&REPEAT(spillReg (desiredRegs)&UNTIL desiredRegs * freeRegs = desiredRegs$END"END spillRegs;  PROCEDURE spillAllRegs ();"(* sichert alle temporÑren Regs *)"BEGIN$(*&&& auch reg-vars in ihre%*    memory-zelle retten. dafÅr sorgen, daû beim nÑchsten%*    benutzen der wert wieder ins reg geladen wird und dort bleibt *)$spillRegs (tempRegs);"END spillAllRegs;  PROCEDURE spillAllRegsExcept (VAR expr: ExprDesc);"(* sichert alle temporÑren Regs auûer denen von 'expr' *)"VAR regs: RegSet;"BEGIN$regs:= tempRegs;$exclRegs (expr, regs);$spillRegs (regs);"END spillAllRegsExcept;  PROCEDURE loadAddressTo ( VAR expr: ExprDesc; niceRegs: RegSet );"(*#* LÑdt Referenz der Expr. in ein Adreû-Reg. und setzt LÑnge auf 4.#* Ist die Expr eine Konstante, wird die Konstante dazu im Code abgelegt.#* Wird z.B. f. ADR()-Funktion benutzt.#*)"VAR r: RegType; ptr: ADDRESS; gl: BOOLEAN; ofs: LONGINT;"BEGIN$ofs:= 0;$WITH expr DO&IF kind = constant THEN(changeConstantToConstRef (expr, Size (expr));&END;&IF (kind = constRef) THEN((* LEA <const-adr>,An und INC(An,<constOfs) generieren *)(ofs:= constOfs;(kind:= memory;(mode:= absRef;(tiefe:= 0;(mayBeOdd:= FALSE;((* Achtung: hier muû 'constHead' noch erhalten bleiben! *)&ELSIF kind = stack THEN((*$? Safety: assert ((stackReg # A3) OR (up) OR (stackedSize = 0L));*)(changeStackToIndir (expr)&END;&assert ((kind = memory) & (mode # immRef));&IF ((mode = d16An) OR (mode = d8AnXn)) & ~shortInt (disp) THEN((* Sonderbehandlung: Obwohl bei d16An 'disp' nur 16 Bit groû)* sein darf, werten wir hier ggf. auch grîûere Offsets aus,)* da dies u.U. bei Zuweisung groûer Daten vom Stack in)* 'loadSizedAddress' vorkommt. FÅr evtl. Adr-Arten der 68020)* ist das eh' sinvoll. *)((* statt  LEA disp(baseReg),r: LEA 0(baseReg),r + ADDA #ofs,r *)(ofs:= disp;(disp:= 0;&END;&IF (mode = d16An) & (baseReg IN niceRegs) & (ABS (disp) <= 8L) THEN((* statt LEA x(An),An wird ADDQ/SUBQ #x,An erzeugt,)* bei LEA 0(An),An wird sogar gar nix gen. *)(incReg (baseReg, toZZ (disp, TRUE), 4);(exprReg:= baseReg;&ELSIF (mode = d8AnXn) & (baseReg IN niceRegs) & (disp = 0L) THEN((* statt LEA 0(An,Xm),An wird ADD Xm,An gen. *)(genADDA (idxL, idxReg, baseReg);(deallocReg (idxReg);(exprReg:= baseReg;&ELSE(deallocRegs (expr);(r:= allocReg (niceRegs);(genLEA (expr, r);(exprReg:= r;&END;&kind:= register;&IF ofs # 0 THEN(incReg (exprReg, toZZ (ofs, TRUE), 4)&END;&item:= CardPtr;$END;"END loadAddressTo;  PROCEDURE loadAddress ( VAR expr: ExprDesc );"(*#* LÑdt Referenz der Expr. in ein Adreû-Reg. und setzt LÑnge auf 4.#* Ist die Expr eine Konstante, wird die Konstante dazu im Code abgelegt.#* Wird z.B. f.ADR()-Funktion benutzt.#*)"BEGIN$loadAddressTo (expr, addrRegs)"END loadAddress;  PROCEDURE loadSizedAddress (VAR expr, oldExpr: ExprDesc; size: LONGINT);"(* nur lokal fÅr die beiden folg. Routinen! *)"(* Test: FEHLER19.M *)"BEGIN$oldExpr:= expr;$WITH expr DO&IF (kind = stack) & NOT (stackReg IN tempRegs) THEN((*$? Safety: assert (stackReg IN RegSet {A3,A7});*)(IF ODD (size) THEN INC (size) END;(oldExpr.stackedSize:= size;(stackedSize:= size;(IF up THEN*(* LEA (A3),An *)*changeStackToIndir (expr);*loadAddress (expr);(ELSE*(* LEA -stackSize(A3),An *)*changeStackToIndir (expr);*disp:= -size;*loadAddress (expr);(END&ELSE(loadAddress (expr)&END$END"END loadSizedAddress;  PROCEDURE updateStack (VAR expr: ExprDesc);"VAR n: LONGINT;"BEGIN$WITH expr DO&IF (kind = stack) & NOT (stackReg IN tempRegs) THEN(n:= stackedSize;(IF NOT up THEN n:= -n END;(incReg (stackReg, toZZ (n, TRUE), 4);&END$END"END updateStack;  PROCEDURE loadDestAddress (VAR expr: ExprDesc; size: LONGINT);"(*#* wie 'loadExprAddress', jedoch mit manueller size-Angabe fÅr Destinations#* FÅr Destinations darf der Stack sofort korrigiert werden (dazu updateStacks#* aufrufen), weil der Wert ja immer auf den Stack kommt, so daû er auch#* sofort geschÅtzt werden sollte.#*)"VAR oldExpr: ExprDesc;"BEGIN$loadSizedAddress (expr, oldExpr, size);$updateStack (oldExpr)"END loadDestAddress;  PROCEDURE loadExprAddress (VAR expr, oldExpr: ExprDesc);"(*#* wie 'loadAddress', geht auch, wenn Datum auf Stack steht.#* nicht fÅr Ziel-designator anzuwenden (dafÅr gibt's loadDestAddress)!#* Achtung: Da der Stack nicht gleich hier korrigiert werden darf,#*  muû dies nach dem Zugriff mit 'updateStack (oldExpr)' geschehen!#*)"BEGIN$loadSizedAddress (expr, oldExpr, LONGINT (expr.stackedSize));"END loadExprAddress;  PROCEDURE loadSourceAddress ( VAR expr: ExprDesc );"(*#* wie 'loadAddress', nur kann fÅr source-werte bei MOVE noch optimiert werden#*)"BEGIN$WITH expr DO&IF ((kind = constant) OR (kind = constRef)) & (constOfs = 0) THEN((* wenn absolute Adr, kann statt LEA adr,An besser #adr gen. werden *)(IF kind = constant THEN*changeConstantToConstRef (expr, Size (expr));(END;((*$? Safety: assert (kind = constRef); *)(kind:= constImm;(item:= CardPtr;(RETURN&ELSIF kind = memory THEN(IF mode = absRef THEN*(* wenn absolute Adr, kann statt LEA adr,An besser #adr gen. werden *)*mode:= immRef;*item:= CardPtr;*RETURN(ELSIF mode = extL THEN*(* wenn externe Adr, kann statt LEA adr,An besser #adr gen. werden *)*exprConst.l:= LONGWORD (extAddr);*kind:= constant;*item:= CardPtr;*RETURN(END&END$END;$loadAddress (expr)"END loadSourceAddress;  PROCEDURE moveAddress (VAR expr, dest: ExprDesc);"(*#* wie loadSourceAddress, nur wird der Wert gleich woanders abgelegt;#* Åblicherweise wird dies benutzt, um Variablen-Refs auf den Stack#* zu packen.#*)"VAR t: PtrItem;"BEGIN$(*~~~ hier ggf. stattdessen PEA gen. *)$WITH expr DO&t:= item;&IF (kind # memory)&OR (mode # d16An)&OR (disp # 0L) THEN(loadSourceAddress (expr)&ELSE(kind:= register;(exprReg:= baseReg&END;&item:= sizedItem (4, FALSE);&genMOVEaa (expr, dest, 0);&item:= t$END;"END moveAddress;  PROCEDURE inDataReg (VAR expr: ExprDesc): BOOLEAN;"BEGIN$RETURN (expr.kind = register) & (expr.exprReg < A0)"END inDataReg;  (* unbenutzt PROCEDURE moveReg ( source, dest: RegType; size: CARDINAL );"BEGIN$(*$? Safety: assert (~(source IN tempRegs) & ~(dest IN tempRegs));*)$genMOVErr (source, dest, size)"END moveReg; *)  (* unbenutzt PROCEDURE moveTempReg ( source, dest: RegType; size: CARDINAL );"BEGIN$(*$? Safety: assert ((source IN tempRegs) & ~(dest IN tempRegs));*)$deallocReg (source);$genMOVErr (source, dest, size)"END moveTempReg; *)  (* unbenutzt PROCEDURE moveToTempReg ( source: RegType;:VAR dest: RegType; niceRegs: RegSet; size: CARDINAL );"(* move register to one of niceRegs *)"BEGIN$(*$? Safety: assert (~(source IN tempRegs));*)$dest:= allocReg (niceRegs);$genMOVErr (source, dest, size)"END moveToTempReg; *)  PROCEDURE constToReg (v: ZZ; size: CARDINAL; r: RegType);"BEGIN$IF int8ZZ (v) & (r IN anyDataReg) THEN&genMOVEQ (v, r)$ELSE&genMOVEir (v, size, r)$END;"END constToReg;  PROCEDURE prepareStackForLoad (VAR expr: ExprDesc);"BEGIN$IF expr.kind = stack THEN&WITH expr DO(IF (stackReg = A3) & ~up THEN*incReg (stackReg,2toZZ (LONGINT (Size (expr)) - LONGINT (stackedSize), FALSE),24);*stackedSize:= Size (expr)(END;&END;$END;"END prepareStackForLoad;  FORWARD copy (VAR source, dest: ExprDesc; size: LONGCARD; byByte: BOOLEAN); FORWARD loadRealReg (VAR expr: ExprDesc; niceRegs: RegSet);  PROCEDURE loadAllocedReg ( VAR expr: ExprDesc; r: RegType );"(* load the expr. into the register *)"VAR op: CARDINAL;"BEGIN$IF (r >= F0) THEN&SyntaxError (rRegVa)$ELSE&(*$? Safety: assert ((r < A0) OR (Size (expr) # 1L)); *)&WITH expr DO(CASE kind OF(| constRef: (*$?Safety2: assert (constOfs = 0); *)4kind:= memory;4mode:= absRef;4genMOVEar (expr, r); (| constant: constToReg (exprConst.zz, SHORT (Size (expr)), r);((| condFlags:IF fpuFlags THEN6op:= mapFPUcc (relOp, not);4ELSE6op:= mapCC (relOp, signed, not);4END;4not:= FALSE; (* ~~~ ist das korrekt? oder nicht verÑndern? *)4kind:= register;4exprReg:= r;4genBool (op, fpuFlags, expr); (| register: IF (exprReg >= F0) & (item = SRealPtr) THEN6deallocReg (exprReg);6initPseudoRegExpr (expr, item, exprReg, FALSE);6genMOVEar (expr, r);4ELSE6genMOVEar (expr, r);6deallocReg (exprReg)4END;((| memory,*stack:    IF (kind = memory) & (mode = relConst) THEN6(*7* wir wollen die Adr. einer lok. Proc laden7* dann erzeugen wir stattdessen einen LEA7*)6(*$? Safety: assert (r >= A0);*)6mode:= relRef;6genLEA (expr, r);4ELSE6IF (kind = stack) THEN8(*$? Safety: assert ( (stackReg # A3) OR up ORN(Size (expr) = stackedSize) );*)6END;6genMOVEar (expr, r)4END;(END;&END$END;$expr.kind:= register;$expr.exprReg:= r;"END loadAllocedReg;  PROCEDURE loadRegVar ( VAR expr: ExprDesc; r: RegType );"BEGIN$(*$? Safety: assert (NOT (r IN freeRegs) & (r IN varRegs));*)$WITH expr DO&CASE kind OF&| register: IF exprReg # r THEN4loadAllocedReg (expr, r)2END;&| stack,(memory:   IF r < F0 THEN4deallocRegs (expr);2END;2(*$? Safety:4IF (kind = memory) & (mode = relConst) THEN6assert (r IN addrRegs);4END;2*)2prepareStackForLoad (expr);2loadAllocedReg (expr, r)&ELSE2loadAllocedReg (expr, r)&END;$END;"END loadRegVar;  PROCEDURE loadReg ( VAR expr: ExprDesc; niceRegs: RegSet );"(* load the expr. into one of the registers in niceRegs *)"VAR r: RegType;"BEGIN$IF niceRegs <= RegSet{F0..F7} THEN&loadRealReg (expr, niceRegs)$ELSE&WITH expr DO(CASE kind OF(| register: IF ~ ( exprReg IN niceRegs ) THEN6r:= allocReg (niceRegs);6loadAllocedReg (expr, r)4END;(| stack,*memory:   deallocRegs (expr);4IF (kind = memory) & (mode = relConst) THEN6niceRegs:= addrRegs * niceRegs;6(*$? Safety: assert (niceRegs # RegSet {});*)4END;4prepareStackForLoad (expr);4r:= allocReg (niceRegs);4loadAllocedReg (expr, r)(ELSE4r:= allocReg (niceRegs);4loadAllocedReg (expr, r)(END;&END;$END;"END loadReg;  PROCEDURE swapRegs (VAR left, right: ExprDesc);"(* tauscht Regs aus *)"VAR r: RegType;"BEGIN$(*$? Safety: assert ((left.kind = register) & (right.kind = register));*)$genEXG (right.exprReg, left.exprReg);$r:= right.exprReg;$right.exprReg:= left.exprReg;$left.exprReg:= r"END swapRegs;  PROCEDURE loadRegByEXG ( VAR expr: ExprDesc; destReg: RegType);"(* 'expr' soll nach 'destReg' geladen werden. 'destReg' ist aber belegt.#* Hier wird nun nach der Expr gesucht, die das Reg belegt und dann deren#* Reg in ein anderes Reg gelegt. Diese Routine geht davon aus, daû die#* anderen Exprs genau 'kind=register' sind, wenn sie das Reg belegen.#* Wird in dieser Form fÅr die Reg-Parm-öbergabe gebraucht.  *)"VAR (*$Reg*) mySpillSp: ExprSP;"BEGIN$IF destReg >= F0 THEN&SyntaxError (rNImpY)$ELSE&loadReg (expr, addrRegs+dataRegs);&mySpillSp:= spillSp;&WHILE mySpillSp < exprSp DO(INC (mySpillSp);(IF (exprStack[mySpillSp].expr.kind = register)(& (exprStack[mySpillSp].expr.exprReg = destReg) THEN*swapRegs (expr, exprStack[mySpillSp].expr);*RETURN(END;&END;&bong()$END;"END loadRegByEXG;   PROCEDURE extendRegToLong (VAR expr: ExprDesc);"VAR s: CARDINAL; t: PtrItem; r: RegType;"BEGIN$(*$? Safety: assert (expr.kind = register);*)$s:= SHORT (Size (expr));$IF s < 4 THEN&(*$? Safety: assert (s = 2);*)&IF signedExpr (expr) THEN(genr (EXTL, expr.exprReg);(t:= IntPtr&ELSE(genr (SWAP, expr.exprReg);(genr (CLRW, expr.exprReg);(genr (SWAP, expr.exprReg);(t:= SCardPtr&END;&expr.item:= t$END"END extendRegToLong;  PROCEDURE loadRegExt (VAR expr: ExprDesc; niceRegs: RegSet;6resultSize: CARDINAL; setType: BOOLEAN);"(* load expr into Reg and extend to 'resultSize' *)"VAR s: CARDINAL; r: RegType; unsignedExpand, signed: BOOLEAN;"BEGIN$(*$? Safety: assert (NOT (niceRegs <= RegSet {F0..F7})); *)$s:= SHORT (Size (expr));$IF s = resultSize THEN&loadReg (expr, niceRegs)$ELSE&(*$? Safety: assert (s < resultSize);*)&IF (expr.kind = constant) & int8ZZ (expr.exprConst.zz) THEN(r:= allocReg (niceRegs);(loadAllocedReg (expr, r);(IF r IN anyDataReg THEN*(* MOVEQ wurde erz., so daû kein weiteres Extend nîtig ist *)*RETURN(END&END;&&signed:= signedExpr (expr);&&unsignedExpand:= FALSE;&IF expr.kind = register THEN(IF signed THEN*r:= expr.exprReg;*IF NOT (r IN niceRegs) THEN,r:= allocReg (niceRegs);,loadAllocedReg (expr, r)*END;(ELSE*IF (expr.exprReg IN niceRegs) & (niceRegs * freeRegs = RegSet {}) THEN,(* Reg muû im gleichen Reg expandiert werden m. ANDI *),unsignedExpand:= TRUE*ELSE,r:= allocReg (niceRegs * dataRegs);,genClrReg (r);                (* MOVEQ #0,Dr *),loadAllocedReg (expr, r)*END;(END;&ELSE(IF signed & ( (expr.kind = memory) OR (expr.kind = stack) ) THEN*deallocRegs (expr)(END;(IF NOT signed(& exprUsesRegs (expr, niceRegs)(& (niceRegs * freeRegs = RegSet {}) THEN*(* Reg muû nach dem Load expandiert werden m. ANDI *)*unsignedExpand:= TRUE;(ELSIF signed & (s = 2) THEN*r:= allocAddrRegIfAllowed (niceRegs)(ELSE*r:= allocReg (niceRegs * dataRegs)(END;(IF NOT signed THEN*IF (expr.kind = memory) OR (expr.kind = stack) THEN,deallocRegs (expr)*END;*IF unsignedExpand THEN,r:= allocReg (niceRegs * dataRegs)*ELSE,genClrReg (r);                (* MOVEQ #0,Dr *)*END;(END;(prepareStackForLoad (expr);(loadAllocedReg (expr, r);&END;&&(*$? Safety: assert (expr.exprReg IN niceRegs); *)&&IF signed & (r < A0) THEN(IF s = 1 THEN genr (EXTW, expr.exprReg); END;(IF resultSize = 4 THEN genr (EXTL, expr.exprReg); END&ELSIF unsignedExpand THEN((* ANDI auf Data-Reg *)(IF resultSize = 2 THEN*genANDI (2, $00FF, expr.exprReg);(ELSIF s = 1 THEN*genANDI (4, $000000FFL, expr.exprReg)(ELSE*genANDI (4, $0000FFFFL, expr.exprReg)(END&END;&&IF setType THEN(expr.item:= sizedItem (resultSize, signed)&END$END"END loadRegExt;  PROCEDURE copyRegExt (REF source: ExprDesc; VAR second: ExprDesc;6niceRegs: RegSet; destSize: CARDINAL);"(*#* kopiert <ea> aus 'source' in ein neues Reg und liefert dessen#* Beschreibung in 'second'.#* Optional kann eine Grîûe (destSize > 0) fÅr das zweite Reg.#* bestimmt werden, so daû dann ein expand gemacht wird.#* Wenn 'niceRegs' auch Adreûreg. erlaubt und ein signed expand nîtig ist,#* wird, falls eins der Adr-Regs frei ist, der Wert dorthinein kopiert.#*)"VAR sourceSize: CARDINAL; signed: BOOLEAN; regs: RegSet; reg: RegType;"BEGIN$second:= source;$sourceSize:= SHORT (Size (source));$IF sourceSize < destSize THEN&(* expand *)&signed:= signedExpr (source);&IF signed THEN(IF sourceSize = 2 THEN*reg:= allocAddrRegIfAllowed (niceRegs)(ELSE*reg:= allocReg (niceRegs * dataRegs)(END;(regs:= freeRegs;(loadAllocedReg (second, reg);(IF reg < A0 THEN*IF sourceSize = 1 THEN genr (EXTW, reg); END;*IF destSize = 4 THEN genr (EXTL, reg); END(END;&ELSE(reg:= allocReg (dataRegs * niceRegs);(genClrReg (reg);     (* MOVEQ #0,Dr *)(regs:= freeRegs;(loadAllocedReg (second, reg);&END;&second.item:= sizedItem (destSize, signed)$ELSE&reg:= allocReg (niceRegs);&regs:= freeRegs;&loadAllocedReg (second, reg);$END;$freeRegs:= regs"END copyRegExt;  PROCEDURE copyRef ( VAR expr, ref: ExprDesc );"(*#* Legt eine Kopie von 'expr' an, so daû nun beide auf keinen Fall das#* selbe Adr-Reg benutzen und damit nicht der eine den Ptr des andern#* Ñndern kann.#* Die Routine legt z.Zt. einfach immer zwei Adr-Regs an, auch wenn dies#* nicht nîtig wÑre, z.B. bei absolut-Zugriffen.#* Beide Exprs zeigen danach mit (An) auf den Wert.#*)"VAR t: PtrItem; odd: BOOLEAN;"BEGIN$(*$? Safety: assert (expr.kind # stack); (* wer rÑumt sonst den Stack ab? *) *)$t:= expr.item;$odd:= (expr.kind = memory) & expr.mayBeOdd;$loadAddressTo (expr, addrRegs);$copyRegExt (expr, ref, addrRegs, 0);$makeIndir (expr, 0, odd);$makeIndir (ref, 0, odd);$expr.item:= t;$ref.item:= t"END copyRef;  PROCEDURE newRegWithConstant (VAR expr: ExprDesc; size: CARDINAL; const: ZZ);"(* lÑdt die Konst in ein neues Datenregister; 'item' ist NIL! *)"VAR r: RegType;"BEGIN$r:= allocReg (dataRegs);$constToReg (const, size, r);$initExpr (expr, NIL, register);$expr.exprReg:= r"END newRegWithConstant;  PROCEDURE moveA6toTempReg (VAR baseReg: RegType);"VAR r: RegType;"BEGIN$IF NOT (baseReg IN tempRegs) (* Vorsicht, wenn sich varRegs & tempRegsB* Åberlappen&&& Dann mÅssen auch Var-RegsB* geschÅtzt werden! *)$THEN&r:= allocReg (addrRegs);&genMOVErr (baseReg, r, 4);&deallocReg (baseReg);&baseReg:= r$END;"END moveA6toTempReg;  PROCEDURE addIdxReg (VAR expr, index: ExprDesc; long, nullDisp: BOOLEAN);"(* IN: expr zum Zugriff auf Datum mit indir. Zugriff (d16 o. d8)#*     'nullDisp': TRUE, wenn voraussichtlich 'disp' Null bleibt.#* OUT: expr plus index-Reg#*#* Vorsicht: long=FALSE nur Åbergeben, wenn index in INTEGER paût,#*   aber nicht, wenn index zwar 2 Byte groû ist, aber > MaxInt#*   werden kann!#*)"BEGIN$(*%* 1) (An)        -> ADD index,An / wenn index in Reg: 0(An,index)%* 2) disp(An)    -> disp(An,index), falls ABS (disp) < 128 & disp # 0%* 3) disp(An,Xn) -> ADD index,An%*)$WITH expr DO&(*$? Safety: assert ((kind = memory) & (Size (index) > 1L));*)&IF (mode = d16An) & byteVal (disp)&AND (NOT nullDisp OR (disp # 0) OR (index.kind = register)) THEN(loadReg (index, anyCPUReg);(restoreStack (index);(mode:= d8AnXn;(idxReg:= index.exprReg;(idxL:= long&ELSE(moveA6toTempReg (baseReg);(genar (ADDA, index, baseReg);(restoreStack (index);(deallocRegs (index)&END$END"END addIdxReg;  PROCEDURE addDisp (VAR expr: ExprDesc; ofs: LONGINT);"(* IN: expr zum Zugriff auf Datum mit indir. Zugriff (d16 o. d8)#* OUT: expr mit neuem offset ('ofs' wird addiert)#*)"BEGIN$WITH expr DO&(*$? Safety:(assert ((expr.kind = memory) & ( (mode=d8AnXn) OR (mode=d16An) ));&*)&INC (ofs, disp);&IF mode = d8AnXn THEN(IF (ofs > LONG (127)) OR (ofs < LONG (-128)) THEN*moveA6toTempReg (baseReg);*genADDA (idxL, idxReg, baseReg);*deallocReg (idxReg);*mode:= d16An(END&END;&IF mode = d16An THEN(IF (ofs > LONG (MaxInt))(OR (ofs < LONG (MinInt)) THEN*moveA6toTempReg (baseReg);*genADDAL (ofs, baseReg);*ofs:= 0(END;&END;&disp:= ofs$END"END addDisp;  PROCEDURE addOffset (VAR fact: ExprDesc; ofs: LONGINT);"(* Achtung: fact.item muû hiernach wieder neu gesetzt werden, weil#*          wg. 'loadAddress' dieser immer auf CardPtr gesetzt wird! *)"VAR odd: BOOLEAN;"BEGIN$odd:= oddAccess (fact) OR ODD (ofs); (* ~~~ immer? *)$IF indir (fact) THEN&addDisp (fact, ofs);&fact.mayBeOdd:= odd$ELSIF ofs # 0L THEN&loadAddress (fact);&makeIndir (fact, ofs, odd);$END"END addOffset;   PROCEDURE loadCCR ( VAR expr: ExprDesc );"(* check the BOOLEAN *)"BEGIN$WITH expr DO&(*$? Safety: assert (BooleanType (item));*)&CASE kind OF&| condFlags: (* OK *)&| constant: bong&| register,(memory,(stack:     gena (TST, expr, 0);3deallocRegs (expr);3kind:= condFlags;3fpuFlags:= FALSE;3signed:= FALSE;3relOp:= ne&END;$END;"END loadCCR;  PROCEDURE tstAndJmp (true: BOOLEAN; VAR fact: ExprDesc; VAR targets: Labels;5VAR oldExpr: ExprDesc; VAR backPtr: ADDRESS);"VAR lbl: Label; negate: BOOLEAN; n: CARDINAL;"BEGIN$(*$? Safety: assert (fact.kind # jmp);*)$loadCCR (fact);$backPtr:= CodePtr ();$oldExpr:= fact;$negate:= fact.not;$IF NOT true THEN negate:= NOT negate END;$(*$? Safety: assert (fact.kind = condFlags);*)$IF fact.fpuFlags THEN&n:= mapFPUcc (fact.relOp, negate);$ELSE&n:= mapCC (fact.relOp, fact.signed, negate);$END;$genbcc (n, fact.fpuFlags, lbl);$fact.kind:= jmp;$MarkRef (lbl, targets);"END tstAndJmp;  PROCEDURE moveAndJmp (true: BOOLEAN; VAR fact: ExprDesc; VAR targets: Labels;6VAR oldExpr: ExprDesc; VAR backPtr: ADDRESS);"VAR lbl: Label; negate: BOOLEAN;"BEGIN$(*$? Safety: assert (fact.kind # jmp);*)$loadReg (fact, RegSet{D0});$backPtr:= CodePtr ();$oldExpr:= fact;$negate:= fact.not;$IF NOT true THEN negate:= NOT negate END;$genbcc (mapCC (ne, FALSE, negate), FALSE, lbl);$MarkRef (lbl, targets);"END moveAndJmp;   (* ----------------------------------------------------------------------- *) (*   diverse Hilfsroutinen  *)  PROCEDURE getConversionDesc (source, dest: PtrItem; VAR d: ConvDesc);"(*#* Liefert fÅr 'safe conversion' sowie expand/shorten die erforderlichen#* Codierungs-Infos sowie den Ergebnistypen (=dest). Wird von 'fitValue'#* dann angepaût.#*)"BEGIN$ASSEMBLER(MOVE.L  d(A6),A2(MOVE.L  dest(A6),D0     ;dest(MOVE.L  source(A6),D2   ;source(MOVE.L  TreeBase,A1((CLR.W   ConvDesc.boundsCheck(A2)(CLR.B   ConvDesc.sizeFlags(A2)(CLR     ConvDesc.signedBounds(A2)(CMPI.B  #6,-1(A1,D2.L)  ; Procedure?(BNE     takeLen(MOVE.W  #4,ConvDesc.sourceSize(A2)(BRA     wasProc takeLen MOVE.W  -4(A1,D2.L),ConvDesc.sourceSize(A2) wasProc MOVE.W  -4(A1,D0.L),ConvDesc.destSize(A2)(MOVE.L  D0,ConvDesc.destType(A2)((CMP.L   D0,D2(BEQ.W   isComp           ;gleiche Typen  -> kein Code nîtig((CMPI.B  #11,-1(A1,D2.L) ;Source Subr ?(BNE     Comp12(MOVE.L  -18(A1,D2.L),D2 ;ja: durch Basetype ersetzen Comp12(; BOOLEANs, BITNUM und Enums bei Source werden als CARDINAL geprÅft:(CMPI.B  #24,-1(A1,D2.L) ;BOOLEAN?(BEQ     isBool2(CMPI.B  #41,-1(A1,D2.L) ;BITNUM?(BEQ     isBool2(CMPI.B  #9,-1(A1,D2.L)  ;Enum?(BNE     noEnum isBool2 MOVE.L  SCardPtr,D2 noEnum(MOVE.W  -2(A1,D0.L),D1  ;Dest-Kennung((CMPI.B  #11,D1(BEQ     isSubr(CMPI.B  #24,D1          ;BOOLEAN? dann CARDINAL [0..1](BEQ     isBool(CMPI.B  #41,D1          ;BITNUM? dann CARDINAL [0..31](BEQ     isBin(CMPI.B  #9,D1           ;Enum? dann CARDINAL [0..MAX(enum)](BEQ     isEnum((BSR.W   asComp1(TST.B   ConvDesc.sizeFlags(A2)(BPL.W   ende(; Dest ist CHAR und muû als CARDINAL [0..255] gechecked werden(CLR.L   ConvDesc.lowerBound(A2)(MOVE.L  #255,ConvDesc.upperBound(A2)(MOVE    #1,ConvDesc.boundsCheck(A2)(MOVE    #1,ConvDesc.boundSize(A2)(BRA.W   ende( isEnum  ; Dest ist Enum(MOVE.L  -10(A1,D0.L),ConvDesc.upperBound(A2) contDst CLR.L   ConvDesc.lowerBound(A2)(MOVE.L  SCardPtr,D0     ;BaseType(BRA     hdlSubr((; Dest ist BOOLEAN isBool  MOVE.L  #1,ConvDesc.upperBound(A2)(BRA     contDst((; Dest ist BITNUM isBin   MOVE.L  #31,ConvDesc.upperBound(A2)(BRA     contDst( isSubr  ; Dest ist Subrange(MOVE.L  -10(A1,D0.L),ConvDesc.lowerBound(A2)(MOVE.L  -14(A1,D0.L),ConvDesc.upperBound(A2)(MOVE.L  -18(A1,D0.L),D0 ;BaseType( hdlSubr BSR     asComp1(MOVE    #1,ConvDesc.boundsCheck(A2)(CMPI.W  #2,-4(A1,D0.L) ;Laenge des BaseType:(BEQ     Comp3        ; Word ->(BCS     Comp40       ; Byte ->(MOVE    #4,ConvDesc.boundSize(A2)(CMP.L   IntPtr,D0      ;*** Long: signed?(BNE     isComp(ADDQ    #1,ConvDesc.signedBounds(A2)(BRA     isComp Comp40  MOVE    #1,ConvDesc.boundSize(A2)(CMP.L   BytIPtr,D0      ;*** Byte signed?(BNE     isComp(ADDQ    #1,ConvDesc.signedBounds(A2)(BRA     isComp Comp3   MOVE    #2,ConvDesc.boundSize(A2)(CMP.L   SIntPtr,D0    ;*** Word RangeCheck(BNE     isComp(ADDQ    #1,ConvDesc.signedBounds(A2) isComp  BRA.W   ende  asComp1 LEA     AsTab(PC),A0(BRA     search2 search  ADDQ.L  #2,A0 search2 MOVE.B  (A0)+,D1(BEQ.L   rtn(CMP.B   -1(A1,D2.L),D1(BNE     search         ;Sourcetyp falsch(MOVE.B  (A0),D1(CMP.B   -1(A1,D0.L),D1(BNE     search         ;Desttyp falsch((MOVE.B  1(A0),D1       ;gefunden: Code fuer Typanpassung holen(MOVE.B  D1,ConvDesc.sizeFlags(A2) rtn     RTS((; Assignment-kompatible Typen. Types, die hier nicht aufgefÅhrt(;   sind, werden direkt ohne weitere PrÅfung zugewiesen!(; Aufbau: Source-Kennung, Dest-Kennung, Check-Code(; Check-Codes:(;   Bit 0: Int<->Card, 1: expand, 2: short, 3: signed, 4: real,(;       5: Proc-Short, 6: Proc-Expand,(;       7: Subrange-Test f. dest durchfÅhren!( AsTab   ; selbe Grîûe, aber Vorzeichenwechsel(DC.B     4, 22, 1001%(DC.B     4,  1, 1001%(DC.B     1, 22, 1001%(DC.B    22,  1, 0001%(DC.B    33, 34, 1001%(DC.B    34, 33, 0001%((; expand(DC.B     3,  1, 0010%(DC.B    33,  1, 0010%(DC.B    34,  1, 0010%(DC.B    35,  1, 0010%((DC.B     3,  4, 0010%(DC.B    33,  4, 0010%(DC.B    34,  4, 0010%(DC.B    35,  4, 0010%((DC.B     3, 22, 0010%(DC.B    33, 22, 1011%(DC.B    34, 22, 0010%(DC.B    35, 22, 0010%((DC.B     3, 30, 0010%(DC.B    33, 30, 0010%(DC.B    34, 30, 0010%(DC.B    35, 30, 0010%((DC.B    33, 23, 0010%   ; 23: ADDRESS(DC.B    34, 23, 0010%(DC.B    35, 23, 0010%((DC.B     3, 33, 0010%(DC.B     3, 34, 0010%(DC.B     3, 35, 0010%((DC.B     6, 44, 01000000%   ; Procedure -> Localproc-Type(DC.B    19, 44, 01000000%   ; Proc-Type -> Localproc-Type(((; short(DC.B     1, 33, 1100%   ; LI -> I(DC.B    22, 33, 0101%   ; LC -> I(DC.B     4, 33, 0100%   ; ZZ -> I(DC.B    30, 33, 0100%   ; LB -> I(DC.B     1, 34, 0100%   ; LI -> C(DC.B    22, 34, 0100%   ; LC -> C(DC.B     4, 34, 0100%   ; ZZ -> C(DC.B    30, 34, 0100%   ; LB -> C(DC.B     1, 35, 0100%   ; LI -> B(DC.B    22, 35, 0100%   ; LC -> B(DC.B     4, 35, 0100%   ; ZZ -> B(DC.B    30, 35, 0100%   ; LB -> B(DC.B     1,  3, 0100%   ; LI -> CHAR(DC.B    22,  3, 0100%   ; LC -> CHAR(DC.B    30,  3, 0100%   ; LB -> CHAR(DC.B     4,  3, 0100%   ; ZZ -> CHAR(DC.B    33,  3, 10000100%   ; I  -> CHAR(DC.B    34,  3, 10000100%   ; C  -> CHAR(DC.B    35,  3, 10000100%   ; SB -> CHAR(DC.B     4, 38, 00000100%   ; ZZ -> BYTE(DC.B    33, 38, 00001100%   ; I  -> BYTE(DC.B    34, 38, 00000100%   ; C  -> BYTE(DC.B    35, 38, 00000100%   ; SB -> BYTE(DC.B    44, 19, 00100000%   ; Localproc-Type -> Proc-Type((;reals(DC.B    40,  2, 10010%      ; expand(DC.B     2, 40, 10100%      ; shorten((DC.B     0(SYNC&ende$END;"END getConversionDesc;  PROCEDURE alwaysFitting (type: PtrItem): ConvDesc;"(*#* liefert 'range' so, daû 'valueFitting' immer TRUE liefert.#*)"VAR range: ConvDesc;"BEGIN$range.boundsCheck:= FALSE;$range.sizeFlags:= convSet {};$range.destType:= type;$range.sourceSize:= 0;$range.destSize:= 0;$RETURN range"END alwaysFitting;   PROCEDURE GetRparen;"BEGIN$IF CurrentSymbol.itemNo # rparen THEN&SyntaxError (rParXp)$END;$GetSymbol"END GetRparen;  PROCEDURE ChkComma;"BEGIN$IF CurrentSymbol.itemNo # comma THEN&SyntaxError (rComXp)$END;"END ChkComma;  PROCEDURE GetComma;"BEGIN$GetSymbol;$ChkComma;"END GetComma;  PROCEDURE GetLparen;"BEGIN$GetSymbol;$IF CurrentSymbol.itemNo # lparen THEN&SyntaxError (rLPaXp)$END;"END GetLparen;  PROCEDURE GetRbrack;"BEGIN$IF CurrentSymbol.itemNo # rbrack THEN&SyntaxError (rBrkXp)$END;$GetSymbol"END GetRbrack;  PROCEDURE ChkRbrace;"BEGIN$IF CurrentSymbol.itemNo # rbrace THEN&SyntaxError (rBrcXp)$END;"END ChkRbrace;  PROCEDURE isNumber (item: PtrItem; VAR size: NumberSize;CVAR type: NumberType): BOOLEAN;"BEGIN$item:= HostType (item);$IF (item = SCardPtr) THEN&size:= ord2;&type:= cardType$ELSIF (item = SIntPtr) THEN&size:= ord2;&type:= intType$ELSIF (item = BothTyp) OR (item = ZZTyp) THEN&size:= ord4;&type:= bothType$ELSIF (item = SBothTyp) THEN&size:= ord2;&type:= bothType$ELSIF (item = CardPtr) THEN&size:= ord4;&type:= cardType$ELSIF (item = IntPtr) THEN&size:= ord4;&type:= intType$ELSIF (item = SRealPtr) THEN&size:= real4;&type:= realType$ELSIF (item = RealPtr) THEN&size:= real8;&type:= realType$ELSE&size:= unspecSize;&type:= unspecType;&RETURN FALSE$END;$RETURN TRUE"END isNumber;  PROCEDURE isWholeNumber (t: PtrItem): BOOLEAN;"BEGIN$RETURN ItemNo (HostType (t)) IN ItemSet {1, 30, 33, 34, 35, 4, 22}"END isWholeNumber;  PROCEDURE isOrdinal (t: PtrItem): BOOLEAN;"(* TRUE, wenn 'whole number' oder CHAR, Enum, BOOLEAN *)"BEGIN$RETURN (ItemNo (HostType (t)) IN ItemSet {1, 30, 33, 34, 35, 4, 22, 3, 9, 24})$OR CharType (HostType (t))"END isOrdinal;  PROCEDURE isReal (type: PtrItem): BOOLEAN;"VAR n: CARDINAL;"BEGIN$n:= ItemNo (type);$RETURN (n = 2 (* REAL *)) OR (n = 40 (* LONGREAL *))"END isReal;  PROCEDURE isPointer (type: PtrItem): BOOLEAN;"(* alle fÅr Adreû-Register in Frage kommenden Types#* - VORSICHT: nicht anwenden auf Proc-Type m. StaticLink sowie OpenArray *)"VAR n: CARDINAL;"BEGIN$n:= ItemNo (type);$RETURN (n = 20 (* POINTER *))(OR (n = 23 (* ADDRESS *))(OR (n = 19 (* PROCEDURE *))(OR (n =  8 (* Opaque (eigen) *))(OR (n = 25 (* Opaque (extern) *))"END isPointer;  PROCEDURE isChar (t: PtrItem): BOOLEAN;"(* liefert TRUE, wenn 't' ein CHAR-Type (Var oder Const) ist *)"BEGIN$RETURN CharType (t)"END isChar;  PROCEDURE isSS (VAR expr: ExprDesc): BOOLEAN;"(* liefert TRUE, wenn 't' ein String-Literal ist *)"BEGIN$RETURN (expr.item = SSTyp)"END isSS;  PROCEDURE isStringVar (t: PtrItem): BOOLEAN;"(* liefert TRUE, wenn 't' = ARRAY [0..x] OF CHAR ist *)"BEGIN$RETURN (ItemNo (t) = 12))& (ItemNo (ElementType (t)) = 3))(* >> nicht mehr nîtig:  & (LowBound (IndexType (t)) = 0L) *)"END isStringVar;  PROCEDURE isProc (t: PtrItem): BOOLEAN;"BEGIN$RETURN (ItemNo (t) = 6) OR (ItemNo (t) = 44) OR (ItemNo (t) = 19)"END isProc;  PROCEDURE MaxReal (longReal: BOOLEAN): RR;"BEGIN$(* Die Routinen liefern die Werte im benîtigten Ziel-Format *)$IF fpu () = softReal THEN&IF longReal THEN RETURN RR (LargeLONGREAL (MM2Real))2ELSE RETURN RR (LargeREAL (MM2Real)) END$ELSE&IF longReal THEN RETURN RR (LargeLONGREAL (IEEEReal))2ELSE RETURN RR (LargeREAL (IEEEReal)) END$END;$RealConstIsUsed;"END MaxReal;  PROCEDURE MinReal (longReal: BOOLEAN): RR;"BEGIN$(* Die Routinen liefern die Werte im benîtigten Ziel-Format *)$IF fpu () = softReal THEN&IF longReal THEN RETURN RR (SmallLONGREAL (MM2Real))2ELSE RETURN RR (SmallREAL (MM2Real)) END$ELSE&IF longReal THEN RETURN RR (SmallLONGREAL (IEEEReal))2ELSE RETURN RR (SmallREAL (IEEEReal)) END$END;$RealConstIsUsed"END MinReal;  PROCEDURE getBounds (item: PtrItem; VAR lowBound, highBound: ZZ);"(*#* es kînnen alle Scalare Åbergeben werden, also auch BYTE, WORD, ADDRESS,#* LONGWORD, usw.#* Nur Reals gehen nicht!#*)"VAR n: CARDINAL; signed: BOOLEAN;"BEGIN$lowBound:= toZZ (0L, FALSE);$n:= ItemNo (item);$IF n = 11 THEN    (* Subrange *)&signed:= signedType (item);&lowBound:= toZZ (LowBound (item), signed);&highBound:= toZZ (HighBound (item), signed)$ELSIF n = 9 THEN  (* Enum *)&highBound:= toZZ (NoOfElems (item) - 1L, FALSE);$ELSIF n = 3 THEN  (* CHAR *)&highBound:= toZZ (255L, FALSE)$ELSIF (n = 39) THEN  (* signed BYTE *)&lowBound:= toZZ (-128L, TRUE);&highBound:= toZZ (127L, FALSE)$ELSIF (n = 38) THEN  (* BYTE *)&lowBound:= toZZ (-128L, TRUE);&highBound:= toZZ (255L, FALSE)$ELSIF (n = 41) THEN  (* BITNUM *)&highBound:= toZZ (31L, FALSE)$ELSIF n = 24 THEN (* BOOLEAN *)&highBound:= toZZ (1L, FALSE)$ELSIF n = 34 THEN (* CARDINAL *)&highBound:= toZZ (LONG (MaxCard), FALSE)$ELSIF (n = 21) THEN (* WORD *)&lowBound:= toZZ (LONG (MinInt), TRUE);&highBound:= toZZ (LONG (MaxCard), FALSE)$ELSIF n = 22 THEN (* LONGCARD *)&highBound:= toZZ (MaxLCard, FALSE)$ELSIF n = 33 THEN (* INTEGER *)&lowBound:= toZZ (LONG (MinInt), TRUE);&highBound:= toZZ (LONG (MaxInt), TRUE)$ELSIF n = 35 THEN (* SBothTyp *)&highBound:= toZZ (LONG (MaxInt), TRUE)$ELSIF n = 1  THEN (* LONGINT *)&lowBound:= toZZ (MinLInt, TRUE);&highBound:= toZZ (MaxLInt, FALSE)$ELSIF n = 30 THEN (* LongBoth *)&highBound:= toZZ (MaxLInt, FALSE)$ELSIF n IN ItemSet {8,20,23,25,26,4} THEN&lowBound:= toZZ (MinLInt, TRUE);    (* Opq, Pointer, Longword, ZZ *)&highBound:= toZZ (MaxLCard, FALSE)$ELSE&SyntaxError (rSclXp) (* dieser type ist nicht scalar *)$END;"END getBounds;  PROCEDURE getElems (lowBound, highBound: ZZ; VAR elems: LONGCARD);"BEGIN$elems:= diffZZ (highBound, lowBound) + 1L"END getElems;   (*$? CompileWithOldCompiler: PROCEDURE LTOS (lr: LongREAL): ShortREAL;"CONST fpstat  =  $fffa40;       (* Response word of MC68881 read *)(fpstatlo=  $fffa41;(fpctrl  =  $fffa42;       (* Control  word of MC68881 write *)(fpcmd   =  $fffa4a;       (* Command  word of MC68881 write *)(fpcond  =  $fffa4e;       (* Condition word of MC68881 write *)(fpop    =  $fffa50;       (* Operand  long of MC68881 read/write *)"VAR res: ShortREAL;"BEGIN$IF fpu () # softReal THEN&ASSEMBLER(LEA     lr(A6),A0 externl MOVE.W  #$5400,fpcmd         ; FMOVE.D (A0),FP0 !DoDl1  TST.B   fpstatlo(BEQ     DoDl1(MOVE.L  (A0)+,fpop(MOVE.L  (A0),fpop(MOVE.W  #$6400,fpcmd         ; FMOVE.S FP0,D1 !DoDl3  MOVE.B  fpstatlo,D0(BEQ     DoDl3(CMPI.B  #4,D0(BNE     DoDErr !GoBack MOVE.L  fpop,D0(CMPI.B  #2,fpstatlo(BEQ     NoErr !DoDErr CLR.L   D0(JSR     FPUError NoErr   MOVE.L  D0,res(A6)&END$ELSE&ASSEMBLER(LEA     lr(A6),A0(MOVE.L (A0)+,D1(MOVE.L (A0),D0(TST.W D1        ; test exponent(BEQ.S null      ; branch if zero(SWAP   D1       ; get exponent into low word(MOVE.W D1,D2    ; prepare exponent calculation(ASR   #3,D2(ADD   #$40,D2   ; add bias(BMI   null      ; still neg.: underflow(CMP   #$80,D2   ; compare with maximum ffp exponent(BCC   overfl    ; branch if exponent too high(BTST #0,D1      ; test sign bit(BNE isneg(ADDI.B #$80,D2"isneg SWAP   D0       ; get mantissa bit 16..24(MOVE   D0,D1    ; now complete mantissa(TST.B D1        ; must we round up ?(BPL   noround   ; skip rounding up(ADD.L #$100,D1  ; round it up(BCC   noround   ; were there all ones ?(BSET   #31,D1   ; division by two(ADDQ.B #1,D2    ; correct exponent(BVS   overfl    ; exponent overflow noround MOVE.B D2,D1    ; place sign & exponent(MOVE.L  D1,D0(BRA     rok overfl  TRAP    #6(DC.W    -7-$4000     ;overflow null    MOVEQ   #0,D0   ; get a true zero rok     MOVE.L  D0,res(A6)&END;$END;$RETURN res"END LTOS; *)  PROCEDURE LRNEG (VAR lr: RR);"BEGIN$IF fpu () = softReal THEN&ASSEMBLER(MOVE.L lr(A6),A0(TST.W  (A0)(BEQ    ZERO(BCHG   #0,1(A0)'ZERO:&END$ELSE&ASSEMBLER(MOVE.L  lr(A6),A0(BCHG    #7,(A0)&END$END"END LRNEG;  PROCEDURE SRNEG (VAR sr: SR);"BEGIN$IF fpu () = softReal THEN&ASSEMBLER(MOVE.L  sr(A6),A0(TST.L   (A0)(BEQ     zero(EORI.B  #$80,3(A0)'zero&END$ELSE&ASSEMBLER(MOVE.L  sr(A6),A0(BCHG    #7,(A0)&END$END"END SRNEG;  PROCEDURE LRABS (VAR lr: RR);"BEGIN$IF fpu () = softReal THEN&ASSEMBLER(MOVE.L lr(A6),A0(TST.W  (A0)(BEQ    ZERO(BCLR   #0,1(A0)'ZERO:&END$ELSE&ASSEMBLER(MOVE.L  lr(A6),A0(BCLR    #7,(A0)&END$END"END LRABS;  PROCEDURE SRABS (VAR sr: SR);"BEGIN$IF fpu () = softReal THEN&ASSEMBLER(MOVE.L  sr(A6),A0(TST.L   (A0)(BEQ     zero(ORI.B   #$80,3(A0)'zero&END$ELSE&ASSEMBLER(MOVE.L  sr(A6),A0(BCLR    #7,(A0)&END$END"END SRABS;  PROCEDURE DestFormat (): AnyRealFormat;"BEGIN$RETURN VAL (AnyRealFormat, ORD (fpu () # softReal))"END DestFormat;  PROCEDURE verifyIdenticalFormats;"BEGIN$IF DestFormat () # UsedFormat THEN&(*!!!  hier fehlt eine Funktion, um ohne FPU LR nach SR im IEEE-Format'*     zu konvertieren.'*   Um die Sache nicht noch komplizierter machen, ist z.Zt. auch das'*   SHORTen von MM2Real-Consts unter einer FPU nicht mîglich. Dem'*   wÑre abzuhelfen, indem einfach die entspr. Routine aus dem Runtime'*   hier verwendet wÅrde. *)&BadId:= 'LONG/SHORT(IEEE-const): need FPU';&SyntaxError (rTmpRs);$END;"END verifyIdenticalFormats;  PROCEDURE srToSys (r: SR): REAL;"BEGIN$verifyIdenticalFormats;$(* wenn keine Konvertierung nîtig, ist alles OK&RETURN Conv (AnyReal {LONGREAL (r), DestFormat ()}, UsedFormat);$*)$RETURN REAL (r)"END srToSys;  PROCEDURE srToDest (r: REAL): SR;"BEGIN$verifyIdenticalFormats;$(* wenn keine Konvertierung nîtig, ist alles OK&RETURN RR (Conv (AnyReal {r, UsedFormat}, DestFormat ()));$*)$RETURN SR (r)"END srToDest;  PROCEDURE lrToSys (r: RR): LONGREAL;"VAR ar: AnyReal;"BEGIN$ar.value:= LONGREAL (r);$ar.format:= DestFormat ();$RETURN Conv (ar, UsedFormat);"END lrToSys;  PROCEDURE lrToDest (r: LONGREAL): RR;"VAR ar: AnyReal;"BEGIN$ar.value:= r;$ar.format:= UsedFormat;$RETURN RR (Conv (ar, DestFormat ()));"END lrToDest;  PROCEDURE shortenReal (VAR expr: ExprDesc; errNo: INTEGER);"BEGIN$(*$? Safety: assert ((expr.item = RealPtr) & (expr.kind = constant));*)$expr.item:= SRealPtr;$IF ABS (lrToSys (expr.exprConst.rr)) > lrToSys (MaxReal (FALSE)) THEN&SyntaxError (errNo)$END;$(*$? CompileWithOldCompiler:&expr.exprConst.sr:= LTOS (expr.exprConst.rr);$*)$(*$? CompileWithNewCompiler:&verifyIdenticalFormats;&expr.exprConst.sr:= SR (SHORT (LONGREAL (expr.exprConst.rr)));$*)$expr.exprConst.zz.over:= FALSE"END shortenReal;  PROCEDURE expandReal (VAR expr: ExprDesc);"BEGIN$(*$? Safety: assert ((expr.item = SRealPtr) & (expr.kind = constant));*)$expr.item:= RealPtr;$verifyIdenticalFormats;$expr.exprConst.rr:= RR (LONG (REAL (expr.exprConst.sr)));"END expandReal;  PROCEDURE adaptZZ (VAR this: ExprDesc; to: PtrItem; boundCheck: BOOLEAN);"(* Paût auch Real-Konstanten an! *)"VAR lo, hi: ZZ;"BEGIN$WITH this DO&IF kind = constant THEN(IF (item = ZZTyp) & (isWholeNumber (to) OR (ItemNo (to) = 38)) THEN*item:= to;*IF boundCheck THEN,getBounds (to, lo, hi);,IF NOT inZZ (exprConst.zz, lo, hi) THEN.SyntaxError (rConOp),END*END(ELSIF (item = RealPtr) & (to = SRealPtr) THEN*shortenReal (this, rConOp);(END&END$END"END adaptZZ;  PROCEDURE cutZZ (VAR x: ZZ; size: CARDINAL);"(*$D-*)"(* lîscht unbenutzte Upper-Bytes in ZZ-Feld *)"BEGIN$WITH x DO&over:= FALSE;&IF size <= 2 THEN(c2:= 0;(IF size = 1 THEN*b1:= BYTE (0)(END&END$END"(*$D-*)"END cutZZ;  PROCEDURE reduceZZ (VAR expr: ExprDesc);"(*#* Wandelt Type, so daû keinesfalls mehr ZZ-Type eingestellt ist#*)"VAR int: BOOLEAN; lo, hi: ZZ;"BEGIN$IF (expr.item = ZZTyp) THEN&(*$? Safety: assert (expr.kind = constant);*)&int:= int16ZZ (expr.exprConst.zz);&IF card16ZZ (expr.exprConst.zz) THEN(IF int THEN*expr.item:= SBothTyp(ELSE*expr.item:= SCardPtr(END&ELSIF int THEN(expr.item:= SIntPtr&ELSE(getBounds (BothTyp, lo, hi);(IF inZZ (expr.exprConst.zz, lo, hi) THEN*expr.item:= BothTyp(ELSIF posZZ (expr.exprConst.zz) THEN*expr.item:= CardPtr(ELSE*expr.item:= IntPtr(END&END$END"END reduceZZ;  PROCEDURE makeZZ (t: PtrItem): PtrItem;"BEGIN$IF ItemNo (t) IN ItemSet {1, 22, 30, 33, 34, 35} THEN&RETURN ZZTyp$ELSE&RETURN t$END"END makeZZ;  PROCEDURE getNumTypeForRange (lo, hi: ZZ; VAR t: PtrItem);"(*#* Liefert CARDINAL/INTEGER/SBothTyp/LONGCARD/LONGINT/BothTyp,#* je nachdem, was am gÅnstigsten f. [lo..hi] paût.#* Meldet SyntaxError, wenn Werte zu groû#*)"BEGIN$IF card16ZZ (lo) & card16ZZ (hi) THEN&IF int16ZZ (lo) & int16ZZ (hi) THEN(t:= SBothTyp&ELSE(t:= SCardPtr&END$ELSIF int16ZZ (lo) & int16ZZ (hi) THEN&t:= SIntPtr$ELSIF posZZ (lo) THEN&IF NOT hi.over THEN(t:= BothTyp&ELSE(t:= CardPtr&END$ELSE&IF cmpZZ (hi, toZZ (MaxLInt, FALSE)) = gt THEN(SyntaxError (rBouRg)&END;&t:= IntPtr$END;"END getNumTypeForRange;  PROCEDURE adaptSSToChar (VAR expr: ExprDesc);"BEGIN$IF (expr.item = SSTyp) THEN&IF Size (expr) <= 1L THEN expr.item:= CharPtr END$END"END adaptSSToChar;  FORWARD extractConst (VAR fact: ExprDesc; ofs, size: LONGCARD);  PROCEDURE adaptStringToSS (VAR expr: ExprDesc);"(*#* Diese Funktion wandelt Konstanten vom Typ ARRAY [..] OF CHAR nach SS.#* Das kommt v.A. bei Value Constructors vor. "LENGTH" macht z.B. Gebrauch#* hiervon. Allerdings darf dies nicht ohne Weiteres bei Zuweisungen#* verwendet werden, da ja nicht unbedingt ein CHAR-Array als Null-termin.#* String angesehen werden darf, man kînnte ja sich gerade mit Value-Constr.#* ein CHAR-Array mit 0-Zeichen mittendrin basteln wollen. Dies geht nur#* mit einer zusÑtzlichen Direktive, die die Annahme erlaubt, daû ein#* CHAR-Array ein String sei.#* ~~~ Allerdings kînnte man hierfÅr auch statt der Direktive den SS-Typ#* bei Value-Constr. beibehalten, dann geht's automatisch.#*)"VAR ptr: POINTER TO ARRAY [0..32767] OF CHAR;&l2, len: CARDINAL;"BEGIN$WITH expr DO&IF (kind = constant) OR (kind = constRef) THEN(IF isStringVar (item) THEN*(* nun die LÑnge des Strings bestimmen und String verschieben *)*l2:= SHORT (Size (expr));*IF kind = constant THEN,ptr:= ADR (exprConst.b) + 1 - LONG (l2)*ELSE,(*$? Safety: assert (constHead # NIL); *),ptr:= constAddr + constOfs;*END;*len:= LENGTH (ptr^);*IF len > l2 THEN,len:= l2;*ELSE,l2:= len*END;*IF len = 0 THEN len:= 1 END;*extractConst (expr, 0, len);*item:= SSTyp;*exprSize:= l2(END&END$END"END adaptStringToSS;  PROCEDURE SetSSLength (VAR expr: ExprDesc);"BEGIN$IF (ItemNo (expr.item) = 27) THEN&(*$? Safety: assert (expr.item = SSTyp);*)&SetTypeLength (expr.item, Size (expr))$END"END SetSSLength;  PROCEDURE ResetSSLength (VAR expr: ExprDesc);"BEGIN$IF (expr.item = SSTyp) THEN&SetTypeLength (expr.item, 0)$END"END ResetSSLength;   PROCEDURE compatTT (left, right: PtrItem): BOOLEAN;"VAR resType: PtrItem;"BEGIN$RETURN ExprComp (resType, left, right)"END compatTT;  PROCEDURE checkCompat (VAR left, right: ExprDesc; VAR resType: PtrItem;8errNo: INTEGER);"(*#* ZZ-Types werden angepaût, wenn Subrange, wird daraus Basetype gemacht.#*)"VAR no: CARDINAL;"BEGIN$adaptSSToChar (left);$adaptSSToChar (right);$adaptZZ (left, HostType (right.item), TRUE);$adaptZZ (right, HostType (left.item), TRUE);$SetSSLength (left);$SetSSLength (right);$IF NOT ExprComp (resType, left.item, right.item) THEN SyntaxError (errNo) END;$ResetSSLength (left);$ResetSSLength (right);$no:= ItemNo (resType);$IF (no # 6) & (no # 19) & (no # 44) THEN&right.item:= resType;&left.item:= resType;$END"END checkCompat;  PROCEDURE varCompat (source, dest: PtrItem): BOOLEAN;"BEGIN$RETURN VarComp (dest, source)"END varCompat;  FORWARD fitValue (VAR source: ExprDesc; conv: ConvDesc);  PROCEDURE checkVarCompat (VAR source: ExprDesc; dest: PtrItem; errNo: INTEGER);"VAR range: ConvDesc;"BEGIN$IF NOT varCompat (source.item, dest) THEN SyntaxError (errNo) END;$IF ItemNo (source.item) = 44 THEN&(* 8 Byte-Proc-Parm wird an VAR-Parm Åbergeben.'*  -> Da es ein Parm ist, ist die Var auf jeden Fall schon init.,'*     so daû nun einfach ein NIL-Check auf das upper Long gemacht wird: *)&getConversionDesc (source.item, dest, range);&fitValue (source, range);$END"END checkVarCompat;  PROCEDURE asnCompat (VAR source: ExprDesc; dest: PtrItem;5VAR range: ConvDesc): BOOLEAN;"(*#* FÅr range-Checks werden in 'range' die notwendigen Informationen#* geliefert#*)"VAR (*$Reg*)n: INTEGER;"BEGIN$SetSSLength (source);$n:= AsnComp (dest, source.item);$IF n # 0 THEN&adaptSSToChar (source);&adaptZZ (source, dest, TRUE);&n:= AsnComp (dest, source.item);&IF n > 0 THEN SyntaxError (n) END$END;$ResetSSLength (source);$IF n = 0 THEN getConversionDesc (source.item, dest, range) END;$RETURN n = 0"END asnCompat;  PROCEDURE checkAsnCompat (VAR source: ExprDesc; dest: PtrItem;:VAR range: ConvDesc; errNo: INTEGER);"BEGIN$IF NOT asnCompat (source, dest, range) THEN&SyntaxError (errNo)$END;"END checkAsnCompat;  PROCEDURE checkValCompat (VAR source: ExprDesc; dest: PtrItem;:VAR range: ConvDesc; errNo: INTEGER);"(* Value an Parameter - Joker auch zulassen *)"BEGIN$IF NOT asnCompat (source, dest, range) THEN&IF isJoker (dest) THEN(IF source.item = ZZTyp THEN*(*$? Safety: assert (source.kind = constant);*)*IF (LONG (sizeZZ (source.exprConst.zz)) > TypeLength (dest)) THEN,SyntaxError (rConRg) (* const zu groû f. zuweisung *)*END;*range:= alwaysFitting (dest);*source.item:= dest(ELSE*IF Size (source) > TypeLength (dest) THEN,SyntaxError (rParTy) (* nicht zuweisungskompat *)*END;*getConversionDesc (source.item,,sizedItem (SHORT (TypeLength (dest)), signedType (source.item)), range)(END;&ELSE(SyntaxError (errNo)&END$END"END checkValCompat;   PROCEDURE swapOp (VAR op: Operator);"(* wird aufgerufen, wenn rechter/linker Op vertauscht werden *)"(* nicht geeignet, um den Vergleich zu invertieren (NOT)! *)"BEGIN$CASE op OF$| le: op:= ge$| ge: op:= le$| gt: op:= lt$| lt: op:= gt$| eq, ne: (* ok *)$END"END swapOp;  PROCEDURE prepareFPUop (VAR source, dest: ExprDesc; VAR op: Operator;8VAR isrel: BOOLEAN);"BEGIN$isrel:= op IN OpSet {eq, ne, le, ge, lt, gt};$(*%* wenn source schon im Reg steht, dann ggf. operanden tauschen%*)$IF (source.kind = register)$& (op IN OpSet {mul, add, eq, ne, le, ge, lt, gt}) THEN&swapExpr (source, dest);&IF isrel THEN swapOp (op) END$END"END prepareFPUop;   PROCEDURE checkStack (size: LONGCARD);"VAR r: RegType; a7: ExprDesc;"BEGIN$IF stackCheckActive () & (size > StackReserve DIV 4L) THEN&INC (size, StackReserve);&r:= allocAddrRegIfAllowed (dataRegs + addrRegs);&IF (r >= A0) & (size <= 32767) THEN(genLEArel (SHORT (size), A3, r)&ELSE(genMOVErr (A3, r, 4);(incReg (r, toZZ (size, FALSE), 4);&END;&initRegExpr (a7, 4, A7);&genar (CMP, a7, r);&gen (Bcc + mapCC (cc, FALSE, TRUE) + 4);&genTrap (StackOverflowTrap);&deallocReg (r)$END"END checkStack;  PROCEDURE checkOverflow (type: PtrItem);"BEGIN$IF overflowCheckActive () THEN&IF signedType (type) THEN(gen (TRAPV);&ELSE (* 68020: einfach TRAPCS *)(gen (Bcc + mapCC (cc, FALSE, FALSE) + 4);(genTrap (OverflowTrap);&END$END"END checkOverflow;  PROCEDURE checkMulOverflow (VAR expr: ExprDesc);"(* erzeugt bei unsigned:#*    SWAP Dn#*    TST.W Dn#*    BEQ  ok#*    TRAP #6#*    DC   overflow#* ok SWAP Dn#*#* bei signed:#*    MOVE.W Dn,An#*    CMPA.L Dn,An#*    BEQ    ok#*    TRAP #6#*    DC   overflow#* ok#*)"VAR help: ExprDesc; t: PtrItem;"BEGIN$IF overflowCheckActive () THEN&IF signedType (expr.item) THEN(copyRegExt (expr, help, dataRegs + addrRegs, 4);(t:= expr.item; expr.item:= CardPtr; (* um CMP.L zu erzeugen *)(genar (CMP, expr, help.exprReg);(expr.item:= t;(deallocRegs (help);(gen (Bcc + mapCC (eq, FALSE, FALSE) + 4);(genTrap (OverflowTrap)&ELSE(genr (SWAP, expr.exprReg);(gena (TST, expr, 2);(gen (Bcc + mapCC (eq, FALSE, FALSE) + 4);(genTrap (OverflowTrap);(genr (SWAP, expr.exprReg);&END;$END"END checkMulOverflow;   (* PROCEDURE pwr2 (n: INTEGER): LONGINT;"VAR res: LONGINT;"BEGIN$ASSEMBLER(; prÅfe, ob Konst. eine 2-Potenz ist(MOVEQ   #1,D1(MOVE    n(A6),D0(BEQ     ende(BMI     neg(ASL     D0,D1&ende(MOVE.L  D1,res(A6)$END;$RETURN res"END pwr2; *)  PROCEDURE log2 (x: ZZ; VAR n: CARDINAL): BOOLEAN;"VAR res: CARDINAL;"BEGIN$ASSEMBLER(; prÅfe, ob Konst. eine 2-Potenz ist(MOVE.L  x.v(A6),D1(TST.W   x.over(A6)(BEQ     nov(TST.L   D1(BNE     false(MOVEQ   #32,D0  ; dieser Wert ist gar nicht mîglich (max. 2^32-1) :-)(BRA     ende&nov(TST.L   D1(BEQ     false(BPL     p(NEG.L   D1&p MOVEQ   #-1,D0&l ADDQ    #1,D0(LSR.L   #1,D1(BCC     l(TST.L   D1(BEQ     ende&false(MOVEQ   #33,D0&ende(MOVE    D0,res(A6)$END;$n:= res;$RETURN n <= 31"END log2;    (*$D-*)  MODULE WithDisplays; "IMPORT$Safety, BadId, SyntaxError, rTmpRs,$ExprKind, deallocRegs, genPushReg, pushReg, genPopReg, assert, D0, A7, F0,$loadAddressTo, exprStack, ptrVar, PtrItem, ExprDesc, exprSp, ExprSP,$RegType, A7Offset, allocRegVar, PopExpr, PushExpr, RegSet, freeRegs,$deallocReg, pushNonTemp, popNonTemp, freeVarRegs, getThisReg,$bong, deallocRegVar, varRegs; "EXPORT$reloadDisplays, spillDisplays, closeDisplay, openDisplay,$procDepth, getDisplay, loadDisplay, freeDisplay; "CONST WithDisplays = 20; "TYPE DisplayDesc = RECORD expr: ExprSP; oldReg: RegType END; "VAR displayStack: ARRAY [1..WithDisplays] OF DisplayDesc;&spillSP, displaySP: [0..WithDisplays];'(*(* spillSP zeigt auf Grenze, oberhalb der alle Displays auf dem(* A7-Stack stehen, darunter stehen sie in einem Reg(*)  "PROCEDURE spill;$BEGIN&INC (spillSP);&IF spillSP > displaySP THEN(BadId:= 'Register-Variable (fÅr POINTER) freimachen!';(SyntaxError (rTmpRs)((*!!! das spilling kann nur Reg-Vars fÅr WITH freimachen -- wenn jedoch)*    alle addr-regs in expliziten reg-vars abgelegt sind, bekommen)*    wir kein Reg frei. -> spilling auf alle Exprs ausweiten. dann)*    dies auch anwenden, wenn eine lokale proc aufgerufen wird, die)*    auf welche von Ñuûeren reg-vars zugreift)*)&END;&WITH exprStack [displayStack [spillSP].expr].expr DO(IF kind = register THEN*(* wir haben einen WITH-Pointer im Reg gefunden -> auf A7 laden *)*(*$? Safety:,assert (exprReg IN varRegs);,assert (displayStack [spillSP].oldReg = F0);**)*displayStack [spillSP].oldReg:= exprReg;*deallocRegVar (exprReg);*pushNonTemp (exprReg, TRUE);*kind:= stack;*stackReg:= A7;*up:= TRUE;*restoreAfterUse:= 0;*stackedSize:= 4;*stackPtr:= A7Offset;(END;((*$? Safety: assert (kind = stack)*)&END$END spill; "PROCEDURE getDisplayReg (VAR r: RegType);$VAR saved: RegSet;$BEGIN&(*'* Wir brauchen ein Addr-Reg.'* Dazu wird jede gerade freie Reg verwendet, also auch eins, das'* fÅr eine Var reserviert ist, aber z.Zt. nicht benutzt wird.'*)&saved:= freeVarRegs;&freeVarRegs:= RegSet {D0..A7};&IF allocRegVar (ptrVar, r) THEN((*$? Safety: assert (displayStack [spillSP].expr = -1);*)((* Reg war vorher nicht belegt -> auf A7 retten *)(pushNonTemp (r, TRUE)&ELSE(REPEAT*spill;(UNTIL allocRegVar (ptrVar, r)&END;&freeVarRegs:= saved$END getDisplayReg; "PROCEDURE reloadDisplay (VAR d: DisplayDesc);$BEGIN&IF NOT getThisReg (d.oldReg) THEN(bong&END;&(*$? Safety: assert (d.oldReg # F0); *)&WITH exprStack [d.expr].expr DO((*$? Safety: assert ((kind = stack) & (stackPtr = A7Offset));*)(popNonTemp (d.oldReg);(kind:= register;(exprReg:= d.oldReg;(d.oldReg:= F0;&END$END reloadDisplay; "PROCEDURE spillDisplays (VAR marker: CARDINAL);$BEGIN&marker:= spillSP;&WHILE spillSP # displaySP DO spill END;$END spillDisplays; "PROCEDURE reloadDisplays (marker: CARDINAL);$BEGIN&WHILE (spillSP # marker) DO(reloadDisplay (displayStack [spillSP]);(DEC (spillSP)&END$END reloadDisplays; "PROCEDURE loadDisplay (VAR expr: ExprDesc);$VAR r: RegType; regs: RegSet;$BEGIN&getDisplayReg (r);&INCL (freeRegs, r);&regs:= RegSet {};&INCL (regs, r);&loadAddressTo (expr, regs);&EXCL (freeRegs, r);&(*$? Safety: assert (expr.kind = register);*)&PushExpr (expr);&INC (displaySP);&displayStack [displaySP].expr:= exprSp;&displayStack [displaySP].oldReg:= F0 (* um ggf. Fehler auszulîsen *)$END loadDisplay; "PROCEDURE freeDisplay;$VAR expr: ExprDesc;$BEGIN&(*$? Safety: assert (displayStack [displaySP].expr = exprSp);*)&DEC (displaySP);&IF spillSP > displaySP THEN DEC (spillSP) END;&PopExpr (expr);&(*$? Safety: assert (expr.kind = register);*)&deallocRegVar (expr.exprReg);&(*!!! Diese Annahme, daû 'expr' ein Reg ist, kann nicht mehr gemacht'*    werden, sobald auch bei voller Belegung aller Addr-Reg-Vars'*    WITH noch mîgl. ist: Dann kann es entweder sein, daû auch der'*    innerste With-Ptr auf dem Stack steht, so daû das deallocRegVar'*    nicht getan werden darf, oder eine RegVar wurde ins memory'*    gelegt, so daû dann dies wieder zurcÅkgeladen werden darf. Dann'*    dÅrfte dazu wahrscheinlich hier erstmal die Freigabe erfolgen.'*)&IF displayStack [spillSP].expr = -1 THEN((* -> kein gespillter WITH-Ptr mehr -> Reg. normal wiederherstellen *)(popNonTemp (expr.exprReg);&ELSE((* da haben wir ja noch einen, der auf dem Stack liegt)* -> runter mit ihm *)(reloadDisplay (displayStack [spillSP]);(DEC (spillSP);&END$END freeDisplay; "PROCEDURE procDepth (tiefe: CARDINAL): CARDINAL;$(*%* Bestimmt die A6-Tiefe, denn in WITH-Scopes ist Tiefe%* zu groû ist, weil WITH-Pointer nicht mehr als neues%* A6-Scope angelegt werden%*)$VAR n: CARDINAL;$BEGIN&n:= displaySP;&WHILE tiefe > 0 DO(IF displayStack [n].expr = -1 THEN*RETURN tiefe(END;(DEC (tiefe);(DEC (n)&END;&RETURN 0$END procDepth; "PROCEDURE getDisplay (tiefe: CARDINAL; VAR expr: ExprDesc);$BEGIN&expr:= exprStack [displayStack [displaySP - tiefe].expr].expr$END getDisplay; "PROCEDURE openDisplay;$BEGIN&INC (displaySP);&INC (spillSP);&(*$? Safety: assert (spillSP = displaySP);*)&displayStack [displaySP].expr:= -1;$END openDisplay; "PROCEDURE closeDisplay;$BEGIN&(*$? Safety: assert (displayStack [displaySP].expr = -1);*)&DEC (displaySP);&DEC (spillSP);&(*$? Safety: assert (spillSP = displaySP);*)$END closeDisplay; "BEGIN$spillSP:= 0;$displaySP:= 0;$openDisplay;"END WithDisplays;  (*$D-*)   MODULE RuntimeCalls;  (*!* in diesem Modul sind alle Funktionen zusammengefaût, die Runtime-!* Aufrufe vorbereiten und dazu Werte in bestimte Register laden.!*!* Regeln:!*!*   Werden mehrere ExprDesc in Regs geladen, muû beachtet werden, daû!* es zu keinem Deadlock kommt. Z.B. kann es dann passieren, wenn nachein-!* ander ein Adr-Reg nach A0 und ein Data-Reg nach D0 geladen werden sollen;!* ist dann z.B. das A0 von der 2. Expr durch (A0) oder Ñhnliches belegt,!* geht's schief.!*   Deshalb mÅssen mehrere Regs immer in 2 Schritten beladen werden:!* Zuerst werden alle Exprs lediglich in beliebige (anyReg, anyDataReg, usw)!* Regs geladen, erst danach jedes zu seinem Ziel-Reg - ggf. ist dazu!* dann 'loadRegs' zu benutzen.!*) "IMPORT coding, CallRuntimeProc, deallocRegs, loadReg, RegSet, RegType,)D0, D1, D2, A0, A1, A2, A3, A7, ExprDesc, ZZ, exclRegs, spillRegs,)Safety, allocReg, deallocReg, constToReg, swapExpr, ExprKind, anyReg,)anyCPUReg, tempRegs, assert, loadAddress, COPYW, COPYL, swapRegs,)swapOp, Operator, sizedItem, Size, LENW, LENL, CAPI, loadRegExt,)PtrItem, PS3B, PS3W, PS3L, LADD, LSUB, LMUL, LDIV, SIRG, CMP8,)dataRegs, incReg, freeRegs, SMEM, SXOR, SINCL, SEXCL, toZZ,)initPseudoRegExpr, F0, F2, F7, floatRegs, bong, fpu, FPUType,)FADD, FSUB, FDIV, FMUL, FNEG, LNEG, RSHT, RXPD, FNUL, FGET, FPUT,)FOPS, FOPD, FMVS, FMVD, rNImpY, SizeOfLongReal, Freg, Fea,)TypeLength, SizeOfShortReal, SyntaxError, isReal, OpSet,)BoolPtr, FCMP, FBEQ, FBNE, FBLE, FBGE, FBGT, FBLT, getFPUop,)FCPN, FCPS, FCPD, LREQ, LRNE, LRLE, LRGE, LRLT, LRGT, FABS,)changeStackToIndir, loadDestAddress, updateStack, loadExprAddress,)anyDataReg, loadAddressTo, pushReg, A7Offset, genar, CMP,)initStackExpr, genMOVErr, RealPtr, SRealPtr, CardPtr, IntPtr,)rOpTyp, MemModes, roundUp, posZZ, cmpZZ, negZZ, getBounds, RefType,)LC2S, LI2S, LC2D, LI2D, S2LC, S2LI, D2LC, D2LI, prepareFPUop,)SADD, SSUB, SMUL, SDIV, SRLE, SRGE, SRLT, SRGT, LABS, SABS, SNEG,)int8ZZ, FP7S, FP7D, FP3S, FP3D, FG7S, FG7D, FG3S, FG3D,)spillRegByMove, genPushReg, genPopReg, PushExpr, PopExpr,)makeInd0An, initRegExpr, SCardPtr, ItemNo, genMOVEar, changeToStack,)IEEERuntimeCall, isStringVar, updateStackOffsets, reloadPtr,)Test, (*$? Test: showExpr, showExprStack, showRegs, *))exprUsesRegs, FP7M, FG7M, loadRealReg, changeToStackTo, addrRegs; "EXPORT runtimeConstMul, runtimeVarMul, runtimeConstCopy, runtimeCap,)runtimeCopyOnStack, runtimeElemSet, runtimeSetOp, runtimeLength,)runtimeMoveRealRegToVar, runtimeRealOp, runtimeRealMono,)runtimePushRealReg, runtimeCopyOpenArray, runtimeRangeSet,)runtimeCmp8Byte, runtimeMoveRealRegs, runtimeLoadRealToReg,)runtimeShiftRotate;  "PROCEDURE callRuntime (n: CARDINAL);$BEGIN&IF coding () THEN CallRuntimeProc (n) END$END callRuntime; "PROCEDURE loadRegs (VAR x1: ExprDesc; r1: RegType;6VAR x2: ExprDesc; r2: RegType);$(*%* Diese Funktion ist aufzurufen, nachdem beide exprs in Regs%* geladen wurden (z.B. loadReg (expr, anyReg)).%* Hier wird dann dafÅr gesorgt, daû die richtigen Regs belegt werden.%*)$VAR b1, b2: BOOLEAN; regs: RegSet;$BEGIN&regs:= RegSet {};&(*$? Safety: assert ((x1.kind = register) & (x2.kind = register)); *)&b1:= (x1.exprReg = r2);&b2:= (x2.exprReg = r1);&IF b1 THEN(IF b2 THEN*(* wenn beide Ops schon in den Regs stehen, aber verkehrt herum,+* dann beide mit EXG-Instr. tauschen *)*swapRegs (x1, x2)(ELSE*(* x1 steht im falschen Reg *)*INCL (regs, r1);*loadReg (x1, regs)(END&ELSIF b2 THEN((* x2 steht im falschen Reg *)(INCL (regs, r2);(loadReg (x2, regs)&END;&IF x1.exprReg # r1 THEN(regs:= RegSet {};(INCL (regs, r1);(loadReg (x1, regs)&END;&IF x2.exprReg # r2 THEN(regs:= RegSet {};(INCL (regs, r2);(loadReg (x2, regs)&END;$END loadRegs;""PROCEDURE prepareUno (REF expr: ExprDesc; usedRegs: RegSet);$BEGIN&exclRegs (expr, usedRegs);&spillRegs (usedRegs)$END prepareUno;""PROCEDURE prepareDuo (REF exp1, exp2: ExprDesc; usedRegs: RegSet);$BEGIN&exclRegs (exp1, usedRegs);&exclRegs (exp2, usedRegs);&spillRegs (usedRegs)$END prepareDuo;""PROCEDURE runtimeShiftRotate (opcode: CARDINAL; VAR set, count: ExprDesc;@lo, hi: ZZ);$BEGIN&prepareDuo (set, count, RegSet {D0,D1,D2});&loadReg (set, anyCPUReg);&loadReg (count, anyCPUReg);&loadRegs (set, D0, count, D1);&constToReg (hi, 2, D2);&callRuntime (opcode)$END runtimeShiftRotate;$"PROCEDURE runtimeMoveRealRegs (opcode: CARDINAL; pop: BOOLEAN);$(* FMOVEM f. ST-FPU gen. *)$BEGIN&IEEERuntimeCall;&(*$? Safety: assert ((D0 IN freeRegs) & (A1 IN freeRegs) & (A2 IN freeRegs)); *)&(*>>> hier wird davon ausgegangen, daû die Register D0/A1/A2 frei sind!'* wenn Parm-öbergabe Åber temp. Regs geht, ist das nicht mehr der Fall.*)&constToReg (toZZ (LONG (opcode), FALSE), 2, D0);&IF pop THEN(callRuntime (FG7M)&ELSE(callRuntime (FP7M)&END$END runtimeMoveRealRegs;""PROCEDURE runtimeLoadRealToReg (VAR expr: ExprDesc; niceRegs: RegSet);$$VAR old: ExprDesc; long, ea: BOOLEAN; n: CARDINAL; t: PtrItem;(r: RegType; regs: RegSet; $PROCEDURE loadnr;&BEGIN(constToReg (toZZ (LONG (n + Freg (r)), FALSE), 2, D0);&END loadnr;$$BEGIN&(*$? Safety: assert (fpu () = externalFPU);*)&n:= FGET + Fea (expr, ea);&IEEERuntimeCall;&IF ea THEN(long:= Size (expr) > LONG (SizeOfShortReal);(IF long THEN*regs:= RegSet {A0,D0,A2};(ELSE*regs:= RegSet {D0,D1,A2};(END;&ELSE(regs:= RegSet {D0,A2};&END;&prepareUno (expr, regs);&r:= allocReg (niceRegs);&IF ea THEN(t:= expr.item;(IF long THEN*loadExprAddress (expr, old);*loadReg (expr, RegSet {A0});*loadnr;*callRuntime (FOPD);*updateStack (old)(ELSE*loadReg (expr, RegSet{D1});*loadnr;*callRuntime (FOPS)(END;(deallocReg (expr.exprReg);(expr.item:= t;&ELSE((*$? Safety: assert (expr.kind = register); *)((*$? Safety: assert (expr.exprReg # r); *)(deallocRegs (expr);(loadnr;(callRuntime (FNUL)&END;&expr.kind:= register;&expr.exprReg:= r;$END runtimeLoadRealToReg;""PROCEDURE runtimePushRealReg (VAR source: ExprDesc; sp: RegType);$(*%* Reg in 'expr' auf Stack retten,%* ohne irgend ein Register zu spillen (hîchstens Umladen in ein anderes).%*)$$VAR r: RegType;$$PROCEDURE save (reg: RegType; long: BOOLEAN; VAR regSaved: BOOLEAN);&VAR regs: RegSet;&BEGIN(regSaved:= FALSE;(IF NOT (reg IN freeRegs) THEN*regs:= RegSet{reg};*IF NOT spillRegByMove (regs) THEN,(* D2 ist belegt - wir retten es auf den anderen Stack und holen es-* danach zurÅck *),genPushReg (reg, long, r);,regSaved:= TRUE*ELSE,EXCL (freeRegs, reg);  (* wg. nÑchstem 'spillRegByMove' belegen *)*END(END;&END save;$$VAR a2s, d2s, ea: BOOLEAN; n: CARDINAL; v: ZZ; oldFree: RegSet;$BEGIN&(*$? Safety:(assert (fpu () = externalFPU);(assert ((sp=A3) OR (sp=A7));(assert (source.kind = register);&*)&IEEERuntimeCall;&n:= FPUT + Freg (source.exprReg) + $4400;&IF source.item = RealPtr THEN INC (n, $1000) END;&v:= toZZ (LONG (n), FALSE);&&oldFree:= freeRegs;&IF sp = A7 THEN r:= A3 ELSE r:= A7 END;&save (D2, FALSE, d2s);&save (A2, TRUE, a2s);&&constToReg (v, 2, D2);&callRuntime (FP7S + ORD (source.item = RealPtr) + 2*ORD(sp=A3));&updateStackOffsets (sp, sp=A3, Size (source));&&IF a2s THEN((* A2 zurÅckladen *)(genPopReg (A2, TRUE, r)&END;&IF d2s THEN((* D2 zurÅckladen *)(genPopReg (D2, FALSE, r)&END;&freeRegs:= oldFree$END runtimePushRealReg; "PROCEDURE runtimeMoveRealRegToVar (VAR source: ExprDesc; dest: ExprDesc);$VAR ea: BOOLEAN; regs: RegSet; t: PtrItem; n: CARDINAL;$BEGIN&(*$? Safety:(assert (fpu () = externalFPU);(assert ((dest.kind # register) & (source.kind = register));&*)&prepareUno (dest, RegSet {A0,D0,A2}); (* source ist immer float-Reg *)&t:= dest.item;&regs:= freeRegs;&n:= FPUT + Fea (dest, ea) + Freg (source.exprReg); (* danach Ñndert sich dest.imte! *)&loadDestAddress (dest, Size (dest));&loadReg (dest, RegSet {A0});&constToReg (toZZ (LONG (n), FALSE), 2, D0);&freeRegs:= regs;&IEEERuntimeCall;&IF TypeLength (t) = LONG (SizeOfShortReal) THEN(callRuntime (FMVS)&ELSE(callRuntime (FMVD)&END;$END runtimeMoveRealRegToVar;""PROCEDURE runtimeRealMono (VAR expr: ExprDesc; op: CARDINAL);$(*%* 'op':%*  2: -()%*  3: ABS()%*  LC2S..D2LI: FLOAT/TRUNC%*)$VAR n: CARDINAL;(r: RegType;(regs: RegSet;(destType, t: PtrItem;(dlong, slong, ea: BOOLEAN;(old, pseudoReg: ExprDesc;$$PROCEDURE loadnr;&BEGIN(constToReg (toZZ (LONG (n + Freg (r)), FALSE), 2, D0)&END loadnr;$$BEGIN&slong:= expr.item = RealPtr;&destType:= expr.item;&IF (fpu () = softReal) OR (op >= LC2S) (* Bei FLOAT/TRUNC immer *) THEN((IF fpu () = softReal THEN*IF slong & (op # 0) THEN (* -> bei sr:= lr kommt kein extra Reg-Load *),loadRealReg (expr, floatRegs);*END;(END;((regs:= RegSet {};(IF op = 0 THEN*(* SHORT () *)*(*$? Safety: assert (slong);*)*destType:= SRealPtr;*regs:= RegSet {A0,D0..D2,F2};*n:= RSHT(ELSIF op = 1 THEN*(* LONG () *)*(*$? Safety: assert (NOT slong);*)*destType:= RealPtr;*regs:= RegSet {A0,D0,D1,F2};*n:= RXPD(ELSIF op = 2 THEN*(* Negate *)*IF slong THEN n:= LNEG ELSE n:= SNEG END(ELSIF op = 3 THEN*(* ABS () *)*IF slong THEN n:= LABS ELSE n:= SABS END(ELSIF (op >= LC2S) & (op <= D2LI) THEN*(* LC2S, LI2S, LC2D, LI2D, S2LC, S2LI, D2LC, D2LI *)*regs:= RegSet {D0..D1,F2};*IF op = D2LC THEN INCL (regs, D2) END;*n:= op;*IF op >= S2LC THEN,IF (op - S2LC) MOD 2 = 0 THEN.destType:= CardPtr,ELSE.destType:= IntPtr,END*ELSE,IF op <= LI2S THEN.destType:= SRealPtr,ELSE.destType:= RealPtr,END*END(ELSE*bong ()(END;((dlong:= destType = RealPtr;((IF slong OR dlong THEN*INCL (regs, A0)(END;(IF NOT slong OR NOT dlong THEN*INCL (regs, D0)(END;(prepareUno (expr, regs);((IF (fpu () # softReal) & (expr.kind = register) THEN*(* wenn Wert in echtem FP-Reg steht, muû er zum Zugriff+* ins RAM (auf den Stack) geladen werden, weil die Routinen unten+* (z.B. loadReg, loadRegExt) kein Reg-Transfer von Fn nach Dn+* kînnen. *)*pushReg (expr, A7);(END;(((* Eingabewert nach D0/(A0) laden *)(IF slong THEN*IF expr.kind # register THEN,loadExprAddress (expr, old);,loadReg (expr, RegSet {A0});*ELSE,initPseudoRegExpr (pseudoReg, expr.item, expr.exprReg, FALSE);,loadExprAddress (pseudoReg, old); (* expr-Adr: A0 *),loadReg (pseudoReg, RegSet {A0});,deallocReg (A0),(* FPn bleibt alloziert *)*END;(ELSE*IF expr.item = SRealPtr THEN,loadReg (expr, RegSet {D0})*ELSE,loadRegExt (expr, RegSet {D0}, 4, TRUE)*END;(END;(((* RÅckgabewert vorbereiten *)(IF dlong THEN*IF slong THEN,(* A0 ist bereits besetzt *)*ELSE,(* Auf dem Stack Platz f. LONGREAL reserv.-* und A0 darauf zeigen lassen *),deallocRegs (expr);,initStackExpr (expr, RealPtr, A3);,expr.up:= FALSE;,expr.stackedSize:= SizeOfLongReal;,genMOVErr (A3, A0, 4);,incReg (A3, toZZ (LONG(SizeOfLongReal), TRUE), 4);*END(ELSE*IF slong THEN,(* D0 fÅr Erg. vorbereiten *),deallocRegs (expr); (* A0 freigeben *),expr.kind:= register;,expr.exprReg:= allocReg (RegSet {D0})*ELSE,(* Erg. kommt wieder nach D0 *)*END(END;((expr.item:= destType;((callRuntime (n);((IF slong THEN*updateStack (old)(END;(&ELSE&((*$? Safety: assert (fpu () = externalFPU); *)(IF op = 2 THEN*n:= FNEG;(ELSE*(*$? Safety: assert (op = 3); *)*n:= FABS;(END;(INC (n, Fea (expr, ea));(IF ea THEN*IF slong THEN,regs:= RegSet {A0,D0,A2};*ELSE,regs:= RegSet {D0,D1,A2};*END;*r:= allocReg (floatRegs);(ELSE*regs:= RegSet {D0,A2};*r:= expr.exprReg;(END;(prepareUno (expr, regs);(IEEERuntimeCall;(IF ea THEN*t:= expr.item;*IF slong THEN,loadExprAddress (expr, old);,loadReg (expr, RegSet {A0});,loadnr;,callRuntime (FOPD);,updateStack (old)*ELSE,loadReg (expr, RegSet{D1});,loadnr;,callRuntime (FOPS)*END;*deallocReg (expr.exprReg);*expr.item:= t;*expr.exprReg:= r;(ELSE*loadnr;*callRuntime (FNUL)(END&END;$END runtimeRealMono; "PROCEDURE runtimeRealOp (op: Operator; VAR source, dest: ExprDesc);$(*%* fÅr Compares, DIV & SUB gilt: 'source' ist der rechte Wert%* 'source' ist generell eine beliebige Adr, 'dest' ist ein Register%*)$VAR m, n: CARDINAL;(regs: RegSet;(isrel, long, ea: BOOLEAN;(old, pseudoReg: ExprDesc;$$PROCEDURE loadnm;&BEGIN(constToReg (toZZ (LONG (n), FALSE), 2, D0);(IF isrel THEN*constToReg (toZZ (LONG (m), FALSE), 2, D2)(END&END loadnm;$$BEGIN&(* 'dest' kommt in ein Register, 'source' kann alles sein.'* Overflow-Checks werden in den Routinen erkannt *)&&prepareFPUop (source, dest, op, isrel);&long:= dest.item = RealPtr;&&IF fpu () = softReal THEN&(IF long THEN*loadRealReg (dest, floatRegs);*prepareDuo (dest, source, RegSet {A0..A2,D0..D2});**CASE op OF,add: n:= LADD|,sub: n:= LSUB|,mul: n:= LMUL|,rdiv:n:= LDIV|,eq:  n:= LREQ|,ne:  n:= LRNE|,le:  n:= LRLE|,ge:  n:= LRGE|,lt:  n:= LRLT|,gt:  n:= LRGT|*ELSE,SyntaxError (rOpTyp)*END;**IF source.kind = register THEN,deallocReg (source.exprReg);,initPseudoRegExpr (source, source.item, source.exprReg, FALSE);*END;**loadExprAddress (source, old); (* source-Adr: A0 (rechter Wert) *)*loadReg (source, RegSet {A0});**initPseudoRegExpr (pseudoReg, dest.item, dest.exprReg, FALSE);*loadAddressTo (pseudoReg, RegSet {A1}); (* dest-Adr: A1 (linker Wert) *)*(ELSE*IF op IN OpSet {mul, rdiv} THEN,regs:= RegSet {A0,D0..D2};*ELSIF op IN OpSet {eq, ne} THEN,,(* direkten CMP.L gen. *),loadReg (dest, dataRegs);,genar (CMP, source, dest.exprReg);,deallocRegs (source);,WITH dest DO.deallocReg (exprReg);.item:= BoolPtr;.kind:= condFlags;.fpuFlags:= FALSE;.relOp:= op;.signed:= FALSE;.not:= FALSE,END;,RETURN *ELSE,regs:= RegSet {D0..D2}*END;*prepareDuo (source, dest, regs);*loadReg (source, anyCPUReg);*loadReg (dest, anyCPUReg);*loadRegs (source, D0, dest, D1);**CASE op OF,add: n:= SADD|,sub: n:= SSUB|,mul: n:= SMUL|,rdiv:n:= SDIV|,le:  n:= SRLE|,ge:  n:= SRGE|,lt:  n:= SRLT|,gt:  n:= SRGT|*ELSE,SyntaxError (rOpTyp)*END;*(END;((callRuntime (n);((IF long THEN*deallocRegs (pseudoReg);*updateStack (old)(END;(deallocRegs (source);((IF isrel THEN*WITH dest DO,deallocReg (exprReg);,item:= BoolPtr;,kind:= register;,exprReg:= allocReg (RegSet {D0});,not:= FALSE*END;(END;(&ELSE((*$? Safety: assert (fpu () = externalFPU);*)(((*)* Achtung: hier wird 'runtimeLoadRealToReg' aufgerufen, wobei)* bestimmte An/Dn-Regs benîtigt werden!)* Das heiût, daû diese Regs frei sein mÅssen, also nicht)* von 'source' belegt sein dÅrfen.)* Das wird hier sichergestellt, indem 'source' erst nochmal)* auf den expr-Stack geladen wird, damit ggf. ein Spilling)* mîglich ist.)*)(PushExpr (source);(loadRealReg (dest, floatRegs);(PopExpr (source);(reloadPtr (source);(((* Opcode nach D0 *)(getFPUop (source, dest.exprReg, op, isrel, n, m, ea);(regs:= RegSet {D0,A2};(IEEERuntimeCall;(IF ea THEN*IF long THEN,regs:= RegSet {A0,D0,A2}*ELSE,regs:= RegSet {D0,D1,A2}*END;(END;(IF isrel THEN*INCL (regs, D2)(END;(prepareDuo (source, dest, regs);(IF ea THEN*IF long THEN,loadExprAddress (source, old);,loadReg (source, RegSet {A0});,loadnm;,IF isrel THEN.callRuntime (FCPD),ELSE.callRuntime (FOPD),END;,updateStack (old)*ELSE,loadReg (source, RegSet {D1});,loadnm;,IF isrel THEN.callRuntime (FCPS),ELSE.callRuntime (FOPS),END*END;(ELSE*loadnm;*IF isrel THEN,callRuntime (FCPN)*ELSE,callRuntime (FNUL)*END(END;((deallocRegs (source);((IF isrel THEN*WITH dest DO,deallocReg (exprReg);,item:= BoolPtr;,kind:= condFlags;,fpuFlags:= FALSE;,relOp:= ne;,signed:= FALSE;,not:= FALSE*END;(END;(&END;$END runtimeRealOp; "PROCEDURE runtimeCopyOpenArray (VAR expr: ExprDesc; n: CARDINAL);$VAR usedRegs: RegSet;$BEGIN&usedRegs:= RegSet {A0,A1,A2,D1,D2};&exclRegs (expr, usedRegs);&spillRegs (usedRegs);&loadAddressTo (expr, RegSet {A0});&callRuntime (n);$END runtimeCopyOpenArray;""PROCEDURE runtimeCopyOnStack (VAR expr, addr, count: ExprDesc;@instrSize: CARDINAL; toA7: BOOLEAN);$VAR n: CARDINAL; usedRegs: RegSet;$BEGIN&CASE instrSize OF(1: n:= PS3B|(2: n:= PS3W|(4: n:= PS3L&END;&IF toA7 THEN(INC (n, 3)&ELSE(SyntaxError (rNImpY) (* A3-Routinen berÅcksichtigen A0 noch nicht *)&END;&usedRegs:= RegSet {A0,A1,A2,D1,D2};&(*'* Wenn Aufruf von "moveOpenArray", dann enthÑlt eins der temp. Regs'* den alten A7. Es kann nun vorkommen (bei mehrdim. Open Arrays by'* Value), daû 'count' in D0, wÑhrend das gerettete A7 in A2 liegt.'* Nun kÑme ein sofortiger spillRegs-Aufruf damit nicht klar, weil'* A2 nach D0 gemoved werden sollte, was aber nicht geht, da es'* noch von 'count' benutzt wird. Daher wird's hier nun ggf. erst'* umgeladen:'*)&IF exprUsesRegs (count, RegSet{D0}) THEN loadReg (count, RegSet {D1}) END;&IF exprUsesRegs (addr, RegSet{D0}) THEN makeInd0An (addr) END;&exclRegs (expr, usedRegs);&exclRegs (addr, usedRegs);&exclRegs (count, usedRegs);&spillRegs (usedRegs);&loadReg (count, anyDataReg);&loadAddress (expr);&loadAddress (addr);&loadRegs (expr, A0, addr, A1);&loadReg (count, RegSet {D1});&callRuntime (n);$END runtimeCopyOnStack; "PROCEDURE runtimeElemSet (VAR elem, set: ExprDesc;<op: Operator; lo: ZZ);$VAR size: LONGCARD; regs: RegSet; n: CARDINAL; old: ExprDesc; t: PtrItem;$BEGIN&(*$? Safety: assert (set.typeChecked); *)&(*$? Safety: assert (NOT set.regset);*)&regs:= RegSet {A0,D0,D1};&IF op = in THEN INCL (regs, D2) END;&prepareDuo (elem, set, regs);&loadRegExt (elem, dataRegs, 2, TRUE);&size:= Size (set); (* Size geht durch loadAddress verloren! *)&t:= set.item;&loadExprAddress (set, old);&loadReg (set, RegSet {A0});&loadReg (elem, RegSet {D0});&IF NOT set.zerobased THEN(negZZ (lo);(incReg (D0, lo, 2);&END;&IF op = in THEN(constToReg (toZZ (size, FALSE), 2, D1);(n:= SMEM&ELSIF op = add THEN(n:= SINCL&ELSE(n:= SEXCL&END;&callRuntime (n);&set.item:= t;&updateStack (old)$END runtimeElemSet;""PROCEDURE runtimeRangeSet (VAR elem1, elem2, set: ExprDesc; lo: ZZ);$(* Bits 'elem1' bis 'elem2' in 'set' setzen; 'set' muû bereits (A0) sein *)$VAR size: LONGCARD; regs: RegSet; n: CARDINAL;$BEGIN&(*$? Safety: assert (set.typeChecked);*)&(*$? Safety: assert (NOT set.regset);*)&regs:= RegSet {A0,A1,A2,D0,D1,D2};&exclRegs (elem1, regs);&exclRegs (elem2, regs);&exclRegs (set, regs);&spillRegs (regs);&loadRegExt (elem1, anyCPUReg, 2, TRUE);&loadRegExt (elem2, anyCPUReg, 2, TRUE);&loadRegs (elem1, D0, elem2, D1);&(*$? Safety:(assert ((set.kind = memory) & (set.mode = d16An) & (set.baseReg = A0));&*)&IF NOT set.zerobased THEN(negZZ (lo); incReg (D0, lo, 2); incReg (D1, lo, 2);&END;&constToReg (toZZ (Size (set), FALSE), 2, D2);&callRuntime (SIRG);$END runtimeRangeSet;""PROCEDURE runtimeCmp8Byte (VAR l, r: ExprDesc);$PROCEDURE load (VAR x: ExprDesc);&BEGIN(IF (x.kind = stack) & (x.stackReg = A3) THEN*(* SUBQ.L #8,A3 *)*incReg (A3, toZZ (-8, FALSE), 4);*x.stackedSize:= 0(END;(loadAddress (x)&END load;$BEGIN&prepareDuo (l, r, RegSet {A0,A1});&load (r); (* 'r' zuerst, falls beide auf Stack liegen! *)&load (l);&loadRegs (r, A0, l, A1);&callRuntime (CMP8);$END runtimeCmp8Byte;""PROCEDURE runtimeSetOp (VAR l, r: ExprDesc;:op: Operator; const, opcode: CARDINAL);$VAR regs: RegSet;$BEGIN&(*$? Safety: assert (NOT l.regset);*)&IF op = eq THEN(regs:= RegSet {A0,A1,D0}&ELSE(regs:= RegSet {A0,A1,D0,D1}&END;&IF opcode = SXOR THEN INCL (regs, D2) END;&prepareDuo (l, r, regs);&loadAddress (l);&loadAddress (r);&loadRegs (l, A0, r, A1);&constToReg (toZZ (LONG (const - 1), FALSE), 2, D0);&callRuntime (opcode);&deallocRegs (r);$END runtimeSetOp;""PROCEDURE runtimeLength (VAR expr: ExprDesc);$VAR exprsize: LONGCARD; size, opcode: CARDINAL; old: ExprDesc;$BEGIN&prepareUno (expr, RegSet {D0,D1,A0});&exprsize:= Size (expr);&IF (exprsize <= 65536L) THEN(opcode:= LENW;(size:= 2&ELSE(opcode:= LENL;(size:= 4&END;&IF isStringVar (expr.item) THEN(loadExprAddress (expr, old);(loadReg (expr, RegSet {A0});(constToReg (toZZ (exprsize-1, FALSE), size, D0);(callRuntime (opcode);(updateStack (old);&ELSE((*$? Safety: assert ((ItemNo (expr.item) = 32) OR (ItemNo (expr.item) = 42)); *)((*/// bei mehrdim. Open Arrays hier sicherstellen, daû nur)* eine Dim. besteht! *)(changeToStackTo (expr, addrRegs-RegSet{A0});(expr.item:= CardPtr;(genMOVEar (expr, A0);(expr.item:= sizedItem (size, FALSE);(genMOVEar (expr, D0);(callRuntime (opcode);&END;&deallocRegs (expr);&initRegExpr (expr, size, allocReg (RegSet {D0}));$END runtimeLength;$"PROCEDURE runtimeCap (VAR expr: ExprDesc);$VAR t: PtrItem;$BEGIN&prepareUno (expr, RegSet {D0,A2});&t:= expr.item;&loadRegExt (expr, RegSet {D0}, 2, TRUE);&callRuntime (CAPI);&expr.item:= t$END runtimeCap;$"PROCEDURE runtimeConstMul (VAR expr: ExprDesc; factor: ZZ;=size, opcode: CARDINAL);$BEGIN&prepareUno (expr, RegSet {D0..D2});&loadReg (expr, RegSet {D0});&constToReg (factor, size, D1);&callRuntime (opcode);$END runtimeConstMul; "PROCEDURE runtimeVarMul (VAR left, right: ExprDesc;;mul: BOOLEAN; opcode: CARDINAL);$(*%* Ergebnis in 'left', 'right' wird freigegeben%*)$BEGIN&prepareDuo (left, right, RegSet {D0..D2});&IF mul&AND (+(left.kind = register)  & (left.exprReg = D1)(OR (right.kind = register) & (right.exprReg = D0) )&THEN(swapExpr (left, right)&END;&loadReg (right, anyCPUReg); (*restoreStack (right);*)&loadReg (left, anyCPUReg);&loadRegs (left, D0, right, D1);&callRuntime (opcode);&deallocRegs (right);$END runtimeVarMul; "PROCEDURE runtimeConstCopy (VAR source, dest: ExprDesc;>long: BOOLEAN; count: LONGCARD);$VAR regs: RegSet; size, opcode: CARDINAL; save: RegSet;(old2, old, workSource, workDest: ExprDesc;$BEGIN&IF long THEN regs:= RegSet {A0..A2,D0..D2} ELSE regs:= RegSet {A0,A1,D0,D1} END;&prepareDuo (source, dest, regs);&workSource:= source;&workDest:= dest;&save:= freeRegs;&loadDestAddress (workDest, count); (* dest   -> A0 *)&loadExprAddress (workSource, old); (* source -> A1 *)&loadRegs (workSource, A1, workDest, A0);&IF long THEN(opcode:= COPYL;(size:= 4&ELSE(opcode:= COPYW;(size:= 2&END;&constToReg (toZZ (count, FALSE), size, D0);&callRuntime (opcode);&updateStack (old);&freeRegs:= save;&(* wenn auf Stack kopiert wurde, ggf. SP hochsetzen *)&WITH dest DO(IF kind = stack THEN*INC (stackedSize, count);*IF stackReg IN tempRegs THEN,(*-* Reg (A0) wurde schon von Runtime-Routine hochgesetzt.-* Nun kann 'dest' einfach A0 zugewiesen bekommen.-* Allerdings kann es sein, daû A0 vorher von 'source' belegt war.-* Diese hat nun eigentlich A1 als Pointer, allerdings wurde-* dies durch das Arbeiten Åber 'workSource' nicht in 'source'-* ggf. durch 'loadRegs' angepaût. Zum GlÅck wird 'source' aber-* nicht mehr benîtigt, so daû sie jetzt hier freigegeben wird-* und dann A0 f. 'dest' verwendet werden kann.-*),deallocRegs (source); source.kind:= jmp (* dummy *);,deallocReg (stackReg);,stackReg:= allocReg (RegSet {A0})*ELSE,(* Reg ist A3 oder so -> wurde schon von 'loadXXXAddress' hochgesetzt*),(* nur syncStacks darf nicht nochmal ADDQ #1,A3 machen: *),IF ODD (stackedSize) THEN INC (stackedSize) END*END;(END&END;$END runtimeConstCopy; "END (* MODULE *) RuntimeCalls;   PROCEDURE makePostInc (VAR sp: ExprDesc; size: LONGCARD);"(*#* Wird aufgerufen, um den A7-Stackpointer in einen Hilfs-Pointer#* umzuladen, damit mit (An)+ gearbeitet werden kann.#* Der Wert 'size' gibt die ParameterlÑnge an und muû gerade sein!#*)"VAR descSP: ExprDesc;"BEGIN$(*$? Safety: assert (sp.kind = stack);*)$WITH sp DO&IF NOT up THEN(roundUp (size);((*$? Safety: assert (stackReg IN (tempRegs + RegSet {A3,A7}));*)(incReg (stackReg, toZZ (-LONGINT (size), FALSE), 4);(initRegExpr (descSP, 4, stackReg);(loadReg (descSP, addrRegs);(stackReg:= descSP.exprReg;(up:= TRUE;(restoreAfterUse:= 0;(stackedSize:= 0&END$END"END makePostInc;   (*!* BEGIN of RealGen!*)  (*!* Dies Modul ist fÅr alle Real-Operationen zustÑndig.!*!* Hierin wird entschieden, auf welche Art die Reals angesprochen werden:!* a) Åber die Runtime-Funktionen mit simulierten FP-Regs,!* b) Åber Runtime, speziell ausgelegt fÅr den externen 881, mit Benutzung!*    seiner Regs,!* c) direkt Åber den 881-Prozessor einer PAK oder des Atari TT.!*)  PROCEDURE genStoreIntFPUReg (r: RegType; VAR dest: ExprDesc);"VAR n: CARDINAL; VAR code: codeDesc;"BEGIN$n:= $F200;$getSrcEA (dest, 0, n, code);$IF coding () THEN&PutCode (n);&n:= FPUT + Freg (r) + $4400;&IF dest.item = RealPtr THEN INC (n, $1000) END;&PutCode (n);&encodeTail (dest, code);$END;"END genStoreIntFPUReg;  PROCEDURE genLoadIntFPUReg (VAR expr: ExprDesc;<opcode: CARDINAL; r: RegType);"VAR ea: BOOLEAN; n1, n2: CARDINAL; VAR code: codeDesc;"BEGIN$n1:= $F200;$n2:= opcode + Fea (expr, ea) + Freg (r);$IF ea THEN getSrcEA (expr, 0, n1, code); END;$IF coding () THEN&PutCode (n1);&PutCode (n2);&IF ea THEN encodeTail (expr, code); END$END;"END genLoadIntFPUReg;  PROCEDURE moveRealRegs (pop: BOOLEAN; list: CARDINAL);"(* FMOVEM gen. *)"VAR op2, opcode: CARDINAL; st: ExprDesc; code: codeDesc;"BEGIN$op2:= FMOVEM + $2000 * ORD (~pop) + $1000 * ORD (pop) + list;$IF fpu () = externalFPU THEN&runtimeMoveRealRegs (op2, pop)$ELSE&(*$? Safety: assert (fpu () = internalFPU); (*sinnlos bei softReals*)*)&IEEERuntimeCall;&initStackExpr (st, CardPtr, A7);&st.up:= pop;&opcode:= $F200;&getSrcEA (st, -1, opcode, code);&IF coding () THEN(PutCode (opcode);(PutCode (op2);&END;$END;"END moveRealRegs;  PROCEDURE loadInternalFPU (VAR expr: ExprDesc;>opcode: CARDINAL; niceRegs: RegSet);"VAR r: RegType;"BEGIN$r:= allocReg (niceRegs);$genLoadIntFPUReg (expr, opcode, r);$deallocRegs (expr);$expr.kind:= register;$expr.exprReg:= r;"END loadInternalFPU;  PROCEDURE loadRealReg (VAR expr: ExprDesc; niceRegs: RegSet);"VAR size: CARDINAL;&r: RegType;&pseudoReg: ExprDesc;"BEGIN$WITH expr DO&IF (kind # register) OR ~(exprReg IN niceRegs) THEN(IF (fpu () = softReal) THEN*size:= SHORT (Size (expr));*IF (kind = stack) & (size > 4) THEN makePostInc (expr, size) END;*IF kind = register THEN,deallocReg (exprReg);,initPseudoRegExpr (expr, item, exprReg, FALSE);*END;*changeToStack (expr);*r:= allocReg (niceRegs);*(*$? Safety: assert (r >= F0); *)*initPseudoRegExpr (pseudoReg, item, r, FALSE);*IF size > 4 THEN,changeToStack (pseudoReg)*END;*copy (expr, pseudoReg, size, FALSE);*deallocRegs (pseudoReg);*deallocRegs (expr);*expr.kind:= register;*expr.exprReg:= r;(ELSIF fpu () = internalFPU THEN*loadInternalFPU (expr, FGET, niceRegs)(ELSE*runtimeLoadRealToReg (expr, niceRegs)(END;&END$END"END loadRealReg;  PROCEDURE pushRealReg (VAR expr: ExprDesc; to: RegType);"(*#* lÑdt 'expr' auf den Stack. 'expr' muû im Reg stehen!#* Es muû darauf geachtet werden, daû keinesfalls ein spilling#* ausgelîst wird, weil es sonst zu Konflikten kommen kann#* (Rekursion in 'spillReg')!#*)"VAR pseudoReg, stack: ExprDesc;"BEGIN$(*$? Safety: assert (expr.kind = register);*)$IF (fpu () = softReal) THEN&initStackExpr (stack, expr.item, to);&IF expr.item = RealPtr THEN(initPseudoRegExpr (pseudoReg, CardPtr, expr.exprReg, to = A7);(genMOVEaa (pseudoReg, stack, 4);(initPseudoRegExpr (pseudoReg, CardPtr, expr.exprReg, to # A7);(genMOVEaa (pseudoReg, stack, 4);&ELSE(initPseudoRegExpr (pseudoReg, expr.item, expr.exprReg, FALSE);(genMOVEaa (pseudoReg, stack, 4);&END;$ELSIF fpu () = internalFPU THEN&initStackExpr (stack, expr.item, to);&genStoreIntFPUReg (expr.exprReg, stack);$ELSE&runtimePushRealReg (expr, to);$END;"END pushRealReg;  PROCEDURE assignRealReg (VAR source, dest: ExprDesc);"(*#* Entweder ist 'dest' ein Reg (Reg-Var) und 'source' ist beliebig#* oder 'source' ist im Register und 'dest' ist Var oder RegVar.#* Beides nur mit FPU (ST oder TT)!#*)"BEGIN$(*$? Safety: assert (fpu() # softReal); *)$IF dest.kind = register THEN&(*$? Safety: assert (dest.exprReg IN varRegs); *)&INCL (freeRegs, dest.exprReg);&loadRealReg (source, RegSet {dest.exprReg});&(*$? Safety: assert (NOT (dest.exprReg IN freeRegs)); *)$ELSE&(*$? Safety: assert (source.kind = register); *)&IF fpu () = internalFPU THEN(genStoreIntFPUReg(source.exprReg, dest);&ELSE(runtimeMoveRealRegToVar (source, dest);&END$END"END assignRealReg;  PROCEDURE negateReal (VAR expr: ExprDesc);"BEGIN$IF fpu () = internalFPU THEN&(* FNEG FPn *)&loadInternalFPU (expr, FNEG, floatRegs)$ELSE&runtimeRealMono (expr, 2)$END"END negateReal;  PROCEDURE absReal (VAR expr: ExprDesc);"BEGIN$IF fpu () = internalFPU THEN&(* FABS FPn *)&loadInternalFPU (expr, FABS, floatRegs)$ELSE&runtimeRealMono (expr, 3)$END"END absReal;  PROCEDURE convertReal (VAR expr: ExprDesc; n: CARDINAL);$(*%* 'n':%*  0: SHORT()%*  1: LONG()%*  LC2S..D2LI: FLOAT/TRUNC%*)"BEGIN$IF (fpu () # softReal) & (n <= 1) THEN&(* das reicht schon f. Expand/Short *)&loadRealReg (expr, floatRegs);&IF n = 0 THEN(expr.item:= SRealPtr&ELSE(expr.item:= RealPtr&END$ELSE&(* ruft immer die allgemeinen Runtime-Funktionen auf: *)&runtimeRealMono (expr, n)$END"END convertReal;  PROCEDURE realOp (op: Operator; VAR this, from: ExprDesc);"(*#* fÅr DIV & SUB gilt: 'this' ist der rechte Wert.#* 'from' kommt in ein Register, 'this' kann alles sein.#*)"VAR isrel: BOOLEAN; n2,n1,m: CARDINAL; ea: BOOLEAN; code: codeDesc;"BEGIN$IF fpu () = internalFPU THEN&prepareFPUop (this, from, op, isrel);&loadRealReg (from, floatRegs);&getFPUop (this, from.exprReg, op, isrel, n2, m, ea);&n1:= $F200;&IF ea THEN getSrcEA (this, 0, n1, code); END;&IF coding () THEN(PutCode (n1);(PutCode (n2);(IF ea THEN encodeTail (this, code); END&END;&deallocRegs (this);&IF isrel THEN(WITH from DO*deallocReg (exprReg);*item:= BoolPtr;*kind:= condFlags;*fpuFlags:= TRUE;*relOp:= op;*signed:= TRUE;  (* irrelevant bei FPU *)*not:= FALSE(END;&END;$ELSE&runtimeRealOp (op, this, from);&(*wird schon in runtime-Routine gemacht: deallocRegs (this); *)$END;$PushExpr (from)"END realOp;  (*!* END of RealGen!*)   PROCEDURE constMul (VAR op: ExprDesc; resultType: PtrItem; factor: ZZ;4checkOver: BOOLEAN);"(*#* Beim Aufruf mÅssen alle ExprDesc auûer 'op' auf dem Stack stehen, da#* sonst der Spill-Mechanismus nicht funktionieren kann!#*#* wenn der Factor Eins ist, der result-Type aber grîûer als der von 'op',#* wird zumindest Code zum Expandieren erzeugt.#*)""VAR opSize, resultSize, opcode: CARDINAL; signed: BOOLEAN; "PROCEDURE overCheck;$BEGIN&(*~~~ die kodierung gen. zwar einen Overflow-Check, sinngemÑû ist es'*    bei der Anwendung f. array-index und f. high-wert-calcs ein'*    range-check!'*    param 'checkOver' sollte bestimmbar machen, von welchem Flag'*    es abh. ist, den overflow zu prÅfen: von der overflow- oder von'*    der range-check-option.'*)&IF checkOver THEN checkOverflow (resultType) END$END overCheck; "PROCEDURE extend;$BEGIN&IF resultSize > opSize THEN(loadRegExt (op, dataRegs, resultSize, TRUE);&END;$END extend; "PROCEDURE singleAdd;$BEGIN&genar (ADD, op, op.exprReg);&overCheck$END singleAdd; "BEGIN$signed:= signedType (resultType);$opSize:= SHORT (Size (op));$resultSize:= SHORT (TypeLength (resultType));$IF nullZZ (factor) THEN&(* es darf keine Null-Konst. erzeugt werden, weil dadurch evtl.'* folgende Proc-Aufrufe wegoptimiert wÅrden. *)&clearExpr (op);$ELSE&IF factor.over THEN((* ~~~ overflow, wenn ABS ('op') > 1 *)((* wir melden erstmal immer einen Fehler: *)(SyntaxError (rAriOv)&ELSIF factor.v = 1L THEN((* extend, aber ggf. in selbem Reg, auch bei Reg-Vars *)(IF resultSize > opSize THEN*loadRegExt (op, anyDataReg, resultSize, TRUE);(END;&ELSIF factor.v = 2L THEN(extend;(loadReg (op, dataRegs);(singleAdd&ELSIF factor.v = 4L THEN(extend;(loadReg (op, dataRegs);(IF checkOver & NOT signed THEN*(* bei Rangecheck kann mit mehrfach-Shift kein Overflow bei+* unsigned Typen erkannt werden *)*singleAdd; singleAdd(ELSE*gena (ASLI + $200 * 2, op, 0);*overCheck(END&ELSIF factor.v = 8L THEN(extend;(loadReg (op, dataRegs);(IF checkOver & NOT signed THEN*(* s.o. *)*singleAdd; singleAdd; singleAdd(ELSE*gena (ASLI + $200 * 3, op, 0);*overCheck(END&ELSE((*~~~ ggf. auch bei anderen 2-Potenz-Faktoren mit ASL arbeiten?!)*    dann z.b. f. 2^16 SWAP verwenden! *)(IF opSize <= 2 THEN*loadRegExt (op, dataRegs, 2, FALSE);*IF signed THEN opcode:= MULS ELSE opcode:= MULU END;*genir (opcode, FALSE, factor.v, op.exprReg);*IF resultSize = 4 THEN,IF signed THEN op.item:= IntPtr ELSE op.item:= CardPtr END;*ELSIF checkOver THEN,checkMulOverflow (op)*END(ELSE*IF signed & int16ZZ (factor) & posZZ (factor)*OR NOT signed & card16ZZ (factor) THEN,(* Long * Word *),IF signed THEN opcode:= IMLW ELSE opcode:= CMLW END;,runtimeConstMul (op, factor, 2, opcode);,overCheck;*ELSE,(* Long  * Long *),IF signed THEN opcode:= IMLL ELSE opcode:= CMLL END;,runtimeConstMul (op, factor, 4, opcode);,overCheck;*END(END&END$END;$op.item:= resultType;"END constMul;    PROCEDURE constAdd (VAR op: ExprDesc; resultType: PtrItem; const: ZZ;4checkOver: BOOLEAN); "VAR opSize, resultSize: CARDINAL; "BEGIN$resultSize:= SHORT (TypeLength (resultType));$opSize:= SHORT (Size (op));$IF resultSize > opSize THEN&loadRegExt (op, dataRegs, resultSize, TRUE);$END;$IF NOT nullZZ (const) THEN&loadReg (op, dataRegs);&incReg (op.exprReg, const, resultSize);&IF checkOver THEN checkOverflow (resultType) END$END;$op.item:= resultType;"END constAdd;"  PROCEDURE bothOnStack (left, right: ExprDesc): BOOLEAN;"BEGIN$RETURN (left.kind = stack) AND (right.kind = stack)+AND (left.up = right.up)"END bothOnStack;   PROCEDURE mustCopyByByte (VAR expr: ExprDesc): BOOLEAN;"(*#* Liefert TRUE, wenn Datum byteweise kopiert werden sollte, da es sonst#* u.U. zu Adreû-Fehler kommen kann.#* Liefert nicht TRUE, wenn Datum ein Byte groû ist, weil dann der#* vergesehene MOVE verwendet werden kann.#*)#"BEGIN$RETURN (Size (expr) # 1L)'AND (expr.kind = memory) & expr.mayBeOdd & ByteType (expr.item)"END mustCopyByByte;   (* ************************************************************************* *)  (*!* Intelligente, Code erzeugende Routinen!*)  PROCEDURE clrSingle (VAR dest: ExprDesc; n: CARDINAL);"(*#* 'stackedSize' wird nur hochgezÑhlt, wenn 'n' nicht Null ist!#*)"BEGIN$gena (CLR, dest, n);$IF dest.kind = stack THEN&IF dest.stackReg = A7 THEN roundUpCard (n) END;&INC (dest.stackedSize, n)$END;"END clrSingle;  PROCEDURE moveSingle (VAR source, dest: ExprDesc; n: CARDINAL);"(*#* 'stackedSize' wird nur hochgezÑhlt, wenn 'n' nicht Null ist!#*)"BEGIN$IF (source.kind = constant) AND (source.exprConst.zz.l = 0L) THEN&IF n = 0 THEN((* hiermit wird verhindert, daû stackedSize verÑndert wird, *)* aber trotzdem die Size von 'source' verwendet wird       *)(gena (CLR, dest, SHORT (Size (source)))&ELSE(clrSingle (dest, n)&END$ELSE&genMOVEaa (source, dest, n);&IF source.kind = stack THEN(IF source.stackReg = A7 THEN roundUpCard (n) END;(INC (source.stackedSize, n)&END;&IF dest.kind = stack THEN(IF dest.stackReg = A7 THEN roundUpCard (n) END;(INC (dest.stackedSize, n)&END$END"END moveSingle;   PROCEDURE copy (VAR source, dest: ExprDesc; size: LONGCARD; byByte: BOOLEAN); "VAR null: ExprDesc;&ptrConst: ADDRESS;&first, nulled: BOOLEAN;&constSave: ConstValue; "TYPE copyProc = PROCEDURE (CARDINAL);""PROCEDURE zero (siz: CARDINAL): BOOLEAN;$CONST null = BYTE (0);$VAR n: CARDINAL; p: POINTER TO BYTE;$BEGIN&p:= ptrConst;&REPEAT(IF p^ # null THEN RETURN FALSE END;(DEC (siz);(INC (p)&UNTIL siz = 0;&RETURN TRUE$END zero; "PROCEDURE constCopy (n: CARDINAL);$BEGIN&(*$? Safety:(assert (first OR (dest.kind = stack) & (dest.stackReg # A7) & (dest.up));&*)&first:= FALSE;&IF (n = 4) AND NOT zero (4)&AND ( zero (2) OR zero (2) )&AND (dest.kind = stack) & (dest.stackReg # A7) THEN(constCopy (2);(constCopy (2)&ELSE(DEC (size, n);(IF zero (n) THEN*IF nulled THEN,moveSingle (null, dest, n)*ELSE,IF size <= 2L THEN.(* CLR (An)+ *).clrSingle (dest, n),ELSE.(* MOVEQ #0,Dn    *).(* MOVE  D0,(An)+ *).initConstExpr (null, n, toZZ (0L, FALSE));.loadReg (null, dataRegs);.nulled:= TRUE;.moveSingle (null, dest, n),END*END(ELSE*Move (ptrConst, ADR (source.exprConst.b) + 1L - LONG (n), n);*moveSingle (source, dest, n);(END;(INC (ptrConst, n)&END$END constCopy; "PROCEDURE memCopy (n: CARDINAL);$BEGIN&(*$? Safety: assert (first OR (dest.kind = stack) &<((source.kind # stack) OR (dest.up = source.up)));*)&first:= FALSE;&DEC (size, n);&moveSingle (source, dest, n)$END memCopy; "PROCEDURE doit (n: CARDINAL);$BEGIN&IF source.kind = constant THEN(constCopy (n)&ELSE(memCopy (n)&END;$END doit; "BEGIN$(*$? Safety:&assert ( NOT byByte OR NOT ((dest.kind=stack) & (dest.stackReg=A7)) );$*)$IF (dest.kind = register) & (source.kind = constant) THEN&(*$? Safety: assert ((dest.exprReg IN varRegs) & NOT (dest.exprReg IN freeRegs));*)&constToReg (source.exprConst.zz, SHORT (size), dest.exprReg);$ELSE&(*'* Sonderfall, wenn single Instr. und source.kind = constant:'*   dann kann, wenn ein Byte an ein Long zugewiesen wird, ein'*   MOVEQ #const,Dn gen. werden!'*)&IF (size = 4L) & NOT byByte&& (source.kind = constant) & int8ZZ (source.exprConst.zz)&& NOT nullZZ (source.exprConst.zz) THEN(loadReg (source, anyDataReg)&END;&&nulled:= FALSE;&constSave:= source.exprConst;&ptrConst:= ADR (constSave.b) + 1L - size;&first:= TRUE;&IF NOT byByte THEN(WHILE SHORT (size) >= 4 DO*doit (4)(END;(IF SHORT (size) >= 2 THEN*doit (2)(END&END;&WHILE SHORT (size) # 0 DO(doit (1)&END;&IF nulled THEN deallocRegs (null) END;$END"END copy;   PROCEDURE moveLocalProcOnA3 (VAR source: ExprDesc);"(* LÑdt eine Prozedur oder eine Proc-Var (Typ 19) auf den A3-Stack *)"VAR help: ExprDesc;"BEGIN$initStackExpr (help, CardPtr, A3);$(*&IF (source.kind # stack) OR (source.stackReg # A3) THEN((*was war denn hier???*)&END;$*)$IF ItemNo (source.item) = 6 THEN&IF global IN ItemFlag (source.item) THEN(genMOVEaa (source, help, 4);(deallocRegs (source);(gena (CLR, help, 4);&ELSE(makeIndir (source, 0, FALSE);(loadAddress (source);(genMOVEaa (source, help, 4);(deallocRegs (source);((* bei lokalen procs Display laden *)(IF source.tiefe = 0 THEN*(* MOVE.L A6,(A3)+ *)*initRegExpr (source, 4, getLink (0));(ELSE*(* MOVE.L (Ar),(A3)+ *)*initRegExpr (source, 4, getLink (source.tiefe-1));*makeIndir (source, 0, FALSE)(END;(genMOVEaa (source, help, 4);(deallocRegs (source)&END$ELSE&(*$? Safety: assert (ItemNo (source.item) = 19);*)&genMOVEaa (source, help, 4);&deallocRegs (source);&gena (CLR, help, 4);$END;$source:= help;$source.up:= FALSE;$source.stackedSize:= 8;"END moveLocalProcOnA3;   PROCEDURE fitValue (VAR source: ExprDesc; (*kein VAR! *) conv: ConvDesc);"(*#* Macht Expand und Range-Check fÅr alle ordinalen und Real-Types#*#* Der Type von expr wird auch mit angepaût!#*#* Erzeugt Range-Check-Code, falls $R-Option aktiv ist.#* Muû nach 'asnCompatible' und vor dem Assignment#* aufgerufen werden.#*#* ~~~ in sonderfÑllen kînnte dies schon auûen optimiert werden:#*     denn diese routine muû zum check den wert ins reg laden,#*     bei zuweisung eines card auf einen int brÑuchte aber nur#*     erst hinterher ein BMI-check gemacht werden.#*     lîsung: zumindest sollte diese routine auch den status 'condRegs'#*     auswerten kînnen und bei den einfachen fÑllen auch darauf verzichten,#*     den wert ins reg zu laden. dann wÅrde dies von assign erkannt werden#*     mÅssen, und dann nach dem assign der kind=condRegs sein und dann#*     der check hier gemacht werden.#*)""PROCEDURE prepareBoundCheck (lo, hi: LONGWORD; signed: BOOLEAN; size: CARDINAL);$(* bereitet Subrange-Check vor. Wenn bereits einer vorgesehen ist,%* wird der Bereich entspr. verkleinert *)$VAR z1: ZZ;$BEGIN&WITH conv DO(IF boundsCheck THEN*z1:= toZZ (lowerBound, signedBounds);*IF cmpZZ (z1, toZZ (lo, signed)) = lt THEN lowerBound:= lo END;*z1:= toZZ (upperBound, signedBounds);*IF cmpZZ (z1, toZZ (hi, signed)) = gt THEN upperBound:= hi END;(ELSE*boundsCheck:= TRUE;*lowerBound:= lo;*upperBound:= hi(END;(signedBounds:= signed;(IF cmpZZ (toZZ (lowerBound, signedBounds),2toZZ (upperBound, signedBounds)) = gt THEN*(* ranges Åberschneiden sich nicht mehr -> Fehler melden *)*SyntaxError (rSubrg)(END;(boundSize:= size&END$END prepareBoundCheck; "VAR loExpr, hiExpr, help: ExprDesc;&savedType: PtrItem;&elems: LONGCARD;&lo, hi: ZZ; "BEGIN (* fitValue *)$WITH conv DO&IF realConv IN sizeFlags THEN(IF source.kind = constant THEN*IF shorten IN sizeFlags THEN,shortenReal (source, rReaRg)*ELSIF expand IN sizeFlags THEN,expandReal (source)*END(ELSE*IF shorten IN sizeFlags THEN,convertReal (source, 0)*ELSIF expand IN sizeFlags THEN,convertReal (source, 1)*END(END((*~~~ die runtime-aufrufe bei der VAL-auswertung kînnen hierdurch)*       ersetzt werden)*)"&ELSIF sizeFlags # convSet {} THEN&(IF source.kind = constant THEN**getBounds (destType, lo, hi);*IF NOT inZZ (source.exprConst.zz, lo, hi) THEN SyntaxError (rConRg) END;((ELSE(*(*$? Safety2: assert ((sourceSize) = SHORT (Size (source)));*)**(*+* Range-Check bei Zuweisung von verschiedenen Basistypes+* ------------------------------------------------------+*+* shorten+* -------+*+* LONGINT -> INTEGER:+*      MOVE.L  source,Dx+*      ; signed -> MOVEA+*      MOVE.W  Dx,Ay+*      CMP.L   Dx,Ay+*      BEQ     ok+*      TRAP+*   ok MOVE    Dx,dest+*+* LONGCARD -> INTEGER (wie LONGCARD/LONGINT->CARDINAL, plus BMI):+*      MOVE.L  source,Dx+*      ; NOT signed+*      MOVEQ   #0,Dy+*      MOVE.W  Dx,Dy+*      BMI     er              ; <- signChange+*      CMP.L   Dx,Dy+*      BEQ     ok+*   er TRAP+*   ok MOVE    Dx,dest+*+* LONGCARD / LONGINT -> CARDINAL+*      MOVE.L  source,Dx+*      ; NOT signed+*      MOVEQ   #0,Dy+*      MOVE.W  Dx,Dy+*      CMP.L   Dx,Dy+*      BEQ     ok+*   er TRAP+*   ok MOVE    Dx,dest+*+* LONGCARD / LONGINT -> BOOLEAN / Enum:+*   wie LONGCARD / LONGINT -> CARDINAL, zusÑtzlich Subrange-Check+*+* LONGCARD / LONGINT -> CHAR (wie LC/LI->CARDINAL, nur andere Size):+*      MOVE.L  source,Dx+*      ; NOT signed+*      MOVEQ   #0,Dy+*      MOVE.B  Dx,Dy     ; <- Size: destSize+*      CMP.L   Dx,Dy+*      BEQ     ok+*   er TRAP+*   ok MOVE    Dx,dest+*+* Enum / CARDINAL / INTEGER -> CHAR+*      MOVE.W  source,Dx+*      MOVE.B  Dx,dest+*   zusÑtzlich Subrange-Test [0..255]+*+* BOOLEAN -> CHAR+*      MOVE.W  source,Dx+*      MOVE.B  Dx,dest+*   kein Test nîtig+*+* Localproc-Type (44) -> Proc-Type (19)+*      LEA     source,A0+*      TST.L   4(A0)+*      BEQ     ok+*      TRAP+*   ok+*+* expand+* ------+*+* CHAR -> CARDINAL / INTEGER+*      MOVEQ   #0,Dx+*      MOVE.B  source,Dx+*      MOVE.W  Dx,dest+*+* CHAR / CARDINAL / BOOLEAN / Enum -> LONGCARD / LONGINT+*      MOVEQ   #0,Dx+*      MOVE    source,Dx       ; size: 'sourceSize'+*      MOVE.L  Dx,dest+*+* INTEGER -> LONGINT+*      MOVE.W  source,Dx+*      EXT.L   Dx+*      MOVE.L  Dx,dest+*+* INTEGER -> LONGCARD+*      MOVE.W  source,Dx+*      EXT.L   Dx+*      BPL     ok+*      TRAP+*   ok MOVE.L  Dx,dest+*+* Procedure (6) / Proc-Type (19) -> Localproc-Type (44)+*      MOVE.L  source,(A3)++*      CLR.L   (A3)++*+*+* keine Size-énderung+* -------------------+*+* BOOLEAN / Enum (<32768 Elemente) -> INTEGER:+*   immer OK+*+* CARDINAL / INTEGER -> Enum / BOOLEAN+*   nur Subrange-Check+*+* CARDINAL / Enum (>=32768 Elemente) -> INTEGER,+* INTEGER                            -> CARDINAL:+*      Range-Check [0..$7FFF]+*+* LONGCARD -> LONGINT,+* LONGINT -> LONGCARD:+*      MOVE.L  source,D0+*      BPL     ok+*      TRAP+*   ok MOVE.L  Dx,dest+*+*) *(* wenn Size = 1, dann muû es ein CHAR o. BYTE sein: *)*(*$? Safety2:*assert ((destSize # 1)2OR (ItemNo (destType) = 38)2OR (ItemNo (destType) = 3));*assert ((sourceSize # 1)2OR (ItemNo (source.item) = 38)2OR (ItemNo (source.item) = 3));**)*IF shorten IN sizeFlags THEN,,(* beim KÅrzen muû source > 1 Byte, dest < 4 Byte sein: *),(*$? Safety2:,assert (((sourceSize) = 4) OR (sourceSize = 2));,assert (((destSize) = 2) OR (destSize = 1));,*),loadReg (source, anyDataReg);,IF rangeCheckActive () & NOT (subCheck IN sizeFlags) THEN.savedType:= source.item;.source.item:= sizedItem (destSize, signedConv IN sizeFlags);.copyRegExt (source, help, dataRegs + addrRegs, sourceSize);.IF signChange IN sizeFlags THEN0(*$? Safety: assert (NOT (signedConv IN sizeFlags));*)0gen (Bcc + mapCC(pl, FALSE, TRUE) + 4).END;.source.item:= savedType;.genar (CMP, source, help.exprReg);.deallocRegs (help);.gen (Bcc + mapCC (eq, FALSE, FALSE) + 4);.genTrap (RangeTrap),END**ELSIF expand IN sizeFlags THEN,,(* beim Erweitern muû source < 4 Byte, dest > 1 Byte sein: *),(*$? Safety2:,assert ((sourceSize = 1) OR (sourceSize = 2));,assert ((destSize = 2) OR (destSize = 4));,*),IF rangeCheckActive (),& (signedConv IN sizeFlags),& (signChange IN sizeFlags) THEN.(* INTEGER -> LONGCARD *).loadRegExt (source, anyDataReg, 4, TRUE);.gen (Bcc + mapCC (pl, FALSE, FALSE) + 4);.genTrap (RangeTrap),ELSE.loadRegExt (source, anyCPUReg, 4, TRUE).(* hier wird Wert ggf. auch in ein Adreû-Reg. geladen *),END,*ELSIF procShorten IN sizeFlags THEN,,(*$? Safety2:,assert (ItemNo (source.item) = 44);,assert (ItemNo (destType) = 19);,assert (source.kind # stack);,*),loadAddress (source);,makeIndir (source, 4, FALSE);,gena (TST, source, 4);,source.disp:= 0;,gen (Bcc + mapCC (eq, FALSE, FALSE) + 4);,genTrap (DisplayTrap),*ELSIF procExpand IN sizeFlags THEN,,(*$? Safety2: assert (ItemNo (destType) = 44);*),moveLocalProcOnA3 (source);,*ELSE,,(* sonst mÅssen Grîûen identisch sein *),(*$? Safety2: assert ((sourceSize) = (sourceSize));*),,IF rangeCheckActive () THEN.IF signChange IN sizeFlags THEN0IF sourceSize = 4 THEN2loadReg (source, anyDataReg);2gen (Bcc + mapCC (pl, FALSE, FALSE) + 4);2genTrap (RangeTrap)0ELSE2(*$? Safety2: assert (sourceSize = 2);*)2prepareBoundCheck (0L, $7FFFL, FALSE, sourceSize)0END.END,END,*END; (* IF shorten.. OR expand.. ELSE *)&(END"&ELSIF (source.kind # constant) & (source.kind # constRef) THEN ((* prÅfen, ob beide Types wirklich gleich groû sind.)* Falls nicht, haben wir bei 'getConversionDesc' einen der Types)* (z.B. BothTyp, SBothTyp) vergessen.)*)((*$? Safety2: assert (Size (source) = TypeLength (destType));*)"&END; (* ELSIF sizeFlags # convSet {} ELSE *)&&IF NOT isSS (source) THEN(source.item:= destType;(IF sizeFlags # convSet {} THEN*sourceSize:= destSize;(END;&END;&&IF boundsCheck THEN&(IF source.kind = constant THEN,*getBounds (destType, lo, hi);*IF NOT inZZ (source.exprConst.zz, lo, hi) THEN SyntaxError (rConRg) END;((ELSE*IF rangeCheckActive () THEN,,initConstExpr (loExpr, boundSize,;toZZ (lowerBound, signedBounds));,initConstExpr (hiExpr, boundSize,;toZZ (upperBound, signedBounds));,,IF (boundSize = 2),& (LONGCARD (lowerBound) = 0L),& (LONGCARD (upperBound) <= $7FFFL) THEN.loadReg (source, anyDataReg);.genir (CHK, FALSE, upperBound, source.exprReg);,ELSIF (boundSize = 4),& (LONGCARD (lowerBound) # 0L),& (   (LONGCARD (lowerBound) <= $7FFFL)/OR (LONGCARD (upperBound) <= $7FFFL) ) THEN.(* Wert wird in ein Adreû-Reg geladen und kann dann mit CMPA.W/* verglichen werden *).loadReg (source, addrRegs);.IF LONGCARD (lowerBound) <= $7FFFL THEN loExpr.item:= SIntPtr END;.IF LONGCARD (upperBound) <= $7FFFL THEN hiExpr.item:= SIntPtr END;.genar (CMP, loExpr, source.exprReg);.gen (Bcc + mapCC (lt, signedBounds, FALSE) + 4 + SHORT (Size (hiExpr)));.genar (CMP, hiExpr, source.exprReg);.gen (Bcc + mapCC (le, signedBounds, FALSE) + 4);.genTrap (RangeTrap),ELSE.loadReg (source, anyDataReg);.IF signedBounds & (LONGCARD (lowerBound) = 0L) THEN0gen (Bcc + mapCC (pl, FALSE, FALSE) + 4);0genTrap (RangeTrap).ELSE0IF LONGCARD (lowerBound) # 0L THEN2genar (CMP, loExpr, source.exprReg);2gen (Bcc + mapCC (lt, signedBounds, FALSE) + 6);0END;0genar (CMP, hiExpr, source.exprReg);0gen (Bcc + mapCC (le, signedBounds, FALSE) + 4);0genTrap (RangeTrap).END,END(*END (* IF rangeCheckActive () *)*(END (* IF source.kind = constant *)(&END (* IF boundsCheck *)$END (* WITH conv *)"END fitValue;  PROCEDURE valueFitting (REF range: ConvDesc): BOOLEAN;"(*#* Liefert TRUE, wenn kein Range-Check oder Expand durchgefÅhrt werden muû.#*)"BEGIN$WITH range DO&RETURN NOT ( rangeCheckActive ()3& (boundsCheck OR (sizeFlags # convSet {})) )3& (sourceSize = destSize)$END;"END valueFitting;   PROCEDURE syncStacks (VAR expr, dest: ExprDesc; pre: BOOLEAN);"(*#* korrigiert bei Datentransfer ggf. die Stacks#* 'pre': TRUE, wenn Aufruf vor dem Transfer, sonst danach#*)"PROCEDURE syncStack (VAR sp: ExprDesc);$BEGIN&WITH sp DO((*$? Safety: assert (stackReg IN (tempRegs + RegSet {A3,A7}));*)(IF pre & NOT up THEN*IF stackReg # A7 THEN,incReg (stackReg, toZZ (-1L, FALSE), 4);,INC (stackedSize)*END;(ELSIF NOT pre & up THEN*IF stackReg # A7 THEN,incReg (stackReg, toZZ (+1L, FALSE), 4);,INC (stackedSize)*END;(END;&END$END syncStack;"BEGIN$IF (dest.kind = stack) & ODD (dest.stackedSize) THEN&IF (expr.kind = stack) THEN syncStack (expr) END;&syncStack (dest)$END;$(*$? Safety: assert (pre OR NOT ODD (A3Offset) & NOT ODD (A7Offset))*)"END syncStacks;  PROCEDURE adaptStack (VAR expr: ExprDesc; sourceSize: LONGCARD);"(*#* Paût A3 f. Laden eines Datum vom Stack an#*)"BEGIN$WITH expr DO&IF (kind = stack) & (stackReg = A3) THEN((*$? Safety: assert (stackedSize # 0L);*)(incReg (stackReg,0toZZ (LONGINT (sourceSize) - LONGINT (stackedSize), FALSE), 4);(stackedSize:= sourceSize&END$END"END adaptStack;"  PROCEDURE fillStack (VAR dest: ExprDesc; destSize: LONGCARD);"(*#* fÅllt Stack bei String-Consts auf 'destSize' auf#*)"BEGIN$(*$? Safety: assert (dest.stackReg IN (tempRegs + RegSet {A3,A7}));*)$incReg (dest.stackReg, toZZ (LONGINT (destSize) - LONGINT (dest.stackedSize), FALSE), 4);$dest.stackedSize:= destSize"END fillStack;   (* ************************************************************************* *)  (*!* Vorbereitende Hilfs-Routinen, die Code-unabhÑngig sind!*)  PROCEDURE shiftLeft (VAR expr: ExprDesc; n: CARDINAL);"VAR c: CARDINAL;"BEGIN$IF n > 0 THEN&WITH expr.exprConst DO(FOR c:= n TO strConstSize DO*str [c-n]:= str [c](END;(FOR c:= strConstSize - n + 1 TO strConstSize DO*str [c]:= StringTerminator(END&END;&SetSize (expr, Size (expr) + LONG (n));$END"END shiftLeft;  PROCEDURE shiftRight (VAR expr: ExprDesc; n: CARDINAL);"VAR c: CARDINAL;"BEGIN$WITH expr.exprConst DO&FOR c:= strConstSize TO n BY -1 DO(str [c]:= str [c-n]&END;&FOR c:= 0 TO n-1 DO(str [c]:= 0C&END$END;$SetSize (expr, Size (expr) - LONG (n));"END shiftRight;  PROCEDURE terminateStringConst (VAR expr: ExprDesc; destType: PtrItem);"(*#* FÅgt bei String-Consts ggf. eine Null an, wenn die dest-LÑnge#* es erfordert.#*)"VAR destSize, exprSize: LONGCARD;"BEGIN$(*$? Safety:$assert (expr.item = SSTyp);$*)$exprSize:= Size (expr);$destSize:= TypeLength (destType);$IF exprSize < destSize THEN&IF expr.kind = constant THEN (* noch kein Ende-Zeichen dran *)(IF (exprSize = 0)(OR (expr.exprConst.str[strConstSize] # StringTerminator) THEN*shiftLeft (expr, 1) (* String aufschieben *)(END&ELSE((*$? Safety: assert ((expr.kind = constRef));*)((* bei Strings im Data ist schon eine Null dran *)(SetSize (expr, Size (expr) + 1L);&END$END;"END terminateStringConst;  PROCEDURE adaptStringConst (VAR expr: ExprDesc; destType: PtrItem);"(*#* FÅllt String-Consts auf LÑnge des String-Typs 'destType' auf.#* Ist 'destType' kleiner, wird String auch korrekt gekÅrzt.#* Wird nur fÅr Typ-Casts von Strings benutzt.#*)"VAR destSize, exprSize: LONGCARD;"BEGIN$(*$? Safety: assert (isSS (expr) & isStringVar (destType));*)$exprSize:= Size (expr);$destSize:= TypeLength (destType);$IF exprSize # destSize THEN&IF exprSize <= LONG (constBufSize) THEN((*$? Safety: assert (expr.kind = constant);*)(IF destSize > LONG (constBufSize) THEN*(* Const muû abgelegt werden.-Sie wird nur in ihrer upsprÅnglichen LÑnge abgelegt, was-aber u.U. zu Speicherverletzungen fÅhren kann, weil trotzdem-die Anzahl von "destSize" Bytes bei einer Zuweisung kopiert-werden wird! Aber das vernachlÑssigen wir einfach, bis jemand-sich darÅber beschwert.**)*changeConstantToConstRef (expr, exprSize);(ELSIF destSize > exprSize THEN*shiftLeft (expr, SHORT (destSize-exprSize)) (* String verlÑngern *)(ELSE*shiftRight (expr, SHORT (exprSize-destSize)) (* String verkÅrzen *)(END;&ELSE((*$? Safety: assert (expr.kind = constRef);*)((*)* String mÅûte bereits 0-terminiert sein, daher keine weitere)* Aktion nîtig)*)&END$END;$expr.item:= destType"END adaptStringConst;    (* ----------------------------------------------------------------------- *)  (* ----------------------------------------------------------------------- *)   FORWARD VarExpression (); FORWARD ConstExpression;  FORWARD call (VAR leftOnA3: LONGCARD; pushAddr: BOOLEAN; pushBase: LONGINT); FORWARD hdlSetConstructor (type: PtrItem); FORWARD hdlArrayConstructor (type: PtrItem); FORWARD hdlRecordConstructor (type: PtrItem);  PROCEDURE hdlConstructor (t: PtrItem);"BEGIN$IF (ItemNo (t) = 45) OR (ItemNo (t) = 5) (* SET *) THEN&hdlSetConstructor (t)$ELSIF ItemNo (t) = 12 (* ARRAY *) THEN&hdlArrayConstructor (t)$ELSIF ItemNo (t) = 13 (* RECORD *) THEN&hdlRecordConstructor (t);$ELSE&SyntaxError (rValCs)$END;"END hdlConstructor;  PROCEDURE deref (VAR fact: ExprDesc);"(*#* lÑdt Pointer und Ñndert 'expr' in seinen Basetype#*)"VAR no: CARDINAL;"BEGIN$no:= ItemNo (fact.item);$IF (no = 20 (* POINTER *) )$OR (no = 23 (* ADDRESS *) ) THEN&(* Wert des Pointers laden: MOVE.L (Ax),Ax *)&loadReg (fact, anyAddrReg);&makeIndir (fact, 0, TRUE);&fact.item:= RefType (fact.item);&IF ItemNo (fact.item) = 0 (* zeigt auf Relay *) THEN(SyntaxError (rBdPtr)&END;&fact.readOnly:= FALSE$ELSE&SyntaxError (rPtrXp)$END"END deref;   (* ----------------------------------------------------------------------- *)    PROCEDURE extractConst (VAR fact: ExprDesc; ofs, size: LONGCARD);"(*#* verkleinert 'fact'. Dazu ist 'ofs' der Offset ab Const-Beginn, 'size'#* die neue LÑnge.#*)"VAR endptr: ADDRESS;&help: ConstValue;"BEGIN$WITH fact DO&IF kind = constant THEN(endptr:= ADR (exprConst.b) + 1;(Move (endptr - Size (fact) + ORD (ofs), endptr - size, size);&ELSE((*$? Safety: assert (kind = constRef); *)(INC (constOfs, ofs);(IF (size <= constBufSize) THEN*(* wir kînnen Const aus Code 'exprConst' ablegen *)*IF constHead = NIL THEN dropConstantFromTree (fact) END;*Move (constAddr + constOfs, ADR(help.b)+1-size, size);*cutConst (fact);*exprConst:= help;*kind:= constant(ELSE*(* abgelegte Const im DATA-Puffer direkt kÅrzen *)*IF (constOfs > 0) & (varItem = NIL) & constantAtEnd (fact) THEN,reduceConstant (fact);*END(END;&END;$END"END extractConst;   PROCEDURE checkBounds (VAR index: ExprDesc; VAR arrayLow, arrayHigh, base: ZZ);"(*#* Dyn. Range-check f. Array-Bounds#*#* Findet zuerst heraus, ob Index-Range in den Feldbereich paût, so daû#* kein Range-Check nîtig wird. Dazu werden dann die Array-Bounds#* korrigiert, so daû auch die Index-Breitenbestimmung auûerhalb#* sich ggf. auf einen Shortint beschrÑnken kann, obwohl das Feld#* selbst einen Long-Range hat.#*#* In 'base' wird der Offset geliefert, der beim Elementzugriff vom#* index noch subtrahiert werden muû.#*#* ~~~ kann diese Routine mit 'fitValue' kombiniert werden, sobald#*     'fitValue' die Checks rein nach den Bounds beurteilt (und nicht#*     getrennt nach range-check und sign-change)?#*)"VAR alreadyInReg, lowFits, highFits, chkInstr: BOOLEAN;&indexLow, indexHigh: ZZ;"BEGIN$base:= arrayLow;$$(* PrÅfen, ob Index bedingungslos in Feldbereich paût *)$getBounds (index.item, indexLow, indexHigh);$lowFits:= cmpZZ (indexLow, arrayLow) # lt;$highFits:= cmpZZ (indexHigh, arrayHigh) # gt;$IF lowFits THEN arrayLow:= indexLow END;$IF highFits THEN arrayHigh:= indexHigh END;$IF cmpZZ (arrayLow, arrayHigh) = gt THEN&(* ranges Åberschneiden sich nicht mehr -> Fehler melden *)&SyntaxError (rSubrg)$END;$$IF rangeCheckActive () THEN&(*                                        [..arrayHigh](- index[0..61000] -> array[0..60000]  : [..60000] CMP #60000(- index[0..31000] -> array[0..30000]  : [..30000] CHK #30000(- index[0..61000] -> array[0..30000]  : [..30000] CHK #30000(- index[0..31000] -> array[0..60000]  : [..31000] keine PrÅfung&*)&chkInstr:= (Size (index) = 2L) & int16ZZ (arrayHigh) & (arrayHigh.l >= 0);((* >>> Size(index) muû 2 sein, weil CHK nur diese Grîûe kann,)*     der zu testende High-Bound muû innerhalb 0..$7FFF liegen. *)&&(*'* Low-Check durchfÅhren:'* Wert gleichzeitig auf Null bringen, damit die Elemente'* am Ende mit Null-Baseoffset adressiert werden kînnen.'*'* index[-10..] -> array[0..]  : [0..], kein CHK, keine Base-Korrektur'*)&IF NOT lowFits THEN(alreadyInReg:= (index.kind = register) & (index.exprReg IN dataRegs);(loadReg (index, dataRegs);(IF nullZZ (arrayLow) THEN*IF alreadyInReg THEN,(* TST index, um Flags zu setzen *),gena (TST, index, 0)*END;*(* Reg nur auf negativ testen: BLE error *)(ELSE*subZZ (arrayHigh, arrayLow);*negZZ (arrayLow); (* arrayLow darf nicht > 2^31 sein - naja *)*incReg (index.exprReg, arrayLow, SHORT (Size (index)));*(* ADD wurde erzeugt ->  BCC/GE error *)*(* SUB wurde erzeugt ->  BCS/LT error *)*base:= toZZ (0L, FALSE);*arrayLow:= toZZ (0L, FALSE)(END;(IF chkInstr OR highFits THEN*(* wir mÅssen hier schon Trap erzeugen *)*gen (Bcc + mapCC (ge, signedExpr (index), FALSE) + 4);*genTrap (RangeTrap)(ELSE*(* sprung auf Trap von arrayHigh-check *)*gen (Bcc + mapCC (lt, signedExpr (index), FALSE) + 4 + sizeZZeven (arrayHigh))(END;&END;&&(*'* Nun High-Check durchfÅhren:'* CHK geht nur bei high<=MaxInt'* beim obigen SUB muû sonst ggf. mit BCC der unterlauf'* geprÅft werden!'*'* Es wird immer vorzeichenlos verglichen. Das geht, weil der Wert'* immer bull-based vorliegt.'*)&IF NOT highFits THEN(loadReg (index, anyDataReg);(IF chkInstr THEN*genir (CHK, FALSE, arrayHigh.c, index.exprReg);(ELSE*genia (CMPI, arrayHigh.l, index, 0);*gen (Bcc + mapCC (le, FALSE, FALSE) + 4);*genTrap (RangeTrap)(END&END$$END (* IF rangeCheckActive *)"END checkBounds;  FORWARD varMul (op: Operator; left, right: ExprDesc;2chkOver: BOOLEAN; resultType: PtrItem);  PROCEDURE accessArray (VAR fact: ExprDesc; no: CARDINAL; forHIGH: BOOLEAN); "PROCEDURE myMulZZ (VAR x: ZZ; elemSize: LONGCARD; VAR over: BOOLEAN);$VAR pos: BOOLEAN;$BEGIN&SignalOverflow:= FALSE;&HasOverflown:= FALSE;&pos:= posZZ (x);&mulZZ (x, toZZ (elemSize, FALSE));&over:= HasOverflown;&IF HasOverflown THEN(IF pos THEN*x:= toZZ (MaxLCard, FALSE)(ELSE*x:= toZZ (MinLInt, TRUE)(END;&END;&SignalOverflow:= TRUE;$END myMulZZ; "VAR$firstOpenArray, highPtrUsed: BOOLEAN; "PROCEDURE accessSubRoutine (): BOOLEAN;"$(*%* Dieser Teil wird als Subroutine verwendet, um den Stackbedarf%* bei der VarExpression-Rekursion klein zu halten%*)%$VAR&highPtr, high, index, size: ExprDesc;&idxBaseType, highType, type: PtrItem;&ofs: LONGINT;&elemSize: LONGCARD;&base, min, max, lowBound, highBound: ZZ;&minOver, maxOver: BOOLEAN;&sizeIsConst, odd, longIdx: BOOLEAN;&idxIsNull, needHigh, open, longOpen: BOOLEAN;&range: ConvDesc;&endptr: ADDRESS;&highLen, n: CARDINAL;&reg: RegType; $BEGIN&PopExpr (index);&IF highPtrUsed THEN PopExpr (highPtr); reloadPtr (highPtr) END;&PopExpr (fact);&&open:= (no # 12);&highLen:= 0;&IF open THEN(longOpen:= (no = 42);(IF longOpen THEN*highLen:= 4;*highType:= CardPtr(ELSE*highLen:= 2;*highType:= SCardPtr(END&ELSIF forHIGH THEN(SyntaxError (rBdHig)&ELSIF isSS (fact) THEN(highType:= CardPtr&ELSE(highType:= IndexType (fact.item)&END;&checkAsnCompat (index, highType, range, rBdIdx);&&sizeIsConst:= TRUE;&IF open THEN(reloadPtr (fact);(type:= OpenArrayType (fact.item);(sizeIsConst:= NOT isOpenArray (type);((needHigh:= ~sizeIsConst OR forHIGH/(* wenn weitere Dims folgen, High-Zugriff fÅr Elementgrîûenbe-0* stimmung anfordern *)*OR rangeCheckActive () AND-( (index.kind#constant) OR ~nullZZ(index.exprConst.zz) );/(* wenn Index = 0, brauchen wird den High-Wert nicht prÅfen *)(IF firstOpenArray THEN*initOpenArrayAccess (fact, needHigh);*firstOpenArray:= FALSE;(END;(IF needHigh THEN*IF NOT highPtrUsed THEN,initHighExpr (fact, highPtr);,highPtrUsed:= TRUE;*END;(END;((lowBound:= toZZ (0L, FALSE);(IF longOpen THEN*highBound:= toZZ ($FFFFFFFFL, FALSE);(ELSE*IF TypeLength (type) = 1 THEN,highBound:= toZZ ($7FFFL, FALSE)*ELSE,highBound:= toZZ ($FFFFL, FALSE)*END(END;&ELSIF isSS (fact) THEN(lowBound:= toZZ (0L, FALSE);(highBound:= toZZ (Size (fact)-1L, FALSE);(type:= CharPtr;&ELSE(getBounds (IndexType (fact.item), lowBound, highBound);(type:= ElementType (fact.item)&END;&elemSize:= TypeLength (type);&&minOver:= FALSE;&maxOver:= FALSE;&&(*'* offset:= (index - lowBound) * elemSize'*) &(* ----------------------------------- *'* Range-Check fÅr 'index' durchfÅhren *'* ----------------------------------- *)&idxIsNull:= FALSE;&IF index.kind = constant THEN(idxIsNull:= nullZZ (index.exprConst.zz);(IF open THEN*IF ~idxIsNull THEN,IF rangeCheckActive () THEN.reloadPtr (fact);..(* wenn das "Ah"-Reg noch in Benutzung ist, muû es nun wieder/* auf den korrekten Wert gebracht werden, falls es wg. mehrdim./* Open Arrays fÅr die dyn. Elementgrîûenbestimmung (s.u.)/* schon fortgeschritten ist. *).adjustHighPtr (fact, highPtr);..(* Konstante mit High-Wert vergleichen *).genia (CMPI, index.exprConst.zz.l, highPtr,0);(* CMPI #idx,(An)+ *).IF sizeIsConst THEN0highPtrUsed:= FALSE;0deallocRegs (highPtr);.ELSE0INC (highPtr.stackedSize, highLen);.END;.(* wenn HIGH-Wert >= Idx, dann OK *).gen (Bcc + mapCC (ge, FALSE, FALSE) + 4);.genTrap (RangeTrap);,END*END;(ELSE*IF NOT inZZ (index.exprConst.zz, lowBound, highBound) THEN,SyntaxError (rIdxRg)*END;(END;(negZZ (lowBound);(addZZ (index.exprConst.zz, lowBound);(base:= toZZ (0, FALSE)&ELSE (* IF index.kind = constant *)((*)* 'lowBound' und 'highBound' beschreiben die)* Grenzen des Feldbereichs.)*)* 'base' dagegen enthÑlt den Offset, der vom 'index')* abgezogen werden muû, wenn auf das Element zugegriffen)* wird.)*)((*       offset:= (index - lowBound) * elemSize *)((* oder: offset:=  index * elemSize - lowBound * elemSize *)(checkBounds (index, lowBound, highBound, base);+(* korrigiert ggf. die Bounds und setzt 'base' *)(IF open THEN*IF rangeCheckActive () THEN,reloadPtr (fact);,(* Index mit High-Wert vergleichen *),,(* wenn das "Ah"-Reg noch in Benutzung ist, muû es nun wieder-* auf den korrekten Wert gebracht werden, falls es wg. mehrdim.-* Open Arrays fÅr die dyn. Elementgrîûenbestimmung (s.u.)-* schon fortgeschritten ist. *),adjustHighPtr (fact, highPtr);,,loadRegExt (index, anyCPUReg, highLen, TRUE);,genar (CMP, highPtr, index.exprReg);         (* CMP (Ah)+,Di *),IF sizeIsConst THEN.highPtrUsed:= FALSE;.deallocRegs (highPtr);,ELSE.INC (highPtr.stackedSize, highLen);,END;,(* wenn Idx <= HIGH-Wert, dann OK *),gen (Bcc + mapCC (le, FALSE, FALSE) + 4);,genTrap (RangeTrap);*END;(END;&END; (* IF index.kind = constant *)&&IF sizeIsConst & (index.kind = constant) THEN&(mulZZ (index.exprConst.zz, toZZ (elemSize, FALSE));(ofs:= intZZ (index.exprConst.zz); (endptr:= ADR (fact.exprConst.b) + 1L;(reloadPtr (fact);(IF (fact.kind = constant) OR (fact.kind = constRef) THEN*(*$? Safety: assert (ofs >= 0L);*)*extractConst (fact, ofs, elemSize);(ELSE*IF ofs # 0L THEN,addOffset (fact, ofs);,(* fact.item wird gleich sowieso neu gesetzt *)*END(END;&&ELSE (* IF sizeIsConst & (index.kind = constant) *)(((*)* es muû bestimmt werden, welchen Type der Index)* nach der Skalierung hat. Dazu wird der mîgliche)* Bereich des Index mit der Elementgrîûe multipliziert)* und daraus dann der neue Typ bestimmt.)*)* Wenn der Feldbereich ein long-Range ist, die index-)* Var aber nur Shortint, wurde bereits von 'checkBounds')* der Feldbereich entsprechend verkleinert, so daû)* dann auch die Word-Var als Index ausreicht.)*)(IF sizeIsConst THEN*min:= lowBound;*max:= highBound;*myMulZZ (min, elemSize, minOver);*myMulZZ (max, elemSize, maxOver);*getNumTypeForRange (min, max, idxBaseType);*longIdx:= longSignedType (idxBaseType);(ELSE*idxBaseType:= CardPtr; (* HIGH-Werte sind immer positiv *)*longIdx:= TRUE(END;((INC (fact.highOfs, highLen);(PushExpr (fact);(PushExpr (index);((IF sizeIsConst OR idxIsNull THEN*initExpr (size, idxBaseType, constant);*IF idxIsNull THEN elemSize:= 0 END;*size.exprConst.zz:= toZZ (elemSize, FALSE)(ELSE*(* falls mehrere offene Dimensionen noch kommen, mÅssen die+* High-Werte (plus 1) miteinander multipliziert werden, um+* die Elementgrîûe zu errechnen *)*fact.item:= type;*REPEAT,adjustHighPtr (fact, highPtr);,n:= SHORT (Size (highPtr));,(*$? Safety: assert (highPtr.kind = stack); *),copyRegExt (highPtr, high, dataRegs, 4);,INC (highPtr.stackedSize, n);,incReg (high.exprReg, toZZ (1,FALSE), 4);,IF type = fact.item THEN (* wir sind noch beim 1. High-Wert. *).size:= high,ELSE.varMul (mul, size, high, FALSE, CardPtr); (* ist immer Long-Mul *).PopExpr (size),END;,INC (fact.highOfs, n); (* "fact" ist auf ExprStack *),fact.item:= OpenArrayType (fact.item);*UNTIL NOT isOpenArray (fact.item);*elemSize:= TypeLength (fact.item)(END;((IF highPtrUsed & sizeIsConst THEN*(* den High-Ptr brauchen wir nun nicht mehr *)*highPtrUsed:= FALSE;*deallocRegs (highPtr);(END;((PopExpr (index);(reloadPtr (index);(((* nun den Index mit der Elementgrîûe multipl. *)(IF longIdx THEN n:= 4 ELSE n:= 2 END;(IF index.kind = constant THEN*mulZZ (index.exprConst.zz, toZZ (elemSize, FALSE));(ELSE*constMul (index, idxBaseType, toZZ (elemSize, FALSE),6minOver OR maxOver);(END;(IF sizeIsConst THEN (* ... dann ist 'index' nicht 'constant' *)*mulZZ (base, toZZ (elemSize, FALSE));(ELSE*(*$? Safety: assert (nullZZ (base)); *)*(* falls 'base' doch nicht immer Null ist:0(* hier sofort die 'base' vom Index abziehen *)0IF ~nullZZ (base) OR (SHORT (Size (index)) < n) THEN2negZZ (base);2loadRegExt (index, anyCPUReg, n, TRUE);2incReg (index.exprReg, base, n);0END;0base:= toZZ (0, FALSE);**)*IF index.kind = constant THEN,constMul (size, CardPtr, index.exprConst.zz,8minOver OR maxOver(*nîtig?*));,index:= size;*ELSE,IF SHORT (Size (index)) < n THEN.loadRegExt (index, anyCPUReg, n, TRUE);,END;,varMul (mul, index, size, FALSE, CardPtr);,PopExpr (index)*END(END;((PopExpr (fact);(reloadPtr (fact);((IF (fact.kind = constant) OR (fact.kind = constRef) THEN*(* Damit sind auch Indizierungen von Const. mîglich *)*makeInd0An (fact);(END;((odd:= oddAccess (fact) OR ODD (elemSize);*(* 'elemSize' ist hier die Grîûe des Typs hinter den offenen Dims,+* sie bestimmt auch beim mehrdim. Open Arrays, ob das Ganze ungerade+* sein kann. *)((IF ~idxIsNull THEN*IF indir (fact) THEN,IF SHORT (Size (index)) < n THEN.loadRegExt (index, anyCPUReg, n, TRUE),END;,addIdxReg (fact, index, longIdx, nullZZ (base));,fact.mayBeOdd:= odd*ELSE,loadAddress (fact);,IF (index.kind # register),& ( (Size (index) = 4L) OR (Size (index) = 2L) & ~longIdx ) THEN.(* wenn fact = "0(An)", dann "ADD index,An" *).genar (ADDA, index, fact.exprReg);.restoreStack (index);.deallocRegs (index);.makeIndir (fact, 0, odd),ELSE.loadRegExt (index, anyCPUReg, n, TRUE);.makeIndirIdx (fact, index.exprReg, longIdx, odd),END*END;*addDisp (fact, -intZZ (base))(END;(&END; (* IF sizeIsConst & (index.kind = constant) *)&&fact.item:= type;&&IF CurrentSymbol.itemNo # comma THEN(IF highPtrUsed THEN*DEC (fact.highOfs, INTEGER(SHORT (highPtr.stackedSize)));*(* Das muû der Aufrufer v. accessArray erledigen: deallocRegs (highPtr) *)(END;(RETURN FALSE (* Ende der Indizierung *)&END;&&no:= ItemNo (fact.item);&IF NOT (    (no = 12) (* ARRAY *)/OR (no = 42) (* OPEN LONGARRAY *)/OR (no = 32) (* OPEN ARRAY *) ) THEN(SyntaxError (rBrkXp)&END;&&PushExpr (fact);&IF highPtrUsed THEN PushExpr (highPtr) END;&&RETURN TRUE (* weiter geht's mit nÑchstem Index *)$END accessSubRoutine; "BEGIN (* accessArray *)$highPtrUsed:= FALSE;$firstOpenArray:= TRUE;$PushExpr (fact);$REPEAT&GetSymbol;&VarExpression ();$UNTIL NOT accessSubRoutine ();$GetRbrack;"END accessArray;  (*$D-*)  PROCEDURE desigAccess (VAR fact: ExprDesc; forHIGH: BOOLEAN); "VAR (*$Reg*)no: CARDINAL; type: PtrItem; (*$Reg*)ofs: LONGINT;&endptr: ADDRESS; (*$Reg*)elemSize: LONGCARD; "BEGIN$LOOP&no:= ItemNo (fact.item);&IF CurrentSymbol.itemNo = lbrack THEN(IF (no = 12) (* ARRAY *)(OR (no = 42) (* OPEN LONGARRAY *)(OR (no = 32) (* OPEN ARRAY *) THEN*accessArray (fact, no, forHIGH)(ELSE*SyntaxError (rArrXp)(END;&ELSIF CurrentSymbol.itemNo = dot THEN(IF forHIGH THEN SyntaxError (rBdHig) END;(IF no = 13 (* RECORD *) THEN*WITH fact DO,type:= LocalTree (item);,IF NOT SearchLocalItem (type) THEN SyntaxError (rIdUn) END;,ofs:= TypeLength (type);,IF (kind = constant) OR (kind = constRef) THEN.type:= RefType (type);.elemSize:= TypeLength (type);.extractConst (fact, ofs, elemSize);.item:= type,ELSE.addOffset (fact, ofs);.item:= RefType (type);,END;*END;(ELSE*SyntaxError (rRecXp)(END;(GetSymbol&ELSIF CurrentSymbol.itemNo = arrow THEN(IF forHIGH THEN SyntaxError (rBdHig) END;(deref (fact);(GetSymbol&ELSE(EXIT&END;&fact.regVar:= FALSE;$END; (* LOOP *)"END desigAccess;  PROCEDURE checkSet (VAR fact: ExprDesc);"VAR n: CARDINAL; lo, hi: ZZ;"BEGIN$n:= ItemNo (fact.item);$IF (n = 5) OR (n = 45) THEN&fact.regset:= (n = 45) OR (TypeLength (fact.item) = 1L);&getBounds (RefType (fact.item), lo, hi);&fact.zerobased:= posZZ (lo) & (cmpZZ (hi, toZZ (31L, FALSE)) # gt);&fact.typeChecked:= TRUE$END;"END checkSet;  TYPE DesigAccesses = (readDesig,  (* willBeRead *)6setDesig,   (* willBeWritten *)6modifyDesig,(* willBeWritten, willBeRead *)6varDesig,   (* might be read/written *)6typeDesig); (* no read/write *)  PROCEDURE initIndir (VAR fact: ExprDesc; ofs: LONGINT; odd: BOOLEAN);"BEGIN$initExpr (fact, RefType (CurrentSymbol.item), register);$fact.exprReg:= getLink (procDepth (Tiefe));$makeIndir (fact, ofs, odd OR ODD (ofs))"END initIndir;  PROCEDURE designator (access: DesigAccesses; loadRegToMemory: BOOLEAN;6errNo: INTEGER); "(*#* 'willBeRead': TRUE -> Wert der Var wird benîtigt (sonst wird ggf.#*  bei Reg-Vars der Wert aus dem Memory erst gar nicht geladen, z.B.#*  bei Zuweisung darauf)#* 'willBeWritten': TRUE -> Wert wird beschrieben -> damit wird dann#*  automatisch die Var. in den Initialisiert-Status versetzt.#*#* wenn 'loadRegToMemory' = TRUE, wird, wenn Var eine Reg-Var#* ist, ein Zugriff auf die Memory-Zelle vorbereitet und die Var#* darin abgelegt.#*) "VAR willBeRead, willBeWritten: BOOLEAN;  (*$D-*) "PROCEDURE getVar (VAR fact: ExprDesc);$VAR item: PtrItem; fl: IFS; reg: RegType; loadValue, accessReg: BOOLEAN;$BEGIN&item:= CurrentSymbol.item;&fl:= CurrentSymbol.flags;&&NewAccessDepth (item, Global + 1);&&accessReg:= FALSE;&loadValue:= FALSE;&&IF extVar IN fl THEN(((*$? Safety: assert (IsInMem (item));*)(initMemExpr (fact, RefType (item), extL, FALSE);(fact.extAddr:= LONGCARD (VarAddress (item));(IF ODD (LONGCARD (fact.extAddr)) THEN fact.mayBeOdd:= TRUE END(&ELSE((IF procDepth (Tiefe) # 0 THEN*IF IsRegVar (item) THEN,(* Reg-Vars nicht in lok. Procs benutzbar *),SyntaxError (rLocVa)*END;*(*$? Safety: assert (IsInMem (item));*)*loadRegToMemory:= TRUE(END;((IF willBeRead & IsDirty (item) THEN*(* Var. ist noch nicht initialisiert! *)*SyntaxError (rNoIni)(END;((IF NOT loadRegToMemory & IsRegVar (item) THEN*reg:= UsedReg (item);*IF IsInReg (item) THEN,(*$? Safety: assert (NOT (reg IN freeRegs));*),accessReg:= TRUE*ELSE,(*-* Var liegt noch im Memory - wenn ihr Reg unbelegt ist, dann-* benutzen; wenn kein Assignment, dann erst Wert aus Memory laden.-*),IF reg IN freeRegs THEN.(* Reg am Ende auf jeden Fall benutzen -> gleich reservieren *).EXCL (freeRegs, reg);.UseReg (item); (* Reg benutzen *).IF willBeRead THEN0(* ist schon oben erfolgt:4IF IsDirty (item) THEN6(* Var. ist noch nicht initialisiert! *)6SyntaxError (rNoIni)4ELSE0*)2(* zuerst auf Mem zugreifen, dann erst ins Reg laden *)2loadValue:= TRUE0(* END *).ELSE0(*~~~ das lassen wir erstmal, denn dann klappt's1*    mit deref. Pointern nicht, z.B. bei "p^:= ..."1*    wird hier vermutet, daû eine Zuweisung auf 'p'1*    erfolgt und dann wird 'p' gar nicht mehr ggf. geladen.2(* Assign -> gleich Reg benutzen *)2accessReg:= TRUE1* stattdessen:1*)0IF IsDirty (item) THEN2(* Var. ist noch nicht initialisiert! *)2accessReg:= TRUE0ELSE2(* zuerst auf Mem zugreifen, dann erst ins Reg laden *)2loadValue:= TRUE0END.END,END*END(END;((IF willBeWritten THEN*ClearDirt (item)(END;((IF accessReg THEN*initExpr (fact, RefType (item), register);*EXCL (freeRegs, reg);*UseReg (item);*fact.exprReg:= reg;(ELSE*IF global IN fl THEN,initMemExpr (fact, RefType (item), absRef, ODD (VarAddress (item))O(*$? OldByteOrder: OR TRUE *) );*ELSE,(* local *),initIndir (fact, VarAddress (item), FALSE)*END(END;((IF NOT (global IN fl) & (indirVar IN fl) THEN*(*$? Safety: assert (IsInMem (item));*),(*~~~ kînnte man auch zulassen mit ein2wenig aufwand, dann aber 'willBeRead' berÅcksichtigen*)*IF isOpenArray (fact.item) THEN,IF NOT bitInOptions (30) (* ^ *) THEN.fact.mayBeOdd:= TRUE,END*ELSE,loadIndir (fact, 0, NOT bitInOptions (30) (* ^ *))*END;(END;(&END;&&fact.varItem:= item;&fact.readOnly:= refVar IN fl;&fact.regVar:= IsRegVar (item);&&(*'* Reg-Var, falls sie noch im Mem liegt, in ihr Register laden,'* falls nicht Assignment darauf erfolgen soll.'*)&IF loadValue THEN(loadRegVar (fact, reg)&END;$END getVar;  (*$D-*) "PROCEDURE getRecElem (VAR fact: ExprDesc);$(* bei WITH-Scope *)$VAR withPtr: ExprDesc; varItem: PtrItem; ofs: LONGINT;$BEGIN&varItem:= CurrentSymbol.item;&getDisplay (Tiefe, withPtr);  (* hole WITH-Expr *)&ofs:= TypeLength (CurrentSymbol.item);&(* Record-Elems kînnen nicht in einem Reg stehen! Schon, weil gar'* kein Platz fÅr die nîtigen Informationen dazu reserviert ist. *)&IF withPtr.kind # register THEN((*$? Safety: assert (withPtr.kind = stack);*)(IF GlobalA7Hidden THEN*(*!!! das sollte mal gelîst werden.+* z.b, indem der gerettete A7 auf dem Stack in ein temp. Reg+* geladen wird (steht in 'stacks.help') *)*BadId:= 'keinen WITH-Zugriff durchfÅhren!';*SyntaxError (rTmpRs)(END;(initExpr (fact, RefType (CurrentSymbol.item), register);(fact.exprReg := A7;((*$? Safety: assert (withPtr.stackPtr # 0L);*)(makeIndir (fact, withPtr.stackPtr - A7Offset, FALSE);(loadIndir (fact, ofs, ODD (ofs));(fact.readOnly:= withPtr.readOnly;&ELSE(fact:= withPtr;(makeIndir (fact, ofs, ODD (ofs));(fact.item:= RefType (CurrentSymbol.item)&END;&fact.varItem:= 20L; (* damit ggf. Buserror ausgelîst wird *)$END getRecElem; "VAR fact: ExprDesc; newtype: PtrItem; "TYPE DAS = SET OF DesigAccesses; "BEGIN (* designator *)$willBeRead:= access IN DAS {readDesig, modifyDesig};$willBeWritten:= access IN DAS {setDesig, modifyDesig, varDesig};$IF extendedSyntax ()$AND (  (ORD (CurrentSymbol.typ) = 36) &+(StdProcNo (CurrentSymbol.item) = 104 (* CAST *) ))OR (typeDesc IN CurrentSymbol.flags) ) THEN&IF (typeDesc IN CurrentSymbol.flags) THEN((* Type-Transfer *)(newtype:= CurrentSymbol.item;(GetLparen;&ELSE((* CAST *)(GetLparen;(GetSymbol;(IF NOT (typeDesc IN CurrentSymbol.flags) THEN SyntaxError (rTyDXp) END;(newtype:= CurrentSymbol.item;(GetComma;&END;&GetSymbol;&designator (access, loadRegToMemory, errNo); (* Rekursion! *)&PopExpr (fact);&IF Size (fact) # TypeLength (newtype) THEN SyntaxError (rConv) END;&fact.item:= newtype;&checkSet (fact);&GetRparen;$ELSE&IF NOT (userDef IN CurrentSymbol.flags) THEN(SyntaxError (errNo)&ELSIF ORD (CurrentSymbol.typ) = 17 THEN(getVar (fact)&ELSIF ORD (CurrentSymbol.typ) = 14 (* Record-Elem *) THEN(getRecElem (fact)&ELSE(SyntaxError (errNo)&END;&GetSymbol;$END;$desigAccess (fact, FALSE);$checkSet (fact);$IF willBeWritten THEN&(* Abfrage muû *nach* dem desigAccess-Aufruf stehen: *)&IF (access # varDesig) OR warningsActive () THEN(IF fact.readOnly THEN SyntaxError (rRdOnl) END;&END$END;$PushExpr (fact)"END designator;  (* ----------------------------------------------------------------------- *)   PROCEDURE initProcExpr (VAR expr: ExprDesc; item: PtrItem; tiefe: CARDINAL);"BEGIN$IF global IN ItemFlag (item) THEN&initMemExpr (expr, item, immRef, FALSE);$ELSE&initMemExpr (expr, item, relConst, FALSE);&(*'*    'immRef' muû verwendet werden, weil proc in Expr als Konst.'*    angesprochen werden muû. Bei einem Aufruf sorgt 'call' dann ggf.'*    fÅr eine Wandlung nach 'absRef'.'*    Eigentlich mÅûte passend dazu auch eine Art Konstante f. relative'*    Procs eingetragen werden, damit bei einer Bestimmung der Adr.'*    der Proc dann ihre Adr. mit "LEA ofs(PC)" geladen wird. Leider'*    klappt das aber nicht, weil ja 'loadReg' dazu verwendet wird und'*    dort ein 'MOVE.L' erzeugt wÅrde, und es dafÅr keine Konst-<ea>'*    f. rel-pc gibt.'*    Deshalb wird mit der virtuellen Adressierung 'relConst' gearbeitet,'*    die dann im Falle des Ladens der Konstante Åbersetzt werden muû'*    nach 'pcRel' mit LEA. Dies kommt z.Zt. aber gar nicht vor.'*)$END;$expr.varItem:= item;$expr.tiefe:= tiefe"END initProcExpr;   TYPE RegState = RECORD2regs: RegSet;0END;  PROCEDURE SaveRegState (VAR save: RegState);"BEGIN$WITH save DO&regs:= freeRegs;$END"END SaveRegState;  PROCEDURE RestoreRegState (VAR save: RegState);"BEGIN$WITH save DO&freeRegs:= regs;$END"END RestoreRegState;  MODULE fold;  (*!* dieses lokale Modul dient ausschlieûlich dazu, die Funktion!* 'constantFold' bereitzustellen.!*) "IMPORT Operator, ExprDesc, BS, initExpr, TypeLength, BoolPtr, PtrSet,)WORD, PtrFullSet, rOpTyp, SyntaxError, inZZ, ItemNo, PushExpr,)SuppressCode, toZZ, addZZ, subZZ, divZZ, mulZZ, modZZ, ExprKind,)cutConst, Size, dropConstantFromTree, OpSet, CodePtr, SetCodePtr,)getBounds, RefType, ZZ, nullZZ, posZZ, cmpZZ, lrToSys, srToDest,)ItemSet, srToSys, lrToDest, Safety, FoldingConst, expandToZZ,)reduceConstant, ADDRESS, ADR, CompileWithOldCompiler, assert;  "EXPORT constantFold;  "TYPE SetOp = PROCEDURE (VAR BS, BS, BS); "VAR true: BOOLEAN;&dest: ExprDesc; "PROCEDURE setAnd (VAR d: BS; l, r: BS);$BEGIN&d:= l * r;$END setAnd; "PROCEDURE setOr (VAR d: BS; l, r: BS);$BEGIN&d:= l + r;$END setOr; "PROCEDURE setXOr (VAR d: BS; l, r: BS);$BEGIN&d:= l / r;$END setXOr; "PROCEDURE setDiff (VAR d: BS; l, r: BS);$BEGIN&d:= l - r;$END setDiff; "PROCEDURE setEq (VAR d: BS; l, r: BS);$BEGIN&true:= true AND (l = r)$END setEq; "PROCEDURE setLe (VAR d: BS; l, r: BS);$BEGIN&true:= true AND (l <= r)$END setLe; "PROCEDURE setGe (VAR d: BS; l, r: BS);$BEGIN&true:= true AND (l >= r)$END setGe; "PROCEDURE constantFold (op: Operator; VAR left, right: ExprDesc); $PROCEDURE bigOp (op: SetOp);&VAR i: CARDINAL; destSet, leftSet, rightSet: PtrSet;&BEGIN(destSet:= dest.constAddr + dest.constOfs;(leftSet:= left.constAddr + left.constOfs;(rightSet:= right.constAddr + right.constOfs;(IF NOT SuppressCode THEN*FOR i:= 0 TO SHORT (TypeLength (left.item)) - 1 DO,op (destSet^, leftSet^, rightSet^);,INC (destSet);,INC (leftSet);,INC (rightSet)*END(END&END bigOp; $PROCEDURE makeBool (true: BOOLEAN);&BEGIN(initExpr (dest, BoolPtr, constant);(dest.exprConst.w:= WORD (true)&END makeBool; $PROCEDURE inSet (setaddr: ADDRESS);&VAR rightSet: PtrSet; n: CARDINAL; lo, hi: ZZ;&BEGIN(getBounds (RefType (right.item), lo, hi);(IF NOT SuppressCode & inZZ (left.exprConst.zz, lo, hi) THEN*(*$? Safety: assert (right.typeChecked);*)*IF NOT right.zerobased THEN,subZZ (left.exprConst.zz, lo);*END;*n:= left.exprConst.zz.c DIV 8;*IF right.regset THEN,n:= SHORT (Size (right)) - 1 - n*END;*rightSet:= setaddr + LONG (n);*makeBool (left.exprConst.zz.c MOD 8 IN rightSet^)(ELSE*makeBool (FALSE)(END&END inSet; $VAR r1, r2: LONGREAL; s1, s2: REAL; itemNo: CARDINAL;(rightIsLast: BOOLEAN; $BEGIN (* constantFold *)&FoldingConst:= TRUE;&itemNo:= ItemNo (right.item);&CASE itemNo OF&| 5, 45: (* SET *)*IF right.kind = constRef THEN,(* zuerst einmal beide Konstanten in DATA-Puffer *-* legen, weil Reihenfolge im Tree anders ist.   *),IF op # in THEN.(*$? Safety: assert (left.kind = constRef); *).IF left.constHead = NIL THEN dropConstantFromTree (left) END;,END;,IF right.constHead = NIL THEN dropConstantFromTree (right) END;,(* Es kann nun sein, daû 'right' vor 'left' im Speicher liegt.-* Das passiert, wenn 'right' eine anonyme Konst und 'left' eine-* aus dem Tree ist. Aus diesem Grund muû immer der im DATA-Puffer-* zuerst kommende Wert als 'dest' verwendet werden. *),rightIsLast:= right.constHead > left.constHead;,IF rightIsLast THEN dest:= left; ELSE dest:= right; END;,CASE op OF,| mul: bigOp (setAnd);,| rdiv:bigOp (setXOr);,| add: bigOp (setOr);,| sub: bigOp (setDiff);,| eq,.ne:  true:= TRUE;3bigOp (setEq);3IF op = ne THEN true:= NOT true END;3makeBool (true);,| le:  true:= TRUE;3bigOp (setLe);3makeBool (true);,| ge:  true:= TRUE;3bigOp (setGe);3makeBool (true);,| in:  inSet (right.constAddr + right.constOfs),ELSE.SyntaxError (rOpTyp),END;,IF rightIsLast THEN.cutConst (left);.IF op # in THEN cutConst (right) END,ELSE.cutConst (right);.IF op # in THEN cutConst (left) END,END;,IF dest.constOfs # 0 THEN reduceConstant (dest); END;*ELSE (* IF right.kind = constRef... *),(*$? Safety: assert (left.kind = constant); *),dest:= left;,CASE op OF,| add:  dest.exprConst.ws:= left.exprConst.ws + right.exprConst.ws,| sub:  dest.exprConst.ws:= left.exprConst.ws - right.exprConst.ws,| mul:  dest.exprConst.ws:= left.exprConst.ws * right.exprConst.ws,| rdiv: dest.exprConst.ws:= left.exprConst.ws / right.exprConst.ws,| in:   inSet (ADR (right.exprConst.b)+1L - Size(right));,| eq:   makeBool (left.exprConst.ws =  right.exprConst.ws),| ne:   makeBool (left.exprConst.ws #  right.exprConst.ws),| ge:   makeBool (left.exprConst.ws >= right.exprConst.ws),| le:   makeBool (left.exprConst.ws <= right.exprConst.ws),ELSE.SyntaxError (rOpTyp),END*END;*PushExpr (dest)&| 2: (* RR/LONGREAL *)*dest:= left;*r1:= lrToSys (left.exprConst.rr);*r2:= lrToSys (right.exprConst.rr);*CASE op OF*| add:  r1:= r1 + r2*| sub:  r1:= r1 - r2*| mul:  r1:= r1 * r2*| rdiv: r1:= r1 / r2*| eq:   makeBool (r1 = r2)*| ne:   makeBool (r1 # r2)*| ge:   makeBool (r1 >= r2)*| le:   makeBool (r1 <= r2)*| gt:   makeBool (r1 > r2)*| lt:   makeBool (r1 < r2)*ELSE,SyntaxError (rOpTyp)*END;*IF op < eq THEN,dest.exprConst.rr:= lrToDest (r1);*END;*PushExpr (dest)&| 40: (* REAL *)*dest:= left;*s1:= srToSys (left.exprConst.sr);*s2:= srToSys (right.exprConst.sr);*CASE op OF*| add:  s1:= s1 + s2*| sub:  s1:= s1 - s2*| mul:  s1:= s1 * s2*| rdiv: s1:= s1 / s2*| eq:   makeBool (s1 = s2)*| ne:   makeBool (s1 # s2)*| ge:   makeBool (s1 >= s2)*| le:   makeBool (s1 <= s2)*| gt:   makeBool (s1 > s2)*| lt:   makeBool (s1 < s2)*ELSE,SyntaxError (rOpTyp)*END;*IF op < eq THEN,dest.exprConst.sr:= srToDest (s1);*END;*PushExpr (dest)&| 1,22,30,4,  (* 32 Bit INTEGER/CARDINAL/BOTH/ZZ *)(23, 20,     (* ADDRESS, Pointer *)(33, 34, 35, (* 16 Bit INTEGER/CARDINAL *)(3, 24, 9:   (* CHAR, BOOLEAN, Enum *)*(*!!! mÅssten hier nicht alle skalaren erlaubt sein und dann+*    nur, wie bei relops mit vars, bestimmte typen nur auf '#' & '='+*    zulassen?!+* >>> folgende Abfrage ist sicher noch nicht vollstÑndig!+*    besser: Tabelle verwenden, damit auch ADDRESS+ADDRESS,+*    aber nicht ADDRESS=ADDRESS und nicht ADDRESS+LONGCARD+*    verboten werden! *)*IF (itemNo IN ItemSet {3,24,9}) & (op IN OpSet {add,sub,mul,div,mod})*OR (itemNo = 20) & NOT (op IN OpSet {eq, ne}) THEN,SyntaxError (rOpTyp)*END;*(* Werte zu ZZ-Typen erweitern, damit 'over'-Flag stimmt *)*expandToZZ (itemNo, left.exprConst.zz);*expandToZZ (itemNo, right.exprConst.zz);*CASE op OF*| add:  addZZ (left.exprConst.zz, right.exprConst.zz)*| sub:  subZZ (left.exprConst.zz, right.exprConst.zz)*| mul:  mulZZ (left.exprConst.zz, right.exprConst.zz)*| div:  divZZ (left.exprConst.zz, right.exprConst.zz)*| mod:  modZZ (left.exprConst.zz, right.exprConst.zz)*| eq, ne, ge, le, gt, lt:,subZZ (left.exprConst.zz, right.exprConst.zz);,WITH left.exprConst DO.CASE op OF.| eq: makeBool (nullZZ (zz)).| ne: makeBool (NOT nullZZ (zz)).| ge: makeBool (posZZ (zz)).| lt: makeBool (NOT posZZ (zz)).| le: makeBool (nullZZ (zz) OR NOT posZZ (zz)).| gt: makeBool (NOT nullZZ (zz) & posZZ (zz)).END,END;,left:= dest*ELSE,SyntaxError (rOpTyp)*END;*PushExpr (left)&ELSE*SyntaxError (rOpTyp)&END;&FoldingConst:= FALSE;$END constantFold; "END fold;   (* ----------------------------------------------------------------------- *)  PROCEDURE checkDivisor (VAR expr: ExprDesc);"BEGIN$IF expr.kind = constant THEN&IF nullZZ (expr.exprConst.zz) THEN SyntaxError (rDvNul) END$ELSE&IF rangeCheckActive () THEN(IF (expr.kind = register) & (expr.exprReg IN anyDataReg) THEN*(* TST expr, um Flags zu setzen *)*gena (TST, expr, 0)(ELSE*loadReg (expr, anyDataReg);(END;(gen (Bcc + mapCC (ne, FALSE, FALSE) + 4);(genTrap (DivByZeroTrap)&END$END"END checkDivisor;" PROCEDURE varMul (op: Operator; left, right: ExprDesc;2chkOver: BOOLEAN; resultType: PtrItem); "PROCEDURE opWTo (op: Operator; VAR left, right: ExprDesc);$VAR opcode: CARDINAL; signed: BOOLEAN;$BEGIN&signed:= signedType (resultType);&IF op = mul THEN(IF inDataReg (right) THEN swapExpr (right, left) END;(IF signed THEN opcode:= MULS ELSE opcode:= MULU END;(loadReg (left, dataRegs)&ELSE(IF signed THEN opcode:= DIVS ELSE opcode:= DIVU END;(checkDivisor (right);(loadRegExt (left, dataRegs, 4, FALSE)&END;&noDataAccess (right);&genar (opcode, right, left.exprReg);&restoreStack (right);&IF (op = mul) & chkOver THEN checkMulOverflow (left) END;&IF op = mod THEN genr (SWAP, left.exprReg) END;&deallocRegs (right);&left.item:= resultType;&PushExpr (left)$END opWTo;""PROCEDURE opLTo (op: Operator; VAR left, right: ExprDesc);$VAR pn: CARDINAL; r2: RegType; signed: BOOLEAN; regs: RegSet;$BEGIN&signed:= signedType (resultType);&IF op = mul THEN(IF signed THEN pn:= IMLL ELSE pn:= CMLL END&ELSIF op = div THEN(IF signed THEN pn:= IDVL ELSE pn:= CDVL END&ELSIF op = mod THEN(IF signed THEN pn:= IMDL ELSE pn:= CMDL END&ELSE(SyntaxError (rOpTyp)&END;&runtimeVarMul (left, right, op = mul, pn);&IF (op = mul) & chkOver THEN checkOverflow (resultType) END;&left.item:= resultType;&PushExpr (left)$END opLTo; "BEGIN$(*$? Safety: assert (Size (left) = Size (right));*)$IF isReal (resultType) THEN&realOp (op, right, left)$ELSIF (TypeLength (resultType) = 2L) THEN&(*$? Safety: assert ((Size (left) = 2L));*)&opWTo (op, left, right)$ELSE&(*$? Safety: assert (Size (right) = 4L);*)&opLTo (op, left, right)$END"END varMul;   PROCEDURE funcCall;"VAR leftOnA3: LONGCARD; type: PtrItem; fact: ExprDesc;&rtnRegNo: RegType; cdecl, rtnReg: BOOLEAN;"BEGIN$IF InConstExpr THEN SyntaxError (rConXp) END;$LookExpr (fact);$type:= fact.item;$IF NOT isProc (type) THEN SyntaxError (rNoPrc) END;$IF ItemNo (type) = 44 THEN&(* bei Aufruf einer Proc m. Frame-Ptr muû der Ptr auf die Parm-Kette'* erst geholt werden *)&type:= RefType (type)$END;$cdecl:= parmA7 IN ItemFlag (type);$rtnReg:= rtnD0 IN ItemFlag (type);$type:= ElementType (type);$IF type = NIL (* Proc, keine Funktion *) THEN SyntaxError (rNotFn) END;$IF ItemNo (type) = 0 (* zeigt auf Relay *) THEN SyntaxError (rBdRtn) END;$rtnRegNo:= D0;$IF cdecl THEN&IF (TypeLength (type) > 4)&OR (ItemNo (type) IN ItemSet {12,13} (* RECORD, ARRAY *)) THEN((* Return-Wert ist zu groû fÅr Register. Deshalb wird nun auf dem)* A7-Stack der Platz dafÅr reserviert und 'call' Åbermittelt, daû)* nach Laden aller Parms ein Ptr auf diese Stack-Adr. noch auf den)* A7 muû. *)(initStackExpr (fact, type, A7);(WITH fact DO*up:= TRUE;*stackedSize:= roundedUp (TypeLength (type));*incReg (A7, toZZ (-INT(stackedSize), TRUE), 4);(END;(rtnReg:= FALSE&ELSE((* RÅckgabe erfolgt in Register *)(IF rtnReg THEN*(* TC-RÅckgabe: Pointer/Proc-Types/Opaques nach A0 *)*IF ItemNo (type) IN ItemSet {19,20,23,8,25} THEN,rtnRegNo:= A0*END(END;(rtnReg:= TRUE&END$END;$call (leftOnA3, cdecl & ~rtnReg, A7Offset);$IF rtnReg THEN&(*$? Safety: assert ((leftOnA3 = 0L) & (TypeLength (type) <= 4L));*)&initExpr (fact, type, register);&fact.exprReg:= allocReg (RegSet {rtnRegNo})$ELSIF NOT cdecl THEN&initStackExpr (fact, type, A3);&fact.up:= FALSE;&fact.stackedSize:= roundedUp (TypeLength (type));&fact.restoreAfterUse:= leftOnA3;&INC (A3Offset, fact.stackedSize);$END;$checkSet (fact);$PushExpr (fact);"END funcCall;  PROCEDURE shiftOrRotate (rotate, shiftUp: BOOLEAN;9VAR expr, dest: ExprDesc);"VAR opcode: CARDINAL;"BEGIN$IF rotate THEN&IF shiftUp THEN opcode:= ROLI ELSE opcode:= RORI END$ELSE&IF shiftUp THEN opcode:= LSLI ELSE opcode:= LSRI END$END;$(*$? Safety: assert (expr.kind = constant);*)$IF expr.exprConst.zz.c > 8 THEN&(* Shift-Weite > 8, dann Weite ins Reg laden *)&loadReg (expr, dataRegs);&getDestReg (expr.exprReg, opcode);&INC (opcode, $20) (* LSR # -> LSR Dn *)$ELSE&(* Shiftweite setzen *)&INC (opcode, $200 * (expr.exprConst.zz.c MOD 8));$END;$getSizeAt6 (Size (dest), opcode);$genr (opcode, dest.exprReg);"END shiftOrRotate;  (* ----------------------------------------------------------------------- *)  FORWARD loadOnA3 (VAR expr: ExprDesc; range: ConvDesc); FORWARD hdlCall (mode: CARDINAL; type: PtrItem);  PROCEDURE hdlSetConstructor (type: PtrItem);"(*#* SET-Erzeugung.#*#* Ist das Set > 16 Byte, wird Platz im Code reserviert und dieser#* gelîscht, sonst wird's im ExprDesc angelegt. Sodann werden alle#* Const-Elemente im Set gesetzt.#* Kommen Vars vor, wird bei der ersten Var. das Set auf den A3 bzw.#* in ein Reg geladen und bei A3 wird ein Hilfs-Ptr zum Zugriff#* vorbereitet. Dann werden die Vars wie bei INCL die Bits im Reg/Speicher#* setzen.#*)"VAR base: PtrItem;&lbl: Label;&size: CARDINAL;&elem1, elem2, set: ExprDesc;&setAddr: ADDRESS;&dropped, const: BOOLEAN;&n: CARDINAL;&lo, hi: ZZ;&r2, r: RegType;&"PROCEDURE loadSet;$VAR r: RegType;$BEGIN&IF (size = 1) OR set.regset THEN(loadReg (set, dataRegs)&ELSE(r:= allocReg (RegSet{A0}); (* 'A0' ist f. 'runtimeRangeSet' nîtig *)(genMOVErr (A3, r, 4);(loadOnA3 (set, alwaysFitting (type)); (* gen. ggf. CLR-Loop *)(initMemExpr (set, set.item, d16An, FALSE);(checkSet (set);(set.baseReg:= r;((* 'set' zeigt nun mit (An) in den Speicher *)&END;$END loadSet;""PROCEDURE get (VAR elem: ExprDesc);$VAR range: ConvDesc;$BEGIN&VarExpression ();&PopExpr (elem);&IF elem.kind # constant THEN(IF const THEN*loadSet;*const:= FALSE(END;&END;&checkAsnCompat (elem, base, range, rBdTyp);&fitValue (elem, range);$END get;""PROCEDURE setConst (c: CARDINAL);$VAR n: CARDINAL;(pbs: POINTER TO SET OF [0..7];$BEGIN&n:= c DIV 8;&IF set.regset THEN n:= size - 1 - n END;&pbs:= setAddr + LONG (n);&INCL (pbs^, c MOD 8)$END setConst;""BEGIN$base:= RefType (type);$size:= SHORT (TypeLength (type));$$initExpr (set, type, constant);$IF size > constBufSize THEN&(* Konst. wird im Data-Puffer angelegt. *)&dropNewConstant (ADR(Accu)(*dummy-Adr*), size, set); (* Platz reservieren *)&setAddr:= set.constAddr;&Clear (setAddr, size);&dropped:= TRUE$ELSE&setAddr:= ADR (set.exprConst.b)+1L - LONG (size);&dropped:= FALSE$END;$checkSet (set);$$const:= TRUE;$GetSymbol;$IF CurrentSymbol.itemNo # rbrace THEN&LOOP(get (elem1);(getBounds (base, lo, hi);((IF CurrentSymbol.itemNo = dblpoint THEN**GetSymbol;*get (elem2);**IF set.kind # register THEN,IF (elem1.kind = constant) & (elem2.kind = constant),& (const OR dropped) THEN.IF NOT set.zerobased THEN0subZZ (elem1.exprConst.zz, lo);0subZZ (elem2.exprConst.zz, lo).END;.FOR n:= elem1.exprConst.zz.c TO elem2.exprConst.zz.c DO0setConst (n).END;,ELSE.(* wir haben ein groûes Set - Bits durch Runtime setzen *).runtimeRangeSet (elem1, elem2, set, lo);,END;,deallocRegs (elem2);,deallocRegs (elem1);*ELSE,loadReg (elem2, anyDataReg);,loadReg (elem1, anyDataReg);,(* prÅfen, ob lo <= hi: sonst keine Bits setzen *),genar (CMP, elem1, elem2.exprReg);,genbccs (mapCC (cc, FALSE, TRUE), lbl);,IF NOT set.zerobased THEN.negZZ (lo);.loadReg (elem2, dataRegs);.loadReg (elem1, dataRegs);.incReg (elem2.exprReg, lo, 2);.incReg (elem1.exprReg, lo, 2),END;,PushExpr (set);,r2:= allocReg (dataRegs);,genMOVErr (elem2.exprReg, r2, 2);,incReg (r2, toZZ (1L, FALSE), 2);,genar (SUB, elem1, elem2.exprReg);,deallocRegs (elem1);,IF size = 1 THEN.hi:= toZZ ($80L,FALSE),ELSIF size = 2 THEN.hi:= toZZ ($8000L,FALSE),ELSE.hi:= toZZ ($80000000,FALSE),END;,r:= allocReg (dataRegs);,genMOVEir (hi, size, r);,gen (ASR + $200*elem2.exprReg + sizeAt6 (size) + r);,gen (ROL + $200*r2 + sizeAt6 (size) + r);,deallocReg (r2);,PopExpr (set);,deallocRegs (elem2);,loadReg (set, anyDataReg);,genra (OR_, r, set);  (* OR r,set.exprReg *),deallocReg (r);,ToHere (lbl)*END*(ELSE (* IF CurrentSymbol.itemNo = dblpoint ... *)**IF set.kind = register THEN,IF elem1.kind = constant THEN.(* wenn Set ins Reg geladen wurde, dann muû nun jedes Elem/* einzeln mit BSET # gesetzt werden *).IF NOT set.zerobased THEN subZZ (elem1.exprConst.zz, lo) END;.genia (BSETI, elem1.exprConst.zz.c, set, -1);,ELSE.loadReg (elem1, anyDataReg);.IF NOT set.zerobased THEN0negZZ (lo);0loadReg (elem1, dataRegs);0incReg (elem1.exprReg, lo, 2).END;.genar (BSET, set, elem1.exprReg);,END*ELSIF const THEN,IF NOT set.zerobased THEN subZZ (elem1.exprConst.zz, lo) END;,setConst (elem1.exprConst.zz.c);*ELSE,runtimeElemSet (elem1, set, add, lo);,(*$? Safety: assert (set.kind = register);*),changeToIndir (set, set.exprReg);*END;*deallocRegs (elem1);*(END;((IF CurrentSymbol.itemNo = rbrace THEN EXIT END;(IF CurrentSymbol.itemNo # comma THEN SyntaxError (rBrcXp) END;(GetSymbol;&END;$END;$$IF NOT const AND (set.kind # register) THEN&(* wir hatten (A0)-Adressierung. Nun wieder als (A3)-Stack definiern*)&(*$? Safety: assert (set.kind = memory);*)&deallocRegs (set);&changeToStack (set);&WITH set DO(stackReg:= A3;(up:= FALSE;(stackedSize:= size&END$END;$PushExpr (set)"END hdlSetConstructor;  PROCEDURE handleDebug (VAR expr: ExprDesc);""VAR$dest, help: ExprDesc;$l, oldOffs: LONGINT;$resultType: PtrItem;""PROCEDURE pushExpr (ref: BOOLEAN);$VAR keep: BOOLEAN;(savedState: RegState;$BEGIN&keep:= FALSE;&WITH expr DO(IF (kind = stack) & (stackReg = A3) THEN*(* 'loadOnA3' kopiert nicht, wenn Datum schon auf Stack steht *)*help:= expr;*WITH help DO,l:= stackedSize;,changeToIndir (help, stackReg);,disp:= -l*END;*IF item = RealPtr THEN,(* Wenn Datum grîûer als 4 Byte (LONGREAL), dann kann allerdings-* auch nicht mit loadOnA3 gearbeitet werden, ohne ein Zusatz-Reg-* zu verwenden. Daher wird in diesem Fall eine Sonderbehandlung-* gemacht: 2 mal MOVE.L -8(A3),(A3)+ *),expr.up:= TRUE;,genMOVEaa (help, expr, 4); (* MOVE.L -8(A3),(A3)+ *),genMOVEaa (help, expr, 4); (* MOVE.L -8(A3),(A3)+ *),expr.up:= FALSE;,RETURN*END;(ELSIF (kind # constant)(AND ( (kind # memory) OR (mode # immRef) )(AND (kind # register) THEN*copyRef (expr, help);(ELSE*help:= expr;*reduceZZ (help);*keep:= TRUE;     (* Register nicht freigeben! *)(END;&END;&SaveRegState (savedState);&IF ref THEN loadAddress (help) END;&loadOnA3 (help, alwaysFitting (help.item));&IF keep THEN RestoreRegState (savedState) END;$END pushExpr; "BEGIN$(*%* Debug-Information ablegen.%* Das wird nu so kodiert:%*  Expr als Value-Parm auf A3-Stack%*    (bei Strings wird lediglich Pointer und High-Wert Åbergeben)%*  TRAP #5%*  DC.W  Item-No  (nur Scalare, Reals & Strings)%*)$WITH expr DO&IF (scalar IN ItemFlag (item))&OR isReal (item)&OR isStringVar (item)&OR (ItemNo (item) = 32) & (ItemNo (OpenArrayType (item)) = 3) THEN(oldOffs:= A3Offset;(IF isStringVar (item)(OR (ItemNo (item) = 32) & (ItemNo (OpenArrayType (item)) = 3) THEN*resultType:= HostType (item);*IF ItemNo (item) = 32 THEN (* ARRAY OF CHAR *),initStackExpr (dest, NIL, A3);,copyRef (expr, help);,changeToStack (help);,copy (help, dest, 6, FALSE);,deallocRegs (help)*ELSE                            (* String-Var *),pushExpr (TRUE);,initConstExpr (help, 2, toZZ (TypeLength (resultType)-1L, FALSE));,loadOnA3 (help, alwaysFitting (help.item));*END;*gen (TRAP + DebugTrapNo);*gen (CARDINAL(27));(ELSE*pushExpr (FALSE);*gen (TRAP + DebugTrapNo);*gen (ItemNo (HostType (help.item)));(END;(A3Offset:= oldOffs;&END;$END;"END handleDebug;  PROCEDURE expression (condJmp: BOOLEAN;6VAR false, true, falseNot, trueNot: Labels);"(*#* Beim Aufruf mÅssen alle sonstigen ExprDesc auf dem Stack stehen, da#* sonst der Spill-Mechanismus nicht funktionieren kann!#*) "(*#*  condJmp: TRUE -> Gen. Bcc.W zu false/true-Targets, welche dann vom#*    Aufrufer deklariert werden, trueNot wird nicht benutzt.#*  false/true/trueNot werden auch bei BOOLEAN-Expressions verwendet,#*  wenn condJmp FALSE ist. Dann steht 'true' fÅr das Label, an dem der Wert#*  TRUE oder FALSE korrekt im Register steht, falls 'trueNot' Referenzen#*  enthÑlt, steht dort der invertierte Wert im Register, es muû also#*  noch ein NOT (EORI #1,Dn) generiert werden. Der Wert 'not' der Expr#*  zeigt an, ob die noch ungelîste Expr auch invertiert werden muû.#*)  "PROCEDURE setOp (op: Operator; VAR left, right: ExprDesc; type: PtrItem);$VAR opcode: CARDINAL; size: CARDINAL;(leftOnA3, rightOnA3, destOnA3: BOOLEAN;$BEGIN&size:= SHORT (TypeLength (type));&(*$? Safety: assert (left.typeChecked);*)&IF left.regset THEN(prepareStackForLoad (right);(IF bothOnStack (left, right) THEN*loadReg (right, dataRegs);*restoreStack (right);(END;(reloadPtr (left);(prepareStackForLoad (left);((CASE op OF(| le,*sub: loadReg (right, dataRegs);/restoreStack (right);/gena (NOT_, right, 0);/noDataAccess (left);/opcode:= AND_(| ge:  loadReg (left, dataRegs);/restoreStack (left);/gena (NOT_, left, 0);/swapExpr (left, right);/noDataAccess (left);/opcode:= AND_(| eq,*ne:  opcode:= CMP(| add: noDataAccess (left);/opcode:= OR_(| mul: noDataAccess (left);/opcode:= AND_(| rdiv:(*~~~ EORI bei const mîglich *)/loadReg (left, dataRegs);/opcode:= EOR(ELSE*SyntaxError (rOpTyp)(END;(loadReg (right, dataRegs);(restoreStack (right);(genar (opcode, left, right.exprReg);(IF opcode = EOR THEN*(*+* Die Ops mÅssen vertauscht werden, weil das Ziel bei EOR+* in den Bits 0..5, das Source-Reg in 9..11 liegt!+*)*swapExpr (left, right);(END;(restoreStack (left);(deallocRegs (left);((IF op IN OpSet {eq, ne, le, ge} THEN*deallocRegs (right);*WITH right DO,item:= BoolPtr;,kind:= condFlags;,fpuFlags:= FALSE;,relOp:= eq;,signed:= FALSE;,not:= (op = ne)*END(ELSE*right.item:= type(END;(PushExpr (right) &ELSE (CASE op OF(| add: opcode:= SSUM;(| sub: opcode:= SDIF;(| mul: opcode:= SAND;(| rdiv:opcode:= SXOR;(| le, ge, eq, ne: (* nix *)(ELSE*SyntaxError (rOpTyp)(END;((*)* Die Daten in 'left' und 'right' kînnen auf dem A3-Stack stehen.)*)* Bei den nicht-rel-Operationen muû auch das Ergebnis dorthin.)* Daher sind dann verschiedene FÑlle zu berÅcksichtigen:)* - beide Daten stehen nicht auf dem Eval-Stack;)* - das rechte Datum steht auf A3, das linke aber nicht;)* - das linke Datum steht auf A3. Wenn auch das rechte dort steht,)*   wird es einfach abgerÑumt.)* FÅr diese drei FÑlle existieren verschiedene Runtime-Funktionen)* (bei '+', '-', '*' und '/').)*)* Bei den Relations-Ops wird der A3-Stack immer abgerÑumt, es muû nur)* darauf geachtet werden, daû, wenn beide Werte auf dem A3 stehen,)* der Stack in der richtigen Reihenfolge abgerÑumt wird.)*)((leftOnA3:= (left.kind = stack);(rightOnA3:= (right.kind = stack);((*$? Safety:(IF leftOnA3 THEN assert (left.stackReg = A3) END;(IF rightOnA3 THEN assert (right.stackReg = A3) END;(*)(reloadPtr (left);((IF op IN OpSet {add, sub, mul, rdiv} THEN*IF rightOnA3 THEN,IF leftOnA3 THEN.incReg (A3, toZZ (LONG (-INTEGER (size)), TRUE), 4);.changeStackToIndir (right),ELSE.INC (opcode, 4);.changeStackToIndir (right);.right.disp:= -INTEGER(size),END*END;*IF leftOnA3 THEN,INC (opcode, 8);,changeStackToIndir (left);,left.disp:= -INTEGER(size)*ELSIF NOT rightOnA3 THEN,(* A3 korrigieren, denn die Routinen kopieren das Erg. aufn Stack *),updateStackOffsets (A3, TRUE, size)*END;*runtimeSetOp (left, right, mul, size DIV 2, opcode);*deallocRegs (left);*initStackExpr (left, type, A3);*checkSet (left);*left.up:= FALSE;*left.stackedSize:= size;(ELSE*IF leftOnA3 OR rightOnA3 THEN,incReg (A3,4toZZ (LONG (-INTEGER (:size * (ORD (leftOnA3) + ORD (rightOnA3))  )), TRUE),44);,IF leftOnA3 THEN.changeStackToIndir (left);,END;,IF rightOnA3 THEN.IF leftOnA3 THEN0changeStackToIndir (right);0right.disp:= size.ELSE0changeStackToIndir (right);.END,END*END;*IF op IN OpSet {eq, ne} THEN,runtimeSetOp (left, right, eq, size DIV 2, SEQU)*ELSE,IF op = ge THEN swapExpr (left, right) END;,runtimeSetOp (left, right, le, size DIV 2, SLEQ)*END;*deallocRegs (left);*WITH left DO,item:= BoolPtr;,kind:= condFlags;,fpuFlags:= FALSE;,relOp:= eq;,signed:= FALSE;,not:= (op = ne)*END(END;(PushExpr (left) &END;$END setOp;   "PROCEDURE factor (); $$PROCEDURE cast (VAR source: ExprDesc; destType: PtrItem);&(*'* Wenn 'source' ein Signed Type ist'* und ein expand nîtig ist, wird das Vorzeichen mit erweitert!'* String-Consts werden korrekt auf die Dest-LÑnge erweitert,'* ggf. sogar verkÅrzt.'* Ansonsten kînnen nur unstrukturierte (skalare) Typen oder'* solche mit identischer LÑnge gecastet werden.'*)&VAR sourceSize, destSize, sourceType: LONGCARD;&BEGIN((*$D-*)(reduceZZ (source);(sourceSize:= Size (source);(destSize:= TypeLength (destType);(sourceType:= HostType (source.item);(IF (sourceSize <= 4L)(AND (destSize <= 4L)(AND (   (ItemNo (sourceType) IN2ItemSet {1,3,8,9,21,22,24,25,26,30,33,34,35,4,38,39,41})-OR (ItemNo (destType) IN2ItemSet {1,3,8,9,21,22,24,25,26,30,33,34,35,4,38,39,41}) ) THEN*(* dies sind alles Zahltypen, so daû die Werte immer+* rechtsbÅndig sind. Entsprechend wird auch gecastet *)*IF source.kind = constant THEN,(* unbenutze Upper-Bytes des ZZ-Feldes auf Null setzen *),cutZZ (source.exprConst.zz, SHORT (destSize));*ELSIF sourceSize # destSize THEN,IF sourceSize < destSize THEN.loadRegExt (source, anyCPUReg, SHORT (destSize), FALSE),ELSE.loadReg (source, anyDataReg),END*END(ELSIF sourceSize # destSize THEN*IF isSS (source) & isStringVar (destType) THEN,terminateStringConst (source, destType);,adaptStringConst (source, destType);*ELSIF (ItemNo (sourceType) = 44) & (ItemNo (destType) = 19) THEN,(* nix weiter tun. es wird einfach das untere longword genommen *)*ELSE,SyntaxError (rCast)*END(END;((*$D-*)(source.item:= destType&END cast; $PROCEDURE stdFunction;&&VAR expr: ExprDesc;*nsize: NumberSize; ntype: NumberType;*range: ConvDesc;*type: PtrItem;*itemNo, n: CARDINAL;*mask, elems: LONGCARD;*lo, hi: ZZ;*last: BOOLEAN;*pc: POINTER TO CHAR; &PROCEDURE safeConversion (VAR expr: ExprDesc; destType: PtrItem);((TYPE kinds = (wholeNumber, realNumber, noNumber);((PROCEDURE getKind (t: PtrItem;:VAR ns: NumberSize; VAR nt: NumberType; VAR k: kinds);*BEGIN,IF isNumber (t, ns, nt) THEN.IF nt = realType THEN0k:= realNumber.ELSE0k:= wholeNumber.END,ELSE.k:= noNumber,END*END getKind;*(VAR sourceType: PtrItem;,source, dest: kinds;,const: BOOLEAN;,dNumSize, sNumSize: NumberSize;,dNumType, sNumType: NumberType; (PROCEDURE convertScalar;*VAR range: ConvDesc;*BEGIN,getConversionDesc (sourceType, destType, range);,fitValue (expr, range)*END convertScalar; (PROCEDURE getSourceType;*BEGIN,sourceType:= HostType (expr.item);,getKind (sourceType, sNumSize, sNumType, source);*END getSourceType; (BEGIN*adaptSSToChar (expr);*reduceZZ (expr);*IF expr.item # destType THEN,const:= expr.kind = constant;,getSourceType;,getKind (destType, dNumSize, dNumType, dest);,IF source = realNumber THEN.IF dest = noNumber THEN SyntaxError (rNoCnv) END;.IF dest = wholeNumber THEN0(* Real nach LONGCARD/LONGINT konvertieren.1* Dann weiter wie bei Conv. from LONGCARD/LONGINT *)0(*$? CompileWithNewCompiler:0IF const THEN2WITH expr.exprConst DO4IF sNumSize = real4 THEN6IF dNumType = cardType THEN8l:= LONGWORD (VAL (LONGCARD, srToSys (sr)))6ELSE8l:= LONGWORD (VAL (LONGINT, srToSys (sr)))6END;4ELSE6IF dNumType = cardType THEN8l:= LONGWORD (VAL (LONGCARD, lrToSys (rr)))6ELSE8l:= LONGWORD (VAL (LONGINT, lrToSys (rr)))6END;4END;4zz.over:= FALSE2END;2IF dNumType = cardType THEN4expr.item:= CardPtr;2ELSE4expr.item:= IntPtr;2END;0ELSE0*)2convertReal (expr, S2LC + ORD (dNumType = intType)J+ 2 * ORD (sNumSize = real8));0(*$? CompileWithNewCompiler:0END;0*)0getSourceType;0convertScalar.ELSE0(* Runtime: REAL -> LONGREAL oder umgekehrt *)0IF const THEN2IF dNumSize = real4 THEN4(* SHORT () *)4shortenReal (expr, rReaRg);2ELSE4(* LONG () *)4expandReal (expr);2END0ELSE2convertReal (expr, ORD (sNumSize = real4))0END;.END,ELSIF (source = wholeNumber) THEN.IF (dest = realNumber) THEN0(*$? CompileWithNewCompiler:0IF const THEN2RealConstIsUsed;2WITH expr.exprConst DO4IF dNumSize = real4 THEN6IF sNumType = intType THEN8sr:= srToDest (VAL (REAL, LONGINT (l)))6ELSE8sr:= srToDest (VAL (REAL, LONGCARD (l)))6END;6zz.over:= FALSE4ELSE6IF sNumType = intType THEN8rr:= lrToDest (VAL (LONGREAL, LONGINT (l)))6ELSE8rr:= lrToDest (VAL (LONGREAL, LONGCARD (l)))6END4END2END0ELSE0*)2convertReal (expr, LC2S + 2 * ORD (dNumSize = real8)J+ ORD (sNumType = intType)  )0(*$? CompileWithNewCompiler:0END0*).ELSE0convertScalar.END,ELSE.(* enums, char, boolean *).IF dest # wholeNumber THEN SyntaxError (rNoCnv) END;.convertScalar,END;,expr.item:= destType*END(END safeConversion;(&PROCEDURE getVarExpr;(BEGIN*GetSymbol;*VarExpression ();*PopExpr (expr);*itemNo:= ItemNo (expr.item)(END getVarExpr;(&PROCEDURE getDesig (access: DesigAccesses);(BEGIN*GetSymbol;*designator (access, FALSE, rVarXp);*PopExpr (expr)(END getDesig;(&PROCEDURE getType;(BEGIN*GetSymbol;*IF NOT (typeDesc IN CurrentSymbol.flags) THEN SyntaxError (rTyDXp) END;*type:= CurrentSymbol.item;(END getType;(&PROCEDURE doShiftRotate;((* Subroutine zur Stack-Ersparnis *)((VAR*help, help2, dest: ExprDesc;*shifts, bits: CARDINAL;*mask: LONGCARD;*lo2, hi2: ZZ;*mustMask, shiftUp: BOOLEAN;((BEGIN*LookExpr (dest);*IF (ItemNo (dest.item) # 45)*OR (ItemNo (HostType (RefType (dest.item))) # 41) THEN,SyntaxError (rBinXp)*END;*(*$? Safety: assert (dest.regset & dest.zerobased);*)*ChkComma;*getVarExpr;*IF NOT isWholeNumber (expr.item) THEN SyntaxError (rWhNXp) END;*PopExpr (dest);*reloadPtr (dest);*getBounds (RefType (dest.item), lo, hi);*bits:= SHORT (diffZZ (hi, lo)) + 1;*mustMask:= NOT nullZZ (lo)5OR (cmpZZ (hi, toZZ (Size(dest)*8L-1L, FALSE)) # eq);*IF expr.kind = constant THEN,shiftUp:= posZZ (expr.exprConst.zz);,IF NOT shiftUp THEN negZZ (expr.exprConst.zz) END;,IF n = 108 (* ROTATE *) THEN.(* beim Rotieren nur Faktor MOD Setbreite nehmen *).modZZ (expr.exprConst.zz, toZZ (LONG (bits), FALSE)),END;,IF NOT nullZZ (expr.exprConst.zz) THEN.IF cmpZZ (expr.exprConst.zz,8toZZ (LONG (bits), FALSE)) = lt THEN0(* Wir schieben/rot. den Wert weniger als die Setbreite *)0shifts:= expr.exprConst.zz.c;0(*1*      MOVE    set,D01*      MOVE    D0,D2                 ; help21*      MOVE    #expr,D11*      LSL/R   D1,D01*)0prepareStackForLoad (dest);0loadReg (dest, anyDataReg);0IF mustMask THEN copyRegExt (dest, help2, dataRegs, 0) END;0shiftOrRotate (n=108, shiftUp, expr, dest);0IF mustMask THEN2(* unbenutzte Bits wiederherstellen *)2lo2:= lo; hi2:= hi;2IF shiftUp THEN INC (lo.c, shifts) ELSE DEC (hi.c, shifts) END;2mask:= makeMask (lo.c, hi.c);2IF n = 107 (* SHIFT *) THEN4(*5*      ANDI    #mask,D05*)4genANDI (SHORT (Size (dest)), mask, dest.exprReg);2ELSE4(*5*      MOVE    D0,D25*      ANDI    #mask,D05*      MOVE    #bits,D15*      ROR/L   D1,D25*      ANDI    #mask,D25*      OR      D2,D05*)4PushExpr (help2);4deallocRegs (expr);4copyRegExt (dest, help, dataRegs, 0);4genANDI (SHORT (Size (dest)), mask, dest.exprReg);4initConstExpr (expr, 2, toZZ (LONG (bits), FALSE));4shiftOrRotate (TRUE, NOT shiftUp, expr, help);4IF shiftUp THEN6hi:= lo; lo:= lo2; DEC (hi.c)4ELSE6lo:= hi; INC (lo.c); hi:= hi24END;4genANDI (SHORT (Size (dest)), makeMask (lo.c, hi.c), help.exprReg);4genar (OR_, help, dest.exprReg);4deallocRegs (help);4PopExpr (help2);2END;2(* und nun die restlichen Bits wiederherstellen:3*      ANDI    #inverseMask(lo,hi),D23*      OR      D2,D03*)2loadReg (help2, dataRegs);2genANDI (SHORT (Size (dest)), makeInvMask (lo2.c, hi2.c), help2.exprReg);2genar (OR_, help2, dest.exprReg);2deallocRegs (help2);0END;.ELSE0(* Wir schieben mehr als die Bitbreite -> Erg. ist 0 *)0clearExpr (dest).END;,END*ELSE,IF mustMask THEN.SyntaxError (rNImpY) (*!!! fehlt noch *),END;,safeConversion (expr, SIntPtr);,IF n = 108 (* ROTATE *) THEN n:= ROTA ELSE n:= SHFT END;,runtimeShiftRotate (n, dest, expr, lo, hi);*END;*deallocRegs (expr);*expr:= dest(END doShiftRotate;&&PROCEDURE doHigh;(VAR*help: ExprDesc;*regs: RegSet;(BEGIN*(*+* Jetzt wird ordentlich herumgesaut:+* Es wird davon ausgegangen, daû das Open Array ein Parm/Var+* ist und der Descriptor entweder x(A6) oder bei lok.+* Scopes x(A0) adressiert wird. Dann wird der Array-Access+* ggf. durchgefÅhrt, um an den High-Offset zu kommen bei+* mehrdim. Open Arrays (z.B: HIGH (a[0])). Dabei wird die+* Codeerzeugung unterdrÅckt. Wenn kein Array-Index vorkam,+* bleibt in 'help' der Zugriff auf den Array-Desc. erhalten,+* bei einem Index dagegen beschreibt 'help' den Ptr auf das+* Array. Der Ptr auf die High-Werte steht dann in help.highReg.+* So kann 'deallocRegs(help)' nicht einfach so aufgerufen wer-+* den, weil evtl. dann der High-Ptr (in A0) freigegeben wird.+* Deshalb wird 'freeRegs' gesichert und hinterher wieder+* zurÅckgesetzt.+*)*initIndir (expr, VarAddress (CurrentSymbol.item), FALSE);*expr.varItem:= CurrentSymbol.item;*GetSymbol;*help:= expr; regs:= freeRegs;*activateCodeSuppression (last);*desigAccess (help, TRUE);*restoreCodeSuppression (last);*freeRegs:= regs;*addDisp (expr, help.highOfs+4);*itemNo:= ItemNo (help.item);*IF itemNo = 32 THEN,expr.item:= SCardPtr*ELSIF itemNo = 42 THEN,expr.item:= CardPtr*ELSE,SyntaxError (rBdHig)*END(END doHigh;&&BEGIN (* stdFunction *)(n:= StdProcNo (CurrentSymbol.item);(type:= CurrentSymbol.item;(GetLparen;(IF n < 100 THEN*CASE n OF *| 1: (* ABS *)/getVarExpr;/expr.item:= HostType (expr.item);/IF NOT isNumber (expr.item, nsize, ntype) OR (ntype = cardType) THEN1SyntaxError (rIoRXp)/END;/IF expr.kind = constant THEN1WITH expr.exprConst DO3IF ntype = realType THEN5IF nsize = real4 THEN SRABS (sr) ELSE LRABS (rr) END3ELSE5IF NOT posZZ (zz) THEN negZZ (zz) END3END1END/ELSE1IF ntype = realType THEN3absReal (expr);1ELSE3IF (expr.kind = register) & (expr.exprReg IN dataRegs) THEN5gena (TST, expr, 0);3ELSE5loadReg (expr, dataRegs);3END;3gen (Bcc + mapCC (pl, FALSE, FALSE) + 2);3gena (NEG, expr, 0);3(*4* eigentlich ist nach Wirth & ISO der Result-Typ4* gleich dem Argument-Typ. Allerdings war bei MM24* bisher das Res CARDINAL/LONGCARD. Damit beiden4* gerecht wird, machen wir nun BothTyp draus:4*)3IF nsize = ord2 THEN5expr.item:= SBothTyp3ELSE5expr.item:= BothTyp3END1END/END**| 2: (* ORD *)/(*0* nach ISO gehen nur Ordinale, wir erlauben aber auch0* LONGWORD, WORD & BYTE!!0*)/getVarExpr;/adaptSSToChar (expr);/expr.item:= HostType (expr.item);/IF exprSize (expr) > 2 THEN1type:= CardPtr/ELSE1type:= SCardPtr/END;/IF isOrdinal (expr.item) THEN1safeConversion (expr, type)/ELSIF isJoker (expr.item) THEN1cast (expr, type)/ELSE1SyntaxError (rSclXp)/END**| 3: (* HIGH *)/GetSymbol;/IF NOT (userDef IN CurrentSymbol.flags)/OR (ORD (CurrentSymbol.typ) # 17) THEN1SyntaxError (rBdHig)/END;/doHigh;**| 4, (* LONG *),5: (* SHORT *)/getVarExpr;/IF expr.item = ZZTyp THEN1(*$? Safety: assert (expr.kind = constant);*)1IF n = 4 (* LONG *) THEN3IF expr.exprConst.zz.l < 0L THEN5expr.item:= IntPtr3ELSIF expr.exprConst.zz.over THEN5expr.item:= CardPtr3ELSE5expr.item:= BothTyp3END1END (* sonst bleibt's beim Alten *)/ELSE1type:= StdProcParms (type);1expr.item:= HostType (expr.item);1WHILE StdParmType (type) # expr.item DO3type:= NextStdParm (type);3IF type = NIL THEN SyntaxError (rParTy) END1END;1type:= StdParmRes (type);1IF isJoker (expr.item) THEN3cast (expr, type)1ELSE3(* hier kann 'type' auch BYTE sein! *)3safeConversion (expr, type)1END/END**| 6: (* ODD *)/getVarExpr;/IF NOT (scalar IN ItemFlag (expr.item)) THEN SyntaxError (rSclXp) END;/IF expr.kind = constant THEN1expr.exprConst.zz.over:= FALSE;1expr.exprConst.w:= WORD (ODD (CARDINAL (expr.exprConst.w)));1expr.exprConst.w2:= WORD (0);1expr.not:= FALSE/ELSE1(*2* FÅr die Odd-Bestimmung wird einfach der Wert in ein2* Reg. geladen und dann mit "ANDI #1,Dn" ein Boolean2* daraus gemacht2*)1loadReg (expr, dataRegs);1genANDI (2, CARDINAL (1), expr.exprReg);1IF condJmp THEN3deallocRegs (expr);3WITH expr DO5kind:= condFlags;5fpuFlags:= FALSE;5relOp:= ne;5signed:= FALSE;5not:= FALSE3END1END/END;/expr.item:= BoolPtr/*| 7, (* MIN *),8: (* MAX *)/getType;/IF isOrdinal (type) THEN1getBounds (type, lo, hi);1IF isNumber (type, nsize, ntype) THEN3type:= ZZTyp (* aus MAX (CARDINAL/INTEGER) wird ZZ;       *A* Chars/Enums bleiben dagegen bei ihren Typ *)1END;1initExpr (expr, HostType (type), constant);1IF n = 7 (* MIN *) THEN3expr.exprConst.zz:= lo1ELSE3expr.exprConst.zz:= hi1END;/ELSIF isReal (type) THEN1initExpr (expr, RealPtr, constant);1IF n = 7 (* MIN *) THEN3expr.exprConst.rr:= MinReal (ItemNo (type) = 2)1ELSE3expr.exprConst.rr:= MaxReal (ItemNo (type) = 2)1END;/ELSE1SyntaxError (rOoRXp)/END;/GetSymbol;/*| 9: (* VAL *)/getType;/IF NOT isOrdinal (type) & NOT isReal (type) THEN1SyntaxError (rOoRXp)/END;/GetComma;/getVarExpr;/adaptSSToChar (expr);/IF NOT isOrdinal (expr.item) & NOT isReal (expr.item) THEN1SyntaxError (rOoRXp)/END;/safeConversion (expr, type)/*|10: (* LENGTH *)/getVarExpr;/IF (expr.kind = constRef) OR (expr.kind = constant) THEN1IF expr.kind = constRef THEN3IF expr.constHead = NIL THEN dropConstantFromTree (expr) END;1END;1adaptStringToSS (expr);1IF NOT isSS (expr) THEN SyntaxError (rStCXp) END;1elems:= Size (expr);1(*$? Safety: assert (elems > 0L);*)1IF expr.kind = constRef THEN3(* sonst kann man nicht explizit ein 0C an's Ende hÑngen5pc:= expr.constAddr + elems - 1L;5IF pc^ = 0C THEN DEC (elems) END;3*)3cutConst (expr)1ELSE3(*$? Safety: assert (expr.kind = constant);*)3(* sonst kann man nicht explizit ein 0C an's Ende hÑngen5IF expr.exprConst.str[strConstSize] = 0C THEN DEC (elems) END3*)1END;1IF elems <= 65535L THEN n:= 2 ELSE n:= 4 END;1initConstExpr (expr, n, toZZ (elems, FALSE));1(* hier CARDINAL/LONGCARD liefern - nicht ZZ (nach ISO)! *)/ELSIF isStringVar (expr.item)/OR ((ItemNo (expr.item) = 32) OR (ItemNo (expr.item) = 42))2& (ItemNo (OpenArrayType (expr.item)) = 3) THEN1deallocHighReg (expr);1runtimeLength (expr)/ELSE1SyntaxError (rStrXp)/END;/*|11: (* SIZE *)/GetSymbol;/IF typeDesc IN CurrentSymbol.flags THEN1initConstExpr (expr, 4, toZZ (TypeLength (CurrentSymbol.item), FALSE));1GetSymbol/ELSE1activateCodeSuppression (last);1designator (typeDesig, FALSE, rVoCXp);1restoreCodeSuppression (last);1PopExpr (expr);1IF isOpenArray (expr.item) THEN SyntaxError (rSizVr) END;1restoreStack (expr);1deallocRegs (expr);1initConstExpr (expr, 4, toZZ (TypeLength (expr.item), FALSE));/END;/expr.item:= ZZTyp;/*|12: (* INT *)/(*0* nach ISO gehen nur Ordinale & Reals, wir erlauben aber auch0* LONGWORD, WORD & BYTE.0* Besonderheit bei BYTE: Der Wert wird mit Vorzeichen expandiert0*)/getVarExpr;/expr.item:= HostType (expr.item);/adaptSSToChar (expr);/reduceZZ (expr);/IF Size (expr) > 2L THEN1type:= IntPtr/ELSE1type:= SIntPtr (* ist teilw. kritisch, z.B. bei INT(shortcard) *)/END;/IF isReal (expr.item) OR isOrdinal (expr.item) THEN1safeConversion (expr, type)/ELSIF isJoker (expr.item) THEN1IF jokerSize (ItemNo (expr.item)) = 1 THEN3(* bei INT (byte) wird mit Vorzeichen expandiert! *)3expr.item:= BytIPtr1END;1cast (expr, type)/ELSE1SyntaxError (rSclXp)/END/*|13: (* CAP *)/getVarExpr;/adaptSSToChar (expr);/IF NOT isChar (HostType (expr.item)) THEN SyntaxError (rChrXp) END;/IF expr.kind = constant THEN1expr.exprConst.ch:= CAP (expr.exprConst.ch)/ELSE1runtimeCap (expr)/END/*|14: (* CHR *)/getVarExpr;/IF NOT isWholeNumber (expr.item) THEN1SyntaxError (rWhNXp)/END;/type:= CharPtr;/getConversionDesc (expr.item, type, range);/fitValue (expr, range);/expr.item:= type;/*|15, 16: (* FLOAT, LFLOAT *)/getVarExpr;/IF NOT isNumber (expr.item, nsize, ntype)/&  NOT isReal (expr.item) THEN SyntaxError (rNumXp) END;/IF n = 15 THEN type:= SRealPtr ELSE type:= RealPtr END;/safeConversion (expr, type);/*|17: (* TRUNC *)/getVarExpr;/IF NOT isReal (expr.item) THEN SyntaxError (rReaXp) END;/safeConversion (expr, CardPtr);**|18: ASSEMBLER8DC.W    SerLead10Serial2 DC.W    SerVal1       ;SerienNr ^^^/END;**ELSE,SyntaxError (rNotFn)*END;(ELSE*ASSEMBLER0PEA     labelAdr(PC)*END;*CASE n OF *|102: (* 101: ADR *)0ASSEMBLER2; Achtung: die '102' ist nur ein Pseudo-Label, das nicht2;   vorkommt! In Wahrheit wird diese Routine durch den2;   ELSE-Zweig des CASE (s.u.) angesprungen!1labelAdr:0END;00getDesig (varDesig);0IF warningsActive () THEN2IF expr.readOnly THEN SyntaxError (rRefRs) END;2IF expr.regVar THEN SyntaxError (rRegVa) END;0END;0IF isOpenArray (expr.item) THEN2deallocHighReg (expr);2loadIndir (expr, 0, FALSE)0END;0loadSourceAddress (expr);0expr.item:= StdParmRes (StdProcParms (type)); (* ADDRESS *)00ASSEMBLER:BRA.W   SerOk:DC.W    SerLead02Serial1 DC.W    SerVal0       ;SerienNr ^^^0END; *|103: (* TSIZE *)0getType;0initConstExpr (expr, 4, toZZ (TypeLength (type), FALSE));0expr.item:= ZZTyp;0GetSymbol;0(* mehrere Args zulassen bei Records (werden nicht geprÅft): *)0WHILE (CurrentSymbol.itemNo = comma)0& (ItemNo (type) = 13 (* RECORD *) ) DO2(*&&& Werte auswerten *)2GetSymbol;2ConstExpression;2PopExpr (helpExpr);0END;**|104: (* CAST *)0getType;0GetComma;0getVarExpr;0cast (expr, type);0IF extendedSyntax () & ~AsmMode THEN2desigAccess (expr, FALSE);2deallocHighReg (expr); (* 15.2.94, hier stand irrtÅmlich 'help' *)0END;0*|105: (* CADR *)*0GetSymbol;0IF (userDef IN CurrentSymbol.flags)0AND (ORD (CurrentSymbol.typ) = 28) THEN2(* TABLE *)2initMemExpr (expr, 0(*dummy*), absRef, FALSE);2expr.varItem:= CurrentSymbol.item;2expr.readOnly:= TRUE;2GetSymbol;0ELSE2VarExpression ();2PopExpr (expr);2WITH expr DO4IF isOpenArray (item) THEN6deallocHighReg (expr);6loadIndir (expr, 0, FALSE)4END;4IF (kind # memory)4&  (kind # constant)4&  (kind # constRef)4OR (kind = memory) & (mode = immRef) THEN6SyntaxError (rVoCXp)4END2END;2reduceZZ (expr);0END;0loadSourceAddress (expr);0expr.item:= StdParmRes (StdProcParms (type)); (* ADDRESS *)0(*    oder noch besser: auf POINTER TO expr.item --1*    dann wÅrde auch korrekter Check mîglich sein, ob1*    durch 'reduceZZ' ein 2- oder 4-Byte wert abgelegt wurde *)**|106: (* DEREF *)0getVarExpr;0deref (expr)**|107, 108: (* SHIFT, ROTATE *)0GetSymbol;0VarExpression ();0doShiftRotate; *|126, 127: (* CALLSYS, CALLEXT *)0hdlCall (n-126, type);0initExpr (expr, StdParmRes (StdProcParms (type)), register);0expr.exprReg:= allocReg (RegSet {D0}) *(*&&& ADDADR, SUBADR, DIFADR *)**ELSE,IF n >= 120 THEN.SyntaxError (rNotFn),END;,ASSEMBLER0; Hiermit wird System-Funktion 101 (ADR) angesprungen:0RTS,END;*END;*ASSEMBLER0; Seriennummer Serial1 gegen Serial2 prÅfen ^^^0MOVE.L  (A7)+,A00CLR.L   D00MOVE.W  Serial1-labelAdr(A0),D00MOVEQ   #SerCnt1,D1(lp      LSR.L   #1,D00BCC     l10BTST    #6,D00BNE     l2(l3      BSET    #17,D0(l2      DBF     D1,lp0ADDI.W  #SerOffset1,D00CMP.W   Serial2-labelAdr(A0),D00BEQ     SerOk0LEA     SCardPtr,A00MOVE.L  8(A0),-4(A0)    ; BothTyp -> SIntPtr0BRA     SerOk(l1      BTST    #6,D00BEQ     l20BRA     l3(SerOk*END(END;(checkSet (expr);(PushExpr (expr);(GetRparen&END stdFunction;  $PROCEDURE checkCall;&BEGIN(IF (CurrentSymbol.itemNo) = lparen THEN*funcCall(END&END checkCall; $PROCEDURE userFunction;&VAR fact: ExprDesc;&BEGIN(initProcExpr (fact, CurrentSymbol.item, procDepth (Tiefe));(PushExpr (fact);(GetSymbol;&END userFunction;  $PROCEDURE const (namedID: BOOLEAN);&&VAR StringBuffer: ARRAY [0..MaxStringConst] OF CHAR;*StringLength: [0..MaxStringConst];*itemIsUserConst: BOOLEAN;*currentItem: PtrItem;*fact: ExprDesc; &PROCEDURE hdlString;(VAR type: PtrItem;(BEGIN*WITH fact DO,(* String-Kennung erzeugen - muû unbedingt vor drop...-Aufruf! *),IF StringLength <= strConstSize THEN.initExpr (fact, SSTyp, constant);.IF itemIsUserConst THEN0fact.varItem:= currentItem; (* Verweis auf CONST im Tree *).END;.(* String in Expr merken *).(* String wird als Konst. abgelegt *).IF StringLength = 0 THEN0exprConst.ch:= 0C.ELSE0Move (ADR (StringBuffer),2ADR (exprConst.b)-LONG(StringLength-1)(* rechtsbÅndig *),2StringLength).END;,ELSE.(* String kommt ins DATA-Segment *).initExpr (fact, SSTyp, constRef);.IF itemIsUserConst THEN0fact.varItem:= currentItem; (* Verweis auf CONST im Tree *).ELSE0(* String sofort in DATA-Puffer ablegen *)0dropNewConstant (ADR (StringBuffer), StringLength, fact);.END,END;,SetSize (fact, StringLength);*END;(END hdlString;&&PROCEDURE appendToBuffer (item: PtrItem);(VAR n: [0..MaxStringConst]; p: POINTER TO CHAR;(BEGIN*IF StringLength + StrLen >= MaxStringConst THEN,SyntaxError (rSCoLg)*END;*n:= 0;*p:= AccuPtr;*WHILE n < StrLen DO,INC (n);,StringBuffer [StringLength]:= p^;,INC (StringLength); INC (p);*END(END appendToBuffer; &PROCEDURE loadConst (type: PtrItem);((* lÑdt Konstante aus Accu auf ExprStack *)((* kann laden: alles, auûer String-Consts *)(VAR nsize: NumberSize; ntype: NumberType;,lo, hi: ZZ; n: CARDINAL;(BEGIN*initExpr (fact, type, constant);*WITH fact DO,IF itemIsUserConst THEN.varItem:= currentItem; (* Verweis auf CONST im Tree *),END;,n:= SHORT (TypeLength (item));,IF (n < 4) & (scalar IN ItemFlag (item)) THEN.Move (ADR (Accu), ADR (exprConst.l), 4),ELSIF n <= constBufSize THEN.Move (AccuPtr, ADR (exprConst.b)+1L-LONG(n), n),ELSE.(* Konst kommt ins DATA-Segment *).(* Wenn Const > AccuSize, wurde sie von ConstantFactor() in den/* Code abgelegt, und zwar mit einem Sicherheits-Offset von $100/* Bytes. *).IF itemIsUserConst THEN0kind:= constRef;0constOfs:= 0;0constHead:= NIL;.ELSE0(* Konst sofort in DATA-Puffer ablegen *)0dropNewConstant (AccuPtr, n, fact);.END,END;,IF isNumber (item, nsize, ntype) THEN.IF (nsize = ord4) & (item # ZZTyp) THEN0exprConst.zz.over:= (ntype = cardType) & (exprConst.zz.v < 0L);.ELSIF nsize = ord2 THEN0IF ntype = intType THEN exprConst.w2:= WORD (-1) END;0exprConst.zz.over:= FALSE;0IF ntype = bothType THEN item:= ZZTyp END;.(*.ELSIF ntype = realType THEN.*).END,END;*END;(END loadConst; &BEGIN (* const *)(IF CurrentSymbol.itemNo = lbrace (* '{' -> BITSET *) THEN*(* keinen Fehler melden, damit PIM3-konform,SyntaxError (rBitse)**)*hdlSetConstructor (BSetPtr);*GetSymbol(ELSE*currentItem:= CurrentSymbol.item;*itemIsUserConst:= (userDef IN CurrentSymbol.flags) &<(ItemNo (currentItem) = 50);*IF NOT ConstantFactor () THEN SyntaxError (rFactr) END;*IF StrConstType (CurrentSymbol.item) THEN,StringLength:= 0;,LOOP.appendToBuffer (CurrentSymbol.item);.GetSymbol;.IF (CurrentSymbol.itemNo) # strConc THEN EXIT END;.itemIsUserConst:= FALSE;.GetSymbol;.IF NOT ConstantFactor ().OR NOT StrConstType (CurrentSymbol.item) THEN0SyntaxError (rStCXp).END,END;,hdlString*ELSE,(* numerische oder strukt. Konst. *),loadConst (CurrentSymbol.item); (* Wert steht in Accu *),GetSymbol*END;*IF namedID & ~AsmMode THEN,(* benamte Consts wie Designators auswerten *),desigAccess (fact, FALSE);,PushExpr (fact);,checkCall;,PopExpr (fact)*END;*checkSet (fact);*PushExpr (fact)(END&END const; $PROCEDURE getFactExpr;&PROCEDURE handleJmp;(VAR tempTrue, tempFalse, dummyLbl1, dummyLbl2: Labels;(BEGIN*GetSymbol;*expression (TRUE, tempFalse, tempTrue, dummyLbl1, dummyLbl2);*(*$? Safety: assert (~unSolved (dummyLbl1)); *)*(*$? Safety: assert (~unSolved (dummyLbl2)); *)*AddLabelsTo (tempFalse, false);*AddLabelsTo (tempTrue, true);(END handleJmp;&BEGIN((* Unterscheidung ist nîtig, weil sonst "(x IN s) = b" nicht ginge: *)(IF condJmp THEN*handleJmp(ELSE*GetSymbol;*VarExpression ()(END&END getFactExpr; $PROCEDURE hdlType;&VAR t: PtrItem; expr: ExprDesc;&BEGIN(t:= CurrentSymbol.item;(GetSymbol;(IF CurrentSymbol.itemNo = lparen THEN*(* Type Transfer *)*GetSymbol;*VarExpression ();*GetRparen;*PopExpr (expr);*IF isSS (expr) & isStringVar (t) THEN,(*-* Es kînnen auch String-Consts mit dem Typ-Bezeichner gecastet-*  werden, allerdings nur, wenn die Const auch ganz reinpaût-*),IF Size (expr) > TypeLength (t) THEN SyntaxError (rSCoOv) END;,terminateStringConst (expr, t);,adaptStringConst (expr, t);*ELSE,IF (expr.kind = constant) & isWholeNumber (expr.item) THEN.IF (LONG (sizeZZ (expr.exprConst.zz)) > TypeLength (t)) THEN0SyntaxError (rConRg).END;.expr.item:= t,ELSE.IF Size (expr) # TypeLength (t) THEN SyntaxError (rConv) END;,END;*END;*expr.item:= t;*IF extendedSyntax () & ~AsmMode THEN desigAccess (expr, FALSE); END;*checkSet (expr);*PushExpr (expr);*IF extendedSyntax () & ~AsmMode THEN checkCall END(ELSIF CurrentSymbol.itemNo = lbrace THEN*(* Type/Value Constructor *)*hdlConstructor (t);*GetSymbol(ELSE*SyntaxError (rFactr)(END&END hdlType; $PROCEDURE swapLabels;&VAR tempFalse: Labels;&BEGIN(tempFalse:= false;(false:= true;(true:= tempFalse;&END swapLabels; $PROCEDURE hdlNot;&VAR fact: ExprDesc;&BEGIN(GetSymbol;(swapLabels;(factor ();(swapLabels;(PopExpr (fact);(IF NOT BooleanType (fact.item) THEN SyntaxError (rBolXp) END;((* folgende Conditions bzw. Const-Wert invertieren *)(IF fact.kind = constant THEN*(*$? Safety: assert (ORD (fact.exprConst.w) < 2); *)*fact.exprConst.w:= WORD (NOT BOOLEAN (fact.exprConst.w))(ELSE*fact.not:= NOT fact.not(END;(PushExpr (fact);&END hdlNot; $BEGIN (* factor *)&IF (CurrentSymbol.itemNo) = 0 THEN(SyntaxError (rIdUn)&ELSIF typeDesc IN (CurrentSymbol.flags) THEN(hdlType&ELSIF userDef IN CurrentSymbol.flags THEN(IF (ORD (CurrentSymbol.typ) = 17)(OR (ORD (CurrentSymbol.typ) = 14) THEN*designator (readDesig, FALSE, -1043 (* darf nicht vorkommen *));*checkCall(ELSIF ORD (CurrentSymbol.typ) = 36 THEN*stdFunction;*IF extendedSyntax () & ~AsmMode THEN checkCall END(ELSIF ORD (CurrentSymbol.typ) = 6 THEN*userFunction;*checkCall(ELSE*const (TRUE)(END;&ELSE(IF CurrentSymbol.itemNo = lparen THEN*(* In Klammer mÅssen neue Labels vergeben werden *)*getFactExpr;*GetRparen;(ELSIF (CurrentSymbol.itemNo = tilde)(OR    (CurrentSymbol.itemNo = SymNot) THEN*hdlNot(ELSE*const (FALSE)(END&END;$END factor;  "PROCEDURE term (); $VAR resultType: PtrItem;(size: CARDINAL; $PROCEDURE constOp (op: Operator; VAR expr, const: ExprDesc); &VAR n, opcode: CARDINAL; signed: BOOLEAN;*p: POINTER TO BYTE; &BEGIN(IF isReal (resultType) THEN*realOp (op, const, expr)(ELSIF op = mul THEN*constMul (expr, resultType, const.exprConst.zz, TRUE);*PushExpr (expr)(ELSE*(* Achtung: Wenn bei DIV/MOD die Word-optimierten Routinen+* "CDVW,IDVW,CMDW,IMDW" benutzt werden, muû 'checkDivisor' vorher+* aufgerufen werden, da die Routinen keine Null-PrÅfung machen. *)*IF nullZZ (const.exprConst.zz) THEN,SyntaxError (rDvNul)*END;*signed:= signedExpr (expr);*IF posZZ (const.exprConst.zz) & log2 (const.exprConst.zz, n) THEN,IF op = div THEN.IF n # 0 (* DIV durch 1? *) THEN0IF n >= (size * 8) THEN2(* Ergebnis ist Null *)2clearExpr (expr)0ELSE2loadReg (expr, dataRegs);2IF n >= 16 THEN4(* CLR.W und SWAP bzw. SWAP und EXT.L *)4IF ~signed THEN genr (CLRW, expr.exprReg) END;4genr (SWAP, expr.exprReg);4IF signed THEN genr (EXTL, expr.exprReg) END;4DEC (n, 16);4size:= 22END;2IF n > 0 THEN4IF signed THEN opcode:= ASRI ELSE opcode:= LSRI END;4getSizeAt6 (size, opcode);4IF n > 8 THEN6(* LSR #8,expr *)6genr (opcode, expr.exprReg);6DEC (n, 8)4END;4(* LSR #n,expr *)4genr (opcode + $200 * (n MOD 8), expr.exprReg)2END0END.END,ELSIF op = mod THEN.IF n < (size * 8) THEN0IF n = 0 THEN2(* Ergebnis ist Null *)2clearExpr (expr)0ELSIF signed THEN2(* hier mÅûten neg. Werten erst in pos. gewandelt, nach dem3* ANDI wieder negiert werden. Das ist zu umstÑndlich, daher3* wird einfacherhalber der DIV-Befehl benutzt *)2varMul (op, expr, const, TRUE, resultType);2RETURN0ELSE2loadReg (expr, dataRegs);2genANDI (size, const.exprConst.zz.v-1L, expr.exprReg);0END.END,ELSE.SyntaxError (rOpTyp),END;,PushExpr (expr)*ELSE,varMul (op, expr, const, TRUE, resultType);*END;(END&END constOp; $PROCEDURE mulop (n: CARDINAL; VAR op: Operator): BOOLEAN;&VAR expr: ExprDesc;&BEGIN(IF n = asterisk THEN*op:= mul(ELSIF (n = 5) (* / *) THEN*op:= rdiv;(ELSIF (n = 50) (* DIV *) THEN*op:= div;(ELSIF (n = 52) (* MOD *) THEN*op:= mod(ELSIF (n = SymAnd) OR (n = 19) (* & *) THEN*op:= and(ELSE*RETURN FALSE(END;(RETURN TRUE&END mulop; $VAR&op: Operator;&lconst, rconst: BOOLEAN;&localTrue, localFalse: Labels; $PROCEDURE handleAnd;&VAR(last, left, right: ExprDesc;(bccPtr: ADDRESS;(lastRegs: RegSet;(f1, ignore: BOOLEAN;(nice: RegSet;&BEGIN(PopExpr (left);((IF NOT BooleanType (left.item) THEN SyntaxError (rOpTyp) END;(((*)* nun mÅssen wir alle andern Regs spillen, da im Fall,)* daû in der Bool-Expr sonstwo ein spill auftauchen wÅrde,)* durch die Label-Springerei an Stellen gesprungen werden)* kînnte, an denen ein Reg noch auf dem Stack steht, obwohl)* es durch die optimierten SprÅnge gar nicht auf den Stack kam.)* Beispiel:  ptrToBool:= NOT bool AND boolFunc();)*   hier wÅrde das Addr-Reg f. das Ergebnis beim F-Aufruf)* auf den Stack kommen, aber erst bei der Zuweisung und somit)* hinter dem false-Label von 'NOT bool' erst zurÅckgeladen)* werden. Wenn nun aber bool=TRUE, wÅrde zum Label gesprungen,)* ohne daû Åberhaupt das Reg gespilled worden wÑre.)*)(spillAllRegsExcept (left);(((* Sprung, wenn FALSE... *)(ignore:= FALSE;(bccPtr:= NIL;(last:= left;(IF left.kind = constant THEN*IF BOOLEAN (left.exprConst.w) = FALSE THEN,(* rechten Teil ignorieren *),ignore:= TRUE*END(ELSE*IF condJmp THEN,tstAndJmp (FALSE, left, localFalse, last, bccPtr);*ELSIF NOT left.not THEN,moveAndJmp (FALSE, left, localFalse, last, bccPtr);*ELSE,moveAndJmp (FALSE, left, localTrue, last, bccPtr);*END;*IF unSolved (true) THEN Solve (true); bccPtr:= NIL END;*IF unSolved (trueNot) THEN Solve (trueNot); bccPtr:= NIL END(END;(restoreStack (left);(lastRegs:= freeRegs;(deallocRegs (left);(((* Nun die rechte Seite... *)(GetSymbol;(f1:= SuppressCode;(SuppressCode:= SuppressCode OR ignore; (* ggf. keinen Code erzeugen *)((* die linke Seite darf nicht mehr auf den Expr-Stack weil)* sie bereits dealloziert ist. *)(factor ();(SuppressCode:= f1;(PopExpr (right);(IF NOT BooleanType (right.item) THEN SyntaxError (rOpTyp) END; (IF right.kind = constant THEN*IF BOOLEAN (right.exprConst.w) = FALSE THEN,(* 'right' bleibt, 'left' wird ignoriert *)*ELSE,(* wenn rechts TRUE, ignorieren; links Åbernehmen *),freeRegs:= lastRegs;,right:= last*END;*IF bccPtr # NIL THEN,(* Bcc rÅckgÑngig machen, da rechts kein Code erz. wurde: *),IF condJmp OR NOT left.not THEN.PopLabel (localFalse),ELSE.PopLabel (localTrue),END;,SetCodePtr (bccPtr)*END(ELSE*IF left.kind = constant THEN,IF ignore THEN.(* dann noch kein Code erzeugt -> kind bleibt erhalten *).deallocRegs (right);.WITH right DO0IF kind = stack THEN2updateStackOffsets (stackReg, up, stackedSize)0END.END;.right:= left;,END*ELSIF NOT condJmp THEN,nice:= RegSet{};,INCL (nice, left.exprReg);,loadReg (right, nice)*END(END;(PushExpr (right);&END handleAnd;$$PROCEDURE handleOp;&VAR(left, right: ExprDesc; real: BOOLEAN;&BEGIN(PopExpr (right);(PopExpr (left);((checkCompat (left, right, resultType, rBdTyp);((lconst:= left.kind = constant;(rconst:= right.kind = constant;(IF lconst & rconst OR (left.kind = constRef) & (right.kind = constRef) THEN*constantFold (op, left, right);(ELSE*CASE ItemNo (resultType) OF*| 5, 45: (* SET *).setOp (op, left, right, resultType)*| 40, 2,      (* REAL *),1,22,30,4,  (* 32 Bit INTEGER/CARDINAL/BOTH/ZZ *),23,         (* ADDRESS *),33, 34, 35: (* 16 Bit INTEGER/CARDINAL *).prepareStackForLoad (right);.IF bothOnStack (left, right) THEN0IF (ItemNo (left.item) = 2) OR (ItemNo (left.item) = 40) THEN2loadRealReg (right,floatRegs);0ELSE2loadReg (right,dataRegs);0END;0restoreStack (right);.END;.reloadPtr (left);.prepareStackForLoad (left);.size:= SHORT (TypeLength (resultType));.IF (op = mul) & lconst THEN0constOp (op, right, left);.ELSIF rconst THEN0constOp (op, left, right);.ELSE0varMul (op, left, right, TRUE, resultType).END*ELSE.SyntaxError (rOpTyp)*END(END&END handleOp;&&$BEGIN (* term *)&InitLabels (localFalse);&InitLabels (localTrue);&factor ();&WHILE mulop (CurrentSymbol.itemNo, op) DO(IF (op = and) THEN*(* --- BOOLEAN / AND --- *)*handleAnd;(ELSE*GetSymbol;*factor ();*handleOp;(END&END;&AddLabelsTo (localFalse, false);&AddLabelsTo (localTrue, falseNot)$END term;  "PROCEDURE simpleExpression (); $VAR resultType: PtrItem;(localFalse, localTrue: Labels;(notReal, lconst, rconst: BOOLEAN;(op: Operator; $PROCEDURE addSub (opcode: CARDINAL; VAR ea, const: ExprDesc);&(* Bei SUB ist 'ea' left, 'const' right *)&VAR x: ZZ; isConst: BOOLEAN;&BEGIN(isConst:= (const.kind = constant) & notReal;(x:= const.exprConst.zz;(IF isConst & int3ZZ (x) THEN*loadReg (ea, dataRegs);*IF op = sub THEN negZZ (x) END;*genQ (SHORT (x.v), ea);(ELSE*IF (op = add) & isConst & int8ZZ (x) THEN swapExpr (const, ea) END;*IF notReal THEN,loadReg (ea, dataRegs);,genar (opcode, const, ea.exprReg)*ELSE,ea.item:= resultType;,realOp (op, const, ea); (* macht ggf. selbst Overflow-Check *),RETURN*END(END;(checkOverflow (resultType);(deallocRegs (const);(ea.item:= resultType;(PushExpr (ea);&END addSub; $PROCEDURE opTo (VAR left, right: ExprDesc);&(*'* bei SUB muû 'right' als <ea>, left in Reg genommen werden.'*)&VAR opcode: CARDINAL;&BEGIN(IF op = add THEN*opcode:= ADD;(ELSE*opcode:= SUB(END;(IF (op = add) & (lconst OR (inDataReg (right))) THEN*addSub (opcode, right, left)(ELSE*addSub (opcode, left, right)(END&END opTo; $PROCEDURE negate (VAR expr: ExprDesc; nsize: NumberSize; ntype: NumberType);&BEGIN(IF ntype = realType THEN*(* Real negieren *)*IF expr.kind = constant THEN,WITH expr.exprConst DO.IF nsize = real4 THEN SRNEG (sr) ELSE LRNEG (rr) END,END;*ELSE,negateReal (expr)*END(ELSIF (ntype = intType) OR (ntype = bothType) THEN*IF expr.kind = constant THEN,negZZ (expr.exprConst.zz)*ELSE,loadReg (expr, dataRegs);,restoreStack (expr);,gena (NEG, expr, 0);,checkOverflow (expr.item)*END(ELSE*SyntaxError (rNegTp)(END&END negate; $PROCEDURE addop (n: CARDINAL; VAR op: Operator): BOOLEAN;&BEGIN(IF n = plus THEN*op:= add(ELSIF n = minus THEN*op:= sub(ELSIF n = SymOr THEN*op:= or(ELSE*RETURN FALSE(END;(RETURN TRUE&END addop;$ $PROCEDURE handleNeg (neg: BOOLEAN);&VAR(left: ExprDesc;(size: NumberSize;(ntyp: NumberType;&BEGIN(LookExpr (left);(IF NOT isNumber (left.item, size, ntyp) THEN*SyntaxError (rOpTyp)(END;(IF neg THEN*PopExpr (left);*reloadPtr (left);*negate (left, size, ntyp);*PushExpr (left)(END&END handleNeg;$$PROCEDURE handleOr;&VAR(last, left, right: ExprDesc;(bccPtr: ADDRESS;(nice: RegSet;(f1, ignore: BOOLEAN;(lastRegs: RegSet;&BEGIN((* --- BOOLEAN / OR --- *)(PopExpr (left);(IF NOT BooleanType (left.item) THEN SyntaxError (rOpTyp) END;((spillAllRegsExcept (left);(((* Sprung, wenn TRUE... *)(ignore:= FALSE;(bccPtr:= NIL;(last:= left;(IF left.kind = constant THEN*IF BOOLEAN (left.exprConst.w) = TRUE THEN,(* rechten Teil ignorieren *),ignore:= TRUE*END(ELSE*IF condJmp THEN,tstAndJmp (TRUE, left, localTrue, last, bccPtr);*ELSIF NOT left.not THEN,moveAndJmp (TRUE, left, localTrue, last, bccPtr);*ELSE,moveAndJmp (TRUE, left, localFalse, last, bccPtr);*END;*IF unSolved (false) THEN Solve (false); bccPtr:= NIL END;*IF unSolved (falseNot) THEN Solve (falseNot); bccPtr:= NIL END(END;(restoreStack (left);(lastRegs:= freeRegs;(deallocRegs (left);(((* Nun die rechte Seite... *)(GetSymbol;(f1:= SuppressCode;(SuppressCode:= SuppressCode OR ignore; (* ggf. keinen Code erzeugen *)(term ();(SuppressCode:= f1;(PopExpr (right);(IF NOT BooleanType (right.item) THEN SyntaxError (rOpTyp) END; (IF right.kind = constant THEN*IF BOOLEAN (right.exprConst.w) = TRUE THEN,(* 'right' bleibt, 'left' wird ignoriert *)*ELSE,(* wenn rechts FALSE, ignorieren; links Åbernehmen *),freeRegs:= lastRegs;,right:= last*END;*IF bccPtr # NIL THEN,(* Bcc rÅckgÑngig machen, da rechts kein Code erz. wurde: *),IF condJmp OR NOT left.not THEN.PopLabel (localTrue),ELSE.PopLabel (localFalse),END;,SetCodePtr (bccPtr)*END(ELSE*IF left.kind = constant THEN,IF ignore THEN.(* dann noch kein Code erzeugt -> kind bleibt erhalten *).deallocRegs (right);.WITH right DO0IF kind = stack THEN2updateStackOffsets (stackReg, up, stackedSize)0END.END;.right:= left;,END*ELSIF NOT condJmp THEN,nice:= RegSet{};,INCL (nice, left.exprReg);,loadReg (right, nice)*END(END;(PushExpr (right);&END handleOr;$$PROCEDURE handleOp;&&VAR(left, right: ExprDesc;&BEGIN(PopExpr (right);(PopExpr (left);((checkCompat (left, right, resultType, rBdTyp);((lconst:= left.kind = constant;(rconst:= right.kind = constant;(IF lconst & rconst OR (left.kind = constRef) & (right.kind = constRef) THEN*constantFold (op, left, right);(ELSE*CASE ItemNo (resultType) OF*| 5, 45: (* SET *).setOp (op, left, right, resultType)*| 40, 2,      (* REAL *),1,22,30,4,  (* 32 Bit INTEGER/CARDINAL/BOTH/ZZ *),23,         (* ADDRESS *),33, 34, 35: (* 16 Bit INTEGER/CARDINAL *).prepareStackForLoad (right);.IF bothOnStack (left, right) THEN0IF isReal (resultType) THEN2loadRealReg (right,floatRegs);0ELSE2loadReg (right,dataRegs);0END;0restoreStack (right);.END;.reloadPtr (left);.prepareStackForLoad (left);.notReal:= NOT isReal (resultType);.IF rconst & notReal & nullZZ (right.exprConst.zz) THEN0left.item:= resultType;0PushExpr (left).ELSIF lconst & notReal & (op#sub) & nullZZ (left.exprConst.zz) THEN0right.item:= resultType;0PushExpr (right).ELSE0opTo (left, right).END*ELSE.SyntaxError (rOpTyp)*END(END&END handleOp;$$PROCEDURE hdlDebug;&VAR expr: ExprDesc;&BEGIN(PopExpr (expr);(handleDebug (expr);(PushExpr (expr);&END hdlDebug;$$VAR number, negSign: BOOLEAN;&$BEGIN (* simpleExpression *)&InitLabels (localTrue);&InitLabels (localFalse);&&(* Vorzeichen testen: *)&number:= FALSE;&IF (CurrentSymbol.itemNo = plus)&OR (CurrentSymbol.itemNo = minus) THEN(negSign:= (CurrentSymbol.itemNo = minus);(number:= TRUE;(GetSymbol&END; &term ();&&IF number THEN(handleNeg (negSign)&END; &WHILE addop (CurrentSymbol.itemNo, op) DO(IF (op = or) THEN*handleOr(ELSE*GetSymbol;*term ();*handleOp(END&END;&&IF NOT InConstExpr & generateDebugCode () THEN(hdlDebug;&END;&&AddLabelsTo (localTrue, true);&AddLabelsTo (localFalse, trueNot)$END simpleExpression;  "(* ----------------------------------------------------------------------- *)  "VAR lconst, rconst: BOOLEAN; "PROCEDURE inSet (VAR expr, set: ExprDesc);$$PROCEDURE makeFalse;&BEGIN(clearExpr (set);  (* damit ggf. Daten vom A3-Stack gerÑumt werden *)(initExpr (set, BoolPtr, constant);(set.exprConst.w:= WORD (FALSE);(PushExpr (set)&END makeFalse; $VAR lo, hi: ZZ; n: CARDINAL; relOp: Operator;(old, max: ExprDesc; size: CARDINAL; codePtr: ADDRESS; $BEGIN&relOp:= ne;&getBounds (RefType (set.item), lo, hi); &size:= SHORT (Size (set));&(*$? Safety: assert (set.typeChecked);*)&IF set.regset&AND (  (set.kind = register)+OR NOT lconst+OR NOT inZZ (expr.exprConst.zz,8toZZ (LONG (size * 8 - 8), FALSE),8toZZ (LONG (size * 8 - 1), FALSE) ) ) THEN(prepareStackForLoad (set);(IF bothOnStack (expr, set) THEN*loadReg (set, dataRegs);*restoreStack (set);(END;(reloadPtr (expr);(prepareStackForLoad (expr); (IF lconst THEN*(* BTST #x,set *)*IF inZZ (expr.exprConst.zz, lo, hi) THEN,IF NOT set.zerobased THEN.subZZ (expr.exprConst.zz, lo);,END;,loadReg (set, dataRegs);,restoreStack (set);,genr (BTSTI, set.exprReg);,gen (expr.exprConst.zz.c)*ELSE,(* wenn expr auûerhalb des Set, ist Erg. immer FALSE *),makeFalse;,RETURN*END(ELSE*(* BTST expr-Reg,set *),(*-* Wenn expr > MAX (set), muû FALSE geliefert werden.-* Das geht so:-*   MOVE  expr,Dx-*   MOVE  #hi,Dy   ;hier kein CMPI, weil dann Abfrage invertiert-*   CMP   Dx,Dy    ;und dadurch 'SHI' nicht mehr anwendbar wÑre-*   BCS   false    ; > C=1-*   MOVE  set,Ds-*   BTST  Dx,Ds-*  false-*   SHI   bool     ; Z=0 & C=0-*)*loadReg (expr, anyDataReg);*IF NOT set.zerobased THEN,negZZ (lo);,loadReg (expr, dataRegs);,incReg (expr.exprReg, lo, 2);*END;*initConstExpr (max, 2, hi);*loadReg (max, addrRegs + dataRegs);*genar (CMP, expr, max.exprReg);*deallocRegs (max);*gen (Bcc + mapCC (cc, FALSE, TRUE));*codePtr:= CodePtr ();*restoreStack (set);*loadReg (set, anyDataReg);*genarSized (BTST, set, expr.exprReg, -1);*setByte (codePtr - 1L,3SHORT (WORD (SHORT (LONGCARD (CodePtr () - codePtr)))));*relOp:= gt(END &ELSE (IF lconst THEN*IF inZZ (expr.exprConst.zz, lo, hi) THEN,prepareStackForLoad (set);,IF NOT set.zerobased THEN.subZZ (expr.exprConst.zz, lo);,END;,n:= expr.exprConst.zz.c DIV 8;,IF set.regset THEN.n:= SHORT (Size (set)) - 1 - n,END;,IF n > 0 THEN.(*$? Safety: assert (NOT set.regset);*).loadExprAddress (set, old);.makeIndir (set, n, FALSE),ELSIF (set.kind = stack) & (set.stackedSize > 1L) THEN.(*$? Safety: assert ((set.stackReg = A3) & ~set.up);*).incReg (A3, toZZ (- LONGINT (set.stackedSize), TRUE), 4);.changeStackToIndir (set),END;,genia (BTSTI, expr.exprConst.zz.c, set, -1);,IF n > 0 THEN.updateStack (old),END*ELSE,(* wenn expr auûerhalb des Set, ist Erg. immer FALSE *),makeFalse;,RETURN*END(ELSE*reloadPtr (expr);*runtimeElemSet (expr, set, in, lo);(END; &END;&deallocRegs (set);&restoreStack (expr);&deallocRegs (expr);&WITH set DO(item:= BoolPtr;(kind:= condFlags;(fpuFlags:= FALSE;(signed:= FALSE;(not:= FALSE;&END;&set.relOp:= relOp;&PushExpr (set)$END inSet; "PROCEDURE finish (VAR right, left: ExprDesc; op: Operator; sign: BOOLEAN);$BEGIN&deallocRegs (right);&restoreStack (left);&deallocRegs (left);&WITH right DO(item:= BoolPtr;(kind:= condFlags;(fpuFlags:= FALSE;(relOp:= op;(not:= FALSE;(signed:= sign;&END;&PushExpr (right)$END finish; "PROCEDURE cmp (op: Operator; signed: BOOLEAN; VAR left, right: ExprDesc);$BEGIN&IF rconst OR lconst THEN(IF rconst THEN (* damit wird 'right' immer zur Ergebnis-Expr *)*swapExpr (left, right);*rconst:= FALSE; lconst:= TRUE;*swapOp (op)(END;(IF rconst & nullZZ (right.exprConst.zz)(OR lconst & nullZZ (left.exprConst.zz) THEN*IF signed THEN,swapOp (op)*ELSE,IF (op = gt) OR (op = le) THEN.(* ist bei unsigned immer konstant *).cancelExpr (right);.restoreStack (right);.deallocRegs (right);.cancelExpr (left);.restoreStack (left);.deallocRegs (left);.WITH right DO0item:= BoolPtr;0kind:= constant;0exprConst.zz.over:= FALSE;0exprConst.zz.l:= 0;0exprConst.w:= WORD (op = le);0not:= FALSE;.END;.PushExpr (right);.RETURN,ELSIF op = lt THEN op:= ne,ELSIF op = ge THEN op:= eq END*END;*IF (right.kind = register) & (right.exprReg >= A0) THEN,loadReg (right, dataRegs)*ELSE,gena (TST, right, 0)*END;(ELSE*swapOp (op);*genia (CMPI, left.exprConst.zz.v, right, 0);(END;(restoreStack (right);&ELSE(swapOp (op);(loadReg (right, dataRegs);(restoreStack (right);(genar (CMP, left, right.exprReg)&END;&finish (right, left, op, signed);$END cmp; "PROCEDURE relop (n: CARDINAL; VAR op: Operator): BOOLEAN;$BEGIN&CASE n OF&| 18: op:= eq;&| 47, 20: op:= ne&| 21: op:= le;&| 22: op:= ge;&| 23: op:= lt;&| 24: op:= gt;&ELSE(RETURN FALSE&END;&RETURN TRUE$END relop;""VAR op: Operator;""PROCEDURE handleOp;$VAR&left, right: ExprDesc;&resultType: PtrItem;&itemno: CARDINAL;$BEGIN&PopExpr (right);&PopExpr (left); &checkCompat (left, right, resultType, rBdTyp);&&lconst:= left.kind = constant;&rconst:= right.kind = constant;&IF lconst & rconst OR (left.kind = constRef) & (right.kind = constRef) THEN(constantFold (op, left, right);&ELSE(itemno:= ItemNo (resultType);(IF itemno IN ItemSet {19,44,6,38,39,21,26,8,25,41,33,1,3,9,24,34,22,23,20,35,30} THEN*IF itemno IN ItemSet {19,44,6,38,39,21,26,8,25} THEN,IF (op # eq) & (op # ne) THEN.SyntaxError (rOpqOp),END;,IF itemno = 44 THEN.(* 8 Byte-Vergleich durchfÅhren *).IF ItemNo (right.item) # 44 THEN moveLocalProcOnA3 (right) END;.IF ItemNo (left.item) # 44 THEN moveLocalProcOnA3 (left) END;.runtimeCmp8Byte (left, right);.finish (right, left, op, FALSE);.RETURN,END*END;*prepareStackForLoad (right);*IF bothOnStack (left, right) THEN,loadReg (right, dataRegs);,restoreStack (right);*END;*reloadPtr (left);*prepareStackForLoad (left);*cmp (op, itemno IN ItemSet {33,1} (* signed types *), left, right);(ELSIF (itemno = 5) OR (itemno = 45) THEN*(* SET *)*setOp (op, left, right, resultType)(ELSIF (itemno = 2) OR (itemno = 40) THEN*(* REAL, LONGREAL *)*prepareStackForLoad (right);*IF bothOnStack (left, right) THEN,loadRealReg (right, floatRegs);,restoreStack (right);*END;*reloadPtr (left);*prepareStackForLoad (left);*realOp (op, right, left);(ELSE*SyntaxError (rOpTyp)(END&END$END handleOp; "PROCEDURE handleIn;$VAR&left, right: ExprDesc;&range: ConvDesc;$BEGIN&PopExpr (right);&PopExpr (left);&&IF (ItemNo (right.item) # 5) & (ItemNo (right.item) # 45) THEN SyntaxError (rOpTyp) END;&checkAsnCompat (left, RefType (right.item), range, rBdTyp);&&lconst:= left.kind = constant;&rconst:= (right.kind = constRef) OR (right.kind = constant);&IF lconst & rconst THEN(constantFold (in, left, right);&ELSE(inSet (left, right)&END$END handleIn; "PROCEDURE checkCondFlags;$VAR expr: ExprDesc;$BEGIN&LookExpr (expr);&IF expr.kind = condFlags THEN(PopExpr (expr);(loadReg (expr, dataRegs);(PushExpr (expr);&END;$END checkCondFlags; "BEGIN (* expression *)$InitLabels (false);$InitLabels (true);$InitLabels (falseNot);$InitLabels (trueNot);$simpleExpression ();$IF relop (CurrentSymbol.itemNo, op) THEN&GetSymbol;&checkCondFlags;&simpleExpression ();&handleOp;$ELSIF CurrentSymbol.itemNo = 53 (* IN *) THEN&GetSymbol;&simpleExpression ();&handleIn;$END;"END expression;   PROCEDURE hdlBool (VAR expr: ExprDesc;3VAR false, true, falseNot, trueNot: Labels; debug: BOOLEAN);"VAR target: Label;"BEGIN$AddLabelsTo (false, true);$AddLabelsTo (falseNot, trueNot);$IF expr.kind = constant THEN&Solve (true);&Solve (trueNot);$ELSE&IF expr.kind = condFlags THEN(loadReg (expr, dataRegs)&END;&IF unSolved (trueNot) THEN(loadReg (expr, dataRegs);(IF expr.not = FALSE THEN (* BRA des letzten Wertes hinter EORI erzeugen *)*genbcc (mapAlways (), FALSE, target);*MarkRef (target, true)(END;(Solve (trueNot);(expr.not:= TRUE;&END;&IF expr.not THEN(loadReg (expr, dataRegs);(genia (EORI, CARDINAL (1), expr, 0);(expr.not:= FALSE;&END;&IF unSolved (true) THEN(loadReg (expr, dataRegs);(Solve (true);&END;$END;$IF debug THEN&handleDebug (expr)$END"END hdlBool;   PROCEDURE VarExpression ();"VAR false, true, trueNot, falseNot: Labels;"PROCEDURE doBool;$VAR expr: ExprDesc;$BEGIN&PopExpr (expr);&hdlBool (expr, false, true, falseNot, trueNot,/NOT InConstExpr & generateDebugCode ());&PushExpr (expr)$END doBool;"BEGIN$expression (FALSE, false, true, falseNot, trueNot);$IF BooleanType (exprStack[exprSp].expr.item) THEN&doBool;$ELSE&(*$? Safety: assert (NOT (unSolved (true) OR unSolved (false)))*)$END;"END VarExpression;   PROCEDURE ConstExpression;"VAR false, true, trueNot, falseNot: Labels; old: BOOLEAN;"PROCEDURE get;$VAR expr: ExprDesc; size: LONGCARD;$BEGIN&PopExpr (expr);&IF (expr.kind # constant) AND (expr.kind # constRef) THEN(SyntaxError (rConXp)&END;&IF BooleanType (expr.item) THEN(hdlBool (expr, false, true, falseNot, trueNot, FALSE)&ELSE((*$? Safety: assert (NOT (unSolved (true) OR unSolved (false)))*)&END;&PushExpr (expr);$END get;"BEGIN$old:= InConstExpr;$InConstExpr:= TRUE;$expression (FALSE, false, true, falseNot, trueNot);$get;$InConstExpr:= old"END ConstExpression;   PROCEDURE BoolExpression (VAR false: Labels);"VAR true, trueNot, falseNot: Labels; debug: BOOLEAN;"PROCEDURE get;$VAR help, expr: ExprDesc; ptr: ADDRESS; target: Label;$BEGIN&PopExpr (expr);&IF NOT BooleanType (expr.item) THEN SyntaxError (rBolXp) END;&(*'* Anwendung durch IF, WHILE, UNTIL.'* In allen FÑllen wird im TRUE-Fall immer direkt hinter diese'* Expr. gesprungen, im FALSE-Fall werden die offenen Labels auf'* den Integer-Stack gebracht, so daû die IF/WHILE/UNTIL-Anweisung'* diese am Ende auflîsen kann (mit 'ToHere', gibt's auch in SYMBOL)'*)&IF debug THEN(hdlBool (expr, false, true, falseNot, trueNot, TRUE);&END;&IF expr.kind = constant THEN(IF BOOLEAN (expr.exprConst.w) = TRUE THEN*(*+* Alle Labels hierher, keine false-Labels Åbriglassen+*)*Solve (true);*Solve (false);(ELSE*(*+* Alle SprÅnge zum false-Label, dann Code-Erzeugung unterdrÅcken+* Da aber nicht sicher ist, daû nicht vielleicht doch Code erz.+* wird, wird zur Sicherheit vorher noch ein BRA zum false-Lbl erzeugt+* ~~~ die mîgl. Code-Erzeugung kînnte durch Vergleich der CodePtr+*   erkannt werden.+*)*genbcc (mapAlways (), FALSE, target);*MarkRef (target, false);*AddLabelsTo (true, false);*SuppressCode:= TRUE(END&ELSE(tstAndJmp (FALSE, expr, false, help, ptr);(Solve (true);&END;$END get;"BEGIN$GetSymbol;$debug:= NOT InConstExpr & generateDebugCode ();$expression (~debug, false, true, trueNot, falseNot);$get"END BoolExpression;   (* ************************************************************************* *) (* ************************************************************************* *)  PROCEDURE fitExpression (VAR expr, dest: ExprDesc; REF range: ConvDesc);"BEGIN$IF isSS (expr) & isStringVar (dest.item) THEN&terminateStringConst (expr, dest.item)$END;$PushExpr (dest);$fitValue (expr, range); (* Expand & Range-Check *)$PopExpr (dest);"END fitExpression;  PROCEDURE moveTo (VAR expr, dest: ExprDesc;2sync, fillUp, destOpenArr, oddDest: BOOLEAN;2REF range: ConvDesc);"(*#* sync:        TRUE -> Stack immer gerade halten#* fillUp:      TRUE -> Stack immer bis zur Dest-LÑnge auffÅllen#* destOpenArr: TRUE -> Strings brauchen nicht Null-terminiert werden#* oddDest:     TRUE -> 'dest' beginnt mit Sicherheit auf ungerader Adr.#*#* Wenn sync=TRUE und kein Byte-Copy oder oddDest, kann der MOVE auf gerade#* Werte aufgerundet werden, weil ein MOVE.B von der CPU eh einen Word-#* Zugriff macht.#*) "VAR l, sourceSize, destSize: LONGCARD; p: ADDRESS; mustCopy, byByte: BOOLEAN; "PROCEDURE callCopy (long: BOOLEAN);$BEGIN&runtimeConstCopy (expr, dest, long, sourceSize);$END callCopy; "PROCEDURE copyLoop (VAR source, dest: ExprDesc; size: LONGCARD);$$VAR elemSize: CARDINAL; n: LONGCARD; count: ExprDesc; a3, a7: LONGINT;$$BEGIN&(* Schleife erzeugen *)&IF byByte THEN(elemSize:= 1; n:= size&ELSE(elemSize:= 4; n:= size DIV 4L&END;&(* Kopierschleife direkt erzeugen *)&IF source.kind = constant THEN(changeConstantToConstRef (source, size);(changeToStack (source)&END;&initConstExpr (count, 2, toZZ (n-1L, FALSE));&loadReg (count, dataRegs);&a3:= A3Offset; a7:= A7Offset;&moveSingle (source, dest, elemSize);&INC (dest.stackedSize, LONG (elemSize) * (n-1L));&INC (A7Offset, (A7Offset-a7) * LONGINT (n-1L));&INC (A3Offset, (A3Offset-a3) * LONGINT (n-1L));&genDBcc (mapNever (), count.exprReg, -4);&deallocRegs (count);&DEC (size, n * LONG (elemSize));&IF size > 0L THEN(copy (source, dest, size, byByte)&END$END copyLoop;""PROCEDURE prepareCopy;$(*%* Bereitet Pointer fÅr Aufruf von 'copy' und 'copyLoop' vor:%* Ptr werden ggf. fÅr PostInc gesetzt.%* Nicht aufzurufen, wenn 'runtimeConstCopy' benutzt wird, weil%* im Runtime ggf. nochmal A3 benutzt wird, was aber hier schon%* durch die PostInc-Vorbereitung nicht mehr erlaubt wÑre.%*)$BEGIN&(* prÅfen, ob PostInc gemacht werden muû *)&IF dest.kind = stack THEN(IF expr.kind = stack THEN*IF NOT dest.up THEN,(* gen. MOVE -(A7),-(A3) *)*ELSE,(*$? Safety: assert (sourceSize = destSize);*),makePostInc (expr, expr.stackedSize (*das war mal: sourceSize*)).(* wenn mit 'stackedSize' nun irgendwo schiefgeht, dafÅr sorgen,/* daû stackedSize richtig gesetzt ist, denn 'sourceSize' darf/* nicht verw. werden, weil sonst in 'hdlArrayConstructor' nicht/* ein doppeltes Entfernen vom A3-Stack bei Var-Replikatoren/* verhindert werden kann (dort wird manuell A3 korrigiert und/* dann stackedSize auf 0 gesetzt, damit es hier nicht nochmal/* passiert *)*END(ELSE*makePostInc (dest, destSize)              (* dest: (An)+ *)(END&ELSE(changeToStack (dest);                     (* dest: (An)+ *)(IF expr.kind = stack THEN*(*$? Safety: assert (sourceSize = destSize);*)*makePostInc (expr, expr.stackedSize (*das war mal: sourceSize*)),(* Bei Problemen: siehe oben, anderer makePostInc-Aufruf *)(END;&END;&IF expr.kind # constant THEN(IF (expr.kind = register) & (expr.exprReg >= F0) THEN*(*$? Safety: assert (isReal (expr.item) & (fpu () = softReal));*)*deallocReg (expr.exprReg);*initPseudoRegExpr (expr, expr.item, expr.exprReg, FALSE);(END;(changeToStack (expr);           (* expr: (An)+, falls nicht -(An) *)&END;$END prepareCopy;""PROCEDURE prepareStacks;$BEGIN&IF sync THEN(syncStacks (expr, dest, TRUE)&ELSE(adaptStack (expr, sourceSize)&END;$END prepareStacks;""BEGIN$IF NOT destOpenArr THEN&fitExpression (expr, dest, range);$END;$reloadPtr (dest);$$sourceSize:= Size (expr);$IF destOpenArr THEN&destSize:= roundedUp (sourceSize)$ELSE&IF (dest.kind = stack) & sync THEN(destSize:= roundedSize (dest)&ELSE(destSize:= Size (dest)&END$END;$$(* Ob byteweise kopiert werden muû, muû schon hier ermittelt werden,%* weil durch die folg. Funktionen ggf. die Informationen darÅber%* verloren gehen kînnen. *)$byByte:= oddDest OR mustCopyByByte (expr) OR mustCopyByByte (dest);%(*~~~ hier kînnte optimiert werden: dies kommt vor, wenn daten f. value constr. auf den stack kommen.+wenn dabei ein datum ungerader lÑnge war, steht SP nun auf ungerader Adr. Wenn nun eine Konst.+aufgeladen wird, brÑuchte nur das 1. Byte byteweise kopiert werden, der Rest geht dann doch wortweise. *) $IF sync & ODD (sourceSize) & (sourceSize < destSize)$& (expr.kind # register) THEN&(* Falls expr eine ungerade Grîûe hat, wird sie um eins vergrîûert, damit'* - aus einem MOVE.W und einem MOVE.B ein MOVE.L wird (nicht nur bei'*   Stack-Pushs sondern auch bei Zuw. auf Var);'* - bei Stack-Pushs kein extra Sync mehr erzeugt werden braucht.'* Darf nur bei Konstanten und bei Laden aus Memory, jedoch nicht bei'* Move von Reg nach Memory/Stack. *)&IF (sourceSize = 3) & NOT byByte&OR (dest.kind = stack))AND (    (sourceSize = 1) & NOT ((expr.kind = memory) & expr.mayBeOdd)/OR (sourceSize > 1) & NOT byByte ) THEN(IF expr.kind = constant THEN*shiftLeft (expr, 1);(END;(INC (sourceSize);(IF destSize < sourceSize THEN destSize:= sourceSize END&END$END; $mustCopy:= TRUE;$IF (expr.kind = dest.kind) THEN&CASE expr.kind OF&| register: mustCopy:= expr.exprReg # dest.exprReg&| stack:    mustCopy:= (expr.stackReg # dest.stackReg) OR=(expr.up = dest.up);&ELSE&END;$END; $IF mustCopy THEN"&(*'* ist Zuweisung mit einer einzigen Instr. durchfÅhrbar?'*)&IF (sourceSize = 1L)&OR NOT byByte AND (sourceSize # 3L) AND (sourceSize <= 4L)&OR (expr.kind = register) & (expr.exprReg >= F0) & (fpu () # softReal)&OR (dest.kind = register) & (dest.exprReg >= F0) & (fpu () # softReal)&THEN((IF sync THEN*syncStacks (expr, dest, TRUE)(ELSE*(*$? Safety: assert (    (expr.kind # stack) OR (expr.stackReg # A7)?AND (dest.kind # stack) OR (dest.stackReg # A7) );*)*adaptStack (expr, sourceSize)(END;(IF (expr.kind = register) & (expr.exprReg >= F0)(OR (dest.kind = register) & (dest.exprReg >= F0) THEN*(*$? Safety: assert (isReal (expr.item));*)*assignRealReg (expr, dest);(ELSE*copy (expr, dest, sourceSize, FALSE);     (* MOVE.x expr,dest *)(END;(IF fillUp & ~destOpenArr & isSS (expr) THEN*(*~~~ nur, wenn auf A3? *)*fillStack (dest, destSize);(ELSIF sync THEN*syncStacks (expr, dest, FALSE)(END;(&ELSE((IF byByte & (dest.kind = stack) THEN*(* wenn mehrere Bytes mit "-(A7)" kopiert werden mÅssen, *+* muû der SP dazu in ein Hilfsreg. geladen werden       *)*makePostInc (dest, destSize);(END; (IF expr.kind = constRef THEN*(*~~~ null-const erkennen! -> constante cutten und clr-loop gen.! *)(END;((IF NOT byByte & (sourceSize <= 16L) OR byByte & (sourceSize <= 4L) THEN*(* Direkt kopieren, wenn <= 16 Byte, aber nicht bei Byte-Daten *+* Somit entstehen bis zu 4 MOVE.L                             *)*prepareCopy;*prepareStacks;*copy (expr, dest, sourceSize, byByte)(ELSE*IF sourceSize >= 256L THEN,(* ab 256 Byte kann ggf. MOVEM-Routine aus Block-Modul verw. werden *),(* Runtime: Copy (4MB), prÅfen, ob Byte/Long-Moves *),IF sync THEN syncStacks (expr, dest, TRUE) END; (* nicht prepareStacks, weil 'adaptStack' nicht darf *),callCopy (TRUE);*ELSE,IF byByte & (sourceSize >= 20L) (*~~~ besten Wert ausprobieren *) THEN.(* bei groûen Byte-Mengen soll Runtime-Routine prÅfen, ob sie */* doch wortweise kopieren kann                               *).(* Runtime: Copy (64KB), prÅfen, ob Byte/Long-Moves *).IF sync THEN syncStacks (expr, dest, TRUE) END; (* nicht prepareStacks, weil 'adaptStack' nicht darf *).callCopy (FALSE);,ELSE.prepareCopy;.prepareStacks;.copyLoop (expr, dest, sourceSize);,END*END(END;(IF fillUp & ~destOpenArr & isSS (expr) THEN*(*~~~ nur, wenn auf A3? *)*fillStack (dest, destSize);(ELSIF sync THEN*syncStacks (expr, dest, FALSE)(END&&END; (* ... ELSE ... *)&$END; (* IF mustCopy *)""END moveTo;   PROCEDURE moveToVar (VAR expr, var: ExprDesc; range: ConvDesc);"(*#* kopiert Datum nach 'var'. Bei String-Konstanten wird entsprechend#* nur der benîtigte Teil kopiert.#*)"BEGIN$moveTo (expr, var, FALSE, FALSE, FALSE, FALSE, range);$deallocRegs (expr);"END moveToVar;   PROCEDURE addToVar (expr: ExprDesc; VAR st: ExprDesc;4odd, more: BOOLEAN; VAR range: ConvDesc);"(*#* Kopiert Datum als Teil einer Variablen ('st' muû Stack sein!).#* Wird von value constructors benutzt#*)"BEGIN$(*$? Safety: assert ((st.kind = stack) & (st.up));*)$moveTo (expr, st, FALSE, more, FALSE, odd, range);$deallocRegs (expr);"END addToVar;   PROCEDURE makeStackIndir (VAR expr: ExprDesc; ofs: LONGINT);"(*#* macht aus Stack-Adressierung eine indirecte Adressierung mit Offset#*)"BEGIN$WITH expr DO&(*$? Safety: assert ((kind = stack) & (restoreAfterUse = 0L));*)&kind:= memory;&baseReg:= stackReg;&mayBeOdd:= FALSE;&mode:= d16An;&disp:= ofs;$END"END makeStackIndir;   PROCEDURE loadOnA7 (VAR expr: ExprDesc; range: ConvDesc; VAR size: LONGCARD);"(*#* Kopiert Datum auf den A7-Stack. 'expr' zeigt hinterher auf das Datum#* Wird von 'forStatement' benutzt#*)"VAR st: ExprDesc;"BEGIN$initStackExpr (st, expr.item, A7);$moveTo (expr, st, TRUE, TRUE, FALSE, FALSE, range);$deallocRegs (expr);$size:= st.stackedSize;$makeStackIndir (st, 0);$expr:= st"END loadOnA7;  PROCEDURE loadOnA3 (VAR expr: ExprDesc; range: ConvDesc);"(*#* Kopiert Datum auf den A3-Stack. Der Stack wird immer aufgefÅllt.#* Wird z.B. von RETURN und öbergaben an alte Routinen im Compiler#* (z.B. CASE) benutzt.#* 'expr' zeigt hinterher auf den A3-Stack#*)"VAR st: ExprDesc; t: PtrItem;"BEGIN$t:= expr.item;$initStackExpr (st, range.destType, A3);$moveTo (expr, st, TRUE, TRUE, FALSE, FALSE, range);$deallocRegs (expr);$expr:= st;$WITH expr DO&(*$? Safety: assert ((kind = stack) & (stackReg = A3));*)&item:= t;&up:= FALSE$END;"END loadOnA3;   PROCEDURE moveOpenArray (VAR expr, parm, data: ExprDesc; mustCopy: BOOLEAN);"(*#* expr: Das Argument#* parm: Stack f. Parameter#* data: Stack f. Zwischenablage#*)"VAR count, help, highPtr: ExprDesc;&exprBase, parBase, exprType, parType: PtrItem;&opcode, n, instrs, instrSize: CARDINAL;&size: LONGCARD;&identical: BOOLEAN;&odd, addedOne: BOOLEAN;  (*"PROCEDURE pushPtr (r: RegType);$(* trÑgt Pointer auf Datum nach, wenn value als Kopie Åbergeben wird *)$VAR src, ptr: ExprDesc;$BEGIN&initRegExpr (ptr, 4, parm.stackReg);&makeIndir (ptr, -LONGINT (parm.stackedSize), FALSE);&initRegExpr (src, 4, r);&genMOVEaa (src, ptr, 4);$END pushPtr; *) "PROCEDURE makePtr (VAR ptr: ExprDesc);$BEGIN&initRegExpr (ptr, 4, parm.stackReg);&makeIndir (ptr, -LONGINT (parm.stackedSize), FALSE);$END makePtr; "PROCEDURE loadAndPushHigh (VAR highPtr, high: ExprDesc; mustExtend: BOOLEAN;6VAR destHighSize: CARDINAL);$(* hier wird high-wert ggf. auf den dest-high-wert expandiert *)$(* folg. Vars von auûeren werden benutzt/verÑndert:%* parType, parBase, exprType, exprBase, identical, parm *)$VAR destHighType: PtrItem;(help: ExprDesc;(exprSize, fact: LONGCARD;(n: CARDINAL;$BEGIN&(*'* Drei Mîglichkeiten:'*  1. beide sind ein ARRAY/LONGARRAY OF ARRAY ...'*  2. beide sind ein ARRAY/LONGARRAY OF T'*  3. Der Par ist ein ARRAY/LONGARRAY OF BYTE/WORD/LONGWORD'* Bei Fall 1. und 2. wird lediglich der High-Wert auf den Stack geladen,'* bei 3. wird er ggf. noch mit der Jokergrîûe skaliert'*)&exprBase:= OpenArrayType (exprType);&parBase:= OpenArrayType (parType);&IF isOpenArray (exprBase) THEN mustExtend:= TRUE END;&IF identical & ~mustCopy THEN mustExtend:= FALSE END;&IF isLongOpenArray (parType) THEN(destHighType:= CardPtr;(destHighSize:= 4&ELSE(IF mustExtend THEN*destHighType:= CardPtr;(ELSIF TypeLength (parBase) = 1 THEN*destHighType:= SIntPtr(ELSE*destHighType:= SCardPtr(END;(destHighSize:= 2;(IF Size (highPtr) > 2L THEN SyntaxError (rLgAOv) END&END;&IF isLongOpenArray (exprType) THEN highPtr.item:= CardPtr ELSE highPtr.item:= SCardPtr END;&IF mustExtend THEN n:= 4 ELSE n:= destHighSize END;&IF identical & ~mustCopy THEN(moveSingle (highPtr, parm, destHighSize);       (* MOVE (Ap)+,(A3)+ *)&ELSE(copyRegExt (highPtr, high, dataRegs, n);        (* MOVE (Ap)+,Dh *)&END;&IF NOT varCompat (exprBase, parBase)&AND NOT (isOpenArray (exprBase) & isOpenArray (parBase)) THEN((* wenn 'expr' noch mehr Dims hat, diese alle miteinander multipl. *)(WHILE isOpenArray (exprBase) DO*(* in diesem Fall ist 'mustExtend' immer TRUE *)*incReg (high.exprReg, toZZ (1,FALSE), 4);*IF isLongOpenArray (exprType) THEN highPtr.item:= CardPtr ELSE highPtr.item:= SCardPtr END;*copyRegExt (highPtr, help, dataRegs, 4);*incReg (help.exprReg, toZZ (1,FALSE), 4);*varMul (mul, help, high, FALSE, CardPtr);*PopExpr (high);*incReg (high.exprReg, toZZ (-1,TRUE), 4);*exprBase:= OpenArrayType (exprBase);(END;((* Typen sind nicht gleich groû - ggf. HIGH umrechnen: *)(exprSize:= TypeLength (exprBase); (* Grîûe der Elems vom Source-Array *)(n:= jokerSize (ItemNo (parBase));(IF n = 0 THEN (* kein Joker *) SyntaxError (rParTy) END;(IF exprSize MOD LONG (n) # 0L THEN SyntaxError (rOddAr) END;(fact:= exprSize DIV LONG (n);&ELSE(fact:= 1&END;&IF ~identical OR mustCopy THEN((* hier wird auch ggf. Expand gemacht: *)(constMul (high, destHighType, toZZ (fact, FALSE), FALSE);(constAdd (high, destHighType, toZZ (fact-1, FALSE), FALSE);(moveSingle (high, parm, destHighSize);          (* MOVE.x Dh,(A3)+ *)(IF ~mustCopy THEN deallocRegs (high) END&END;$END loadAndPushHigh; "VAR parSize, rn, dims: CARDINAL;&fact, exprSize: LONGCARD;&"BEGIN (* moveOpenArray *)$(*%* Zuerst wird herausgefunden, ob Expr und Parameter kompatibel sind%* und ob die HIGH-Werte identisch sind, weil dann eine optimierte%* Zuweisung erfolgen kann.%*%* LONGARRAY und ARRAY sind kompatibel in beiden Richtungen, ggf. wird%* ein Range-Error bei Laufzeit erkannt (bisher ist nur eine Richtung%* mîglich).%* ARRAY OF BYTE/CHAR erlauben nur 32768 Elemente!%*%* Allgemeine Syntax bei Weitergabe von Open-Arrays:%*   Expr:  {ARRAY Range OF} TX%*   Parm:  {ARRAY OF | LONGARRAY OF} TP%* Expr und Parm mÅssen die gleiche Anzahl Dimensionen haben, es sei%* denn, TP ist ein Joker-Type - dann dÅrfen bei Expr noch weitere%* Dim. folgen.%* Das wird geprÅft, indem fÅr jede Open-Array-Dim. beim Parm%* auch eine bei Expr verlangt wird.%*%* Ist TP kein Joker-Type, mÅssen TX & TP identisch sein und keine%* HIGH-Umrechnung ist nîtig. Bei Jokern wird der letzte HIGH-Wert%* bei der öbergabe noch mit dem Faktor TSIZE(TX)/TSIZE(TP) erhîht.%*)$$(*$? Safety: assert (expr.kind = memory);*) (* ist ja schlieûlich eine Var, oder? *)$odd:= expr.mayBeOdd;         (* 'assert' wird hierfÅr benîtigt *)$identical:= TRUE; (* -> HIGH-Werte sind identisch *)$dims:= 0;$parType:= data.item;$(*$? Safety: assert (isOpenArray (parType));*)$exprType:= expr.item;$REPEAT&INC (dims);&parBase:= OpenArrayType (parType);&exprBase:= OpenArrayType (exprType);&IF NOT isOpenArray (exprType) THEN SyntaxError (rArDXp) END;&IF isLongOpenArray (parType) # isLongOpenArray (exprType) THEN(identical:= FALSE;&END;&exprSize:= TypeLength (exprBase); (* Grîûe der Elems vom Source-Array *)&IF NOT varCompat (exprBase, parBase) THEN((* Typen sind nicht gleich groû - ggf. HIGH umrechnen: *)(n:= jokerSize (ItemNo (parBase));(IF n = 0 THEN (* kein Joker *) SyntaxError (rParTy) END;(IF exprSize MOD LONG (n) # 0L THEN SyntaxError (rOddAr) END;(fact:= exprSize DIV LONG (n);(IF fact # 1L THEN*identical:= FALSE;(END&ELSE(fact:= 1&END;&&parType:= parBase;&exprType:= exprBase;$UNTIL NOT isOpenArray (parType);$$IF identical & (dims = 1) & (exprSize = 1L) THEN$&(*'* Es ist ein eindim. Byte-Array mit identischen HIGH-Grîûen zu Åbergeben'*)&IF isLongOpenArray (expr.item) THEN n:= 8 ELSE n:= 6 END;&IF mustCopy THEN((* Das Kopieren wird von einer Runtime-Routine erledigt, die)* lediglich die Adr. v. 'expr' erhÑlt *)(IF isLongOpenArray (expr.item) THEN*rn:= CLOP(ELSE*rn:= CWOP(END;(IF parm.stackReg # A3 THEN*SyntaxError (rNImpY)*(* &&& Runtime-Routinen f. Datum->A3 fehlen+*   auûerdem: dann muû beachtet werden, daû ggf. 'parm' ein+*   temp. hilfsreg verwendet und die Copy-Routine ggf. ein+*   spilling auslîst (z.B., wenn ein REF-Parm an einen value-oparr-+*   parm Åbergeben wird). wenn aber das hilfsreg zuerst gespillt+*   wird und dann die daten auf den stack geladen werden, dann+*   klappt das rÅckladen nicht mehr so einfach.+*   Hierzu muû auch erstmal "PushExpr (parm)" vor dem evtl. Spilling+*   erfolgen!+*)*(* DEC (A7Offset, n); *)(ELSE*INC (A3Offset, n);(END;(runtimeCopyOpenArray (expr, rn); (* kopiert Daten nach -(A7) *)&ELSE((* Ptr und HIGH-Wert werden wie bei einer Zuwsg. auf den Stack kopiert*)(changeToStack (expr);(copy (expr, parm, n, FALSE);&END;&deallocRegs (expr);&$ELSE$&initOpenArrayAccess (expr, TRUE);&initHighExpr (expr, highPtr);&&IF parm.stackReg = A7 THEN(SyntaxError (rNImpY) (*@@ Pushs rÅckwÑrts: HIGH zuerst!*)&END;&&(*/// quick-and-dirty werden erstmal der pointer und der high-wert auf'*    den A3-stack geschmissen!! natÅrlich mÅssen die werte auch wahl-'*    weise auf den A7-stack kommen oder bei zuw. an opArr-Var sogar'*    noch ganz anders ausgewertet werden! *)&IF NOT mustCopy THEN((* natÅrlich kann der Pointer nur jetzt schon Åbergeben werden,)* wenn nicht erst eine Kopie angelegt werden muû -- fÅr diesen)* Fall wird hier erstmal nur Platz fÅr den Pointer geschaffen,)* der dann erst spÑter init. wird. *)(moveAddress (expr, parm);                 (* MOVE.L An,(A3)+ *)&ELSE(incReg (parm.stackReg, toZZ (4L, FALSE), 4);&END;&INC (parm.stackedSize, 4);&&PushExpr (expr);&&parType:= data.item;&exprType:= expr.item;&&loadAndPushHigh (highPtr, count, FALSE, n);&&addedOne:= FALSE;&WHILE isOpenArray (parBase) DO(parType:= parBase;(exprType:= exprBase;(IF mustCopy & NOT addedOne THEN*constAdd (count, CardPtr, toZZ (1L, FALSE), FALSE);*addedOne:= TRUE;(END;(loadAndPushHigh (highPtr, help, TRUE, n);(IF mustCopy THEN*constAdd (help, CardPtr, toZZ (1L, FALSE), FALSE);*PushExpr (highPtr);*varMul (mul, help, count, FALSE, CardPtr);*PopExpr (count);*PopExpr (highPtr);*reloadPtr (highPtr);(END&END;&&deallocRegs (highPtr); (* Damit wird der Ptr auf die High-Werte freigegeben *)&&PopExpr (expr);&reloadPtr (expr);&&size:= TypeLength (parBase);&IF (size MOD 4L = 0L) THEN (* damit sind Byte-Types autom. ausgeschlossen *)(instrSize:= 4;(size:= size DIV 4L&ELSIF (size MOD 2L = 0L) THEN (* damit sind Byte-Types autom. ausgeschlossen *)(instrSize:= 2;(size:= size DIV 2L&ELSE(instrSize:= 1;&END;&&IF mustCopy THEN&(IF FALSE (*~~~ erstmal immer Runtime benutzen, weil kÅrzer;2*    am Ende sollte dies Åber option gesteuert werden kînnen *)(& NOT addedOne & (Size (count) = 2L) & (size = 1L) THEN*(* Sonderfall: ARRAY OF BYTE/CHAR -> Kopierschleife gen. *)(((*~~~*(*+* Ist die Source kein Var/Ref-Parameter, liegt das Datum auf dem+* Stack und kann daher immer word-weise kopiert werden. dazu wird+* einfach die anzahl durch 2 geteilt. das gleich wird auch bei andern+* Daten gemacht, nur werden dann immer zwei MOVE-Instr. auf einmal+* erzeugt. Dies erspart die Gen. eines Sync und auûerdem kann immer+* ein SUB.W gemacht werden, ohne daû bei Werten > 32K falsch gerechnet+* wÅrde!+*)*opcode:= LSRI;*getSizeAt6 (2, opcode);*genr (opcode + $200 * 1, count.exprReg);  (* "LSR.W #1,Dcount" *)**IF data.stackReg = A7 THEN,(* A7-Stack muû vor dem Kopieren runtergesetzt werden *),FOR n:= 1 TO 2 * instrSize DO.(* wir ziehen count instrSize-mal von A7 ab *).genSUBA (FALSE, count.exprReg, A7); (* "SUBA.W Dcount,A7" *),END;,incReg (A7, toZZ (LONG (-2 * INTEGER(instrSize)), TRUE), 4);,(* ~~~ an dieser stelle ggf. stack-overflow prÅfen. *),initRegExpr (help, 4, A7);,loadReg (help, addrRegs);,makeIndir (help, 0, FALSE);,changeToStack (help)*ELSE,help:= data;*END;**(*+* Nun kann der Pointer nachinit. werden.+* Dazu wird folg. gen: "MOVE.L A3/A7,-x(Aparm)"+*)*pushPtr (data.stackReg);**IF NOT odd & (instrSize = 1) OR (instrSize = 2) THEN,instrSize:= instrSize * 2;      (* aus MOVE.B mach MOVE.W, .W -> .L *),instrs:= 1;*ELSE,instrs:= 2                      (* sonst kodiere den Befehl doppelt *)*END;**changeToStack (expr);*FOR n:= 1 TO instrs DO,genMOVEaa (expr, help, instrSize);*END;*genDBcc (mapNever (), count.exprReg, -2 -(2 * INTEGER(instrs)));**IF data.stackReg = A7 THEN,deallocRegs (help)*END;((*)((ELSE(*(*+* Bei grîûeren Basistypen oder mehreren Dims: Runtime aufrufen+* Dabei gibt es folg. Variable:+*  - je nach instrSize wird @PUnB, @PUnW oder @PUnL aufgerufen,+*    das 'n' steht fÅr '3' oder '7', je nach Destination-Stack.+*  - In A1 wird Ptr auf Source Åbergeben+*  - In D1.L wird Elementanzahl, jeweils f. Byte/Word/Long, Åbergeben+*  - In A0 wird Pointer auf Ptr f. erzeugte Kopie Åbergeben+*  - A2 kann von der Routine benutzt werden+*)*IF size # 1L THEN,constMul (count, CardPtr, toZZ (size, FALSE), FALSE);,IF NOT addedOne THEN.constAdd (count, CardPtr, toZZ (size, TRUE), FALSE);,END*ELSIF NOT addedOne THEN,constAdd (count, CardPtr, toZZ (1, TRUE), FALSE);*END;*makePtr (help);    (* -x(A3): Adr von Ptr der Array-Kopie *)*runtimeCopyOnStack (help, expr, count, instrSize, data.stackReg = A7);*deallocRegs (help);(END;(deallocRegs (count)&END;&deallocRegs (expr);$$END; (* IF identical & (dims = 1) ELSE *)$"END moveOpenArray; (*$D-*)   CONST MaxDynOpArrays = 10;  TYPE StackDesc = RECORD3parm, data: ExprDesc;3forParms: BOOLEAN; (* FALSE: value constructors *)3odd: BOOLEAN;      (* TRUE: letzter Push lieû SP ungerade *)3openArray: BOOLEAN;3parmIsA3: BOOLEAN;3parmUsed: LONGCARD;3dataUsed: LONGCARD;3dataUsedDyn: BOOLEAN;3stackOffset: LONGINT;3firstParm: BOOLEAN;3dataSP: RegType;   (* A3 oder A7 *)1END;  PROCEDURE moveToStack ((*kein VAR!*) expr: ExprDesc; VAR stacks: StackDesc;7REF range: ConvDesc; ref, reg: BOOLEAN);"(*#* Die Expr wird als Parameter auf den Parm-Stack gebracht. Wenn es ein#* Open Array Parameter ist, wird der Wert auf den Hilfsstack und seine#* Ref. auf den Parm-Stack gebracht.#* Wenn 'ref' TRUE, wird nicht der Wert, sondern dessen Referenz#* auf den Stack gelegt, bei Konstanten werden diese dann ggf. im#* Code abgelegt.#* Bei String-Konstanten wird nur dann, wenn der Wert (ref = FALSE)#* auf den Parameter-Stack soll, der Stack passend aufgefÅllt -- bei#* Ablage auf den Hilfs-Stack wird nur soviel draufgelegt, wie nîtig.#*#* 'expr' wird auf jeden Fall freigegeben (mit 'deallocRegs')!#*) "VAR ofs: LONGINT;&noCheck, mustCopy: BOOLEAN;&r: RegType;&help: ExprDesc;&regs: RegSet;&"BEGIN$mustCopy:= NOT ref; (* -> Datum muû kopiert werden. *)$noCheck:= FALSE;$$IF stacks.dataUsedDyn THEN&(* gesicherten SP ins Reg laden, falls er durch spill auf den Stack kam *)&PopExpr (help);&loadReg (help, dataRegs);&PushExpr (help)$END;$$IF ref & (expr.kind = register) THEN&(*'* Wenn eine REF-öbergabe verlangt ist, der Wert aber in einem'* Reg steht, muû er trotzdem auf den Stack gelegt werden'*)&mustCopy:= TRUE;$ELSIF (expr.kind = stack) THEN&IF expr.stackReg = A3 THEN(expr.up:= FALSE; (* damit der Wert ggf. mit "-(A3)" geholt wird *)((* Datum liegt auf A3-Stack *)(IF stacks.parmIsA3 THEN*IF stacks.openArray OR ref THEN,(* Ref soll auf A3-Stack *),(*&&& das geht noch nicht -- erklÑrung siehe unten bei "››1"-*mustCopy:= NOT stacks.firstParm (* umkopieren, wenn schon Parms auf A3 *)-*  stattdessen&&&: *) mustCopy:= TRUE; noCheck:= TRUE;*ELSE,(* Datum soll auf A3-Stack *),IF valueFitting (range) THEN.stacks.odd:= FALSE;.mustCopy:= FALSE (* wenn's paût, ist kein move mehr nîtig *),END*END(ELSE*IF stacks.openArray OR ref THEN,(* Ref soll auf A7-Stack -> kein move nîtig *),mustCopy:= FALSE*END(END&ELSE((*$? Safety: assert (expr.stackReg = A7); *)(expr.up:= TRUE; (* damit der Wert ggf. mit "(A7)+" geholt wird *)((* Datum liegt auf A7-Stack *)(IF stacks.parmIsA3 THEN*IF stacks.openArray OR ref THEN,(* Ref soll auf A3-Stack -> kein move nîtig *),mustCopy:= FALSE*END(ELSE*IF stacks.parm.stackReg = A7 THEN,(* wenn mit Hilfsreg kopiert wird, muû immer kopiert werden,-* das Datum darf nicht so auf dem A7 verbleiben! *),IF stacks.openArray OR ref THEN.(* Ref soll auf A7-Stack *).(*&&& das geht noch nicht -- erklÑrung siehe unten bei "››1"/*mustCopy:= NOT stacks.firstParm (* umkopieren, wenn schon Parms auf A3 *)/*  stattdessen&&&: *) mustCopy:= TRUE; noCheck:= TRUE;,ELSE.(* Datum soll auf A7-Stack *).IF valueFitting (range) THEN0stacks.odd:= FALSE;0mustCopy:= FALSE (* wenn's paût, ist kein move mehr nîtig *).END,END*END(END&END$END;$$IF isOpenArray (expr.item) THEN&(*$? Safety2: assert (NOT reg); *)&(*'* Source ist ein Open Array. Wird normalerweise an einen Open-Array-'* Parameter Åbergeben.'* Dies kann aber auch vorkommen, wenn eine Open-Array-Var auf eine'* andere oder ein Open Array-Parameter an eine solche Var zugewiesen'* wird.'*)&IF mustCopy & NOT stacks.dataUsedDyn THEN((* bei ersten Open-Array wird der alte SP nach D0 gerettet *)((* "MOVE.L A7/A3,An" *)(IF stacks.parmIsA3 THEN*GlobalA7Hidden:= TRUE; (* nun kein A7-relativer Zugriff mehr mîglich. *)*LocalA7Hidden:= TRUE; (* nun kein A7-relativer Zugriff mehr mîglich. *)*LocalA7WhenHidden:= A7Offset;*stacks.stackOffset:= A7Offset;*r:= A7(ELSE*stacks.stackOffset:= A3Offset;*r:= A3(END;(initRegExpr (help, 4, r);(loadReg (help, dataRegs+addrRegs);(stacks.dataUsedDyn:= TRUE;(PushExprNoSpill (help)&ELSIF stacks.dataUsedDyn THEN(PopExpr (help);(PushExprNoSpill (help)&END;&moveOpenArray (expr, stacks.parm, stacks.data, mustCopy);&IF stacks.parmIsA3 THEN(stacks.parm.stackedSize:= 0&END;&IF stacks.dataUsedDyn THEN(PopExpr (help);(PushExpr (help)&END;&$ELSE&&IF mustCopy THEN((* Value-Argument -> erstmal den Wert auf den Stack bringen *)(IF stacks.openArray OR ref THEN*(* Bei REF/VAR/Open Array Parameter muû das Datum auf den Hilfs-Stack *)*IF stacks.openArray THEN,(* FÅr 'ref' wird schon in 'call' der Stack geprÅft.-* >> TT 30.05.93: Nicht mehr - aber der Fall, daû 'mustCopy=TRUE'-*    und 'noCheck' = FALSE ist, kommt hier bei REF-Parms eh nicht-*    vor. Trotzdem wird sicherheitshalber der Stack-Check auch bei-*    REF-Parms gemacht, falls noCheck=FALSE.-* Allerdings wird der Check nur gemacht, wenn Wert wirklich-* auf Stack kopiert wird und nicht nur einfach von A3 nach A7-* verschoben wird: *)*END;*IF NOT noCheck THEN checkStack (Size (expr)) END;*PushExpr (stacks.parm);*moveTo (expr, stacks.data, stacks.forParms, FALSE, TRUE, FALSE, range);*deallocRegs (expr);*PopExpr (stacks.parm);*reloadPtr (stacks.parm);*expr:= stacks.data;*expr.stackReg:= stacks.dataSP(ELSE*(* Bei Value Parameter muû das Datum auf den Parameter-Stack *)*WITH stacks DO,IF reg THEN.fitExpression (expr, parm, range);.IF usesTempRegs (expr) THEN0IF isReal (expr.item) THEN2regs:= floatRegs0ELSIF isPointer (expr.item) THEN2regs:= addrRegs0ELSE2regs:= dataRegs0END;0loadReg (expr, regs).END;,ELSE.moveTo (expr, parm, forParms, TRUE, FALSE, odd, range);.odd:= NOT forParms AND XOR (odd, ODD (parm.stackedSize));,END;,IF parmIsA3 THEN.(* diese Daten werden vom Aufgerufenen abgerÑumt *).parm.stackedSize:= 0,END;*END;(END;&ELSE((* evtl. Datum auf Stack wird nicht vom Aufgerufenen abgerÑumt *)(IF (expr.kind = stack) THEN*IF NOT reg & (stacks.openArray OR ref) THEN,IF stacks.parmIsA3 THEN.stacks.parm.stackedSize:= expr.stackedSize,ELSE.stacks.data.stackedSize:= expr.stackedSize,END*ELSIF expr.stackReg = A7 THEN,stacks.parm.stackedSize:= expr.stackedSize*END(END;&END; &IF ref OR stacks.openArray THEN((* Referenz von Datum auf Parameter-Stack bringen *)(IF expr.kind = stack THEN*IF expr.stackReg = A3 THEN,(* Datum auf A3 -> "PEA -size(A3)" *),ofs:= -LONGINT (expr.stackedSize)*ELSE,(* Datum auf A7 -> "MOVE.L A7,(A3)+" *),ofs:= 0*END;*makeStackIndir (expr, ofs);(END;(IF reg THEN*loadAddress (expr)(ELSE*moveAddress (expr, stacks.parm);*IF NOT stacks.parmIsA3 THEN,INC (stacks.parm.stackedSize, 4);*END;(END;&END;&&IF reg THEN(PushExpr (expr)    (* Reg-Parms werden erst spÑter richtig geladen *)&ELSE(deallocRegs (expr)&END$$END;"END moveToStack;    PROCEDURE initStacks (VAR stacks: StackDesc; forCall: BOOLEAN;6parmSP: RegType; length: LONGCARD; upwd: BOOLEAN);"(*#* Legt bei Beginn von Parameter-Liste die beiden Stacks f. Parameter#* und Ref-Daten (z.B. f. Open Arrays) an.#* 'forCall': TRUE > Daten f. Parm-öbergabe; FALSE > Daten f. value constr.#* 'parmSP': Stack-Register, auf den die Parameter kommen.#* 'length' muû, falls parmSP=A7 und mehr als ein Parameter folgen,#*   die Anzahl der auf dem Stack benîtigten Bytes enthalten, damit gleich#*   der Stack entspr. vorbereitet werden kann.#* 'upwd': TRUE, wenn unbedingt (An)+ verwendet werden soll#*)"BEGIN$IF parmSP = A3 THEN&stacks.dataSP:= A7;$ELSE&(*$? Safety: assert (parmSP = A7);*)&stacks.dataSP:= A3$END;$WITH stacks DO&forParms:= forCall;&odd:= FALSE;&parmIsA3:= (parmSP = A3);&parmUsed:= 0;&dataUsed:= 0;&dataUsedDyn:= FALSE;&firstParm:= TRUE;&initStackExpr (parm, NIL, parmSP);&initStackExpr (data, NIL, dataSP);&IF upwd THEN(makePostInc (parm, length)&END$END"END initStacks;  PROCEDURE setParType (VAR stacks: StackDesc; type: PtrItem);"(*#* Wird aufgerufen, um Parameter-Type mitzuteilen#*)"BEGIN$IF type # NIL THEN&stacks.openArray:= isOpenArray (type);&IF stacks.openArray THEN(WITH stacks.parm DO*item:= CardPtr;*stackedSize:= 0(END;(initStackExpr (stacks.data, type, stacks.dataSP);&ELSE(WITH stacks.parm DO*item:= type;*stackedSize:= 0(END;(initStackExpr (stacks.data, type, stacks.dataSP);&END$END"END setParType;  PROCEDURE pushStacks (VAR stacks: StackDesc);"(*#* legt SP-Beschreibungen mit 'PushExpr' ab, damit ggf. Spilling geht#*)"BEGIN$PushExpr (stacks.parm);$PushExpr (stacks.data);"END pushStacks;  PROCEDURE popStacks (VAR stacks: StackDesc);"BEGIN$PopExpr (stacks.data);$PopExpr (stacks.parm);"END popStacks;  PROCEDURE reloadStackPtrs (VAR stacks: StackDesc);"BEGIN$reloadPtr (stacks.data);$reloadPtr (stacks.parm);"END reloadStackPtrs;   PROCEDURE updateStacks (VAR stacks: StackDesc);"BEGIN$WITH stacks DO&INC (parmUsed, parm.stackedSize);&IF NOT stacks.dataUsedDyn THEN INC (dataUsed, data.stackedSize) END;&deallocRegs (data);&firstParm:= FALSE$END"END updateStacks;  PROCEDURE saveStacks (VAR stacks: StackDesc; VAR regWithHiddenA7: RegType);"(*#* wird direkt vor Call aufgerufen.#*)"VAR r: RegType; help: ExprDesc;"BEGIN$WITH stacks DO&IF dataUsedDyn THEN(PopExpr (help);((*$? Safety: assert (help.kind = register);*)(genPushReg (help.exprReg, TRUE, dataSP);(regWithHiddenA7:= help.exprReg;(deallocRegs (help);&END$END"END saveStacks;  PROCEDURE deallocStacks (validStacks: BOOLEAN;9VAR stacks: StackDesc; parmLen: LONGINT;9popFromA3: LONGCARD;9popFromA7: LONGCARD;9VAR leftOnA3: LONGCARD);"(*#* RÑumt nach Proc-Call mit den Stacks wieder auf.#* In 'popFromA3/7' kînnen zusÑtzliche Bytes zum AbrÑumen angegeben werden.#* In 'leftOnA3' wird der Wert zurÅckgegeben, der dort vom Aufrufer#* abgerÑumt werden muû. Dies kann nicht hier erledigt werden, weil#* u.U. call() eine Funktionsproz. aufrief, die noch einen Wert auf#* dem A3-Stack hinterlassen hat. Dann darf der A3-Stack erst nach#* dem Runterladen des Funktionsergebnisses korrigiert werden.#* 'parmLen' gibt an, wieviel Bytes auf den Parm-Stack geladen sein#* mÅûten, bzw, wieviel Byte die aufgerufene Routine abgerÑumt hat.#*)"VAR r: RegType; help: ExprDesc;"BEGIN$leftOnA3:= 0;$IF validStacks THEN&WITH stacks DO(IF NOT forParms THEN*bong () (*wird z.Zt. nicht benutzt -- ggf. sonst A3/7Offset korrig. *)(ELSE*IF dataUsedDyn THEN,(*$? Safety: assert (data.kind = stack);*),data.stackReg:= dataSP;,data.up:= parmIsA3;,data.item:= sizedItem (4, FALSE);,genMOVEar (data, dataSP);,IF parmIsA3 THEN.A7Offset:= stackOffset,ELSE.A3Offset:= stackOffset,END*END;*IF dataUsed # 0L THEN,IF parmIsA3 THEN.INC (popFromA7, dataUsed);,ELSE.(*/* hier kann A3 ruhig abgerÑumt werden, denn der A3 wird nur/* dann als Data-Stack verwendet, wenn die Parms auf den A7/* kommen -- und dann kann ein evtl. Funktionsergebnis nicht/* auf dem A3-Stack Åbergeben werden./*).INC (popFromA3, dataUsed);,END*END;*IF parmUsed # 0L THEN,IF parmIsA3 THEN.HALT;.(*&&& ››1/*/*  kînnte man auch so lîsen, daû, wenn Daten noch auf A3/*  als Ergebnis geblieben sind, diese runtergeschoben werden./*  das ist im Durchschnitt auch nicht schlimmer, als den 1. Parm/*  sonst gleich auf A7 umzukopieren./*/*    damit das klappt, muû vorige 'firstParm'-Abfrage/*    reaktiviert werden. Auûerdem muû dann erstmal/*    das konzept bezlg. den datentransfers umgestellt/*    werden. problem: bei jedem transfer eines datums vom/*    stack irgendwohin muû 'restoreStack' ggf. durchgefÅhrt/*    werden. so z.b. bei loadReg, gen (ADD,..), usw./*    deshalb dÅrfen im expr/designator-teil keine gen-aufrufe/*    mehr gemacht werden -- 'deallocRegs' sollte auch nur/*    von diesen aufgerufenen routinen, die das dann tun/*    (so, wie jetzt z.b. loadReg), gemacht werden. stattdessen/*    gibt es zusÑtzlich 'deallocExpr', welches von den Ñuûeren/*    routinen benutzt wird, wenn sie davon ausgehen, daû nun/*    eine datenzusammenfassung passiert ist. ebenso kann dann/*    dort auch 'clearExpr' aufgerufen werden, wobei dafÅr/*    gesorgt wird, daû ggf. der stack von den daten befreit/*    wird./*).leftOnA3:= parmUsed,ELSE.INC (popFromA7, parmUsed);,END*END(END;(IF parmIsA3 THEN DEC (A3Offset, parmLen) END;&END; (* WITH stacks *)$END;$incReg (A7, toZZ (popFromA7, FALSE), 4);$incReg (A3, toZZ (-INT (popFromA3), TRUE), 4);"END deallocStacks;   (* ************************************************************************* *) (* ************************************************************************* *) (* ************************************************************************* *)  VAR SavedTempRegs: RegSet;  PROCEDURE assignment (); "VAR dest, expr: ExprDesc; range: ConvDesc; lastA3, lastA7: LONGINT; "PROCEDURE procCall;$VAR leftOnA3: LONGCARD; item: PtrItem;$BEGIN&item:= expr.item;&IF ItemNo (item) = 44 THEN((* bei Aufruf einer Proc m. Frame-Ptr muû der Ptr auf die Parm-Kette)* erst geholt werden *)(item:= RefType (item);&END;&IF ElementType (item) # NIL (* Funktion *) THEN(SyntaxError (rNoFun)&END;&call (leftOnA3, FALSE, 0);&IF leftOnA3 > 0L THEN(incReg (A3, toZZ (-LONGINT (leftOnA3), TRUE), 4)&END$END procCall; "VAR ok: BOOLEAN; "BEGIN (* assignment *)$lastA3:= A3Offset;$lastA7:= A7Offset;$$IF (userDef IN CurrentSymbol.flags) & (ORD (CurrentSymbol.typ) = 6) THEN&initProcExpr (expr, CurrentSymbol.item, procDepth (Tiefe));&PushExpr (expr);&GetSymbol ();&procCall$ELSE&designator (setDesig, FALSE, rVarXp);&IF CurrentSymbol.itemNo # becomes THEN(LookExpr (expr);(assert (NOT IsRegVar (expr.varItem));*(* >> proc-Vars dÅrfen nicht als Reg-Vars dekl. werden, weil+*    durch obigen designator-Aufruf dann der Wert ggf. nicht+*    aus dem Memory geladen wÅrde, wenn er als Parm Åbergeben+*    wurde. *)(IF (ItemNo (expr.item) = 19) OR (ItemNo (expr.item) = 44) THEN*procCall;(ELSE*SyntaxError (rAsgXp)(END&ELSE(LookExpr (dest);((* ~~~ die Abfrage wird schon in 'designator' gemacht. Einziges/Problem dabei: auch bei Proc-Var-Aufrufen wird schon von/vornherein eine Zuweisung angenommen und so kommt eine/Fehlermeldung, wenn eine Prov-Var als REF-Parm dekl. wurde.*IF dest.readOnly THEN SyntaxError (rRdOnl) END;(*)(GetSymbol;(VarExpression ();(PopExpr (expr);(PopExpr (dest);((checkAsnCompat (expr, dest.item, range, rParTy);(((*$? Safety: assert (NOT bothOnStack (dest, expr));*)*(* kann eigentlich nicht vorkommen, weil linke Seite beim Assignment+* nur als Pointer existieren kann und dieser hîchstens auf den+* A7 gespilled worden sein kann. *) (moveToVar (expr, dest, range);((deallocRegs (dest);&END;$END;$$(*$? Safety: assert (NOT FoldingConst);*)$IF (lastA3 # A3Offset) OR (lastA7 # A7Offset) THEN&IF lastA3 # A3Offset THEN BadId:= 'A3(assign/call)' ELSE BadId:= 'A7(assign/call)' END;&SyntaxError (rIntSP);&A3Offset:= lastA3;&A7Offset:= lastA7;$END;$IF freeRegs * tempRegs # SavedTempRegs THEN&BadId:= 'assign';&(*$? Safety:(Append (LHexToStr (LONGCARD(freeRegs*tempRegs),7), BadId, ok);(Append (LHexToStr (LONGCARD(SavedTempRegs),7), BadId, ok);&*)&SyntaxError (rIntRg);&freeRegs:= freeRegs - tempRegs + SavedTempRegs$END;"END assignment;   PROCEDURE pushHigh (parType, exprType: PtrItem;4VAR expr, dest: ExprDesc; countUsed, genCode: BOOLEAN); "VAR fact, maxHigh, elemSize, exprSize, elems: LONGCARD;&size, n: CARDINAL;&lo, hi: ZZ;&high: ExprDesc;&oldType, destHighType, parBase, exprBase: PtrItem;""BEGIN$oldType:= expr.item;$REPEAT&parBase:= OpenArrayType (parType);&IF isOpenArray (exprType) THEN((RETURN; (* dies wird z.Zt. in 'moveOpenArray' erled.*) &ELSE((IF isOpenArray (parBase) THEN*(* es kommt eine weitere open array-dimension *)*IF ItemNo (exprType) # 12 (* ARRAY *) THEN,SyntaxError (rArDXp)*END;*elemSize:= Size (expr); (*!!! unsicher/nur provisiorisch *)*getBounds (IndexType (exprType), lo, hi);*getElems (lo, hi, elems);*exprBase:= ElementType (exprType) (* wird unten benîtigt *)(ELSE*(*$? Safety: assert (exprType = expr.item);*)*adaptSSToChar (expr);*exprSize:= Size (expr);*elemSize:= TypeLength (parBase);*elems:= exprSize DIV elemSize;*n:= ItemNo (parBase);*size:= jokerSize (n);*IF size > 0 THEN,(* Basistype ist BYTE/WORD/LONGWORD *),IF exprSize MOD LONG (size) # 0L THEN SyntaxError (rOddAr) END*ELSIF (n = 3 (* CHAR *)) AND (ItemNo (exprType) = 27) THEN,(* String-Const zu ARRAY OF CHAR immer kompatibel *)*ELSE,(* ~~~ hier fehlt ggf. ZZ-Anpassung!-*     -- das kann nur eintreten, wenn z.B. ein ZZ-Wert an ein-*        Array of LONGCARD Åbergeben wird. Dieser Fall sollte-*        daher schon bei der asncompat-prÅfung in der call-routine-*        berÅcksichtigt werden, so daû dann gleich der passende-*        wert auf den stack kommt *),IF NOT compatTT (parBase, exprType),AND ( (ItemNo (exprType) # 12) OR2NOT compatTT (parBase, ElementType (exprType)) ) THEN.SyntaxError (rParTy),END*END(END;(((* 'elems' als HIGH-Wert ablegen *)(DEC (elems);(IF isLongOpenArray (parType) THEN*initConstExpr (high, 4, toZZ (elems, FALSE))(ELSE*IF elemSize = 1 THEN,maxHigh:= $7FFF; (* nur 32KB bei Byte-Arrays zulassen(wg. Optim.) *)*ELSE,maxHigh:= $FFFF*END;*IF elems > maxHigh THEN,SyntaxError (rOpAOv)*END;*initConstExpr (high, 2, toZZ (elems, FALSE))(END;(&END;&&IF genCode THEN(moveSingle (high, dest, 0);(IF countUsed THEN*INC (dest.stackedSize, Size (high));(END;&END;&deallocRegs (high); &parType:= parBase;&exprType:= exprBase;&expr.item:= exprType; (* >> damit ggf. 'Size(expr)' (s.o.) funktioniert *)$UNTIL NOT isOpenArray (parBase); (* weitere OPEN ARRAY-Dimens. bearbeiten*)$expr.item:= oldType;"END pushHigh;   TYPE  ParExprDesc = RECORD6expr: ExprDesc;6exprType: PtrItem;6range: ConvDesc;6parType: PtrItem;6byRef, openArray: BOOLEAN4END;   PROCEDURE initConstPar (VAR parExpr: ParExprDesc);"BEGIN$WITH parExpr DO&initExpr (expr, UndefTyp, constant);&parType:= NIL;&byRef:= FALSE;&openArray:= FALSE;$END"END initConstPar;  PROCEDURE getSinglePar ( parType: PtrItem; varPar, refPar, isPar: BOOLEAN;9VAR parExpr: ParExprDesc );"BEGIN$parExpr.parType:= parType;$WITH parExpr DO&byRef:= refPar OR varPar;&openArray:= isOpenArray (parType); &(*&&& geht das nun automatisch?(IF openArray THEN*(* nur bei einfachem Datum mit -(A7) arbeiten *)*changeSP (parmSP, parmStackLength)(END;&*)"&IF varPar THEN((* wozu das? in design. wird sowie 'rVarXp' gemeldet -> viel besser?!*IF NOT (userDef IN CurrentSymbol.flags) THEN SyntaxError (rIdXp) END;(*)(designator (varDesig, TRUE, rVarXp)&ELSE(VarExpression ()&END;&PopExpr (expr);&&IF varPar THEN(IF warningsActive () THEN*IF expr.regVar THEN SyntaxError (rRegVa) END;(ELSE*(* !!! erstmal immer Fehler melden, weil sonst dafÅr gesorgt+*    werden muû, daû das ins RAM abgelegte Reg noch vor dem+*    nÑchsten Statement wieder ins Reg muû!,IF expr.regVar & IsInReg (expr.varItem) THEN.(* Reg in Mem ablegen *).UseMem (expr.varItem);.changeToStack (expr);.changeStackToIndir (expr);.initExpr (reg, expr.item, register);.reg.exprReg:= UsedReg (expr.varItem);.genMOVEaa (reg, expr, 0),END+* stattdessen also: *)*IF expr.regVar THEN SyntaxError (rRegVa) END;(END&END;&&IF openArray THEN(range:= alwaysFitting (parType);(IF NOT isOpenArray (expr.item) THEN*reduceZZ (expr)(END((* Diese FÑlle werden erst beim HIGH-Push ('pushHigh') geprÅft *)&ELSE(IF isOpenArray (expr.item) THEN*SyntaxError (rOp2Op) (* Open Array nicht auf norm. Parm zuweisbar *)(ELSIF varPar THEN*checkVarCompat (expr, parType, rVPaTy);*range:= alwaysFitting (parType);(ELSIF isPar THEN*checkValCompat (expr, parType, range, rParTy)(ELSE*checkAsnCompat (expr, parType, range, rParTy)(END&END;$END;"END getSinglePar;   PROCEDURE pushPar ( VAR stack: StackDesc;4VAR parExpr: ParExprDesc; regPar: BOOLEAN ); "VAR origExprSize: LONGCARD;""BEGIN$WITH parExpr DO&IF expr.item = SSTyp THEN(IF parType = CharPtr THEN*adaptSSToChar (expr);(ELSE (* IF NOT openArray OR (Size (expr) = 0) THEN *)*(* String-Consts an Open-Array-Parms immer Null-terminiert Åbergeben+* (incl. erhîhtem High-Wert). *)*terminateStringConst (expr, parType);(END&END;&&(*$? Safety: assert (Size (expr) > 0L);*)&&exprType:= expr.item;&&IF openArray THEN((* Zuerst einmal Compat-PrÅfung usw. machen. WÅrde zuerst der)* Stack-Push gemacht, kînnten irgendwelche nicht zutreffenden)* Annahmen zu internen Fehlern fÅhren *)((*$? Safety: assert (~regPar); *)((* 'expr' wird hier Åbergeben, damit der Zugriff auf dessen)* HIGH-Werte ggf. bekannt ist. *)(pushHigh (parType, exprType, expr, stack.parm, FALSE, FALSE))(*~~~ wird zweimal nacheinander aufgerufen - hier wg. Compat-Check,**   weiter unten fÅr echten High-Push. Verbraucht sicher viel Zeit *)&END;&&(*'* Nun erfolgt das Laden des Parameters auf den Stack.'* 'expr', das den Zugriff auf das Datum beschreibt, muû erhalten'* bleiben, damit ggf. bei einer HIGH-öbergabe das Zugriff auf'* den HIGH-Wert des Datums mîglich ist, falls es ein Open-Array'* Parameter ist.'*)&origExprSize:= AnyTypeLength (exprType); (* Size f. pushHigh retten... *)&IF byRef & (expr.kind = constant) THEN(changeConstantToConstRef (expr, Size (expr));&END;&moveToStack (expr, stack, range, byRef, regPar);&SetTypeLength (exprType, origExprSize); (* ... und wiederherstellen *)&&IF openArray THEN((* 'expr' wird hier Åbergeben, damit der Zugriff auf dessen)* HIGH-Werte ggf. bekannt ist. *)(pushHigh (parType, exprType, expr, stack.parm, NOT stack.parmIsA3, TRUE)&END;$$END;$updateStacks (stack);"END pushPar;   PROCEDURE canAddToConstPar (VAR source: ParExprDesc): BOOLEAN;"(*#* Liefert TRUE, wenn 'source' ein Const ist, die erstmal in 'dest'#* gemerkt bzw. mit vorigen Consts zusammengefaût werden kann.#* Bei REF-Parms geht dies nicht, weil ja nicht der Wert der Const#* sondern ihr Pointer auf den Stack muû. Die hiesige Zusammenfassung#* jedoch versucht ja gerade, mehrere Consts zusammen auf einmal auf#* den Stack zu laden.#*)"VAR parSize, dataSize, size: LONGCARD; c: CARDINAL;"BEGIN$IF NOT (source.byRef OR source.openArray) THEN&IF (source.expr.kind = constant) OR (source.expr.kind = constRef) THEN((*)* String-Consts mÅssen ggf. Null-terminiert und aufgefÅllt werden.)* Wenn sie viel kleiner sind als ihre Ziel-Var, wird normalerweise)* die Const nicht mehr mit abgelegt, da dann die normale Parameter-)* Zuweisung besser vorgeht, indem sie nur die nîtigen Bytes kopiert)* und dann den SP auf die Ziel-LÑnge hochsetzt.)* FÅr den Fall, daû es ein Value Constructor ist, der in einer)* Const-Expr vorkommt, darf das aber nicht gemacht werden, sondern)* die String-Const muû in ihrer vollen Ziel-LÑnge abgelegt werden.)*)(IF isSS (source.expr) & isStringVar (source.parType) THEN*terminateStringConst (source.expr, source.parType);*IF NOT InConstExpr*AND (TypeLength (source.parType) - Size (source.expr) > 3L) THEN,RETURN FALSE*END(END;(RETURN TRUE&END$END;$RETURN FALSE"END canAddToConstPar;   (*$D-*) PROCEDURE addToConstPar (VAR source, dest: ParExprDesc;9parSize: LONGCARD; roundUp: BOOLEAN);"VAR dataSize: LONGINT; size: LONGCARD; c: INTEGER; x: ADDRESS;"BEGIN$(*$? Safety: assert (dest.expr.item = UndefTyp);*)$makeUndef (source.expr); $(* Grîûe der Const merken und ggf. auf gerade LÑnge bringen: *)$dataSize:= Size (source.expr);$IF roundUp THEN&IF ODD (parSize) THEN(INC (parSize)&END;&IF ODD (dataSize) THEN(IF source.expr.kind = constant THEN shiftLeft (source.expr, 1) END;(INC (dataSize)&END;$END;$$(* Bei constants die Bytes oberhalb der Expr-LÑnge lîschen: *)$IF source.expr.kind = constant THEN&FOR c:= 0 TO strConstSize - SHORT (dataSize) DO(source.expr.exprConst.str [c]:= 0C&END;$END;$$(* zum Debuggen:&x:= ADR (source.expr.exprConst); x:= ADR (dest.expr.exprConst);$*)$(* neue Grîûe der zusammengefaûten Const berechnen *)$size:= (Size (dest.expr)) + (parSize);$$(*%* Zuerst 'dest' gÅltig machen:%* Wenn schon eine Const bestand, dann diese ggf. ablegen, ansonsten%* source zu dest machen%*)$IF (dest.expr.kind = constant) & (size > LONG (constBufSize)) THEN&(* !TT 4.4.94: Diese Version funktionierte nicht, wenn man zwei'* Konstanten mit kind=constant zusammenfÅgte, die dann > constBufsize'* wurden:*IF dest.parType # NIL THEN,(* schon vorige Const erzeugt;-* Konst. auf jeden Fall in den Data-Puffer ablegen.-* source wird spÑter angefÅgt *),dropNewConstant (ADR (dest.expr.exprConst.b)+1L-Size (dest.expr),:Size (dest.expr), dest.expr);*ELSE,(* noch keine vorige Const abgelegt *),IF source.expr.kind # constRef THEN.(* Konst. auf jeden Fall in den Data-Puffer ablegen *).dropNewConstant (ADR (source.expr.exprConst.b)+1-ORD(dataSize),<dataSize, source.expr);,END;,(* source wird zu 'dest' Åbernommen. *),dest.expr:= source.expr;,(* expandConstant (dest.expr, parSize) Rest der Const lîschen *)*END&*)&(* 4.4.94 neue Version, Testprg: CONSTREC.M: *)&dest.parType:= UndefTyp;&dropNewConstant (ADR (dest.expr.exprConst.b)+1L-Size (dest.expr),:Size (dest.expr), dest.expr);$END;$$(*%* Nun, wenn Const schon vorher bestand, source anfÅgen%*)$IF dest.parType # NIL THEN&IF source.expr.kind = constRef THEN((* neue Const im Code an alte im Code anfÅgen *)((*$? Safety: assert (dest.expr.kind = constRef);*)((*$? Safety: assert (dest.expr.constOfs = 0); *)((*)* Die hinzuzufÅgende Konst. muû ggf. erstmal im DATA-Puffer abgelegt)* werden. Danach wird sie gleich wieder freigegeben, damit die ggf.)* davor liegende Konst. aufgefÅllt werden kann. Falls die 'source'-)* Konst schon vor der 'dest'-Konst im Puffer abgelegt ist (weil sie)* eine anonyme ist und schon beim Expr-Holen abgelegt wurde, wÑhrend)* die 'dest'-Konst erst jetzt gerade bei 'dropConstantFromTree' in)* den Puffer gelangte), verbleibt sie ungenutzt im Puffer und wird)* spÑter nicht in das DATA-Segment Åbernommen.)*)(IF source.expr.constHead = NIL THEN dropConstantFromTree (source.expr) END;(x:= source.expr.constAddr;(cutConst (source.expr); (* lîscht 'constAddr' *)((*$? Safety: assert (constantAtEnd (dest.expr)); *)(addNewConstant (x, dataSize, parSize, dest.expr);&ELSIF dest.expr.kind = constRef THEN((*$? Safety: assert (dest.expr.constOfs = 0); *)((*$? Safety: assert (constantAtEnd (dest.expr)); *)(addNewConstant (ADR (source.expr.exprConst.b)+1-ORD(dataSize),6dataSize, parSize, dest.expr);&ELSE(dest.expr.varItem:= NIL; (* auf Konst im Tree darf nicht mehr ref. werden *)(shiftLeft (dest.expr, SHORT (parSize));(FOR c:= strConstSize - SHORT (dataSize) + 1 TO strConstSize DO*dest.expr.exprConst.str [c-SHORT(INT(parSize)-dataSize)],:= source.expr.exprConst.str [c](END;&END$ELSIF source.expr.kind = constant THEN&shiftLeft (source.expr, SHORT (INT(parSize)-dataSize));&dest.expr:= source.expr$END;$$WITH dest DO&exprType:= UndefTyp;&parType:= UndefTyp;&range:= alwaysFitting (exprType);&expr.exprSize:= size$END;$$deallocRegs (source.expr); (* ...nur zur Sauberkeit *)"END addToConstPar; (*$D-*)  PROCEDURE saveProcAddr (VAR proc: ExprDesc);"(*#* Falls Adr. der Proc Åber eine Adr. mit einem temp. Reg erreicht#* wird, wird hier dafÅr gesorgt, daû ein einzelner, direkter Zeiger#* darauf erzeugt wird, damit beim Spilling nur ein einfacher#* Ptr auf dem Stack steht.#*)"BEGIN$IF usesTempRegs (proc) & (proc.kind = memory) THEN&(*)(* vorzugsweise in ein Addr-Reg laden: *))IF addrRegs * tempRegs * freeRegs # RegSet {} THEN+loadReg (proc, anyAddrReg))ELSE+loadReg (proc, anyCPUReg))END&*)&makeInd0An (proc);$END"END saveProcAddr;  PROCEDURE callProcAddr (VAR proc: ExprDesc; hiddenA7: RegType; VAR popA7: BOOLEAN); "VAR link: ExprDesc;&regs: RegSet;&r: RegType;&A7ofs, d: LONGINT;""PROCEDURE moveHiddenA7;$(* SP-Kopie ggf. in Addr-Reg laden *)$BEGIN&IF hiddenA7 < A0 THEN(genMOVErr (hiddenA7, A0, 4);(hiddenA7:= A0&END$END moveHiddenA7;""BEGIN$popA7:= FALSE;$IF LocalA7Hidden THEN&A7ofs:= LocalA7WhenHidden$ELSE&hiddenA7:= A7;&A7ofs:= A7Offset$END;$WITH proc DO&IF (kind = memory) & (mode = ptrOnA7) & (LocalA7Hidden OR (depth # A7ofs)) THEN(popA7:= TRUE;(r:= allocReg (addrRegs);(d:= depth - A7ofs;((* Folg. Access geht nur bis max. 32KB Daten auf dem A7-Stack: *)(IF d >= MAX (SHORTINT) THEN*(* zwar wird vorher schon ein entspr. Test gemacht, aber bis+* hierher kînnen sich noch mehr Daten auf dem Stack angesammelt+* haben (z.B. bei Funktionsprozeduren m. Open Array-Parms?) *)*SyntaxError (rParOv)(END;(moveHiddenA7;(genMOVELIndTo (hiddenA7, r, SHORT (d));(disp:= 0;(kind:= memory;(mode:= d16An;(baseReg:= r&ELSIF (kind = stack) & (LocalA7Hidden OR (stackPtr # A7ofs)) THEN((*$? Safety: assert (stackReg = A7);*)(popA7:= TRUE;(disp:= stackPtr - A7ofs;(kind:= memory;(mode:= d16An;(moveHiddenA7;(baseReg:= hiddenA7&ELSE(reloadPtr (proc);&END;&IF ItemNo (item) = 44 (* Proc-Type mit Frame-Ptr *) THEN((*$? Safety: assert (kind = memory);*)(changeToStack (proc);(proc.item:= CardPtr;(link:= proc;(regs:= addrRegs;(EXCL (regs, proc.stackReg); (* damit A0 nicht zerstîrt wird *)(loadReg (proc, regs);       (* MOVE.L (A0)+,A1 *)(genMOVEar (link, D2);       (* MOVE.L (A0)+,D2 *)&ELSIF ItemNo (item) # 6 (* PROCEDURE *) THEN((* Wert der Proc-Var in ein AddrReg laden, unten wird's dann nach (An))* gewandelt.)* Wenn der Wert allerdings gespilled wurde, ihn mit A7-Offset laden)* und den SP nach dem Call abrÑumen. *)((*$? Safety: assert (kind # spilledSP);*)(loadReg (proc, anyAddrReg);&END$END;$makeIndir (proc, 0, FALSE);$gena (JSR, proc, 4);$deallocRegs (proc);"END callProcAddr;   PROCEDURE call (VAR leftOnA3: LONGCARD;0pushAddr: BOOLEAN; pushBase: LONGINT); "VAR$popFromA3, popFromA7: LONGCARD;$nextParItem, parType, parItem: PtrItem;$regPar, refPar, varPar: BOOLEAN; "PROCEDURE getParmLength (par: PtrItem; VAR pl, sl: LONGCARD; VAR single: BOOLEAN);$(*%* bestimmt die Anzahl Bytes, die auf den Parm-Stack ('pl'), sowie%* Åberhaupt auf den Stack, jedoch ohne Open Arrays ('sl') kommen werden.%* 'single' ist TRUE, wenn nur ein einziges einfaches Arg. kommt.%*)$$PROCEDURE incpl (n: LONGCARD);&BEGIN(IF pl # 0 THEN single:= FALSE END;(INC (pl, n)&END incpl;&$VAR t: PtrItem; reg, ref: BOOLEAN;$$BEGIN&single:= TRUE;&pl:= 0;&sl:= 0;&WHILE par # NIL DO(reg:= ParmToReg (par);(ref:= (refParm IN ParmFlag (par)) OR (varParm IN ParmFlag (par));(t:= ParmType (par);(IF isOpenArray (t) THEN*(*$? Safety: assert (NOT reg); *)*single:= FALSE; (* weil sonst HIGH bei -(A7) zuerst kommen mÅûte,;* was moveOpenArray aber noch nicht kann *)*incpl (4); (* fÅr Adresse des Arrays *)*REPEAT,IF isLongOpenArray (t) THEN.incpl (4);,ELSE.incpl (2),END;,t:= OpenArrayType (t)*UNTIL ~isOpenArray (t);(ELSIF ref THEN*IF ~reg THEN incpl (4) END;*(* TT 30.05.93:.wozu sollte bei REF-Parm der Wert fÅr den Stack-Check erhîht.werden? Normalerweise wird auch wirklich beim REf-Parm nix.auf den Stack kopiert. Und wenn doch, dann doch wohl nur.bei generischen AusdrÅcken, also dann, wenn keine Variable.sondern z.B. ein Value Constr. als Par. Åbergeben wird. Und.da prÅft doch der Value Constr. selbst schon den Stack.,IF refParm IN ParmFlag (par) THEN.INC (sl, TypeLength (t));.IF ODD (sl) THEN INC (sl) END;,END**)(ELSE*IF ~reg THEN,incpl (TypeLength (t));,INC (sl, TypeLength (t));,IF ODD (pl) THEN INC (pl); INC (sl) END;*END;(END;(par:= NextParm (par)&END;$END getParmLength;"(*$D-*)""TYPE CodeSaveDesc = RECORD8stack0: StackDesc;8cutPtr: ADDRESS;8relocNo: LONGCARD;8spillSpSv: INTEGER;8a3, a7: LONGINT;6END;""VAR stacks: StackDesc;&stackLen, parmLen: LONGCARD;&singlePar, constPar: ParExprDesc;&single, oldHiddenL, oldHiddenG, popA7, hadParms: BOOLEAN;&oldHideVal: LONGINT;&save: CodeSaveDesc;&procItem: PtrItem;&r: RegType;&regsToFree: RegSet;&parCnt, noOfParms: CARDINAL;&regWithHiddenA7, oldSpillDestReg: RegType;&oldSpillDestDir: Directions;&"PROCEDURE saveCode ();$BEGIN&WITH save DO(stack0:= stacks;(cutPtr:= CodePtr();(relocNo:= RelocCount;(spillSpSv:= spillSp;(a3:= A3Offset;(a7:= A7Offset&END;$END saveCode;""PROCEDURE restoreCode (): BOOLEAN;$BEGIN&WITH save DO(IF (cutPtr = NIL) (* 1.11.90: zur Sicherheit eingebaut - bin mir nicht sicher *)(OR (spillSpSv # spillSp)(OR (relocNo # RelocCount) THEN*cutPtr:= NIL;*RETURN FALSE(END;(stacks:= stack0;(SetCodePtr(cutPtr);(cutPtr:= NIL;(A3Offset:= a3;(A7Offset:= a7;&END;&RETURN TRUE$END restoreCode; "PROCEDURE presetProc;$VAR proc: ExprDesc;$BEGIN&PopExpr (proc);&(*$? Safety: assert ((ItemNo (proc.item) = 6) OR (ItemNo (proc.item) = 44) OR;(ItemNo (proc.item) = 19));*)&saveProcAddr (proc);&PushExpr (proc);&procItem:= proc.item;&IF ItemNo (procItem) = 44 THEN((* bei Aufruf einer Proc m. Frame-Ptr muû der Ptr auf die Parm-Kette)* erst geholt werden *)(procItem:= RefType (procItem);&END$END presetProc; "PROCEDURE handleCall;$(* Prozeduraufruf *)$VAR proc, link: ExprDesc;$BEGIN&PopExpr (proc);&IF (ItemNo (proc.item) = 6) & NOT (global IN ItemFlag (proc.item)) THEN((*)* lokale Proc aufrufen: Static Link laden nach D2 bzw. -(A7))*)* Auf den A7 kommt der Static Link nur, wenn die Proc Parms)* auf A7 erwartet und auch wirklich Parms vorhanden sind!)*)(WITH proc DO*IF (kind = memory) & (mode = ptrOnA7) & LocalA7Hidden*OR (kind = stack) & LocalA7Hidden THEN,IF regWithHiddenA7 = D2 THEN.(* falls wir den HiddenA7 noch brauchen und der in D2 liegt,/* den Wert in ein anderes Reg kopieren: *).genMOVErr (D2, A0, 4);.regWithHiddenA7:= A0,END*END(END;((* doch zuerst eventuelle Reg-Vars im Memory ablegen *)((*&&&alle reg-vars, die von lok.proc benutzt werden, ablegen*)(IF proc.tiefe = 0 THEN*(* MOVE.L A6,D2 *)*initRegExpr (link, 4, getLink (0));(ELSE*(* MOVE.L (Ar),D2 *)*initRegExpr (link, 4, getLink (proc.tiefe-1));*makeIndir (link, 0, FALSE)(END;(IF (noOfParms # 0) AND (parmA7 IN ItemFlag (proc.item)) THEN*pushReg (link, A7);*INC (stacks.parmUsed, 4)(ELSE*loadReg (link, RegSet {D2})(END;(deallocRegs (link)&END;&callProcAddr (proc, regWithHiddenA7, popA7)$END handleCall; "PROCEDURE NthParm (n: CARDINAL): PtrItem;$(* Liefert den <n>ten Parameter. FÑngt mit 1 an. *)$VAR par: PtrItem;$BEGIN&par:= FirstParm (procItem);&WHILE n > 1 DO par:= NextParm (par); DEC (n) END;&RETURN par$END NthParm; "VAR ok: BOOLEAN; "BEGIN (* call *)$(*%* Bei einer Proc-Var kann es passieren, daû ihr Wert in einem temp.%* Reg steht. Wir lassen nun zu, daû das Reg dann ggf. gespilled wird.%* Wird am Ende dann die Adr. fÅr den Aufruf benîtigt, wird geprÅft,%* ob der auf dem Stack steht. In diesem Fall wird dann Åber den%* A7-Offset auf den Wert zugegriffen und nach dem Call verworfen.%* Damit der Wert beim ggf. spilling 'kind=register' hat, wird er%* hier schon in ein Reg geladen, sofern es nîtig ist (nur nîtig, wenn%* temp. Vars belegt werden, die gespilled werden kînnten).%* Vorsicht: Wenn die Parm-öbergabe auf den Stack geht, auf den ggf.%*   auch die Proc-Adr gespilled wird, muû dies ganz am Anfang vor allen%*   Parameter-Loads geschehen! Einfacherhalber wird deshalb erstmal%*   der Wert immer gespilled durch den gleich folgenden 'spillAllRegs'.%*   Soll dies erst beim ggf. Parm-Load geschehen, kann hier stattdessen%*   'spillAllRegsExcept (proc)' eingesetzt werden.%*)$popFromA3:= 0;$popFromA7:= 0;$parmLen:= 0;$oldHiddenG:= GlobalA7Hidden;$oldHiddenL:= LocalA7Hidden;$oldHideVal:= LocalA7WhenHidden;$LocalA7Hidden:= FALSE;$presetProc;$spillAllRegs (); (* Alle temporaries von frÅher aus dem Weg *)$$noOfParms:= 0;$parItem:= FirstParm (procItem);$$IF CurrentSymbol.itemNo = lparen THEN&(*$D-*)&IF parItem # NIL THEN(getParmLength (parItem, parmLen, stackLen, single);(checkStack (stackLen);(((* Spilling je nach Parm-Stack auf den anderen Stack legen *)(oldSpillDestReg:= spillDestReg;(oldSpillDestDir:= spillDestDir;(spillDestReg:= A7;(spillDestDir:= down;(IF parmA7 IN ItemFlag (procItem) THEN*initStacks (stacks, TRUE, A7, parmLen, NOT single);*IF stacks.parm.stackReg = A7 THEN,spillDestReg:= A3;,spillDestDir:= up;*END(ELSE*initStacks (stacks, TRUE, A3, 0, FALSE);(END;((initConstPar (constPar);(save.cutPtr:= NIL;(REPEAT*IF parItem = NIL THEN SyntaxError (rParXp) (* ')' erwartet *) END;**INC (noOfParms);*parType:= ParmType (parItem);*nextParItem:= NextParm (parItem);*refPar:= refParm IN ParmFlag (parItem);*varPar:= varParm IN ParmFlag (parItem);*regPar:= ParmToReg (parItem);**IF ItemNo (parType) = 0 (* zeigt auf Relay *) THEN,SyntaxError (rBdPar)*END;**pushStacks (stacks); (*&&& spilling testen, wenn Daten auf A7 kommen, auch bei Open Arrays *)*GetSymbol ();*getSinglePar (parType, varPar, refPar, TRUE, singlePar);*popStacks (stacks);**(*+* Wenn Par ins Reg soll, wird keine Const zusammengefaût!+* Auûerdem muû dafÅr gesorgt werden, daû der Wert keinesfalls+* mehr als ein Reg. belegt (loadReg-Aufruf in movetoStack).+* Am Ende werden nochmal alle Parms rÅckwÑrts durchgegangen,+* um die Parms in die richtigen Regs zu laden.+* Dabei muû beachtet werden, daû ggf. ein EXG generiert werden muû.+*)*IF ~regPar & canAddToConstPar (singlePar) & restoreCode () THEN,fitValue (singlePar.expr, singlePar.range);,addToConstPar (singlePar, constPar, TypeLength (parType), TRUE);,saveCode;,reloadStackPtrs (stacks);,setParType (stacks, constPar.parType);,pushPar (stacks, constPar, FALSE);*ELSE,reloadStackPtrs (stacks);,setParType (stacks, singlePar.parType);,pushPar (stacks, singlePar, regPar);,save.cutPtr:= NIL;,initConstPar (constPar);*END;**parItem:= nextParItem;(UNTIL CurrentSymbol.itemNo # comma;(IF parItem # NIL THEN SyntaxError (rParNr) (* zu wenig Parms *) END;(((* falls A7 in Hilfsreg (meist A0) geladen war, muû dies noch)* vor dem evtl. Laden der Reg-Parms wieder freigegeben werden: *)(deallocRegs (stacks.parm);(((* Nun die Reg-Parms nachladen, und zwar rÅckwÑrts, da evtl. gespillt *)((*$? Safety: assert (NOT spilling); *)(regsToFree:= RegSet {};(spilling:= TRUE; (* zur Absicherung, daû nicht wieder gespillt wird *)(FOR parCnt:= noOfParms TO 1 BY -1 DO*parItem:= NthParm (parCnt);*IF ParmToReg (parItem) THEN,WITH singlePar DO.PopExpr (expr);.r:= ParmRegNo (parItem);.IF (expr.kind # register) OR (expr.exprReg # r) THEN0IF r IN freeRegs THEN2loadReg (expr, RegSet {r})0ELSE2(* Reg ist von einem andern Parm belegt. Mit EXG tauschen. *)2loadRegByEXG (expr, r)0END;.END;.INCL (regsToFree, r);,END*END(END;(spilling:= FALSE;(freeRegs:= freeRegs + regsToFree;((spillDestReg:= oldSpillDestReg;(spillDestDir:= oldSpillDestDir;&ELSE(GetSymbol&END;&(*$D-*)&GetRparen$ELSE&IF parItem # NIL THEN SyntaxError (rParNr) (* zu wenig Parms *) END;$END;$$IF noOfParms # 0 THEN&saveStacks (stacks, regWithHiddenA7)'(* VORSICHT: Falls A7Hidden=TRUE, erhalten wir in 'regWithHiddenA7'(*           das Register mit dem Wert des alten A7. Wir brauchen(*           diesen Wert dann u.U. noch in 'callProcAddr' und dÅrfen(*           ihn deshalb bis dahin nicht zerstîren! (Kann bisher nur(*           in handleCall bei Laden des StatLink nach D2 passieren) *)$END;$$IF freeRegs * tempRegs # SavedTempRegs THEN&BadId:= 'call';&(*$? Safety:(Append (LHexToStr (LONGCARD(freeRegs*tempRegs),7), BadId, ok);(Append (LHexToStr (LONGCARD(SavedTempRegs),7), BadId, ok);&*)&SyntaxError (rIntRg);&freeRegs:= freeRegs - tempRegs + SavedTempRegs$END;$$IF pushAddr THEN&(* PEA x(SP)  fÅr öbergabe des Return-Wert-Pointers erzeugen *)&WITH singlePar DO(initMemExpr (expr, NIL, d16An, FALSE);(IF ~LocalA7Hidden THEN*expr.baseReg:= A7;*expr.disp:= pushBase - A7Offset;(ELSE*(* Falls Orig-A7 wg. dyn. Arrays auf dem Stack steht, nun+* (A3) nach An laden und dann disp(An) auf Stack pushen. *)*expr.baseReg:= stacks.dataSP (* muû A3 sein, wenn Parms auf A7 *);*loadReg (expr, addrRegs);*makeIndir (expr, pushBase - LocalA7WhenHidden, FALSE)(END;(genPushAddress (expr, A7);(INC (popFromA7, 4);(deallocRegs (expr)&END$END;$$handleCall; (* Proc-Aufruf mit Static-Link-öbergabe *)$IF popA7 THEN INC (popFromA7, 4) END;$$deallocStacks (noOfParms#0, stacks, parmLen, popFromA3, popFromA7, leftOnA3);$GlobalA7Hidden:= oldHiddenG;$LocalA7Hidden:= oldHiddenL;$LocalA7WhenHidden:= oldHideVal"END call;   PROCEDURE hdlCall (mode: CARDINAL; type: PtrItem);"(*#* ruft TRAP oder externe Funktion mit Parms auf A7.#*  mode = 0: SYSTEM.CALLSYS (trapNo, parms...)#*  mode = 1: SYSTEM.CALLEXT (addr, parms...)#* Regeln fÅr Parameter:#*  - Int-Consts werden, wenn kein 'L' dran, als 16 Bit-Wert Åbergeben.#*  - Byte-Daten als Words geladen (das Byte-Datum findet sich sodann#*    auf einer ungeraden Stack-Adresse), das High-Byte wird dabei nicht#*    unbedingt richtig expandiert/gelîscht, sondern kann jeden MÅll#*    enthalten!#*  - Alle anderen Daten mÅssen 1, 2, oder 4 Byte groû sein.#*    FÅr Strings, usw, muû also CADR/ADR() verwendet werden.#*    String-Consts dÅrfen nicht automatisch wie mit CADR ausgewertet werden,#*    weil dann zw. Strings der LÑnge Eins und Char-Consts keine Unter-#*    scheidung mîglich wÑre.#*)""VAR sp, expr: ExprDesc;&range: ConvDesc;&n, parNo: CARDINAL;&popA7: BOOLEAN;&"BEGIN$GetSymbol;$IF mode = 0 THEN&ConstExpression ()$ELSE&VarExpression ();$END;$PopExpr (expr);$type:= StdParmType (StdProcParms (type));$checkAsnCompat (expr, type, range, rBdTyp);$fitValue (expr, range);$IF mode = 1 THEN saveProcAddr (expr); END;$PushExpr (expr);$spillAllRegs (); (* Alle temporaries von frÅher aus dem Weg *)$(* &&& An dieser Stelle mÅûte das Spilling auf A3 statt A7 gelenkt%*     werden, damit es zu keinen Konflikten kommt. *)$parNo:= 0;$WHILE CurrentSymbol.itemNo = comma DO&GetSymbol ();&VarExpression ();&LookExpr (expr);&reduceZZ (expr);&n:= SHORT (Size (expr));&IF (n = 3) OR (n > 4)&OR (ItemNo (expr.item) = 12)      (* ARRAYs sind nicht erlaubt *)&OR isSS (expr) & (n > 1) (* Strings sind nicht erlaubt *) THEN(SyntaxError (rScAdX)&END;&INC (parNo);$END;$initStackExpr (sp, 0L, A7);$WHILE parNo # 0 DO&PopExpr (expr);&IF (expr.kind = stack) & (expr.stackReg = A7)&OR (expr.kind = memory) & (expr.mode = ptrOnA7) THEN((* expr wurde gespilled - das darf nicht *)(SyntaxError (rNoRgs)&END;&reduceZZ (expr);&n:= SHORT (Size (expr));&IF n = 1 THEN(IF expr.kind # constant THEN*loadReg (expr, anyReg)(END;(n:= 2&END;&(* wenn CADR() verwendet wurde, wird LEA adr(PC),An; PEA (An) erzeugt.'* Besser wÑre, gleich PEA adr(PC) zu gen. ~~~ *)&moveSingle (expr, sp, n);&deallocRegs (expr);&DEC (parNo)$END;$PopExpr (expr);$IF mode = 0 THEN&(* TRAP generieren *)&gen (TRAP + expr.exprConst.zz.c);$ELSE&(* JSR gen. *)&callProcAddr (expr, 0, popA7);&(*~~~ unschîn: Es wird bei einer Konstant-Adr. kein JSR $adr sondern'*     LEA adr,A0  JSR (A0) erzeugt, weil callProcAddr keine absolut-'*     Adr. kennt, sondern nur Vars und zu relozierende Adr. *)&IF popA7 THEN INC (sp.stackedSize, 4) END$END;$(* Stack bereinigen *)$incReg (A7, toZZ (sp.stackedSize, FALSE), 4);"END hdlCall;   PROCEDURE hdlLoad;"(*#* LOAD (expr, regNo);#*)"VAR expr, reg: ExprDesc; free, regs: RegSet;"BEGIN$GetLparen;$GetSymbol;$free:= freeRegs;$VarExpression ();$PopExpr (expr);$adaptSSToChar (expr);$reduceZZ (expr);$IF Size (expr) > 4L THEN SyntaxError (rVarSz) END;$ChkComma;$GetSymbol ();$ConstExpression ();$PopExpr (reg);$IF NOT isWholeNumber (reg.item)$OR NOT inZZ (reg.exprConst.zz, toZZ (0L, FALSE), toZZ (15L, FALSE)) THEN&SyntaxError (rConRg)$END;$regs:= RegSet {};$INCL (regs, reg.exprConst.zz.c);$INCL (freeRegs, reg.exprConst.zz.c);$loadRegExt (expr, regs, 4, FALSE);$freeRegs:= free;$GetRparen"END hdlLoad;  PROCEDURE hdlStore;"(*#* STORE (regNo, var);#*)"VAR var, reg: ExprDesc; regNo: RegType; wasFree: BOOLEAN;"BEGIN$GetLparen;$GetSymbol ();$ConstExpression ();$PopExpr (reg);$IF NOT isWholeNumber (reg.item)$OR NOT inZZ (reg.exprConst.zz, toZZ (0L, FALSE), toZZ (15L, FALSE)) THEN&SyntaxError (rConRg)$END;$regNo:= reg.exprConst.zz.c;$wasFree:= regNo IN freeRegs;$EXCL (freeRegs, regNo);$ChkComma;$GetSymbol;$designator (setDesig, FALSE, rVarXp);$PopExpr (var);$IF (Size (var) = 1L) & (regNo >= 8)$OR (Size (var) > 4L) THEN SyntaxError (rVarSz) END;$initExpr (reg, var.item, register);$reg.exprReg:= regNo;$genMOVEaa (reg, var, 0);$deallocRegs (var);$IF wasFree THEN INCL (freeRegs, regNo) END;$GetRparen"END hdlStore;   PROCEDURE getSingle (VAR singlePar: ParExprDesc; parType: PtrItem;5VAR stillConst: BOOLEAN);"VAR c: BOOLEAN;"BEGIN$GetSymbol;$IF CurrentSymbol.itemNo = lbrace THEN&(*'* anonyme Dimension auswerten'*)&hdlConstructor (parType);&singlePar.parType:= parType;&singlePar.exprType:= parType;&singlePar.byRef:= FALSE;&singlePar.openArray:= FALSE;&PopExpr (singlePar.expr);&singlePar.range:= alwaysFitting (parType);&GetSymbol;$ELSE&getSinglePar (parType, FALSE, FALSE, FALSE, singlePar);$END;$c:= (singlePar.expr.kind = constRef) OR (singlePar.expr.kind = constant);$IF NOT c THEN&IF InConstExpr THEN SyntaxError (rConXp) END;&stillConst:= FALSE$END"END getSingle;  (*!* ~~~!* Optimierungen fÅr Konstruktoren:!* Wird ein Wert mit Variablen zusammengesetzt, erzeugt der Compiler (4.3)!* z.Zt. recht ineffizienten Code:!* 1. Sind die meisten Wert konstant, wird ab der 1. nicht-Konstante alles!* dynamisch und einzeln zusammengepackt. besser wÑre, wenn die grîûeren!* kostanten HÑppchen ggf. auch wieder als Paket im DATA-Segment abegelegt!* wÅrde. Bisher passiert dies nur beim ersten konstanten Teil bis zur!* ersten Variablen. Noch besser wÑre es, in FÑllen, bei denen die meisten!* Werte konstant sind, alle diese Werte in ein groûes DATA-Element (das!* dann gleich den gesamten Konstruktor-Wert darstellt) zu packen.!* Dann braucht nur noch Code erzeugt werden, der die wenigen variablen Werte!* in die LÅcken des Wertes im DATA-Segment einfÅgt.!* 2. Wie schon woanders hier beschrieben, kînnten die Werte gleich in die!* Ziel-Var geschrieben werden, anstatt sie erstmal auf dem A3-Stack aufzu-!* bereiten und hinterher umzukopieren.!*) PROCEDURE hdlArrayConstructor (arrayType: PtrItem); "VAR lo, hi: ZZ;&parSize, saveBytes, stackedBytes, elems: LONGCARD;&parType: PtrItem;&oldA3, a3, a7: LONGINT;&long, saved, isConst: BOOLEAN;&singlePar, constPar: ParExprDesc;&sourcePtr, destPtr, loopAddr, startPtr, cutPtr: ADDRESS;&constSave: ConstValue;&count, prev, dest: ExprDesc;&l, l2, relocNo: LONGCARD;&spillSpSv: INTEGER;&symbol: Symbol;&reg: RegSet; "PROCEDURE saveCode;$BEGIN&a3:= A3Offset;&a7:= A7Offset;&prev:= dest;&cutPtr:= CodePtr();&saveBytes:= stackedBytes;&spillSpSv:= spillSp;&relocNo:= RelocCount;&LastDataRelocAdr:= NIL;&saved:= TRUE;$END saveCode; "PROCEDURE restoreCode (): BOOLEAN;$(*%* Diese Routine stellt den gesicherten Zustand wieder her:%* Der Code-Ptr wird zurÅckgesetzt und 'dest.stackedSize' auch.%* Dies funktioniert nur solange, wie wirklich nur einfache Kopier-%* schleifen abgelegt wurden. Es kann aber z.B. bei der unteren%* Anwendung auch vorkommen, daû zw. zwei Konstanten ein Reg gespilled%* wird. Dann darf 'restoreCode' nicht benutzt werden, weil diese%* Routine nicht fÑhig wÑre, das erfolgte Spilling wieder rÅckgÑngig%* zu machen. Theoretisch wÑre das zwar mîglich, dann sollte dafÅr%* aber ein allg. Routine erstellt werden, die dann alle VerÑnderungen%* auch fÅr andere Peephole-Anwendungen rÅckgÑngig machen kann.%* Auch sollten dann ReloziereintrÑge wieder entfernt werden kînnen.%*)$BEGIN&IF saved THEN(IF (spillSpSv # spillSp) THEN*isConst:= FALSE;*RETURN FALSE(END;(IF (relocNo # RelocCount) THEN*IF (relocNo+1 = RelocCount) & (LastDataRelocAdr # NIL) THEN,(* Relozierverweis auf DATA-Element rÅckgÑngig machen *),LastDataRelocAdr^:= 0*ELSE,isConst:= FALSE;,RETURN FALSE*END(END;(saved:= FALSE;(dest:= prev;(SetCodePtr (cutPtr);(stackedBytes:= saveBytes;(A3Offset:= a3;(A7Offset:= a7;&END;&RETURN TRUE$END restoreCode; "PROCEDURE pushSingle (odd, mustCopyIfSourceOnA3: BOOLEAN);&$PROCEDURE doit (): BOOLEAN;&VAR l: LONGINT;&BEGIN(IF singlePar.expr.kind = stack THEN*(*$? Safety: assert (singlePar.expr.stackReg = A3);*)*IF dest.stackReg = A3 THEN,IF mustCopyIfSourceOnA3 THEN.(* Wert auf Stack muû dupliziert werden. Dazu muû der Source-SP/* in ein Hilfs-Reg geladen werden, weil er sonst abgerÑumt wÅrde *).l:= singlePar.expr.stackedSize;.changeStackToIndir (singlePar.expr);.addDisp (singlePar.expr, -l);.changeToStack (singlePar.expr); (* >> LEA -x(A3),An *),ELSE.RETURN FALSE,END*END(END;(RETURN TRUE&END doit; $BEGIN&IF InConstExpr THEN SyntaxError (rConXp) END;&isConst:= FALSE; (* muû VOR doit() stehen, da sonst ggf. nicht gelîscht wird! *)&saved:= FALSE;&reloadPtr (dest);&IF doit () THEN(addToVar (singlePar.expr, dest, odd, TRUE, singlePar.range)&END;&initConstPar (constPar);$END pushSingle; "BEGIN$getBounds (IndexType (arrayType), lo, hi);$getElems (lo, hi, elems);$parType:= ElementType (arrayType);$parSize:= TypeLength (parType); $(*%* Das Kopieren des Array geht folgendermaûen:%* Die Daten werden, falls es keine ConstExpr ist, auf den A3-Stack%* gelegt. Damit es keine Probleme mit ungeraden ElementlÑngen gibt,%* wird in diesem Fall der A3 gleich erhîht und dann mit einem%* Hilfsregister gearbeitet. Wird A3 direkt verwendet, muû noch der%* Sonderfall, daû durch einen Funktionsaufruf das Ergebnis schon auf dem%* Stack steht, berÅcksichtigt werden (geschieht in 'pushSingle').%*)$IF NOT InConstExpr & (ODD (parSize)) THEN&startPtr:= CodePtr (); (* Adr. merken f. evtl. ZurÅckschieben (s.u.) *)&oldA3:= A3Offset;&(* Laden von A3 in ein temp. Reg, dann Erhîhen von A3 *)&checkStack (TypeLength (arrayType));&initRegExpr (dest, 4, A3);&loadReg (dest, addrRegs);&dest.item:= parType;&incReg (A3, toZZ (roundedUp (elems * parSize), FALSE), 4);&makeIndir (dest, 0, FALSE);&changeToStack (dest);$ELSE&startPtr:= NIL;&IF NOT InConstExpr THEN checkStack (TypeLength (arrayType)) END;&initStackExpr (dest, parType, A3);$END;$$initConstPar (constPar);$isConst:= TRUE;$saved:= FALSE;$stackedBytes:= 0;$LOOP&DEC (elems);&PushExpr (dest);&getSingle (singlePar, parType, isConst);&PopExpr (dest);&IF CurrentSymbol.itemNo = bySym THEN((*)* BY-Behandlung:)*)*   Wenn ein Wert, der nicht von einem Funktionsaufruf stammt, so klein)* ist, daû er in ein Reg paût, wird er erst in eines geladen und dann eine)* Zuweisungsschleife mit diesem Reg kodiert.)*)*   Bei sonstigen Werten wird der Wert einmal zugewiesen und da herum)* die Schleife gebildet.)*)(GetSymbol;(ConstExpression;(PopExpr (count);(IF (count.kind # constant) OR (count.item # ZZTyp) THEN*SyntaxError (rByNum)(END;(IF NOT inZZ (count.exprConst.zz, toZZ (1L, FALSE), toZZ (elems+1L, FALSE)) THEN*SyntaxError (rByCnt)(END;(l:= count.exprConst.zz.l;(DEC (elems, l-1L);(IF InConstExpr THEN**(*+* In CONST-Anweisungen wird Wert in jedem Fall statisch kopiert.+*)**fitValue (singlePar.expr, singlePar.range);*singlePar.range:= alwaysFitting (parType);**LOOP,IF l = 0L THEN EXIT END;,,IF (constPar.expr.kind = constRef) THEN..IF singlePar.expr.kind # constRef THEN0constSave:= singlePar.expr.exprConst;0(*0~~~ hier dÅrfte man sich entscheiden, ob nun die konst2zusammengesetzt werden wird, denn dann sollte sie auf jeden2fall in den DATA-Puffer gelegt werden.2falls aber die konsts einzeln eh' schon im tree vorliegen,2wÑre es bei grîûeren daten platzsparender, stattdessen die2consts nicht zusammenzufÅgen sondern bei laufzeit zusammen2zu kopieren.2allerdings nicht, wenn es an einen ref-parm gehen soll. dann2wÑre evtl. eine gesamtablage im DATA effizienter, wenn es2eine groûe konst bleibt. d.h, wenn der konstruktor auch vars2enthÑlt, wird auch eine Åbergabe an einen ref-parm keinen2vorteil haben, wenn man teile davon im data ablegt.2-- Weitere mîgliche optimierung: auch bei Konstruktoren mit5Vars/Exprs kînnte man alles im DATA-Segment statt auf5dem Stack anlegen. Vorteil: Die Konst-Teile bleiben immer5unverÑndert im DATA-Segment und nur die variablen Teile5mÅssen zugewiesen werden. -> Spart Laufzeit und Code zum5Zusammenkopieren. Auûerdem fÑllt das Stack-Gewurschtel5weg.0>>> Achtung: die öberlegung scheint hier am falschen platz2zu sein, denn hier ist nur die sonderbeh. f. BY0*)0dropNewConstant (ADR (constSave.b)+1L-parSize, parSize, singlePar.expr);.END;.makeUndef (singlePar.expr);.WITH singlePar.expr DO0(*$? Safety: assert ((constOfs = 0) & (constHead # NIL)); *)0exprSize:= l * parSize;0extendConstant (exprSize, singlePar.expr);0sourcePtr:= constAddr;.END;.destPtr:= sourcePtr;.WHILE l > 1 DO0INC (destPtr, parSize);0Move (sourcePtr, destPtr, parSize);0DEC (l).END;,,ELSE..(*$? Safety: assert (singlePar.expr.kind = constant);*),,END;,,DEC (l);,IF restoreCode () THEN.(*$? Safety: assert (isConst); *).addToConstPar (singlePar, constPar, Size (singlePar.expr), FALSE);.saveCode;,ELSE.bong (),END;,*END;*(ELSE**(*+* Bei BY im Programmcode wird immer eine Kopierschleife generiert+*)**(*$? Safety: assert ((dest.kind = stack) OR (dest.kind = spilledSP));*)*l2:= l; (* retten, 'l' ggf. geÑndert wird *)*IF singlePar.expr.kind = stack THEN,(*$? Safety: assert (singlePar.expr.stackReg = A3);*),IF (dest.stackReg = A3) AND (parSize # 4L) AND (parSize > 2L) THEN.(* Wert befindet sich bereits auf dem A3-Stack, deshalb 1mal/* weniger kopieren *).subZZ (count.exprConst.zz, toZZ (1L, FALSE));.DEC (l),ELSE.incReg (A3, toZZ (-LONGINT (singlePar.expr.stackedSize), TRUE), 4);.changeStackToIndir (singlePar.expr);,END*END;*IF NOT nullZZ (count.exprConst.zz) THEN,reduceZZ (count);,long:= Size (count) > 2L;,IF NOT long THEN.subZZ (count.exprConst.zz, toZZ (1L, FALSE)),END;,IF isSS (singlePar.expr) & isStringVar (parType) THEN.terminateStringConst (singlePar.expr, parType),END;,IF (parSize = 4L) OR (parSize <= 2L) THEN.fitValue (singlePar.expr, singlePar.range); (* Expand & Range-Check *).loadReg (singlePar.expr, dataRegs);.singlePar.range:= alwaysFitting (parType),END;,loadReg (count, dataRegs);,reloadPtr (dest);,(*-* Schleifenbeginn-*),IF long THEN.gen (BRA + 2);.genr (SWAP, count.exprReg);,END;,loopAddr:= CodePtr ();,reg:= RegSet {}; INCL (reg, count.exprReg);,PushExpr (count);,pushSingle (ODD (parSize), TRUE);,PopExpr (count);,reloadPtr (count);,loadReg (count, reg);,dbccBackTo (mapNever (), count.exprReg, loopAddr);,IF long THEN.genr (SWAP, count.exprReg);.dbccBackTo (mapNever (), count.exprReg, loopAddr-2L);,END;,(*-* Schleifenende-*),deallocRegs (count)*END;*dest.stackedSize:= parSize * l2;*IF dest.stackReg = A3 THEN,updateStackOffsets (A3, TRUE, parSize * (l-1L))*END*(END (* IF InConstExpr ELSE *)&ELSIF isConst & canAddToConstPar (singlePar) & restoreCode () THEN(fitValue (singlePar.expr, singlePar.range);(addToConstPar (singlePar, constPar, TypeLength (parType), FALSE);(saveCode;(IF NOT InConstExpr THEN*reloadPtr (dest);*addToVar (constPar.expr, dest, ODD (stackedBytes), TRUE, constPar.range);(END;&ELSE(pushSingle (ODD (stackedBytes), FALSE)&END;&IF dest.kind = stack THEN(INC (stackedBytes, dest.stackedSize);(dest.stackedSize:= 0;&END;&IF elems = 0L THEN EXIT END;&IF CurrentSymbol.itemNo # comma THEN SyntaxError (rComXp) END;$END(*LOOP*);$deallocRegs (dest); (* Hilfs-Zeiger freigeben *)$IF isConst & restoreCode () THEN&dest:= constPar.expr;&dest.item:= arrayType;&IF startPtr # NIL THEN((* Es war eine Konstante -> Hilfsreg-Benutzung wieder entfernen;      *)* Dies ist v.A. wichtig, weil sonst A3 fÑlschlicherweise erhîht wÑre *)(A3Offset:= oldA3;((* noch kein weiterer Code erzeugt -> einfach CodePtr rÅcksetzen *)(SetCodePtr (startPtr)&END;$ELSE&initStackExpr (dest, arrayType, A3);&dest.up:= FALSE;&dest.stackedSize:= roundedSize (dest);$END; $ChkRbrace;$PushExpr (dest)"END hdlArrayConstructor;   PROCEDURE hdlRecordConstructor (recordType: PtrItem);""VAR a3, a7: LONGINT;&long, saved, isConst: BOOLEAN;&singlePar, constPar: ParExprDesc;&sourcePtr, destPtr, cutPtr: ADDRESS;&constSave: ConstValue;&prev, dest: ExprDesc;&loadedBytes, relocNo: LONGCARD;&spillSpSv: INTEGER;&symbol: Symbol;&reg: RegSet; "PROCEDURE saveCode;$BEGIN&a3:= A3Offset;&a7:= A7Offset;&prev:= dest;&cutPtr:= CodePtr();&spillSpSv:= spillSp;&relocNo:= RelocCount;&LastDataRelocAdr:= NIL;&saved:= TRUE;$END saveCode; "PROCEDURE restoreCode (): BOOLEAN;$(*%* Diese Routine stellt den gesicherten Zustand wieder her:%* Der Code-Ptr wird zurÅckgesetzt und 'dest.stackedSize' auch.%* Dies funktioniert nur solange, wie wirklich nur einfache Kopier-%* schleifen abgelegt wurden. Es kann aber z.B. bei der unteren%* Anwendung auch vorkommen, daû zw. zwei Konstanten ein Reg gespilled%* wird. Dann darf 'restoreCode' nicht benutzt werden, weil diese%* Routine nicht fÑhig wÑre, das erfolgte Spilling wieder rÅckgÑngig%* zu machen. Theoretisch wÑre das zwar mîglich, dann sollte dafÅr%* aber ein allg. Routine erstellt werden, die dann alle VerÑnderungen%* auch fÅr andere Peephole-Anwendungen rÅckgÑngig machen kann.%* Auch sollten dann ReloziereintrÑge wieder entfernt werden kînnen.%*)$BEGIN&IF saved THEN(IF (spillSpSv # spillSp) THEN*isConst:= FALSE;*RETURN FALSE(END;(IF (relocNo # RelocCount) THEN*IF (relocNo+1 = RelocCount) & (LastDataRelocAdr # NIL) THEN,(* Relozierverweis auf DATA-Element rÅckgÑngig machen *),LastDataRelocAdr^:= 0*ELSE,isConst:= FALSE;,RETURN FALSE*END(END;(saved:= FALSE;(dest:= prev;(SetCodePtr (cutPtr);(A3Offset:= a3;(A7Offset:= a7;&END;&RETURN TRUE$END restoreCode; "PROCEDURE pushSingle;$BEGIN&IF InConstExpr THEN SyntaxError (rConXp) END;&isConst:= FALSE; (* muû VOR stack-Abfrage stehen! *)&saved:= FALSE;&reloadPtr (dest);&IF singlePar.expr.kind = stack THEN((*$? Safety: assert (singlePar.expr.stackReg = A3);*)(IF dest.stackReg = A3 THEN*RETURN(END;&END;&addToVar (singlePar.expr, dest, FALSE, TRUE, singlePar.range);&initConstPar (constPar);$END pushSingle; "PROCEDURE addConst (VAR par, constPar: ParExprDesc; VAR dest: ExprDesc);$BEGIN&fitValue (par.expr, par.range);&addToConstPar (par, constPar, TypeLength (par.parType), FALSE);&saveCode;&IF NOT InConstExpr THEN(reloadPtr (dest);(addToVar (constPar.expr, dest, FALSE, TRUE, constPar.range)&END;$END addConst; "PROCEDURE fillUp (VAR constPar: ParExprDesc; VAR dest: ExprDesc; len: LONGCARD);$VAR constOne: ParExprDesc;$BEGIN&WHILE len > 0 DO(WITH constOne DO*parType:= CharPtr;*initExpr (expr, parType, constant);*expr.exprConst.ch:= 0C;*byRef:= FALSE; openArray:= FALSE;*range:= alwaysFitting (parType);*dest.item:= parType;(END;(IF isConst & canAddToConstPar (constOne) & restoreCode () THEN*addConst (constOne, constPar, dest);*INC (loadedBytes);*DEC (len)(ELSE*(*$? Safety: assert ((dest.kind=stack) & (dest.stackReg=A3)); *)*incReg (A3, toZZ (len,FALSE), 4);*INC (loadedBytes, len);*len:= 0(END;(dest.stackedSize:= 0;&END;$END fillUp; "PROCEDURE sync (field: PtrItem);$BEGIN&(*$? Safety: assert (ItemNo (field) = 14); *)&(* prÅfen, ob ggf. ein FÅllbyte eingefÅgt werden muû *)&IF INT (TypeLength (field)) < INT (loadedBytes) THEN((* das kann nur ein mit "[x]" rÅckversetzter Offset sein - geht nicht! *)(SyntaxError (rReOfs)&END;&fillUp (constPar, dest, TypeLength (field) - loadedBytes)$END sync; "PROCEDURE addField (field: PtrItem);$BEGIN&(*$? Safety: assert (ItemNo (field) = 14); *)&dest.item:= singlePar.parType;&IF isConst & canAddToConstPar (singlePar) & restoreCode () THEN(addConst (singlePar, constPar, dest);&ELSE(pushSingle&END;&INC (loadedBytes, TypeLength (singlePar.parType));&dest.stackedSize:= 0;$END addField; "PROCEDURE fieldListSeq (recField: PtrItem);$VAR parType, tagField: PtrItem;(value: LONGINT;$BEGIN&LOOP(parType:= RefType (recField);(IF ItemNo (recField) = 47 THEN*(*+* Variante auswerten.+* Dazu wird eine ConstExpr geholt, dann auf AsnCompat geprÅft.+* Dann wird in den Tags nach dem Wert gesucht.+* Wenn ein Var-Feld existiert, wird der Wert zugewiesen.+*)*GetSymbol;*PushExpr (dest);*ConstExpression ();*singlePar.parType:= parType;*WITH singlePar DO,PopExpr (expr);,PopExpr (dest);,byRef:= FALSE; openArray:= FALSE;,checkAsnCompat (expr, parType, range, rParTy);,fitValue (expr, range);,(* zuerst legen wir den Wert ab, falls nîtig *),IF BaseType (recField) # 0 THEN.sync (BaseType (recField));.addField (BaseType (recField)),END;,(* Nun suchen wir nach dem Wert in den Tags *),value:= expr.exprConst.zz.v;,tagField:= TagFieldList (recField);,LOOP.IF tagField = 0 THEN0(* Wert exist. nicht in Tag-Feldern *)0SyntaxError (rNoTag).END;.IF (value >= LowBound (tagField)) & (value <= HighBound (tagField)) THEN0(* gefunden *)0fieldListSeq (NextParm (tagField));0EXIT.END;.tagField:= NextTagField (tagField);,END;*END(ELSE*(* normales Record-Feld auswerten *)*PushExpr (dest);*sync (recField);*getSingle (singlePar, parType, isConst);*PopExpr (dest);*addField (recField);(END;((recField:= NextRecField (recField);(IF recField = 0 THEN*EXIT(END;((IF CurrentSymbol.itemNo # comma THEN SyntaxError (rComXp) END;&END (* LOOP *)$END fieldListSeq; "BEGIN (* hdlRecordConstructor *)$(*%* Das Kopieren des Records geht folgendermaûen:%* Die Daten werden, falls es keine ConstExpr ist, auf den A3-Stack%* gelegt.%* Wird A3 verwendet, muû noch der Sonderfall, daû durch einen%* Funktionsaufruf das Ergebnis schon auf dem Stack steht,%* berÅcksichtigt werden (geschieht in 'pushSingle').%*)$IF NOT InConstExpr THEN checkStack (TypeLength (recordType)) END;$initStackExpr (dest, NIL, A3);$initConstPar (constPar);$isConst:= TRUE;$saved:= FALSE;$loadedBytes:= 0;$$fieldListSeq (FirstRecField (recordType));$fillUp (constPar, dest, TypeLength (recordType) - loadedBytes);$$deallocRegs (dest); (* Hilfs-Zeiger freigeben *)$IF isConst & restoreCode () THEN&dest:= constPar.expr;&dest.item:= recordType;$ELSE&initStackExpr (dest, recordType, A3);&dest.up:= FALSE;&dest.stackedSize:= roundedSize (dest);$END;$ChkRbrace;$PushExpr (dest)"END hdlRecordConstructor;   (* Testausgaben: PROCEDURE errorBdTyp (l, r: PtrItem);"VAR ok: BOOLEAN;"BEGIN$ConvCard (ItemNo (l), 0, BadId);$Append ('/', BadId, ok);$Append (CardToStr (ItemNo (r), 0), BadId, ok);$SyntaxError (rBdTyp)"END errorBdTyp; *)  PROCEDURE adjustRangeType (t: PtrItem; upperType: PtrItem);"VAR min, max, lo, hi: ZZ; elems: LONGCARD; baseType: PtrItem;"BEGIN$baseType:= BaseType (t);$lo:= toZZ (LowBound (t), signedType (baseType));$hi:= toZZ (HighBound (t), signedType (upperType));$IF TypeLength (t) = 0L THEN&baseType:= makeZZ (baseType)$ELSE&(*$? Safety: assert (t # ZZTyp)*) (* wenn doch, dann Abfrage unten Ñndern! *)$END;$IF NOT compatTT (baseType, makeZZ (upperType)) THEN&SyntaxError (rBdTyp)&(* errorBdTyp (baseType, makeZZ (upperType)) *)$END;$IF cmpZZ (lo, hi) = gt THEN&SyntaxError (rLowHi)$END;$IF baseType # ZZTyp THEN&(* Subrange hat schon festen Typ - prÅfen, ob alles paût *)&getBounds (BaseType (t), min, max);&IF (cmpZZ (lo, min) = lt) OR (cmpZZ (hi, max) = gt) THEN(SyntaxError (rBouRg)&END;$ELSE&(* wir mÅssen einen neuen Typen und Grîûe bestimmen *)&getNumTypeForRange (lo, hi, baseType);&IF baseType = SBothTyp THEN(baseType:= SCardPtr&ELSIF baseType = BothTyp THEN(baseType:= CardPtr&END;&SetBaseType (t, baseType);$END;$SetTypeLength (t, TypeLength (baseType))"END adjustRangeType;   PROCEDURE hdlInclExcl (incl: BOOLEAN);"VAR dest, elem, set: ExprDesc; range: ConvDesc;&lo, hi: ZZ; n: CARDINAL;"BEGIN$(* A0: Ptr auf Set; D0.W: Element; D1 frei; Range-Check hier machen! *)$GetLparen;$GetSymbol;$designator (modifyDesig, FALSE, rVarXp);$PopExpr (set);$IF (ItemNo (set.item) # 5) & (ItemNo (set.item) # 45) THEN SyntaxError (rOpTyp) END;$ChkComma;$GetSymbol ();$VarExpression ();$PopExpr (elem);$checkAsnCompat (elem, RefType (set.item), range, rBdTyp);$fitValue (elem, range);$getBounds (RefType (set.item), lo, hi);$(*$? Safety: assert (set.typeChecked);*)$IF elem.kind = constant THEN&IF NOT set.zerobased THEN subZZ (elem.exprConst.zz, lo) END;&n:= elem.exprConst.zz.c DIV 8;&IF set.regset THEN(n:= SHORT (Size (set)) - 1 - n&END;&IF (n > 0) & (set.kind # register) THEN(loadAddress (set);(makeIndir (set, n, FALSE)&END;&IF incl THEN n:= BSETI ELSE n:= BCLRI END;&genia (n, elem.exprConst.zz.c, set, -1);$ELSIF set.regset THEN&(*'* Hier wird sichergestellt, daû in 'dest' nur eine einfache'* Adressierung mit Åber d16(An) erfolgt, also keinesfalls mit'* d8(An,Dn), weil sonst evtl. Dn doppelt (als set-Var im Reg und'* bei moveSingle am Ende) benutzt wird.'*)&makeInd0An (set);&dest:= set;&loadReg (set, anyDataReg);&loadReg (elem, anyDataReg);&IF NOT set.zerobased THEN(negZZ (lo);(loadReg (elem, dataRegs);(incReg (elem.exprReg, lo, 2)&END;&IF incl THEN n:= BSET ELSE n:= BCLR END;&genar (n, set, elem.exprReg);&moveSingle (set, dest, 0);$ELSE&IF incl THEN(runtimeElemSet (elem, set, add, lo)&ELSE(runtimeElemSet (elem, set, sub, lo)&END;$END;$deallocRegs (elem);$deallocRegs (set);$GetRparen;"END hdlInclExcl;   PROCEDURE forStatement; "VAR count, help, var, first, last: ExprDesc;&firstRange, lastRange: ConvDesc;&op: Operator;&loops, by, lo, hi: ZZ;&loopStart, loopEnd: Label;&flags: IFS;&regs: RegSet;&lastSuppress, wasReg, usedReg, regVar,&firstOnA7, constInReg, constLoop: BOOLEAN;&constReg, regNo, varReg, varPtr: RegType;&t: PtrItem;&n: CARDINAL;&stackUsed: LONGCARD;&"BEGIN$(*%* FOR var := first TO last DO ...%*%* Regeln:%*   - first ist asn-compat zu var%*   - last ist identisch mit HostType (var)%*   - erst first & last ausrechnen, dann verleichen;%*     nur, wenn first <= last, dann Schleife:%*       - first auf var zuweisen%*       - statement-sequence%*       - INC (first)%*%* Der Code sieht dann so aus (Optimierung auf KÅrze):%*%* >> Wenn 'first' auf dem A7 steht ('last' natÅrlich nicht):%*          MOVE    first,Dx%*          MOVE    last,-(A7)%* >> sonst:%*          MOVE    last,-(A7)%*          MOVE    first,Dx%*%*          ; hier ggf. Range-Check f. var:= first%*  loop:   CMP     (A7),Dx%*          BHI     ende%*          MOVE    Dx,var%*          ...%*          MOVE    var,Dx%*          ADDI    #by,Dx%*          BCC     loop%*  ende:   ADDQ    #Size(last),A7%*%* Beim konstanten Schleifen wird folg. codiert:%*          MOVE    #hi-lo,-(A7)%*          MOVE    #first,var%*  loop:   ...%*          ADDI    #by,var%*          SUBQ    #1,(A7)%*          BCC     loop%*          ADDQ    #Size(count),A7%*%*%*)$GetSymbol;$$IF NOT (userDef IN CurrentSymbol.flags)$OR (ORD (CurrentSymbol.typ) # 17)$OR (  IFS {exported, imported, extVar, indirVar}(* CurrentSymbol.flags # IFS {})$OR (procDepth (Tiefe) # 0)$OR (global IN CurrentSymbol.flags) & (Global # 0) THEN&SyntaxError (rForVr)$END;$var.varItem:= CurrentSymbol.item;$IF NOT isOrdinal (RefType (var.varItem)) THEN SyntaxError (rScLop) END;$IF refVar IN CurrentSymbol.flags THEN SyntaxError (rRdOnl) END;$IF (AccessDepth (var.varItem) > Global+1) AND NOT suppressOpt () THEN&(* auf Var wurde schon in lok. Proz. zugegriffen - darf nicht bei'* Schleifenvar in Reg! *)&SyntaxError (rForAc)$END;$$(*%* Nun wird die Laufvar. einfach als temp. Reg-Var definiert.%* Das wird aber nur getan, wenn noch ein Reg frei ist, das noch%* nicht fÅr eine Reg-Var vorgemerkt ist. Denn wÅrde ein Reg benutzt,%* das z.Zt. zwar frei ist, dann aber in der Schleife doch benutzt%* werden soll, kann es ineffektiv werden, wenn das dann nicht geht;%* wenn das belegte Reg gar von einer Var. f. eine FOR-Schleife reserv.%* ist, kann es noch aufwendiger werden.%*)$wasReg:= IsRegVar (var.varItem);$regVar:= wasReg OR NOT suppressOpt () & allocRegVar (dataVar, regNo);$IF regVar THEN&initExpr (var, RefType (var.varItem), register);&var.varItem:= CurrentSymbol.item;&IF wasReg THEN(regNo:= UsedReg (var.varItem);((*$? Safety: assert (NOT (regNo IN freeVarRegs));*)(var.exprReg:= regNo;(usedReg:= IsInReg (var.varItem);(IF usedReg THEN*(*$? Safety: assert (NOT (regNo IN freeRegs))*)(ELSE*(*$? Safety: assert (regNo IN freeRegs);*)*EXCL (freeRegs, regNo)(END&ELSE((* wenn Reg vorher unbenutzt war, dann nun auf A7 retten *)((*$? Safety: assert (regNo IN freeVarRegs);*)(pushNonTemp (regNo, TRUE); (* immer LONG retten, da evtl. ein MOVEQ.L gen. wird! *)(usedReg:= FALSE;(var.exprReg:= regNo;&END;&PushExpr (var);&GetSymbol;$ELSE&(* wenn kein Reg frei, dann als normale Var ansprechen *)&designator (setDesig, FALSE, rForVr);&LookExpr (var);$END;$$IF CurrentSymbol.itemNo # becomes THEN SyntaxError (rAsgXp) END;$$GetSymbol ();$VarExpression ();$LookExpr (first);$checkAsnCompat (first, var.item, firstRange, rParTy);$$IF CurrentSymbol.itemNo # toSym THEN SyntaxError (rToXp) END;$$GetSymbol ();$VarExpression ();$PopExpr (last);$adaptZZ (last, var.item, TRUE);$adaptSSToChar (last);$IF NOT compatTT (var.item, last.item) THEN SyntaxError (rForTo) END;$getConversionDesc (last.item, var.item, lastRange);$lastRange.lowerBound:= LONGWORD (0L);$$IF CurrentSymbol.itemNo = bySym THEN&GetSymbol;&ConstExpression ();&PopExpr (help);&by:= help.exprConst.zz;&IF NOT isWholeNumber (help.item) OR nullZZ (by) THEN(SyntaxError (rIntSt)&END;$ELSE&by:= toZZ (1L, FALSE)$END;$$IF CurrentSymbol.itemNo # doSym THEN SyntaxError (rDoXp) END;$$stackUsed:= 0;$IF last.kind = constant THEN&fitValue (last, lastRange); (* prÅfe, ob Wert innerhalb 'var' liegt *)&lastRange:= alwaysFitting (var.item);$END;$$PopExpr (first);$reloadPtr (first);$firstOnA7:= (first.kind = stack) & (first.stackReg = A7);$$PopExpr (var);$(* kann eh nicht vorkommen:  reloadPtr (var); *)$$(*$? Safety: assert ((last.kind#stack) OR (last.stackReg=A3)); (* siehe oben, Codebsp. *) *)$IF (last.kind # constant) & NOT firstOnA7 THEN&loadOnA7 (last, alwaysFitting (var.item), stackUsed)$END;$$IF regVar THEN&IF NOT usedReg THEN(IF NOT wasReg THEN*MakeRegVar (var.varItem);*SetReg (var.varItem, regNo)(END;(UseReg (var.varItem)&END$ELSE&(*'* Hier muû 'var' in ein einziges Reg geladen werden, falls der'* mode d8AnXn ist'*)&(*$? Safety: assert (var.kind = memory);*)&IF  (var.mode # absRef)&AND NOT ((var.mode = d16An) & NOT (var.baseReg IN tempRegs)) THEN(makeInd0An (var);&END;&IF var.mode # absRef THEN(varPtr:= var.baseReg;((*$? Safety: assert (var.mode = d16An);*)((*$? Safety: assert ((varPtr = A0) OR (varPtr = VarReg))*)&END;$END;$$fitValue (first, firstRange);$$constLoop:= ~suppressOpt () & (first.kind = constant) & (last.kind = constant);$$IF constLoop THEN$&(* Access-Level lîschen, um zu erkennen, ob Zugriff darauf erfolgt *)&SetAccessDepth (var.varItem, 0);$&loops:= last.exprConst.zz;&subZZ (loops, first.exprConst.zz);&divZZ (loops, by);&&lastSuppress:= SuppressCode;&IF NOT posZZ (loops) THEN(SuppressCode:= TRUE&END;&&initConstExpr (count, sizeZZeven (loops), loops);&constInReg:= allocRegVar (dataVar, constReg);&IF constInReg THEN((*$? Safety: assert (constReg IN freeVarRegs);*)((* da Reg vorher unbenutzt war, nun auf A7 retten *)(pushNonTemp (constReg, TRUE); (* immer LONG retten, da evtl. ein MOVEQ.L gen. wird! *)(INCL (freeRegs, constReg);(regs:= RegSet {};(INCL (regs, constReg);(loadReg (count, regs);&ELSE(loadOnA7 (count, alwaysFitting (count.item), stackUsed);&END;&loopEnd:= NIL; $ELSE$&IF regVar & NOT usedReg THEN(regs:= RegSet {};(INCL (regs, regNo);(INCL (freeRegs, regNo)&ELSE(regs:= anyDataReg&END;&loadReg (first, regs);&IF (last.kind # constant) & firstOnA7 THEN(loadOnA7 (last, alwaysFitting (var.item), stackUsed)&END;&(*$? Safety: assert (NOT regVar OR NOT (regNo IN freeRegs));*)&&loopStart:= CodePtr ();&IF last.kind = constant THEN(genia (CMPI, last.exprConst.zz.v, first, 0);&ELSE(genar (CMP, last, first.exprReg)&END;&IF posZZ (by) THEN op:= gt ELSE op:= lt END;&genbcc (mapCC (op, signedExpr (var), FALSE), FALSE, loopEnd);$$END;$$(* MOVE  Dx,var *)$IF NOT constLoop THEN&varReg:= first.exprReg;$END;$help:= var;$moveToVar (first, help, lastRange);$ClearDirt (var.varItem);$$IF constLoop THEN&loopStart:= CodePtr ();$END;$$help:= var;$PushExpr (var);$(*%*   spillAllRegs ();%*%* nun muû var-Desc entw. auf dem Stack stehen,%* global sein, in einer Reg-Var stehen oder mit d16(A6) adr. sein.%*%* >>> spilling brÑuchte eigentlich gar nicht unbedingt getan werden,%*     denn es kann sein, daû in den folg. statements das reg nicht%*     gespilled werden braucht. Allerdings mÅssen die 3 unteren%*     Vars f. RETURN und EXIT richtig gesetzt sein, und deshalb%*     mÅûten dann diese Vars in 'spillReg' und 'reloadPtr' korrigiert%*     werden.%*)$$flags:= ItemFlag (var.varItem);$SetItemFlag (var.varItem, flags + IFS {refVar}); (* 'var' schÅtzen *)$$StatementSequence;$$SetItemFlag (var.varItem, flags);$$IF CurrentSymbol.itemNo # endSym THEN SyntaxError (rBdSym) END;$GetSymbol;$$PopExpr (var);$reloadPtr (var);$IF regVar THEN&IF NOT usedReg THEN(UseMem (var.varItem);(deallocRegVar (regNo);&END;&IF NOT wasReg THEN(MakeMemVar (var.varItem);&END;$ELSE&(*$? Safety:(assert (var.kind = memory);(assert ((var.mode = absRef) OR (var.mode = d16An));(assert ((var.mode # d16An) OR (varPtr = var.baseReg));&*)$END;$$IF constLoop THEN&&IF AccessDepth (var.varItem) # 0 THEN((* Auf Laufvar. wurde zugegriffen *)((* DEC (var, by) *)(IF int3ZZ (by) THEN*genQ (by.i, var)(ELSE*genia (ADDI, by.l, var, 0)(END;&END;&&IF (count.kind = register) & (Size (count) = 2L) THEN((* DBRA Dn,loopStart *)(genDBcc (mapNever (), count.exprReg,1LONGINT (loopStart) - LONGINT (CodePtr () + 2L));&ELSE((* SUBQ  #1,(A7) *)(genQ (-1, count);((* BCC   loopStart *)(bccBackTo (mapCC (cc, FALSE, FALSE), loopStart);&END;&&IF constInReg THEN deallocRegVar (constReg) END;&$ELSE$&(* MOVE  var,Dx *)&regs:= RegSet {};&INCL (regs, varReg);&loadReg (help, regs);&deallocRegs (help);&&(* ADD   #by,Dx *)&incReg (first.exprReg, by, SHORT (Size (help)));&(* BCC   loopStart *)&bccBackTo (mapCC (cc, signedType (help.item), FALSE), loopStart);$$END;$$(* END of FOR *)$(* ADDQ #2/4,A7 *)$ToHere (loopEnd);$incReg (A7, toZZ (stackUsed, FALSE), 4);$$IF constLoop THEN&IF constInReg THEN(popNonTemp (constReg);&END;&SuppressCode:= lastSuppress;$ELSIF suppressOpt () & NOT wasReg THEN&(* letzten Schleifenwert in die Var zurÅckladen *)&(*$? Safety: assert (first.kind = register);*)&genMOVEaa (first, var, 0);$END;$$IF regVar & NOT wasReg THEN&popNonTemp (regNo);$END;$$SetDirt (var.varItem);$"END forStatement;   PROCEDURE hdlIncDec (doInc: BOOLEAN);"VAR var, arg: ExprDesc;&vtype: PtrItem;&opcode: CARDINAL;&doCheck: BOOLEAN;&range: ConvDesc;&lo, lo2, hi, hi2: ZZ;"BEGIN$GetLparen;$GetSymbol;$designator (modifyDesig, FALSE, rVarXp);$PopExpr (var);$IF NOT (scalar IN ItemFlag (var.item)) & (ItemNo (var.item) # 20 (* POINTER *)) THEN&SyntaxError (rSclXp)$END; $IF CurrentSymbol.itemNo = comma THEN&PushExpr (var);&GetSymbol ();&VarExpression ();&PopExpr (arg);&PopExpr (var);&reloadPtr (var);&IF NOT isWholeNumber (arg.item) THEN(SyntaxError (rWhNXp)&END;$ELSE&initExpr (arg, var.item, constant);&arg.exprConst.zz.c:= 1$END; $vtype:= sizedItem (SHORT (Size (var)), signedType (var.item));$getConversionDesc (arg.item, vtype, range);$fitValue (arg, range); $doCheck:= TRUE;$IF arg.kind = constant THEN&IF int3ZZ (arg.exprConst.zz) THEN(IF NOT nullZZ (arg.exprConst.zz) THEN*IF NOT doInc THEN negZZ (arg.exprConst.zz) END;*genQ (arg.exprConst.zz.i, var)(ELSE*doCheck:= FALSE(END&ELSIF (var.kind = register) & (var.exprReg >= A0) THEN(addConstToAddrReg (arg.exprConst.zz.v, var.exprReg)&ELSE(IF doInc THEN opcode:= ADDI ELSE opcode:= SUBI END;(genia (opcode, arg.exprConst.l, var, 0)&END$ELSE&IF signedType (var.item) # signedType (arg.item) THEN(SyntaxError (rBdTyp)&END;&loadReg (arg, anyDataReg);&IF doInc THEN opcode:= ADD ELSE opcode:= SUB END;&genra (opcode, arg.exprReg, var)$END;$deallocRegs (arg);$IF doCheck THEN&getBounds (var.item, lo, hi);&var.item:= sizedItem (SHORT (Size (var)), signedType (var.item));&getBounds (var.item, lo2, hi2);&IF (cmpZZ (lo, lo2) # eq) OR (cmpZZ (hi, hi2) # eq) THEN(checkBounds (var, lo, hi, lo2);&ELSE(checkOverflow (var.item)&END;$END;$deallocRegs (var);$GetRparen"END hdlIncDec;  PROCEDURE withStatement;"VAR oldA2ofs: INTEGER;&lastWith: BOOLEAN;&withPtr: ExprDesc;"BEGIN$GetSymbol;$designator (readDesig, FALSE, rReDXp);$PopExpr (withPtr);$IF ItemNo (withPtr.item) # 13 THEN SyntaxError (rReDXp) END;$IF withPtr.regVar THEN SyntaxError (rRegVa) END;$IF CurrentSymbol.itemNo # doSym THEN SyntaxError (rDoXp) END;$$lastWith:= WithScope;$WithScope:= TRUE;$OpenScope (LocalTree (withPtr.item));$INC (ROScope, 4);$loadDisplay (withPtr);$$StatementSequence;$$freeDisplay;$CloseScope ();$DEC (ROScope, 4);$WithScope:= lastWith;$$IF CurrentSymbol.itemNo # endSym THEN SyntaxError (rBdSym) END;$GetSymbol;$"END withStatement;   VAR lastA3, lastA7: LONGINT;  PROCEDURE codeBegin;"BEGIN$exprSp:= -1;$spillSp:= -1;$spilling:= FALSE;$spillDestReg:= A7;$spillDestDir:= down;$RelocCount:= 0;$SuppressCode:= FALSE;$lastA3:= A3Offset;$lastA7:= A7Offset;$SavedTempRegs:= freeRegs * tempRegs;$openDisplay;  (* fÅr WITH *)"END codeBegin;  PROCEDURE codeEnd;"BEGIN$closeDisplay;  (* fÅr WITH *)$(*$? Safety:$assert (exprSp = -1);$assert (spillSp = -1);$assert (NOT SuppressCode);$*)$IF (lastA3 # A3Offset) OR (lastA7 # A7Offset) THEN&IF lastA3 # A3Offset THEN BadId:= 'A3/codeend' ELSE BadId:= 'A7/codeend' END;&SyntaxError (rIntSP);&A3Offset:= lastA3;&A7Offset:= lastA7;$END;"END codeEnd;  PROCEDURE moveRegs (regs: RegSet; pop: BOOLEAN);""VAR ncpu, nfpu: CARDINAL; r2, r1, r: RegType; lastA7: LONGINT;&list: RECORD dummy: BYTE; fpu: BYTE; cpu: CARDINAL; END;""PROCEDURE moveFPU;$BEGIN&IF nfpu # 0 THEN moveRealRegs (pop, ORD(list.fpu)); END;$END moveFPU;""PROCEDURE moveCPU;$VAR st: ExprDesc;$BEGIN&IF ncpu = 1 THEN(IF pop THEN*genPopReg (r1, TRUE, A7)(ELSE*genPushReg (r1, TRUE, A7)(END&ELSIF ncpu # 0 THEN((* MOVEM gen. *)(initStackExpr (st, CardPtr, A7);(st.up:= pop;(gena (MOVEML + $400 * ORD (pop), st, -1);(gen (list.cpu)&END;$END moveCPU;""BEGIN$lastA7:= A7Offset;$(*%* CPU-Regs und FPU-Regs sichern%*)$ncpu:= 0;$nfpu:= 0;$list.cpu:= 0;$list.fpu:= BYTE(0);$FOR r:= D0 TO F7 DO&IF (r IN (varRegs - RegSet {A3,A7}))  (* wenn's ein Var-Reg ist *)&& NOT (r IN regs)                     (* und es belegt wurde    *) THEN(r2:= r;(IF r < F0 THEN r1:= r END;(ASSEMBLER*; r: 0..23*; F:23-16, D/A:15-0*MOVE.W  r2(A6),D0     ;Vorsicht! 'r' liegt u.U. im Register!*TST     pop(A6)*BNE     norev*SUBI    #15,D0*BHI     freg*NEG     D0*BRA     norev(freg*SUBQ    #8,D0*NEG     D0*ADDI    #16,D0(norev*MOVE.L  list(A6),D1*BSET    D0,D1*MOVE.L  D1,list(A6)(END;(IF r < F0 THEN INC (ncpu) ELSE INC (nfpu) END&END;$END;$IF pop THEN&moveFPU;&moveCPU;$ELSE&moveCPU;&moveFPU$END;$A7Offset:= lastA7"END moveRegs;   (*$D-*)  VAR helpCh: CHAR;$helpRange: ConvDesc;$false: Labels;$helpTarget: Label;$helpType: PtrItem;$size: LONGCARD;$helpAddr3, helpAddr2, helpAddr: ADDRESS;$lastOffset: LONGINT;$expandToLongOfs, no, no2: CARDINAL;$helpReg: RegType;$regList: RegSet;$mustReduceZZ: BOOLEAN;  PROCEDURE expr;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$lastOffset:= A3Offset;$(*$? Safety: assert (NOT ODD (A3Offset));*)$GetSymbol ();$VarExpression ();$PopExpr (helpExpr);$reduceZZ (helpExpr);$adaptSSToChar (helpExpr);$loadOnA3 (helpExpr, alwaysFitting (helpExpr.item));$(*$? Safety: assert (NOT ODD (A3Offset));*)$A3Offset:= lastOffset;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7(LEA     helpExpr,A0(MOVE.L  helpExpr.item(A0),D0(JSR     PushInt$END"END expr;"(*$L=*)  PROCEDURE caseExpr;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$GetSymbol ();$VarExpression ();$PopExpr (helpExpr);$IF NOT (scalar IN ItemFlag (helpExpr.item)) THEN SyntaxError (rScCas) END;$reduceZZ (helpExpr);$adaptSSToChar (helpExpr);$no2:= SHORT (Size (helpExpr));$IF no2 < 2 THEN no2:= 2 END;$loadRegExt (helpExpr, RegSet {D0}, no2, FALSE);$deallocReg (D0);$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7(LEA     helpExpr,A0(MOVE.L  helpExpr.item(A0),D0(JSR     PushInt$END"END caseExpr;"(*$L=*)  PROCEDURE pushExpr;"(*$L-*)"BEGIN$ASSEMBLER(MOVE.W  D0,no(JSR     PullInt(MOVE.L  D0,helpAddr(JSR     Entry$END;$(*$? Safety:&assert (NOT ODD (A3Offset));$*)$lastOffset:= A3Offset;$GetSymbol ();$VarExpression ();$PopExpr (helpExpr);$checkAsnCompat (helpExpr, helpAddr, helpRange, rParTy);$IF no = 0 THEN&loadOnA3 (helpExpr, helpRange);$ELSE&fitValue (helpExpr, helpRange);&loadReg (helpExpr, RegSet {D0});&deallocReg (D0)$END;$(*$? Safety: assert (NOT ODD (A3Offset));*)$A3Offset:= lastOffset;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END pushExpr;"(*$L=*)  PROCEDURE pushAdr;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$lastOffset:= A3Offset;$designator (varDesig, FALSE, rVarXp);$PopExpr (helpExpr);$IF helpExpr.regVar THEN SyntaxError (rRegVa) END;$helpAddr:= helpExpr.item;$loadSourceAddress (helpExpr);$loadOnA3 (helpExpr, alwaysFitting (helpExpr.item));$A3Offset:= lastOffset;$ASSEMBLER(JSR     Exit(MOVE.L  helpAddr,D0(JSR     PushInt(MOVEQ   #0,D7$END"END pushAdr;"(*$L=*)  PROCEDURE doConstExpr;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$ConstExpression;$PopExpr (helpExpr);$IF mustReduceZZ THEN&reduceZZ (helpExpr)$END;$(*%* nun muû die Konstante zurÅck in den Accu%*)$size:= Size (helpExpr);$helpAddr2:= ADR (Accu);$expandToLongOfs:= 0;$IF isSS (helpExpr) THEN&helpAddr2:= ADR (STRBUF);&helpExpr.item:= StrPtr;&StrLen:= SHORT (size);&IF StrLen > SIZE (STRBUF) THEN SyntaxError (rSCoLg) END;$ELSE&IF (size < 4L) & (scalar IN ItemFlag (helpExpr.item)) THEN(expandToLongOfs:= SHORT (4-size);(size:= 4&ELSIF size > LONG(AccuSize) THEN(helpAddr2:= NIL (* Datum nicht kopieren, sondern Ptr drauf liefern *)&END$END;$IF helpExpr.kind = constRef THEN&IF helpExpr.constHead = NIL THEN dropConstantFromTree (helpExpr) END;&helpAddr3:= helpExpr.constAddr + helpExpr.constOfs - LONG(expandToLongOfs);&cutConst (helpExpr);$ELSE&helpAddr3:= ADR (helpExpr.exprConst.b)-size+1L$END;$IF helpAddr2 # NIL THEN&AccuPtr:= helpAddr2;&Move (helpAddr3, helpAddr2, SHORT (size));$ELSE&AccuPtr:= helpAddr3$END;$ASSEMBLER(JSR     Exit(LEA     helpExpr,A0(MOVE.L  helpExpr.item(A0),D0(JSR     PushInt$END"END doConstExpr;"(*$L=*)  PROCEDURE constExpr;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    mustReduceZZ,-(A7)(MOVE    #1,mustReduceZZ(JSR     doConstExpr(MOVE    (A7)+,mustReduceZZ$END"END constExpr;"(*$L=*)  PROCEDURE constExprZZ;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    mustReduceZZ,-(A7)(CLR     mustReduceZZ(JSR     doConstExpr(MOVE    (A7)+,mustReduceZZ$END"END constExprZZ;"(*$L=*)  PROCEDURE boolExpr;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$BoolExpression (false);$PushLabels (false, no);$(*$?Safety2: assert (LabelsInPool = 0); *)$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7(MOVE.W  no,D0$END"END boolExpr;"(*$L=*)  PROCEDURE assign;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry(MOVE.L  A3,-(A7)$END;$InConstExpr:= FALSE;$assignment;$ASSEMBLER(MOVE.L  (A7)+,A0(CMPA.L  A0,A3(BEQ     ok$END;$BadId:= 'A3 corrupted';$SyntaxError (rFatlR);$ASSEMBLER&ok(JSR     Exit(MOVEQ   #0,D7$END"END assign;"(*$L=*)  PROCEDURE adjustSubrange;"(*$L-*)"BEGIN$ASSEMBLER(MOVE.L  D0,helpAddr(JSR     Entry$END;$adjustRangeType (CurrentSymbol.item, helpAddr);$ASSEMBLER(JSR     Exit$END"END adjustSubrange;"(*$L=*)  PROCEDURE aCallSys;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$helpType:= CurrentSymbol.item;$GetLparen;$hdlCall (0, helpType);$GetRparen;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aCallSys;"(*$L=*)  PROCEDURE aCallExt;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$helpType:= CurrentSymbol.item;$GetLparen;$hdlCall (1, helpType);$GetRparen;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aCallExt;"(*$L=*)  PROCEDURE aLoad;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlLoad;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aLoad;"(*$L=*)  PROCEDURE aStore;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlStore;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aStore;"(*$L=*)  PROCEDURE aExcl;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlInclExcl (FALSE);$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aExcl;"(*$L=*)  PROCEDURE aIncl;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlInclExcl (TRUE);$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aIncl;"(*$L=*)  PROCEDURE aInc;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlIncDec (TRUE);$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aInc;"(*$L=*)  PROCEDURE aDec;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$hdlIncDec (FALSE);$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aDec;"(*$L=*)  PROCEDURE aWith;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$withStatement;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aWith;"(*$L=*)  PROCEDURE aFor;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$forStatement;$ASSEMBLER(JSR     Exit(MOVEQ   #0,D7$END"END aFor;"(*$L=*)  PROCEDURE aBegin;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$codeBegin;$ASSEMBLER(JSR     Exit$END"END aBegin;"(*$L=*)  PROCEDURE aEnd;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$codeEnd;$ASSEMBLER(JSR     Exit$END"END aEnd;"(*$L=*)  PROCEDURE saveVarRegs;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$moveRegs (freeVarRegs, FALSE);$ASSEMBLER(JSR     Exit$END"END saveVarRegs;"(*$L=*)  PROCEDURE restoreVarRegs;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$moveRegs (freeVarRegs, TRUE);$ASSEMBLER(JSR     Exit$END"END restoreVarRegs;"(*$L=*)  PROCEDURE initBlock;"(*$L-*)"BEGIN$ASSEMBLER(JSR     Entry$END;$freeRegs:= RegSet {D0..A2,A4..A6,F0..F7};$freeVarRegs:= freeRegs;$ASSEMBLER(JSR     Exit$END"END initBlock;"(*$L=*)  PROCEDURE exclFromFreeRegs;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    D0,no(JSR     Entry$END;$EXCL (freeRegs, no);$ASSEMBLER(JSR     Exit$END"END exclFromFreeRegs;"(*$L=*)  PROCEDURE inclInFreeRegs;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    D0,no(JSR     Entry$END;$INCL (freeRegs, no);$ASSEMBLER(JSR     Exit$END"END inclInFreeRegs;"(*$L=*)  PROCEDURE getRegVar;"(*$L-*)"BEGIN$ASSEMBLER(MOVE    D0,no(JSR     Entry$END;$helpReg:= 0;$IF (VarType (no) # floatVar)$OR (VarType (no) = floatVar) & (fpu () # softReal) THEN&IF allocRegVar (VarType (no), helpReg) THEN(ASSEMBLER*MOVE    helpReg,D0*ORI     #$80,D0   ; Flag: "ist Reg-Var"*MOVE    D0,helpReg(END&END$END;$ASSEMBLER&JSR     Exit&MOVE    helpReg,D0$END"END getRegVar;"(*$L=*)  PROCEDURE discardA7;"(*$L-*)"BEGIN$ASSEMBLER(MOVE.L  D0,lastOffset(JSR     Entry$END;$releaseNonTemp (lastOffset);$ASSEMBLER(JSR     Exit$END"END discardA7;"(*$L=*)  BEGIN"FP[F0+0,FALSE]:= '@FP0L';"FP[F0+1,FALSE]:= '@FP1L';"FP[F0+2,FALSE]:= '@FP2L';"FP[F0+3,FALSE]:= '@FP3L';"FP[F0+4,FALSE]:= '@FP4L';"FP[F0+5,FALSE]:= '@FP5L';"FP[F0+6,FALSE]:= '@FP6L';"FP[F0+7,FALSE]:= '@FP7L';"FP[F0+0,TRUE]:= '@FP0H';"FP[F0+1,TRUE]:= '@FP1H';"FP[F0+2,TRUE]:= '@FP2H';"FP[F0+3,TRUE]:= '@FP3H';"FP[F0+4,TRUE]:= '@FP4H';"FP[F0+5,TRUE]:= '@FP5H';"FP[F0+6,TRUE]:= '@FP6H';"FP[F0+7,TRUE]:= '@FP7H';"ASM:= 'ASSEMBLER';"LocalA7Hidden:= FALSE;"GlobalA7Hidden:= FALSE;"SignalOverflow:= TRUE;"assert (TSIZE (ConstValue) = LONG (strConstSize + 1)); END MM2Comp2.  
(* $0006758B$0002210A$0002210A$0007237E$FFE9DEE5$FFECE853$0004F58A$FFEBC3F7$00055242$FFE9DEE5$FFEEDF64$000000C8$FFEEDF64$000778E2$FFEEDF64$00076595$FFEEDF64$0006CE38$0004682D$00054B04$00048452$0004D3C2$00055828$FFEEDF64$FFEEDF64$FFEEDF64$FFE9DEE5$FFEEDF64$FFEDA5DC$0003CB5E$FFECC0C3$0005BC6C$0005F2AD$FFEEDF64$0003545B$0005166F$0005BC65$FFEEDF64$0003F64A$FFEEDF64$00022723$0006CE0BÄ$000000B0........T.......T.......T.......T.......T.......T.......T.......T.......T.......$000221B5$000217EF$00021D9A$00021F05$00002019$0000214F$000020CC$0000214C$000020C7$000000B0$000000C8$00021EE0$00021A7D$FFE4ED30$00021ED8$00021DDB¨ÄÇ*)
