 IMPLEMENTATION MODULE MM2Comp; (*$ z-,m-,r-,l-,q+,p+,v+,c-,g+ *)  (* -----------------------------------------------------#Modula Compiler  /4.3 /  fuer Atari ST#-----------------------------------------------------#File mc1: Compiler-Rumpf, Statement-Uebersetzung##17.10.85     Auswertung von AutoCommands#21.02.86     LastGSD2 deklariert fuer Assembler#22.02.86     Neuordnung der Texte#26.02.86     esc-Konstante definiert;0Codes fuer RunErrFile- und RunAskName-0AutoCommands vertauscht;0Default-Setzung der Compileroptions nach Neustart/1neue Compilation Unit getrennt#21.03.86     (TT) Assembler : LINK-Instr. berichtigt (V#0738)#14.04.86     richtige Fehlermeldung bei lok. Modulen (Nr. 109);0$Konfig-Option abfragen, Default auf K-.#15.04.86     DirectLoc, LastOffs als ZW fuer Open-Array-Zugriff.#16.04.86     Array/Record Zuweisung mit Inline-Code uebersetzen#21.04.86     Default fuer $K ist K+#11.07.86     Assign kopiert jetzt auch Array/Record vom Stack;0in FormRes Array & Record als Funkt.Ergebnis zugelassen#28.07.86     EXIT aus WITH restauriert jetzt den A2-Pointer vor der0auessersten WITH-Anweisung#08.09.86     neues Modula-Symbol -> FirstAsmSbl, AND, OR, NOT erhoeht0'FROM Module IMPORT IdList' in lok. Module erlaubt#09.09.86     ASSEMBLER ... END alternativ zur $A-Option#06.10.86     Var. OpenConds fuer Conditional Comments eingefuehrt;0StorVar synchronisiert alle (!) Parameter auf gerade Adressen#15.10.86     Export von Aufzaehlungstypen aus lokalen Modulen (LocXp);0Import dito (ImpId, SetRelay, MarkId, MakeId);0TypPtr fuer Word/Long/Address entfallen;0Standardprozeduren nicht mehr als res. Worte behandelt#16.10.86     Voreinstellung der Option G+ in OpToSet;0dLayout = 3 wegen neuer Pseudo/System-Module;0Statseq: nach Stat10 auf Stat17 verzweigen#17.10.86     MinReal, MaxReal eingefuehrt;0EXCL / INCL / INC / DEC fuer Bytes modifiziert;0Assign fuer einzelne Bytes3(nicht fuer Rec/Arr ungerader Laenge!);0CASE fuer Byte-Selektoren (durch Expandieren des Selektors);0FOR fuer Byte-Laufvar.#18.10.86     DefVolume als Default fuer DefMod-Suche (bisher #A0: - tsk!)#20.10.86     Reihenfolge Excl/Incl in StandardProc-Sprungtabelle vertauscht#22.10.86     Block16 synchronisiert VarSpace am Ende jedes Dekl.teils;0UProc erlaubt leere '()' wenn keine Parameter erwartet.#23.10.86     Assign9 behandelt Array [..] of Char wie Strings (Atari);0andere @StAs-Prozedur fuer Atari-Version!#24.10.86     ConstExpr statt ConstEx; Typ kommt jetzt auf IntStack zurueck,0naechstes Symbol ist schon geholt!#25.10.86     Pointer als Argument in INC/DEC zugelassen#26.10.86     String-Assignment: in der Gepard-Version Laenge der Source0synchronisiert uebergeben!#28.10.86     IOTRANSFER erwartet Address als Exception-Vektorangabe;0Buffer und Groessenkonst. fuer SETs auf max. 2^16 Elemente$1.11.86     Assign benutzt fuer Strings gleicher Laenge normale Zuweisung$2.11.86     Assign orientiert sich bei skalaren Zuw. an der Dest-Laenge0(wg. Anpassung Short -> LongTypen)$8.11.86     PROCESS-Typ durch ADDRESS ersetzt#30.11.86     mehrere DC.L in einer Zeile vermieden (Assembler-Fehler)$3.12.86     aReturn erzeugt Code fuer Laengenanpassung, wenn ein String0Funktionsergebnis ist#19.12.86     in FpSect Deklaration von Open Array als ValPar erlaubt;#20.12.86     StorVar markiert Open Arrays IMMER als VAR-Parameter (weil0sie als lokale Variablen immer so zu behandeln sind).#11. 1.87     Table.D erzeugt 8 Byte pro Table-Element#14. 1.87     RealConst-Format umschaltbar#18. 1.87     CopyArrays, ProcDesc (OpenArr by Val) wieder raus#29. 1.87     neue Variable AdrOnStk gibt an, ob die Adresse der im folgenden1aufzurufenden Proc auf (A7) steht (bei ProcVar-Call)#31. 1.87     nach jedem ProcCall wird ReleaseArrays aufgerufen, um ggf.1angelegte Kopien von Open Arrays zu loeschen#15. 2.87     UseFormat wird jetzt fuer jedes Modul auf 2 gesetzt.#16. 2.87     Strings (bei Atari auch Array of Char) werden stets mit2byteweisem Zugriff umkopiert;$1. 3.87 TT  Anpassungen fÅr Atari-MOS in Importen, sowie bei Allocate-0Aufruf; String-Variablen alle nun 80 Zeichen lang; SysReturn-0Aufruf am Ende v. 'Comp' weg, dafÅr Retten v. A1/A2/A4.#25. 3.87     Atari: Zuweisung kurzerString := langerString verboten2(Assign0);#30.03.87  TT ARGCV nicht mehr importiert.#07.04.87  TT XtendedCode und RealIsUsed - Flags -> Kennung wird gesetzt#08.04.87  TT Gepard: Set auf 256 Elem, beschr., wg. Speichermangel0bei 512 KB Systemen#12.04.87  TT 6 pTxt...-Variablen definiert fÅr Assembler; GdosTypes import.;0ReadChar aus Console import.; Option $W fÅr Warnings (Default0ist $W+); Warnigs fÅr Compiler erstmal ausgeschaltet.0Achtung !!! Auch der Compiler ist hier fehlerhaft ! A3 muû0statt nach 'EvalStack' geladen zu werden, mit 'SaveHP'0gesichert werden !#13.04.87  TT neue Versionsnummer 3.4; UseFormat wird jetzt0fÅr jedes Modul zurÅckgesetzt#16.06.87     geforderte Platzreserve in Codespc auf $400 verdoppelt2(wegen gelegentlicher AbstÅrze)#16.06.87     SetLÑnge fÅr Atari-Version halbiert (Long -> Short);0Realformat-Kennung im Header nur bei Gepard-Modulen!#24.06.87     FROM LocalModule IMPORT zugelassen (aImport);#26.06.87     Atari: LINK #0 auch im Modulbody;0BackOpt fÅr RÅckschaltung auf vorige CompOption mit $ x=;#27.06.87     Module lokal zu Prozeduren zugelassen:2(ModDec) PrÅfung auf globale Deklaration rausgenommen;2(ImpId, LocXp, SetRelay) Eintrag der ScopeDifferenz in2Relay-EintrÑgen#28.06.87     ImpId sucht ID beim Relay-Anlegen in dem Scope, wo er auch2gefunden wurde;0Block: versuchsweise lokale Forward-Dekl. erlaubt#29.06.87     'OpenFwds' zÑhlt in lokalen Scopes offene FWD-Deklarationen2(OldHead, Block)#30.06.87     aFOR erkennt auch Integer-Subrange als signed#02.07.87     Source- und Modulnamen in Atari-Module;0aRETURN rÑumt auch in Prozeduren vor UNLINK-Aufruf (putRET)1den Stack ab (wegen neuer Atari-Konvention: erst LINK, dann1Register retten); bei $L- entfÑllt Fehler rRetFo. (?gehts?)#03.07.87     Variable StackReserve: Mindestplatz fÅr Runtime-Stackcheck#04.07.87     Strings.Insert importiert (fÅr IO-Module);0auch lokale fehlende FORWARD-Impl. Åber TravTre suchen;0Atari: $S schaltet Prozeduranfangs-Stackcheck (Block10)#08.07.87     Aufrufe FinExp/FinVar vertauscht (IPMod)#14.07.87 TT  ARETURN korrgiert (ADD.W #XX,A7 wurde nie ausgefÅhrt, weil0eine alte Anweisung Åbriggeblieben war.#21.07.87 TT  LINK-Erzeugung in Modulbody wieder raus.#22.07.87 TT  LISTEN-Anweisung impl. (aListen)#23.07.87 TT  PrioritÑt wird anders gesetzt: Wenn Body, dann wird direkt0SetPriority aufgerufen, sonst wird's in put5 erledigt0(vor Block11).#03.11.87 TT  DefVolume wird nur bei Gepard hinter ClockStart gesetzt.#16.11.87 jm  TxtLine (Zeile innerhalb des laufenden Textfiles, fÅr1öbergabe an Editor) wird nicht mehr fÅr jedes Modul1gesetzt. Startwert ist 0.0TxtCol definiert (wird zur Fehlermeldung an Editor in1Compio.ErrorEntry gesetzt).0IOCall implementiert (aIOCall)#17.11.87     Korrektur fÅr IOCALL: Obergrenze 4 in SysProc;0aListen erlaubt optional leere Argument-Klammern#15.12.87     SerLead vor Seriennummern: tarnt Seriennummern als Operanden;1ermîglicht eindeutiges Finden durch Patch-Programm#18.12.87     aReturn: ERST Ergebnis-Expression ausrechnen,1DANN ggf. Stack-Reste abrÑumen!#22.12.87 TT  Text-I/O Åber FileBase statt TextWindows#11.01.88     'ProcNames' definiert (Flag: "vor ProcBody Namen der2Prozeduren einfÅgen") und ausgewertet (bei Block16)#16.01.88 TT  Nach Proc-Namen wird Verkettungs-^ abgelegt.#17.01.88 TT  'ProcNames' nun als Comp-Option (M(ark procedures, Default: +),0Innerhalb des Codes bewirkt RÅckschalten auf $M- nur, daû0leere Namen abgelegt werden, also immer noch 8 Byte pro Proz.#03.04.88 TT  Version 3.5h wg. aVal m. unterschiedl. Sizes#15.04.88     LÑngenliste fÅr Procs vorbereitet#18.05.88     neues Format der LÑngenliste: enthÑlt immer {Adresse LÑnge};1bei globalen Prozeduren ist die Adresse der Beginn der1zugehîrigen lokalen Prozeduren, sonst immer die Anfangs-1adresse (des Modulrumpfs, des Tables) selbst.0Dazu Baumeintrag fÅr Prozeduren, TABLEs, Module um zus.1Long-Feld mit relativer Anfangsadresse der lokalen Procs1erweitert.0Modul-Layout-Kennung auf 2 erhîht.#28.05.88 TT  Proc-Entry-Code optimiert (bedingter Aufruf von Runtime-1Hilfsroutinen) (siehe !tt 28.5.88);#29.05.88 TT  In Header steht auf Offset 42 ein Pointer.L auf den Beginn1des Codes, also dem Ende des Headers.#05.06.88 TT  Damit Key-Berechnung sich nicht Ñndert, wird im Baum f.1ProzedureintrÑge bei Def-Modulen 8 Byte weniger (wie vorm118.5.) angelegt (NEWPROC).#07.06.88 TT  ModDec: Abfrage des Flags 'ProcNames'.#10.06.88 TT  InOutBase statt FileBase importiert.#28.06.88     IDArg akzeptiert LONG im 2. Argument, wenn das erste LONG ist.#29.06.88     Variable myScope fÅr Record-Deklarationen (in Symbol.Icl);0ImpId: findet den importierten ID auch, wenn er Åber2Relay erreicht wird.0MinReal und MaxReal an Atari-Realformat angepaût.0hinter Block10: Platzbedarf fÅr lokale Vars wird vor Put5-2Aufruf gerettet (ging kaputt, falls Put5 PrioritÑt setzt).#24.10.88 >>> VERSION 3.6h##10.12.89     Nachtrag der énderungen aus einteiligem Compiler:#)28.12.88     TravTre Åbersieht keine lokalen Module mehr9beim Relozieren*1.01.89     In TabDec wird ggf. ProcName abgelegt (14.07.88 TT)*1.01.89     aCase: CASE-Syntax mit leeren Feldern korrigiert;9stolpert nicht mehr Åber vîllig fehlende '|'.9Dazu neue Fehlermeldung Nr. 67 !!!)29.01.89     fParm erkennt REF-Parameter und setzt bit9 im VarPar-Wort;6StorVar laesst REF-Flag ($200) in D0;6SetPar markiert REF-Parameter in Flagbit 0;6Assign verbietet Zuweisung auf RefPar;6provisorisch: WITH RefPar verboten!6neue Fehlermeldung Nr. 89*6.3.89      StorVar: lÑût REF-Flag auch bei Open Arrays.6SetPar verwechselt REF und VAR nicht mehr. REF-Parameter9haben auch das VAR-Flag gesetzt!)31.3.89      IDArg: 2. Parameter von INC, DEC jetzt Integer bzw.9LongInt. (énderung der erwarteten Typen und des Codes9fÅr Expansion des 2. Arguments bei INC (long, word);9Kommentare mit ///)6K-Option ist nur noch im Gepard-Modus fÅr Konfiguration7zustÑndig;6K+ schaltet im Atari-Modus erweiterte Key-Berechnung ein.7(Kommentare mit +++))02.07.89     neue Fehlermeldung rRefRs (REF-Restriktion, Nr. 85).6Assign0 ruft bei Stringzuweisungen ungleicher LÑnge immer7STAS auf.)11.05.89 TT  (Nachtrag) In IDARG 2mal Compat durch ASCOMP ersetzt,8damit sowohl INT als auch CARD als 2. Arg. bei INC/DEC8gehen)25.07.89 TT  LibFiles immer importiert; $Q+ ist nun default)07.09.89     REFs sind mit Ausnahme von Open Arrays zunÑchst wieder8verboten. énderung in fpSect mit %%% markiert.)08.11.89     (Symbol): T+ aktiviert invertierte Reihenfolge der8FieldList8$13.12.89     Nachtrag der énderungen aus TTs einteiligem Compiler:$)20.08.89 TT  IPMOD: "MM2Code" wird zu Beginn des Codes eingetragen)31.08.89 TT  erw. Key-Berechnung nun immer (unabh. von $K-Option);6FindError-Pos nun immer relativ zum echten Code-Beginn.)03.09.89 TT  Options: $B- default)09.09.89 TT  B-Option wird erst am Code-Ende Åbernommen)20.09.89 TT  AWITH meldet bei REF-Parm rRefRs statt rRefPa-Fehler;6$W+ ist default)08.10.89 TT  Zum Decomprimieren wird nun mind. 12KB freigelassen,6dazu intelligenterer Allocate-Aufruf;6Assign meckert nicht mehr bei Aufruf einer Proc-Var als6REF-Parameter.)22.11.89 TT  OptForLink enthÑlt alle unbenutzten Options+$13.12.89 jm  fpSect, oldPar: Deklaration von LONGARRAY OF <type> in3Prozedurkîpfen zugelassen; Eintrag in der Parameterkette3wie Open Arrays, jedoch mit Kennung 42 statt 32.1fpSect erlaubt Deklaration mehrdim. Open Arrays3(Syntax {ARRAY OF} <type>). oldPar kommt sowieso schon3damit klar.1fpSect erlaubt Deklaration von REF-Parametern bei allen3Typen.1(Symbol) neues reserviertes Wort LONGARRAY (Nr. 71).1(Symbol) VarDec legt Variablen stets auf gerade Adressen.1(Import) neue Standardbezeichner VAL, LENGTH, LONGREAL;:neuer System-Bezeichner CAST1NewProc: Compileroption $E(xternal) fÅr Prozeduren definiert:4wenn E+ gesetzt ist, wird in der Proc.-Beschreibung4Bit 3 gesetzt (sonst fÅr VarPar-Kennung)4-> Parameter-öbergabe Åber A7-Stack.4!!! Wird bei der ParameterÅbernahme am Blockanfang8noch nicht berÅcksichtigt!$14.12.89 TT  NachtrÑge:1TraceProc neu: bei $E+ wird Proc-Name durch Debug ausgegeben1StatSeq: Ruft bei Proc-Type 'Assign' statt 'UProc' auf$29.12.89 TT  fpsect: LONGARRAY hat nun endlich Kennung 42 (bisher 44)$30.12.89 TT  Default nun $T+$05.01.90 TT  StatSeq: leeres ASSEMBLER END nun mîglich;1Comp: TxtLine wird nun in CompIO init.$27.01.90 TT  fpu() neu: Real-Format wird testweise erstmal Åber $F+/-1gewÑhlt. -- danach wird entweder fÅr 'softReal' oder1'externalFPU' entschieden. Um Code fÅr eine PAK-881 zu1generieren, mÅûte noch eine weitere Information ausgewertet1werden: entweder Åber eine Comp-Option oder, wenn das system-1format genommen werden soll, muû dies Åber 'MOSCtrl.UsedFPU'1ermittelt werden.$03.02.90 TT  StorVar markiert Open Arrays NICHT MEHR IMMER als VAR-Parms;1ITEMS, SetVar, SetPar reservieren ein Word mehr compile-time-1lokal im Tree f. Reg-Var-Verwaltung; Bei Procs ohne Ergebnis1werden Parameter auf A3-Stack belassen.$07.02.90 TT  TraceProc nun bei jedem RETURN, nicht nur am Proc-Ende;1diverse Erweiterungen wg. Reg-Vars hier und in Symbol.VarDec;1Reg-Vars kînnen z.Zt. nur in Procs, jedoch nicht im Level von1Modulen definiert werden. Entsprechend wird nur bei Proc-1Entries Åberhaupt berÅcksichtigt, Regs f. Vars zu retten$10.02.90 TT  Bei mehreren RETURNs in Proc-Body werden alle weiteren auf1den ersten mit einem BRA gelenkt.1Wenn EXIT-Stack voll, wird ebenso Sprung zum Forward-BRA des1letzten EXITs generiert.1Funktionsergebnisse <= 4Byte werden in Reg geliefert, sofern1nicht extra $J- gesetzt ist. PrHead & SetType setzen dann1Bit 4 im Flag-Byte des Proc-Items. Auûerdem Anpassung in1M2if wg. Compat-Vergleich Proc <-> Proc-Var$18.02.90 TT  StorVar: Stackbedarf f. LONGARRAY nun korrekt auf 8 Byte;$25.02.90 TT  fpSect: Bei $H+ werden 8 Byte f. PROC-Parms reserviert und3neue Kennung 44 vergeben1$K+ fÅr Zuweisungskompat LONG -> SHORT reserviert$01.03.90 TT  geforderte Platzreserve in Codespc auf $1000 vervierfacht3(wegen Baum-Zerstîrungen bei knappem Speicher)$21.04.90 TT  Nun wieder RÅckgabe Åber (A3) statt D0 als Default. Per $Z+3kann nun die D0-RÅckgabe aktiviert werden, $J hat keinen3Einfluû mehr darauf.1IMPORT: Key-Berechnung prÑzisiert (Item-Flags werden nun mit3einbezogen), sollte nun auch unabhÑngig von Symbol-Erweite-3rungen sein.1$J+ lîst nun bei nicht erfÅlltem CASE ohne ELSE Laufzeit-3fehler aus.1CASE nun auch mit LONGCARDs funktionsfÑhig$20.07.90 TT  $U+ nun default (SETs nach neuem Format)$30.07.90 TT  DLayout nun 5, da Record-Beschreibung f. Aggregate erweitert$12.09.90 TT  RealConstUsed entfernt, ConFact setzt RealIsUsed selbst;3fpu() setzt RealIsUsed nur bei IEEE-Reals, denn solange3nur die MM2Real-Routinen aus Runtime benutzt werden, ist3das Format egal, weil die fÅr alle Modi vorhanden sind3und Runtime selbst prÅft, ob die ggf. benîtigte FPU3vorhanden ist.$24.09.90 TT  fpSect: Auch bei LocalProc-Parms wird nun die $Z-Einstellung1berÅcksichtigt/kopiert; OldPar/OldHead: vergleichen D0-1RÅckgabe-Flags bei Prozeduren/Prozedur-Typen; "Code" heiût1nun "Header", zus. bezeichnet "CodeStart" den Beginn des1echten Codes (Ende des Headers), rel.^ zum Code werden nun1rel. zu "CodeStart" eingetragen; aExport meldet Fehler, wenn1res. Worte exportiert werden (bisher wurde das nur beim 1.1ID gemacht); LocXp exportiert nun den richtigen ID auch bei1Relays; meldet Fehler bei $J+ und leerem CASE;1ProcDec: Stellt am Ende einer Proc den RStkPtr wieder so3her, wie er vorher war (ErklÑrung s. unten).1AsComp20: BerÅcksichtigt keine Relays bei Parms mehr - die3dÅrften doch bei Opaque-Nachdekl. gar nicht mehr vorkommen!?1LocXp: Erlaubt nun auch EXPORT von lok. Impl. Procs, die global3im Defmod exportiert wurden.$10.10.90 TT  nun kann TT-FPU-Format extra angewÑhlt werden (z.T. mit $F* )$18.10.90 TT  CLRTRE prÅft, ob Baum fehlerfrei war.$20.10.90 TT  aCASE erzeugt ggf. SUBQ statt SUBI, erzeugt kein SUBI #0 mehr.$11.11.90 TT  $[+ erreicht Parm-öbergabe auf A7, A5 wird dann als FramePtr1benutzt und A6 bleibt frei.1$\+ erreicht Parm-öbergabe nach Turbo-C.$06.12.90 TT  Im Modulheader 8 longs reserviert$08.12.90 TT  Bei TC gibt es zwei RÅckgabemodi: bei 'cdecl' alles in D0,1bei TC-Modus scalare in D0, pointer aber in A0. Um das in den1Item-Flags zu unterscheiden, gibt es folg. Regeln:1- wenn A7-Parm-öbergabe, wird die RÅckgabe-Direktive ($Z)3ignoriert und stattdessen immer eine optimierte RÅckgabe im3Reg angestrebt.1- wenn TC-Parm-öbergabe, wird das Bit 0, das sonst f. $Z3benutzt wird, gesetzt, um anzuzeigen, daû Pointer in A03statt D0 geliefert werden.1In beiden FÑllen muû die Entscheidung, ob ein Return-Wert1vorliegt und ob er in ein Reg paût, in 'funcCall' geschehen!1Die Bits werden hier immer unabh. vom Rtn-Wert gesetzt!$19.12.90 TT  Prio wird nur noch einmal gesetzt, und zwar zw. LINK und1"pushRegs". Allerdings lÑuft es nicht auf dem Atari TT,1da ein "MOVE from SR" erzeugt wird!$20.12.90 TT  Korrektur zum 19.12.: Static Link wieder korrekt gesichert$11.03.91 TT  AsComp20: Erkannte "isCompat", wenn die D0-Parm-Kette vor1der D2-Kette aufhîrte.$28.03.91 TT  Version 4.1$08.04.91 TT  SetRelay: Bei lok. Nachdekl. einer extern exportierten oder1Forward-dekl. Proc wird der Relay-Ptr korrekt eingesetzt1(zeigte bisher auf sich selbst); Export einer Proc. aus zwei1Leveln von lok. Modulen geht nun; A5/A6 werden nun in Modulen1lok. zu Procs nicht mehr zerstîrt (waren bisher freie Regs);1kein spradischer Bus-Error mehr bei BEGIN von Modulen lok.1zu Procs (^letzte Ref wurde an falscher Stelle reserviert -12. dummy.L eingefÅgt bei 15er-Kennung); Wenn 'SuppressCode'1TRUE, wird kein Code bei RETURN generiert.$14.07.91 TT  Version 4.1b1Grîûe d. ID-Stacks Åber "/In" bestimmbar, default = 2048.$15.09.91 TT  Version 4.1c (s. MM2COMP2, SYMBOL.ICL)1Bei TC-öbergabe werden auch Opaques und PROC-Types in Regs1Åbergeben.$13.10.91 TT  Version 4.1d: Scan-Offsets beim Protokoll stimmen jetzt wieder.$20.11.91 TT  Version 4.2 wg. 0C-AnfÅgung bei String-Consts$15.05.92 TT  MAC-Option: Proc-Namen am Ende der Proc (Achtung: Kînnen von1Linker nicht entfernt werden!)$30.05.93 TT  Version 4.2b: kein Stack-Check mehr bei REF-Parms$10.12.93 TT  Version 4.2c: TRAP f. vergessenes RETURN wird wieder erzeugt,1allerdings nicht erzeugt, wenn in der Ñuûersten Statement-1Ebene der Funktion ein RETURN vorkam, denn dann ist sicher,1daû man nicht mehr ans Ende der Funktion gelangen kann.$13.12.93 TT  Prgheader: "prgFlags" wird auf 7 gesetzt (f. TT-RAM usw.);1Version 4.3: DATA-Segment wird fÅr Konstanten reserviert.$16.01.94 TT  Das System-Real-Format wird nicht mehr Åber die installierte1FPU sondern Åber die Var. RealMode ermittelt.1V4.3b$13.02.94 TT  A7- und Reg-öbergabe wird auch bei Definition von PROC-Types1berÅcksichtigt.1Dlayout nun 6 f. erweitertes Format des Def-Modulkopfes1V4.3c$03.06.94 TT  V4.3d wg. Korrektur bei verschachtelten Constructors1(s. TREFIN.ICL)1DynSpace, MaxSpace und DataLen konfigurierbar (s. OpenIO)$----------------------------------------------------- *)   FROM MM2Comp2 IMPORT adjustSubrange, aIncl, aExcl, boolExpr, assign, aFor,3constExpr, expr, pushAdr, pushExpr, aWith, SuppressCode,3freeVarRegs, aInc, aDec, aBegin, aEnd, getRegVar,3initBlock, freeRegs,3BITSETfromSYSTEM, discardA7, caseExpr, aCallSys, aCallExt,3constExprZZ, aLoad, aStore; (*$C+*)IMPORT MM2Comp2;(*$C=*)  FROM Strings  IMPORT Pos, Concat, Delete, Length, Compare, Relation,5PosLen, String;  FROM StrConv  IMPORT IntToStr, CardToStr, LHexToStr, StrToReal, StrToLCard,5StrToCard; FROM Files    IMPORT Access, State, File, ReplaceMode; FROM Binary   IMPORT ReadBytes, WriteBytes, Seek, SeekMode, FileSize; FROM MOSGlobals IMPORT MemArea, PathStr, fInsufficientMemory; FROM RealCtrl IMPORT AnyRealFormat, Conv; FROM PrgCtrl  IMPORT TermCarrier, CatchProcessTerm,TermProcess, GetBasePageAddr; FROM Storage  IMPORT ALLOCATE, DEALLOCATE, MemAvail; FROM Lists    IMPORT ResetList, NextEntry; FROM Paths    IMPORT SearchFile, ListPos, MakeFullName; FROM PathCtrl IMPORT PathList, PathEntry; FROM PathEnv  IMPORT HomePath, ReplaceHome; FROM ShellMsg IMPORT ScanMode, ScanAddr, CodeName,5CodeSize, ModuleName, ErrorMsg, TextName,5DefPaths, ImpPaths, SrcPaths, ModPaths, Active, DefSfx,5DefLibName, DefOutPath, ModOutPath, ImpOutPath,5ShellPath, TextLine, TextCol, ImpSfx, ModSfx, ErrListFile; FROM Clock    IMPORT Time, Date, CurrentTime, CurrentDate; FROM Block    IMPORT Copy; FROM ModCtrl IMPORT  GetProcAddr; FROM MOSCtrl IMPORT  RealMode; IMPORT               Files, Text, NumberIO, TimeConvert, Convert, LibFiles,5Compressions, Strings, InoutBase, FastStrings, Directory,5FileNames;  VAR ErrorNr, AutoCmd : Cardinal;  CONST RealForm = 0;  CONST Asm20 = TRUE ;&MAC = FALSE;  CONST  (***** Versionsnummern *****) &CompilerVersion = 4;#CompilerSubVersion = 3;&internalVersion = 'e'; (* AnhÑngsel an "Version.Subversion" *)  (*$ ? Gepard: dlayout = 3;/layout = 0;  *) (*$ ? Atari:  dlayout = 6;/layout = 2; *) .SerVal2 = $312F;   (* verschlÅsselt nach Verfahren 2 *).SerCnt2 = 366;     (* Iterationszahl-1 fÅr SchlÅssel 2 *)-SerLead2 = $0240;   (*   mit #data16 - Operanden     *)+SerOffset2 = $3C78;   (*   mit #data16 - Operanden     *)  (***** Implementationskonstanten *****) (DynSpcDft =   $8000;     (* Reserve fuer dyn. Variablen fuer GDOS *)(MaxSpcDft = 3000000;     (* Max. belegter Platz vom Compiler *)(DataSpcDft=   20000;     (* Reserv. Platz fÅr DATA-Bereich (default) *)(maxStrLen =     255;     (* max StringLaenge *)(DefaStr   =      80;     (* Default StringLaenge *)$DefaReserve   =    $200;     (* Default fÅr Runtime Stack Reserve *)  (***** Symbolnummern *****) &FirstAsmSbl = 93;          (* Nummer des ersten Assm-Symbols,Dmuss bei Erweiterung der Modula-SymboleDentsprechend erhoeht werden ! (TT)  *)  (***** ASCII-Konstanten *****) -eof =  3c; (* Ctrl-C - muû bleiben wg. Editoren *)-tab =  9c;.cr = 13c;.lf = 10c;-dle = 16c;-DC1 = 17c;-esc = 27c;-spc = 32c;* (***** Auto-Commands *****) %ScanAskName = 3;        (* Error-Scan, Textnamen erfragen *)%ScanErrFile = 8;        (* Error-Scan, Textname = ErrorFileName *)&RunAskName = 6;        (* Compile & Start, Textnamen erfragen *)&RunErrFile = 7;        (* Compile & Start, Textname = ErrFile *)%CompErrFile = 2;        (* Compile, Textname = ErrorFileName *)%ExecErrFile = 9;        (* Start Codefile, nach Run hinterlassen *)%EditErrFile = 1;        (* Editor Aufruf, nach Syntaxfehler *)% (***** Default Compileroptions *****)  (*$ ? Gepard:$$AllOptions = $00851880;  (* einmalige Voreinstellung beim Compilerstart *)$OptToClear = $00038000;  (* 0 = "fuer jede CompUnit als Def. loeschen,Efalls nicht sowieso in OptToSet"       *)$OptToSet   = $00841880;  (* 1 = "fuer jede CompUnit als Def. setzen"    *) *) (*$ ? Atari:$$(* einmalige Voreinstellung beim Compilerstart *)$AllOptions = (*_^]\[zyxwvutsrqponmlkjihgfedcba@ *)300000000101111110011010000001000%;$$(* 0 = "fuer jedes Mod als Dft. loeschen, falls nicht sowieso in OptToSet"*)$OptToClear = (*_^]\[zyxwvutsrqponmlkjihgfedcba@ *)300000000010000110000000000000000%;$$(* 1 = "fuer jede CompUnit als Dft. setzen"    *)$OptToSet   = (*_^]\[zyxwvutsrqponmlkjihgfedcba@ *)300000000101111000011010000001000%;$$(* 1 = "Bits am Code-Ende f. Linker Åbernehmen", auch teilw. unbenutzt*)$OptForLink = (*_^]\[zyxwvutsrqponmlkjihgfedcba@ *)311111010000000000000000000000100%; *)  (***** Fehlernummern *****)  (*$ I CompErr.ICL *)  (*!*   ---------------!*   BUFFER / STACKS!*   ---------------!*)  VAR  pTxtMne: ADDRESS;  (* Zeigt in Textpuffer auf den Asm-Mnemonic *) pTxtOp1: ADDRESS;  (* Werden bei RELOAD korrigiert ! *) pTxtOp2: ADDRESS; pTxtOp3: ADDRESS; pTxtLin: ADDRESS; pTxtLin2:ADDRESS; pLastSym:ADDRESS;  LastGSD2 : LongCard;            (* rettet letztes D2 fuer AsmSameSbl *)  DoingAsm: BYTE;                 (* Flag f. SyntaxErr: In Asm *) OprndCnt: BYTE;                 (* f. SyntaxErr: Nr. des bearb. Ops *)  FindError: address;             (* runtime error position *) HeaderLen: LONGCARD;            (* Offset vom Header zum Code (f. ProtLine) *)  SYMTRE:ADDRESS;                 (* Wurzel des Symbolbaums *)  SRCBUF: STRING;                 (* Buffer fuer TreeSearch *) IDSTART: ADDRESS;               (* ^ vor ID (falls nicht bekannt) *)  IDSTKBPtr, IDSTKEPtr: ADDRESS;             (* Platz fuer ID-Stack, aufwÑrts *) IDStkSize: LONGCARD;  INTSTKE:"ARRAY[1..$400] OF WORD;   (* Platz fuer Integer-Stack, abwÑrts *) INTSTK:"ARRAY[1..$40] OF WORD;    (* Exit Stack: abwaerts *) EXSTK:"ARRAY[1..$40] OF WORD;    (* Display Stack: abwaerts *) DISPLAY:WORD;  DUMMY:ARRAY[1..$40] OF WORD;    (* Relocate Stack fuer alte Module *) RELSTK:WORD;@(* FP Akkus *) TXTNAME:   ARRAY[1..10] OF WORD; CNBUF:     ARRAY[1..15] OF WORD;   (*!*   ----------------!*   ZWISCHENSPEICHER!*   ----------------!*)  VAR(linePtr: address;*'saveRegs: ARRAY [0..2] OF ADDRESS;('txtline2,+line,(txtline,(cmtLine,)cmtCol,(endtext,)endmod,)ipflag: cardinal;)(backopt: LongCard;((version: string;'protfile: boolean;'NoReload: boolean;             (* Reload unterdruecken *)&OpenConds: Cardinal;            (* Zaehler fuer offene Cond. Comments *)'MustSync: boolean;             (* lokale Var fuer Record-Deklaration *)&RecOffset: LONGINT;             (* Base-Offset der Rec-Felder *)'OpenFwds: Cardinal;            (* offene FORWARD-Deklarationen3(nur in lokalen Scopes auszuwerten, global Åber TravTre) *)$ #XtendedCode: BOOLEAN;   (* TRUE: X+ Option wurde angewÑhlt *)#RealIsUsed: BOOLEAN;    (* TRUE: Real-Format ist endgÅltig festgelegt *)#SysFormat: Cardinal;            (* vom MOS verwendetes Real-Format;F0 = Gepard, 1 = ST-FPU, 2 = TT-FPU *) GlobalUseFormat,&UseFormat: Cardinal;            (* zu erzeugendes Real-Format;[3 = SysFormat *) (*&FormConst: String;      (* Name des ID, der UseFormat wahlt   *) *)#&ProcNames: BOOLEAN;     (* TRUE: vor ProcBody Prozedurnamen im Code *)#LastProcAddr: ADDRESS; $LoopDiscOfs: LONGINT;     (* Position des A7 vor LOOP *) $UseRegister: BOOLEAN;     (* Zw. f. $Reg-Deklaration (-> CompOpt) *) (RetFlag: BOOLEAN;     (* TRUE: Bei RETURN Wert nach D0 statt auf A3 *)'VarA3Ofs: LONGCARD;    (* A3-Offset v. Parms, von putRET benutzt *) $OptToSetVar,$OptToClrVar: LONGWORD;    (* globale Options fÅr jedes Modul *) (gotFrwd: BOOLEAN;     (* f. ProcDec, Block *) (DynSpace : LONGCARD;  (* Reserve fuer dyn. Variablen fuer GDOS *)(MaxSpace : LONGCARD;  (* Max. belegter Platz vom Compiler *)  TABLE.W  OLDSBL: 0                     (* LETZTES GEFUNDENES SYMBOL *); TABLE.L  IDSTKPtr:0                    (* ^ID STACK *); TABLE.W  VARCNT:0; TABLE.L  VARSPC:0; TABLE.L  ISTKPtr:0                     (* ^INTEGER STACK *); TABLE.L  HOOK:0                        (* ^BAUMANSCHLUSS *); TABLE.L  TypeLen:0                     (* TYP-LAENGE *); TABLE.W  PARCNT:0                      (* ANZ. LOKALE VAR *); TABLE.L  FPARM:0                       (* ^PROC-Parameter *); !(*    zur Benutzung von FPARM:$1. ModDec, ProcDec Åbergeben Adresse, an der BLOCK einen ^Body'ablegt.$2. Zwischenspeicher in PrHead etc. (Anlegen der Parameter-Liste)  *)$ TABLE.L  RESTYPE:0         ; TABLE.W  LastRet:0                     (* FLAG FUER RETURN im Blk vorgekommen *); TABLE.W  LastWasRet:0                  (* FLAG FUER RETURN als letztes Stmt *); TABLE.L  RetAddr:0                     (* Adr. des letzten RETURN *); TABLE.L  LastExit:0                    (* Adr. des letzten EXIT *); TABLE.W  VARPAR:0;                     (* Bits: 8: VarPar; 7: Ref; 15: OpArr *) TABLE.B  RegDnCnt:$FF;                 (* ZÑhler f. vergebene Reg-Parms *) TABLE.B  RegAnCnt:$FF;                 (* ZÑhler f. vergebene Reg-Parms *)  TABLE.W  LOOPLEV  :    0; TABLE.L  EXSTKPtr :    0; TABLE.L  PARADR   :    0; TABLE.W  parmsOnA7:    0; TABLE.W  negVarSpc:    0; TABLE.L  CASETYPE :    0; TABLE.W  secondBcc:    0; TABLE.W  MINCASE  :    0; TABLE.W  MINCASE2 :    0; (* ERSETZT MINCASE+2 *) TABLE.W  MAXCASE  :    0; TABLE.W  MAXCASE2 :    0; (* ERSETZT MAXCASE+2 *) TABLE.W  CASECNT  :    0; TABLE.W  FRSTCASE :    0; TABLE.L  REGSAV   :    0,0,0,0,0; TABLE.W  XPCNT    :    0; TABLE.W  MODCNT   :    0; TABLE.W  MODFLAG  :    0             (* 0:PROC, 1:LOCAL MOD, 2:MAIN PRG *); TABLE.W  PRIORITY :    0             (* Interrupt-Priority des Moduls *); TABLE.W  LBLCNT   :    0             (* ANZ. CASE-LBL FUER 1 CASE *); TABLE.L  ENUMTYPE :    0             (* ^ENUMERATION *); TABLE.L  RSTKPtr  :    0; TABLE.L  KEY      :    0             (* MODULE KEY FUER DEFMOD *); TABLE.W  PERVIMP  :    0; TABLE.W  WASQUAL  :    0             (* QUAL.ID-FLAG VON GetSbl *); TABLE.L  ASMSCOPE :    0             (* ^BAUM DER ASM-SYMBOLE *); TABLE.L  ZW1      :    0; TABLE.W  ZW2      :    0; TABLE.W  CODEGEN  :    0             (* FLAG: CODEERZEUGUNG? *); TABLE.W  NewTyp   :    0             (* Flag fuer Typdeklarationen  *);  VAR SourceScope: Address;            (* ^ScopeTree beim Importieren inHlok. Module *)*myScope: Address;          (* ^Scope, in das bei Record-Decl. dieHneuen Feldnamen eingetragen werden *))lastElem: ADDRESS;          (* ^Eintrag zur Verkettung v. Rec-Feldern*)  (* FORWARD DEKLARATIONEN *)  FORWARD AAssm; FORWARD ACASE; FORWARD aCode; FORWARD ADISPOSE; FORWARD AERR6; FORWARD AEXIT; FORWARD AExport; FORWARD AIF; FORWARD AImport; FORWARD AIOCall; FORWARD AIOTransfer; FORWARD AListen; FORWARD ALOOP; FORWARD ANEW; FORWARD ANewProcess; FORWARD AREPEAT; FORWARD AReturn; FORWARD AsComp20; FORWARD ASSM; FORWARD ASTRING; FORWARD ATransfer; FORWARD AWHILE; FORWARD BLOCK; FORWARD CALLAL; FORWARD CALLDEAL; FORWARD CHECKID; FORWARD CLRTRE; FORWARD CODESPC; FORWARD COMMENT; FORWARD COMPOPT; FORWARD CONSDEC; FORWARD CSP; FORWARD DEFMOD; FORWARD DUMP; FORWARD EXECMOD; FORWARD FETCH; FORWARD FETNOSP; FORWARD FINEXP; FORWARD FINIMP; FORWARD FINVAR; FORWARD FwdKnot; FORWARD GETID; FORWARD GETID0; FORWARD GETID1; FORWARD GETID2; FORWARD GETID3; FORWARD GetLPar; FORWARD GetRPar; FORWARD GetSbl; FORWARD GLOBIMP; FORWARD ImpID; FORWARD InitImports; FORWARD INITRE; FORWARD IPMOD; FORWARD ITEMS; FORWARD LABEL; FORWARD LoadBadID; FORWARD LOCXP; FORWARD LookID; FORWARD ModDec; FORWARD NDARG; FORWARD OldHead; FORWARD NewOpaque; FORWARD OLDID; FORWARD OLDID0; FORWARD PrHead; FORWARD PRTID; FORWARD PRTSTR; FORWARD PROCDEC; FORWARD PULLID; FORWARD PullInt; FORWARD PushInt; FORWARD LookINT; FORWARD SAMESBL; FORWARD SearchID; FORWARD SetAdr; FORWARD SetId; FORWARD SetId0; FORWARD SetId2; FORWARD SetIdI; FORWARD SETKNG; FORWARD SETTYPE; FORWARD SETTYP13; FORWARD StatSeq; FORWARD SUELZ; FORWARD TABDEC; FORWARD TRESRC; FORWARD TraceProc; FORWARD TRESRC0; FORWARD TYPEDEC; FORWARD VARDEC;   (*$i CompIO.ICL *) (*$i TreFin.ICL *) (*$i CodeMain.ICL *) (*$i Symbol.ICL  *)   (*   -----------------------------------------!*   COMPILER INITIALISIERUNG fuer Compile-Cmd!*   ------------------------------------------!*)  PROCEDURE INITCOM; BEGIN ASSEMBLER(JSR     GetSourceName(TST.W   ProtFile(BEQ     noProt(JSR     OpenProt !noProt CLR.W   CODEGEN(CLR.L   FindError&END END INITCOM;  (*   -----------------------------------------!*   COMPILER INITIALISIERUNG fuer Find-Cmd!*   ------------------------------------------!*)  PROCEDURE INITfind; BEGIN ASSEMBLER(JSR     GetSearchName(CLR.W   ProtFile                ;hier immer ohne ProtFile!(CLR.W   CODEGEN (*$ ? RunGep:(MOVE.L  CODE,D0(ADD.L   ERRORPOS,D0     *) (*$ ? RunST:(MOVEQ   #-12,D0         *)(MOVE.L  D0,FINDERROR&END END INITfind;  (* ';' oder '[priority];' verarbeiten *)  PROCEDURE GetPriority; BEGIN ASSEMBLER(MOVE.W  #$FFFF,priority(JSR     GetSbl(CMP.W   #15,D3    ; [?(BNE     nopr(JSR     GetSbl(MOVE.L  ZZTyp,-(A7)(MOVE.L  #$12345,ZZTyp(JSR     ConFact(CMP.L   ZZTyp,D2(BEQ     scard(MOVE    #rCarXp,D5(JMP     SyntaxErr !scard  MOVE.L  (A7)+,ZZTyp(MOVE.W  AccuS14,priority(JSR     GetSbl(CMP.W   #27,D3    ; ]?(BEQ     ok2(MOVE    #rBrkXp,D5(JMP     SyntaxErr !ok2    JSR     GetSbl !nopr   CMP.W   #11,D3    ; ;?(BEQ     ok1(MOVE    #rSemXp,D5(JMP     SyntaxErr !ok1&END END GetPriority;  (* Code fuer Setzen der Interrupt-Priority erzeugen,#falls priority gesetzt ist. *)  PROCEDURE SetPriority; BEGIN ASSEMBLER(MOVE.W   priority,D0(BMI      nix(JMP      put146       ;altes SR retten und neues setzen !nix&END END SetPriority;  PROCEDURE fpu (): FPUType;"BEGIN$ASSEMBLER)MOVE    UseFormat,D0)CMPI    #3,D0          ; wurde $F benutzt?)BCS     retUse         ; ja: gewÅnschte Einstellung liefern)MOVE    SysFormat,D0   ; liefert softReal oder externalFPU,@; je nach System, unter dem compiliert wird'retUse)MOVE    D0,(A3)+$END"END fpu;  PROCEDURE RealConstIsUsed;"BEGIN$ASSEMBLER(MOVE    #1,RealIsUsed  ; wenn Real-Konst, dann ist nun Format festgelegt$END"END RealConstIsUsed;  PROCEDURE IEEERuntimeCall;"BEGIN$ASSEMBLER(; wird auch aufgerufen, wenn direkter 68881-Code erzeugt wird!(MOVE    #1,RealIsUsed  ; wenn internalFPU o. externalFPU, dann?; ist nun Format festgelegt$END"END IEEERuntimeCall;  (*!*   -------------------------------!*   COMPILER ANFANG!*   -------------------------------!*)  PROCEDURE COMP; BEGIN(ASSEMBLER**(* RAM-Platzvergabe *) *LEA     Header,A0*MOVE.L  A0,(A3)+*JSR     MemAvail*MOVE.L  -(A3),D0*CMP.L   MaxSpace,D0     ;mehr als 3 MB brauchen wir keinesfalls*BLS     takeAll*MOVE.L  MaxSpace,D0 takeAll:  MOVE.L  D0,(A3)+*MOVE.L  D0,-(A7)*JSR     ALLOCATE        ;grîûten Speicherblock komplett anfordern*TST.L   Header*BEQ     outofmem*JSR     MemAvail        ;ist noch ein groûes Gap Åbrig?*MOVE.L  -(A3),D0*CMP.L   DYNSPACE,D0    ;Reserve fuer GDOS & Co*BCC     allocOK*; Speicher nochmal anfordern, Gap Åbrig lassen*LEA     Header,A0*MOVE.L  A0,(A3)+*CLR.L   (A3)+*JSR     DEALLOCATE*LEA     Header,A0*MOVE.L  A0,(A3)+*JSR     MemAvail*MOVE.L  DynSpace,D0      ;Reserve fuer GDOS & Co*SUB.L   D0,-4(A3)*BCS     outofmem*MOVE.L  -4(A3),(A7)*JSR     ALLOCATE         ;Speicher anfordern*TST.L   Header*BNE     allocOK!outofmem MOVE.W  #fInsufficientMemory,(A3)+*JMP     TermProcess"allocOK*MOVE.L  (A7)+,A1       ;reservierte Anzahl Bytes*ADDA.L  Header,A1*MOVE.L  A1,SYMTRE      ;Ende des Speicherblocks: Symbolbaum-Root*; Platz. f. DATA-Puffer reservieren*MOVE.L  Header,D0*MOVE.L  D0,DataStart*ADD.L   DataLen,D0*ADDQ.L  #1,D0*BCLR    #0,D0*MOVE.L  D0,DataEnd*MOVE.L  D0,Header*MOVE.L  D0,A0*ADDA.W  #32000,A0      ;Platz f. Header/Code muû mind. 32KB sein*CMPA.L  A1,A0*BHI     outofmem**MOVE.L  A3,EVALSTK     ;^EvalStack retten*CLR.W   NoReload**; Voreinstellungen fuer ges. Uebersetzung (auch mehrere Module)*; (GlobalUseFormat wird *vor* 'OpenIO' gesetzt) (*$ ? RunGep:*JSR     RealForm*MOVE    -(A3),SysFormat  *) (*$ ? RunST:*(* vor 16.1.94:,CLR.W   SysFormat,CMPI    #IEEEReal,UsedFormat,BNE     sysFormSet,JSR     SysInfo.FPU      ; wenn IEEE, dann verwendete FPU ermitteln,MOVE.W  -(A3),SysFormat**)*(* neu: *)*MOVE    RealMode,D0  ;0:keine Reals (kommt nicht vor), 1:MM2Reals usw.*SUBQ    #1,D0*MOVE.W  D0,SysFormat sysFormSet: *)**MOVE.L  #AllOptions,Options ;Default Options setzen*MOVE.L  #OptToClear,OptToClrVar*MOVE.L  #OptToSet,OptToSetVar*MOVE.L  #DefaReserve,StackReserve**; Puffer fÅr ID-Stack reservieren (default: 2KB)*MOVE.L  Header,A0*MOVE.L  A0,IDStkBPtr*ADDA.L  IDStkSize,A0*MOVE.L  A0,IDStkEPtr*MOVE.L  A0,Header**; AutoCommands auswerten und loslegen**MOVE.W  AutoCmd,D0      ;*** AutoCommands auswerten*BEQ     CompAsk         ; gar keins*CLR.W   AutoCmd         ; sonst: schon mal zuruecksetzen*CMP.W   #ScanErrFile,D0 ;Find Runtime Error in ErrFile*BEQ     Find*CMP.W   #ScanAskName,D0 ;Find Runtime Error, Namen erfragen*BEQ     FindAsk*CMP.W   #CompErrFile,D0 ;ErrFile nur ueberetzen?*BEQ     CompIt*MOVE.W  #ExecErrFile,AutoCmd  ;nein, also exec vorbereiten*CMP.W   #RunErrFile,D0        ;Run mit Namen in ErrFile?*BEQ     CompIt                 ;ja !CompAsk  CLR.W   ErrorFileName   ;Compile oder Run, Namen erfragen !CompIt   JSR     INITCOM*BRA     ReStart !FindAsk  CLR.W   ErrorFileName   ;Scan, Namen erfragen !Find     JSR     INITFIND *; Folgendes passiert fuer jedes uebersetzte Modul* !ReStart  MOVE.L  IDStkEPtr,A4*MOVE.L  #$4D4D3243,(A4)+        ; "MM2C"*MOVE.L  #$6F646500,(A4)+        ; "ode"*MOVE.L  A4,Header*MOVE.L  DataStart,DataPtr**JSR     ClockStart (*$? Gepard: MOVE.W  #$012D,DEFVOLUME ;GDOS Defn-Volume '-' fuer DefModule *)*CLR.W   GLOBAL        ;Restart mit neuem Modul*CLR     LINE          ;Zeile innerhalb des Moduls*CLR     RealIsUsed*CLR     XtendedCode*MOVE.L  Options,D0    ;einige Options fuer jede CompUnit neu setzen*AND.L   OptToClrVar,D0*OR.L    OptToSetVar,D0*MOVE.L  D0,Options*MOVE.L  D0,BackOpt*JSR     validateOpts  ;AbhÑngigkeiten entspr. der Options setzen *CLR.W   D7            ;PEEPHOLE ZU*CLR.L   Peephole*CLR.W   ROSCOPE       ;keine ReadOnly-Scopes*CLR.L   LINEPtr*CLR.L   KEY*CLR.W   OpenConds     ;keine offenen Cond.Comments**MOVE.W  GlobalUseFormat,UseFormat  ; die Format-Wahl soll fuer jedesM; Modul neu geschehen.*; CMPI.W  #2,UseFormat  ;Reals im GDOS-Systemformat (Default)?*; BEQ     noUser        ; ja*; MOVE.W  #3,UseFormat  ; nein: neue Auswertung der FormConst noetig noUser    MOVE.L  IDSTKBPtr,A0    ;ID STACK INITIALISIEREN*CLR.B   (A0)*ADDQ.L  #1,A0*MOVE.L  A0,IDSTKPtr*MOVE.L  #INTSTK,ISTKPtr*MOVE.L  #EXSTK,EXSTKPtr ;EXIT STACK*LEA     RELSTK,A0*CLR.L   -(A0)         ;ENDMARKE*MOVE.L  A0,RSTKPtr*LEA     DISPLAY,A6*MOVE.L  #1,-(A6)      ;DISPLAY STACK*JSR     INITRE        ;SYMBOLE IN BAUM EINTRAGEN*CLR.W   ENDTEXT*MOVE.W  #1,ENDMOD      ;jetzt Modul-Ende: evtl. Textende*JSR     GetSbl         ;MODULE-ANFANG*TST.W   ENDTEXT*BNE.L   DONE*CLR.W   ENDMOD*CMPI.W  #51,D3         ;'MODULE'?*BNE     COMP1*MOVE.W  #1,IPFLAG      ;PGM MOD*BRA     COMP2 !COMP1    CMPI.W  #66,D3         ;IMPLEMENTATION*BNE     COMP3*MOVE.W  #2,IPFLAG*BRA     COMP4 !COMP3    CMPI.W  #67,D3        ;DEFINTION*BEQ     ok1 !ER4      MOVE    #rModXp,D5*JMP     SyntaxErr !ok1      MOVE.W  #3,IPFLAG !COMP4    JSR     GetSbl*CMPI.W  #51,D3*BNE     ER4 !COMP2    JSR     GETID         ;MODUL-NAME*JSR     GetPriority   ;evtl. Priority und Semikolon holen !ok2      CMPI.W  #3,IPFLAG     ;DEFMODUL?*BNE     COMP5*JSR     DEFMOD*BRA     COMP6 !COMP5    JSR     IPMOD !COMP6    JSR     OLDID*JSR     CHECKID*BEQ     ok4           ;IDs sind gleich*MOVE    #rIdMis,D5    ;MisMatch*JMP     SyntaxErr ok4       JSR     GetSbl*CMPI.W  #9,D3*BEQ     ok3*MOVE    #rPerXp,D5          ;'.' EXPECTED*JMP     SyntaxErr !ok3*JSR     CLRTRE**; Kennung fÅrs Real-Format in Modulkopf*CLR     D0*TST     RealIsUsed    ;Real-Kennung nur setzen, wenn Real-Konsts oder*BNE     realsUsed     ;FPU-Code oder $F+ o. $F* vorkommen.*; Keine Real-Consts oder FPU-Code: bei $F+/* trotzdem markieren*MOVE    UseFormat,D1*BEQ     noRealsUsed*CMP.W   #3,D1*BEQ     noRealsUsed realsUsed MOVE    UseFormat,D0*CMP.W   #3,D0          ;SystemFormat benutzen ?*BCS     ccc*MOVE    SysFormat,D0 ccc       ; D0 ist 0 (Gepard Reals) oder 1 (ST-FPU) oder 2 (TT-FPU)*ADDQ    #1,D0*LSL.B   #5,D0         ; Real-Kennung nach Bit 5&6 noRealsUsed*; Kennung fÅr 68020/881-Code in Modulkopf*MOVE    XtendedCode,D1*ROR.B   #1,D1*OR.B    D1,D0**; Kennung f. "Prozedur-Namen vorhanden"**CMPI.W  #3,IPFLAG     ; nicht bei Defmods*BEQ     ccc3*TST.W   ProcNames*BEQ     ccc3*BSET    #4,D0         ; Bit 4 in Kennung setzen* ccc3      MOVE.L  Header,A0*OR.B    1(A0),D0      ; Kennungbyte*MOVE.B  D0,1(A0)* *JSR     ClockStop*JSR     SUELZ         ;TEXT/CODELEN*TST.L   FINDERROR*BNE     FIND          ;RuntimeError Pos nicht gefunden*JSR     CSAVE         ;CODE SPEICHERN*TST.W   ProtFile*BEQ     NoVerbos      ;Kein Protokoll*MOVE.L  Options,D0*BTST    #22,D0        ;Verbose?*BEQ     NoVerbos*JSR     Statistics !NoVerbos JSR     PULLID*BRA     RESTART !DONE     JSR     CloseProt*MOVE.L  EVALSTK,A3'END END COMP;  !(*  Source- und Modulnamen als Atari-Strings ins Codefile schreiben;%Pointer auf Offset 26 und 30 setzen...%%SourceName = Top of FilenameStack%ModuleName = Top of IDStack%%(A0,A4,A5,D0-D7)!*) PROCEDURE EnterNames;"BEGIN$ASSEMBLER(MOVE.L  Header,A0         ;^Sourcename setzen(MOVE.L  A4,D0(SUB.L   A0,D0(MOVE.L  D0,26(A0)(MOVE.L  A4,A5(JSR     GetFn           ;Sourcenamen von FnStack holen(MOVE.L  A5,A4(JSR     put0            ;sync((MOVE.L  Header,A0         ;^ModuleName setzen(MOVE.L  A4,D0(SUB.L   A0,D0(MOVE.L  D0,30(A0)((JSR     LookId          ;A0 := ^ Top of ID-Stack en3     MOVE.B  (A0)+,(A4)+(BNE     en3             ;kopieren bis Endmarke 0.B(JSR     put0            ;sync$END"END EnterNames;  (*!*   IMPLEMENTATION ODER PROGRAM MODULE!*)  PROCEDURE IPMOD; BEGIN ASSEMBLER(MOVE.W  IPFLAG,D0(MOVE.B  #LAYOUT,(A4)+(MOVE.B  D0,(A4)+(JSR     put3          ; 2:KEY(MOVE.L  A4,FPARM      ;   hier trÑgt BLOCK die Rumpf-Adr ein(JSR     put3          ; 6:^Body(JSR     put3          ;10:^Ende(JSR     put3          ;14:^ImportListe(JSR     put3          ;18:^ExportListe(JSR     put3          ;22:^Var/Proc-Liste (Reloc-Liste) (*$ ? Atari:(JSR     put3          ;26:^Modulname(JSR     put3          ;30:^SourceName(JSR     put3          ;34:^SymbolName (spÑter mal)(JSR     put3          ;38:^LÑngenliste(JSR     put3          ;42:^Codebeginn/Ende des Headers(MOVE.L  Options,(A4)+ ;46:Options zu Beginn (z.B. durch ArgLine)(JSR     put3          ;50:clinkresv(JSR     put3          ;54:stackSize(MOVE.L  #$00000007,(A4)+  ;58:prgFlags(JSR     put3          ;62:dataStart (Data liegt zw. Code und Reloc-List)(JSR     put3          ;66:reserviert(JSR     put3          ;70:reserviert(JSR     put3          ;74:reserviert(JSR     put3          ;78:reserviert(JSR     EnterNames *) (MOVE.W  #$2,MODFLAG   ;COMP UNIT(CLR.W   GLOBAL(CLR.W   LastRet(CLR.L   LastExit(CLR.W   LOOPLEV       ;LOOP NESTING LEVEL(CLR     RetFlag       ;keine Parm-RÅckgabe in D0(JSR     GetSbl(JSR     GLOBIMP       ;LÑdt Importe, auch eigenes Def-Mod und erstellt>;dabei die Import- und Exportliste(CLR.L   LastProcAddr(MOVE.L  Options,D0(BTST    #13,D0        ;M-Option (Mark Procedures)(SNE     D0(ANDI    #1,D0(MOVE    D0,ProcNames (MOVE.L  A4,D0         ;Anfangsadresse des Codes eintragen(MOVE.L  Header,A0(SUB.L   A0,D0(MOVE.L  D0,42(A0)(MOVE.L  D0,HeaderLen((* doch erstmal nicht wg. zu viel Aufwand f. Linker, da u.A.+dann einige Offsets Null werden kînnen und dies bisher+als Endmarke benutzt wurde.*MOVE.L  A4,CodeStart    ;Wahre Adr. des Codes(*)(MOVE.L  Header,CodeStart  ;erstmal wie bisher gleich lassen (TST.L   FINDERROR(BEQ     noFind(MOVE.L  A4,D0           ; ADR des Code-Beginns(ADD.L   ScanAddr,D0     ; plus Such-Offset(MOVE.L  D0,FINDERROR noFind (JSR     initBlock       ;reg./temp. Vars freigeben (incl. A5,A6)(MOVE.L  freeRegs,D0(CLR     parmsOnA7(CLR     gotFrwd(JSR     Block((; hinter dem Code werden die Konstanten aus dem DATA-Puffer abgelegt:(MOVE.L  A4,D0(MOVE.L  Header,A0(SUB.L   A0,D0(MOVE.L  D0,62(A0)       ;^Data-Beginn(JSR     FinishData((; Ende des Codes - Beginn der Variablen hiermit festlegen:(MOVE.L  A4,D0(MOVE.L  Header,A0(SUB.L   A0,D0(MOVE.L  D0,22(A0)       ;^VAR/PROC-Liste(ADD.L   VARSPC,D0(BPL     notNeg(TRAP    #6              ;interner Fehler(DC.W    -124 notNeg  MOVE.L  D0,10(A0)       ;Modulende (hinter Code & Vars)((; einige Options im Header nachtragen:(MOVE.L  Header,A0(ADDA.W  #46,A0          ; ADR (COMPOPTS)(MOVE.L  (A0),D0(MOVE.L  #OptForLink,D1  ; diese Bits sind nachzutragen(MOVE.L  D1,D2(NOT.L   D1(AND.L   D1,D0           ; Bits aus Header lîschen(MOVE.L  Options,D1(AND.L   D2,D1           ; Bits aus akt. Options maskieren(OR.L    D1,D0           ; und in Header einsetzen(MOVE.L  D0,(A0)((JSR     FINIMP        ;ImportListe (muû vor Relozierungen bleiben)(JSR     FINVAR        ;VAR/PROC/CONST relozieren, LÑngenliste erstellen(JSR     FINEXP        ;ExportListe: ReloziereintrÑge&END END IPMOD;   PROCEDURE TraceProc;"BEGIN$ASSEMBLER(MOVE.L  Options,D2(BTST    #5,D2         ; $E-Option prÅfen(BEQ     noTrace (JSR     PUTDebug      ; Trap-No steht schon in D0(JSR     LookID(MOVE.B  (A0)+,(A4)+   ;es sind mind. 2 Zeichen en3     MOVE.B  (A0)+,(A4)+(BNE     en3           ;kopieren bis Endmarke 0.B(JSR     put0          ;sync&noTrace$END"END TraceProc;  (*!*   === Block ===!*!* ErhÑlt in D0.L die 'freeRegs', die zum Code-Beginn zu setzen sind.!*)  PROCEDURE Block; BEGIN!ASSEMBLER*MOVE.W  negVarSpc,-(A7)*MOVE.W  parmsOnA7,negVarSpc*MOVE.W  MODCNT,-(A7)*CLR.W   MODCNT*MOVE.W  OpenFwds,-(A7)*CLR.W   OpenFwds*MOVE.W  RetFlag,-(A7) ;kann u.U. in Proc/ModDec zerstîrt werden*MOVE.L  PARADR,-(A7)  ;ENDE DER Parameter*MOVE.L  FPARM,-(A7)   ;^Rumpf-Adresse (wird nachher nachgetragen)*MOVE.W  parmsOnA7,-(A7)*MOVE.L  D0,-(A7)      ;freeRegs *TST     gotFrwd*BEQ     Block5*BRA     isFrwd        ;FORWARD wurde bereits in ProcDec erkannt !Block1   JSR     GetSbl !Block5   CMPI.W  #58,D3        ;TYPE*BNE     Block2*JSR     TYPEDEC*BRA     Block5 !Block2   CMPI.W  #56,D3        ;VAR*BNE     Block13*JSR     VARDEC*BRA     Block5 !Block13  CMPI.W  #57,D3        ;CONSTANT*BNE     Block3*JSR     CONSDEC*BRA     Block5 !Block3   CMPI.W  #59,D3        ;PROCEDURE*BNE     Block4*JSR     PROCDEC*BRA     Block1 !Block4   CMPI.W  #51,D3        ;MODULE*BNE     Block15*JSR     ModDec*BRA     Block1 !Block15  CMPI.W  #84,D3        ;TABLE*BNE     Block20*JSR     TABDEC*BRA     Block5 !Block20  CMPI.W  #90,D3        ;FORWARD*BNE     Block16**; FORWARD nach Gepard-Syntax auswerten*JSR     GetSbl isFrwd    MOVE.L  VARSPC,-(A7)*JSR     PrHead*JSR     PullInt    ;WIRD BEI PROC-DEC NACH BEGIN GEMACHT (ERGEBNISTYP)*JSR     CLRTRE        ;LOKALE VAR ETC LOESCHEN*JSR     PULLID*SUBQ.W  #1,GLOBAL*MOVE.L  (A7)+,VARSPC  ;VAR-ADR DER GLOBALEN EBENE*ADDQ.W  #1,OpenFwds*BRA     Block1  ; Ende der Deklarationen: hier beginnt der Modul-/Prozedur-Rumpf!  emptyName DC.W   0  !Block16 MOVE.L  freeRegs,freeVarRegs  ; die belegten Var-Regs merken zum Retten)MOVE.L  (A7)+,freeRegs        ; Regs erstmal wieder freigeben)MOVE.W  (A7)+,parmsOnA7 )TST     parmsOnA7)BNE     parOnA7)(*$C+*) MOVE.W  #MM2Comp2.A6,D0 (*$C-*))BRA     setVarRg parOnA7  (*$C+*) MOVE.W  #MM2Comp2.A5,D0 (*$C-*) setVarRg MOVE    D0,VarReg  ; Reg. f. Var-Zugriff definieren)MOVE    D0,ParReg  ; Reg. f. Parm-Zugriff definieren )TST.W   ProcNames)BEQ     noName        ;Name ist nicht gefragt)); Proc-/Module-Name in den Code))CLR.B   (A4)+         ;Startmarke)LEA     emptyName(PC),A0)MOVE.L  Options,D0)BTST    #13,D0        ;M-Option (Mark Procedures))BEQ     en4           ; $M-: nur Leernamen eintragen)JSR     LookID!en4     MOVE.B  (A0)+,(A4)+   ;es sind mind. 2 Zeichen!en3     MOVE.B  (A0)+,(A4)+)BNE     en3           ;kopieren bis Endmarke 0.B)JSR     put0          ;sync)); Link-^ fÅr rÅckw. verk. Liste aller Procs anfÅgen))MOVE.L  LastProcAddr,(A4)+)MOVE.L  A4,D0)SUB.L   CodeStart,D0)MOVE.L  D0,LastProcAddr  noName   MOVE.L  (A7)+,A0)JSR     SETADR        ;Adresse des Rumpfes und LÑnge eintragen)MOVE.L  (A7)+,PARADR)MOVE.W  (A7)+,RetFlag))MOVE.L  VarSpc,D0     ;Gesamt-VarPlatz (und damit Modullaenge))TST     negVarSpc     ;neg. Offsets? (bei A5-relativem Zugriff))BEQ     notNeg)SUBQ.L  #1,D0         ; synchronisieren)BCLR    #0,D0)BRA     negOK notNeg   ADDQ.L  #1,D0         ; synchronisieren)BCLR    #0,D0 negOK    MOVE.L  D0,VarSpc )TST.W   Global)BEQ     ok5           ;fehlende globale Procs werden eh bemerkt)TST.W   OpenFwds      ;prÅfe, ob FORWARD-Referenzen offengeblieben)BMI     ok5           ;kann in Impl.modulen negativ sein (Defns))BEQ     ok5)LEA     FwdKnot,A5    ;benutzte undekl. Forwards anmÑkeln)MOVE.L  (A6),D2       ;Scope kann nicht leer sein)JSR     TravTr1 ok5      MOVE.W  (A7)+,OpenFwds)); Bei $E+ TRAP f. Proc-Namensausgabe erzeugen)MOVEQ   #66,D0        ; markiert Entry der Proc)JSR     TraceProc))CLR     WithScope          ; wir sind nicht in einem WITH)CLR.L   VarA3Ofs           ; erstmal keine A3-Korrektur beim Return))MOVE.L  Options,D2)BTST    #12,D2)BEQ.L   Block8        ;L-  kein Rangecheck, kein Link, keine Priority )MOVE.W  MODFLAG,D0    ;Module Body?)BEQ     Block11       ;nee: Link durchfÅhren  (* FPU-Check nicht mehr machen, weil der nur bei wirklicher Real-Verwendung"stattfinden sollte)CMPI    #2,D0         ;Main Body?)BNE     noFPUChk))MOVE.L  Options,D0)BTST    #6,D0         ; $F+?)BEQ     noFPUChk ); FPU prÅfen und ggf. initialisieren)MOVEQ   #90,D3)JSR     CSP           ;Runtime: FPU prÅfen *)  noFPUChk JSR     SetPriority   ;neue Interrupt-Priority faellig ?)BRA.L   Block8        ;kein Link, kein Rangecheck  ; ; *** LINK und Parm-Copy durchfÅhren *** ; Block11 (*)CMPI.W  #1,GLOBAL     ;globale Proc ?)BNE     islocal       ;nein)JSR     SetPriority   ;neue Interrupt-Priority faellig ? islocal *))MOVE.L  Options,D1)BTST    #19,D1        ;Stackcheck on?)BEQ     noCheck1      ;nein)MOVE.L  VARSPC,D0)BPL     doCheck)NEG.L   D0 doCheck  JSR     put56b        ;StackSpc Check (kurz)); JSR     put56a        ;StackSpc Check (schnell));!!! hier kînnte per Option auf Speed/Size optimiert werden noCheck1 ); Wenn Prozedur mit Parms und kein Result oder Result in D0,); oder wenn Parms auf A7,); bleiben Parms auf A3/A7-Stack (kein lokales Umkopieren).)TST.L   ParAdr         ;wenn keine Parms, dann normalen Link)BEQ.W   moveParm))TST     parmsOnA7)BEQ     notOnA7      ;Parms sind nicht auf A7)); Werte bleiben auf A7-Stack. Dazu muû gesonderter LINK gen. werden:); (D2 muû vom Aufrufer zuletzt auf den A7 gebracht worden sein!)); LINK   A5,#-(varspc-parspc)  (* parspc wurde bereits subtrahiert *))MOVE.L  VarSpc,D0)JSR     putLink       ;LINK ERZEUGEN)CMPI.W  #1,GLOBAL     ;lokale Proc:)BNE     Put502        ; kein Prio setzen)JSR     SetPriority put502   JSR     pushRegs      ;Reg-Vars (nicht A5) retten)BRA.W   endOfParmCopy  notOnA7  JSR     LookInt        ;^Resulttype der Proc/Function)TST.L   D0)BEQ     noFunc         ;wenn kein Erg, dann bleiben Parms auf A3 )TST     RetFlag        ;F-Result > 4 Byte?)BEQ     moveParm       ;ja -> Link mit lokalem Copy auf A7  noFunc   ; ** Proc erhÑlt Parms. -> auf A3 belassen **); Werte bleiben auf A3-Stack. Dazu muû gesonderter LINK gen. werden:); LINK    A5,#0); MOVE.L  A6,-(A7)); MOVE.L  A3,A6); MOVE.L  D2,(A3)+   ; falls lok. Proc); ADDI    #varspc-parspc,A3)MOVE.L  VarSpc,D0)CMPI.W  #1,GLOBAL     ;globale Proc?)BEQ     Block102      ;ja)SUBQ.L  #4,D0         ;lokale Proc: 4 Byte f. stat. Link nicht addieren Block102 JSR     PutLinkWOcopy)MOVE.L  VarSpc,D0)ADD.L   ParAdr,D0)MOVE.L  D0,VarA3Ofs   ;fÅr putRET, damit A3 am Ende korrig. wird)BRA.W   endOfParmCopy  moveParm MOVE.L  VARSPC,D0)BPL     movePar2)NEG.L   D0 movePar2 CMPI.W  #1,GLOBAL     ;globale Proc?)BEQ     Block10       ;ja)SUBQ.L  #4,D0         ;lokale Proc: 4 Byte in Wirklichkeit fÅr Link Block10  MOVE.L  D0,-(A7)      ;Netto-VarPlatz merken );normalen (alten) Link erzeugen:); LINK   A5,#-varspc); MOVE.L D2,-(A7)); MOVE.L A7,A2); MOVEM  A6,-(A7)); MOVE.L A2,A6)NEG.L   D0)JSR     put5          ;LINK ERZEUGEN  linkOK   MOVE.L  (A7)+,D1      ;Platz fÅr lokale Var)MOVE.L  PARADR,D0     ;Platz fÅr Parameter)BEQ     Block8        ;KEINE))LSR.L   #1,D0)SUBQ.L  #1,D0)SUB.L   PARADR,D1     ;Offset: Ende der Parameter bis Ende lok.Var.)); lok. Daten dÅrfen > 32K werden, Parameter aber erstmal nicht!)CMP.L   #$7FFF,D1)BCS     Block78)MOVE    #rParOv,D5)JMP     SyntaxErr) Block78  NEG.L   D1)JSR     put7          ;lokale Variablen umkopieren  endOfParmCopy  ; ; *** Nun sind LINK und Parm-Copy durchgefÅhrt *** ;  Block8 (*$ ? Gepard:                  ;+++ Konfiguration nicht fÅr Atari)TST.W   MODFLAG       ;Module Body?)BEQ     NoConf        ; nein, keine Konfiguration)MOVE.L  Options,D1)BTST    #11,D1        ;Konfig-Option?)BNE     NoConf        ; K+, also auch nicht)JSR     Put147        ; K-, Leer-Branch erzeugen *) !NoConf  CMPI.W  #1,MODFLAG)BEQ     Block18       ;LOCAL MODULE)JSR     LookID        ;PROC UND MAIN PROG: ID AUSGEBEN)JSR     PRTID !Block18 JSR     EXECMOD       ;MODULE INIT)CLR.L   RESTYPE)TST.W   MODFLAG)BNE     Block21)JSR     PullInt       ;^RESULTTYPE BEI PROC)MOVE.L  D0,RESTYPE !Block21 CLR.W   LastRet)JSR     SAMESBL)CMPI.W  #36,D3        ;BEGIN)BNE.L   Block19)); Programmcode erzeugen)NOT.W   CODEGEN)MOVE.L  A7Offset,-(A7))MOVE.L  A3Offset,-(A7))CLR.L   A3Offset)CLR.L   A7Offset)JSR     aBegin)JSR     StatSeq)JSR     aEnd)MOVE.L  (A7)+,A3Offset)MOVE.L  (A7)+,A7Offset)NOT.W   CODEGEN  !Block19 CMPI.W  #35,D3        ;END)BEQ     ok2)MOVE    #rBdSym,D5    ;END EXPECTED)JMP     SyntaxErr !ok2)TST.W   MODFLAG)BNE     Block9        ;MODULE BODY: KEIN RETURN NOETIG)TST.L   RESTYPE)BEQ     Block9)MOVE.L  Options,D2)BTST    #12,D2        ;Link off?)BEQ     Block9        ;  ja, RETURN nicht nîtig)TST.W   LASTRET)BNE     ok3)MOVE    #rNoRet,D5)JMP     SyntaxErr !ok3 ; Funktion liefert Ergebnis und es kam bereits mind. 1 RETURN vor. ; Am Ende der Prov einen TRAP anfÅgen, um zu erkennen, wenn Programm ; dorthin ohne eine RETURN-Anweisung kommt.)TST.W   LastWasRet    ;haben wir gerade ein RETURN gehabt?)BNE     ok4           ;  dann brauchen wir den Trap nicht.)JSR     put55         ;TRAP f. vergessenes RETURN bei Function !ok4 (*$?~MAC: ; beim Mac muû immer RTS am Ende stehen f. Procname/MacsBug)BRA     Block6 *)  !Block9 (*$?~MAC: ; beim Mac muû immer RTS am Ende stehen f. Procname/MacsBug)TST.W   LastRet)BEQ     putit)JSR     jmpToRet       ;Sprung zum letzten RETURN gen.)BRA     Block6 *) putit    JSR     putRET)ADDQ.W  #1,LastRet  (*$?MAC: ; Proc-/Module-Name im Mac-Style hinter die Proc)MOVE.B  #$80,(A4)+)MOVE.L  A4,-(A7))ADDQ.L  #1,A4)JSR     LookID!en5     MOVE.B  (A0)+,(A4)+)BNE     en5           ;kopieren bis Endmarke 0.B)SUBQ.L  #1,A4)MOVE.L  A4,D0)MOVE.L  (A7)+,A0)SUB.L   A0,D0)SUBQ    #1,D0)MOVE.B  D0,(A0))JSR     put0          ;sync)CLR.W   (A4)+ *) Block6:  TST.W   GLOBAL)BEQ     isglobl)JSR     FinConst      ;die lokal dekl. CONSTs in DATA-Puffer kopieren isglobl: MOVE.W  (A7)+,MODCNT)MOVE.W  (A7)+,negVarSpc)JMP     FinLblAndFwrd  ;Sind alle Fwrd-Refs aufgelîst?'END END Block;  (*!*   TABLE!*)  PROCEDURE TABDEC; BEGIN  ASSEMBLER)  los      TST.W   GLOBAL        ;GLOBALES LEVEL?)BEQ     ok)MOVE    #rLocTb,D5    ; LOKAL NICHT ERLAUBT)JMP     SyntaxErr !ok      JSR     GetSbl)CMPI.W  #9,D3         ;.?)BNE     TABDEC1)JSR     FETNOSP       ;LAENGEN-SUFFIX HOLEN)ANDI.W  #$5F,D2       ;KLEINSCHRIFT WEG)MOVE.W  D2,-(A7))JSR     GetSbl)BRA     TABDEC2 !TABDEC1 MOVE.W  #'W',-(A7) !TABDEC2 TST.W   D3)JSR     GETID0        ;TABELLEN-NAME)JSR     PULLID)JSR     SetId)MOVE.W  #$801C,D0)JSR     SETKNG)MOVE.L  D6,-(A7)      ;Baumeintrag merken)MOVE.L  A4,D0)SUB.L   CodeStart,D0)MOVE.L  D0,-6(A1,D6.L)   ;Adr)MOVE.L  D0,-18(A1,D6.L)  ;Adr nochmal fÅr LÑngenliste)); !TT 14.07.88)TST.W   ProcNames)BEQ     noName         ;Name ist nicht gefragt)CLR.L   (A4)+          ; Leernamen einfÅgen, damit Linker klarkommt)CLR.L   (A4)+)ADDQ.L  #8,-6(A1,D6.L)   ;Adr korrigieren (hinter ProcName) noName   CLR.L   -10(A1,D6.L)     ;^letzte Ref.)SUBI.L  #18,D6)MOVE.L  D6,TRESPC)JSR     GetSbl)CMPI.W  #25,D3        ;:)BEQ     TABDEC3)MOVE    #rColXp,D5         ; EXP)JMP     SyntaxErr !TABDEC3 JSR     GetSbl)JSR     ConstExpr)JSR     PullInt)MOVE.L  D0,D2)CMP.L   StrPtr,D2     ;STRING?)BNE     TABDEC4)LEA     STRBUF,A0)MOVE.W  STRLEN,D2)SUBQ.W  #1,D2)BMI     TABDEC5)CLR.L   D0)MOVE.W  4(A7),D1 !TABDEC6 MOVE.B  (A0)+,D0)BSR.L   TABELM)DBF     D2,TABDEC6)BRA     TABDEC5  !TABDEC4 CMPI.B  #2,-1(A1,D2.L) ;Real ?)BEQ     ok1            ; ja)BTST    #0,-2(A1,D2.L) ; nein, dann also Skalar?)BNE ok1)MOVE    #rConTp,D5     ;ILL.TYPE)JMP     SyntaxErr !ok1     MOVE.L  Accu,D0         ;S1<=>I1)MOVE.L  AccuS14,D2)MOVE.W  4(A7),D1      ;LAENGE)BSR.L   TABELM        ;put B/W/L/D  !TABDEC5 JSR     SameSbl)CMPI.W  #10,D3        ;,)BEQ     TABDEC3)CMPI.W  #11,D3        ;;)BEQ     ok2)MOVE    #rSemXp,D5)JMP     SyntaxErr !ok2     JSR     put0          ;SYNC))MOVE.L  (A7)+,D6        ;^Baumeintrag)MOVE.L  A4,D0           ;aktuelle Code-Adr)SUB.L   CodeStart,D0    ;relativ)SUB.L   -18(A1,D6.L),D0 ;Anfangsadr abziehen: LÑnge)MOVE.L  D0,-14(A1,D6.L) ;in Baum eintragen))JSR     GetSbl)BLS     TABDEC2         ;weitere ID's zur gleichen ElementlÑnge))ADDQ.L  #2,A7           ;ElementlÑnge vom Stack)RTS  !TABELM  CMPI.B  #'W',D1)BEQ     TABELM4)CMPI.B  #'L',D1)BEQ     TABELM5)CMPI.B  #'D',D1)BEQ     ok4)CMPI.B  #'B',D1)BEQ     ok3)MOVE    #rBdSuf,D5)JMP     SyntaxErr !ok4     MOVE.L  D0,(A4)+)MOVE.L  D2,(A4)+)BRA     TABELM6 !ok3     MOVE.B  D0,(A4)+)BRA     TABELM6 !TABELM4 MOVE.W  D0,(A4)+)BRA     TABELM6 !TABELM5 MOVE.L  D0,(A4)+ !TABELM6'END END TABDEC;  (*!*   PROCEDURE!*)  PROCEDURE PROCDEC; BEGIN  ASSEMBLER*; Der Relocation-Stackptr fÅr lokale Module muû hier gerettet*; und am Proc-Ende zurÅckgesetzt werden. Das ist nîtig, weil*; Module lok. zu Procs ja ihre Deklarationen im Baum anlegen,*; dieser aber Åber ClrTre bei Proc-Ende gelîscht wird und sonst beim*; erneuten Wachsen des Baums die Items des Modulbaums Åberschrieben*; wÅrden. Macht aber nix, da solche Module nicht nach auûen Åber die*; Proc hinweg exportieren kînnen.*MOVE.L  RStkPtr,-(A7)*MOVE    StatLinkOffs,-(A7)*CLR     StatLinkOffs*MOVE.L  VARSPC,-(A7)*CLR.L   VARSPC**TST.W   GLOBAL        ;GLOBALE PROC?*BEQ     PROCDEC1*ADDQ.L  #4,VARSPC     ;4 BYTE OFFSET WEGEN StatLINK !PROCDEC1 MOVE.W  MODFLAG,-(A7)*CLR.W   MODFLAG       ;PROC BODY*MOVE.L  freeRegs,-(A7)**JSR     GetSbl*JSR     PrHead        ;formale Parameter auswerten**MOVE.L  fparm,A0      ;^Baumeintrag-6*BTST    #0,4(A0)      ;kommt Result in ein Reg?*SNE     D0*ANDI    #1,D0*MOVE    D0,RetFlag*BTST    #3,4(A0)      ;Stehen Parms auf A7?*SNE     D0*ANDI    #1,D0*MOVE    D0,parmsOnA7**JSR     initBlock     ; definiert alle Regs, auûer A3,A7 als frei*(*$C+*)*MOVEQ   #MM2Comp2.A5,D0*JSR     MM2Comp2.exclFromFreeRegs ; A5 als belegt kennzeichnen*(*$C=*)*TST     parmsOnA7*BNE     noA6excl*(*$C+*)*MOVEQ   #MM2Comp2.A6,D0*JSR     MM2Comp2.exclFromFreeRegs ; A6 als belegt kennzeichnen*(*$C=*) noA6excl  MOVE.L  freeRegs,-(A7)**; Nun prÅfen, ob "FORWARD;" folgt.*CLR     gotFrwd*JSR     GetSbl*CMPI.W  #90,D3        ;FORWARD*BNE     noFrwd**ADDQ    #1,gotFrwd    ; merken, daû bereits FORWARD gefunden*JSR     GetSbl*CMPI.W  #11,D3        ; ";"*BNE     noFrwd**; es ist eine FORWARD-Deklaration nach Pascal-Syntax.*; nun wird aufgerÑumt:*JSR     PullInt       ;Erg-Typ (in PrHead gesetzt)*JSR     CLRTRE        ;LOKALE VAR ETC LOESCHEN*ADDQ.W  #1,OpenFwds*BRA.W   frwdExit* noFrwd    ; ParAdr enthÑlt die Anzahl der als Parms Åbergebenen Bytes, also*;   immer ohne evtl. stat.Link-Ptr, weil der ja nicht auf dem Stack,*;   sondern in einem Reg Åbergeben wird.*; VarSpc die bisher benîtigten Bytes fÅr den lokalen Stack,*;   das sind bis jetzt nur evtl. die 4 Byte f. die Speicherung des*;   stat.Link. Der Rest wird erst in "Block" bei der VAR-Dekl.*;   errechnet.**MOVE.L  fparm,A0      ;^Baumeintrag-6*SUBA.W  #20,A0        ;jetzt ^Adress-Eintrag*MOVE.L  A4,D0         ;Anfangsadresse eintragen*SUB.L   CodeStart,D0*MOVE.L  D0,(A0)       ;Offset: -26*MOVE.L  A0,-(A7)**; Wenn Prozedur mit Parms und kein Result oder Result in D0,*; bleiben Parms auf A3-Stack (kein lokales Umkopieren). Dazu*; werden hier die Offsets korrigiert moveParms TST.L   ParAdr        ;wenn keine Parms, dann normalen Link*BEQ     isFunc2**TST     parmsOnA7*BEQ     notOnA7      ;Parms sind nicht auf A7**; nun mÅssen die Offsets f. A7-Parms korrigiert werden.*CMPI.W  #1,GLOBAL     ;globale Proc?*BEQ     Block103      ;ja*ADDQ.L  #4,ParAdr     ;lokale Proc: 4 Byte f. stat. Link reservieren*MOVE    #8,StatLinkOffs ; und Offset f. Zugriff (A5) merken Block103  LEA     MovParA7Knot,A5*MOVE.L  (A6),D2       ;^Tree der lok. Vars*JSR     TravTr1*; und VarSpc rÅcksetzen*CLR.L   VarSpc*BRA     isFunc2  notOnA7   JSR     LookInt       ;^RESULTTYPE BEI PROC*TST.L   D0            ;wenn kein F-Ergebnis, dann korrigieren*BEQ     moveParm2*TST     RetFlag       ;Result in D0?*BEQ     isFunc2       ;nein -> Parms werden normal umkopiert  moveParm2 ; nun mÅssen die Offsets der Parms f. A3 korrigiert werden.*LEA     MovParA3Knot,A5*MOVE.L  (A6),D2       ;^Tree der lok. Vars*JSR     TravTr1*; und VarSpc wieder rÅcksetzen*CLR.L   VarSpc*CMPI.W  #1,GLOBAL     ;globale Proc ?*BEQ     isFunc2*ADDQ.L  #4,VarSpc  isFunc2   JSR     SameSbl*MOVE.L  4(A7),D0      ;freeRegs*JSR     Block*JSR     CLRTRE *MOVE.L  (A7)+,A0      ;Eintrag f. LÑngenliste fertigstellen*MOVE.L  A4,D0*SUB.L   CodeStart,D0  ;relative Pos. des Endes*SUB.L   (A0),D0       ;Adresse (Offset: -26)*MOVE.L  D0,4(A0)      ;LÑnge (Offset: -22) *JSR     OLDID*JSR     CHECKID*BEQ     ok4           ;IDs sind gleich*MOVE    #rIdMis,D5    ;MisMatch*JMP     SyntaxErr ok4       JSR     GetSbl*CMPI.W  #11,D3*BEQ     ok*MOVE    #rSemXp,D5          ;';' EXPECTED*JMP     SyntaxErr !ok frwdExit  ADDQ.L  #4,A7*MOVE.L  (A7)+,freeRegs*MOVE.W  (A7)+,MODFLAG*MOVE.L  (A7)+,VARSPC*MOVE    (A7)+,StatLinkOffs*MOVE.L  (A7)+,RStkPtr*SUBQ.W  #1,GLOBAL*JSR     PULLID'END END PROCDEC;  (*!*   ------------------!*   MODULE DEKLARATION!*   ------------------!*)  PROCEDURE ModDec; BEGIN  ASSEMBLER !ok2     JSR     GETID)JSR     LookID)JSR     PRTID)JSR     LookID)JSR     SetId)MOVE.W  #$800F,D0)JSR     SETKNG)LEA     -10(A1,D6.L),A0)MOVE.L  A0,FPARM      ;fÅr BLOCK: hier Rumpf-Adr eintragen)CLR.L   -6(A1,D6.L)   ;^LOK. BAUM BEI QUAL.EXP)CLR.L   -14(A1,D6.L)  ;DUMMY)CLR.L   -18(A1,D6.L)  ;DUMMY)CLR.L   -22(A1,D6.L)  ;^ LETZTE REF))MOVE.L  D6,-(A7)      ;fÅr spÑteren LÑngeneintrag)MOVE.L  D6,D0         ;fuer spÑtere Initialisierung)JSR     PushInt       ;Modul-Eintrag merken)ADDQ.W  #1,MODCNT)SUBI.L  #30,D6)MOVE.L  D6,TRESPC)MOVE.L  #1,-(A6))CLR.L   -(A6)         ;DISP STACK ERHOEHEN)MOVE.W  Priority,-(A7))JSR     GetPriority)JSR     GetSbl)JSR     aImport)JSR     aExport)MOVE.W  XPCNT,-(A7))MOVE.W  MODFLAG,-(A7))MOVE.W  #$1,MODFLAG   ;LOCAL MODULE)CLR     RetFlag       ;keine Parm-RÅckgabe in D0)CLR     parmsOnA7)MOVE.L  freeRegs,-(A7))JSR     initBlock     ;reg./temp. Vars freigeben (incl. A5,A6)); bei Modulen lokal zu Procs A5/A6 nicht freigeben:)TST.W   GLOBAL        ;in Proc?)BEQ     isglobal      ;nein)(*$C+*))MOVEQ   #MM2Comp2.A5,D0)JSR     MM2Comp2.exclFromFreeRegs ; A5 als belegt kennzeichnen)MOVEQ   #MM2Comp2.A6,D0)JSR     MM2Comp2.exclFromFreeRegs ; A6 als belegt kennzeichnen)(*$C=*) isglobal MOVE.L  freeRegs,D0)CLR     gotFrwd)JSR     Block)MOVE.L  (A7)+,freeRegs)MOVE.W  (A7)+,MODFLAG)MOVE.W  (A7)+,XPCNT)MOVE.W  (A7)+,Priority)JSR     LOCXP          ; Local Export));*** Eintrag f. LÑngenliste fertigstellen))MOVE.L  (A7)+,D1)MOVE.L  -10(A1,D1.L),A0 ;Rumpfanfang)ADDA.L  CodeStart,A0)TST.W   ProcNames)BEQ     fertig          ;kein Name vorhanden)SUBQ.L  #8,A0           ;so lang ist der Namenseintrag mindestens look     TST.B   (A0)            ;suche 0-Marke vor dem Namen)BEQ     fertig)SUBQ.L  #2,A0)BRA     look fertig   MOVE.L  A4,D0)SUB.L   A0,D0)MOVE.L  D0,-26(A1,D1.L) ;LÑnge des Rumpfes inkl. Name))MOVE.L  A0,D0)SUB.L   CodeStart,D0)MOVE.L  D0,-30(A1,D1.L) ;Anfang des Rumpfes vor dem Namen))MOVE.L  (A6)+,D0)BEQ     ModDec1)MOVE.L  RSTKPtr,A0    ;MERKEN)MOVE.L  D0,-(A0))MOVE.L  A0,RSTKPtr !ModDec1 ADDQ.L  #4,A6)JSR     OLDID)JSR     CHECKID)BEQ     ok4           ;IDs sind gleich)MOVE    #rIdMis,D5    ;MisMatch)JMP     SyntaxErr ok4      JSR     PULLID)JSR     GetSbl)CMPI.W  #11,D3)BEQ     ok1)MOVE    #rSemXp,D5)JMP     SyntaxErr !ok1     RTS!END END ModDec;   PROCEDURE aImport; BEGIN ASSEMBLER ; ;   ---------------------------- ;   Import-STATEMENT UEBERSETZEN ;   ---------------------------- ; aImports CMPI.W  #69,D3       ;'Import'?)BNE     Import1)MOVE.L  A6,D0)ADDQ.L  #8,D0        ;die importierbaren Ids finden wir im)MOVE.L  D0,SourceScope ;naechsthoeheren Scope Level Import2  JSR     ImpID)JSR     GetSbl)CMPI.W  #10,D3        ;,)BEQ     Import2)CMPI.W  #11,D3)BEQ     ok2)MOVE    #rSemXp,D5)JMP     SyntaxErr ok2      JSR     GetSbl)BRA     aImports Import1  CMP.W   #68,D3        ;'FROM'?)BNE     Import3       ;nein, also gar kein Import-Statement)ADDQ.L  #8,A6         ;naechsthoeheres Scope waehlen)JSR     GetSbl        ;Modul-Namen holen)LEA     -8(A6),A6     ;zurueck ins Scope des lok. Moduls)BEQ     Er58          ;undecl.)BPL     Er5           ;kein Id)CMPI.B  #16,-1(A1,D2.L) ;DefMod-Qualifier ?)BEQ     ok5)CMPI.B  #15,-1(A1,D2.L) ;lokales Modul ?)BEQ     ok5)MOVE    #rMdDXp,D5     ;kein Module-Name)JMP     SyntaxErr Er5      MOVE    #rIdXp,D5      ;kein Id, sondern res. Wort)JMP     SyntaxErr ER58     MOVE    #rIdUn,D5      ;undeclared)JMP     SyntaxErr ok5      MOVE.L  -6(A1,D2.L),-(A7) ;^lokalen Baum hinter dem Qualifier)JSR     GetSbl)CMPI.W  #69,D3        ;'IMPORT'?)BEQ     ok6           ;klar doch!)MOVE    #rImpXp,D5    ;nein? sollte aber kommen!)JMP     SyntaxErr ok6      MOVE.L  #1,-4(A6)     ;neues, abgeschl. ScopeLevel simulieren,)MOVE.L  (A7)+,-8(A6)  ;das die qualif. Ids enthaelt)MOVE.L  A6,D0)SUBQ.L  #8,D0)MOVE.L  D0,SourceScope ;aus diesem neuen  Level wird importiert)BRA     Import2        ;weiter wie IMPORT ohne FROM Import3!END END aImport;  PROCEDURE aExport; BEGIN!ASSEMBLER ; ;   ------------------------ ;   LOKALE Export-STATEMENTS ;   ------------------------ ;)CLR.W   XPCNT)CMPI.W  #1,D3)BNE     Export1)CLR.L   -(A7)            ;DEFAULT IST UNQUAL. Export3  JSR     GetSbl)BLS     Export2       ;ID (0 ODER NEG.))CMPI.W  #64,D3        ;QUALIFIED?)BEQ     ok3 idxp     MOVE    #rIdXp,D5)JMP     SyntaxErr ok3      MOVE.L  FPARM,D0)ADDQ.L  #4,D0         ;HIER ^LOKALEN BAUM NACHTRAGEN)MOVE.L  D0,(A7) Export4  JSR     GetSbl)BHI     idxp Export2  JSR     OLDID0        ;BEI QUALEXP AUCH BEKANNTE ID'S ERLAUBT)ADDQ.W  #1,XPCNT)JSR     GetSbl)CMPI.W  #10,D3        ; ',' -> MEHR ID'S)BEQ     Export4)CMPI.W  #11,D3        ; ';' ?)BEQ     ok4)MOVE    #rSemXp,D5)JMP     SyntaxErr ok4      MOVE.L  (A7)+,D0      ;QUAL.FLAG AUF STACK)JSR     PushInt)JMP     GetSbl Export1!END END aExport;  (* zwei Proc-Types vergleichen. Source in D2, Dest in D0, Returncode in D1 *) PROCEDURE AsComp20; BEGIN ASSEMBLER*MOVEM.L D0/D2,-(A7)*MOVE.W  -2(A1,D2.L),D1  ;Source-Kennung*CMPI.B  #19,D1        ;SOURCE DARF PROC.TYPE SEIN*BEQ     AsComp21*CMPI.B  #6,D1         ; ODER PROC*BEQ     AsComp21*CMPI.B  #44,D1        ;SOURCE DARF local PROC.TYPE SEIN*BNE.W   noCompat*MOVE.L  -10(A1,D2.L),D2 ;bei lok.Proctypes ^19er-Kennung laden AsComp21*;prÅfen, ob beide die selben öbergabe-Flags f. Parms & Result haben*MOVE    D3,-(A7)*ANDI    #$0900,D1*MOVE.W  -2(A1,D0.L),D3*ANDI    #$0900,D3*CMP     D1,D3*BNE     noCompat3*MOVE    (A7)+,D3**SUBQ.L  #4,D0*SUBQ.L  #4,D2*BRA     AsComp26        ;hier gibt's noch kein VarPar-Flag!  noCompat3 ANDI    #$0800,D1*ANDI    #$0800,D3*CMP     D1,D3*BNE     noCompat4*MOVE    (A7)+,D3*MOVEM.L (A7)+,D0/D2*MOVE    #rZopt,D1*RTS noCompat4 MOVE    (A7)+,D3 noCompa4b MOVEM.L (A7)+,D0/D2*MOVE    #rParOp,D1*RTS  noCompat2 CMP.B   -11(A1,D2.L),D1 ;stimmt Reg-öbergabe?*BNE     noCompa4b*BRA.W   noCompat  !AsComp24 MOVE.W  -12(A1,D0.L),D1 ;*** VarPar-Flags vergleichen*CMP.W   -12(A1,D2.L),D1*BNE     noCompat2       ;not ok* !AsComp26 MOVEM.L D0/D2,-(A7)*MOVE.L  -10(A1,D2.L),D2 ;*** Typ-Eintrag vergleichen*MOVE.L  -10(A1,D0.L),D0  compar (* TT: das dÅrfte doch gar nicht mehr nîtig sein?*TST.B   -1(A1,D0.L)     ;Relay (nachdekl. Opaque) ?*BNE     noRel1*MOVE.L  -6(A1,D0.L),D0 noRel1    TST.B   -1(A1,D2.L)     ;Relay (nachdekl. Opaque) ?*BNE     noRel2*MOVE.L  -6(A1,D2.L),D2 noRel2 *)        CMP.L   D0,D2*BEQ.W   nextPar         ;direkt gleich*MOVE.B  -1(A1,D2.L),D1  ;nicht gleich: OpenArray oder String ?*BEQ     foundDif        ;Relay? Dann sicher Fwrd-Typ*CMP.B   -1(A1,D0.L),D1*BNE.W   foundDif        ;auch verschiedene Kennung: falsch**CMPI.B  #42,D1*BEQ     isOpen*CMPI.B  #32,D1*BNE     noOpen* isOpen    MOVE.L  -6(A1,D2.L),D2  ;zwei Open Arrays:*MOVE.L  -6(A1,D0.L),D0*BRA     compar          ;Elementtypen vergleichen  noOpen    CMPI.B  #44,D1*BNE     noPr44*; Proc-Parm vergleichen*MOVE.L  -10(A1,D0.L),D1  ;^Type*CMP.L   -10(A1,D2.L),D1*BNE     foundDif*MOVE.B  -2(A1,D0.L),D1*MOVE.B  -2(A1,D2.L),D2*ANDI.B  #1,D1*ANDI.B  #1,D2*CMP.B   D2,D1            ;D0-RÅckgabe-Flags vergleichen*BEQ     nextPar*BRA     foundDif  noPr44    CMPI.B  #27,D1*BNE     foundDif*MOVE.L  -10(A1,D0.L),D1 ;zwei Strings*CMP.L   -10(A1,D2.L),D1 ;Laengen gleich ?*BEQ     nextPar  foundDif  ;prÅfen, ob einer der Parms ein Fwrd-Typ ist - dann andere Meldung*TST.B   -1(A1,D2.L)*BEQ     fwrdTyp*TST.B   -1(A1,D0.L)*BEQ     fwrdTyp*ADDQ.L  #8,A7           ;Abweichung: alte D0/D2 vergessen noCompat  MOVEM.L (A7)+,D0/D2*MOVEQ   #-1,D1*RTS  fwrdTyp   ADDQ.L  #8,A7           ;Abweichung: alte D0/D2 vergessen*MOVEM.L (A7)+,D0/D2*MOVE    #rBdPrc,D1*RTS  nextPar   MOVEM.L  (A7)+,D0/D2    ;zurueck in die Parameter-LinkedList*MOVE.L  -6(A1,D2.L),D2  ;*** Pointerkette weiter verfolgen*BEQ     AsComp23*MOVE.L  -6(A1,D0.L),D0*BNE     AsComp24*BRA     noCompat  AsComp23  MOVE.L  -6(A1,D0.L),D0*BNE     noCompat isCompat  MOVEM.L (A7)+,D0/D2*CLR     D1!END END AsComp20;  FORWARD   MarkId1; PROCEDURE MarkId; #(*   ID (und evtl. EnumElemente) im Baum markieren$*$*      (D2)$*$*      (A1,D2.L) = ^ zu markierenden Eintrag$*      D0        = zu setzendes Bit im FlagByte (0..7)$*)  BEGIN ASSEMBLER)BSET    D0,-2(A1,D2.L) ;Eintrag markieren)BNE     dblExp         ;wurde schon exportiert)TST.B   -1(A1,D2.L)    ;ist es ein Relay-Eintrag?)BNE     norel)MOVE.L  -6(A1,D2.L),D2 norel:   JMP     MarkId1 dblExp   JSR     LoadBadID)MOVE    #rDblEx,D5     ;doppelter Export)JMP     SyntaxErr END END MarkId;  PROCEDURE MarkId1; #(*   NUR evtl. EnumElemente im Baum markieren$*$*      (D2)$*$*      (A1,D2.L) = ^ Enum-Typ-Eintrag$*      D0        = zu setzendes Bit im FlagByte (0..7)$*)  BEGIN ASSEMBLER)CMPI.B  #9,-1(A1,D2.L) ;Enum?)BNE     mark2)MOVE.L  -14(A1,D2.L),D2 mark3    BSET    D0,-2(A1,D2.L) ;Element exportieren)MOVE.L  -12(A1,D2.L),D2)BNE     mark3 mark2 END END MarkId1;  VAR  IdBuffer: ARRAY [0..255] OF Char;  PROCEDURE MakeId;##(*   traegt ID aus Baum vorwaerts in IDBuffer ein.$*   A0  =  ^ hinter Id im Baum$*   A0 :=  ^ IdBuffer$*)  BEGIN ASSEMBLER)MOVE.L   A2,-(A7))LEA      IdBuffer,A2 lp       MOVE.B   -(A0),(A2)+)CMPI.B   #$FE,(A0))BCS      lp)CLR.B    -1(A2)        ;Null als Endmarke)LEA      IdBuffer,A0)MOVE.L   (A7)+,A2&END END MakeId;   PROCEDURE SetRelay; "(*   lokaler Import & Export: Knoten-Handler fuer TravTre;#*   traegt fuer markierte Objekte ein Relay im obersten Scope des#*   Display-Stacks ein.#*#*   Sieht dabei immer die Markierung des Original-Eintrags an,#*   bei Relays also den Relay-Eintrag und nicht den Verwiesenen.#*   Das ist f. LocXp nîtig (s.u.).#*#* Testprg: EXPDUPES.M#*#*   D1 = Åbersprungene StatLink-Level (im Relay-Eintrag vermerken)#*)  BEGIN ASSEMBLER);wir mÅssen an den Original-Eintrag zum Namen kommen. Bei Relays);zeigt D2 nicht darauf, D4 dafÅr vor dessen Namen.));zuerst aber prÅfen, ob der Eintrag nicht anonym ist, denn dann);ist er nicht interessant. Da es keine anonymen Relays gibt (sinnlos),);geht uns dabei auch kein evtl. markierter Relay durch die Lappen.); TestPrg: ENUMRLAY.M)CMPI.B  #$FE,-9(A1,D4.L) ; ist Name anonym?)BCC.W   nomark           ; dann ignorieren))MOVE.L  D4,D0 !TravTr5 SUBQ.L  #2,D0          ;NAME WEG)CMPI.W  #$FE00,-8(A1,D0.L))BCS     TravTr5        ;noch keine Endmarke)BCLR    #6,-10(A1,D0.L) ;Flag ggf. gleich wieder loeschen!)BNE     mark            ;markiert: kopieren));da MarkId1 bei Enum-Elems nur die Consts selbst und nicht evtl.);die Relays markiert, mÅssen wir auch noch das Export-Flag beim);Originaleintrag prÅfen); TestPrg: ENUMRLAY.M)BCLR    #6,-10(A1,D2.L) ;Flag ggf. gleich wieder loeschen!)BEQ     nomark          ;markiert: kopieren) mark     BCLR    #6,-10(A1,D2.L) ;Flag sicherheitshalber immer lîschen)MOVE.L  D0,-(A7))MOVE.W  D1,-(A7))MOVE.L  D2,-(A7))LEA     -8(A1,D4.L),A0 ; ^ID holen)JSR     MakeId         ; vorwaerts in Buffer schreiben);bei Prozeduren prÅfen, ob lokale Dekl. erfolgt ist)CMPI.B  #6,-9(A1,D2.L))BNE     noProc)MOVE.L  A0,-(A7))MOVE.L  A2,-(A7))MOVE.L  A0,A2)MOVE.B  (A0),D1)MOVE.L  (A6),D2)JSR     LocalSearch    ;nach Proc im globalen Level suchen)MOVE.L  (A7)+,A2)MOVE.L  (A7)+,A0)BCC     localProcExport ;existiert schon auûen -> umtragen noProc:  ; ID mit Relay global eintragen)JSR     SetId)MOVE.L  (A7)+,D2)MOVE.W  (A7)+,D1)MOVE.L  (A7)+,D0       ;dummy)SUBQ.L  #8,D2          ;jetzt ist D2 = ^Id-Beschreibung)CLR.W   -2(A1,D6.L))MOVE.L  D2,-6(A1,D6.L) ;RELAY-EINTRAG)MOVE.W  D1,-8(A1,D6.L) ;Åbersprungene ScopeDifferenz)SUBQ.L  #8,D6)MOVE.L  D6,TRESPC nomark   RTS  noCompat MOVE    #rBdIpl,D5)BRA     error twice    MOVE    #rId2x,D5      ;decl. twice error    LEA     IdBuffer,A0)JSR     LoadBadID)JMP     SyntaxErr  localProcExport); Lokal deklarierte Proc, die schon auûen Åber Def-Modul oder FORWARD); definiert wurde, umtragen.); Dazu werden die Adr., die LÑnge und die Ref-Verkettung nach auûen); kopiert und dann die lokale Definition in ein Relay umgewandelt.)MOVE.L  D2,D0          ;D0 zeigt nun auf globale Proc-Beschreibung)CMPI.B  #6,-1(A1,D2.L) ;ist's auch eine Proc?)BNE     twice)TST.L   -6(A1,D2.L)    ;ist Adr. auûen noch unbekannt?)BNE     twice          ;Nein, dann wurde sie schon deklariert)MOVE.L  (A7)+,D2       ;D2 zeigt auf lokale Proc-Beschreibung)SUBQ.L  #8,D2)JSR     AsComp20       ; Definitionen vergleichen)MOVE    D1,D5)BMI     noCompat)BNE     error); Werte umtragen)MOVE.L  -6(A1,D2.L),-6(A1,D0.L) ; Adresse der Proc)MOVE.L  -22(A1,D2.L),-22(A1,D0.L) ; LÑnge der Proc f. LÑngenliste)MOVE.L  -26(A1,D2.L),-26(A1,D0.L) ; Adresse der Proc f. LÑngenliste); jetzt Ref-Kette umtragen. Dazu das Ende der lokalen Kette); finden und dies mit globaler verbinden)LEA     -18(A1,D2.L),A0 next     MOVE.L  (A0),D3)BEQ     ende)ADD.L   CodeStart,D3)MOVE.L  D3,A0)BRA     next ende     MOVE.L  -18(A1,D0.L),(A0)      ;letzte glob. Ref ans Ende der lok.Kette)MOVE.L  -18(A1,D2.L),-18(A1,D0.L) ; letzte Ref der lok. Kette umtragen); zuletzt lok. Proc-Eintrag zum Relay-Eintrag umwandeln)CLR.B   -1(A1,D2.L))MOVE.L  D0,-6(A1,D2.L))MOVE.W  (A7)+,D1)CLR.W   -8(A1,D2.L)    ;SCOPE-Differenz dÅrfte egal sein, oder?); Falls markierte Eintrag ein Relay war, muû auch der umgebogen werden.); Das kommt z.B. vor, wenn ein lok. Modul einen global Forw-dekl. Bez.); exportiert, der aber erst in einem nochmals dazu lok. Modul dekl. &); exportiert wird. Dann wird zuerst bei Ende des inneren lok. Moduls); ein Relay im Ñuûeren lok. Modul auf die Dekl. angelegt. Hier kommen); wir dann erst beim LocXp vom Ñuûeren lok. Modul hin, wenn die Forw-); dekl. von ganz auûen bemerkt wird. Dann muû 1. die Dekl. aus dem lok.); Modul nach ganz auûen umgetragen werden (bereits oben geschehen) und); dann auch der Relay-^ im Ñuûern lok. Modul umgebogen werden:)MOVE.L  (A7)+,D1)SUBQ.L  #8,D1)CMP.L   D2,D1)BEQ     ende2); Nun mÅûte (A1,D1.L) bereits ein Relay-Eintrag sein)MOVE.L  D0,-6(A1,D1.L))CLR.W   -8(A1,D1.L)    ;SCOPE-Differenz dÅrfte egal sein, oder? ende2 END END SetRelay;   PROCEDURE ImpID; BEGIN ASSEMBLER  ;   ----------------------------------- ;   ID aus lokaler Import-ID-Liste lesen ;   ----------------------------------- )MOVE.L  A6,-(A7)      ;einiges Getrickse mit A6 wird noetig...)MOVE.L  SourceScope,A6)JSR     GetSbl)BMI     ok5))MOVE.L  (A7)+,A6      ;kein ID gelesen:)BEQ     Er58          ; - voellig unbekannt)MOVE    #rIdXp,D5     ; - res. Wort)JMP     SyntaxErr !ER58    MOVE    #rIdUn,D5)JMP     SyntaxErr) ok5      JSR     OldId0         ;auf ID-Stack)MOVE.L  D2,-(A7)       ;^Id merken)CMPI.B  #9,-1(A1,D2.L) ;Enum?)BNE     ImpId1)); ein Enum-Typ wird importiert:); markiere alle zugehîrigen Elementnamen...))MOVEQ   #6,D0)JSR     MarkId1       ;nur evtl. EnumElemente markieren)MOVE.W  Tiefe,D1      ;durch den Import Åbersprungene StatLink-Ebenen:?; Tiefe # 0 mîgl., wenn Modul lokal zu Prozedur)); ... suche das Scope, in dem der importierte Enum und die Elemente); deklariert sind...))MOVE.L  (A7),D0 ImpId2   CMPA.L  #Display,A6)BEQ     ImpId3        ;Stack ist leer; ID muû aus pervasive Level sein)MOVE.L  (A6)+,D2)BEQ     ImpId2        ;leeres oder pervasive-Scope, ignorieren)BPL     ImpId2        ;Modul-Grenze)CMP.L   D2,D0)BGT     ImpId2        ;D0 grîûer: gehîrt zu 'globalerem' Level)BRA     ImpId4 ImpId3   MOVEQ   #0,D2         ;ins Pervasive Scope ); ... trage alle in diesem Scope markierten IDs lokal ein) ImpId4   MOVE.L  4(A7),A6      ;wieder ins normale Scope zum Eintragen)LEA     SetRelay,A5   ;Knoten-Handler-Routine)JSR     TravTr1       ;durchsucht den Source-Baum; SetRelay trÑgt?; Relays auf alle markierten Objekte ein?; (das sind die importierten IDs und ggf.?; Enumeration-Elemente)JSR     TravTr0       ;auch lok. Module, weil ggf.?;Relays auf die bestehen und dort Enum-Elems?;herkommen (die wÅrden sonst nicht gefunden).)); nun den ID selbst eintragen (egal, ob Enum oder nicht)) ImpId1   MOVE.L  4(A7),A6      ;zurÅck ins lokale Scope)JSR     PullId)JSR     SetId         ;im aktuellen Level eintragen)MOVE.W  Tiefe,D1      ;!!! darf von SetId nicht verÑndert werden)MOVE.L  (A7)+,D2)CLR.W   -2(A1,D6.L))MOVE.L  D2,-6(A1,D6.L) ;RELAY-EINTRAG)MOVE.W  D1,-8(A1,D6.L) ;Åbersprungene ScopeDifferenz)SUBQ.L  #8,D6)MOVE.L  D6,TRESPC)ADDQ.L  #4,A7         ;Display Stack stimmt schon wieder!END END ImpID;   PROCEDURE LoadBadID;"BEGIN$ASSEMBLER)MOVE.L  A0,A2)LEA     BadId,A0)MOVEQ   #0,D0          ; optional Term-Char)MOVEQ   #40,D2 ; max. Length)JSR     FetchString$END"END LoadBadID;   PROCEDURE LOCXP; BEGIN!ASSEMBLER  ;   -------------------------- ;   Export AUS LOKALEN MODULEN: ;       NACH ENDE ID'S RETTEN ;   --------------------------  ; Die ID-Namen werden vom ID-Stack geholt, dann jeweils im Baum gesucht ; und dann das Flag 6 (exported) im Eintrag gesetzt. Wenn alle IDs durch, ; wird der Baum nochmal gescanned und alle markierten EintrÑge Åber Relays ; ins Ñuûere Scope Åbertragen. ; TT 26.09.90: ; Damit bei Relay-EintrÑgen wirklich der Original-ID und nicht etwa dessen ; Verweis exportiert wird, wird hier dafÅr gesorgt, daû das Flag im Relay- ; eintrag selbst gesetzt und abgefragt wird. ; dazu Testprg: EXPDUPES.M )TST.W   XPCNT)BEQ     LOCXP1        ;GAR KEINE Exports)JSR     PullInt)TST.L   D0)BEQ     LOCXP2        ;UNQUAL. Export)MOVE.L  8(A6),-(A7)   ;GLOBALES SCOPE RETTEN)CLR.L   8(A6)         ;STATT DESSEN NEUES EINRICHTEN)MOVE.L  D0,-(A7))BSR.L   LOCXP2)MOVE.L  (A7)+,A0)MOVE.L  8(A6),(A0)    ;^LOKALEN BAUM HINTER QUALIFIER)MOVE.L  (A7)+,8(A6)   ;GLOBALES SCOPE REPARIEREN)RTS ); exportierten Id zunaechst nur im Baum markieren) LOCXP2   JSR     PullID        ;EXP. ID ANGUCKEN)MOVE.L  A0,-(A7))MOVE.L  A2,-(A7))MOVE.L  A0,A2)MOVE.B  (A0),D1)MOVE.L  (A6),D2       ;INS LOKALE LEVEL)JSR     LocalSearch     ;  DURCHSUCHEN)MOVE.L  (A7)+,A2)MOVE.L  (A7)+,A0)BCC     ok6)JSR     LoadBadID)MOVE    #rExpUn,D5    ;  -> UNDEFINED)JMP     SyntaxErr ok6      MOVE.L  D1,D2         ;wir wollen ggf. Relay-Eintrag markieren)MOVEQ   #6,D0         ;Markierung in Bit 6)JSR     MarkId        ;ID (und evtl. EnumElemente) markieren)SUBQ.W  #1,XPCNT)BNE     LOCXP2        ;MEHR ExportS)); jetzt den Baum durchscannen und alles exportieren,); was markiert wurde:))LEA     SetRelay,A5   ;Export-Handler-Routine)MOVE.L  (A6),D2       ;^Baumwurzel)ADDQ.L  #8,A6         ; fuer Eintragungen: auf 'globales'?; (nÑchsthîheres) Scope)CLR.W   D1            ;Export Åberspringt kein StatLink-Level)JSR     TravTr1       ;globalen Baum durchlaufen)JSR     TravTr0       ;auch lok. Module, weil ggf.?;Relays auf die bestehen und dort Enum-Elems?;herkommen (die wÅrden sonst nicht gefunden).)SUBQ.L  #8,A6         ;zurueck ins lokale Scope LOCXP1!END END LOCXP;  (*!*   Call local module!*)! PROCEDURE CMOD; BEGIN ASSEMBLER)MOVE.W  -2(A1,D2.L),D0 ;KENNUNG)BTST    #9,D0          ;muss immer global sein!)BEQ     CUP3          ;LOCAL)JSR     put8          ;JSR.L)MOVE.L  A4,D0)SUB.L   CodeStart,D0)MOVE.L  -22(A1,D2.L),(A4)+)MOVE.L  D0,-22(A1,D2.L) !CUPRTS  RTS !CUP3    JSR     put54         ;BSR.L)MOVE.L  -10(A1,D2.L),D0)ADD.L   CodeStart,D0 !CUP6    SUB.L   A4,D0)MOVE.W  D0,(A4)+)BPL     CUP4)NEG.L   D0 !CUP4    SWAP    D0)TST.W   D0)BEQ     CUPRTS)MOVE    #rBranc,D5         ;BRANCH TOO LONG)JMP     SyntaxErr'END END CMOD;  (*!*  POINTERKETTE FUER LOKALE VORWAERTS-AUFRUFE ABARBEITEN!*)! PROCEDURE SETADR; BEGIN ASSEMBLER)MOVE.L  A4,D0)SUB.L   CodeStart,D0      ;REL. ^ BERECHNEN)MOVE.L  D0,(A0)       ;ADR EINTRAGEN)CMPI.W  #1,GLOBAL)BLS     SETADR1       ;GLOBALE PROC ODER MAIN PGM)MOVE.L  -12(A0),D1    ;Abs ^LETZTE REF)BEQ     SETADR1       ;KEINE)MOVE.L  D1,A0 !SETADR2 MOVE.W  (A0),D4)SUB.L   A4,D1)NEG.L   D1)CMP.L   #$7FFF,D1)BLS     ok1)MOVE    #rBranc,D5            ;BRA TOO LONG)JMP     SyntaxErr !ok1     MOVE.W  D1,(A0))ADDA.W  D4,A0)MOVE.L  A0,D1)TST.W   D4)BNE     SETADR2 !SETADR1'END END SETADR;  PROCEDURE EXECMOD; BEGIN ASSEMBLER ; ;   ---------------------------- ;   Lokale MODULE INITIALISIEREN ;   ---------------------------- ;*TST.W   MODCNT*BEQ     EXECMOD1*CLR.L   -(A7) !EXECMOD2 JSR     PullInt       ;MODULE UMSTAPELN*MOVE.L  D0,-(A7)      ;  UM RICHTIGE REIHENFOLGE*SUBQ.W  #1,MODCNT     ;  EINZUHALTEN*BNE     EXECMOD2 !EXECMOD3 MOVE.L  (A7)+,D2      ;CODE ZUM AUFRUF*BEQ     EXECMOD1      ;  DER MODULE ERZEUGEN*JSR     CMOD          ;Call local module*BRA     EXECMOD3 !EXECMOD1!END END EXECMOD;  (*!*   CALL USER PROCEDURE!*) (* PROCEDURE CUP; BEGIN ASSEMBLER)MOVE.W  -2(A1,D2.L),D0 ;KENNUNG)BTST    #9,D0)BEQ     CUP3          ;LOCAL)JSR     put8          ;JSR.L)MOVE.L  A4,D0)SUB.L   CodeStart,D0)MOVE.L  -18(A1,D2.L),(A4)+)MOVE.L  D0,-18(A1,D2.L) !CUPRTS  RTS !CUP3    MOVE.W  TIEFE,D0      ;SCOPE DIFFERENZ)JSR     put142        ;statlink -> D2)JSR     put54         ;BSR.L)MOVE.L  -6(A1,D2.L),D0)BEQ     CUP5          ;ADR NOCH UNBEKANNT)ADD.L   CodeStart,D0 !CUP6    SUB.L   A4,D0)MOVE.W  D0,(A4)+)BPL     CUP4)NEG.L   D0 !CUP4    SWAP    D0)TST.W   D0)BEQ     CUPRTS)MOVE    #rBranc,D5         ;BRANCH TOO LONG)JMP     SyntaxErr !CUP5    MOVE.L  -18(A1,D2.L),D0 ;LETZTE REF)MOVE.L  A4,-18(A1,D2.L) ;EIGENE ADR ALS LETZTE REF.)TST.L   D0)BNE     CUP6            ;DIES IST NICHT 1. REF)CLR.W   (A4)+'END END CUP; *)  PROCEDURE CLRTRE; BEGIN ASSEMBLER ; ;   --------------------------------------- ;   BAUM LOESCHEN NACH ABSCHLUSS EINER PROC ;   --------------------------------------- ;)MOVE.L  (A6)+,D0      ;POP DISPLAY STACK)BEQ     CLRTRE1       ;KEINE LOKALE EINTRAGUNG)MOVE.L  TRESPC,D3)MOVE.L  D0,TRESPC     ;LOKALE ID'S FREIGEBEN)MOVE.L  D0,D2); vorher nochmal prÅfen, ob Baum nicht fehlerhaft ist)JSR     VerifyTree !CLRTRE1!END END CLRTRE;  PROCEDURE SetPar; BEGIN ASSEMBLER)MOVE.L  VARSPC,D4         ;^PARADR'S)JSR     PullInt)ADD.L   D0,VARSPC SetPar6  SUBQ.W  #1,D5             ;noch Variablen auf dem Stack?)BMI.W   SetPar1           ;nein ->)JSR     PULLID)JSR     SetId)JSR     PullInt           ;Flag: 0 = ValPar)ANDI.W  #$7F00,D0)BEQ     SetPar2           ;ValPar)BTST    #8,D0             ;VarPar?)BNE     SetPar4)MOVE.W  #$8911,D0         ;als Ref-Parameter eintragen)BRA     SetPar3 SetPar4  MOVE.W  #$8811,D0         ;als Var-Parameter eintragen)BRA     SetPar3 SetPar2  MOVE.W  #$8011,D0         ;als Val-Parameter eintragen SetPar3  JSR     SETKNG)JSR     PullInt           ;Laenge der einzutragenden Var)ADD.L   D4,D0             ;ADR)MOVE.L  D0,-6(A1,D6.L))JSR     PullInt           ;Typ der einzutragenden Var)MOVE.L  D0,-10(A1,D6.L))MOVE.W  D5,-(A7))MOVE.L  D0,D5)JSR     PullInt           ;Flag, ob Reg-Var)TST.W   D0)BEQ     noReg));!!!  erstmal Fehler melden, weil das autom. Laden solcher);     Vars sofort erfolgen mÅûte und nicht erst bei Zugriff,);     weil sonst z.B. Fehler auftreten, wenn 1. Zugriff in einem);     IF vorkommt -> wird der IF-Zweig nicht durchlaufen, wird);     Reg nicht geladen, danach aber benutzt)MOVE    #rRegVa,D5)JMP     SyntaxErr))JSR     allocReg)ANDI    #$00FF,D0) noReg    MOVE.W  (A7)+,D5)MOVE    D0,-16(A1,D6.L)      ;Kennungen f. Reg-Vars)SUBI.L  #16,D6)MOVE.L  D6,TRESPC)BRA     SetPar6 SetPar1!END END SetPar;  PROCEDURE procFlags;"BEGIN$ASSEMBLER)MOVE.L  D1,-(A7))MOVE.L  Options,D1)BTST    #27,D1        ;$[+ (f. A7-ParameterÅbergabe)?)BEQ     norm)BSET    #3,D0         ;Flagbit 3 setzen norm     BTST    #28,D1        ;$\+ (f. TC-ParameterÅbergabe & -rÅckgabe)?)BEQ     norm2)BSET    #3,D0         ;Flagbit 3 setzen)BSET    #0,D0         ;Flagbit 0 setzen norm2    MOVE.L  (A7)+,D1$END"END procFlags;  PROCEDURE procParFlags;"BEGIN$ASSEMBLER); verÑndert ParFlags in D3. /D0/); in D2 muû ^Par-Type Åbergeben werden))MOVE.L  Options,D0)BTST    #28,D0    ; $\)BEQ.W   noReg)); REF/VAR-Parms sowie PROCEDURE/ADDRESS/POINTER/Opaque); kommen nach A0/A1, aber z.Zt. keine Open Arrays!); Rest der Skalaren nach D0-D2)MOVE.W  D3,D0)BMI.W   noReg         ;-> open array)ANDI    #$0300,D0)BNE     allocAn       ;-> var/ref)MOVE.B  -1(A1,D2.L),D0         ; Typkennung)CMPI.B  #19,D0)BEQ     allocAn)CMPI.B  #20,D0)BEQ     allocAn)CMPI.B  #23,D0)BEQ     allocAn)CMPI.B  #8,D0         ;Opaque?)BEQ     allocAn)CMPI.B  #25,D0        ;Opaque?)BEQ     allocAn)BTST.B  #0,-2(A1,D2.L)         ; skalar?)BEQ     noReg)CMPI.L  #4,-6(A1,D2.L)         ; Grîûe <= 4?)BHI     noReg)CMPI.B  #2,RegDnCnt)BGE     noReg                  ; schon alle D-Regs vergeben)ADDQ.B  #1,RegDnCnt)MOVE.B  RegDnCnt,D3)ORI.B   #$80,D3)BRA     noReg allocAn  CMPI.B  #1,RegAnCnt)BGE     noReg                  ; schon alle A-Regs vergeben)ADDQ.B  #1,RegAnCnt)MOVE.B  RegAnCnt,D3)ADDQ.B  #8,D3)ORI.B   #$80,D3 noReg$END"END procParFlags;  PROCEDURE NEWPROC; BEGIN ASSEMBLER ;)JSR     LookID)JSR     SetId)MOVE.W  #$8006,D0     ;TYP)JSR     SETKNG)CLR     D0)JSR     procFlags)OR.B    D0,-2(A1,D6.L))CLR.L   -6(A1,D6.L)   ;ADR)CLR.L   -10(A1,D6.L)  ;^PAR)CLR.L   -14(A1,D6.L)  ;^RES)CLR.L   -18(A1,D6.L)  ;^REFERENZ)SUBQ.L  #6,D6)MOVE.L  D6,FPARM      ;^PAR-Liste)CMPI.W  #3,ipflag     ; DEF-Mod ?)BEQ     isdef)SUBQ.L  #8,D6         ;18.5.'isdef)SUBI.L  #12,D6        ;18.5.)MOVE.L  D6,TRESPC!END END NEWPROC;   PROCEDURE fpSect; (*$Formale Parameter-Sektion aus dem Text lesen.$IDs auf Id-Stack, VarPar-Flag in D3, Typ in D2 zurueckgeben *) BEGIN ASSEMBLER)CLR.W   VARPAR)CLR.W   VARCNT)CMPI.W  #56,D3        ;VAR)BEQ     isVar)CMPI.W  #70,D3        ;REF)BNE     fpSect2)BSET    #1,VARPAR)BRA     fpSect1 isVar    BSET    #0,VARPAR  fpSect1  JSR     GetSbl        ;IDs auf den Stack schaufeln fpSect2  TST.W   D3)JSR     GETID0))MOVE.W  UseRegister,D0)CLR.W   UseRegister)JSR     PUSHINT       ;merken, ob Reg-Var))ADDQ.W  #1,VARCNT)ADDQ.W  #1,PARCNT)JSR     GetSbl)CMPI.W  #10,D3        ;,?)BEQ     fpSect1       ;weiter, solange ',' folgt))CMPI.W  #25,D3        ;:?)BNE     colxp ); Typbeschreibung abarbeiten) hdltype  JSR     GetSbl)CMPI.W  #60,D3        ;'ARRAY'?)BEQ     soparr)CMPI.W  #71,D3        ;'LONGARRAY'?)BNE     fpSect5       ;nein, einfacher Typ)); Open Array-Parm auswerten))MOVE.W  #$802A,D0)BRA     oparr soparr   MOVE.W  #$8020,D0 oparr    MOVE.L  TRESPC,D6     ;Beschreibung fÅr Open Arrays abarbeiten)JSR     SETKNG)MOVE.L  D6,-(A7)      ;merken fÅr Nachtrag des Elementtyps)SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)BSET    #7,VARPAR);weitere Syntax muû sein: OF <type>)JSR     GetSbl)CMPI.W  #46,D3        ;OF)BNE     ofxp)BSR     hdltype)MOVE.L  (A7)+,D6       ;Pointer auf Open Array-Beschreibung)MOVE.L  D2,-6(A1,D6.L) ;ElementTyp nachtragen)MOVE.L  D6,D2          ;neuer ^Parametertyp)RTS) colxp    MOVE    #rColXp,D5)JMP     SyntaxErr ofxp     MOVE    #rOFXp,D5)JMP     SyntaxErr typxp    MOVE    #rTyDXp,D5)JMP     SyntaxErr));einfachen Parametertyp parsen (kein Open Array)  fpSect5  BTST    #10,D3        ;TYP?)BNE     fpSect3)CMPI.W  #47,D3        ;'STRING')BNE     typxp)JSR     SETTYP13)BRA     fpSect4  fpSect3  CMPI.B  #19,D3        ;PROC-Type?)BNE     fpSect6)TST.B   VarPar        ;nur bei value-Parms Kennung 44 verwenden!)BNE     fpSect6))MOVE.L  Options,D0)BTST    #08,D0         ;$H- ? Dann PROC-Type m. 4 Byte belassen)BEQ     fpSect6)); Proc-Typen mit 8 Byte anlegen)MOVE.L  TRESPC,D6)MOVE.W  D3,D0         ;alte Flags Åbernehmen!)MOVE.B  #$2C,D0       ;neue Kennung: 44)JSR     SETKNG)SUBI.L  #10,TRESPC)MOVE.L  #8,-6(A1,D6.L)                 ; LÑnge auf 8 setzen)MOVE.L  D2,-10(A1,D6.L)                ; ^normalen Typ eintragen)MOVE.L  D6,D2                          ; dies ist der neue Typ  fpSect6  MOVE.L  D2,-(A7))JSR     GetSbl)MOVE.L  (A7)+,D2 fpSect4  MOVE.W  VARPAR,D3"END END fpSect;   PROCEDURE StorVar; (*$Daten einer fp-Sektion (von fpSect) auf Int-Stack retten$(fuer spaeteren Eintrag als lokale Variablen);$dabei Platzbedarf der Parameter ausrechnen und Adressen hochzaehlen. *) BEGIN ASSEMBLER)MOVE.L  D2,D0         ;^Typ)JSR     PushInt)MOVE.L  PARADR,D0     ;relative Adresse)JSR     PushInt)MOVE.W  D3,D0         ;welche Art von Parameter?)BMI     StorVar3      ;Open Array)ANDI    #$FF00,D0)BEQ     StorVar1      ;by Value)ADDQ.L  #4,PARADR     ;Laenge bei Var- und Ref-Parameter)BRA     StorVar2 StorVar3 ADDQ.L  #4,PARADR     ;Laenge bei Open-Array-Parameter)MOVE.L  D2,-(A7) StorVar6 CMPI.B  #42,-1(A1,D2.L) ; LONGARRAY?)BEQ     StorVar4)CMPI.B  #32,-1(A1,D2.L) ; SHORTARRAY?)BEQ     StorVar7)MOVE.L  (A7)+,D2)BRA     StorVar2 StorVar7 ADDQ.L  #2,PARADR     ;Laenge bei SHORTOpen-Array-Parameter)BRA     StorVar5 StorVar4 ADDQ.L  #4,PARADR     ;Laenge bei LONGOpen-Array-Parameter StorVar5 MOVE.L  -6(A1,D2.L),D2 ;Element-Typ bei Open Array)BRA     StorVar6 StorVar1 MOVE.L  -6(A1,D2.L),D0 ;Laenge bei Val-Parameter (und nicht OpArr))ADDQ.L  #1,D0         ;Laenge muss immer synchronisiert sein)BCLR    #0,D0)ADD.L   D0,PARADR StorVar2); nun ggf. Reg-Parm zuweisen)JSR     procParFlags))MOVE.W  D3,D0         ;VarPar-Flag)JMP     PushInt       ;..auch auf den Stack END END StorVar;  PROCEDURE NEWPAR; (* weiteren Link in der Parameter-Kette anlegen *) BEGIN ASSEMBLER)MOVE.W  #$8007,D0     ;KENNUNG: PAR-KETTE)JSR     SETKNG)CLR.L   -6(A1,D6.L))MOVE.L  D2,-10(A1,D6.L))MOVE.W  D3,-12(A1,D6.L) ;VARPAR FLAG)MOVE.L  D6,-6(A1,D5.L) ;^ParameterListe)MOVE.L  D6,D5)SUBI.L  #12,D6 END END NEWPAR;  PROCEDURE OLDPAR; BEGIN ASSEMBLER)MOVEM.L D2/D3,-(A7))MOVE.L  -6(A1,D5.L),D6 ;^NEXT PAR)BNE     ok !ER91    MOVEM.L (A7)+,D2/D3)MOVE    #rBdIpl,D5)JMP     SyntaxErr !ER92    ANDI.B  #8,D3)ANDI.B  #8,D2)CMP.B   D2,D3            ;Parm-öbergabeflags vergleichen)BEQ     isZopt)MOVEM.L (A7)+,D2/D3)MOVE    #rParOp,D5)JMP     SyntaxErr isZopt   MOVEM.L (A7)+,D2/D3)MOVE    #rZopt,D5)JMP     SyntaxErr !ok      MOVE.L  -10(A1,D6.L),D0 ;STIMMT TYP?)TST.W   -2(A1,D0.L))BNE     OLDPAR1)MOVE.L  -6(A1,D0.L),D0  ;OPAQUE-TYP WURDE NACHDEKLARIERT !OLDPAR1 CMP.W   -12(A1,D6.L),D3 ;STIMMT VARPAR-FLAG?)BEQ     OLDPAR4)CMP.B   -11(A1,D6.L),D3 ;stimmt Reg-öbergabe?)BEQ     ER91)MOVEM.L (A7)+,D2/D3)MOVE    #rParOp,D5)JMP     SyntaxErr !OLDPAR4 CMP.L   D0,D2)BEQ     OLDPAR6)MOVE.B  -1(A1,D2.L),D3  ;NICHT GLEICH:)CMP.B   -1(A1,D0.L),D3)BNE     Er91           ;AUCH VERSCHIEDENE KENNUNG)CMPI.B  #42,D3         ;                          ||)BEQ     twoloas        ;zwei Long Open Arrays     ||)CMPI.B  #32,D3)BNE     OLDPAR5 twoloas  MOVE.L  -6(A1,D2.L),D2  ;ZWEI OPEN ARRAYS)MOVE.L  -6(A1,D0.L),D0)BRA     OLDPAR4         ;ELEMENTTYPEN VERGLEICHEN !OLDPAR5 CMPI.B  #27,D3)BNE     OLDPAR3)MOVE.L  -10(A1,D0.L),D3  ;ZWEI STRINGS)CMP.L   -10(A1,D2.L),D3  ;LAENGEN GLEICH?)BNE     Er91)BRA     OLDPAR6 !OLDPAR3 CMPI.B  #44,D3)BNE     Er91); Proc-Parm vergleichen)MOVE.L  -10(A1,D0.L),D3  ;^Typ)CMP.L   -10(A1,D2.L),D3)BNE     Er91)MOVE.L  -6(A1,D0.L),D3   ;LÑnge (8 Byte))CMP.L   -6(A1,D2.L),D3)BNE     Er91)MOVE.B  -2(A1,D0.L),D3)MOVE.B  -2(A1,D2.L),D2)ANDI.B  #9,D3)ANDI.B  #9,D2)CMP.B   D2,D3            ;D0-RÅckgabe-Flags vergleichen)BNE     ER92 !OLDPAR6 MOVEM.L (A7)+,D2/D3)MOVE.L  D6,D5!END END OLDPAR;  PROCEDURE FORMRES; (* holt Result-Type bei Function *) BEGIN ASSEMBLER)JSR     GetSbl)BTST    #10,D3         ; Type-ID?)BNE     FORMRES1 (*)CMPI.W  #47,D3         ; "STRING"?)BEQ     ok *))MOVE    #rTyDXp,D5)JMP     SyntaxErr (* !ok      JSR     SETTYP13       ; STRING auswerten)BRA     FORMRES2 *) FORMRES1 MOVE.L  D2,-(A7))MOVE.W  D3,-(A7))JSR     GetSbl         ; Semikolen holen)MOVE.W  (A7)+,D3)MOVE.L  (A7)+,D2 FORMRES2 MOVE.L  FPARM,D6)MOVE.L  D2,RESTYPE)BMI     ok3)JSR     HALT           ;interner Fehler)MOVE    #rIntEr,D5)JMP     SyntaxErr'ok3)JMP     SAMESBL!END END FORMRES;  (* PROCEDURE AsmVisible;"(* Liefert EQ, wenn ASSEMBLER im akt. Modul sichtbar *)"BEGIN$ASSEMBLER)BRA     cont't ACZ     'ASSEMBLER')SYNC'cont)MOVE.L  A2,-(A7))LEA     t(PC),A2)MOVE.B  (A2),D2)JSR     TRESRC)MOVE.L  (A7)+,A2)SCS     D0)MOVE.B  D0,-(A7))JSR     SameSbl)MOVE.B  (A7)+,D0$END"END AsmVisible; *)  PROCEDURE PrHead; BEGIN ASSEMBLER);22.4.90: GetSbl muû nun schon vorher aufgerufen werden)TST     D3)BEQ     PrHead6)BMI     ok ER5      MOVE    #rIdXp,D5)JMP     SyntaxErr ok       TST.W   Tiefe)BNE     PRH1          ;lokale Neudeklaration)JMP     OldHead       ;aus FORWARD oder DefMod bekannt ? PrH1     TST.W   D3 PrHead6  JSR     GETID0)JSR     NEWPROC)CLR.L   PARADR        ;Parameter-VAR-ADR'S, wird hochgezaehlt)CLR.W   PARCNT)CLR.L   RESTYPE       ;^Ergebnistyp; NIL bei Procs)MOVE.B  #-1,RegAnCnt)MOVE.B  #-1,RegDnCnt)CLR.L   -(A6)         ;neues Display)JSR     GetSbl)CMPI.W  #14,D3        ;()BNE.L   PrHead1)CLR.W   UseRegister)JSR     GetSbl)CMPI.W  #26,D3        ;))BEQ.L   PrHead5)MOVE.L  FPARM,D5      ;^Param List, kommt schliesslich in Proc-Eintrag)ADDQ.L  #2,D5)MOVE.L  D5,-(A7))); aufgezÑhlte Parms einlesen samt ihres Typs !PrHead2 JSR     fpSect         ; liefert Varpar-Flag in D3!)MOVE.L  (A7)+,D5)MOVE.L  TRESPC,D6 ); erstmal die Reg-Var-Flags wieder vom IntStack holen)MOVE.L  A3,-(A7))MOVE.L  EVALSTK,A3)MOVE.W  VarCnt,D1 !PrHead7 JSR     PullInt)MOVE.W  D0,(A3)+)SUBQ    #1,D1)BNE     PrHead7 ); nun die aufgezÑhlten Vars anlegen !PrHead3 MOVE.W  -(A3),D0)JSR     PushInt)MOVE    D3,-(A7)      ;D3 wird bei Reg-Parms verÑndert)JSR     StorVar       ;bekommt Varpar-Flag in D3!)JSR     newPar        ;Parameter-KETTE)MOVE.W  (A7)+,D3)SUBQ.W  #1,VarCnt)BNE     PrHead3       ;WEITERE VAR DIESES TYPS))MOVE.L  (A7)+,A3))MOVE.L  D6,TRESPC)JSR     SAMESBL)CMPI.W  #26,D3        ;))BEQ     PrHead5)CMPI.W  #11,D3)BEQ     ok1)MOVE    #rParXp,D5)JMP     SyntaxErr !ok1     MOVE.L  D5,-(A7))JSR     GetSbl)BRA     PrHead2        ;nÑchsten Parm & Typ auswerten  !PrHead5 JSR     GetSbl !PrHead1 MOVE.L  PARADR,D0     ;GESAMTPLATZ FUER PAR'S)JSR     PushInt)CMPI.W  #25,D3        ;:)BNE     PrHead4 );Result-Type der Function holen)JSR     FORMRES)MOVE.L  D2,-8(A1,D6.L) ;^RES-TYPE)BTST    #3,4(A1,D6.L))BNE     PrHead4        ;bei A7-Parm-öbergabe ist $Z irrelevant); prÅfen, ob Result in Register statt auf A3-Stack lieferbar ist)MOVE.L  Options,D0)BTST    #26,D0         ;$Z- ? Dann keine D0-RÅckgabe)BEQ     PrHead4)CMPI.L  #4,-6(A1,D2.L) ;paût Result in ein Register?)BHI     PrHead4)BSET    #0,4(A1,D6.L)  ;ja: Bit 0 in Item-Flags setzen  !PrHead4 CMPI.W  #11,D3         ;';'?)BEQ     ok2)MOVE    #rSemXp,D5)JMP     SyntaxErr !ok2     ADDQ.W  #1,GLOBAL)MOVE.W  PARCNT,D5)JSR     SetPar)MOVE.L  RESTYPE,D0)JSR     PushInt)MOVE.L  FPARM,D6)LEA     0(A1,D6.L),A0  ;^ADR-EINTRAG)MOVE.L  A0,FPARM      ;FUER Block END END PrHead;  PROCEDURE OldHead; BEGIN ASSEMBLER*CMPI.B  #6,D3         ;PROC?*BEQ     ok !ER18     MOVE    #rId2,D5      ;DECL. TWICE*JMP     SyntaxErr ErrParm   MOVE    #rParOp,D5    ;diff. Parm-Modes*JMP     SyntaxErr !ok       TST.L   -6(A1,D2.L)   ;REL.ADR=0: NOCH UNDECLARED*BNE     ER18*SUBQ.W  #1,OpenFwds*TST.W   D3*JSR     OLDID0        ;FUER END-ID-CHECK**; stimmen Parm-öbergaben Åberein?*CLR     D0*JSR     procFlags*MOVE.B  -2(A1,D2.L),D1*ANDI.B  #$09,D1       ;Bits 0 & 3 maskieren*BTST    #3,D0*BNE     nomask0*BCLR    #0,D1         ;Bit 0 wg. ggf. Z-Direktive wegmaskieren nomask0   CMP.B   D0,D1*BNE     ErrParm**CLR.L   PARADR        ;Parameter-VAR-ADR'S*CLR.W   PARCNT*CLR.L   RESTYPE*CLR.L   -(A6)         ;NEUES DISPLAY*SUBQ.L  #6,D2*MOVE.L  D2,FPARM*ADDQ.L  #2,D2*MOVE.L  D2,-(A7)*JSR     GetSbl*CMPI.W  #14,D3        ;(*BNE.L   OldHead1*JSR     GetSbl*CMPI.W  #26,D3        ;)*BEQ.L   OldHead5  !OldHead2 JSR     fpSect*MOVE.L  (A7)+,D5*MOVE.L  TRESPC,D6**; erstmal die Reg-Var-Flags wieder vom IntStack holen*MOVE.L  A3,-(A7)*MOVE.L  EVALSTK,A3*MOVE.W  VarCnt,D1!!PrHead7 JSR     PullInt*MOVE.W  D0,(A3)+*SUBQ    #1,D1*BNE     PrHead7* !OldHead3 MOVE.W  -(A3),D0*JSR     PushInt*MOVE    D3,-(A7)      ;D3 wird bei Reg-Parms verÑndert*JSR     StorVar*JSR     OLDPAR        ;Parameter-KETTE VERFOLGEN*MOVE.W  (A7)+,D3*SUBQ.W  #1,VARCNT*BNE     OldHead3      ;WEITERE VAR DIESES TYPS*MOVE.L  (A7)+,A3**MOVE.L  D5,-(A7)*JSR     SAMESBL*CMPI.W  #26,D3        ;)*BEQ     OldHead5*CMPI.W  #11,D3*BEQ     ok1*MOVE    #rParXp,D5*JMP     SyntaxErr !ok1      JSR     GetSbl*BRA     OldHead2 !OldHead5 JSR     GetSbl !OldHead1 MOVE.L  PARADR,D0     ;GESAMTPLATZ FUER PAR'S*JSR     PushInt*MOVE.L  (A7)+,D5*TST.L   -6(A1,D5.L)*BEQ     ok2 !ER91     MOVE    #rBdIpl,D5    ;PAR-KETTE MUSS HIER ENDEN!*JMP     SyntaxErr ErrZOpt   MOVE    #rZopt,D5     ;different Z-Directives*JMP     SyntaxErr !ok2      CLR.L   D2*MOVE.L  FPARM,D6*CMPI.W  #25,D3        ;:*BNE     OldHead4**JSR     FORMRES*; bei Result prÅfen, ob D0-RÅckgabe-Flags Åbereinstimmen*BTST    #3,4(A1,D6.L)*BNE     checked        ;bei A7-Parm-öbergabe ist $Z irrelevant*MOVE.L  Options,D0*BTST    #26,D0         ;$Z-*BEQ     noRegD0*CMPI.L  #4,-6(A1,D2.L) ;paût Result in ein Register?*BHI     noRegD0*BTST    #0,4(A1,D6.L)*BEQ     ErrZOpt*BRA     checked noRegD0   BTST    #0,4(A1,D6.L)*BNE     ErrZOpt checked  !OldHead4 MOVE.L  -8(A1,D6.L),D0  ;D0: ^Original-Beschreibung*TST.W   -2(A1,D0.L)*BNE     OldHead7*MOVE.L  -6(A1,D0.L),D0  ;OPAQUE-TYP WURDE NACHDEKLARIERT !OldHead7 CMP.L   D0,D2           ;STIMMT RES.TYPE?*BEQ     OldHead6*CMPI.B  #27,-1(A1,D0.L) ;STRINGS?*BNE     ER91*CMPI.B  #27,-1(A1,D2.L)*BNE     ER91*MOVE.L  -10(A1,D0.L),D0 ;GLEICHE LAENGEN?*CMP.L   -10(A1,D2.L),D0*BNE     ER91 !OldHead6 CMPI.W  #11,D3        ;;*BEQ     ok3*MOVE    #rSemXp,D5*JMP     SyntaxErr !ok3      ADDQ.W  #1,GLOBAL*MOVE.W  PARCNT,D5*JSR     SetPar*MOVE.L  RESTYPE,D0*JSR     PushInt*MOVE.L  FPARM,D6*LEA     0(A1,D6.L),A0  ;^ADR-EINTRAG*MOVE.L  A0,FPARM      ;fÅr Block!END END OldHead;  PROCEDURE CODESPC; BEGIN ASSEMBLER)MOVE.L  A1,D1)ADD.L   TRESPC,D1)SUB.L   A4,D1)CMPI.L  #$1000,D1)BCC     ok)MOVE    #rSpace,D5)JMP     SyntaxErr !ok END END CODESPC;   VAR PrevWasRet: BYTE;  PROCEDURE StatSeq; BEGIN!ASSEMBLER*; sollte in dieser Loop das Flag auf (A7) gesetzt werden, so*; dÅrften alle weiteren Statements bis zum Verlassen dieser Schleife*; ignoriert werden, weil dann nÑmlich ein RETURN bereits die*; Statement-Sequenz abgebrochen hat.*CLR.W   -(A7) !StatSeqL JSR     CODESPC       ;NOCH PLATZ?*BSR.L   StatSeq0      ;VERTEILER*CMPI.W  #11,D3        ;;?*BEQ     StatSeqL*MOVE.W  (A7)+,LastWasRet*RTS  ;        STATEMENT  StatSeq0 JSR     GetSbl)TST     AsmMode       ;Assembler-Option antesten)BEQ     NOASS)JMP     ASSM  noAss    MOVE.L  Options,D0)BCLR    #0,D0)BEQ     NoBrk)MOVE.L  D0,Options)BREAK NoBrk)TST.W   D3)BNE     ok)MOVE    #rIdUn,D5)JMP     SyntaxErr ok       BPL.L   StatSeq1      ;MODULA WORT)); Identifier)BTST    #2+8,D3       ;Typ (bei $A+))BNE     StatAsn)CMPI.B  #6,D3         ;PROC)BEQ     StatAsn)CMPI.B  #17,D3        ;VAR)BEQ     StatAsn !Stat2   CMPI.B  #14,D3        ;REC.FELD)BNE     Stat11 StatAsn  JMP     Assign !Stat11  CMPI.B  #36,D3        ;Standardproc)BNE     Bad           ;nix gueltiges)); Standardprozeduren))MOVE.W  -4(A1,D2.L),D3)CMP.W   #104,D3)BEQ     StatAsn        ;CAST (bei $A+))CMP.W   #100,D3)BHI     SysProc        ;aus dem SystemModul)SUB.W   #20,D3         ;kleinste gueltige StdProc-Nummer)BCS     Bad)CMP.W   #5,D3)BHI     Bad)LEA     ProcAdrs(pc),A0)LSL.W   #2,D3)MOVE.L  0(A0,D3.W),A0)JMP     (A0)  ProcAdrs DC.L    aInc)DC.L    aDec)DC.L    aNew)DC.L    aDispose)DC.L    aIncl)DC.L    aExcl  SysProc  SUB.W   #120,D3)CMP.W   #10,D3)BHI     Bad)LEA     SysAdrs(pc),A0)LSL.W   #2,D3)MOVE.L  0(A0,D3.W),A0)JMP     (A0)  Bad      MOVE    #rStatm,D5)JMP     SyntaxErr  SysAdrs  DC.L    aNewProcess)DC.L    aTransfer)DC.L    aIOTransfer)DC.L    aListen)DC.L    aIOCall)DC.L    aAssm)DC.L    aCallSys)DC.L    aCallExt)DC.L    aCode)DC.L    aLoad)DC.L    aStore ); reserviertes Wort  StatSeq1 CMPI.W  #37,D3        ;REPEAT)BNE     Stat3)JMP     AREPEAT !Stat3   CMPI.W  #39,D3        ;WHILE)BNE     Stat4)JMP     AWHILE !Stat4   CMPI.W  #31,D3        ;IF)BNE     Stat5)JMP     AIF !Stat5   CMPI.W  #65,D3        ;RETURN)BNE     Stat6)MOVE.W  #1,4(A7)      ;Flag setzen, daû RETURN gerade vorkam)JMP     ARETURN !Stat6   CMPI.W  #41,D3        ;LOOP)BNE     Stat7)JMP     ALOOP !Stat7   CMPI.W  #54,D3        ;EXIT)BNE     Stat8)JMP     AEXIT !Stat8   CMPI.W  #42,D3        ;FOR)BNE     Stat9)JMP     aFOR !Stat9   CMPI.W  #45,D3        ;CASE)BNE     Stat10)JMP     ACASE !Stat10  CMPI.W  #55,D3        ;WITH)BNE     Stat18)JMP     aWith (* !Stat17  CMPI.W  #92,D3        ;ASSEMBLER)BNE     Stat18 *) Stat18"END END StatSeq;  PROCEDURE aAssm;"BEGIN$ASSEMBLER)ST      AsmMode)MOVE.L  ASMSCOPE,-(A6) ;AssemblerScope oeffnen)ADDQ.W  #4,ROSCOPE)JSR     GetSbl)CMP.W   #35,D3        ;leere ASSEMBLER-Anweisung: nicht Assm aufrufen)BEQ     noAssm)JSR     Assm noAssm   SUBQ.W  #4,ROScope    ;Assembler-Scope wieder dicht)ADDQ.L  #4,A6)CLR     AsmMode)CMP.W   #35,D3        ;jetzt sollte ein END folgen)BNE     Er2)JMP     GetSbl Er2      MOVE    #rEndXp,D5)JMP     SyntaxErr$END"END aAssm;  PROCEDURE ARETURN; BEGIN ASSEMBLER); Return ohne Ergebnis-Expression aussortieren))TST.W   MODFLAG)BNE     RETURN2       ;Module Body: kein Ergebnis mîglich)MOVE.L  RESTYPE,D0)BEQ     RETURN2)); Ergebnis zurÅckgeben))JSR     PushInt)MOVE.W  RetFlag,D0)JSR     pushExpr)BRA     Return1 ); Return aus FOR: ggf. Reste des Stacks abrÑumen) Return2  JSR     GetSbl        ;kein Ergebnis: folgendes Symbol holen  Return1  TST     SuppressCode)BNE     noCode); Stack ggf. wg. FOR, WITH, usw, abrÑumen)CLR.L   D0)JSR     discardA7)TST.W   LastRet)BEQ     putit)JMP     jmpToRet putit    JSR     putRET)ADDQ.W  #1,LastRet noCode!END END ARETURN;    PROCEDURE SolveForwRefs;"BEGIN$ASSEMBLER)BRA     start solve2   JSR     PullInt)MOVE.L  D0,D2)JSR     ToHere start    DBF     D4,solve2$END"END SolveForwRefs;  PROCEDURE AWHILE; BEGIN ASSEMBLER)MOVE.W  SuppressCode,-(A7))JSR     LABEL         ;SETZEN)JSR     PullInt       ;Label vom Int-Stack retten)MOVE.L  D0,-(A7))JSR     boolExpr)MOVE    D0,-(A7)      ;Anz. der Forward-Refs auf Stack)CMPI.W  #40,D3        ;DO?)BEQ     ok)MOVE    #rDoXp,D5)JMP     SyntaxErr !ok      JSR     StatSeq)CMPI.W  #35,D3        ;END)BEQ     ok1)MOVE    #rBdSym,D5)JMP     SyntaxErr !ok1     MOVE    (A7)+,D4)MOVE.L  (A7)+,D0      ;VOR-BRA.L LUECKE)TST     SuppressCode)BNE     noBra)JSR     BRAToLabelD0 noBra    JSR     SolveForwRefs)MOVE.W  (A7)+,SuppressCode)JMP     GetSbl!END END AWHILE;) PROCEDURE AREPEAT; BEGIN ASSEMBLER)JSR     LABEL)JSR     PullInt       ;Label vom Int-Stack retten)MOVE.L  D0,-(A7))JSR     StatSeq)CMPI.W  #38,D3        ;UNTIL)BEQ     ok)MOVE    #rUntXp,D5)JMP     SyntaxErr !ok      MOVE.W  SuppressCode,-(A7))JSR     boolExpr)MOVE.W  (A7)+,SuppressCode     ; hat hier ja keinen Sinn mehr)MOVE    D0,D4)BRA     start solve    JSR     PullInt       ;Ref von 'boolExpr' zu FALSE-target)MOVE.L  D0,D1)MOVE.L  (A7),D0       ;Adr. des Labels)JSR     SolveLabel start    DBF     D4,solve)ADDQ.L  #4,A7 END END AREPEAT;) PROCEDURE ALOOP; BEGIN ASSEMBLER)JSR     LABEL)ADDQ.W  #1,LOOPLEV)MOVE.L  EXSTKPtr,A0)CLR.W   -(A0)          ;EXIT COUNT)MOVE.L  A0,EXSTKPtr)MOVE.L  LoopDiscOfs,-(A7)   ;BYTES AUF DEM STACK VON FOR/WITH)MOVE.L  LastExit,-(A7))MOVE.L  A7Offset,LoopDiscOfs)CLR.L   LastExit)JSR     StatSeq)MOVE.L  (A7)+,LastExit)MOVE.L  (A7)+,LoopDiscOfs)CMPI.W  #35,D3)BEQ     ok)MOVE    #rBdSym,D5         ;END EXPECTED)JMP     SyntaxErr !ok      JSR     BRAToLabel)MOVE.L  EXSTKPtr,A5)MOVE.W  (A5)+,D0)BEQ     LOOP2 !LOOP1   MOVE.L  (A5)+,D2)JSR     ToHere)SUBQ.W  #1,D0)BNE     LOOP1 !LOOP2   MOVE.L  A5,EXSTKPtr)SUBQ.W  #1,LOOPLEV)JMP     GetSbl END END ALOOP;) PROCEDURE AEXIT; BEGIN ASSEMBLER)TST.W   LOOPLEV)BNE     ok)MOVE    #rNoLop,D5)JMP     SyntaxErr ok);noch Muell/gerettete Regs auf dem Stack?)MOVE.L  LoopDiscOfs,D0)JSR     discardA7))MOVE.L  EXSTKPtr,A0)LEA     INTSTK,A5)ADDQ.L  #6,A5)CMPA.L  A5,A0)BLS     isFull         ; Stack ist voll -> BRA zum letzten EXIT gen.)MOVE.W  (A0)+,D0)ADDQ.W  #1,D0)MOVE.L  A4,D1)ADDQ.L  #2,D1)MOVE.L  D1,-(A0))MOVE.W  D0,-(A0))MOVE.L  A0,EXSTKPtr  (* brauchen wir nicht mehr:)CMPA.L  #INTSTK,A0)BHI     ok1)MOVE    #rExiOv,D5)JMP     SyntaxErr'ok1 *))MOVE.L  A4,LastExit)JSR     put39         ;BRA forward)JSR     put2          ;BRA-WEITE RESERVIEREN)JMP     GetSbl  isFull   ; Sprung zum letzten Exit erzeugen)MOVE.L  LastExit,D0)JSR     BRAToLabelD0)JMP     GetSbl END END AEXIT;   PROCEDURE AIF; BEGIN ASSEMBLER)MOVE.W  SuppressCode,-(A7) ;IF-global merken)MOVE.L  ISTKPTR,-(A7)  ;INTEGER-SP merken)CLR.W   -(A7)          ;zÑhlt die BRAs zum END)CLR.W   -(A7)          ;zÑhlt die Labels der letzten 'boolExpr'  !IF2     MOVE.W  SuppressCode,-(A7) ;merken f. THEN bis END/ELSE/ELSIF)JSR     boolExpr)MOVE    D0,2(A7) )CMPI.W  #32,D3        ;THEN)BEQ     ok)MOVE    #rTheXp,D5)JMP     SyntaxErr  !ok      JSR     StatSeq)MOVE.W  (A7)+,SuppressCode))TST     (A7))BNE     doCode); IF/ELSIF war TRUE -> keinen weiteren Code gen.)MOVE    #1,SuppressCode doCode)CMPI.W  #34,D3        ;ELSIF)BNE     IF1 )JSR     Put39         ; BRA...)JSR     ForwardRef)ADDQ.W  #1,2(A7)); nun alle false-Labels von boolExpr auflîsen)MOVE    (A7),D4)BSR     solve)BRA     IF2  !IF1     CMPI.W  #33,D3        ;ELSE)BNE     IF3 )JSR     Put39         ; BRA...)JSR     ForwardRef)ADDQ.W  #1,2(A7)); nun alle false-Labels von boolExpr auflîsen)MOVE    (A7),D4)BSR     solve)CLR     (A7))JSR     StatSeq  !IF3     CMPI.W  #35,D3        ;END)BEQ     ok1)MOVE    #rBdSym,D5)JMP     SyntaxErr  !ok1     ; zuletzt die BRA-Label zum END lîsen)MOVE.W  (A7)+,D4)ADD.W   (A7)+,D4)JSR     SolveForwRefs)MOVE.L  ISTKPTR,D0  ;INTEGER-SP)CMP.L   (A7)+,D0)BEQ     StkOk)JSR     HALT        ; da stimmt was nicht! StkOk    MOVE.W  (A7)+,SuppressCode)JMP     GetSbl  solve    ; Lîsen der letzten Label-Liste vom 'boolExpr'-Aufruf)JSR     PullInt     ; aber zuvor noch die neue Forw-Ref retten)MOVE.L  D0,-(A7))JSR     SolveForwRefs)MOVE.L  (A7)+,D0)JMP     PushInt"END END AIF;)) PROCEDURE Acase; BEGIN ASSEMBLER)JSR     caseExpr        ;CASE-Selektor nach D0)JSR     PullInt         ;SELECTOR TYPE)CMPI.B  #11,-1(A1,D0.L) ;Subrange ?)BNE     noSubR)MOVE.L  -18(A1,D0.L),D0 ;Basistyp nehmen !noSubR  MOVE.L  D0,caseTYPE)CLR.W   FRSTcase)CLR.W   caseCNT)JSR     Put39         ; BRA...)JSR     ForwardRef)CMPI.W  #46,D3        ;OF?)BEQ     case3)MOVE    #rOFXp,D5)JMP     SyntaxErr !case3   JSR     GetSbl        ;jetzt auch leere ||| erlaubt );folgt ein <case> oder ist er leer (d.h. | oder END folgt) ?)CMPI.W  #29,D3        ;|)BEQ     case3)CMPI.W  #30,D3        ;!)BEQ     case3)CMP.W   #33,D3        ;ELSE?)BEQ     case2)CMP.W   #35,d3        ;END?)BEQ     case4)); muss nicht-leerer <case> sein)ADDQ.W  #1,caseCNT    ;muss weiterer case sein)BSR.L   onecase));jetzt muss '|' oder END folgen!)CMPI.W  #29,D3        ;|)BEQ     case3)CMPI.W  #30,D3        ;!)BEQ     case3)CMP.W   #33,D3        ;ELSE?)BEQ     case2)CMP.W   #35,d3        ;END?)BEQ     case4)MOVE    #rCaStr,D5)JMP     SyntaxErr) !case4   JSR     label         ;default case)MOVE.L  Options,D0)BTST    #10,D0        ;$J-?)BEQ     nocaseEr)TST.W   caseCNT)BEQ     emptyCas)BTST    #18,D0        ;$R-?)BEQ     nocaseEr)JSR     PutTRAPCaseErr)BRA     nocaseEr emptyCas MOVE    #rNoCas,D5    ;bei J+ Fehler bei leerem Case melden)JMP     SyntaxErr nocaseEr TST.W   caseCNT)BEQ     ignCase       ;bei J- leeres Case ignorieren)JSR     Put39         ; BRA...)JSR     ForwardRef)BRA     ok2  !case2   JSR     label)BSR.L   casestat      ;statement seq)CMPI.W  #35,D3        ;END?)BEQ     ok2)MOVE    #rBdSym,D5)JMP     SyntaxErr  !ok2     BSR     caseTBL       ;SPRUNGTABELLE ignCase  JMP     GetSbl ; caseTBL  MOVE.L  caseTYPE,D0)MOVE.L  A4,-(A7)        ;case VERTEILER-ADR)SF      secondBcc)CMPI.L  #4,-6(A1,D0.L) ;LONG TYPE?)BNE     caseTBL4        ;WORD)); CaseTbl fuer Long-Selektoren))JSR     Put79b         ; CMPI.L)MOVE.L  MaxCase,(A4)+)CMPI.B  #1,-1(A1,D0.L) ; LONGINT?)BEQ     CASETBL6 CASETBL0 JSR     PUT47          ; BHI)MOVE.L  A4,-(A7))JSR     PUT2           ; put 0.W)MOVE.L  MinCase,D0)BEQ.W   CASETBL8)JSR     PutSubIL_D0   ;SUB.L #MINcase)JSR     Put46         ;BCS)BRA.L   CASETBL7 CASETBL6 ; vorzeichenbehafteter Vergleich)TST.L   MinCase       ;wenn LowBound=0, dann Vergl. ohne Vorzeichen!)BEQ     CASETBL0)JSR     Put49         ;BGT)MOVE.L  A4,-(A7))JSR     PUT2           ; put 0.W)MOVE.L  MinCase,D0)BEQ.W   CASETBL8)JSR     PutSubIL_D0   ;SUB.L #MINcase)JSR     Put48         ;BLT)BRA.W   CASETBL7 ); CaseTbl fuer Word-Selektoren) CASETBL4 MOVE.L  D0,-(A7))JSR     PUT79         ;CMPI.W)MOVE.W  MAXcase2,(A4)+)MOVE.L  (A7)+,D0)CMPI.B  #33,-1(A1,D0.L) ;ShortInt?)BEQ     caseTBL5      ;SIGNED caseTBL9 JSR     Put47         ;BHI)MOVE.L  A4,-(A7))JSR     PUT2           ; put 0.W)MOVE.W  MinCase2,D0)BEQ     CASETBL8)JSR     PutSubIW_D0   ;SUB.W #MINcase)JSR     Put46         ;BCS)BRA     caseTBL7 caseTBL5 ; vorzeichenbehafteter Vergleich)TST.L   MinCase       ;wenn LowBound=0, dann Vergl. ohne Vorzeichen!)BEQ     CASETBL9)JSR     Put49         ;BGT)MOVE.L  A4,-(A7))JSR     Put2)MOVE.W  MinCase2,D0)BEQ     CASETBL8)JSR     PutSubIW_D0   ;SUB.W #MINcase)JSR     Put48         ;BLT ); Weiter fÅr alle Selektoren) caseTBL7 ST      secondBcc)MOVE.L  A4,-(A7))JSR     PUT2           ; put 0.W caseTBL8 JSR     Put70         ;VERTEILER)MOVE.L  A4,A5         ;^ANFANG DER SPRTAB)MOVE.L  MAXcase,D0)SUB.L   MINcase,D0)LSL.L   #1,D0)MOVE.W  D0,D4         ;^LAST ADR)ADDQ.L  #2,D0)ADDA.L  D0,A4         ;CODE-PTR HINTER TAB)JSR     PullInt       ;BRA NACH ELSETEIL)MOVE.L  D0,D2)JSR     ToHere)JSR     LookINT       ;DEFAULT ADR)MOVE.L  D0,D1)MOVE.L  (A7)+,A0)MOVE.L  D1,D2)SUB.L   A0,D2)MOVE.W  D2,(A0)       ;OUT OF RNG caseS NACHTRAGEN)TST.B   secondBcc)BEQ     no2nd)MOVE.L  (A7)+,A0)MOVE.L  D1,D2)SUB.L   A0,D2)MOVE.W  D2,(A0) no2nd    JSR     PullInt       ;DEFAULT-ADR HOLEN)SUB.L   A5,D0)MOVE.W  D0,D5 caseTBL1 MOVE.W  D0,0(A5,D4.W))SUBQ.W  #2,D4)BPL     caseTBL1 caseTBL3 JSR     PullInt)MOVE.L  D0,D2)JSR     ToHere        ;STATEMENT-ENDE)JSR     PullInt       ;STATEMENT-ADR)SUB.L   A5,D0         ;RELATIV ZUM VERTEILER)MOVE.W  D0,D2)JSR     PullInt)MOVE.L  D0,D4         ;case-ZAEHLER caseTBL2 JSR     PullInt)SUB.L   MINcase,D0)LSL.W   #1,D0)CMP.W   0(A5,D0.W),D5  ;STEHT NOCH DIE DEFAULT-ADR DA?)BEQ     CSTOK)MOVE    #rCase2,D5        ;case LABEL DECL. TWICE)JMP     SyntaxErr CSTOK    MOVE.W  D2,0(A5,D0.W)  ;IN TABELLE EINTRAGEN)SUBQ.W  #1,D4)BNE     caseTBL2)SUBQ.W  #1,caseCNT    ;MEHR caseS?)BNE     caseTBL3)JSR     PullInt)MOVE.L  D0,D2)MOVE.L  (A7)+,D1      ;VERTEILER-ADR)JMP     ToHere0)); Im Folgenden werden alle CASE-Labels stets Long bearbeitet;); die Subroutines sind daher fuer alle Selektor-Typen zu verwenden:)); eine Case-Variante verarbeiten) !onecase  CLR.W   LBLCNT        ;LABEL-ZAEHLER*MOVE.L  A4,-(A7)*BRA     onecase2 !onecase1 JSR     GetSbl !onecase2 BSR.L   caseLBL*CMPI.W  #8,D3         ;..*BNE     onecase3*BSR.L   LBLRNG !onecase3 CMPI.W  #10,D3        ;,*BEQ     onecase1*CMPI.W  #25,D3        ;:*BEQ     OCSOK*MOVE    #rColXp,D5*JMP     SyntaxErr !ocsok    CLR.L   D0*MOVE.W  LBLCNT,D0*JSR     PushInt*MOVE.L  (A7)+,D0      ;LABEL AUF StatSeq SETZEN*JSR     PushInt*CLR.W   D7 !casestat MOVE.L  MINcase,-(A7)*MOVE.L  MAXcase,-(A7)*MOVE.L  caseTYPE,-(A7)*MOVE.W  caseCNT,-(A7)*JSR     StatSeq*JSR     Put39         ; BRA...*JSR     ForwardRef*MOVE.W  (A7)+,caseCNT*MOVE.L  (A7)+,caseTYPE*MOVE.L  (A7)+,MAXcase*MOVE.L  (A7)+,MINcase*RTS ); ein CaseLabel holen und verdauen  !caseLBL JSR     ConstExpr)MOVE.L  caseTYPE,D2)JSR     PullInt)JSR     adaptSStoCHAR)JSR     constTyp)JSR     COMPATRR)BEQ     CsLblok)MOVE    #rBdTyp,D5)JMP     SyntaxErr !CsLblok BSR.L   minmax)MOVE.L  Accu,D0)JMP     PushInt ); 'Label .. Label' verdauen) LBLRNG   MOVE.L  Accu,-(A7)      ;LOW BND MERKEN)JSR     GetSbl)JSR     ConstExpr)MOVE.L  caseTYPE,D2)JSR     PullInt)JSR     adaptSStoCHAR)JSR     constTyp)JSR     COMPATRR)BEQ     LRNGok)MOVE    #rBdTyp,D5)JMP     SyntaxErr LRNGok   MOVE.L  (A7),D0)BSR.L   compar)BEQ     LBLRNG1)MOVE    #rLowHi,D5         ;LOW BND > HIGH BND)JMP     SyntaxErr LBLRNG1  MOVE.L  (A7),D0)CMP.L   Accu,D0)BEQ     LBLRNG2       ;BEI GLEICHHEIT FERTIG)BSR.L   minmax)MOVE.L  Accu,D0)JSR     PushInt)SUBQ.L  #1,Accu)BRA     LBLRNG1 LBLRNG2  ADDQ.L  #4,A7)RTS  ; ;   VERGLEICHT D0 MIT Accu SIGNED ODER UNSIGNED ;   D0 <= I1: EQ ;   D0 > I1: NE ; !compar  CMPI.B  #33,-1(A1,D2.L) ;ShortInt?)BEQ     compare3)CMPI.B  #01,-1(A1,D2.L) ;LongInt?)BEQ     compare3)CMP.L   Accu,D0         ;UNSIGNED)BHI     compare1      ;NE compare2 CLR.W   D0            ;SETZT EQ compare1 RTS compare3 CMP.L   Accu,D0)BGT     compare1      ;NE GESETZT)BRA     compare2      ;EQ)); minimales und maximales CaseLabel ermitteln) minmax   ADDQ.W  #1,LBLCNT)TST.W   FRSTcase)BNE     minmax1)MOVE.L  Accu,MINcase)MOVE.L  Accu,MAXcase)NOT.W   FRSTcase)RTS minmax1  MOVE.L  Accu,D0)CMPI.B  #33,-1(A1,D2.L) ;ShortInt?)BEQ     minmax2)CMPI.B  #01,-1(A1,D2.L) ;LongInt?)BEQ     minmax2 minmax3  CMP.L   MINcase,D0    ;UNSIGNED)BCS     minmax6)CMP.L   MAXcase,D0)BHI     minmax7)RTS minmax2  CMP.L   MINcase,D0    ;SIGNED)BLT     minmax6)CMP.L   MAXcase,D0)BGT     minmax7)RTS minmax7  MOVE.L  D0,MAXcase)RTS minmax6  MOVE.L  D0,MINcase!END END Acase;   (*!*    Hilfsprozeduren zur Parameter-Auswertung!*)! PROCEDURE GetLPar;              (* Linke Klammer holen *) BEGIN ASSEMBLER)JSR     GetSbl)CMPI.W  #14,D3)BEQ     ok)MOVE    #rLPaXp,D5)JMP     SyntaxErr ok     END END GetLPar;  PROCEDURE GetRPar;        (* Rechte Klammer pruefen, folgendes Symbol holen *) BEGIN ASSEMBLER)CMPI.W  #26,D3)BEQ     ok)MOVE    #rParXp,D5)JMP     SyntaxErr ok       JMP     GetSbl'END END GetRPar;  PROCEDURE GetComma;      (* Komma pruefen *) BEGIN ASSEMBLER)CMPI.W  #10,D3)BEQ     ok)MOVE    #rComXp,D5)JMP     SyntaxErr ok     END END GetComma;  PROCEDURE GetAdr;       (* Var/Rec-Adresse auf Stack holen lassen,;pruefen, ob Typ mit (D0) kompatibel *) BEGIN ASSEMBLER)JSR     PushInt)JSR     GetSbl)BMI     ok1)MOVE    #rVarXp,D5)JMP     SyntaxErr !ok1     JSR     pushAdr)JSR     compat)BEQ     ok2)MOVE    #rOpTyp,D5)JMP     SyntaxErr ok2   END END GetAdr;  PROCEDURE GetVal;       (* Expressionwert auf Stack holen lassen,;pruefen, ob Typ mit (D0) kompatibel *) BEGIN"ASSEMBLER)JSR     PushInt)MOVEQ   #0,D0)JSR     pushExpr"END END GetVal; ( (*!*     Standard-Prozeduren!*)! PROCEDURE ANEW; BEGIN ASSEMBLER)JSR     NDARG         ;Parameter AUSWERTEN)JSR     CALLAL)JMP     SameSbl&END END ANEW;) PROCEDURE ADISPOSE; BEGIN ASSEMBLER)JSR     NDARG)JSR     CALLDEAL)JMP     SameSbl&END END ADISPOSE;  PROCEDURE NDARG; BEGIN ASSEMBLER)JSR     GetLPar)JSR     GetSbl)BMI     ok1)MOVE    #rVarXp,D5)JMP     SyntaxErr !ok1     JSR     pushAdr)JSR     PullInt)CMPI.B   #20,-1(A1,D0.L) ;POINTER?)BEQ     ok2)MOVE    #rBdTyp,D5         ;TYPE CONFLICT)JMP     SyntaxErr !ok2     MOVE.L  -10(A1,D0.L),D2 ;BASETYPE)JSR     Put25             ;MOVE.L #xx,(A3)+)MOVE.L  -6(A1,D2.L),(A4)+ ;LAENGE DES BASETYPE)JSR     SameSbl)JMP     GetRPar!END END NDARG;  PROCEDURE aCode;"BEGIN$ASSEMBLER(JSR     GetLPar again   JSR     GetSbl(JSR     ConstExpr(MOVE.L  SBothTyp,D2(JSR     PullInt(JSR     COMPATRR(BEQ     LRNGok(MOVE    #rCarXp,D5      ; CARDINAL-Const exp.(JMP     SyntaxErr LRNGok  MOVE.L  Accu,D0(CMPI.L  #$FFFF0000,D0(BCC     ok(CMPI.L  #$0000FFFF,D0(BLS     ok(MOVE    #rConRg,D5      ; Const range error(JMP     SyntaxErr ok      MOVE.W  D0,(A4)+(CMPI.W  #10,D3        ;,?(BEQ     again         ;weiter, solange ',' folgt(JMP     GetRPar$END"END aCode;" PROCEDURE aNewProcess; BEGIN ASSEMBLER(MOVE.L  -8(A1,D2.L),-(A7)  ;^Parameter-Kette(JSR     GetLPar(MOVE.L  (A7)+,D2(MOVE.L  -14(A1,D2.L),-(A7) ;^ naechstes El. der Kette(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ PROC(JSR     GetVal          ;PROC-Expression holen(JSR     GetComma(MOVE.L  (A7),D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetVal          ;Address-Expr holen(JSR     GetComma(MOVE.L  CardPtr,D0(JSR     GetVal          ;LongCard-Expr holen(JSR     GetComma(MOVE.L  (A7)+,D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetAdr          ;Process-VAR (Typ Address) holen(JSR     GetRPar(MOVEQ   #35,D3(JSR     CSP             ;Runtime-Modul aufrufen(JMP     SameSbl%END END aNewProcess;  PROCEDURE aIOTransfer; BEGIN ASSEMBLER(MOVE.L  -8(A1,D2.L),-(A7)  ;^Parameter-Kette(JSR     GetLPar(MOVE.L  (A7),D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetAdr          ;Process-VAR holen(JSR     GetComma(MOVE.L  (A7),D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetAdr          ;Process-VAR holen(JSR     GetComma(MOVE.L  (A7)+,D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetVal          ;Exc.Nr: Address-Expr holen(JSR     GetRPar(MOVEQ   #34,D3(JSR     CSP             ;Runtime-Modul aufrufen(JMP     SameSbl&END END aIOTransfer;  PROCEDURE aTransfer; BEGIN ASSEMBLER(MOVE.L  -8(A1,D2.L),-(A7)  ;^Parameter-Kette(JSR     GetLPar(MOVE.L  (A7),D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetAdr          ;Process-VAR holen(JSR     GetComma(MOVE.L  (A7)+,D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetAdr          ;Process-VAR holen(JSR     GetRPar(MOVEQ   #33,D3(JSR     CSP             ;Runtime-Modul aufrufen(JMP     SameSbl&END END aTransfer;  PROCEDURE aIOCall; BEGIN ASSEMBLER(MOVE.L  -8(A1,D2.L),-(A7)  ;^Parameter-Kette(JSR     GetLPar(MOVE.L  (A7)+,D2(MOVE.L  -6(A1,D2.L),D0  ;^Parameter-Typ ADDRESS(JSR     GetVal          ;Exc.Nr: Address-Expr holen(JSR     GetRPar(MOVEQ   #40,D3(JSR     CSP             ;Runtime-Modul aufrufen(JMP     SameSbl&END END aIOCall;  PROCEDURE aListen; BEGIN ASSEMBLER(MOVEQ   #39,D3(JSR     CSP             ;Runtime-Modul aufrufen(JSR     GetSbl(CMPI.W  #14,D3          ;linke Klammer?(BNE     noPar(JSR     GetSbl(JMP     GetRPar         ;rechte Klammer muû folgen"noPar&END END aListen;  (* (*$ i Q:mc6.Expr.Text    *) (*$ i Q:mc7.Import.Text  *) (*$p-*) (*$ i Q:mc8.Assm.Text    *) (*$p+*) *)  (*$ i Import.ICL   *) (*$ i Assm.ICL     *)  PROCEDURE Compile (); BEGIN "(*$ ? runGep:    pname := 'System.List.Text'; *)"(*$ ? runST:     pname := 'MODULA.LST'; *)""BadID := '';"(*$ ? runST:$IF ScanMode THEN AutoCmd := ScanErrFile$ELSE AutoCmd := 0$END;"*)""ASSEMBLER$(*$ ? runGep: MOVEM.L A1/A2/A4,saveRegs    *)$(*$ ? runST:  MOVEM.L A4/A5/A6,saveRegs    *))MOVE.L  A3,LoSysStack)MOVE.L  A7,HiSysStack"END;""ASSEMBLER)MOVE.W  #3,GlobalUseFormat  ;Default: benutze GDOS-Realformat"END;"DataLen:= DataSpcDft;"MaxSpace:= MaxSpcDft;"DynSpace:= DynSpcDft;""OpenIO;"Comp;"CloseIO;""ASSEMBLER$(*$ ? runGep: MOVEM.L saveRegs,A1/A2/A4    *)$(*$ ? runST:  MOVEM.L saveRegs,A4/A5/A6    *)"END;""CodeSize:= csize;"FastStrings.Assign (cname, CodeName);"Strings.Upper (CodeName);" END Compile;  BEGIN"Compile (*$p+*) END MM2Comp.  
(* $00014D41$00018757$FFE118F8$0000FE7D$000102F6$00010488$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$000054E7$FFFCF6B2$0001F352$FFFCF6B2$00008AF5$FFFCF6B2$00014D41$0000B68B$0001BC8E$FFF6EC04$FFFCF6B2$FFFCF6B2$FFFCF6B2$00018197$000058CC$00012DCD$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$00019A27$0001030C$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2$FFFCF6B2Ä$00008B06T........T.......T......T.......T.T.....T.......T.......T.......T.......T.......$FFE4EE62$0001F1EF$00008881$0000888F$0000887F$000088D5$00008D7E$00008AF5$00008AD2$FFE4EE62$00008AFF$000054E7$0001F21F$0001F207$000089D0$00008AFD∞ÄÉ*)
