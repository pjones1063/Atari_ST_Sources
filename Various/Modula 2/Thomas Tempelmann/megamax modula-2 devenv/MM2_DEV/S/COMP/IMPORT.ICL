  (* -----------------------#Modula Compiler  /4.2c/#-----------------------#File mc7: Import-/Export-Behandlung#$26.3.85  GDOS Version$30.7.85  Export/Import von Stringkonstanten gerader Laenge-Import von Record-Feldern aus DefMod ins zugehoerige.ImpMod nicht mehr global-erster Versuch zum EnumExport-Problem%7.8.85  Exportlisten optional (neuer Standard: alles qual. exportieren)$19.8.85  Global-Level in DefModulen bleibt 0$28.8.85  CompileTime-Absturz bei fehlender Export-Liste ausgeschlossen#11.12.85  Reload beim Holen des Namens 'RUNTIME' verhindert#12.12.85  in PlaTree Platzkalkulation geaendert#14.12.85  Aenderung vom 12. erstmal wieder rueckgaengig gemacht#22.02.86  Neuordnung der Texte#23.02.86  Wert von MinInt geaendert (muss Long eingetragen sein);-Relay (Kennung 0) in die ItemListe eingetragen, in PlaTree-Einsetzen der Beschreibung bei Relays verhindert.#14.04.86  Import von Opaques auf Umwegen in die eigene Implementation-verhindert nicht mehr die Nach-Deklaration#09.09.86  FROM modulname IMPORT holt Modulname mit OldId statt GetId#15.10.86  Pseudo-Modul und System-Modul definiert;-Importe aus System abgefragt und auf internes Modul gelenkt;-nur noch fuer 9 Standardtypen werden xxxPtr eingetragen.#16.10.86  Resultat Expand (Cardinal) von LongCard nach LongBoth geaendert;-ImPseud importiert bei $G+ auch SystemModul komplett;-Std-Funktionen MIN und MAX (Pseudo);-Fehlerbehandlung bei Ueberlauf von Neubildlisten (rImpOv) jetzt-in den aufrufenden Prozeduren, mit richtiger TextPos-Anzeige.#21.10.86  Char-Definition mit 1 oder 2 Bytes fuer Atari/Gepard Version#23.10.86  PlaTree erkennt Relay-Objekte als importiert, wenn ihr-Originaleintrag importiert ist#24.10.86  System-Modul auf Prozesse vorbereitet (aber noch eingeklammert);-Type Process in der Item-Liste aufgenommen.#25.10.86  Prozess-IDs in System freigegeben#26.10.86  Korrektur der Item.Nr fuer System19;-Aenderung vom 23. funktioniert jetzt (Abfrage des Import-Flags-durch BTST #13)#28.10.86  Korrektur der Parameter von IOTRANSFER und NEWPROCESS in System$1.11.86  Aenderung vom 23.10. wieder zurueck, damit Export von.Type = StandardType moeglich wird. Bei Entstehen eines Relays.durch nachtraegliches Bekanntwerden des Namens im Import.'erbt' der Relay die Flags des bestehenden Eintrags!.(OwnItm und ImpItm).$2.11.86  fuer Atari-Version 'LONG' in 'LONGWORD', 'EXPAND' in 'LONG'.umgetauft.$8.11.86  Typ PROCESS in System entfaellt, stattdessen Verweise auf Address#24.03.87  Atari-Version: auch leere Importlisten (nur Typ/Const in Impl.).bleiben drin, damit ImplMod fuer Versionskontrolle geladen.wird. (CloseImp)-Atari: ausfuehrliche Key-Berechnung (CopyInf)#30.03.87  Atari, CloseImp: Pseudomodul-imports nicht rausschreiben#07.04.87  TT, DefMod: Key=0-Verwertung anders, neue Keyber. auch f. Gepard#14.04.87  Key-Berechnung relativ zum globalen User-Id Baum#16.06.87  Platzvergabe fÅr Importphase und BaumplÑtten umgestellt;.der freie Platz wird in festen VerhÑltnissen aufgeteilt#19.06.87  neue Platzverteilung in InitImp#26.06.87  SIZE wird Standardfunktion (statt aus SYSTEM) bei Atari#14.07.87  TT, Atari,CloseImp: Auch Systemmodul-imports nicht rausschreiben#22.07.87  TT, Atari: Neue System-Proc LISTEN#25.10.87  Atari: neues Format der Importliste von DefMods:.keine Namen der importierten Module mehr drin..Es wird immer das wirkliche Ursprungsmodul aufgefÅhrt, auch.bei importierten IDs, die (als TYPE a = B) reexportiert werden.#26.10.87  Atari: BITSET = SET OF [0..15].#27.10.87  DefMod: ^Modulnamen auf relAdr 22 und Namensfeld dahinter.wird in DefnModule eingetragen#05.11.87  OwnDef verkraftet leere Definitionsmodule#16.11.87  Atari: IOCALL in System definiert#17.11.87  Atari: LISTEN-Eintrag in System korrigiert -> IOCALL geht jetzt.-beim Runtime-Import werden die Seriennummern geprÅft und-ggf. die Items-Tabelle vermurkst#29.05.88  ITEMS-Tabelle: neue Beschreibung fÅr 'Procedure', beim/Importieren wird Platz fÅr die LÑngen/Anf.adressen-Felder/angehÑngt;-CopInf, ImpItm verarbeiten die zusÑtzliche Kodierung in ITEMS#28.06.88  ImpQual markiert importierte IDs richtig (énderung vom 2.4.)#29.06.88  OwnItm markiert nur noch Prozeduren, und die in Bit 12 (Extern)/statt in Bit 14 (Export). BIT 14 IST FöR LOKALEN IMPORT/EXPORT/RESERVIERT!! (auûer in Definitionsmodulen beim BaumplÑtten).$2.07.88  System-Modul: Exporte als QUALIFIED markiert#10.12.89  Nachtrag vom 31.03.89:0DefMod: verrechnet kompletten Modulnamen im Key,0wenn K+ Option~ gesetzt ist.#13.12.89  Nachtrag vom 31.08.890DefMod: verrechnet nun immer kompletten Modulnamen0im Key (V3.7b)-Pseudo: neue Standardbezeichner0VAL     Std.function   9,0LENGTH  Std.function  10,0SIZE    Std.function  11,0LONGREAL;-System: neuer Bezeichner CAST  Std.function 104,0VAL und SIZE entfallen#14.12.89  TT LOC in SYSTEM nachgetragen, hat z.Zt. selbe Nr., wie BYTE (38)0REAL hat nur noch 4 Byte,0In ITEMS-Tab LONGARRAY und LONGREAL nachgetragen#18.12.89  TT neue SYSTEM-Funktionen:2CADR  105, DEREF 1060neue Pseudo-Funktionen:2INT  12, CAP  13, CHR  14, FLOAT  15, LFLOAT 16, TRUNC  170Pseudo: EintrÑge 11 (PROC) und 58 (LONGREAL) vertauscht;:auch 11er-Import in System-Modul angepaût8ImPseud kopiert nun auch LongReal-Pointer8Paramter SHORT (LONGREAL): REAL undALONG (REAL): LONGREAL nachgetragen#31.12.89  TT Pseudo: ZZ-Type neu (Kennung 4);8LONG (INTEGER/CARDINAL) liefern nun LONGINT/LONGCARD#09.01.90  TT Pseudo: LONG/SHORT (SBothTyp/BothTyp) hinzugefÅgt#10.01.90  TT Pseudo: Proc wieder an alten Platz gesetzt (11), dazu LongReal8und einen ABS-Parm verschoben.#12.01.90  TT System: SHORT (INTEGER/CARDINAL) ergibt BYTE#02.02.90  TT ImpItm16: Bei Kennung 7 (n Byte im Baum reservieren) wird der0Bereich auch gleich gelîscht. Auûerdem in selber Routine einige0ADDQ.W #x,D6 durch ADDQ.L ersetzt0ITEMS: FÅr Vars 2 Byte mehr reserviert (nur lokal)#19.02.90  TT Pseudo: ZZ mit gesetztem Bit 15, damit es auch in Neubild-Liste2kommt.0Neubild: Liste wird vollst. gelîscht (bisher nur Item-Nr)#27.02.90  TT Pseudo/System: BITSET nun in SYSTEM#21.04.90  TT CopInf: D3 (Key) wird bei Unterbaum nicht mehr zerstîrt,2statt Baum-Offset wird nun die Item-Nr im Key verrechnet,2durch Einbeziehung der Item-Flags wird auch zw. REF/VAR/value,2zw. D0-/(A3)-RÅckgabe und Proc-Parm-Modus im Key unterschieden#09.05.90  TT CALLSYS, CALLEXT, LOAD, STORE, CODE neu in SYSTEM, SHORTCARD2SHORTINT neu in Pseudo#30.06.90  TT BITSET nun mit Kennung 45 statt 5: immer neue Ordnung (unabh.2von $U-Option)#30.07.90  TT ITEMS: Record-Felder um einen Eintrag zum Verketten der1Reihenfolge erweitert; neue Kennungen 16, 46 fÅr Rec-Varianten.#18.08.90  TT Record-Eintrag (#13) geÑndert: vor dem Baum und seinem Ptr2steht nun der Ptr auf das 1. Element. Dadurch verschiebt2sich der Ptr auf den lok. Baum um 4 Byte (von -10 auf -14).#12.09.90  TT SetDef0,ImpItm16: Importierte Real-Konstanten werden ins2Zielformat konvertiert, allerdings noch nicht bei ShortReals!#23.09.90  TT PlaTre, CopInf: Tragen Enum-Elemente nun explizit nach.0PlaTre2 trÑgt nur exportierte Items und die von UnterbÑumen ein.0NumImp entfernt unbenutze Items aus ImportListe, DefMod0schiebt daraufhin geplÑtteten Baum runter; Rec-Variante von0Kennung 16 auf 47 verlegt; Die eigenen ItemNrn von Importlisten0in Def-Modulen sind auch nur noch 2 Byte statt 4 Byte groû.0Werden schon bekannte IDs nochmals importiert (m/o FROM),0dann werden bestehende Relays Åbersprungen, weil sonst doppelt0verkettete Relays entstehen (ImpItm20, OwnItm).0ITEMS: Proc-Type (44): Def. geÑndert.#23.10.90  TT ImpItm16/20,ImpAll,ImpRest,FromImp,ScanItm,ListImp,ItemAdr:0Kennung 7 Åber anonFlag eingefÅhrt, um Gemischtimporte von0Enum-Typen und ihren Elementen korrekt zu erkennen. Doku0siehe GlobImp#02.03.91  TT IPIMP: Importierte externe Vars werden nicht mehr in die0Relozierliste aufgenommen, so daû nun die Adr erhalten bleibt.#27.12.93  TT ImPseud: StrPtr ist nun identisch mit SSTyp; ITEMS: Kenn.50 neu.#15.02.94  TT SETILST: öbernimmt nun wieder Modulnamen in Importliste, aber0nur wÑhrend compiletime, nicht ins erzeugte Defmodul.0ImpXRef/IPIMP: relozierbare Items, die aus einem anderen als0dem importierten Defmod stammen, werden nachtrÑglich in die0Importliste des erzeugten Impmods aufgenommen.#----------------------------------------------------- *)  (*!*!*   Langfristige Registerbelegung:!*!*   A1 = Wurzel des ID-Baums!*   A2 = ^Text!*   A4 = ^erzeugten Code!*   A5 = ^Neubildlisten (bei Import)!*   A6 = ^Display Stack!*!*   TOI = Top of ID-Stack!*!* Eine Neubildliste ist ein Feld von Longs. Der Index ist die beim PlÑtten!* vergebene ItemNr, der Long-Wert der dazu gehîrige Pointer auf die!* Beschreibung im Baum.!*)! CONST ModNameLen = 25;  (* Anzahl sign. Zeichen in ModNames *)  CONST    PseudoKey = $12345679;)SystemKey = $87654321;  VAR       ILSTART,,ILEND,,AllExp,(CurrentDef,(CurrentKey: ADDRESS;$explicitImport,             (* TRUE: FROM ... IMPORT in Bearbeitung *)%mustChgFormat: BOOLEAN;)defFormat,*anonFlag: Cardinal; 2(* anonFlag = 2: gerade kopiertes Item ist anonym, auch7Verweise auf Enumelemente sind anonym einzutragen.5anonFlag = 7: kopiertes Item hat Namen, auch fuer7Enumelemente Namenseintrag fordern *)  FORWARD ImpItm; FORWARD ImpItm1; FORWARD ImpItm16; FORWARD ImpItm20; FORWARD ImpItm30; FORWARD ListImp; FORWARD SetDef0; FORWARD CopInf; FORWARD PlaTre; FORWARD PlaTre2; FORWARD MarkExp; FORWARD NumImp; FORWARD Define; FORWARD GlobExp; FORWARD CloseImp; FORWARD OwnDef; FORWARD ImpQual; FORWARD Runtime; FORWARD ImpAll; FORWARD ImpPer; FORWARD ImpGlob; FORWARD FromImp; FORWARD ImpRest; FORWARD MyPullId; FORWARD ImpXRef;  (*!*   ----------------------------------!*   Definition Module uebersetzen!*   ----------------------------------!*!*      A4 = ^erzeugten Code!*!*)! PROCEDURE DefMod; BEGIN ASSEMBLER)MOVE.B  #DLAYOUT,(A4)+ ;Modul-Format)MOVE.B  #3,(A4)+      ;Kennung: DefMod)JSR     PUT2          ; 2:qual.Flag)JSR     PUT3          ; 4:Key)JSR     PUT3          ; 8:^gepl.Baum)JSR     PUT2          ;12:Anzahl exp. Items)JSR     PUT3          ;14:^Imports)JSR     PUT3          ;18:Platz der definierten Variablen)MOVE.L  A4,-(A7))JSR     PUT3          ;22:^Modulname)JSR     PUT2          ;26:Ende d. Headers (Word!) - erst ab DLayout 6!)JSR     PUT2          ;28:^Sourcename (Word!))JSR     PUT3          ;30:Liste der implizit zu importierenden Module)); Modulnamen/Ende d. Headers eintragen)MOVE.L  A4,D0)SUB.L   Header,D0)MOVE.L  (A7)+,A0)MOVE.L  D0,(A0)+      ;^Modulname)MOVE.W  D0,(A0)+      ;^Headerende))JSR     LookId        ;A0 := ^ Top of ID-Stack!en3     MOVE.B  (A0)+,(A4)+)BNE     en3           ;kopieren bis Endmarke 0.B)JSR     put0          ;sync))JSR     GetSbl)JSR     GlobImp       ;Import-Statements)JSR     GlobExp       ;Export-Satements)JSR     Define        ;Deklarationen)CMPI.W  #35,D3        ;END?)BEQ     OK1)MOVE    #rDecl,D5)JMP     SyntaxErr !OK1     JSR     FinLblAndFwrd ;Sind alle Fwrd-Refs aufgelîst?)JSR     MarkExp       ;Exports im Baum markieren)JSR     PlaTre        ;gepl.Baum erstellen)JSR     NumImp        ;Imports mit eigener ItemNr versehen)CLR.L   (A4)+         ;impliz. Importliste abschlieûen)); Nun geplÑtteten Baum und implizite Importliste); zurÅckschieben (Offset ist in D0))MOVE.L  Header,A3       ;Code-Anfang)MOVE.L  8(A3),D1      ;alter ^geplaetteten Baum)BEQ     nomove        ;keine Exportliste (dann auch keine impl. ImpLst))MOVE.L  D1,A0)SUB.L   D0,8(A3))SUB.L   D0,30(A3))ADDA.L  A3,A0)MOVE.L  A0,A5)SUBA.L  D0,A0         ;neue Adr.);Anfang des gepl.Baums in A5, Ende in A4, Ziel in A0)SUBA.L  D0,A4         ;A4 ist nun Ziel-Ende movtree  MOVE.L  (A5)+,(A0)+)CMPA.L  A4,A0)BCS     movtree nomove)MOVE.L  KEY,D0 ExtKey   MOVE.L  IDStkBPtr,A0  ;neue Key-Berechnung: alle Namens-Bytes rein)ADDQ.L  #1,A0 ekloop   MOVE.B  (A0)+,D1)BEQ     ekend)EOR.B   D1,D0)ROL.L   #1,D0)BRA     ekloop ekend    TST.L   D0)BNE     ok3)MOVEQ   #1,D0         ;0-Key verhindern ok3      MOVE.L  Header,A0)MOVE.L  D0,4(A0)'END END DefMod;   (* ››› *   ---------------------------------- *   Imports in DefModule mit deren eigener ItemNr versehen *   ---------------------------------- * * Bisher enthalten die Importlisten noch Ptr auf die IDs. Nun werden * daraus Item-Nrn gemacht. Nicht benutzte Items, also solche, die nicht * in der Neubildliste auftreten, werden entfernt. Der Wert, um den sich * die Liste verkÅrzt hat, wird in D0 geliefert. * * 15.02.94: * Wg. Alias-Prozeduren mÅssen ggf. die Modulnamen fÅr implizite Importe * eingetragen werden. Dazu wird hier einfach der Name jedes Moduls erstmal * am Code (A4, hinter lin. Baum) angehÑngt und nur dann wieder entfernt, * wenn keine Prozedur in der Importliste Åbrigbleibt. * *      (D0,D1,A0,A5) * *      A3 = ^NeubildListe des importierenden Moduls *      D5 = hîchste eigene ItemNr + 1 * *      D0: Wert, um den die Liste kÅrzer geworden ist. *) PROCEDURE NumImp; BEGIN ASSEMBLER)MOVE.L  A4,-(A7))MOVE.L  Header,A0)MOVE.L  A4,D0)SUB.L   A0,D0)MOVE.L  D0,30(A0)     ;^implizite Importliste)ADDA.L  14(A0),A0     ;^ImportListe)MOVE.L  A0,A5         ;^neue Importliste) !NumImp4 MOVE.L  (A7),A4)MOVE.L  (A0)+,D0)MOVE.L  D0,(A5)+      ;Ende der ImportListe?)BEQ     NumImp2       ; ja))MOVE.W  (A0)+,(A5)+   ;Import in DefMod: Itemanzahl kopieren))MOVE.L  D0,(A4)+      ;Key kopieren))TST.W   (A0)+         ;ist Modulname vorhanden?)BNE     NumImp5))MOVE.B  #'?',(A4)+    ;zum leichteren Debuggen dummy-Namen einfÅgen)MOVE.B  #$FF,(A4)+)BRA     NumImp1) !NumImp5 MOVE.W  (A0)+,D0      ;Modulname f. implizite Importliste kopieren)MOVE.W  D0,(A4)+)CMP.B   #$FE,D0)BCS     NumImp5  !NumImp1 MOVE.W  (A0)+,(A5)+   ;Ende des Imports aus diesem Modul?)BEQ     NumImp4       ; ja)MOVE.L  (A0)+,D0      ;bisheriger Item-Ptr)MOVE.L  A3,-(A7)      ;^Anfang der Neubildliste retten)CLR.W   D1 !NumImp3 ADDQ.W  #1,D1         ;Import in NeubildListe suchen)CMP.L   (A3)+,D0)BEQ     NumImp6       ;gefunden: D1 ist eigene ItemNr)CMP.W   D5,D1         ;alle Items durch?)BCS     NumImp3       ; nein, weiter))SUBQ.L  #2,A5         ; ja, nicht gefunden: entfernen)MOVE.L  (A7)+,A3)BRA     NumImp1) !NumImp6 MOVE.W  D1,(A5)+      ;eigene ItemNr eintragen)MOVE.L  (A7)+,A3)MOVE.W  -2(A1,D0.L),D0 ;Item-Kennung)ANDI    #$80FF,D0)CMPI    #$8006,D0)BNE     NumImp1)MOVE.L  A4,(A7)        ;Dieses Modul bleibt in Impliziter Modulliste)BRA     NumImp1  NumImp2  MOVE.L  A0,D0)SUB.L   A5,D0)ADDQ.L  #4,A7 END END NumImp;  (*!*   ----------------------------------!*   Export-Statement:!*      qual/perv. Flags setzen, IDs auf ID-Stack holen!*   ----------------------------------!*!*      D3 = Symbol (EXPORT falls vorhanden)!*!*      (A0)!*!*      D3 := folgendes Symbol!*      ID-Stack := exp. IDs!*      xpcount := Anzahl der exp. IDs!*      AllExp := "keine ExportListe - alles qualified exportieren"!*)! PROCEDURE GlobExp; BEGIN ASSEMBLER*CLR.W   XPCNT*CMPI.W  #1,D3*BNE     GlobExp3      ;keine Exportliste*CLR.W   AllExp        ;also nur gelistete IDs exportieren*JSR     GetSbl*MOVE.L  Header,A0*CMPI.W  #64,D3        ;QUALIFIED?*BNE     GlobExp4*MOVE.W  #1,2(A0)      ;qual.Flag*BRA     GlobExp2 !GlobExp4 CMPI.W  #76,D3        ;PERVASIVE?*BNE     GlobExp1*MOVE.W  #2,2(A0) !GlobExp2 JSR     GetSbl !GlobExp1 TST.W   D3*JSR     OLDID0*ADDQ.W  #1,XPCNT*JSR     GetSbl*CMPI.W  #10,D3        ;,*BEQ     GlobExp2*CMPI.W  #11,D3        ;;*BEQ     OK1*MOVE    #rSemXp,D5*JMP     SyntaxErr !OK1      JMP     GetSbl !GlobExp3 MOVE.W  #1,AllExp     ;wir wollen alles exportieren*MOVE.L  Header,A0*MOVE.W  #1,2(A0)      ; und zwar qualified'END END GlobExp;  (* *   ---------------------------------- *   Deklarationen des DefModuls uebersetzen: *      IDs in ID-Baum eintragen; *      Platz der deklarierten Var in Modul eintragen *   ---------------------------------- * *      D3 = 1. Symbol * *      (A0) * *      D3 := folgendes Symbol (muss END sein) *      VarSpc := Platzbedarf der deklarierten Variablen *) PROCEDURE Define; BEGIN ASSEMBLER)CLR.L   VARSPC !Define5 CMPI.W  #57,D3        ;CONST)BNE     Define1)JSR     CONSDEC)BRA     Define5 Define1  CMPI.W  #58,D3        ;TYPE)BNE     Define2)JSR     TYPEDEC)BRA     Define5 Define2  CMPI.W  #56,D3        ;VAR)BNE     Define3)JSR     VARDEC)BRA     Define5 Define3  CMPI.W  #59,D3        ;PROCEDURE)BNE     Define4)MOVE.L  VARSPC,-(A7))JSR     GetSbl)JSR     PRHEAD)JSR     CLRTRE        ;lokale Var etc loeschen)JSR     PULLID)SUBQ.W  #1,GLOBAL     ;hier kommt nix lokales)MOVE.L  (A7)+,VARSPC  ;Var-Adr der globalen Ebene)JSR     GetSbl)BRA     Define5 !Define4 MOVE.L  Header,A0)MOVE.L  VARSPC,18(A0) END END Define;  (* *   ---------------------------------- *   Struktur der Baumeintragungen *   ---------------------------------- * *   Kodierung:   ItemKennung {Komponente} 0 *   Komponenten: 1=Ptr (Item-Nr) 2=Const.L 3=Const.W 4=New_Scope 5=^ID (EnumTyp) *                6=Laengenangabe 7,n=Insert <n> Bytes, 8=^ID (EnumElem) *) PROCEDURE ITEMS; BEGIN ASSEMBLER); ACHTUNG:); Bei den Items 6, 17 und 50 _muû_ das 1. Feld (Adr.L) unbedingt); mit ins DEF-Modul hinein, wenn es dort auch nur unnîtig Platz); belegt. Also dort eine '2' statt '7,4' eintragen! Denn in IPIMP); wird in dieses Feld direkt ein Wert geschrieben, ohne daû dann); die Bytes reserviert wÑren, wenn ein Insert dort angegeben wÑre.)DC.B    0,1,0         ;Relay)DC.B    1,2,0         ;LINT)DC.B    2,2,0         ;LONGREAL)DC.B    3,2,0         ;CHAR)DC.B    4,2,0         ;ZZ)DC.B    5,2,1,0       ;SET)DC.B    6,2,1,1,2,7,8,0   ;PROC)DC.B    7,1,1,3,0     ;PARAM)DC.B    8,2,0         ;REDECLARABLE OPAQUE)DC.B    9,2,2,5,0     ;ENUM)DC.B    10,3,1,8,0    ;ENUM.ELEMENT)DC.B    11,2,2,2,1,0  ;SUBR)DC.B    12,2,1,1,0    ;ARRAY)DC.B    13,2,1,4,0    ;RECORD)DC.B    14,2,1,1,0    ;REC.FELD)DC.B    15,4,0        ;Lok.Module)DC.B    16,4,0        ;Qualifier bei importierten Modulen)DC.B    17,2,1,2,7,2,0;VAR)DC.B    18,1,6,0      ;CONST alt, ohne String-Literals (s. Nr.31))DC.B    19,2,1,1,0    ;PROC.TYPE)DC.B    20,2,1,0      ;PTR)DC.B    21,2,0        ;WORD)DC.B    22,2,0        ;LCARD)DC.B    23,2,1,0      ;ADDRESS)DC.B    24,2,0        ;BOOLEAN)DC.B    25,2,0        ;OPAQUE)DC.B    26,2,0        ;LONG)DC.B    27,2,2,0      ;STRING)DC.B    28,2,2,2,2,0  ;TABLE (nicht exportierbar))DC.B    29,2,2,2,3,0  ;Asm-Label (nicht exportierbar))DC.B    30,2,0        ;LBOTH?;31: String-Literal (alt))DC.B    32,1,0        ;OPEN ARRAY)DC.B    33,2,0        ;SINT)DC.B    34,2,0        ;SCARD)DC.B    35,2,0        ;SBOTH)DC.B    36,3,1,0      ;StandardProc)DC.B    37,1,1,1,0    ;StandardProcParams)DC.B    38,2,0        ;BYTE)DC.B    39,2,0        ;Signed BYTE)DC.B    40,2,0        ;REAL)DC.B    41,2,0        ;BITNUM)DC.B    42,1,0        ;OPEN LONGARRAY)DC.B    43,2,0        ;untyped/structured Constant)DC.B    44,2,1,0      ;PROC.TYPE bei Parametern (8 Byte LÑnge))DC.B    45,2,1,0      ;SET (neue Ordnung))DC.B    46,1,2,2,1,0  ;Record-Tag)DC.B    47,2,1,1,1,1,0;Rec-Variante)DC.B    48,0          ;Forward-Typ)DC.B    50,2,1,7,4,6,0 ;CONST neu (nun incl. String-Literals))DC.B    63,0          ;Dummy-Eintrag)DC.B    0)SYNC END END ITEMS;  (* *   ---------------------------------- *   Exportierte ID's im Baum markieren *   (nur benutzt, falls explizite Exportliste vorhanden ist!) *   ---------------------------------- * *      (D0-D3) * *      TOI = exportierte IDs *      xpcount = Anzahl der IDs auf Stack *) PROCEDURE MarkExp; BEGIN ASSEMBLER !ML      SUBQ.W  #1,XPCNT)BMI     MarkExp1       ;keine explizite Exportliste)JSR     PULLID)MOVE.L  A0,-(A7))JSR     SEARCHID       ;liefert in D1 Ptr auf ggf. Relay-Eintrag)MOVE.L  (A7)+,A0)TST.W   D3)BNE     OK11))MOVE    #rExpUn,D5 error    JSR     LoadBadID)JMP     SyntaxErr  !OK11    BMI     OK12  !ER71    MOVE    #rBdExp,D5)BRA     error  !OK12    BTST    #13,D3         ;Import?)BEQ     OK )MOVE    #rReExp,D5     ;ACHTUNG: auch "Type ID = importedType" wird)BRA     error          ; hier verboten, da das ImportFlag im imp.@; Eintrag gesehen wird!  !OK      BSET    #6,-2(A1,D1.L) ;als Exp markieren (ggf. in Relay-Eintrag))BNE     dblExp         ;wurde schon exportiert)(* Enum-Elems werden sowieso in CopInf berÅcksichtigt+CMPI.B  #9,-1(A1,D2.L) ;Enum?+BNE     ML+MOVE.L  -14(A1,D2.L),D2"MarkExp2 BSET    #6,-2(A1,D2.L) ;Element exportieren+BNE     dblExp         ;wurde schon exportiert+MOVE.L  -12(A1,D2.L),D2+BNE     MarkExp2)*))BRA     ML dblExp   MOVE    #rDblEx,D5     ;doppelter Export)BRA     error MarkExp1 END END MarkExp;  (* *   ---------------------------------- *   ItemNummer vergeben beim BaumPlaetten *   ---------------------------------- * *      D1 = ^Objekt im ID-Baum, das numeriert werden soll *      D5 = hoechste bisher vergebene Nr *      A3 = ^Array [ItemNr] of ID-Baum-Adr *      A5 = ^Array [ItemNr] of Eintrag-Status * *      D0 := vergebene ItemNr * *      Schluessel fuer Status-Array: *        0   fertig im PlaTree eingetragen *        2   Vorwaertsref, muss anonym eingetragen werden *        3   Vorwaertsref, muss nicht-anonym eingetragen werden *) PROCEDURE ItemNr; BEGIN ASSEMBLER)TST.L   D1)BEQ     ItemNr3      ;nil-Ptr: Sonderfall)MOVE.W  D5,D0)BEQ     ItemNr1      ;noch keine Nr vergeben)SUBQ.W  #1,D0)MOVE.L  A3,-(A7) !ItemNr2 CMP.L   (A3)+,D1     ;Item in bereits numerierten suchen)DBEQ    D0,ItemNr2)MOVE.L  (A7)+,A3)BNE     ItemNr1      ;nicht gefunden: neue vergeben)NEG.W   D0           ;gefunden)ADD.W   D5,D0)RTS !ItemNr1 ; MOVE.B  #1,0(A5,D5.W) ;als 'nicht im PlaTree' markieren)MOVE.B  #2,0(A5,D5.W) ;!!!)MOVE.W  D5,D0)LSL.W   #2,D0)MOVE.L  D1,0(A3,D0.W) ;in Adr-Liste eintragen)ADDQ.W  #1,D5)MOVE.W  D5,D0)RTS !ItemNr3 CLR.W   D0 END END ItemNr;  (* *   ---------------------------------- *   Geplaetteten Baum erstellen *   ---------------------------------- * *      A3: Array [ItemNr] of ID-Baum-Adressen  (EvalStkPtr wird gerettet) *      A5: Array [ItemNr] of boolean "Item ist eingetragen" *          (A5 liegt vor A3, wichtig fÅr PlatzprÅfung) * *      (D0-D7,A0) * *      A4 = ^wachsenden PlaTree *)  PROCEDURE PlaTre; BEGIN ASSEMBLER)MOVE.L  (A6),D2       ;globale ID-Baum Ebene)BEQ.L   PlaTre1       ; ist leer)MOVE.L  A4,D0         ;Abs. Adresse des gepl. Baums)MOVE.L  Header,A3       ;Code-Anfang)SUB.L   A3,D0         ;Offset zum gepl. Baum)MOVE.L  D0,8(A3)      ;^geplaetteten Baum))MOVE.L  A1,D0)ADD.L   TreSpc,D0)SUB.L   A4,D0         ;Platz zwischen Codeende und Baum)); fÅr jedes Item brauchen wir > 6 Byte im Code, 4 in der Liste der); Basisadressen, 1 in der Flag-Liste.); Wir vergeben D0/2, D0/8 * 3, D0/8. Dann lÑuft ggf. das Codefile); zuerst Åber, und wir mÅssen nur da den Platz prÅfen.))LSR.L   #1,D0)BCLR    #0,D0)LEA     0(A4,D0.L),A5 ;Flags 'eingetragen')LSR.L   #2,D0)BCLR    #0,D0)LEA     0(A5,D0.L),A3 ;Liste der BasisAdr))CLR.W   D5            ;ItemNr.-Zaehler)CLR.W   D4            ;nur exportierte IDs kopieren)JSR     PlaTre2       ;alle exportierten Items kopieren ); nun noch die benutzten, benamten & anonymen Eintraege kopieren )CLR.W   D7 !PlaTre8 ADDQ.W  #1,D7)CMP.W   D5,D7)BHI     PlaTre7)MOVE.B  -1(A5,D7.W),D0;schon eingetragen?)BEQ     PlaTre8       ; ja))CMPI.B  #3,D0         ;mit Namen (nicht-anonym) nachtragen?)BNE     anonym        ; nein))MOVE.W  D7,D0)LSL.W   #2,D0)MOVE.L  -4(A3,D0.W),D2 ;^ItemAdr im OriginalBaum)JSR     GetNameOfId    ;^Namen holen)TST.L   D4)BEQ     error          ;wenn EnumTyp benamt, mÅssen es die Elems auch))MOVE.W  D7,D0)BSET    #15,D0        ;als exportiert kennzeichnen)MOVE.W  D0,(A4)+      ;ItemNr -> PlaTree)MOVE.L  A4,A0         ;^naechsten Eintrag hier nachtragen)ADDQ.L  #2,A4         ;Platz f. ^next freimachen !PlaTre5 SUBQ.L  #1,D4)MOVE.B  0(A1,D4.L),(A4) ;Namen kopieren)CMPI.B  #$FE,(A4)+)BCS     PlaTre5        ;< $FE -> Id geht weiter)BTST    #0,D4          ;ungerade Adr?)BNE     PlaTre5        ; ja, Sync kopieren)BRA     cont  error    MOVE    #rEnuEx,D5     ;"Fehler bei Export von Enum-Elem")JMP     SyntaxErr  anonym   MOVE.W  D7,(A4)+      ;ItemNr -> PlaTree)MOVE.L  A4,A0         ;^naechsten Eintrag hier nachtragen)MOVE.L  #$FEFF,(A4)+  ;leerer Name -> PlaTree)MOVE.W  D7,D0)LSL.W   #2,D0)MOVE.L  -4(A3,D0.W),D2 ;^ItemAdr im OriginalBaum)MOVE    D7,D0  cont     JSR     CopInf        ;Beschreibung kopieren)CMPA.L  A4,A5         ;Beschreibung in Flagfeld gelaufen ?)BHI     PlaTre8 )MOVE    #rExpOv,D5    ;not enough room for Export)JMP     SyntaxErr  PlaTre7  CLR.W   (A4)+)MOVE.L  Header,A0)MOVE.W  D5,12(A0)    ;Anzahl exp. Items PlaTre1 END END PlaTre;  (*; ;   ---------------------------------- ;   ID-Baum durchsuchen und in PlaTree kopieren ;   ---------------------------------- ; ;       (D1,A0) ; ;       D2 = ^Baum-Wurzel ;       D4 = "auch nicht explizit exportierte IDs kopieren" ;       A4 = ^wachsenden PlaTree ;*) PROCEDURE PlaTre2; BEGIN ASSEMBLER*MOVE.L  D2,-(A7)*MOVE.L  -4(A1,D2.L),D2 ;linker Ast*BEQ     PlaTre3*JSR     PlaTre2 !PlaTre3  MOVE.L  (A7),D2*MOVE.L  -8(A1,D2.L),D2 ;rechter Ast*BEQ     PlaTre4*JSR     PlaTre2 !PlaTre4  MOVE.L  (A7)+,D2      ;Knoten bearbeiten *MOVE.L  A4,A0         ;hier ItemNr und ^next nachtragen*ADDQ.L  #4,A4*MOVE.W  D4,-(A7)      ;D4-Flag auf Stack retten*MOVE.L  D2,D4         ;Adr. der ID f. IDfromTree merken*SUBQ.L  #8,D2 !PlaTre5  SUBQ.L  #1,D2*MOVE.B  0(A1,D2.L),(A4) ;Namen kopieren*CMPI.B  #$FE,(A4)+*BCS     PlaTre5        ;< $FE -> Id geht weiter*BTST    #0,D2          ;ungerade Adr?*BNE     PlaTre5        ; ja, Sync kopieren*MOVE.W  -2(A1,D2.L),D0 *TST.W   (A7)*BNE     PlaTre12       ;alles kop. (auch Importe & nicht-Exportierte)*BTST    #13,D0         ;importierter ID?*BNE     PlaTre9        ; ja, nicht Åbernehmen*TST.W   AllExp         ;alles exportieren (keine Liste?)*BNE     PlaTre12       ; ja*BTST    #14,D0         ;In Exportliste?*BEQ     PlaTre9        ; nein, nicht Åbernehmen !PlaTre12*BCLR    #6,-2(A1,D2.L) ;ggf.Export-Flag lîschen*TST.B   D0             ;Relay?*BNE     noRel*MOVE.L  -6(A1,D2.L),D2 noRel     MOVE.L  D2,D1*JSR     ItemNr         ;ItemNr zuweisen*CLR.B   -1(A5,D0.W)    ;als fertig markieren  !PlaTre14 BSET    #15,D0         ;Als exportiert markieren !PlaTre13 MOVE.W  D0,(A0)+*JSR     CopInf         ;ID-Beschreibung kopieren*CMPA.L  A4,A5          ;Beschreibung in Flagfeld gelaufen ?*BLS     noRoom PlaTre1   MOVE    (A7)+,D4*RTS noRoom    MOVE    #rExpOv,D5    ;not enough room for Export*JMP     SyntaxErr !PlaTre9  MOVE    (A7)+,D4*MOVE.L  A0,A4          ;cancel begonnenen Eintrag END END PlaTre2;  (* *   ---------------------------------- *   Beschreibung eines Baumeintrags plaetten; *      nicht zustaendig fuer Kopieren des Namens! *   ---------------------------------- * *      (D0,D2-D4,A4) * *      D0 = eigene Item-Nr (fÅr Key-Berechnung & Export-Flag) *      D2 = rel. ^Beschreibung im ID-Baum *      A0 = Adr zum Nachtragen des ^next Item im PlaTree *      A4 = ^wachsenden PlaTree *      A3 = ^Array [ItemNr] of ID-Baum Adresse *) PROCEDURE CopInf; BEGIN ASSEMBLER)MOVE.L  A0,-(A7)      ;hier ^naechsten Eintrag nachtragen)MOVE    D0,-(A7)      ;Export-Flag merken)CMPA.L  A4,A3)BLS     ER98         ;kein Platz mehr fuer PlaTree)BRA     OK !ER98    MOVE    #rDefOv,D5)JMP     SyntaxErr );Modul-Key erstellen  !OK      MOVE.L  KEY,D3)EXT.L   D0)ADD.L   D0,D3          ;Key mitrechnen)ROL.L   #1,D3))SUBQ.L  #2,D2)MOVEQ   #0,D0)MOVE.W  0(A1,D2.L),D0  ;Kennung des Eintrags)MOVE.W  D0,(A4)+))ADD.L   D0,D3         ;Key mitrechnen)ROL.L   #1,D3))CMPI.B  #31,D0)BEQ.W   CopInf11     ;String Const geht mal wieder anders)LEA     ITEMS,A0      ;Liste mit Item-Beschreibung  CopInf3  CMP.B   (A0)+,D0)BEQ     CopInf1      ;gefunden CopInf2  TST.B   (A0)+        ;nicht gefunden: Ende des Eintrags suchen)BNE     CopInf2)TST.B   (A0)         ;Ende der Liste?)BNE     CopInf3      ; nein)JSR     IDfromTree)MOVE    #rBdExp,D5   ; ja, exp. Item ist nicht definiert)JMP     SyntaxErr  CopInf1  MOVE.B  (A0)+,D0     ;Beschreibung kopieren)BEQ.L   CopInf4      ;fertig)CMPI.B  #1,D0        ;Ptr?)BEQ     CopInf10)CMPI.B  #5,D0        ;^ID? (Enum-Typ auf -Elems), geht wie Ptr)BEQ     CopInf10)CMPI.B  #8,D0        ;^ID? (Enum-Elem-Kette), geht wie Ptr)BNE     CopInf5 ); Pointer und ID kopieren  CopInf10 MOVE.B  D0,-(A7))SUBQ.L  #4,D2)MOVE.L  0(A1,D2.L),D1)JSR     ItemNr)MOVE.W  D0,(A4)+)EXT.L   D0)ADD.L   D0,D3         ;Key mitrechnen)ROL.L   #1,D3)CMPI.B  #1,(A7)+      ;war es ^ID?)BEQ     CopInf1       ; nein, dann fertig)); Sonderbehandlung bei IDs (Enum-Elementen)))TST.B   -1(A5,D0.W)   ;war sie schon mit Namen eingetragen?)BEQ     CopInf1       ; ja: dann ists ja schîn.)TST.W   (A7)          ;Ist Enum-Typ als exportiert markiert?)BPL     CopInf1       ; nein, dann nur anonym nachtragen)MOVE.B  #3,-1(A5,D0.W); ja: zum nicht-anonymen Nachtragen markieren)BRA     CopInf1  CopInf5  CMPI.B  #2,D0         ;Const.L?)BNE     CopInf6)); Constant.Long kopieren))SUBQ.L  #4,D2)MOVE.L  0(A1,D2.L),D0)ADD.L   D0,D3         ;Key mitrechnen)ROL.L   #1,D3)MOVE.L  D0,(A4)+)BRA     CopInf1  CopInf6  CMPI.B  #3,D0         ;Const.W?)BNE     CopInf7)); Constant.Word kopieren))SUBQ.L  #2,D2)MOVEQ   #0,D0)MOVE.W  0(A1,D2.L),D0)ADD.L   D0,D3         ;Key mitrechnen)ROL.L   #1,D3)MOVE.W  D0,(A4)+)BRA     CopInf1  CopInf7  CMPI.B  #4,D0        ;Unterbaum?)BNE     CopInf13)); Unterbaum kopieren);); VORSICHT: Der Ptr auf den Unterbaum muû unmittelbar vor dem);  Baum stehen! Zwar wÅrde CopInf hier auch mit andern FÑllen);  klarkommen, beim Importieren wÅrde es dann aber schiefgehen,);  weil dort der Baum immer direkt nach seinem Ptr abgelegt wird!))SUBQ.L  #4,D2)MOVEM.L A0/D2,-(A7))MOVE.L  0(A1,D2.L),D2)BEQ     CopInf8      ;Unterbaum ist leer)MOVE.L  D4,-(A7))MOVEQ   #1,D4        ;auch Importe und nicht exportierte IDs kopieren)MOVE.L  D3,KEY)JSR     PlaTre2)MOVE.L  KEY,D3)MOVE.L  (A7)+,D4 CopInf8  CLR.W   (A4)+        ;Endmarke Unterbaum)MOVEM.L (A7)+,A0/D2)BRA     CopInf1)); Insert-Anweisung in der Items-Tabelle ist hier zu Åberspringen!  CopInf13 CMPI.B  #7,D0)BNE     CopInf15)MOVEQ   #0,D0)MOVE.B  (A0)+,D0)SUB.L   D0,D2)BRA     CopInf1)); Constant mit var. Laenge kopieren) CopInf15 SUBQ.L  #2,D2             ;muss Konst. mit variabler Laenge sein)MOVE.W  0(A1,D2.L),D0     ;Laengenangabe)MOVE.W  D0,(A4)+ CopInf14 MOVE.L  -4(A1,D2.L),D1    ;Key mitrechnen)ADD.L   D1,D3             ;Key mitrechnen)ROL.L   #1,D3)MOVE.L  D1,(A4)+          ;in Long-Portionen kopieren)SUBQ.L  #4,D2)SUBQ.W  #4,D0)BGT     CopInf14)BRA     CopInf1 ); alten String-Literal kopieren  CopInf11 CLR.W   D1              ;String-Konstante)MOVEQ   #0,D0)MOVE.B  -1(A1,D2.L),D1  ;Zeichenzahl CopInf12 SUBQ.L  #1,D2           ;String kopieren)MOVE.B  0(A1,D2.L),D0)MOVE.B  D0,(A4)+)ADD.L   D0,D3         ;Key mitrechnen)ROL.L   #1,D3)DBF     D1,CopInf12)MOVE.L  A4,D0          ; SYNC A4)LSR     #1,D0)BCC     CopInf4)CLR.B   (A4)+ ); Ende der Beschreibung des Items) CopInf4  ADDQ.L  #2,A7)MOVE.L  (A7)+,A0)MOVE.L  A4,D0)SUB.L   A0,D0)MOVE.W  D0,(A0)       ;rel. ^next nachtragen)MOVE.L  D3,Key"END END CopInf;  (* ››› *   ---------------------------------- *   Kopf der Importliste erstellen; *      jeweils fuer EIN Import-Statement *   ---------------------------------- * *      (D0) * *      A0 = ^importiertes DefModul *      A4 = ^anzulegende ImpListe *      TOI = Name des DefModuls, bleibt da! * *      ILstart := Startadr der Importliste *      ILEnd   := EndAdr der Importliste *) PROCEDURE SETILST; BEGIN ASSEMBLER)MOVE.L  A0,-(A7))MOVE.L  A4,ILSTART)MOVE.L  4(A0),(A4)+   ;Modul Key)MOVE.L  4(A0),CurrentKey)CMPI.W  #3,IPFLAG)BNE     SETILST0)MOVE.W  12(A0),(A4)+   ;bei Import in Def.Modul: Anz. Items)MOVE.W  #1,(A4)+       ;bei Defmods: Flag f. <Modulname vorhanden> SETILST0 ; Modulnamen in Importliste kopieren)JSR     LOOKID)MOVEQ   #modnamelen,D0 ;max. Char-Zahl SETILST1 MOVE.B  (A0)+,(A4)+   ;Namen kopieren)DBEQ    D0,SETILST1)SUBQ.L  #1,A4)MOVE.W  A4,D0)BTST    #0,D0         ;Sync)BNE     SETILST2)MOVE.B  #$FE,(A4)+ SETILST2 MOVE.B  #$FF,(A4)+    ;Endmarke SETILST4 MOVE.L  A4,ILEND)MOVE.L  (A7)+,A0 END END SETILST;  (*!*   ----------------------------------!*   Neubildliste fuer Import suchen / ggf. neu erstellen!*   ----------------------------------!*!*      (D0/D1)!*!*      A5 = ^Block der Neubildlisten!*      D3 = Key des gesuchten Moduls!*      D4 = Anzahl Items (fuer Neueintrag benoetigt)!*      D5 = StartAdr des DefMod, fÅr das die Liste angelegt wird!*           (fÅr PlatzprÅfung)!*!*      A3 := ^Anfang der Neubildliste!*      Zero-Flag := 'ok - kein Ueberlauf'!*)  FORWARD Pseudo; FORWARD SysMod; FORWARD SysModEnd;  PROCEDURE Neubild; BEGIN ASSEMBLER*CLR.L   D0 Neubild1  MOVE.L  0(A5,D0.L),D1  ;bestehende Liste durchsuchen: Key*BEQ     Neubild2      ;kein Modul mehr da*CMP.L   D3,D1         ; = Key des geladenen Moduls?*BEQ     Neubild3*ADD.L   4(A5,D0.L),D0 ;^naechstes Modul*BRA     Neubild1 Neubild2  MOVE.L  D3,0(A5,D0.L)  ;neue Liste: Key eintragen*MOVE.W  D4,D2         ;Anzahl Items*MULU    #6,D4         ;benoetigter Platz*ADD.L   #14,D4        ;Offset fuer Key/^next/items/dummy0*MOVE.L  D4,4(A5,D0.L)*;MOVE.W  D2,8(A5,D0.L)*LEA     08(A5,D0.L),A3*MOVE.L  A3,D1         ;^Anfang der Liste merken*MOVEQ   #0,D0 Neubild4  MOVE.W  D0,(A3)+      ;alle Items undefiniert*MOVE.L  D0,(A3)+*DBF     D2,Neubild4*CLR.L   (A3)+         ;Endmarke*CMP.L   #SysModEnd,D5*BHI     Neubild6      ;hinter SysMod: Platzpruefung notwendig*CMP.L   #Pseudo,D5*BCC     Neubild5      ;in System oder Pseudo: keine Platzprobleme Neubild6  CMP.L   A3,D5         ;sonst pruefen:*BLS     ImpOv         ;A3 >= Adr des geladenen Moduls: Ueberlauf Neubild5  MOVEA.L D1,A3         ;^neue Liste -> A3*CLR.W   D0            ;setze Zero-Flag als Erfolgsmeldung*RTS ImpOv     MOVEQ   #1,D0         ;Fehler signalisieren*RTS Neubild3  LEA     08(A5,D0.L),A3 ;^bestehende Liste -> A3@;zurueck mit Zero-Flag = 1 END END Neubild;  (* ››› *   ---------------------------------- *   Neubildlisten fuer Importe eines DefModuls anlegen; *      in der eigenen NeubildListe CrossRef-Verweise *      auf die Ursprungs-Module eintragen *   ---------------------------------- * *      (A2: ZW fuer ^eigene Neubildliste <A3>, D0-D4) * *      A0 = ^importierendes DefModul *      A3 = ^dessen Neubildliste *) PROCEDURE CrosRef; BEGIN ASSEMBLER)MOVEM.L A0/A2/A3,-(A7))MOVE.L  A3,A2)MOVE.L  A0,D5         ;fÅr Platzcheck in Neubild)ADDA.L  14(A0),A0     ;^ImportListe CrosRef1 MOVE.L  (A0)+,D3      ;Key)BEQ     CrosRef2      ; Ende der ImportListe)MOVE.W  (A0)+,D4      ;Anzahl Items)BEQ     CrosRef2      ; nix)JSR     Neubild       ;Liste suchen/anlegen)BEQ     CrosRef3      ;alles ok))MOVEM.L (A7)+,A0/A2/A3)MOVE    #rImpOv,D5    ;Fehler in Neubild: waechst in geladenes Modul!)JMP     SyntaxErr  CrosRef3 ; MOVE.W  (A0)+,D0); CMP.B   #$FE,D0       ;Modulnamen bis zur Endmarke ueberspringen); BCS     CrosRef3  CrosRef4 MOVE.W  (A0)+,D0      ;fremde ItemNr)BEQ     CrosRef1      ; Ende dieses Imports)BCLR    #15,D0        ;Var/Proc-Flag in alten Compiler-Versionen)MOVE.W  (A0)+,D1      ;eigene ItemNr)BEQ     CrosRef4      ; ist gar nicht vergeben)MULU    #6,D1)MULU    #6,D0)ADD.L   A3,D0         ;^Neubild im UrsprungsModul)CMPI.L  #$FFFF,D1     ;prÅfen wg. (An,D1.W))BLS     ok2)TRAP    #6)DC.W    -101          ;um internen Fehler zu melden%ok2 MOVE.W  #4,0(A2,D1.L)  ;im importierenden Modul als CrossRef markieren)MOVE.L  D0,2(A2,D1.L) ;und ^Ursprung eintragen)BRA     CrosRef4 CrosRef2 MOVEM.L (A7)+,A0/A2/A3  END END CrosRef;  (*!*   ----------------------------------!*   Definitions-Modul laden, Format pruefen!*   ----------------------------------!*!*     (D0-D5)!*!*     TOI = Modulname, bleibt da!!*     A4+$6000 = Lade-Adresse!*!*     A0 := StartAdr des Moduls!*     Zero-Flag := "Modul gefunden"!*!*     LOADDEF jetzt im CompIO Modul!*)  (*!*   ----------------------------------!*   Definitions-Modul laden & vorbereiten (fuer normalen Import):!*      Importliste erzeugen,!*      eigene Neubildliste und CrossRefs anlegen!*   ----------------------------------!*!*      (D0-D5)!*!*      TOI = Modulname, bleibt da!!*      A4 = ^erzeugten Code!*!*      A0 := ^DefModul!*      A3 := ^Neubildliste des DefModul!*      Zero-Flag := "DefMod gefunden"!*)  PROCEDURE SetDef; BEGIN ASSEMBLER)MOVEM.L A2/D3,-(A7))MOVE.W  OLDSBL,-(A7))LEA     SysName(pc),A2   ;TextPointer auf 'SYSTEM' stellen)MOVE.W  #1,NoReload  ;Reload verhindern)JSR     OldId)CLR.W   NoReload)MOVE.W  (A7)+,OLDSBL)MOVEM.L (A7)+,A2/D3)MOVE.L  A5,-(A7))JSR     CheckId       ;ist 'System' auf dem Stack?)MOVE.L  (A7)+,A5)BNE     normLoad)LEA     SysMod,A0)BRA     cont normLoad JSR     LOADDEF       ;DefModul laden, Adr in A0)BNE     SetDef1       ;not avail. cont     JMP     SetDef0 SysName  ACZ     'SYSTEM')SYNC SetDef1 END END SetDef;  PROCEDURE SetDef0; BEGIN ASSEMBLER); === Einsprung ImPseud)MOVE.L  A0,CurrentDef ;Adr des bearbeiteten DefMod)JSR     SETILST       ;ImpListe auf (A4)...)MOVE.L  4(A0),D3      ;Key des geladenen Moduls)MOVE.W  12(A0),D4     ;Anzahl der dekl. Items)SUBA.L  A3,A3         ;Neubildliste erstmal auf NIL)BEQ     SetDef1       ; keine)); glob. Flag setzen, ob Real-Consts umgewandelt werden mÅssen)CLR     mustChgFormat  ;defaultwert)CLR     D1)MOVE.B  1(A0),D1       ;EnthÑlt Modul Real-Consts?)ANDI.B  #$60,D1)LSR     #5,D1)BEQ     noChg          ;NEIN)LSR     #1,D1          ;D1 enth. Format der Reals im Def-Mod)MOVE    UseFormat,D0)CMPI    #3,D0)BCS     retUse)MOVE    SysFormat,D0'retUse                   ;D0 enth. nun Ziel-Format)TST     D0)SNE     D0)ANDI    #1,D0)CMP     D0,D1)BEQ     noChg)MOVE    #1,mustChgFormat)MOVE    D1,defFormat'noChg))MOVE.L  A0,D5         ;fÅr PlatzprÅfung)JSR     Neubild       ;Neubildliste suchen/anlegen)BEQ     ok)MOVE    #rImpOv,D5    ;Fehler in Neubild: waechst in geladenes Modul!)JMP     SyntaxErr ok       JSR     CrosRef       ;Neubildlisten fuer Importe dieses DefMod)CLR.W   D0 SetDef1 END END SetDef0;  (* *   ---------------------------------- *   Importlisten vorbereiten fuer gesamten Import-Teil, *       Platzverteilung bestimmen: *   ---------------------------------- * *      A5 := ^Block der Neubild-Listen * *      vorlÑufige Verteilung des Platzes: *       je 1/8 fÅr Code (Imp.Listen), Neubildlisten, DefModul, 5/8 fÅr Tree *) PROCEDURE INITIMP; BEGIN ASSEMBLER)MOVE.L  A1,D0)ADD.L   TreSpc,D0     ;Untergrenze des Baums)SUB.L   A4,D0         ;Platz zw. Code und Baum)LSR.L   #3,D0)BCLR    #0,D0))LEA     0(A4,D0.L),A5 ;^Neubild-Listen)CLR.L   (A5)          ;Endmarke))ADD.L   A5,D0)MOVE.L  D0,DAdr       ;dahin DefModul laden (fÅr LoadDef) END END INITIMP;   (*!*   ----------------------------------!*      Pseudomodul importieren:!*      Standardtypen in ID-Baum und TypListe eintragen;!*      wenn G+ gesetzt, auch SystemModul importieren!*   ----------------------------------!*!*      (A0,A3,D0-D4)!*) PROCEDURE ImPseud; BEGIN ASSEMBLER); Leernamen auf ID-Stack)MOVE.L  A2,-(A7))LEA     empty(PC),A2)JSR     PushID)MOVE.L  (A7)+,A2))MOVE.W  D3,-(A7))MOVE.L  Options,D0)BTST    #7,D0        ;Gepard-Standard?)BEQ     noGep        ;noe)LEA     SysMod,A0    ;*** Systemmodul pervasive importieren:)JSR     SetDef0      ;Neubildliste eintragen)MOVE.W  #$FFFF,PERVIMP)JSR     ImpAll       ;Import pervasive noGep    LEA     Pseudo,A0    ;*** PseudoModul pervasive importieren:)JSR     SetDef0      ;Neubildliste eintragen)MOVE.W  #$FFFF,PERVIMP)JSR     ImpAll       ;Import pervasive)LEA     INTPTR,A0)ADDQ.L  #6,A3)MOVEQ   #18,D0        ;Anzahl der Std-Types minus Eins ImPseud1 ADDQ.L  #2,A3)MOVE.L  (A3)+,(A0)+   ;^Standard-Typen kopieren)DBF     D0,ImPseud1)MOVE.L  SSTyp,StrPtr)MOVE.W  (A7)+,D3)JMP     MyPullID      ;Name wieder von Stack holen empty:   DC.W    0 END END ImPseud;  (*!*   ----------------------------------!*   Baumeintragungen und Importlisten anlegen!*   ----------------------------------!*) PROCEDURE InitImports;"BEGIN$ASSEMBLER(JSR     INITIMP       ;Neubildlisten vorbereiten(MOVE.L  A4,D0         ;bei Pgm/DefMod:(MOVE.L  Header,A0(SUB.L   A0,D0(MOVE.L  D0,14(A0)    ;^ImportListe anlegen(JSR     ImPseud(; Nun sind CardRel/IntRel init. -> $I-Option kann ausgewertet werden:(JSR     validateOpts$END"END InitImports;  (* *   ---------------------------------- *   Import-Statements uebersetzen *   ---------------------------------- * *     (D0-D5,A0) * *     D3 = 1. Symbol (IMPORT/FROM, falls vorhanden) * *     D3 := Symbol nach ';' *     A3 := Platzbedarf der imp. Variablen * * Um die Probleme mit Enums zu lîsen, wird nun wie folgt vorgegangen: * (TT 22.10.90) * *  1. Wenn alles importiert wird (also ohne FROM, Åber 'ImpAll'), werden *     ja auch alle vorhandenen IDs durchgegangen, sodaû auch die Enum-Elems *     in der "Importliste" vorkommen. Daher ist es dann egal, ob die *     Enum-Elems anonym oder benamt nachgefordert werden, wenn der Typ *     zuerst dran kommt: Irgendwann kommen die Elems nach und werden mit *     Namen nachgetragen. Daher wÑre der Wert in "anonFlag" bei 'ImpAll' egal. *     Damit es aber erst gar nicht bei Import von Strukturen, die wiederum *     Enum-Typen aus anderen Modulen benutzen, evtl. zu benamten Importen *     kommt, ist "anonFlag" generell 2 (anonyme Eintragung von Enum-Elems). *  2. Wenn einzeln Åber FROM importiert wird, ist eine Unterscheidung zw. *     Enum-Typ und -Elem zu treffen: Wird ein Enum-Typ importiert, mÅssen *     die Namen der Elems unbedingt nachgefordert werden (Kennung 7 bei *     ItemAdr). Wird ein Enum-Elem importiert, mÅssen dagegen die Verweise *     auf die ggf. weiteren Elems anonym nachgetragen werden. *  Die Var 'explicitImport' wird bei FROM ... IMPORT auf TRUE gesetzt, *  um den 2. Fall zu erkennen (in ImpItm16 und ScanItm). *  Die Kennung 3 in der Neubildliste kommt nur noch bei Enum-Elems vor, bei *  denen der Enum-Typ mit FROM importiert wurde. So werden mit dieser Kennung *  praktisch explizite FROM-Importe der Elems simuliert. Wenn diese Kennung 3 *  mit einem weiteren expliziten Import kollidiert, ist dies ein Fehler wg. *  Doppel-Imports eines Enum-Elems. *)  PROCEDURE GlobImp; BEGIN ASSEMBLER)JSR     InitImports)CMPI.W  #3,IPFLAG     ;DefMod?)BEQ     GlobImp6)MOVE.L  OPTIONS,D1)BTST    #14,D1)BNE     GlobImp6)JSR     Runtime       ; weder noch: Runtime importieren GlobImp6 CMPI.W  #69,D3        ;IMPORT?)BNE     GlobImp7 GlobImp5 JSR     GETID         ;* IMPORT modulname *)JSR     SetDef        ;DefModul laden & vorbereiten)BEQ     OK)MOVE    #rNoDef,D5         ;nicht gefunden)JMP     SyntaxErr !OK      MOVE.W  2(A0),D1)CMPI.W  #1,D1         ;ist Export qualified?)BNE     GlobImp2)JSR     ImpQual       ; ja)BRA     GlobImp3 GlobImp2 CMPI.W  #2,D1         ;ist Export pervasive?)BNE     GlobImp4)JSR     ImpPer        ; ja)BRA     GlobImp3 GlobImp4 JSR     ImpGlob       ;unqualified Export GlobImp3 JSR     GetSbl)CMPI.W  #10,D3        ;',' ?)BEQ     GlobImp5      ;weitere ModulNamen)CMPI.W  #11,D3)BEQ     OK1)MOVE    #rSemXp,D5          ;muss ';' folgen)JMP     SyntaxErr !OK1     JSR     GetSbl)BRA     GlobImp6 GlobImp7 CMPI.W  #68,D3        ;FROM?)BNE.W   GlobImp1)JSR     OLDID         ;* FROM modulname IMPORT *)JSR     GetSbl)CMPI.W  #69,D3        ;IMPORT?)BEQ     OK2)MOVE    #rImpXp,D5         ; muss folgen)JMP     SyntaxErr !OK2     JSR     SetDef        ;laden & vorbereiten)BEQ     OK10)MOVE    #rNoDef,D5         ;nicht gefunden)JMP     SyntaxErr !OK10    JSR     MyPullId)CLR.W   PERVIMP GlobImp8 JSR     FromImp       ;einen ID importieren)MOVE.L  A0,-(A7))JSR     GetSbl)MOVE.L  (A7)+,A0)CMPI.W  #10,D3        ;,)BEQ     GlobImp8      ;weitere IDs)CMPI.W  #11,D3        ;;)BEQ     OK3)MOVE    #rSemXp,D5)JMP     SyntaxErr !OK3     MOVE.L  A0,-(A7))ADDA.L  8(A0),A0)JSR     ImpRest       ;Refs auf anonym benutzte Items nachtragen)JSR     CloseImp      ;ImpListe: wenn leer: loeschen, sonst Endmarke)MOVE.L  (A7)+,A0)JSR     ImpXRef)JSR     GetSbl)BRA     GlobImp6 GlobImp1 CLR.L   (A4)+         ;Endmarke ImportListen)CMPI.W  #2,IPFLAG     ;Impl.Mod?)BNE     L1)JMP     OwnDef        ;eigenes DefModul laden !L1      CLR.L   VARSPC        ;kein verbrauchter Var-Platz END END GlobImp;  (*$----------------------------------$Import Runtime (pervasive) $prÅft nebenbei die Seriennummern, die auf dem IntegerStack stehen.$Im Fall eines Fehlers wird die Item-Tabelle zerschossen.$---------------------------------- ((D0-D2,D4,D5,A0) *) PROCEDURE Runtime; BEGIN ASSEMBLER)MOVE.W  D3,-(A7))MOVE.W  OLDSBL,-(A7))JSR     PullInt         ;schon mal eine Seriennummer holen)MOVE.W  D0,-(A7))MOVE.L  A2,-(A7))LEA     rtName(pc),A2   ;TextPointer auf 'Runtime' stellen)MOVE.W  #1,NoReload     ;Reload verhindern)JSR     GETID)CLR.W   NoReload)MOVE.L  (A7)+,A2)JSR     LOADDEF     ;Laden, vorbereiten)BEQ     OK)MOVE    #rRuDef,D5      ;Runtime Mod not found)JMP     SyntaxErr rtName   ACZ     'Runtime')SYNC OK       JSR     SetDef0)JSR     ImpPer      ;pervasive importieren)); PrÅfung der Seriennummer))JSR     PullInt     ;das ist die Original-Seriennummer)MOVE    #SerCnt2,D1 lp       BTST    #3,D0       ;17 bit Schieberegister, rechtsrum)BEQ     noChng      ;bit17 (i+1) := bit0 (i) EOR bit3 (i))BCHG    #0,D0 noChng   ASR.L   #1,D0)BCC     zero)BSET    #16,D0 zero     DBF     D1,lp)ADDI.W  #SerOffset2,D0)CMP.W   (A7)+,D0)BEQ     SerOk)LEA     Items,A0)SUBQ.B  #2,3(A0) SerOk    MOVE.W  (A7)+,OLDSBL)MOVE.W  (A7)+,D3 END END Runtime;  (* *   ---------------------------------- *   PullID, ohne A0 zu stoeren *   ---------------------------------- * *      (D0) *) PROCEDURE MyPullId; BEGIN ASSEMBLER)MOVE.L  A0,-(A7))JSR     PULLID)MOVE.L  (A7)+,A0 END END MyPullId;  (* *   ---------------------------------- *   Import eines ID's nach FROM .. IMPORT *   ---------------------------------- * *      (D0-D3) * *      A0 = ^DefModul *      A2 = ^Id im Programmtext * *      A2 := ^hinter Id im Text *)  PROCEDURE FromImp; BEGIN ASSEMBLER*MOVE    #1,explicitImport*MOVE.L  A5,-(A7)*MOVE.L  A0,-(A7)*JSR     GETID         ;Id aus Text holen*JSR     PULLID*MOVE.L  A0,A5         ;^Id*MOVE.L  (A7),A0*MOVE.L  8(A0),D0      ;Offset auf PlaTree*BNE     OK!!ER86    MOVE    #rNoExp,D5         ;keiner da -> ID nicht im DefMod*JMP     SyntaxErr!!OK      MOVE.L  OPTIONS,D2*ADDA.L  D0,A0 !FromImp1 MOVE.W  (A0)+,D5      ;ItemNr*BEQ     ER86         ;Ende des PlaTree -> ID nicht im DefMod*BPL     FromImp2      ;dieses Item ist nicht exportiert*CLR.W   D0 !FromImp3 MOVE.B  0(A5,D0.W),D1  ;Namen vergleichen:*BEQ     FromImp4      ;Ende des Id im Text*MOVE.B  2(A0,D0.W),D3*EOR.B   D3,D1*BEQ     FromImp5*BTST    #3,D2         ;Case Sensitive ?*BNE     FromImp2      ; ja*AND.B   #$DF,D1*BNE     FromImp2 !FromImp5 ADDQ.W  #1,D0*BRA     FromImp3 !FromImp2 ADDA.W  (A0),A0       ;Item ueberspringen*BRA     FromImp1 !FromImp4 CMPI.B  #$FE,2(A0,D0.W)    ;Ende auch im PlaTree?*BCS     FromImp2      ; nein, passt nicht*MOVE.W  #7,anonFlag*JSR     ImpItm20      ; ja, importieren*MOVE.L  (A7)+,A0*MOVE.L  (A7)+,A5 END END FromImp;  (* *   ---------------------------------- *   Importiere komplettes Modul qualifiziert *   ---------------------------------- * *      (A0,D0-D7) * *      A0 = ^geladenes DefModul *      TOI = DefModulname *) PROCEDURE ImpQual; BEGIN ASSEMBLER)MOVE.L  A0,-(A7))JSR     PULLID        ;Mod.Name)JSR     SETID)MOVE.W  #$A010,-2(A1,D6.L) ;als Qualifier eintragen (importiert!!))SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)MOVE.L  (A7)+,A0)MOVE.L  D6,-(A7)      ;hier ^lokalen Baum nachtragen)CLR.L   -(A6)         ;neues Scope)CLR.W   PERVIMP       ;nicht pervasive)JSR     ImpAll        ;ganzes Modul importieren)MOVE.L  (A7)+,D6)MOVE.L  (A6)+,0(A1,D6.L) ;^lok.Baum nachtragen END END ImpQual;  (* *   ---------------------------------- *   Importiere komplettes Modul, nicht qualifiziert *   ---------------------------------- * *      (A0,D0-D7) * *      A0 = ^DefModul *      TOI = DefModulname *) PROCEDURE ImpGlob; BEGIN ASSEMBLER)CLR.W   PERVIMP       ;nicht pervasive)JSR     MyPullId      ;Modulname nicht benoetigt)JSR     ImpAll        ;alles importieren END END ImpGlob;) (* *   ---------------------------------- *   Importiere komplettes Modul, pervasive *   ---------------------------------- * *      (A0,D0-D7) * *      A0 = ^DefModul *      TOI = DefModulname *) PROCEDURE ImpPer; BEGIN ASSEMBLER)CMPI.W  #3,IPFLAG     ;Import in DefMod?)BNE     OK)MOVE    #rPerva,D5         ; nicht erlaubt)JMP     SyntaxErr !OK      MOVE.W  #$FFFF,PERVIMP)JSR     MyPullId      ;Name nicht benoetigt)JSR     ImpAll        ;alles importieren END END ImpPer;  (* *   ---------------------------------- *   Kompletten PlaTree importieren *      in ID-Baum kopieren und Importliste anlegen *   ---------------------------------- * *      (D0-D7,A0) * *      A0 = ^DefMod *      pervimp = Flag "im pervasive Level eintragen" *)  PROCEDURE ImpAll; BEGIN ASSEMBLER)CLR     explicitImport)MOVE.L  A0,-(A7))MOVE.L  8(A0),D0      ;Offset bis PlaTree)BEQ     ImpAll1       ;gar keiner da)ADDA.L  D0,A0)MOVE.L  A0,-(A7) ImpAll2  MOVE.W  #2,anonFlag)JSR     ImpItm        ;A0=^ItemNr)TST.W   (A0))BNE     ImpAll2       ;PlaTree geht weiter)MOVE.L  (A7)+,A0)JSR     ImpRest       ;VorwaertsRefs nachtragen ImpAll1  JSR     CloseImp      ;falls ImpListe leer, loeschen; sonst Endmarke)MOVE.L  (A7)+,A0)JSR     ImpXRef END END ImpAll;  (* *   ---------------------------------- *   Anonym benutzte Items in ID-Baum uebernehmen; *      Vorwaerts-Referenzen darauf nachtragen *   ---------------------------------- * *      (D0-D7,A0) * *      A0 = ^PlaTree *) PROCEDURE ImpRest; BEGIN ASSEMBLER)CLR     explicitImport IMPLOOP  MOVEM.L A0/A2,-(A7))CLR.W   D7 ImpRest5 MOVE.W  (A0)+,D5      ;ItemNr aus PlaTree)BEQ.W   ImpRest2      ; Ende)BCLR    #15,D5        ;Export-Flag uninteressant)MOVE.W  D5,D0)MULU    #6,D0)LEA     0(A3,D0.W),A2  ;Adr in NeubildListe ImpRest0 CMPI.W  #4,(A2)       ;CrossRef?)BNE     ImpRest7)MOVE.L  2(A2),A2      ; ja, im UrsprungsMod nachsehen)BRA     ImpRest0 ImpRest7 CMPI.W  #2,(A2)       ;VorwaertsRef drauf?)BEQ     ImpRest1)CMPI.W  #3,(A2)       ;nicht anon. Vorwaertsref (Enum-Element) ?)BEQ     ImpRest6)CMPI.W  #5,(A2)       ;Eintrag fertig, aber Name nachzuholen?)BEQ     ImpRest6      ; Namen setzen, fertiger Eintrag wird bemerkt)TST.W   (A2))BEQ     ImpRest8)ADDA.W  (A0),A0       ;nichts zu tun)BRA     ImpRest5) ImpRest8 LEA     0(A3,D0.W),A2  ;Adr in NeubildListe)ADDA.W  (A0),A0       ;nichts zu tun)BRA     ImpRest5)); Items mit anonymer Vorw.Ref nachbehandeln) ImpRest1 BSR.L   ImpRest3      ;VorwRef: Referenzen nachtragen)MOVEQ   #1,D7)BRA     ImpRest5)); Items nachbehandeln, die mit Namen bekannt werden dÅrfen);  (anonyme Typbeschreibung KANN vorliegen)) ImpRest6 MOVE.W  #7,anonFlag)JSR     ImpItm20      ;nicht-anon. VorwRef: in ID-Baum; Refs nachtr.)MOVEQ   #1,D7         ; markiere erfolgten Eintrag)BRA     ImpRest5  ImpRest2 MOVEM.L (A7)+,A0/A2   ;PlaTree durch)TST.W   D7            ;evtl. weitere VorwRefs entstanden?)BNE     IMPLOOP       ; ja, nochmal durch)RTS)); anonymen Eintrag nachholen (bei anon. VorwaertsRefs)) ImpRest3 MOVE.W  (A0)+,D0      ;^next weg ImpRest4 MOVE.W  (A0)+,D0      ;Namen weg)CMP.B   #$FE,D0)BCS     ImpRest4)MOVE.W  #2,anonFlag   ;auch verwiesene Eintraege bleiben anonym)MOVE.L  TRESPC,D6)MOVEQ   #1,D1         ;anonymer Eintrag geplant)JSR     ListImp       ;schon da?)JMP     ImpItm30 END END ImpRest;  (* *   ---------------------------------- *   Importliste abschliessen; *      Gepard-CodeGen: loeschen falls leer *   ---------------------------------- * *      A4 = ^Ende der fertigen Importliste *) PROCEDURE CloseImp; BEGIN ASSEMBLER)CMPA.L  ILEND,A4      ;ILEnd zeigt hinter Kopf der ImpList)BHI     CLIMP1 (*$ ? Atari:)MOVE.L  A0,-(A7))MOVE.L  ILSTART,A0)CMPI.L  #PseudoKey,(A0) ;war Pseudomodul importiert ?)BEQ     CLIMP2)CMPI.L  #SystemKey,(A0) ;war Systemmodul importiert ? CLIMP2   MOVE.L  (A7)+,A0)BNE     CLIMP1        ;wenn nicht, dann Importliste immer stehenl. *))MOVE.L  ILSTART,A4    ;keine Eintraege; Liste weg)RTS CLIMP1   CLR.W   (A4)+         ;Endmarke END END CloseImp;  (* *   ---------------------------------- *   Implizite Importe bei IMP-Modulen nachholen. *   ---------------------------------- * *   Die Module der impliziten Importliste werden in die Importliste *   Åbernommen und dann ihre Neubildlisten geprÅft und die dort noch *   undefinierten Items in die Importliste nachgetragen. * *      (D0-D7,A0) * *      A0 = ^DefMod *      A3 = ^Neubildliste des bearbeiteten Defmods *      A5 = ^Block der Neubildlisten *) PROCEDURE ImpXref; BEGIN ASSEMBLER)MOVE.L  A3,-(A7))CMPI.B  #6,(A0)       ;Dlayout)BCS.W   noimports     ; altes Layout)MOVE.L  30(A0),D0)BEQ.W   noimports     ; keine abhÑngigen Module)ADDA.L  D0,A0  IMPLOOP  MOVE.L  (A0)+,D3      ;Key)BEQ.W   noimports     ; keine abhÑngigen Module)MOVE.L  A4,ILSTART)MOVE.L  D3,(A4)+      ;Key in Importliste eintragen); Modulnamen in Importliste kopieren SETILST1 MOVE.W  (A0)+,D0      ;Modulname aus impliziter Importliste kopieren)MOVE.W  D0,(A4)+)CMP.B   #$FE,D0)BCS     SETILST1)MOVE.L  A4,ILEND)); Neubildliste zum Modul suchen)CLR.L   D0 Neubild1 MOVE.L  0(A5,D0.L),D1 ;bestehende Liste durchsuchen: Key)BEQ     Neubild2      ;kein Modul mehr da)CMP.L   D3,D1         ; = Key des geladenen Moduls?)BEQ     Neubild3)ADD.L   4(A5,D0.L),D0 ;^naechstes Modul)BRA     Neubild1 Neubild2                       ;dÅrfte nicht vorkommen)TRAP    #6)DC.W    -111          ;um internen Fehler zu melden)BRA     Neubild2) Neubild3 LEA     08(A5,D0.L),A3 ;^bestehende Liste -> A3 ); Schleife: in Neubild nach undefinierten Items suchen)MOVE.L  4(A5,D0.L),D5)SUBI.L  #14,D5)DIVU    #6,D5         ;Anzahl Items)BRA     next itemloop MOVE    D5,D0         ;Itemnr.)MULU    #6,D0)TST.W   0(A3,D0.W)    ;nachzutragen?)BPL     next))ANDI.W  #$FF,0(A3,D0.W) ;->ist nachgetragen)MOVE    D5,(A4)+)MOVE.L  A0,-(A7))MOVE.L  Header,A0)MOVE.L  A4,D1)SUB.L   A0,D1)SUB.L   14(A0),D1     ;rel. ^Importlisten-Eintrag)MOVE.L  2(A3,D0.W),D0 ;^Item in Tree)MOVE.L  D1,-6(A1,D0.L);  im Baum ueber Adr-Eintrag mogeln)MOVE.L  (A7)+,A0)CLR.L   (A4)+         ;hier ^letzte Ref nachtragen (durch FinImp)) next     DBRA    D5,itemloop )CLR.W   (A4)+         ;Endmarke des Moduls)BRA     IMPLOOP       ;und nÑchstes Modul...  noimports:);prÅfen, ob alle impliziten Importe aufgelîst wurden)MOVE.L  (A7)+,A3      ;Neubildliste des importierten Moduls)MOVE.L  A3,D0)BEQ     nobild        ;DefMod hat keine exportierten Items)MOVE.L  -4(A3),D5)SUBI.L  #14,D5)DIVU    #6,D5         ;Anzahl Items)BRA     st2 lup2     MOVE    D5,D0         ;Itemnr.)MULU    #6,D0)LEA     0(A3,D0.W),A0 lup3     CMPI    #4,(A0)       ;Crossref?)BNE     st3)MOVE.L  2(A0),A0)BRA     lup3 st3      TST     (A0))BPL     st2);Fehler: es ist was Åbriggeblieben)TRAP    #6)DC.W    -112          ;um internen Fehler zu melden st2      DBRA    D5,lup2 nobild: END END ImpXref;   PROCEDURE ImportedTwice;"BEGIN$ASSEMBLER)JSR     GetNameOfId    ;^Namen holen)TST.L   D4)BEQ     error          ;wenn EnumTyp benamt, mÅssen es die Elems auch)ADDQ.L  #8,D4)JSR     IDFromTree)MOVE    #rId2Im,D5     ;Enum-Elem doppelt importiert)JMP     SyntaxErr error    MOVE    #rEnuIm,D5     ;"Fehler bei Import von Enum-Elem")JMP     SyntaxErr$END;"END ImportedTwice;  (* *   ---------------------------------- *   Adresse eines neuen Items registrieren; *      kann auch bereits eingetragen sein (erst anonym, spaeter mit Namen). *      Evtl. vorhandene VorwRefs aufloesen *   ---------------------------------- * *      (D0-D2) * *      D5 = ItemNr *      D6 = Adresse im ID-Baum *      A0 = ^Item-Beschreibung *      A3 = zustaendige NeubildListe *      D1 = einzutragende Kennung (1 oder 6) *           (wenn 1 Åbergeben und bisher 3 eingetragen, entsteht 5) *           (wenn 1 Åbergeben und bisher 6 eingetragen, bleibt 6) *           (wenn 1 Åbergeben und bisher 5 eingetragen, bleibt 5) *           (wenn 6 Åbergeben und bisher 3,5,6 eingetr., kommt Fehler) * *      ZeroFlag := "Item ist noch nicht im Baum" *      D1 := Adresse, falls schon im Baum * *      Kennung: 0=keine Referenz *               1=definiert, anonym, Adr enthaelt TreePtr *               2=VorwaertsRef anonym, Adr enthaelt ^letzte Ref *               3=VorwaertsRef w/Name,     - " - *               4=importiert, Adr enthaelt abs. ^Ursprungs-Neubild *               5=definiert, Adr enth. TreePtr, Name ist aber noch nachzu- *                 tragen (Enum-Element, wenn Enumtyp nachtr. bekannt wird) *               6=definiert, Name bekannt, Adr enthaelt TreePtr *)  PROCEDURE ListImp; BEGIN ASSEMBLER*MOVE.W  D5,D0*BCLR    #15,D0*MULU    #6,D0*MOVE.L  A3,-(A7)*LEA     0(A3,D0.W),A3 !ListImp6 CMPI.W  #4,(A3)       ;CrossRef (importiert)?*BNE     ListImp4*MOVE.L  2(A3),A3      ;im UrsprungsModul bearbeiten*BRA     ListImp6 !ListImp4 TST.W   (A3)*BEQ.W   ListImp1      ;noch unbekannt*CMPI.W  #2,(A3)*BEQ     ListImp8*CMPI.W  #3,(A3)*BEQ     ListImp5**; D1=1: 1 > 1, 5 > 5, 6 > 6*; D1=6: 1 > 6, 5 > 6, 6 > 6*CMP     #1,D1         ;*** Item schon bekannt*BEQ     ListImp7*TST.W   explicitImport ;wird das Elem mit FROM importiert?*BEQ     noFrom2*CMPI    #5,(A3)       ;und wird Name import., obwohl schon gefordert?*BEQ     ListImp2      ;dann Fehler: doppelter Import noFrom2   MOVE.W  #6,(A3)       ;neue Kennung ('aus 1 mach 6') !ListImp7 MOVE.L  2(A3),D1      ;Adr*MOVEA.L (A7)+,A3*RTS  ListImp2  MOVE.L  2(A3),D6 ListImp0  MOVE.L  D6,D2*JMP     ImportedTwice @;*** VorwaertsRefs! !ListImp5 ; es gibt bereits eine Vorw-ref auf ein Enum-Elem (wg. Import*; des Enum-Typs). Wird es nun nochmals explizit importiert,*; ist das ein Fehler.*CMP.B   #6,D1         ;neuer Eintrag benamt?*BEQ     ListImpB*MOVEQ   #5,D1         ;nein: aus 1 mach 5 (Namen nachfordern)*BRA     ListImp8 !ListImpB TST.W   explicitImport ;wird das Elem mit FROM importiert?*BNE     ListImp0      ;dann Fehler !ListImp8 MOVE.W  D1,(A3)       ;neue Kennung ist 1, 5, oder 6*MOVE.L  2(A3),D2 !ListImp3 MOVE.L  0(A1,D2.L),D1 ;*** VorwRefs: Ptr-Kette abarbeiten*MOVE.L  D6,0(A1,D2.L)*MOVE.L  D1,D2*BNE     ListImp3*BRA     ListImp9  !ListImp1 ;*** unbenutztes Item*(**; erstmal prÅfen, ob es eine Crossref darauf war*MOVE.L  A0,-(A7)*MOVEA.L 4(A7),A0      ;Orig-Neubildliste*LEA     0(A0,D0.W),A0*CMPI.W  #4,(A0)       ;CrossRef (importiert)?*BNE     ListImpA*ST      UnknownCrossRef ListImpA  MOVEA.L (A7)+,A0**)*MOVE.W  D1,(A3)       ;zu benutztem Item machen  !ListImp9 MOVE.L  D6,2(A3)      ;^Tree setzen*CLR.L   D1*MOVEA.L (A7)+,A3 END END ListImp;  (* *   ---------------------------------- *   Neue Adr eines Items bzw. Pointerketten-Link liefern *   ---------------------------------- * *      D1 = ItemNr aus PlaTree *      A3 = ^Neubildliste *      D3 = Kennung, die bei Entstehen einer VorwRef einzutragen ist. *            2 = anonym, 3 = mit Namen, *            7 = Name, auch wenn schon bekannt (wird zu 3 oder 5) *      D0 := rel ^Item im IdBaum *) PROCEDURE ItemAdr; BEGIN ASSEMBLER)MULU    #6,D1)BEQ.W   ItemAdr6      ;nil-Ptr: Sonderfall)MOVE.L  A3,-(A7))LEA     0(A3,D1.W),A3 ItemAdr5 MOVE.W  (A3),D0)BEQ.W   ItemAdr1      ;unbekannt)CMPI.W  #4,D0         ;Import)BNE     ItemAdr4)MOVE.L  2(A3),A3      ;^Original-Neubildliste)BRA     ItemAdr5 ItemAdr4 CMPI.W  #2,D0         ;VorwRef anonym ?)BEQ.W   ItemAdr2)CMPI.W  #3,D0         ;VorwRef mit Namen ?)BEQ.W   ItemAdr2)); Adresse des Items ist bekannt))CMP.W   #2,D3         ;anonymer Antrag?)BEQ     known         ;dann reichts schon)(*)CMP.W   #7,D3         ;Namenseintrag unbed. gewuenscht? -> nachfordern)BEQ     getName)CMP.W   #1,D0         ;Name noch unbekannt?)BNE     chkName       ; nein -> ist OK)*) getName  MOVE.W  #5,(A3)       ;nachfordern! chkName  SUBQ.W  #5,D0         ;wird Name bereits gesucht?)BEQ     impTwice      ;ja: dann Fehler melden known    MOVE.L  2(A3),D0      ;Adresse bekannt)MOVE.L  (A7)+,A3)RTS impTwice MOVE.L  2(A3),D2)JMP     ImportedTwice ); VorwaertsRefs) ItemAdr1 CMP.W   #7,D3         ;hier mÅssen wir aus der 7 eine 3 machen)BNE     cont)MOVEQ   #3,D3 cont     MOVE.W  D3,(A3)       ;jetzt erstmals VorwaertsRefs entstanden)CLR.L   2(A3)  ItemAdr2 MOVE.L  2(A3),D0      ;bestehende VorwRef-Kette verlaengern ItemAdr3 TST.L   D6)BEQ     nolink        ;Call aus ScanItm, um Kng 3 anzumelden)MOVE.L  D6,2(A3) nolink   MOVE.L  (A7)+,A3)RTS ItemAdr6 CLR.L   D0 END END ItemAdr;  (* *   ---------------------------------- *   Item in ImportListe fuer I/P-Modul eintragen; *      nur Proc/Var/neue Konst. werden eingetragen. *      Import-Flag in D0 setzen *   ---------------------------------- * *      (D1) * *      D0 = Kennung des Items *      D5 = ItemNr *      D6 = neue IdBaum-Adr *      A0 = ^PlaTree (hinter Kennung) *      A3 = ^Neubildliste *      A4 = ^wachsende Importliste *) PROCEDURE IPIMP; BEGIN ASSEMBLER)CMPI.B  #6,D0         ;Proc?)BEQ     IPIMP1)CMPI.B  #50,D0        ;neue Const?)BEQ     IPIMP1)CMPI.B  #17,D0        ;Var?)BNE     IPIMP2)BTST    #8+4,D0       ;externe Var?)BNE     IPIMP2        ;dann nicht in Importliste eintragen IPIMP1   ; Relozierbare Items dÅrfen nur aus dem Originalmodul importiert wer-); den. Daher wird hier geprÅft, ob das Item nicht eine Crossref ist.)BCLR    #15,D5)MOVE    D5,D1)MULU    #6,D1)CMPI.W  #4,0(A3,D1.W) ;CrossRef (importiert)?)BNE     ok)MOVE.L  A0,-(A7))LEA     0(A3,D1.W),A0 lup      MOVE.L  2(A0),A0)CMPI.W  #4,(A0))BEQ     lup)ORI.W   #$8000,(A0)   ;(s. ImpXRef))MOVE.L  (A7)+,A0)BRA     IPIMP3 ok:      MOVE.W  D5,(A4)+      ;ItemNr in Importliste schreiben)MOVE.L  A0,-(A7))MOVE.L  Header,A0)MOVE.L  A4,D1)SUB.L   A0,D1)SUB.L   14(A0),D1     ;rel. ^Importlisten-Eintrag)MOVE.L  (A7)+,A0)MOVE.L  D1,(A0)       ;  im Baum ueber Adr-Eintrag mogeln)CLR.L   (A4)+         ;hier ^letzte Ref nachtragen (durch FinImp) IPIMP3:  BSET    #13,D0        ;Import-Flag setzen IPIMP2: END END IPIMP;  (* ››› *   ---------------------------------- *   Item in Importliste fuer Def.Modul eintragen *      Import-Flag in Kennung (D0) setzen *   ---------------------------------- * *      D0 = Kennung *      D5 = ItemNr *      D6 = neue IdBaum-Adr *      A4 = ^wachsende ImportListe *      CurrentDef = Anfangsadresse des bearbeiteten DefMod *) PROCEDURE DefImp; BEGIN ASSEMBLER)BSET    #13,D0        ;als Import kennzeichnen)BCLR    #15,D5) (*$ ? Gepard:(MOVE.W  D5,(A4)+      ;bearbeitete ItemNr(MOVE.L  D6,(A4)+      ;Neubild (spÑter eigene ItemNr) *)  (*$ ? Atari:)); suche, ob Item schon im Ursprungsmodul importiert war))MOVEM.L D0/D1/A0,-(A7))MOVE.L  CurrentDef,A0)TST.L   14(A0)         ;Offset zur Importliste im geladenen DefMod)BEQ.W   notfnd         ; keine Importe)ADDA.L  14(A0),A0)BRA     look look2    LEA     2(A0,D1.W),A0  ;A0 hinter Endmarke der vorigen Importliste look     TST.L   (A0)           ;noch ein Import?)BEQ.W   notfnd         ; noe)CLR.W   D1)ADDQ    #2,D1          ;Key, Anzahl Items weg look1    ADDQ    #4,D1          ;beide ItemNr weg)TST.W   0(A0,D1.W))BEQ     look2          ;Endmarke)CMP.W   2(A0,D1.W),D5  ;dessen eigene Nummer = bearbeitete?)BNE     look1          ; ja)); ja, Originalursprung eintragen) found    MOVE.L  (A0),D0)CMP.L   CurrentKey,D0 ;gleiches Modul wie zuvor?)BEQ     same)MOVE.L  D0,CurrentKey)CLR.W   (A4)+         ; nein, Endmarke)MOVE.L  D0,(A4)+      ;neuen Key kopieren)MOVE.W  4(A0),(A4)+   ;Anzahl Items kopieren)BSR     copymodname same     MOVE.W  0(A0,D1.W),(A4)+   ;fremde Nummer kopieren)BRA     ok  copymodname:                   ;Modulname ggf. aus impliziter Importliste holen)MOVE.L  A0,-(A7))MOVE.L  CurrentDef,A0)CMPI.B  #6,(A0)       ;Dlayout)BCS     endloop)ADDA.L  30(A0),A0 loopimp  TST.L   (A0))BEQ     endloop)CMP.L   (A0)+,D0      ;Key: gesuchtes Modul?)BEQ     foundimp nextimp  MOVE    (A0)+,D0      ;weiter zum nÑchsten Key)CMPI.B  #$FE,D0)BCS     nextimp)BRA     loopimp endloop  CLR.W   (A4)+         ;Flag: kein Modulname bekannt)MOVE.L  (A7)+,A0)RTS  foundimp MOVE.W  #1,(A4)+      ;Flag: Modulname ist bekannt nextcop  MOVE    (A0)+,D0)MOVE    D0,(A4)+)CMPI.B  #$FE,D0)BCS     nextcop)MOVE.L  (A7)+,A0)RTS ); nein, geladenes DefMod ist Ursprung) notfnd   MOVE.L  CurrentDef,A0)MOVE.L  4(A0),D0      ;Key)CMP.L   CurrentKey,D0 ;gleiches Modul wie zuvor?)BEQ     same1)MOVE.L  D0,CurrentKey)CLR.W   (A4)+         ; nein, Endmarke)MOVE.L  D0,(A4)+      ;neuen Key kopieren)MOVE.W  12(A0),(A4)+  ;Anzahl Items)BSR     copymodname same1    MOVE.W  D5,(A4)+      ;bearbeitete ItemNr  ok       MOVEM.L (A7)+,D0/D1/A0)MOVE.L  D6,(A4)+      ;Neubild: erlaubt spaeter Feststellung?; der eigenen ItemNr *) END END DefImp;  (* *   ---------------------------------- *   Itemeintrag im PlaTree scannen; *      wenn ^named ID (Enum-Element) vorhanden, *      Nachtrag des Namens ueber ItemAdr anmelden. * *   Sollte nur fuer EnumType/EnumElement aufgerufen werden, *      wenn nachtraeglich ein Import mit Namen gefordert wird. *      (Kann nicht mit lok. Baeumen und Const-Eintragungen umgehen!) *   ---------------------------------- * * TT 01.10.90: Ging schief, wenn zuerst ein Modul mit Enums qual. importiert, *     dann nochmal der EnumTyp unqual. importiert wird: Adr. und Name der *     Enum-Elems sind im Neubild schon als bekannt gekennzeichnet, obwohl ihr *     Name, wie der vom EnumTyp, nochmal im globalen Tree m. Relay angelegt *     werden mÅûte. Deshalb wird hier nun, wenn der Name schon bei ItemAdr *     bekannt, trotzdem der Name nochmal angefordert - ggf. tritt dann eine *     Namenskollision auf, die aber auch immer ein echter Fehler sein dÅrfte. *     Bei kompletten Modulimporten dÅrfen die IDs natÅrlich nicht unbedingt *     angelegt werden, weil die Items sowieso alle drankommen. Die Steuerung *     dafÅr Åbernimmt "anonFlag". * *      (D0-D7,A0) * *      A0 = ^PlaTree, auf ItemNr *      A3 = ^Neubildliste * *      A0 := ^PlaTree, hinter kopiertes Item *)  PROCEDURE ScanItm; BEGIN ASSEMBLER*MOVE.W  (A0)+,D0      ;Kennung*MOVE.L  A2,-(A7)**; passende Eintrags-Beschreibung suchen**LEA     ITEMS,A2      ;Liste der Item-Beschreibungen ScanItm8  CMP.B   (A2)+,D0*BEQ     ScanItm6       ;-> Item gefunden ScanItm7  TST.B   (A2)+         ;falsch, Beschreibung ueberspringen*BNE     ScanItm7*TST.B   (A2)          ;Liste zuende?*BNE     ScanItm8       ;  nein, weiter ScanErr   MOVE.L  (A7)+,A2*MOVE    #rImpor,D5    ;  ja, merkwuerdig (kann nicht vorkommen!)*JMP     SyntaxErr**; Eintrag durchsehen* skipL     ADDQ.L  #2,A0 skipW     ADDQ.L  #2,A0 ScanItm6  MOVE.B  (A2)+,D1      ;* Beschreibung kopieren **BEQ     ScanItm12     ;Ende dieses Eintrags*CMPI.B  #1,D1*BEQ     SkipW         ;Const.W*CMPI.B  #2,D1*BEQ     SkipL         ;Const.L*CMPI.B  #3,D1*BEQ     SkipW         ;Pointer**CMPI.B  #5,D1         ;^Identifier (ID muss mit imp. werden)*BEQ     enumTyp**CMPI.B  #8,D1         ;^Identifier (ID muss mit imp. werden)*BNE     ScanErr       ;falsche Komponente im Eintrag*MOVE.W  (A0)+,D1*MOVE.W  anonFlag,D3   ;Flag, ob der Name unbedingt zu holen ist*TST.W   explicitImport ;wird das Elem mit FROM importiert?*BEQ     ImpItm223*MOVEQ   #2,D3         ;dann Rest anonym nachfordern ImpItm223 CLR.L   D6            ;keine Linked List bei Vorw.eintraegen*JSR     ItemAdr*BRA     ScanItm6  enumTyp   MOVE.W  (A0)+,D1*MOVE.W  anonFlag,D3   ;Flag, ob der Name unbedingt zu holen ist*CLR.L   D6            ;keine Linked List bei Vorw.eintraegen*JSR     ItemAdr*BRA     ScanItm6 ScanItm12 MOVE.L  (A7)+,A2 END END ScanItm;  (* *   ---------------------------------- *   Ein Item in Baum eintragen; *      prueft, ob Eintrag schon da *   ---------------------------------- * *      (D0-D7,A0) * *      A0 = ^PlaTree, auf ItemNr *      A3 = ^Neubildliste * *      A0 := ^PlaTree, hinter kopiertes Item *)  PROCEDURE ImpItm; BEGIN ASSEMBLER)BTST    #7,(A0)       ;exportiert?)BEQ     L1)JMP     ImpItm1 !L1      ADDQ.L  #2,A0)ADDA.W  (A0),A0 END END ImpItm;  PROCEDURE ImpItm1; BEGIN ASSEMBLER)MOVE.W  (A0)+,D5      ;ItemNr)BCLR    #15,D5        ;Export-Flag weg)JMP     ImpItm20 END END ImpItm1;  (*#Item aus Def-Modul importieren - entscheidet, ob nur Relay#angelegt oder es ganz in den Tree kopiert wird. *) PROCEDURE ImpItm20; BEGIN ASSEMBLER)MOVE.L  A0,-(A7)      ;=== Einsprung von FromImp, ImpRest)ADDQ.L  #2,A0)CMPI.B  #$FE,(A0))BCC     ImpItm2       ;>= $FE -> kein Id, sondern Endmarke)TST.W   PERVIMP       ;* ID in Baum eintragen *)BEQ     ImpItm17)JSR     SETPER        ; pervasive)BRA     ImpItm3 ImpItm17 JSR     SETID         ; normal ImpItm3  MOVE.W  A0,D0         ;Sync A0 hinter Namen)BTST    #0,D0)BEQ     ImpItm18)ADDQ.L  #1,A0 ImpItm18 MOVE.L  TRESPC,D6)MOVEQ   #6,D1         ;wir wollen einen Eintrag mit Namen anlegen)JSR     ListImp       ;Item bereits eingetragen?)BEQ     ImpItm4       ; nein, neu eintragen)CLR.B   -1(A1,D6.L)   ; ja, Relay anlegen: Kennung ist 0.B,)TST.B   -1(A1,D1.L)   ;ist Item selbst ein Relay?)BNE     noRelay)MOVE.L  -6(A1,D1.L),D1 ;dann Verweis verwenden noRelay  MOVE.B  -2(A1,D1.L),-2(A1,D6.L) ; Flags kopieren!)MOVE.L  D1,-6(A1,D6.L))SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)MOVE.B  -1(A1,D1.L),D1 ;Kennung des Objekts)CMP.B   #09,D1        ;Enumtyp ?)BEQ     Scan)CMP.B   #10,D1        ;Enum-Element ?)BNE     ImpItm5 Scan     ADDQ.L  #4,A7)JMP     ScanItm       ;Namenseintrag fuer EnumElement nachfordern ImpItm2  MOVE.W  #2,anonFlag)ADDQ.L  #2,A0         ;Dummy-Name weg)MOVE.L  TRESPC,D6     ;* Item anonym eintragen *)MOVEQ   #1,D1         ;geplant ist anonymer Eintrag)JSR     ListImp       ;schon eingetragen?)BEQ     ImpItm4       ; nein, eintragen ImpItm5  MOVE.L  (A7)+,A0      ; ja, Rest des Eintrags im PlaTree ueberspringen)ADDA.W  (A0),A0)RTS ImpItm4  ADDQ.L  #4,A7         ;* Item muss wirklich kopiert werden *)JMP     ImpItm30 END END ImpItm20;  (*#Importiertes Item in Importliste eintragen *) PROCEDURE ImpItm30; BEGIN ASSEMBLER); === Einsprung von ImpRest)MOVE.W  (A0)+,D0      ;Kennung)CMPI.W  #3,IPFLAG     ;DefMod?)BEQ     ImpItm15)JSR     IPIMP         ; nein, ImpListe fuer Imp/PgmMod)JMP     ImpItm16 ImpItm15 JSR     DefImp        ; ja, ImpListe fuer DefMod)JMP     ImpItm16 END END ImpItm30;  (*#Item aus Def-Modul in Baum eintragen *) PROCEDURE ImpItm16; BEGIN ASSEMBLER*JSR     SETKNG        ;=== Einsprung von OwnDef*MOVE.L  D6,-(A7)*SUBQ.L  #2,D6*MOVE.L  A2,-(A7)*CMPI.B  #31,D0        ;StrConst?*BNE     ImpItm23 *; Sonderbehandlung String-Const*MOVE.B  (A0),D1       ;  ja, Laenge holen*BSET    #0,D1         ;  auf gerade Byte-Zahl aufrunden !ImpItm24 SUBQ.L  #1,D6        ;  und String kopieren*MOVE.B  (A0)+,0(A1,D6.L)*DBF     D1,ImpItm24*BRA.L   ImpItm12  !ImpItm23 LEA     ITEMS,A2      ;Liste der Item-Beschreibungen !ImpItm8  CMP.B   (A2)+,D0*BEQ     ImpItm6       ;-> Item gefunden !ImpItm7  TST.B   (A2)+         ;falsch, Beschreibung ueberspringen*BNE     ImpItm7*TST.B   (A2)          ;Liste zuende?*BNE     ImpItm8       ;  nein, weiter*MOVE.L  (A7)+,A2*MOVE    #rImpor,D5    ;  ja, merkwuerdiges Item*JMP     SyntaxErr  !ImpItm6  MOVE.B  (A2)+,D1      ;* Beschreibung kopieren **BEQ.L   ImpItm12      ;Ende dieses Eintrags**CMPI.B  #1,D1*BNE     ImpItm9*MOVE.W  (A0)+,D1      ;^anderes Item, anonym*SUBQ.L  #4,D6*MOVEQ   #2,D3         ;Flag 'anonym'*JSR     ItemAdr       ;Adresse bzw. Pointerkette*MOVE.L  D0,0(A1,D6.L)*BRA     ImpItm6  !ImpItm9  CMPI.B  #2,D1*BNE     ImpItm10*SUBQ.L  #4,D6         ;Const.L*MOVE.L  (A0)+,0(A1,D6.L)*BRA     ImpItm6  !ImpItm10 CMPI.B  #3,D1*BNE     ImpItm11*SUBQ.L  #2,D6         ;Const.W*MOVE.W  (A0)+,0(A1,D6.L)*BRA     ImpItm6  !ImpItm11 CMPI.B  #4,D1*BNE     ImpItm22*SUBQ.L  #4,D6         ;Record: lokaler Baum*MOVE.L  D6,TRESPC*MOVE.L  D6,-(A7)      ;hier ^lok.Baum nachtragen*CLR.L   -(A6) !ImpItm14 TST.W   (A0)          ;Ende des lok. Baums?*BEQ     ImpItm25*MOVE.W  anonFlag,-(A7)*JSR     ImpItm1       ;  nein, weiter*MOVE.W  (A7)+,anonFlag*BRA     ImpItm14 !ImpItm25 ADDQ.L  #2,A0         ;  ja, Endmarke ueberspringen*MOVE.L  (A7)+,D1*MOVE.L  (A6)+,0(A1,D1.L) ;^lokalen Baum nachtragen*BRA.W   ImpItm13  !ImpItm22 CMPI.B  #5,D1*BNE     ImpItm222*SUBQ.L  #4,D6         ;^Enum-Elem von Enum-Typ*MOVE.W  (A0)+,D1*MOVE.W  anonFlag,D3   ;anonym nur, wenn laufendes Item selbst anon.*JSR     ItemAdr*MOVE.L  D0,0(A1,D6.L)*BRA     ImpItm6* ImpItm222 CMPI.B  #8,D1*BNE     ImpItm26*SUBQ.L  #4,D6         ;^Enum-Elem von Enum-Elem*MOVE.W  (A0)+,D1*MOVE.W  anonFlag,D3   ;anonym nur, wenn laufendes Item selbst anon.*TST.W   explicitImport ;wird das Elem mit FROM importiert?*BEQ     ImpItm223*MOVEQ   #2,D3         ;dann Rest anonym nachfordern ImpItm223 JSR     ItemAdr*MOVE.L  D0,0(A1,D6.L)*BRA     ImpItm6  ImpItm26  CMPI.B  #7,D1         ;Insert <n> Bytes-Anweisung?*BNE     ImpItm28*MOVEQ   #0,D1*MOVE.B  (A2)+,D1      ;hole Anzahl Bytes*BRA     ImpItm26b ImpItm26a SUBQ.L  #1,D6         ;Const.W*CLR.B   0(A1,D6.L) ImpItm26b DBRA    D1,ImpItm26a  ;im Baum reservieren & lîschen*BRA     ImpItm6* !ImpItm28 SUBQ.L  #2,D6         ;Laengenangabe fuer folgende Const*MOVE.W  (A0)+,D0*MOVE.W  D0,0(A1,D6.L) !ImpItm27 MOVE.L  (A0)+,-4(A1,D6.L) ;Const kopieren*SUBQ.L  #4,D6*SUBQ.W  #4,D0*BGT     ImpItm27*BRA     ImpItm6  !ImpItm12 MOVE.L  D6,TRESPC !ImpItm13 MOVE.L  (A7)+,A2 *; bei Real-Consts ggf. Format anpassen*MOVE.L  (A7)+,D0*TST     mustChgFormat   ;bleibt Format unverÑndert?*BEQ     ImpItm29*CMPI.B  #18,-1(A1,D0.L) ;Const?*BEQ     ImpItm31*CMPI.B  #50,-1(A1,D0.L) ;Const?*BNE     ImpItm29*MOVE.L  -10(A1,D0.L),D1  ;Typ^ holen*BRA     ImpItm32 ImpItm31: MOVE.L  -6(A1,D0.L),D1  ;Typ^ holen ImpItm32: CMP.L   RealPtr,D1*BEQ     lReal*CMP.L   SRealPtr,D1*BNE     ImpItm29*; ShortReal anpassen*MOVEM.L D2/A0-A3,-(A7)*; *** zeitweilige Restriktion: Keine Formatanpassung bei ShortReals!*MOVE    #rRealF,D5*JMP     SyntaxErr*BRA     ImpItm21 lReal     ; LongReal anpassen*MOVEM.L D2/A0-A3,-(A7)*MOVE.L  EvalStk,A3*LEA     -8(A1,D0.L),A0*CMPI.B  #50,-1(A1,D0.L) ;Const neu?*BNE     ImpItm33*SUBQ.L  #8,A0 ImpItm33: MOVE.L  -(A0),(A3)+*MOVE.L  -(A0),(A3)+*MOVE.L  A0,-(A7)*MOVE    defFormat,D0*MOVE    D0,(A3)+        ;Format im Def-Mod*EORI    #1,D0*MOVE    D0,(A3)+        ;Zielformat*JSR     Conv*MOVE.L  (A7)+,A0*MOVE.L  -(A3),(A0)+*MOVE.L  -(A3),(A0)+ !ImpItm21 MOVEM.L (A7)+,D2/A0-A3*JSR     RealConstIsUsed  ;Real-Format ist nun festgelegt !ImpItm29 END END ImpItm16;  (* PROCEDURE ConvRealToDestFormat;"BEGIN$ASSEMBLER(MOVE.L  A3,-(A7)(MOVE.L  EvalStk,A3(MOVE    UseFormat,D0(CMPI    #3,D0(BEQ     noRconv        ;hat schon richtiges Format(! wenn Werte = 2, dann 1 daraus machen!(MOVE    SysFormat,(A3)+ ;Format der Zahl(MOVE    D0,(A3)+        ;gewÅnschtes Format(JSR     Conv&noRconv(MOVE.L  -(A3),AccuS14(MOVE.L  -(A3),Accu(MOVE.L  A3,EvalStk(MOVE.L  (A7)+,A3$END"END ConvRealToDestFormat;  PROCEDURE ConvRealToSysFormat;"(* A0: Ptr auf Real-Const *)"BEGIN$ASSEMBLER(MOVE.L  A3,-(A7)(MOVE.L  EvalStk,A3(MOVE    UseFormat,D0(CMPI    #3,D0(BEQ     noRconv        ;hat schon richtiges Format(! wenn Werte = 2, dann 1 daraus machen!(MOVE    SysFormat,(A3)+ ;Format der Zahl(MOVE    D0,(A3)+        ;gewÅnschtes Format(JSR     Conv&noRconv(MOVE.L  -(A3),AccuS14(MOVE.L  -(A3),Accu(MOVE.L  A3,EvalStk(MOVE.L  (A7)+,A3$END"END ConvRealToSysFormat; *)  (* *   ---------------------------------- *   Item aus eigenem DefModul importieren: *      aus PlaTree kopieren, *      exportierte Proc/Var in ExportListe eintragen *   ---------------------------------- * *      (D0,D5,D6,A4) * *      A0 = ^Item im PlaTree *      A4 = laufender ^ auf entstehende ExportListe *) PROCEDURE OwnItm; BEGIN ASSEMBLER)MOVE.W  (A0)+,D5      ;ItemNr)MOVE.L  A0,-(A7))ADDQ.L  #2,A0)CMPI.B  #$FE,(A0))BCC     OwnItm2       ;>= $FE -> kein Id, sondern Endmarke))JSR     SETID         ;ID eintragen)MOVE.W  A0,D0)BTST    #0,D0         ;Sync A0)BEQ     OwnItm3)ADDQ.L  #1,A0 !OwnItm3 MOVE.W  #2,anonFlag   ;2: die IDs kommen ja sowieso irgendwann vor...)MOVE.L  TRESPC,D6)MOVEQ   #6,D1         ;wir wollen einen Eintrag mit Namen anlegen)JSR     ListImp       ;Item anonym schon da?)BEQ     OwnItm4       ;nein, neu eintragen)CLR.B   -1(A1,D6.L)   ; ja, Relay anlegen: Kennung und..)TST.B   -1(A1,D1.L)   ;ist Item selbst ein Relay?)BNE     noRelay)MOVE.L  -6(A1,D1.L),D1 ;dann Verweis verwenden noRelay  MOVE.B  -2(A1,D1.L),-2(A1,D6.L) ; Flags kopieren)MOVE.L  D1,-6(A1,D6.L))SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)CMPI.B  #25,-1(A1,D1.L) ;Opaque?)BNE     OwnItm5)MOVE.B  #8,-1(A1,D1.L)  ;redeclarable machen (jm 1404) !OwnItm5 MOVE.L  (A7)+,A0)ADDA.W  (A0),A0)RTS                   ;PlaTree-Eintrag ueberspringen  !OwnItm2 MOVE.L  TRESPC,D6     ;*** anonymes Item eintragen:)MOVE.W  #2,anonFlag)ADDQ.L  #2,A0         ;Blind-ID weg)MOVEQ   #1,D1         ;geplant ist anonymer Eintrag)JSR     ListImp)BNE     OwnItm5       ;gibt's schon: nichts zu tun !OwnItm4 ADDQ.L  #4,A7)MOVE.W  (A0)+,D0      ;Kennung)BCLR    #15,D5        ;Export?)BEQ     OwnItm7       ;nein)CMPI.B  #50,D0        ;Const?)BEQ     OwnItm8)CMPI.B  #17,D0        ;Var?)BEQ     OwnItm8)CMPI.B  #6,D0         ;Proc?)BNE     OwnItm7 OwnItm6  BSET    #12,D0        ;Proc zus. markieren (falls Implement. fehlt,?; soll das von FORWARD-Dekl. unterscheidbar sein OwnItm8  MOVE.W  D5,(A4)+      ;ItemNr der Var/Proc in Exp.Liste eintragen)MOVE.L  D6,(A4)+      ;  hier Adr nachtragen OwnItm7  CMPI.B  #50,D0        ;Const?)BEQ     L1)CMPI.B  #25,D0        ;Opaque?)BNE     L0)MOVE.B  #8,D0         ;redeclarable machen)BRA     L0 L1:      BSET    #12,D0        ;Flag setzen, um zu erkennen, daû eigene?; CONST auch auûerhalb des Moduls evtl. benutzt?; wird, damit sie dann nicht wegoptimiert wird. L0:      JMP     ImpItm16 END END OwnItm;) (* *   ---------------------------------- *   Eigenes Def.Modul in Impl.Modul laden: *      PlaTree uebernehmen, Exportliste anlegen *   ---------------------------------- * *      (D0,D3,A3,A4) * *      A4 = Beginn der anzulegenden Exportliste * *      A0 := ^eigenes DefModul *      VarSpc := Platzbedarf der im DefMod deklarierten Variablen *) PROCEDURE OwnDef; BEGIN ASSEMBLER)MOVE.W  D3,-(A7))MOVE.W  OLDSBL,-(A7))CLR.W   PERVIMP       ;wird beim Import von Records abgefragt!)JSR     SetDef)BEQ     OK)MOVE    #rMyDef,D5        ;nicht gefunden)JMP     SyntaxErr !OK      MOVE.L  A0,-(A7))MOVE.L  A4,D0)MOVE.L  Header,A0)SUB.L   A0,D0)MOVE.L  D0,18(A0)    ;^Exp.Liste)MOVE.L  (A7),A0      ;wieder ^eigenes DefMod)MOVE.L  8(A0),D0     ;Offset bis PlatTree)BEQ     OwnDef1      ;keiner da)ADDA.L  D0,A0 !OwnDef2 TST.W   (A0)          ;Liste zuende?)BEQ     OwnDef1)JSR     OwnItm        ;A0=^ItemNr)BRA     OwnDef2 !OwnDef1 CLR.W   (A4)+         ;Endmarke Exp.Liste)MOVE.L  (A7)+,A0)MOVE.L  Header,A3)MOVE.L  4(A0),2(A3)   ;Key fuer I.Mod uebernehmen)MOVE.L  18(A0),VARSPC ;Platz der vergebenen Var.)MOVE.W  (A7)+,OLDSBL)MOVE.W  (A7)+,D3 END END OwnDef;   CONST    PseudoLen = 78;          (* Anzahl def. Items *))SystemLen = 38;          (* Anzahl def. Items *)  (*!*   ----------------------------------!*    Pseudo-Modul mit StandardTypen und -Prozeduren!*   ----------------------------------!*    Pseudo- und Systemmodul muessen in dieser Reihenfolge hintereinander!*    stehen, damit in Neubild die Platzpruefung funktioniert!!*)  PROCEDURE Pseudo; BEGIN ASSEMBLER Pseudo0  DC.B    6,3            ;Dlayout)DC.W    2              ;pervasive-Flag)DC.L    PseudoKey      ;Key(;DC.L    Pseudo1-Pseudo0 ;^ExportListe)DC.L    62)DC.W    PseudoLen       ;Anzahl def. Items(;DC.L    PseudoI-Pseudo0 ;^ImportListe)DC.L    34)DC.L    0              ;Platz fuer definierte Var.)DC.L    0              ;^Modulname(;DC.W    PseudoI-Pseudo0)DC.W    34             ;HeaderlÑnge)DC.W    0              ;^Sourcename)DC.L    0              ;^Liste d. implizit zu importierenden Module PseudoI  DC.L    SystemKey      ;Import aus System)DC.W    SystemLen      ;Anzahl Items in System)DC.W    1              ;WORD importieren)DC.W    27             ;eigene ItemNr)DC.W    2              ;ADDRESS importieren)DC.W    48)DC.W    3              ;LONG importieren)DC.W    28)DC.W    4              ;BYTE importieren)DC.W    29)DC.W    0)DC.L    0              ;Ende der Importliste Pseudo1  DC.W    $8001,16       ;TYPE LongInt)ASC     'LONGINT')DC.B    $FF)DC.W    $8501)DC.L    4 Pseudo2  DC.W    $8002,18       ;TYPE LongReal)ASC     'LONGREAL')DC.B    $FE,$FF)DC.W    $8402)DC.L    8 Pseudo3  DC.W    $8003,18       ;TYPE LongCard)ASC     'LONGCARD')DC.B    $FE,$FF)DC.W    $8516)DC.L    4 Pseudo4  DC.W    $8004,14       ;TYPE Char)ASC     'CHAR')DC.B    $FE,$FF)DC.W    $8503)DC.L    1 Pseudo5  DC.W    $8005,16       ;TYPE Boolean)ASC     'BOOLEAN')DC.B    $FF)DC.W    $8518)DC.L    2 Pseudo6  DC.W    $8006,18       ;TYPE SHORTINT)ASC     'SHORTINT')DC.B    $FE,$FF)DC.W    $8521)DC.L    2 Pseudo7  DC.W    $8007,18       ;TYPE SHORTCARD)ASC     'SHORTCARD')DC.B    $FF)DC.W    $8522)DC.L    2 Pseudo8  DC.W    $8008,10      ;TYPE ShortBothType)DC.B    $FE,$FF)DC.W    $8523)DC.L    2 Pseudo9  DC.W    $8009,10       ;TYPE LongBothType)DC.B    $FE,$FF)DC.W    $851E)DC.L    4 (*$? NOT BITSETfromSYSTEM: Pseudo10 DC.W    $800A,18       ;TYPE BitSet)ASC     'BITSET')DC.B    $FE,$FF)DC.W    $842D          ; nun mit Kennung 45 statt 5! (30.6.90))DC.L    2)DC.W    72 *) (*$? BITSETfromSYSTEM: Pseudo10 DC.W    $000A,6        ;nur dummy)DC.B    $FE,$FF)DC.W    $803F *) Pseudo11 DC.W    $800B,18       ;TYPE Proc)ASC     'PROC')DC.B    $FE,$FF)DC.W    $8413)DC.L    4)DC.W    0,0 Pseudo12 DC.W    $800C,10       ;TYPE ZZ)DC.B    $FE,$FF)DC.W    $8504)DC.L    6 Pseudo13 DC.W    $800D,14       ;TYPE ShortReal)ASC     'REAL')DC.B    $FE,$FF)DC.W    $8428)DC.L    4 Pseudo14 DC.W    $800E,14       ;TYPE Integer)ASC     'INTEGER')DC.B    $FF)DC.W    $0000          ; Relay auf SHORTINT)DC.W    6 Pseudo15 DC.W    $800F,16       ;TYPE Cardinal)ASC     'CARDINAL')DC.B    $FE,$FF)DC.W    $0000          ; Relay auf SHORTCARD)DC.W    7 Pseudo16 DC.W    $8010,6        ;Hilfseintrag f. noch ungelîste Ptr/Proc-Refs)DC.B    $FE,$FF)DC.W    $8000+48 Pseudo17 DC.W    $8011,14       ;TYPE SS)DC.B    $FE,$FF)DC.W    $841B)DC.L    0,0            ;2. Long nur sicherheitshalber wg. Kompat. Pseudo18 DC.W    $8012,10       ;TYPE >signed byte<)DC.B    $FE,$FF)DC.W    $8527)DC.L    1 Pseudo19 DC.W    $8013,10       ;TYPE >strukt. Konst.<)DC.B    $FE,$FF)DC.W    $842B)DC.L    0 Pseudo20 DC.W    $8014,20       ;CONST MaxInt)ASC     'MaxInt')DC.B    $FE,$FF)DC.W    $8012,8,2)DC.L    $7FFF Pseudo21 DC.W    $8015,12       ;Parameter ABS (Integer): Cardinal;)DC.B    $FE,$FF)DC.W    $8025,6,7,22 Pseudo22 DC.W    $8016,12       ;Parameter ABS (LongInt): LongCard;)DC.B    $FE,$FF)DC.W    $8025,1,3,58 Pseudo23 DC.W    $8017,12       ;Procedure ORD)ASC     'ORD')DC.B    $FF)DC.W    $8024,2,24 Pseudo24 DC.W    $8018,12       ;Parameter ORD (anyThing): Cardinal;)DC.B    $FE,$FF)DC.W    $8025,0,7,00 Pseudo25 DC.W    $8019,14       ;Procedure HIGH)ASC     'HIGH')DC.B    $FE,$FF)DC.W    $8024,3,26 Pseudo26 DC.W    $801A,12       ;Parameter HIGH (anyThing): Cardinal;)DC.B    $FE,$FF)DC.W    $8025,0,7,00 Pseudo27 DC.W    $001B,10       ;WORD anonym)DC.B    $FE,$FF)DC.W    $8515)DC.L    2 Pseudo28 DC.W    $001C,10       ;LONG anonym)DC.B    $FE,$FF)DC.W    $851A)DC.L    4 Pseudo29 DC.W    $001D,10       ;BYTE anonym)DC.B    $FE,$FF)DC.W    $8526)DC.L    1 Pseudo30 DC.W    $801E,14       ;Procedure LONG)ASC     'LONG')DC.B    $FE,$FF)DC.W    $8024,4,31 Pseudo31 DC.W    $801F,12       ;Parameter LONG (Cardinal): LONGCARD;)DC.B    $FE,$FF)DC.W    $8025,7,3,32 Pseudo32 DC.W    $8020,12       ;Parameter LONG (Integer): LONGINT;)DC.B    $FE,$FF)DC.W    $8025,6,1,33 Pseudo33 DC.W    $8021,12       ;Parameter LONG (Word): Long;)DC.B    $FE,$FF)DC.W    $8025,27,28,34 Pseudo34 DC.W    $8022,12       ;Parameter LONG (Byte): Word;)DC.B    $FE,$FF)DC.W    $8025,29,27,66 Pseudo35 DC.W    $8023,14       ;Procedure SHORT)ASC     'SHORT')DC.B    $FF)DC.W    $8024,5,36 Pseudo36 DC.W    $8024,12       ;Parameter SHORT (LongCard): Cardinal;)DC.B    $FE,$FF)DC.W    $8025,3,7,37 Pseudo37 DC.W    $8025,12       ;Parameter SHORT (LongInt): Integer;)DC.B    $FE,$FF)DC.W    $8025,1,6,38 Pseudo38 DC.W    $8026,12       ;Parameter SHORT (Long): Word;)DC.B    $FE,$FF)DC.W    $8025,28,27,39 Pseudo39 DC.W    $8027,12       ;Parameter SHORT (Word): Byte;)DC.B    $FE,$FF)DC.W    $8025,27,29,65 Pseudo40 DC.W    $8028,12       ;Procedure ODD)ASC     'ODD')DC.B    $FF)DC.W    $8024,6,41 Pseudo41 DC.W    $8029,12       ;Parameter ODD (anyScalar): Boolean;)DC.B    $FE,$FF)DC.W    $8025,0,5,0 Pseudo42 DC.W    $802A,12       ;Procedure INC)ASC     'INC')DC.B    $FF)DC.W    $8024,20,00 Pseudo43 DC.W    $802B,12       ;Procedure DEC)ASC     'DEC')DC.B    $FF)DC.W    $8024,21,00 Pseudo44 DC.W    $802C,12       ;Procedure NEW)ASC     'NEW')DC.B    $FF)DC.W    $8024,22,00 Pseudo45 DC.W    $802D,16       ;Procedure DISPOSE)ASC     'DISPOSE')DC.B    $FF)DC.W    $8024,23,00 Pseudo46 DC.W    $802E,14       ;Procedure INCL)ASC     'INCL')DC.B    $FE,$FF)DC.W    $8024,24,00 Pseudo47 DC.W    $802F,14       ;Procedure EXCL)ASC     'EXCL')DC.B    $FE,$FF)DC.W    $8024,25,00 Pseudo48 DC.W    $0030,12       ;ADDRESS anonym)DC.B    $FE,$FF)DC.W    $8517          ;eigener Code, aber Struktur wie Pointer!)DC.L    4)DC.W    27 Pseudo49 DC.W    $8031,16       ;CONST nil)ASC     'NIL')DC.B    $FF)DC.W    $8012,48,4)DC.L    0 Pseudo50 DC.W    $8032,18       ;CONST true)ASC     'TRUE')DC.B    $FE,$FF)DC.W    $8012,5,2)DC.L    1 Pseudo51 DC.W    $8033,18       ;CONST false)ASC     'FALSE')DC.B    $FF)DC.W    $8012,5,2)DC.L    0 Pseudo52 DC.W    $8034,12       ;Procedure MIN)ASC     'MIN')DC.B    $FF)DC.W    $8024,7,00 Pseudo53 DC.W    $8035,12       ;Procedure MAX)ASC     'MAX')DC.B    $FF)DC.W    $8024,8,00 Pseudo54 DC.W    $8036,14       ;Procedure SIZE)ASC     'SIZE')DC.B    $FE,$FF)DC.W    $8024,11,8 Pseudo55 DC.W    $8037,12       ;Parameter SIZE (anyThing): LongCard)DC.B    $FE,$FF)DC.W    $8025,0,3,0 Pseudo56 DC.W    $8038,12       ;Procedure VAL)ASC     'VAL')DC.B    $FF)DC.W    $8024,9,0      ;keine Parameter/Result-Beschreibung! Pseudo57 DC.W    $8039,16       ;Procedure LENGTH)ASC     'LENGTH')DC.B    $FE,$FF)DC.W    $8024,10,0     ;keine Parameter/Result-Beschreibung! Pseudo58 DC.W    $803A,12       ;Parameter ABS (Real): Real;)DC.B    $FE,$FF)DC.W    $8025,2,2,0 Pseudo59 DC.W    $803B,12       ;Procedure INT)ASC     'INT')DC.B    $FF)DC.W    $8024,12,0     ;keine Parameter/Result-Beschreibung! Pseudo60 DC.W    $803C,12       ;Procedure CAP)ASC     'CAP')DC.B    $FF)DC.W    $8024,13,0     ;keine Parameter/Result-Beschreibung! Pseudo61 DC.W    $803D,12       ;Procedure CHR)ASC     'CHR')DC.B    $FF)DC.W    $8024,14,0     ;keine Parameter/Result-Beschreibung! Pseudo62 DC.W    $803E,14       ;Procedure FLOAT)ASC     'FLOAT')DC.B    $FF)DC.W    $8024,15,0     ;keine Parameter/Result-Beschreibung! Pseudo63 DC.W    $803F,16       ;Procedure LFLOAT)ASC     'LFLOAT')DC.B    $FE,$FF)DC.W    $8024,16,0     ;keine Parameter/Result-Beschreibung! Pseudo64 DC.W    $8040,14       ;Procedure TRUNC)ASC     'TRUNC')DC.B    $FF)DC.W    $8024,17,0     ;keine Parameter/Result-Beschreibung! Pseudo65 DC.W    $8041,12       ;Parameter SHORT (LONGREAL): REAL;)DC.B    $FE,$FF)DC.W    $8025,2,13,69 Pseudo66 DC.W    $8042,12       ;Parameter LONG (REAL): LONGREAL;)DC.B    $FE,$FF)DC.W    $8025,13,2,68 Pseudo67 DC.W    $8043,12       ;Parameter SHORT (INTEGER): Byte;)DC.B    $FE,$FF)DC.W    $8025,6,29,71 Pseudo68 DC.W    $8044,12       ;Parameter LONG (SBothTyp): BothTyp;)DC.B    $FE,$FF)DC.W    $8025,8,9,0 Pseudo69 DC.W    $8045,12       ;Parameter SHORT (BothTyp): SBothTyp;)DC.B    $FE,$FF)DC.W    $8025,9,8,70 Pseudo70 DC.W    $8046,12       ;Parameter SHORT (SBothTyp): Byte;)DC.B    $FE,$FF)DC.W    $8025,9,29,67 Pseudo71 DC.W    $8047,12       ;Parameter SHORT (CARDINAL): Byte;)DC.B    $FE,$FF)DC.W    $8025,7,29,0 (*$? NOT BITSETfromSYSTEM: Pseudo72 DC.W    $8048,20       ;Subrange CARDINAL[0..15] f. BITSET)DC.B    $FE,$FF)DC.W    $850B)DC.L    2,0,15         ;Size=2, Low=0, Hi=15)DC.W    7              ;Base Type: CARDINAL *) (*$? BITSETfromSYSTEM: Pseudo72 DC.W    $0048,6        ;nur dummy)DC.B    $FE,$FF)DC.W    $803F *) Pseudo73 DC.W    $8049,20       ;CONST MinInt)ASC     'MinInt')DC.B    $FE,$FF)DC.W    $8012,6,2)DC.L    $FFFF8000 Pseudo74 DC.W    $804A,20       ;CONST MaxCard)ASC     'MaxCard')DC.B    $FF)DC.W    $8012,7,2)DC.L    $FFFF Pseudo75 DC.W    $804B,20       ;CONST MaxLInt)ASC     'MaxLInt')DC.B    $FF)DC.W    $8012,9,4)DC.L    $7FFFFFFF Pseudo76 DC.W    $804C,20       ;CONST MinLInt)ASC     'MinLInt')DC.B    $FF)DC.W    $8012,1,4)DC.L    $80000000 Pseudo77 DC.W    $804D,22       ;CONST MaxLCard)ASC     'MaxLCard')DC.B    $FE,$FF)DC.W    $8012,3,4)DC.L    $FFFFFFFF Pseudo78 DC.W    $804E,12       ;Procedure ABS)ASC     'ABS')DC.B    $FF)DC.W    $8024,1,21))DC.W    0 END END Pseudo;  (* *   ---------------------------------- *    System-Modul mit StandardTypen und -Prozeduren *   ---------------------------------- *) PROCEDURE SysMod; BEGIN ASSEMBLER  System0  DC.B    6,3            ;Dlayout)DC.W    1              ;Qualified-Flag (NICHT pervasive!))DC.L    SystemKey      ;Key(;DC.L    System1-System0 ;^ExportListe)DC.L    58)DC.W    SystemLen       ;Anzahl def. Items(;DC.L    SystemI-System0 ;^ImportListe)DC.L    34)DC.L    0              ;Platz fuer definierte Var.)DC.L    0              ;^Modulname(;DC.W    SystemI-System0)DC.W    34             ;HeaderlÑnge)DC.W    0              ;^Sourcename)DC.L    0              ;^Liste d. implizit zu importierenden Module SystemI  DC.L    PseudoKey      ;Import aus Pseudo)DC.W    PseudoLen      ;Anzahl Items in Pseudo)DC.W    3              ;LongCard importieren)DC.W    10             ;eigene ItemNr)DC.W    11             ;PROC importieren)DC.W    15             ;eigene ItemNr)DC.W    8              ;ShortBothTyp importieren)DC.W    24             ;eigene ItemNr)DC.W    0)DC.L    0              ;Ende der Importliste System1  DC.W    $8001,14       ;TYPE Word)ASC     'WORD')DC.B    $FE,$FF)DC.W    $8515)DC.L    2 System2  DC.W    $8002,18       ;TYPE Address)ASC     'ADDRESS')DC.B    $FF)DC.W    $8517          ;eigener Code, aber Struktur wie Pointer!)DC.L    4)DC.W    1              ;Pointer to Word System3  DC.W    $8003,18       ;TYPE LongWord)ASC     'LONGWORD')DC.B    $FE,$FF)DC.W    $851A)DC.L    4 System4  DC.W    $8004,14       ;TYPE Byte)ASC     'BYTE')DC.B    $FE,$FF)DC.W    $8526)DC.L    1 System5  DC.W    $8005,12       ;Procedure ADR)ASC     'ADR')DC.B    $FF)DC.W    $8024,101,6 System6  DC.W    $8006,12       ;Parameter ADR (anyThing): Address)DC.B    $FE,$FF)DC.W    $8025,0,2,0 System7  DC.W    $8007,14       ;Procedure TSIZE)ASC     'TSIZE')DC.B    $FF)DC.W    $8024,103,8 System8  DC.W    $8008,12       ;Parameter TSIZE (anyThing): LongCard)DC.B    $FE,$FF)DC.W    $8025,0,10,0 System9  DC.W    $8009,14       ;Procedure CAST)ASC     'CAST')DC.B    $FE,$FF)DC.W    $8024,104,0    ;keine Parameter/Result-Beschreibung! System10 DC.W    $000A,10       ;anonyme Beschreibung fuer LongCard)DC.B    $FE,$FF)DC.W    $8516)DC.L    4 System11 DC.W    $800B,20       ;Procedure NEWPROCESS)ASC     'NEWPROCESS')DC.B    $FE,$FF)DC.W    $8024,120,16   ;Parameter: ^^PROC System12 DC.W    $800C,18       ;Procedure TRANSFER)ASC     'TRANSFER')DC.B    $FE,$FF)DC.W    $8024,121,14   ;Parameter: ^^Address fuer Prozess-Angabe System13 DC.W    $800D,20       ;Procedure IOTRANSFER)ASC     'IOTRANSFER')DC.B    $FE,$FF)DC.W    $8024,122,14   ;Parameter: ^^Address fuer Vektor-Angabe System14 DC.W    $800E,12       ;Parameter NEWPROCESS (...ADDRESS...))DC.B    $FE,$FF        ;gleichz. TRANSFER, IOTRANSFER, IOCALL (ADDRESS))DC.W    $8025,2,0,0 System15 DC.W    $000F,14       ;anonyme Beschreibung fuer TYPE Proc)DC.B    $FE,$FF)DC.W    $8413)DC.L    4)DC.W    0,0 System16 DC.W    $8010,12       ;Parameter NEWPROCESS (PROC ...))DC.B    $FE,$FF)DC.W    $8025,15,0,14 System17 DC.W    $8011,16       ;Procedure LISTEN)ASC     'LISTEN')DC.B    $FE,$FF)DC.W    $8024,123,0    ;keine Parameter System18 DC.W    $8012,16       ;Procedure IOCALL)ASC     'IOCALL')DC.B    $FE,$FF)DC.W    $8024,124,14   ;Parameter: address System19 DC.W    $8013,12       ;TYPE LOC)ASC     'LOC')DC.B    $FF)DC.W    $8526          ;ItemNo: 38, wie bei BYTE)DC.L    1 System20 DC.W    $8014,14       ;Procedure CADR)ASC     'CADR')DC.B    $FE,$FF)DC.W    $8024,105,6 System21 DC.W    $8015,14       ;Procedure DEREF)ASC     'DEREF')DC.B    $FF)DC.W    $8024,106,0    ;keine Parameter!!!??? System22 DC.W    $8016,28       ;CONST CompilerVersion)ASC     'CompilerVersion')DC.B    $FF)DC.W    $8012,24,2)DC.L    CompilerVersion System23 DC.W    $8017,32       ;CONST CompilerSubVersion)ASC     'CompilerSubVersion')DC.B    $FE,$FF)DC.W    $8012,24,2)DC.L    CompilerSubVersion System24 DC.W    $0018,10       ;anonyme Beschreibung fuer ShortBothTyp)DC.B    $FE,$FF)DC.W    $8523)DC.L    2 System25 DC.W    $8019,16       ;TYPE BITNUM)ASC     'BITNUM')DC.B    $FE,$FF)DC.W    $8529          ;ItemNo: 41)DC.L    2 System26 DC.W    $801A,14       ;Procedure SHIFT)ASC     'SHIFT')DC.B    $FF)DC.W    $8024,107,0    ;keine Parameter!!!??? System27 DC.W    $801B,16       ;Procedure ROTATE)ASC     'ROTATE')DC.B    $FE,$FF)DC.W    $8024,108,0    ;keine Parameter!!!??? System28 DC.W    $801C,18       ;ASSEMBLER-Identifier)ASC     'ASSEMBLER')DC.B    $FF)DC.W    $8024,125,0 System29 DC.W    $801D,16       ;Function/Procedure CALLSYS)ASC     'CALLSYS')DC.B    $FF)DC.W    $8024,126,35   ;1. Parameter: CARDINAL System30 DC.W    $801E,16       ;Function/Procedure CALLEXT)ASC     'CALLEXT')DC.B    $FF)DC.W    $8024,127,36   ;1. Parameter: ADDRESS System31 DC.W    $801F,14       ;Procedure CODE)ASC     'CODE')DC.B    $FE,$FF)DC.W    $8024,128,0    ;keine Parameter System32 DC.W    $8020,14       ;Procedure LOAD)ASC     'LOAD')DC.B    $FE,$FF)DC.W    $8024,129,0    ;keine Parameter System33 DC.W    $8021,14       ;Procedure STORE)ASC     'STORE')DC.B    $FF)DC.W    $8024,130,0    ;keine Parameter Pseudo34 DC.W    $8022,20       ;Subrange [0..15] f. CALLSYS-TRAP-Nr.)DC.B    $FE,$FF)DC.W    $850B)DC.L    2,0,15         ;Size=2, Low=0, Hi=15)DC.W    24             ;Base Type: BothTyp System35 DC.W    $8023,12       ;Parameter CALLSYS ([0..15]...): LONGWORD)DC.B    $FE,$FF)DC.W    $8025,34,3,0 System36 DC.W    $8024,12       ;Parameter CALLEXT (ADDRESS...): LONGWORD)DC.B    $FE,$FF)DC.W    $8025,2,3,0 (*$? BITSETfromSYSTEM: System37 DC.W    $8025,20       ;Subrange BITNUM[0..15] f. BITSET)DC.B    $FE,$FF)DC.W    $850B)DC.L    2,0,15         ;Size=2, Low=0, Hi=15)DC.W    25             ;Base Type: BITNUM System38 DC.W    $8026,18       ;TYPE BitSet)ASC     'BITSET')DC.B    $FE,$FF)DC.W    $842D)DC.L    2)DC.W    37 *) (*$? NOT BITSETfromSYSTEM: System37 DC.W    $8025,6        ;nur dummy)DC.B    $FE,$FF)DC.W    $803F System38 DC.W    $8026,6        ;nur dummy)DC.B    $FE,$FF)DC.W    $803F *))DC.W    0 END END SysMod;  PROCEDURE SysModEnd; END SysModEnd;  (* EOT *) 
(* $0000A355$0000985C$00011D46$FFE56852$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$00010848$FFE39FFA$00018B3F$FFE39FFA$0001085C$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$000045B4$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFA$FFE39FFAÄ$00010845T.......T.......T.......T.......T.......T.......T.......T.......T.......T.......$FFE30C01$00003736$FFE30C01$0000DC02$0000DC0F$0000DC4D$0000DC60$000108FF$00000038$0000DC50$00010893$00010845$00010A3D$00003718$00003781$000037B2∞ÄÉ*)
