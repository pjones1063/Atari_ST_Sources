 (* -----------------------------------------------------#Modula Compiler  /3.6a/#-----------------------------------------------------##Codeerzeugung fÅr Main-Module#$30.3.85  GDOS Version%7.6.85  bessere Code-Erzeugung fuer StatLink-Verfolgung%8.6.85  bessere Code-Erzeugung fuer Load #0 (CLR)$30.7.85  Interrupt-faehiger Code fuer Subrange Check%7.8.85  Interrupt-Level setzen"{ 12.8.85  NEG.W D0  statt AND.W D7,D0 }$15.8.85  RTE auch in ModulBody bei Priority >= 0$27.8.85  wieder AND.W D7,D0 eingefuehrt#17.10.85  OR & AND statt MOVE to SR bei Interrupt-Level-Aenderung;-MOVE (A7)+,SR statt RTE bei Ende einer Interrupt-Routine#22.02.86  Neuordnung der Texte#14.04.86  Put147 implementiert#15.04.86  Put148, Put149 implementiert; Put119 gestrichen#16.04.86  Put150 implementiert#21.04.86  mulu #1 in Put20 verhindert#12.06.86  Aenderung vom 21.4. funktioniert jetzt wirklich#28.07.86  Put151 implementiert#17.10.86  Put200-Put210 fuer Byte-Handling-Kopierschleifen Put211, 212 fuer gerade oder ungerade Laenge;-Arraygroessen ueber 64K Wort moeglich#18.10.86  Put213 fuer ForLoops;-Peephole-Optimierung auf zwei Ebenen erweitert#19.10.86  Peephole-Behandlung in Put73 korrigiert#21.10.86  Put66/67 und Movecut hinterlassen Info ueber MOVE.W/L source,D0;-Put72 kuerzt MOVE src,A0 auch im vorletzten Befehl;-Put20 ruft Put72 auf.#22.10.86  Put209 fuer Byte-Subrangecheck; alle Unsigned-SubrangeChecks-(95, 97, 209) jetzt ohne Vergleich auf Untergrenze Null;-put141 erlaubt Zuweisung von Arrays > 32K;-AND D7,dest durch ANDI.W #1,dest ersetzt in put43/44/134#23.10.86  Put74 erlaubt Long-Wert;-Put214 zur Formatwandlung Char -> String [1]#24.10.86  Put74 und Put210 erzeugen Endmarken 0.W bzw 0.B;-CSP kennt neue Runtime-Prozeduren TRAN, IOTR, NEWP fuer Prozesse#27.10.86  Put73 erzeugt fuer Wort-Offset LEA statt ADDA (kuerzbar) tt 30.10.86  PutDebug statt Put76$1.11.86  Put214 (Char -> String [1]) erzeugt fuer Atari keinen Code mehr;-alle Put-Routinen fuer Bytes auf nachfolgenden Sync geaendert;-Peephole-Opt. put211 gegen 212 implementiert#25.11.86  in put200.. jeweils SUBQ.L #1,A3 berichtigt (war SUBQ.B);-put218 implementiert und NICHT getestet#30.11.86  Test und Korrektur von put218-put138 erzeugt wieder rechtsbuendige CHARs fuer Gepard-Std.#19.12.86  put219 checkt Zugriff ueber NIL-Pointer; neuer TRAP 7 !#20.12.86  put220 zum Umkopieren von Open Arrays als Value-Parameter;-neue Runtime-Prozedur @COPY dafuer.#16. 1.87  Umstellung A1/A2 -> A5/A5 in Atari-Version#18. 1.87  put221,222 fuer Value-Uebergabe von Open Arrays#29. 1.87  put221 rettet Adr vom Stack, falls Aufruf ueber ProcVar erfolgt.#30. 1.87  put220 umgestellt: erzeugt jetzt Code fuer Uebergabe Open Array.an Open Array by Val; neue RuntimeProc @COPS.#12. 2.87  put212bytes implementiert#15. 2.87  Atari-Version: RangeErr jetzt mit Trap #0,9 statt Trap #0,0.-put221 kopiert Arrays von ungeraden Adressen jetzt mit Hilfsreg.-byteweise auf den A7-Stack; dadurch Umweg ueber (A3) gespart.#16. 2.87  put211bytes implementiert;-put7 kopiert bis zu 16 Byte Parameter ohne Schleife#17. 2.87  put221bytes implementiert          === nicht getestet ===#26. 2.87  put221bytes korrigiert#25. 3.87  Allocate/DeAllocate bei Atari GROSS schreiben#16.04.87  Trap7 bei Gepard mit erweiterem Word !#09.05.87  Atari: TRAP fÅr Errors: #6, fÅr Debug: #5; Errornummern geÑndert#15.06.87  put117 (Real-Abs) fÅr neues Atari-Realformat#18.06.87  put131 mit nachfolgendem Ergebnis-TST fÅr folgende Rangechecks$2.07.87  put5, put6: MOVEM statt einzelner MOVEs beim Register-Retten,/fÅr Atari Reihenfolge MOVEM und LINK/UNLK vertauscht;-putRET: Atari-Version auch im Module Body mit UNLK.$3.07.87  put203a, put204a: Konvertierung Long <> Byte, unsigned;-put56 benutzt fÅr Stackcheck Var. 'StackReserve'.#14.07.87  put5: A7 wird richtig gesetzt, auch bei lok. Procs;3Optimierung bei Put7 (TT)#21.07.87 TT  UNLK-Erzeugung in Modulbody wieder raus.#22.07.87 TT  STPROC: @LSTN neu#23.07.87 TT  PutRet: Priority-Restore wird zw. Reg-Restore und UNLK0gelegt. Put6a in Put6d und Put6e zerteilt; put146 und0put6c angepaût fÅr Atari.#03.01.88 TT  PUT6C korrigiert (D3 gerettet)#28.05.88 TT  put56 optimiert; put56b neu: faût put5 & put56 zusammen und1ruft Runtime-Funktionen zum Link auf; STPROC um '@RES1/2'1erweitert.#07.01.90 TT  put56b Åbergibt nun Bereich als Long statt Word; put5 kann2auch Long-LINK gen.#28.01.90 TT  PutLinkWOcopy neu: Macht LINK, sodaû Parms auf A3-Stack bleiben#08.02.90 TT  'freeRegs' wird beim Retten/RÅckladen der Regs bei Proc-Entry0& -Exit berÅcksichtigt#----------------------------------------------------- *)   (**** Lokal benoetigte Vorwaerts-Referenzen ****)  FORWARD putIncA3; FORWARD Put66; FORWARD Put33w; FORWARD put216; FORWARD SetPriority;  (**** Codeerzeugung: ****)  PROCEDURE MOVECUT; BEGIN ASSEMBLER*TST.L   D7*BMI.L   CLEARCUT      ;letzter Befehl war CLR.x (A3)+*SWAP    D7*ANDI.W  #$FFC0,D0*OR.W    D7,D0**; einige Befehle koennen voellig entfallen:**CMPI.W  #$2048,D0     ;MOVE.L A0,A0?*BEQ     MOVECUT1*CMPI.W  #$3000,D0     ;MOVE.W D0,D0?*BEQ     MOVECUT1*CMPI.W  #$2000,D0     ;MOVE.L D0,D0?*BEQ     MOVECUT1*CMPI.W  #$2848,D0     ;MOVE.L A0,A4?*BNE     MOVECUT2**;move.l a0,a4 verhindern, wenn moeglich**MOVE.L  D7,-(A7)*MOVE.L  Peephole,D7*CMP.B   #4,D7         ;vorher war move #long -> a0 ?*BEQ     ok*CMP.B   #5,D7         ;vorher lea source,a0 ?*BNE     MoveCut3      ;leider nix zu machen ok        ADDQ.L  #4,A7*LSR.W   #8,D7         ;Pos. des zu aendernden Opcodes berechnen*ADDQ.W  #2,D7*NEG.W   D7*ORI.W   #$0800,-2(A4,D7.W) ;Dest A0 zu A4 machen@;beachte Offset -2: patchen im vorigen Bef.*CLR.W   D7*BRA     MoveCut4 MoveCut3  MOVE.L  (A7)+,D7      ;Opcode muss doch erzeugt werden**; ZielAdresse fuer den neuen Code bestimmen* MoveCut2  SWAP    D7*MOVE.W  D7,-(A7)*LSR.W   #8,D7*ADDQ.W  #2,D7*NEG.W   D7*MOVE.W  D0,0(A4,D7.W)*MOVE.W  (A7)+,D7*CMP.W   #$207C,D0     ;move.l #data,a0 erzeugt?*BEQ     longA0*AND.W   #$0FC0,D0     ;Dest-Feld betrachten*BNE     done*ADDQ.B  #7,D7         ;Data -> EvalStk zu Data -> D0 machen*RTS longA0    MOVE.L  #$404,D7      ;#ADR->A0 GEGEN (A0) KUERZBAR*RTS MoveCut1  MOVE.L  Peephole,D7   ;und Info ueber vorigen ausgraben MoveCut4  SUBQ.L  #2,A4         ;letzten Befehl vergessen*CLR.L   Peephole*RTS**;wir basteln uns einen CLR-Opcode...  !CLEARCUT MOVE.W  D0,-(A7)*AND.W   #0000000111000000%,D0 ;Dest Mode rausfiltern*CMP.W   #0000000001000000%,D0 ;ist das ein AReg direkt?*BEQ     MOVEAD        ;schade: ein MoveAddress*MOVE.W  (A7)+,D0*MOVE.W  #$4200,D7     ;high byte von CLR*LSR.W   #3,D0*MOVE.B  D0,D7         ;mode steht richtig in D7*AND.B   #00111000%,D7 ;Rest wegmaskiert*LSR.W   #1,D0*LSR.B   #5,D0         ;reg steht richtig*OR.B    D0,D7*CLR.B   D0*LSR.W   #2,D0         ;len steht richtig*OR.B    D0,D7*BTST    #6,D7*BEQ     clear1        ;ist CLR.L*BCLR    #7,D7         ;CLR.W geschickterweise anders codiert! !clear1   MOVE.W  D7,-2(A4)*BRA     done !movead   MOVE.W  (A7)+,(A4)+  ;nix zu kuerzen bei MOVEA*MOVE.L  D7,PeepHole   ;normale Erzeugung eines neuen Befehls !done     CLR.W   D7            ;bei einfacher Kuerzung: Peephole haelt Wert END END MOVECUT;  (*      Schade: Hier wuerden MOVEs mit Source- und DestAdr entstehen,0wobei einer der Operanden verschoben werden muss -0wegen des moeglichen Eintrags in die RelozierListe leider0verboten! Insbes. muessten Source-Operanden VOR die0Zieladresse gebastelt werden!0 PROCEDURE AssignCut;  (* Prueft vor "MOVE.x source,(A4)", ob vorher LEA source2,A4 oder#MOVE.L #data,A4 steht; wenn moeglich wird direkte Zuweisung erzeugt.##D0 = zu erzeugender Opcode!*)  BEGIN ASSEMBLER(CMP.B   #7,D7           ;LEA nach A4 ?(BEQ     wasLEA(CMP.B   #8,D7           ;MOVE #data,A4?(BEQ     wasMOVE(MOVE.W  D0,(A4)+(CLR.W   D7(RTS wasLEA  AND.W   #$F03F,D0       ;Destination EA ausblenden(MOVE.W  D7,-(A7)        ;merken wegen Offset-Info(LSR.L   #3,D7           ;Reg und Mode der SourceAdr trennen(AND.L   #$0007E000,D7   ;alles ausser Reg/ModeFeld loeschen(LSR.W   #7,D7           ;Reg an richtiger Position(OR.W    D7,D0(SWAP    D7(LSL.W   #6,D7           ;Mode an richtiger Position(OR.W    D7,D0(MOVE.W  (A7)+,D7(BRA     putOp wasMOVE AND.W   #$F03F,D0       ;Destination EA ausblenden(OR.W    #$0E40,D0       ;"Absolute long" einsetzen putOp   LSR.W   #8,D7           ;ZielAdr fuer Patch berechnen(ADDQ.W  #2,D7(NEG.W   D7(MOVE.W  D0,0(A4,D7.W)   ;und neuen Op eintragen(CLR.W   D7&END END AssignCut; *)  PROCEDURE pushRegs;"BEGIN$ASSEMBLER)(*$C+*))MOVE.L  MM2Comp2.freeVarRegs,D0)BSET    #MM2Comp2.A5,D0  ; das wurde schon gerettet durch LINK)MOVE.L  D0,MM2Comp2.freeVarRegs)JSR     MM2Comp2.saveVarRegs)(*$C=*)$END"END pushRegs;  PROCEDURE popRegs;"BEGIN$ASSEMBLER)(*$C+*))JSR     MM2Comp2.restoreVarRegs)(*$C=*)$END"END popRegs;  PROCEDURE Put6e;        (* UNLINK am Prozedurende *) BEGIN ASSEMBLER (*$ ? Gepard: MOVE.W  #$4E59,(A4)+     ;unlk a1  *)  (*$ ? Atari:  MOVE.W  #$4E5D,(A4)+     ;unlk a5  *).CLR.W   D7 END END Put6e;  PROCEDURE Put6d;        (* Register-Restore am Prozedurende *) BEGIN ASSEMBLER (*$ ? Gepard: MOVE.L  #$4CDF1400,(A4)+ ;movem.l (a7)+,a2/a4   *)  (*$ ? Atari:  JSR     popRegs    *).CLR.W   D7 END END Put6d;  PROCEDURE Put6B; BEGIN ASSEMBLER)MOVE.W  #$4E75,(A4)+  ;RTS)CLR.W   D7 END END Put6B;  PROCEDURE Put6c; BEGIN ASSEMBLER (*$ ? Gepard:)MOVE.W  #$46DF,(A4)+  ;MOVE.W (A7)+,SR  *) (*$ ? Atari:)MOVE.W  #$321F,(A4)+  ;MOVE.W (A7)+,D1)MOVE.L  D3,-(A7))MOVEQ   #36,D3        ;JSR @PRIO)JSR     csp)MOVE.L  (A7)+,D3                       *))CLR.W   D7&END END Put6c;  FORWARD BRAToLabelD0;  PROCEDURE jmpToRet;"BEGIN$ASSEMBLER)MOVE.L  RetAddr,D0)JMP     BRAToLabelD0$END"END jmpToRet;  PROCEDURE PutRET; BEGIN ASSEMBLER)MOVE.L  A4,RetAddr     ;Einsprungadr. f. weitere RETURNs merken))MOVE.L  D0,-(A7))MOVE.L  options,D0)BTST    #12,D0        ;L- schaltet auch SR-Rettung ab!)BEQ     doRTS))TST.W   modflag)BNE     doPrio        ;MODULE BODY  (*$ ? Atari: ; Erst MOVEM, dann Priority, dann UNLK:)MOVE.L  VarA3Ofs,D0   ;ggf. A3 abrÑumen)NEG.L   D0)JSR     putIncA3      ;SUB #<D0>,A3)JSR     put6d         ;gerettete nicht-temp.Regs zurÅck)TST.W   priority)BMI     noPrio)CMPI.W  #1,GLOBAL     ;lokale PROC:)BNE     noPrio        ; Prio bleibt erhalten)JSR     Put6c         ;MOVE.W (a7)+,sr erzeugen !noPrio  JSR     Put6e         ;UNLK *)  (*$ ? Gepard: ; Erst UNLK, dann Priority, dann MOVEM:)JSR     put6e         ;UNLK)TST.W   priority)BMI     noPrio)CMPI.W  #1,GLOBAL     ;lokale PROC:)BNE     noPrio        ; Prio bleibt erhalten)JSR     Put6c         ;MOVE.W (a7)+,sr erzeugen !noPrio  JSR     Put6d         ;MOVEM (A7)+,A2/A4 *))BRA     doRTS) doPrio   ; Body:)TST.W   priority)BMI     doRTS)JSR     Put6c         ;MOVE.W (a7)+,sr erzeugen  !doRTS   ; Bei $E+ TRAP f. Proc-Namensausgabe erzeugen)MOVEQ   #67,D0        ; markiert Exit der Proc)JSR     TraceProc))JSR     Put6b         ;RTS !ready   MOVE.L  (A7)+,D0 END END PutRET;  PROCEDURE Put0; BEGIN ASSEMBLER)MOVE.W  A4,D0)CLR.W   D7)BTST    #0,D0)BEQ     Put01)CLR.B   (A4)+ put01   RTS END END Put0;  PROCEDURE Put2; BEGIN ASSEMBLER)CLR.W   (A4)+)CLR.W   D7&END END Put2;) PROCEDURE Put3; BEGIN ASSEMBLER(CLR.L   (A4)+&END END Put3;  PROCEDURE putIncA3;"BEGIN$ASSEMBLER)TST.L   D0)BEQ.W   incEnd)BMI     doDec))CMPI.L  #8,D0)BHI     noQuick))ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$508B,D0        ;ADDQ #<D0>,A3)MOVE.W  D0,(A4)+)BRA     incEnd  noQuick  CMPI.L  #$7FFE,D0)BHI     noWord)MOVE.W  #$D6FC,(A4)+)MOVE.W  D0,(A4)+         ;ADDA.W #<D0>,A3)BRA     incEnd  noWord   MOVE.W  #$D7FC,(A4)+)MOVE.L  D0,(A4)+         ;ADDA.L #<D0>,A3)BRA     incEnd) doDec    NEG.L   D0)CMPI.L  #8,D0)BHI     noQuickN))ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$518B,D0        ;SUBQ #<D0>,A3)MOVE.W  D0,(A4)+)BRA     incEnd  noQuickN CMPI.L  #$7FFE,D0)BHI     noWordN)MOVE.W  #$96FC,(A4)+)MOVE.W  D0,(A4)+         ;SUBA.W #<D0>,A3)BRA     incEnd  noWordN  MOVE.W  #$97FC,(A4)+)MOVE.L  D0,(A4)+         ;SUBA.L #<D0>,A3) incEnd$END"END putIncA3;  PROCEDURE putIncA7;"BEGIN$ASSEMBLER)TST.L   D0)BEQ.W   incEnd)BMI     doDec))CMPI.L  #8,D0)BHI     noQuick))ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$508F,D0        ;ADDQ #<D0>,A7)MOVE.W  D0,(A4)+)BRA     incEnd  noQuick  CMPI.L  #$7FFE,D0)BHI     noWord)MOVE.W  #$DEFC,(A4)+)MOVE.W  D0,(A4)+         ;ADDA.W #<D0>,A7)BRA     incEnd  noWord   MOVE.W  #$DFFC,(A4)+)MOVE.L  D0,(A4)+         ;ADDA.L #<D0>,A7)BRA     incEnd) doDec    NEG.L   D0)CMPI.L  #8,D0)BHI     noQuickN))ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$518F,D0        ;SUBQ #<D0>,A7)MOVE.W  D0,(A4)+)BRA     incEnd  noQuickN CMPI.L  #$7FFE,D0)BHI     noWordN)MOVE.W  #$9FFC,(A4)+)MOVE.W  D0,(A4)+         ;SUBA.W #<D0>,A7)BRA     incEnd  noWordN  MOVE.W  #$9FFC,(A4)+)MOVE.L  D0,(A4)+         ;SUBA.L #<D0>,A7) incEnd$END"END putIncA7;  PROCEDURE PutLinkWOcopy;"BEGIN$ASSEMBLER); LINK    A5,#0); MOVEM.L A6,-(A7)); MOVE.L  A3,A6); MOVE.L  D2,(A3)+   ; falls lok. Proc); ADDI    #<D0>,A3))MOVE.L  D0,-(A7)))MOVE.W  #$4E55,(A4)+     ;LINK A5,#..)CLR.W   (A4)+))CMPI.W  #1,GLOBAL        ;globale Proc:)BNE     Put501)JSR     SetPriority      ; Prio setzen put501)JSR     pushRegs         ;Reg-Vars und A6 retten)MOVE.W  #$2C4B,(A4)+     ;MOVE.L A3,A6))CMPI.W  #1,GLOBAL        ;globale Proc:)BEQ     Put502           ; kein STAT.LINK)MOVE.W  #$26C2,(A4)+     ;MOVE.L D2,(A3)+)ADDQ.L  #4,VarA3Ofs put502)MOVE.L  (A7)+,D0)JSR     putIncA3         ;ADD #<D0>,A3))CLR.W   D7$END"END PutLinkWOcopy;  PROCEDURE putLink;"BEGIN$ASSEMBLER)CMPI.L  #$FFFF8000,D0)BLT     long0); Short-LINK erzeugen)MOVE.W  #$4E55,(A4)+     ;link a5,#..)MOVE.W  D0,(A4)+)RTS long0    ; Long-LINK erzeugen)MOVE.W  #$2F0D,(A4)+  ;move.l a5,-(a7))MOVE.W  #$2A4F,(A4)+  ;move.l a7,a5)MOVE.W  #$DFFC,(A4)+  ;adda.l #x,a7)MOVE.L  D0,(A4)+$END"END putLink;  PROCEDURE Put5;                 (* LINK am Prozeduranfang *) BEGIN ASSEMBLER); LINK   A5,#<D0>); MOVE.L D2,-(A7)); MOVE.L A7,A2); MOVEM  A6,-(A7)); MOVE.L A2,A6  (*$ ? Gepard:)MOVE.L  #$48E70028,(A4)+ ;movem.l a2/a4,-(a7))CMPI.W  #1,GLOBAL     ;lokale Proc:)BNE     Put502        ; kein Prio setzen)JSR     SetPriority put502   MOVE.W  #$4E51,(A4)+     ;link a1,#..)MOVE.W  D0,(A4)+)CMPI.W  #1,GLOBAL     ;globale Proc:)BEQ     Put501        ; kein STAT.LINK)MOVE.W  #$2F02,(A4)+  ;move.l d2,-(a7) put501   MOVE.W  #$244F,(A4)+  ;move.l a7,a2)CLR.W   D7                             *)) (*$ ? Atari:)JSR     putLink)CMPI.W  #1,GLOBAL     ;globale Proc:)BEQ     Put501        ; kein STAT.LINK)MOVE.W  #$2F02,(A4)+  ;move.l d2,-(a7) put501   MOVE.W  #$244F,(A4)+  ;move.l a7,a2)CMPI.W  #1,GLOBAL     ;lokale Proc:)BNE     Put502        ; kein Prio setzen)JSR     SetPriority put502   JSR     pushRegs      ;Reg-Vars und A6 retten)MOVE.W  #$2C4A,(A4)+  ;move.l a2,a6)CLR.W   D7                             *)&END END Put5;  PROCEDURE Put7; BEGIN ASSEMBLER (*$ ? Gepard: TST.W   D1.BNE     put701.MOVE.W  #$2049,(A4)+  ;move.l a1,a0.BRA     put702 put701        MOVE.W  #$41E9,(A4)+  ;lea [d1](a1),a0.MOVE.W  D1,(A4)+                          *). (*$ ? Atari:  TST.W   D1.BNE     put701.MOVE.W  #$204D,(A4)+  ;move.l a5,a0.BRA     put702 put701        MOVE.W  #$41ED,(A4)+  ;lea [d1](a5),a0.MOVE.W  D1,(A4)+                          *). put702        MOVE.W  D0,D1         ;aus DBF-Count VarSpace zurueckrechnen.ADDQ    #1,D1.LSL.W   #1,D1.CMP.W   #16,D1        ;kurz (ohne Loop kopierbar) ?.BLS     noloop..JSR     Put33w        ;MOVE.L/MOVEQ #,D0.MOVE.W  #$3123,(A4)+  ;move.w -(a3),-(a0).MOVE.L  #$51C8FFFC,(A4)+ ;dbf d0,-4.CLR.W   D7.RTS..; bis zu 16 Bytes mit 4 Moves direkt kopieren  mvLong        MOVE.W  #$2123,(a4)+  ;move.l -(a3),-(a0).SUBQ.W  #4,D1 noloop        CMP.W   #2,D1         ;wieviel noch zu kopieren ?.BCS     mvDone        ;muss Null sein.BHI     mvLong        ;muss >= 4 sein.MOVE.W  #$3123,(a4)+  ;move.w -(a3),-(a0) fuer den Rest mvDone        CLR.W   D7 END END Put7;  PROCEDURE Put8; BEGIN ASSEMBLER)MOVE.W  #$4EB9,(A4)+   ;jsr.l)CLR.W   D7&END END Put8;  PROCEDURE Put25; BEGIN ASSEMBLER)MOVE.W  #$26FC,(A4)+)MOVE.L  D7,Peephole)MOVE.L  #$003C0402,D7 END END Put25;  (* PROCEDURE Put33;                (* move.l #[d0],d0  oder  moveq #[d0],d0 *) BEGIN ASSEMBLER)CMPI.L  #127,D0)BLS     Put3301)CMPI.L  #-127,D0)BCC     Put3301)MOVE.W  #$203C,(A4)+)MOVE.L  D0,(A4)+)CLR.W   D7)RTS put3301  ANDI.W  #$FF,D0)ORI.W   #$7000,D0)MOVE.W  D0,(A4)+)CLR.W   D7&END END Put33; *)  PROCEDURE Put33w;                (* move.w #[d0],d0  oder  moveq #[d0],d0 *) BEGIN ASSEMBLER)CMPI.W  #127,D0)BLS     Put3301)CMPI.W  #-127,D0)BCC     Put3301)MOVE.W  #$303C,(A4)+)MOVE.W  D0,(A4)+)CLR.W   D7)RTS put3301  ANDI.W  #$FF,D0)ORI.W   #$7000,D0)MOVE.W  D0,(A4)+)CLR.W   D7&END END Put33w;  (* PROCEDURE Put38; BEGIN ASSEMBLER$CMPI.B  #1,D7)BEQ     Put3801)CMPI.B  #3,D7)BEQ     Put3802)MOVE.L  #$4A636700,(A4)+       ; TST -(A3)    BEQ ...)CLR.W   D7)RTS put3801  LSR.W   #8,D7)SUBA.W  D7,A4)SWAP    D7)EORI.W  #$6100,D7)MOVE.W  D7,(A4)+)CLR.W   D7)RTS put3802  MOVE.W  #$3023,D0)JSR     MOVECUT)MOVE.W  #$6700,(A4)+)CLR.W   D7 END END Put38; *)  PROCEDURE Put39; BEGIN ASSEMBLER$MOVE.W  #$6000,(A4)+)CLR.W   D7 END END Put39;  (* PROCEDURE Put45; BEGIN ASSEMBLER$MOVE.W  #$2F23,D0)CMPI.B  #2,D7)BNE     L1)JMP     MOVECUT)!L1 MOVE.W  D0,(A4)+)CLR.W   D7 END END Put45; *) PROCEDURE Put46; BEGIN ASSEMBLER$MOVE.W  #$6500,(A4)+)CLR.W   D7 END END Put46; PROCEDURE Put47; BEGIN ASSEMBLER$MOVE.W  #$6200,(A4)+)CLR.W   D7 END END Put47; PROCEDURE Put48; BEGIN ASSEMBLER$MOVE.W  #$6D00,(A4)+)CLR.W   D7 END END Put48; PROCEDURE Put49; BEGIN ASSEMBLER$MOVE.W  #$6E00,(A4)+)CLR.W   D7 END END Put49; PROCEDURE Put50; BEGIN ASSEMBLER$MOVE.W  #$2F0C,(A4)+)CLR.W   D7 END END Put50; (* PROCEDURE Put51; BEGIN ASSEMBLER$MOVE.W  #$285F,(A4)+)CLR.W   D7)TST.L   D1)BMI     Put5103)CMPI.L  #8,D1)BLS     Put5101       ;ADDQ)MOVE.W  #$0694,(A4)+)MOVE.L  D1,(A4)+      ;ADD.L)RTS put5101  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5094,D1)MOVE.W  D1,(A4)+)RTS put5103  NEG.L   D1)CMPI.L  #8,D1)BLS     Put5102       ;SUBQ)MOVE.W  #$0494,(A4)+)MOVE.L  D1,(A4)+)RTS put5102  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5194,D1)MOVE.W  D1,(A4)+ END END Put51; PROCEDURE Put52; BEGIN ASSEMBLER$MOVE.W  #$588F,(A4)+)CLR.W   D7 END END Put52; PROCEDURE Put53; BEGIN ASSEMBLER$MOVE.L  #$2017B094,(A4)+)CLR.W   D7 END END Put53; *)  PROCEDURE Put54; BEGIN ASSEMBLER$MOVE.W  #$6100,(A4)+)CLR.W   D7 END END Put54;  PROCEDURE Put55; BEGIN ASSEMBLER); No valid RETURN (*$ ? Gepard:)MOVE.W  #$4E41,(A4)+   *) (*$ ? Atari:)MOVE.W  #$4E46,(A4)+)MOVE    #-9,(A4)+       *))CLR.W   D7&END END Put55;  PROCEDURE PutTRAPCaseErr; BEGIN ASSEMBLER)MOVE.W  #$4E46,(A4)+)MOVE    #-23,(A4)+)CLR.W   D7&END END PutTRAPCaseErr;  PROCEDURE Put56a;  (* schneller Stackspace-Check *) BEGIN ASSEMBLER)MOVE.L  StackReserve,D1)ADD.L   D0,D1)CMPI.L  #$8000,D1)BCS     lower)MOVE.W  #$207C,(A4)+      ;move.l #xx,a0)MOVE.L  D1,(A4)+)MOVE.W  #$D1CB,(A4)+      ;adda.l a3,a0)BRA     c1'lower)MOVE.W  #$41EB,(A4)+      ;lea xx(a3),a0       ; !tt 28.5.88)MOVE.W  D1,(A4)+'c1)MOVE.W  #$B1CF,(A4)+      ; cmp.l a7,a0 (*$ ? Gepard:)MOVE.L  #$65024E44,(A4)+       *) (*$ ? Atari:)MOVE.L  #$65044E46,(A4)+)MOVE    #-10,(A4)+               *))CLR.W   D7&END END Put56a;  PROCEDURE Put56b;  (* kurzer Stackspace-Check *) BEGIN ASSEMBLER)MOVEM.L D1/D3,-(A7))MOVE.L  StackReserve,D1)ADD.L   D0,D1)CMPI.L  #$240,D0       ;max. 64 Bytes mehr auf Stack?)BHI     varLink        ;nein -> variabler Link)MOVEQ   #41,D3         ;ja -> JSR @STK1: immer $240-Check machen)BRA     cont varLink  CMPI.L  #$8000,D0)BCS     useMoveW)MOVE    #$207C,(A4)+   ;MOVE.L #x,A0)MOVE.L  D0,(A4)+)BRA     call useMoveW MOVE    #$307C,(A4)+   ;MOVE.W #x,A0)MOVE.W  D0,(A4)+ call     MOVEQ   #42,D3         ;JSR @STK2 cont     JSR     csp)MOVEM.L (A7)+,D1/D3 END END Put56b;  PROCEDURE Put66;        (* MOVE.L -(A3),D0 *) BEGIN ASSEMBLER$MOVE.W  #$2023,D0$CMPI.B  #2,D7$BNE     L1$JMP     MOVECUT !L1 MOVE.W  D0,(A4)+$MOVE.L  D7,Peephole$MOVE.L  #$00230009,D7       ;Long Data -(A3) -> D0 END END Put66;  PROCEDURE Put67;        (* MOVE.W -(A3),D0 *) BEGIN ASSEMBLER$MOVE.W  #$3023,D0$CMPI.B  #3,D7$BNE     L1$JMP     MOVECUT !L1 MOVE.W  D0,(A4)+$MOVE.L  D7,Peephole$MOVE.L  #$0023000A,D7       ;Word Data -(A3) -> D0 END END Put67;  PROCEDURE Put69; BEGIN ASSEMBLER)MOVE.W  #$0480,(A4)+   ;sub.l #xx,d0)CLR.W   D7&END END Put69;  PROCEDURE Put70; BEGIN  ASSEMBLER)MOVE.W  #$E348,(A4)+)MOVE.L  #$303B0006,(A4)+)MOVE.L  #$4EFB0002,(A4)+)CLR.W   D7 END END Put70;  (* PROCEDURE Put72;  (* versuchsweise mit Kuerzung des vorletzten Befehls *) BEGIN ASSEMBLER)TST.B   D7)BEQ     nix            ;keine Information)CMPI.B  #2,D7)BNE     L1)MOVE.W  #$2063,D0)JMP     MOVECUT !L1      MOVE.L  Peephole,D0)CMPI.B  #2,D0          ;voriger Befehl 'Long -> EvalStack' ?)BNE     nix)); jetzt Situation vor dem letzten Befehl wiederherstellen))MOVEM.L A4/D7,-(A7)    ;jetzigen Zustand retten)LSR.W   #8,D7          ;Offset zum vorigen Befehl ermitteln)NEG.W   D7)LEA     -2(A4,D7.W),A4 ;das wird der vorgetaeuschte Code-Ptr)MOVE.L  A4,-(A7))MOVE.L  Peephole,D7    ;alte Peephole-Situation erzeugen)CLR.L   Peephole)MOVE.W  #$2063,D0)JSR     MoveCut)CMPA.L  (A7)+,A4       ;hat MoveCut A4 veraendert?)BEQ     noNop)MOVE.W  #$4E71,(A4)    ;ja: weggekuerzten Befehl ueberNOPpen noNop    MOVEM.L (A7)+,D7/A4)RTS nix      MOVE.W  #$2063,(A4)+)CLR.W   D7 END END Put72;  PROCEDURE Put74;"(*%Korrektur von A3 bei StringAssign mit SourceLen < DestLen:%A3 um [D1.L] erhoehen. Wird nur mit geradem D1 aufgerufen.%In der Atari-Version muss zunaechst eine Endmarke 00.W%erzeugt werden, falls der String auf dem Stack noch keine%hat; der restliche Offset wird durch Addition auf A3 erreicht."*) BEGIN ASSEMBLER)TST.L   D1)BEQ     Put7401        ;Offset ist Null (*$ ? Atari:)MOVE.W  #$425B,(A4)+   ;clr.w (a3)+)SUBQ.L  #2,D1)BEQ     Put7401        ;das war alles          *))CMPI.L  #$7FFF,D1)BHI     LongOff        ;Offset passt nicht in ein Wort)MOVE.W  #$D6FC,(A4)+   ;adda.w #data,a3)MOVE.W  D1,(A4)+)BRA     put7402 LongOff  MOVE.W  #$D7FC,(A4)+   ;adda.l #data,a3)MOVE.L  D1,(A4)+ put7402  CLR.W   D7 put7401)END END Put74; *)  PROCEDURE PutDebug; BEGIN ASSEMBLER (*$ ? Gepard:)ANDI.W  #$F,D0)ORI.W   #$4E40,D0)MOVE.W  D0,(A4)+      ;TRAP #<D0>)CLR.W   D7                             *) (*$ ? Atari:)MOVE    #$4E45,(A4)+)MOVE    D0,(A4)+)CLR     D7                             *)&END END PutDebug;  (* PROCEDURE Put77; BEGIN ASSEMBLER)MOVE.W  #$6400,(A4)+)CLR.W   D7&END END Put77;  PROCEDURE Put78; BEGIN ASSEMBLER)MOVE.W  #$6800,(A4)+   ; BVC)CLR.W   D7&END END Put78; *)  PROCEDURE Put79; BEGIN ASSEMBLER)MOVE.W  #$0C40,(A4)+   ; CMPI.W)CLR.W   D7&END END Put79;  PROCEDURE Put79b; BEGIN ASSEMBLER)MOVE.W  #$0C80,(A4)+   ; CMPI.L)CLR.W   D7&END END Put79b;  PROCEDURE Put80; BEGIN ASSEMBLER); SUBI.W #_,D0)MOVE.W  #$0440,(A4)+)CLR.W   D7&END END Put80;  PROCEDURE PutSubIW_D0; (* SUB.W #<D0>,D0 *)"BEGIN$ASSEMBLER)TST.W   D0)BEQ     nothing)CMPI.W  #8,D0)BLS     quick)JSR     Put80)MOVE.W  D0,(A4)+)RTS'quick)ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$5140,D0        ;SUBQ.W #<D0>,D0)MOVE.W  D0,(A4)+'nothing)CLR.W   D7$END"END PutSubIW_D0;  PROCEDURE PutSubIL_D0; (* SUB.L #<D0>,D0 *)"BEGIN$ASSEMBLER)TST.L   D0)BEQ     nothing)CMPI.L  #8,D0)BLS     quick)JSR     Put69)MOVE.L  D0,(A4)+)RTS'quick)ANDI.W  #7,D0)LSL.W   #8,D0)LSL.W   #1,D0)ORI.W   #$5180,D0        ;SUBQ.L #<D0>,D0)MOVE.W  D0,(A4)+'nothing)CLR.W   D7$END"END PutSubIL_D0;" (* PROCEDURE Put81;        (* WITH-Kopf *) BEGIN ASSEMBLER.MOVE.W  #$2F23,D0      ;move.l -(a3),-(a7).CMPI.B  #2,D7.BNE     Put8101.JSR     MOVECUT.BRA     Put8102 put8101       MOVE.W  D0,(A4)+ put8102 (*$ ? Gepard: MOVE.L  #$2F0A244F,(A4)+ ;move.l a2,-(a7); move.l a7,a2 *) (*$ ? Atari:  MOVE.L  #$2F0E2C4F,(A4)+ ;move.l a6,-(a7); move.l a7,a6 *).CLR.W   D7&END END Put81;  PROCEDURE Put82;        (* WITH-Ende *) BEGIN ASSEMBLER (*$ ? Gepard: MOVE.L  #$245F588F,(A4)+  ;move.l (a7)+,a2; addq.l #4,a7 *) (*$ ? Atari:  MOVE.L  #$2C5F588F,(A4)+  ;move.l (a7)+,a6; addq.l #4,a7 *).CLR.W   D7&END END Put82;  PROCEDURE Put85; BEGIN ASSEMBLER)MOVE.W  #$3F23,D0      ;move.w -(a3),-(a7))CMPI.B  #3,D7)BNE     L1)JMP     MOVECUT)!L1 MOVE.W  D0,(A4)+)CLR.W   D7%END END Put85;  PROCEDURE Put86; BEGIN ASSEMBLER)MOVE.L  #$3017B054,(A4)+)CLR.W   D7&END END Put86;  PROCEDURE Put87; BEGIN ASSEMBLER)MOVE.W  #$285F,(A4)+)CLR.W   D7)TST.W   D1)BMI     Put8703)CMPI.W  #8,D1)BLS     Put8701       ;ADDQ)MOVE.W  #$0654,(A4)+)MOVE.W  D1,(A4)+      ;ADD.W)RTS put8701  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5054,D1)MOVE.W  D1,(A4)+)RTS put8703  NEG.W   D1)CMPI.W  #8,D1)BLS     Put8702       ;SUBQ)MOVE.W  #$0454,(A4)+)MOVE.W  D1,(A4)+)RTS put8702  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5154,D1)MOVE.W  D1,(A4)+ END END Put87;  PROCEDURE Put88; BEGIN ASSEMBLER$MOVE.W  #$548F,(A4)+)CLR.W   D7 END END Put88;  PROCEDURE Put106; BEGIN ASSEMBLER#MOVE.W  #$5250,(A4)+)CLR.W   D7 END END Put106; PROCEDURE Put107; BEGIN ASSEMBLER#MOVE.W  #$5290,(A4)+)CLR.W   D7 END END Put107; PROCEDURE Put108; BEGIN ASSEMBLER#MOVE.W  #$D150,(A4)+)CLR.W   D7 END END Put108; PROCEDURE Put109; BEGIN ASSEMBLER#MOVE.W  #$D190,(A4)+)CLR.W   D7 END END Put109; PROCEDURE Put110; BEGIN ASSEMBLER#MOVE.W  #$5350,(A4)+)CLR.W   D7 END END Put110; PROCEDURE Put111; BEGIN ASSEMBLER#MOVE.W  #$5390,(A4)+)CLR.W   D7 END END Put111; PROCEDURE Put112; BEGIN ASSEMBLER#MOVE.W  #$9150,(A4)+)CLR.W   D7 END END Put112; PROCEDURE Put113; BEGIN ASSEMBLER#MOVE.W  #$9190,(A4)+)CLR.W   D7 END END Put113; PROCEDURE Put114; BEGIN ASSEMBLER#MOVE.W  #$4280,(A4)+)CLR.W   D7 END END Put114; *)  PROCEDURE Put118; BEGIN ASSEMBLER#MOVE.W  #$DEFC,(A4)+)CLR.W   D7 END END Put118;  (* PROCEDURE Put126; BEGIN ASSEMBLER#JSR     Put67$MOVE.W  #$48C0,(A4)+$CLR.W   D7 END END Put126; *)  PROCEDURE Put128; BEGIN ASSEMBLER#MOVE.W  #$36C0,(A4)+$MOVE.L  D7,Peephole$MOVEQ   #3,D7 END END Put128;  (* PROCEDURE Put142; BEGIN ASSEMBLER)CLR.W   D7)SUBQ.W  #1,D0)BCS     Put1421         ;LOKAL)BEQ     Put1422         ;GLEICHE EBENE  (*$ ? Gepard:)MOVE.W  #$2052,(A4)+    ;move.l (a2),a0 put1423  SUBQ.W  #1,D0)BEQ     Put1424)MOVE.W  #$2050,(A4)+    ;move.l (a0),a0)BRA     Put1423 put1424  MOVE.W  #$2410,(A4)+    ;move.l (a0),d2)RTS put1421  MOVE.W  #$240A,(A4)+    ;move.l a2,d2)RTS put1422  MOVE.W  #$2412,(A4)+    ;move.l (a2),d2 *)  (*$ ? Atari:)MOVE.W  #$2056,(A4)+    ;move.l (a6),a0 put1423  SUBQ.W  #1,D0)BEQ     Put1424)MOVE.W  #$2050,(A4)+    ;move.l (a0),a0)BRA     Put1423 put1424  MOVE.W  #$2410,(A4)+    ;move.l (a0),d2)RTS put1421  MOVE.W  #$240E,(A4)+    ;move.l a6,d2)RTS put1422  MOVE.W  #$2416,(A4)+    ;move.l (a6),d2 *) &END END Put142; *)  PROCEDURE Put146; BEGIN ASSEMBLER (*$ ? Gepard:(MOVE.W   #$40E7,(A4)+  ;MOVE SR,-(A7)(MOVE.W   #$007C,(A4)+  ;ORI #data,SR(MOVE.W   #$0700,(A4)+  ;erst mal hoechste Prioritaet setzen(MOVE.W   #$027C,(A4)+  ;ANDI #data,SR(AND.W    #7,D0         ;D0 enthaelt das Interrupt-Level(LSL.W    #8,D0(OR.W     #$F8FF,D0     ;alle anderen Bits leben lassen(MOVE.W   D0,(A4)+ *) (*$ ? Atari:(MOVE.W   #$40E7,(A4)+  ;MOVE SR,-(A7)(AND.W    #7,D0         ;D0 enthaelt das Interrupt-Level(LSL.W    #8,D0(MOVE.W   #$323C,(A4)+  ;MOVE.W #x,D1(MOVE.W   D0,(A4)+(MOVEQ    #36,D3        ;JSR @PRIO(JSR      csp *)(CLR.W    D7&END END Put146;  (* PROCEDURE Put147;   (* Konfigurations-Dummy, bei $K+ am ModulRumpf-Anfang *) BEGIN ASSEMBLER)MOVE.L  #$60000004,(A4)+ ;bra.l +4)MOVE.W  #$4E75,(A4)+     ;rts)CLR.L   D7 END END Put147; *)  PROCEDURE Put151;  (* Restore A2/A6 bei EXIT aus WITH *) BEGIN ASSEMBLER (*$ ? Gepard: MOVE.W  #$246F,(A4)+     ;movea.w [d0] (a7),a2 *) (*$ ? Atari:  MOVE.W  #$2C6F,(A4)+     ;movea.w [d0] (a7),a6 *).MOVE.W  D0,(A4)+.CLR.W   D7&END END Put151;  PROCEDURE Put203;   (* Expand Byte to Word *) BEGIN ASSEMBLER)JSR     put216           ;pull byte -> D0)MOVE.L  #$024000FF,(A4)+ ;andi.w #$ff,d0)CLR.W   D7)JMP     put128           ;move.w d0,(a3)+&END END Put203;  (* PROCEDURE Put205;   (* Inc (Byte) *) BEGIN ASSEMBLER(MOVE.W  #$5210,(A4)+    ;addq.b #1,(a0)(CLR.W   D7&END END Put205;  PROCEDURE Put206;   (* Dec (Byte) *) BEGIN ASSEMBLER(MOVE.W  #$5310,(A4)+    ;subq.b #1,(a0)(CLR.W   D7&END END Put206;  PROCEDURE Put207;   (* Inc (Byte, x) *) BEGIN ASSEMBLER(MOVE.W  #$D110,(A4)+    ;add.b d0,(a0)(CLR.W   D7&END END Put207;  PROCEDURE Put208;   (* Dec (Byte, x) *) BEGIN ASSEMBLER(MOVE.W  #$9110,(A4)+    ;sub.b d0,(a0)(CLR.W   D7&END END Put208;  PROCEDURE Put210;   (* FOR-LaufVar inkr/dekr. (Bytes) *) BEGIN ASSEMBLER)MOVE.W  #$285F,(A4)+  ;move.l (a7)+,a4)CLR.W   D7)TST.W   D1)BMI     Put8703       ;Step ist negativ: SUBs erzeugen)CMPI.W  #8,D1)BLS     Put8701       ;addq tut's auch ->)MOVE.W  #$0614,(A4)+  ;add.b [d1],(a4))MOVE.W  D1,(A4)+)RTS put8701  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5014,D1     ;addq.b #[d1],(a4) wird gebastelt)MOVE.W  D1,(A4)+)RTS put8703  NEG.W   D1)CMPI.W  #8,D1)BLS     Put8702       ;subq tut's auch ->)MOVE.W  #$0414,(A4)+  ;sub.b [d1],(a4))MOVE.W  D1,(A4)+)RTS put8702  ANDI.W  #7,D1)LSL.W   #8,D1)LSL.W   #1,D1)ORI.W   #$5114,D1     ;subq.b #[d1],(a4) wird gebastelt)MOVE.W  D1,(A4)+&END END Put210;  PROCEDURE Put213;   (* FOR-LaufVar mit Obergrenze vergleichen *) BEGIN ASSEMBLER)MOVE.L  #$3017B014,(A4)+  ;move.w (a7),d0 ;  cmp.b (a4),d0)CLR.W   D7&END END Put213; *)  PROCEDURE put216;       (* Pull Byte -(A3) -> D0 *) BEGIN ASSEMBLER)MOVE.W  #$1023,D0      ;move.b -(a3),d0)CMP.B   #12,D7         ;war move.b source,(a3)+ ?)BNE     put4201)JSR     MoveCut)SUBQ.L  #2,A4          ;clr.b (a3)+ loeschen)RTS put4201  MOVE.W  #$538B,(A4)+   ;subq.l #1,a3)MOVE.W  D0,(A4)+)CLR.W   D7&END END put216;  PROCEDURE STPROC;"BEGIN$ASSEMBLER)ACZ     '@LREQ'        ; 0)ACZ     '@LRNE')ACZ     '@LRLE')ACZ     '@LRGE')ACZ     '@LRLT')ACZ     '@LRGT')ACZ     '@LNEG')ACZ     '@LADD'        ; 7)ACZ     '@LSUB'        ; 8)ACZ     '@IMUL')ACZ     '@CMUL')ACZ     '@LMUL'        ; 11)ACZ     '@IDIV')ACZ     '@CDIV')ACZ     '@LDIV'        ; 14)ACZ     '@IMOD')ACZ     '@CMOD')ACZ     '@STAS')ACZ     '@FNUL'        ; 18)ACZ     '@ICHK')ACZ     '@CCHK'        ; 20)ACZ     '@WCHK')ACZ     '@INCL'        ; 22)ACZ     '@EXCL')ACZ     '@STOL'        ; 24)ACZ     '@LTOS')ACZ     '@FOPS'        ; 26)ACZ     '@FOPD'        ; 27)ACZ     '@SMEM')ACZ     '@SEQL')ACZ     '@SNEQ'        ; 30)ACZ     '@SLEQ')ACZ     '@SGEQ')ACZ     '@TRAN')ACZ     '@IOTR')ACZ     '@NEWP')ACZ     '@PRIO')ACZ     '@COPY'        ;Open Array umkopieren)ACZ     '@COPS'        ;Open Array umkopieren, dabei TOS.L retten)ACZ     '@LSTN')ACZ     '@IOCA'        ; 40)ACZ     '@STK1'        ;Entry-Code f. Prozeduren, mit 0-Link)ACZ     '@STK2'        ;Entry-Code f. Prozeduren)ACZ     '@RES1')ACZ     '@RES2')ACZ     '@RES3')ACZ     '@RES4')ACZ     '@RES5')ACZ     '@RES6')ACZ     '@RES7')ACZ     '@IMLW'        ; 50)ACZ     '@CMLW')ACZ     '@IDVW')ACZ     '@CDVW')ACZ     '@IMDW')ACZ     '@CMDW')ACZ     '@IMLL'        ; 56)ACZ     '@CMLL')ACZ     '@IDVL')ACZ     '@CDVL')ACZ     '@IMDL')ACZ     '@CMDL')ACZ     '@PS3B'        ; 62)ACZ     '@PS3W')ACZ     '@PS3L')ACZ     '@PS7B')ACZ     '@PS7W')ACZ     '@PS7L')ACZ     '@COPW'        ; 68)ACZ     '@COPL'        ; 69)ACZ     '@CAP' DC.B 0  ; 70)ACZ     '@LENW'        ; 71)ACZ     '@LENL'        ; 72)ACZ     '@SAND'        ; 73)ACZ     '@SXOR')ACZ     '@SSUM')ACZ     '@SDIF')ACZ     '@SAN1'        ; 77)ACZ     '@SXO1')ACZ     '@SSU1')ACZ     '@SDI1')ACZ     '@SAN2'        ; 81)ACZ     '@SXO2')ACZ     '@SSU2')ACZ     '@SDI2'        ; 84)ACZ     '@FMVS'        ; 85)ACZ     '@FMVD'        ; 86)ACZ     '@FCPN'        ; 87)ACZ     '@FCPS'        ; 88)ACZ     '@FCPD'        ; 89)ACZ     '@VFPU'        ; 90)ACZ     '@LABS'        ; 91)ACZ     '@SNEG'        ; 92)ACZ     '@SABS'        ; 93)ACZ     '@SADD')ACZ     '@SSUB')ACZ     '@SMUL')ACZ     '@SDIV')ACZ     '@SRLE')ACZ     '@SRGE')ACZ     '@SRLT')ACZ     '@SRGT'        ; 101)ACZ     '@LC2S'        ; 102)ACZ     '@LI2S'        ; 103)ACZ     '@LC2D'        ; 104)ACZ     '@LI2D'        ; 105)ACZ     '@S2LC'        ; 106)ACZ     '@S2LI'        ; 107)ACZ     '@D2LC'        ; 108)ACZ     '@D2LI'        ; 109)ACZ     '@SIRG'        ; 110)ACZ     '@CWOP'        ; 111)ACZ     '@CLOP'        ; 112)ACZ     '@FP7S'        ; 113)ACZ     '@FP7D'        ; 114)ACZ     '@FP3S'        ; 115)ACZ     '@FP3D'        ; 116)ACZ     '@FG7S'        ; 117)ACZ     '@FG7D'        ; 118)ACZ     '@FG3S'        ; 119)ACZ     '@FG3D'        ; 120)ACZ     '@FP7M'        ; 121)ACZ     '@FG7M'        ; 122)ACZ     '@ROTA'        ; 123)ACZ     '@SHFT'        ; 124 $END"END STPROC;  FORWARD CSP1; PROCEDURE CSP; BEGIN ASSEMBLER  MULU    #6,D3)LEA     STPROC,A0)ADDA.L  D3,A0)JMP     CSP1 END END CSP;  PROCEDURE CSP1; BEGIN ASSEMBLER)MOVE.L  A0,-(A7))JSR     SearchID)MOVE.L  (A7)+,A0)CMPI.B  #6,D3         ;PROC?)BEQ     OK1))MOVE.L  A0,A2)LEA     BadId,A0)MOVEQ   #0,D0          ; optional Term-Char)MOVEQ   #40,D2         ; max. Length)JSR     FetchString)MOVE    #rNoRun,D5    ;NOT AVAILABLE)JMP     SyntaxErr!!!OK1    JSR     Put8          ;JSR.L)MOVE.L  A4,D0)SUB.L   CodeStart,D0       ;REL ^REFERENZ)MOVE.L  -18(A1,D2.L),(A4)+ ;Put RELOC LINK)MOVE.L  D0,-18(A1,D2.L)    ;NEUER LINK END END CSP1;) PROCEDURE ALLOC; BEGIN ASSEMBLER (*$ ? Gepard:(ACZ     'Allocate'      *) (*$ ? Atari:(ACZ     'ALLOCATE'      *)(SYNC&END END ALLOC;  PROCEDURE DEALL; BEGIN ASSEMBLER (*$ ? Gepard:(ACZ     'DeAllocate'    *) (*$ ? Atari:(ACZ     'DEALLOCATE'    *)(SYNC&END END DEALL;  PROCEDURE CALLAL; BEGIN ASSEMBLER)LEA     ALLOC,A0)JMP     CSP1&END END CALLAL;  PROCEDURE CALLDEAL; BEGIN  ASSEMBLER)LEA     DEALL,A0)JMP     CSP1'END END CALLDEAL; 
(* $FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158Ä$00008AF1T.......T.......T.......T.......T.......T.......T.......T.......T.......T.......$FFED5158$00008FF1$00008AF1$00008B1E$00008B2C$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158$FFED5158îÄÉ*)
