 MODULE T; (*$M-, E MOS, N- *)  (*$^+*)  (* IMPORT TOSDebug; IMPORT TOSIO, InOut; *) IMPORT FileNames; FROM MOSGlobals IMPORT SfxStr, PfxStr, NameStr; FROM SYSTEM IMPORT ADDRESS, ADR, TSIZE, BYTE, WORD, LONGWORD; FROM SYSTEM IMPORT ASSEMBLER,(CALLSYS, CALLEXT, DEREF, CADR, LOC, CAST, ROTATE, SHIFT,(BITNUM, LOAD, STORE, CODE; FROM Strings IMPORT Length, String; FROM Terminal IMPORT WriteLn, WriteString, Write, Read; FROM Convert  IMPORT ConvReal, ConvFix, ConvFloat, ConvEng, ConvInt, ConvLHex; FROM StrConv  IMPORT StrToReal, StrToCard; FROM SysUtil0 IMPORT VarEqual; IMPORT RandomGen; FROM GEMEnv IMPORT GDOSAvailable; (* FROM Loader IMPORT Monitor; IMPORT SFP004; FROM RealCtrl IMPORT RealFormat, LargeREAL, AnyRealFormat; FROM MathLib0 IMPORT cos, ln, e, pi, rad, ld, log, sin, entier, real, arcsin,(pwrOfTen; IMPORT FPUSupport; *)   TYPE MYREAL = LONGREAL;  VAR saveA3: LONGCARD; PROCEDURE enter; (*$L-*) BEGIN ASSEMBLER MOVE.L  A3,saveA3 END END enter; (*$L=*) PROCEDURE exit; (*$L-*) BEGIN ASSEMBLER CMPA.L saveA3,A3 BEQ ok JSR HALT ok END END exit; (*$L=*)  TYPE SCH = [' '..'9'];%TS = ARRAY [0..8] OF CHAR;%FSS= ARRAY [0..2] OF ARRAY [0..8] OF CHAR;%SS = ARRAY [1..3] OF TS;%TSG= ARRAY [0..9] OF CHAR;%VS = ARRAY [0..18] OF CHAR;%LS = ARRAY [0..22] OF CHAR;%SSG= ARRAY [1..3] OF TSG;%SS1 = ARRAY [1..1] OF TS;%LSS = ARRAY [1..3] OF LS;%AVL = ARRAY [0..9] OF LONGCARD;%AVS = ARRAY [0..1] OF VS;%AAVS = ARRAY [0..1] OF AVS;%AAAVS = ARRAY [0..1] OF AAVS;%PCARD = POINTER TO CARDINAL;%(*$U-*)%LGS = SET OF [0..31];%(*$U+*)%LGS2= SET OF [0..31];%BS = SET OF [0..7];%LBS= SET OF [0..63];%XBS= SET OF [0..1023];%LGARR = ARRAY [1..2] OF ARRAY [0L..$10200] OF RECORD a,b,c: CARDINAL END;%WS = SET OF [0..15];%AR = RECORD c: CARDINAL; a:ARRAY [0..8] OF CARDINAL; b: CHAR; p: PROC END;%SUBR = [0..23];   CONST"c1 = -2 + TSIZE (TS) + (MAX (INTEGER))'+ INT (LONG (ORD (CHR (1))))'- 256 * MIN (INTEGER)'- 249 - 257 * MAX (INTEGER);'(* 'c1' ist 'ZZ'-Typ -- zwar erzeugt ORD einen CARDINAL, LONG (CARDINAL)(* wiederum erzeugt aber den BothTyp *)"c2 = INT(2);  VAR ss: SS;$bs: BS;$fss: FSS;$ssg: SSG;$tsg: TSG;$vs: VS;$ss1: SS1;$lss: LSS;$lgs: LGS;$lgs2: LGS2;$ir: [-3..4];$sr2: [0..4];$sr3: [5..6];$en1: (null, eins, zwei, drei, vier);$en2: [eins..drei];$avl: AVL;$avs: AVS;$aavs: AAVS;$aaavs: AAAVS;$axl: ARRAY [0..333] OF LONGCARD;$sch: SCH;$byte: BYTE;$(* lgArr: LGARR; *)$c, card: SHORTCARD;$d: CARDINAL;$ch,ch2,ch3: CHAR;$xls: ARRAY [0..70001] OF CHAR;$str: String;$addr: ADDRESS;$i: INTEGER;$ls: LS;$pls: POINTER TO LS;$li: LONGINT;$l, lc:LONGCARD;$lw: LONGWORD;$bs1: BITSET;$bs2: BITSET;$bys1, bys2: BS;$pc: PCARD;$ls1, ls2: LBS;$xs1: XBS;$word: WORD;$s4: ARRAY [0..3] OF CHAR;$s3: ARRAY [0..2] OF CHAR;$s2: ARRAY [0..1] OF CHAR;$s1: ARRAY [0..0] OF CHAR;$ac: ARRAY [0..3] OF CARDINAL;$achc: ARRAY CHAR OF CARDINAL;$al: ARRAY [0..3] OF LONGCARD;$ar: AR;$arp: POINTER TO AR;$br: RECORD d,e: CARDINAL END;$cr: RECORD f,g,h: CHAR END;$dr: RECORD i,j: CHAR END;$ad: ADDRESS;$ptrad: POINTER TO ADDRESS;$p1, p2: PROC;$s: TS;$b: BOOLEAN;$ps: POINTER TO TS;$mr, mr2: MYREAL;$lr,lr2: LONGREAL;$sr: REAL;$mra: ARRAY [0..5] OF MYREAL;$sfx: SfxStr;$pfx: PfxStr;$name, name2: NameStr;  PROCEDURE wrReal (rrrr: LONGREAL; n: CARDINAL);"VAR sss: ARRAY [0..30] OF CHAR;"BEGIN$IF n=0 THEN n:= 14 END;$(*$ConvFix (rrrr, 24, n, sss);$WriteString (sss);$Write (' ');$*)$ConvFloat (rrrr, 23, n, sss);$WriteString (sss);$Write (' ');$ConvEng (rrrr, 23, n, sss);$WriteString (sss);$WriteLn;"END wrReal;  PROCEDURE wrHex (lw: LONGWORD);"VAR sss: ARRAY [0..30] OF CHAR;"BEGIN$Write (' ');$ConvLHex (lw, 9, sss);$WriteString (sss);"END wrHex;  PROCEDURE toReal (REF ssss: ARRAY OF CHAR): LONGREAL;"VAR ok: BOOLEAN; pos: CARDINAL;"BEGIN$pos:= 0;$RETURN StrToReal (ssss, pos, ok)"END toReal;  PROCEDURE f(): TS;"BEGIN$RETURN s"END f;  PROCEDURE f5 (VAR c: LS): LONGCARD;"BEGIN$RETURN 0"END f5;  PROCEDURE pch(c: CHAR);"END pch;  PROCEDURE pvch(VAR c: CHAR);"END pvch;  PROCEDURE prch(REF c: CHAR);"BEGIN$(*$W-*)$pvch (c)$(*$W=*)"END prch;  PROCEDURE fch(): CHAR;"BEGIN$RETURN ch"END fch;  PROCEDURE fsg (): TSG;"BEGIN$RETURN tsg"END fsg;  PROCEDURE f2 (): CARDINAL;"BEGIN$RETURN c"END f2;  PROCEDURE op2(b:BOOLEAN; s: ARRAY OF CHAR);"END op2;  PROCEDURE op4(REF s0: ARRAY OF CHAR);"BEGIN$ASSEMBLER BREAK END;$ch:= s0[c];$ad:= CADR (s0);$(*&op2 (b, s0);&s0[0]:= '4';&ad:= ADR (s0);$*)"END op4;  (* PROCEDURE val(s: TS);"END val;  PROCEDURE f3(): LBS;"BEGIN$RETURN ls1"END f3;  PROCEDURE f3b(): BS;"BEGIN$RETURN bs"END f3b;  PROCEDURE f4(): BITSET;"BEGIN$RETURN bs1"END f4;  PROCEDURE f4w(): WS;"VAR ws: WS;"BEGIN$RETURN ws"END f4w;  PROCEDURE op5 (s: ARRAY OF TS): CARDINAL;"BEGIN$RETURN c"END op5;  PROCEDURE fcp(): PCARD;"BEGIN$RETURN pc"END fcp;  PROCEDURE op (s: ARRAY OF TS);"END op;  PROCEDURE op3(s: ARRAY OF TS);"BEGIN$ASSEMBLER BREAK END;$IF HIGH (s) = 0 THEN c:=c END;"END op3;  PROCEDURE opla (ls: LONGARRAY OF CHAR);"BEGIN$ASSEMBLER BREAK END;$IF HIGH (ls) = 0 THEN c:=c END;"END opla;  PROCEDURE mc0 (a: TS);"END mc0; PROCEDURE mc1 (a,b,c: TS);"END mc1; PROCEDURE mc2 (a,b,c: LS);"END mc2;  (* PROCEDURE glob;"VAR r: RECORD a,b,c: ARRAY [-$4000..$4800] OF CARDINAL; END;&mem[0]: ARRAY [0..MAX(LONGCARD)] OF BYTE;"BEGIN$ASSEMBLER BREAK END;$byte:= mem[li];"END glob;  VAR pb: POINTER TO BOOLEAN; PROCEDURE XOR (b: BOOLEAN): BOOLEAN; BEGIN RETURN b END XOR;  VAR arr: ARRAY [-10..50000] OF CHAR; CONST HexDigits = '0123456789abcdef';  PROCEDURE hi (REF d: ARRAY OF WORD);"BEGIN$ASSEMBLER BREAK END;$c:= CARDINAL (d [0]);$hi (d);"END hi;  TYPE A = ARRAY [1..20000] OF CARDINAL; TYPE A2 = ARRAY [1..2] OF A; VAR a: A; a2: A2;  PROCEDURE pA (c: ARRAY OF A);"END pA;  PROCEDURE sf (): BS;"BEGIN$RETURN bys1"END sf;  VAR globvar(*$Reg*): CARDINAL;  PROCEDURE pp ( (*$Reg*)a0,(*$Reg*)a1,(*$REG*)a2: CARDINAL; (*$reg*)p0:PCARD);"VAR (*$REG*)c1, (*$REG*)c2, (*$REG*)c3: CARDINAL;&p1: PCARD;""PROCEDURE pl (VAR cl1: CARDINAL);$END pl; "BEGIN$ASSEMBLER(BREAK(; JSR     f2/$END;$$i:= -1;$i:= i * 3;$$LOOP&FOR c:= 1 TO f2()+2 DO(EXIT;(RETURN&END$END;$RETURN;$$(*$WITH ar DO&c2:= 0;&pl (c1);$END;$c1:= a0;$a1:= c1;$c1:= a0;$c1:= a2;$FOR c2:= 1 TO 4 DO END;$FOR c2:= 1 TO 4 DO c1:= c2 END;$c1:=1;$a0:=1;$p0^:= a0;$INC (p0, 2);$p0^:= a0;$FOR c:= 1 TO 4 DO c2:= 11; c2:= c END;$FOR c2:= 1 TO 4 DO END;$FOR c2:= 1 TO 4 DO c:= c2 END;$*)"END pp; "pp (1,2,3,NIL); *)   TYPE MYBITNUM = BITNUM[0..15];%MYBITSET = SET OF MYBITNUM; VAR bin: MYBITNUM;$bytebitset: SET OF BITNUM[0..7];$wordbitset: MYBITSET;$bitset: SET OF BITNUM;  PROCEDURE f4c (): MYBITSET;"BEGIN$RETURN wordbitset"END f4c;"  (* VAR pr: PROC; (*$H+*) PROCEDURE ppp (p: PROC);"PROCEDURE pro; END pro;"BEGIN$ASSEMBLER BREAK END;$pro ();$RETURN;$p();$ppp (pro);$pr:= p;$p:= pr;"END ppp; *)  (* FORWARD-Test fÅr beide Syntax: PROCEDURE pr2;"PROCEDURE pr1;"FORWARD;"FORWARD pr3;"PROCEDURE pr4;$BEGIN pr3 END pr4;"PROCEDURE pr1;"FORWARD;"PROCEDURE pr1;"FORWARD;"PROCEDURE pr3;$END pr3;"PROCEDURE pr1; END pr1;"BEGIN pr1; pr4 END pr2; *)  (* PROCEDURE sss;"VAR bs (*$Reg*): SET OF BITNUM[0..15];"BEGIN$INCL (bs, 4);$b:= 3 IN bs"END sss; *)  CONST bs1c = {0,6..7,1};&ms1c = MYBITSET {0,6..7,1};  (* PROCEDURE pp2 (VAR p2: PROC);"END pp2; (*$H+*) PROCEDURE ppc (p: PROC);"BEGIN$pp2 (p)"END ppc; PROCEDURE pro; END pro; *)  PROCEDURE conc (a,b: ARRAY OF CHAR): String;"BEGIN RETURN str END conc;  PROCEDURE op0 (s: ARRAY OF CHAR);"BEGIN$ASSEMBLER BREAK END;$op0 (s)"END op0; *)  CONST"cav3 = AVS{'<11111111111111111', '222222222222222222>'};"cl1 = LSS {'111111111111111111', '3333333', ''};"cs1 = SS {'11111111', '22', '3333333'};"cs2 = SS {'11111111', '2222222', '3'};"cs3 = SS {'11', '22', '333333'}; (* << '22' muû byteweise kopiert werden *)"cs4 = SS {'111', '22222222', '33333333'};"cs5 = SS {'11111111', '22222222', '33333333'};"cs6 = SS {'11111111', '22', '33333333'};"cs7 = SS {'111', '22', '333'};"cav1 = AVL {1,2,3,4,5,6,7L,8,9,1000000};"cav2 = AVL {19*10-189,2,3,4,5,6,7L,8,9,1000000};"caaavs = AAAVS {AAVS {AVS{'<11111111111111111', '222222222222222222>'}, AVS{'<11111111111111111', '222222222222222222>'}}, AAVS {AVS{'<11111111111111111', '222222222222222222>'}, AVS{'<11111111111111111', '222222222222222222>'}}};"cl2 = LSS {'111111111111111111', '3333333', '444444444444444444444'};  PROCEDURE oa(REF s: ARRAY OF CARDINAL);"BEGIN$(*$R+*)$ASSEMBLER BREAK END;$c:= s[0];$c:= s[c];$(*$R=*)"END oa;  PROCEDURE rr;"(* Test fÅr Real-RegVars *)"PROCEDURE rl;$VAR (*$Reg*)r0, (*$Reg*)r1: LONGREAL;$BEGIN&ASSEMBLER BREAK END;&r0:= 1.;&r0:= r0+r0*r0;&r1:= r0*r0/3.;$END rl;"VAR r1, (*$Reg*)r2, (*$Reg*)r3: LONGREAL;"BEGIN$rl;$r1:= 1.;$r2:= 2.;$lr:= r1;$lr:= r2;$r1:= lr;$r2:= lr*lr;$r3:= 3.*r2;$IF r2 # 1. THEN HALT END;$IF r3 # 3. THEN HALT END;"END rr;  TYPE PtrToChar = POINTER TO CHAR;  PROCEDURE local (s: TS);"VAR x,i: CARDINAL; w: WORD;&l: LONGCARD;&rec:RECORD dummy:CARDINAL; s: TS END;"BEGIN$ASSEMBLER BREAK END;$(*$A+*)$pvch(CHAR(CAST(PtrToChar,l)^));$WORD(x):= w;$(*!!! das kann er noch nicht:&CAST(WORD,x):= w;$*)$(*$A=*)"END local;  (* MODULE localMod [4];"IMPORT ASSEMBLER;"EXPORT locProc2,locProc;"PROCEDURE locProc (c: CARDINAL);$PROCEDURE loc(c:CARDINAL);&BEGIN(IF c = 1 THEN END&END loc;$BEGIN&ASSEMBLER BREAK END;&loc(1);$END locProc;"PROCEDURE locProc2 (c: CARDINAL): CARDINAL;$BEGIN RETURN 1 END locProc2;"END localMod; *)  BEGIN"enter;""(*"local ('1');"*)"ASSEMBLER BREAK END;"FOR i:= 1 TO 2 DO$c:= ABS (i)"END;""(*"IF ADDRESS(l) = PtrToChar (l) THEN END; (* darf nicht gehen! *)"c:= 1 DIV 0;"*)""(*"wrReal (real (entier (1.234E5)),0);"wrReal (log (1000.0),0);"wrReal (pwrOfTen (2.0),0);""c:= 1;"FOR card:= c-1 TO f2() DO$INC (i)"END;"FOR card:= f2() TO f2() DO$INC (i)"END;"FOR card:= f2() TO c DO$INC (i)"END;"FOR card:= f2() TO c+1 DO$INC (i)"END;"FOR card:= c+1 TO c+1 DO$INC (i)"END;"FOR card:= c TO c DO$INC (i)"END;"IF i # 8 THEN HALT END;""lr:= arcsin (2.); (* sollte Range Error melden *)"lr:= 1.;"lr:= lr / 0.; (* sollte Div By 0 melden *)"lr:= lr + lr;""lr:= 1.;"sr:= lr;"lr:= sr;"sr:= sr + 1.;"lr:= lr + 1.;"wrReal (sr, 0);"wrReal (lr, 0);""lr:= FLOAT (1);"wrReal (lr, 0);"lr:= 1.0;"wrReal (lr, 0);"lr:= LFLOAT (4)*3.14;"wrReal (lr, 0);"lr:= 3.14*LFLOAT (4);"wrReal (lr, 0);"lr:= LFLOAT (4)/3.14;"wrReal (lr, 0);"lr:= 3.14/LFLOAT (4);"wrReal (lr, 0);"*)""(*"c:= 1;"IF FLOAT(c)#1.0 THEN HALT END;"IF LFLOAT(c)#1.0 THEN HALT END;""ss:= SS {TS {'' BY 8, fch()} BY 3};"ss:= SS {'111', '22222222', '33333333'};"aaavs:= AAAVS {{{'<11111111111111111', '222222222222222222>'}, AVS{'<11111111111111111', '222222222222222222>'}}, AAVS {AVS{'<11111111111111111', '222222222222222222>'}, AVS{'<11111111111111111', '222222222222222222>'}}};"IF NOT VarEqual (aaavs, caaavs) THEN HALT END;"avs:= AVS{'1111111111111111111', '2222222222222222222'};"lss:= LSS {'1234567890abcdefgh', '11111111111111111123', '3'};"lss:= LSS {'111111111111111111', '3333333', ls};"ss:= SS {'11111111', '22222222', '33333333'};"s:= '1111111';"ss:= SS {'11111111', '22', '33333333'};"ss:= SS {'111', '22', '333'};"ss:= SS {'11111111', f(), '3333333'};"avl:= AVL {li,2,3,4,5,6,7L,8,9,1000000};"lss:= LSS {'111111111111111111', '3333333', ls};"ss:= SS {'11111111', '22', '3333333'};"ss:= SS {'11111111', '2222222', '3'};"ss:= SS {'11', '22', '333333'}; (* << '22' muû byteweise kopiert werden *)"avl:= AVL {1,2, f5(ls) BY 7, 10};"ssg:= SSG {tsg BY 3};"tsg:= TSG {'<', '.' BY 8, '>'};"ssg:= SSG {TSG {fch() BY 10} BY 3};"ssg:= SSG {{'<', '.' BY 8, '>'} BY 3};"ssg:= SSG {TSG {'<', fch() BY 8, '>'} BY 3};"ssg:= SSG {fsg() BY 3}; (* hier bleibt alles auf A3 *)"fss:= FSS {{'1' BY 9} BY 3};"ss:= SS {TS {fch() BY 9} BY 3};"ss:= SS {s BY 3};"ss:= SS {TS {'<', '.' BY 7, '>'} BY 3};"ss:= SS {f() BY 3};     (* hier muû umkopiert werden *)""WriteString ("@RADD (1.5,2.2): ");"InOut.WriteReal (@RADD (1.5,2.2), 0, 6);"WriteLn;"WriteString ("@RMUL (1.5,2.2): ");"InOut.WriteReal (@RMUL (1.5,2.2), 0, 6);"WriteLn;"WriteString ("fpsub (1.5,2.2): ");"InOut.WriteReal (fpsub (1.5,2.2), 0, 6);"WriteLn;"WriteString ("fpdiv (2.0,2.2): ");"InOut.WriteReal (fpdiv (2.0,2.2), 0, 6);"WriteLn;"WriteString ("pi/2.: ");"InOut.WriteReal (pi/2., 0, 6);"WriteLn;"WriteString ("sin (pi/2.): ");"InOut.WriteReal (sin(pi/2.), 0, 6);"WriteLn;"WriteString ("ln (e): ");"InOut.WriteReal (ln(e), 0, 6);"WriteLn;"WriteString ("ln (3.4): ");"InOut.WriteReal (ln(3.4), 0, 6);"WriteLn;""(* prÅfen, ob IEEE/MM2-Konvertierung bis zum grîûten Wert korrekt geht *)"IF UsedFormat # MM2Real THEN HALT END;"lr:= 0.1;"LOOP$lr2:= Conv (RealFormat {lr, MM2Real}, IEEEReal);$IF lr2 = IEEE_Infinite THEN&wrReal (lr,0);&WriteString ('Infinity');&WriteLn;&EXIT$END;$lr2:= Conv (RealFormat {lr2, IEEEReal}, MM2Real);$IF lr # lr2 THEN&wrReal (lr,0);&wrReal (lr2,0);&EXIT$END;$lr:= lr * 2.;"END;""(* prÅfen, ob IEEE/MM2-Konvertierung bis zum kleinsten Wert korrekt geht *)"IF UsedFormat # MM2Real THEN HALT END;"lr:= 0.1;"LOOP$lr2:= Conv (RealFormat {lr, MM2Real}, IEEEReal);$IF lr2 = 0R THEN&wrReal (lr,0);&WriteString ('Null');&WriteLn;&EXIT$END;$lr2:= Conv (RealFormat {lr2, IEEEReal}, MM2Real);$IF lr # lr2 THEN&wrReal (lr,0);&wrReal (lr2,0);&EXIT$END;$lr:= lr / 2.;"END;""WriteString ('<');"WriteLn;"InOut.WriteFloat (MAX (LONGREAL), 14, 40);"WriteLn;"InOut.WriteFloat (MIN (LONGREAL), 14, 40);"WriteLn;"InOut.WriteFloat (MAX (REAL), 14, 40);"WriteLn;"InOut.WriteFloat (MIN (REAL), 14, 40);"WriteLn;"WriteString ('>');""c:= $234;"sr:= FLOAT (c);"lc:= TRUNC (sr);"lr:= LFLOAT (lc);"lc:= TRUNC (lr);"IF LONG (c) # lc THEN HALT END;""bs1:= bs1c;"IF bs1 # {0,6..7,1} THEN HALT END;"c:= 2; xs1:= XBS {1,c..1022}; IF xs1 # XBS {1..1022} THEN HALT END;"ls1:= LBS {c,0..63}; ls2:= LBS {0..63,c}; IF ls1 # ls2 THEN HALT END;"wordbitset:= ms1c;"c:= 2; d:= 4;"bs1:= {1,c,5};"bs1:= {5..7,c..d,0..1};"wordbitset:= MYBITSET {c..d, 4..d, c..1};"wordbitset:= MYBITSET {1,bin,3,bin,15};""IF 1 IN f4c() THEN END;"IF 0 IN f4() THEN END;"IF 0 IN f3b() THEN END;""WITH arp^ DO$arp^.p();$p()"END;""sr:= 2.;"sr:= sr*sr+sr*sr;"InOut.WriteReal (sr*sr+sr*sr, 40, 20);"Read (ch);""(*$D+*)"s:= '123';"s:= s;"c:= 4;"c:= c+c + (c * c + ORD (bin IN bytebitset));"ss:= SS {f() BY 3};     (* hier muû umkopiert werden *)"*)""(* zuerst die Longreals testen"li:= MIN (LONGINT);"IF li # VAL (LONGINT, VAL (LONGREAL, li)) THEN HALT END;"li:= -2;"IF li # VAL (LONGINT, VAL (LONGREAL, li)) THEN HALT END;"li:= +2;"IF li # VAL (LONGINT, VAL (LONGREAL, li)) THEN HALT END;"li:= MAX (LONGINT);"IF li # VAL (LONGINT, VAL (LONGREAL, li)) THEN HALT END;"lc:= 0;"IF lc # VAL (LONGCARD, VAL (LONGREAL, lc)) THEN HALT END;"lc:= 2;"IF lc # VAL (LONGCARD, VAL (LONGREAL, lc)) THEN HALT END;"lc:= MAX (LONGCARD);"IF lc # VAL (LONGCARD, VAL (LONGREAL, lc)) THEN HALT END;"(* und nun die Shortreals *)"lc:= MAX (LONGCARD)-255;"IF (lc DIV 256 * 256 > VAL (LONGCARD, VAL (REAL, lc)))"OR (lc DIV 256 * 256 + 255 < VAL (LONGCARD, VAL (REAL, lc))) THEN HALT END;"lc:= MAX (LONGINT);"IF (VAL (LONGCARD, VAL (REAL, lc)) # ORD (lc)+1) THEN HALT END;"li:= MAX (LONGINT);"IF (VAL (LONGCARD, VAL (REAL, li)) # ORD (li)+1)"& (VAL (LONGCARD, VAL (REAL, li)) # ORD (li)) THEN HALT END;"lc:= 0;"IF lc # VAL (LONGCARD, VAL (REAL, lc)) THEN HALT END;"lc:= 2;"IF lc # VAL (LONGCARD, VAL (REAL, lc)) THEN HALT END;"li:= 2;"IF li # VAL (LONGINT, VAL (REAL, li)) THEN HALT END;"li:= -2;"IF li # VAL (LONGINT, VAL (REAL, li)) THEN HALT END;"li:= MIN (LONGINT);"IF li # VAL (LONGINT, VAL (REAL, li)) THEN HALT END;"li:= MAX (LONGINT)-255;"IF li # VAL (LONGINT, VAL (REAL, li)) THEN HALT END;"(* diese Statements 2mal testen: MYREAL als REAL und auch als LONGREAL! *)"wrReal (toReal('4.0'),0); wrReal (toReal ('9.0'),0); wrReal (toReal ('1.5'),0); wrReal (toReal ('-1.0'),0); wrReal (toReal ('1.0'),0); wrReal (toReal ('1.0'),0); WriteLn;"mr:= 2.0;"mr:= mr * mr;"wrReal (mr,0);"mr2:= mr;"mr:= mr + mr + 1.0;"mr2:= 1.0 + mr2 + mr2;"IF mr2 # mr THEN HALT END;"wrReal (mr,0);"mr:= mr / 6.0;"lr:= mr;"sr:= lr;"lr:= sr;"mr:= lr;"wrReal (mr,0);"mr:= mr - 2.5;"wrReal (mr,0);"mr2:= 2.0;"IF -1.0 # ((mr2 * 2.0 * mr2 + 1.0) / 6.0 - 2.5) THEN HALT END;"IF mr = mr THEN ELSE HALT END;"IF mr # mr THEN HALT END;"IF mr > mr THEN HALT END;"IF mr <= mr THEN ELSE HALT END;"IF mr >= mr THEN ELSE HALT END;"IF mr < mr THEN HALT END;"wrReal (-mr,0);"wrReal (ABS (mr),0);"Read (ch);"sr:= lr + LONG(sr);"sr:= SHORT (lr);"lr:= SHORT (toReal ('2.0'));"*)""(*"i:= INT (byte) + i;"c:= ORD (byte) + c;"byte:= SHORT (c);"byte:= SHORT (i);"byte:= -127;"byte:= $81;""wordbitset:= MYBITSET {1,0}; (* hier darf '0' nicht erlaubt werden!!! *)""wordbitset:= SHIFT (wordbitset, +12);"wordbitset:= SHIFT (wordbitset, -12);"wordbitset:= ROTATE (wordbitset, +12);"wordbitset:= ROTATE (wordbitset, -12);"bitset:= SHIFT (bitset, 0);""bytebitset:= bytebitset;"wordbitset:= wordbitset;"bitset:= bitset;"c:= c+c + (c * c + ORD (bin IN bytebitset));"IF 15 IN wordbitset THEN END; (* falsches Byte wird geprÅft!!! *)"IF c IN bitset THEN END;""globvar:= $33;"pp (15,16,17,ADR (c));""WITH cr DO (* A4 *)$WITH ar DO (* A5 *)&WITH br DO (* br,-(A7) / A4 *)(WITH dr DO (* A5 *)*h:= b;(END&END;$END;"END;""FOR c:= 1 TO 3 DO i:= c END; (* MOVE.W #1 -> MOVEQ !!! *)"FOR c:= 1 TO c DO b:= NOT b END; (* meldet Fehler!!! *)""pA (a2);"pA (A2{a,a});"pA (A2{a BY 2});"a2:= A2{a BY 2};""FOR c:= 1 TO 3 DO WITH ar DO b:= '' END END;"FOR c:= 1 TO c DO END;""hi (0);"c:= 100;"i:= -200;"INC (c, i);"i:= 200;"INC (c, i);""DEC (ps, c);"b:= 4 IN (bys1 + bys1);"b:= 4 IN sf();"bys1:= sf();"b:= ((1 IN bys1) # b);"bys1:= sf() + BS {0..7};"bys1:= bys1 - BS {1};"pb^:= NOT XOR (b);"pb^:= NOT b AND XOR (b);"DEC (li,c);"INC (ir);"INC (sr2);"sr3:= 4;"INC (sr3);"INC (sr3);"INC (sr3);"ch:= arr[c];"ch:= HexDigits[10];"ch:= HexDigits[c];"ad:= CADR (tab); (* geht noch nicht *)"ch:= arr[sr3];"bys1:= BS {0};"glob;"p1:= glob;"p1;"REPEAT glob UNTIL b;""INCL (bs1, 14);"INCL (bs1, c);"INCL (ls1, 62);"INCL (ls1, c);"EXCL (bs1, 14);"EXCL (bs1, c);"EXCL (ls1, 62);"EXCL (ls1, c);""INCL (bs1, 14);"INCL (bs1, c);"INCL (ls1, 62);"INCL (ls1, c);""IF b AND NOT b THEN END;"IF NOT b AND b THEN glob ELSE c:= f2() END;""mc0 ('2222');"mc1 ('123411', '222222', '3234');"mc2 ('<11111111111111111111>', '<22222222222222222222>', '<333>');""aaavs:= caaavs;"avl:= cav2;"ss:= cs7;"lss:= cl1;""c:= 1L; (* muû Fehler melden *)"IF INT (BYTE (-3)) # -3 THEN HALT END;"i:= INT (byte);"c:= INT (c);"c:= ORD (MAX (SCH));"IF c1 # 15 THEN HALT END;"INC (c, 2);"INC (c, c);"IF ~b THEN c:= 0 END;"c:= CAST (CARDINAL, bs1);"l:= CAST (LONGCARD, bs1);"bs1:= CAST (BITSET, l);"l:= CAST (LONGCARD, i);"b:= f2() IN bs1;"b:= f2() IN ls1;"b:= f2() IN f4();"b:= f2() IN f3();"b:= 33 IN f4();"b:= 70 IN f3();"b:= 4 IN f4();"b:= 4 IN f3();"b:= 33 IN f3();"b:= 33 IN bs1;"b:= 70 IN ls1;"b:= 4 IN bs1;"b:= 4 IN ls1;"b:= 33 IN ls1;"IF c # c THEN END;"b:= ls1 <= ls2;"b:= ls1 <= f3();"b:= f3() <= ls2;"b:= f3() <= f3();"b:= ls1 = ls2;"b:= ls1 = f3();"b:= f3() = ls2;"b:= f3() = f3();"ls1:= ls1 - ls2;"ls1:= ls1 - f3();"ls1:= f3() - ls2;"ls1:= f3() - f3();"bs1:= bs1 - bs2;"ls1:= ls1 - ls2;"b:= bs1 = bs2;"b:= ls1 = ls2;"b:= bs1 <> bs2;"b:= ls1 <> ls2;"b:= bs1 >= bs2;"b:= ls1 >= ls2;"b:= bs1 <= bs2;"b:= ls1 <= ls2;"c:= LENGTH ('');"l:= LENGTH ('');"c:= LENGTH (s);"l:= LENGTH (xls);"ch:= CAP (ch);"l:= LONGINT (2);"l:= LONGCARD(2);"avl:= avl; (* direkte kopierschleife *)"pls:= ADR (ls); pls^:= pls^; (* word-copy Åber runtime *)"axl:= axl; (* runtime: ruft Block.Copy auf *)"i:= VAL (INTEGER, b);"c:= VAL (CARDINAL, b);"b:= VAL (BOOLEAN, c);"b:= VAL (BOOLEAN, i);"en2:= zwei;"en1:= en1;"en1:= en2;    (* hier wÑre kein subrange-test nîtig! *)"en2:= en1;"sch:= CHR (li); (* code kînnte besser sein... *)"sch:= CHR (c);  (* code kînnte besser sein... *)"ch:= CHR (c);"ch:= CHR (i);"ch:= CHR (l);"ch:= CHR (li);"c:= -2;  (* erkennt fehler, wie's sein soll *)"ir:= -4; (* erkennt fehler, wie's sein soll *)"sr2:= i;"sr2:= c;"ir:= i;"ir:= c;"IF l = ADR (ir) THEN END;"i:= SHORT (li);"i:= SHORT (l);"c:= SHORT (li);"c:= SHORT (l);"i:= VAL(INTEGER, ir);"c:= VAL(CARDINAL, ir);"i:= INTEGER(2);"l:= 9;"c:= ORD (l);"c:= ORD (ch);"l:= c;"l:= i;"IF c = MAX (INTEGER) THEN b:= FALSE END;"IF i = MIN (INTEGER) THEN b:= FALSE END;"b:= ODD (i);"IF ODD (i) THEN END;"c:= SIZE (ar.a[c*3+SIZE(ps^)+f2()+c]);"c:= SIZE (TS);"ad:= CADR (12);"ad:= CADR (LONGCARD(12));"c:= DEREF (fcp());"ch:= CAP ('a');"i:= ABS (-i);"i:= ABS (i+1);"ch:= 0C;"ch:= '';"ch:= 'a';"op3(ss);"op4('');"op4(ss);"op4 (f());"op ('');"op ('a');"op ('ab');"op ('abc');"op ('abcd');"op ('abcde');""op (f());"op2(TRUE,f());"val(f());"val('ab');"val(s);"op (s);"op ('');"op ('a');"op ('ab');"op ('abc');"op ('abcd');"op ('abcde');""ps^:= '';"ps^:= '12';"ps^:= '1234';"s1:= '1';"s2:= '12';"s3:= '123';"s4:= '1234';"s:= 0C;"s:= '1';"s:= '12';"s:= '123';"s:= '1234';"*) (* fehler: "c5 = CARDINAL (c2); << hier meckert er..."c5 = CARDINAL (INTEGER(2)); ... aber hier meckert er nicht (so soll's sein)!?"c4 = LONGCARD (c2 + 1); << mÅûte melden: 'typ-conv nur bei selbe lÑnge'..."c4 = LONGINT (c2 + 1); ... aber hier meckert er dann Åberhaupt nicht?! "c:= c + c2; (* bringt falsche fehlermeldung *)"INCL (bs1, 2); (* runtime-routinen schon auf neue parm-Åbergabe umgestellt,2* aufrufe in M2MAIN aber noch nicht! *)"opla ('abcdef'); (* Funktion reserviert noch nicht 4 Bytes f. High-Wert *)"c:= op5(f()) + op5(f()); (* test f. belassen des f()-erg. auf dem stack  *<* siehe dazu kommentar bei "››1" in expr-modul *)"CONST ValC = val;  <<< Proc-Konst-Zuweisungen gehen noch nicht:"li:= INT (c); << hier sollte mal irgendwann kein Range-Check mehr gen. werden"IF INT (c) = 0 THEN END; << auch das sollte ohne check, usw, gehen"c:= lgArr [c][l].c; (* macht totalen Murks: es wird nicht erkannt, daû7* f. 'c' eine long-mul gemacht werden muû; 2.7* scheint letzter offset beim MOVE nicht korrekt zu7* sein und 3. kommt syntaxfehler, wenn 2. array-range7* nicht mit '0L' sondern '0' beginnt! *)"ad:= ADDRESS (Monitor); (* Comp aus neuem Code glaubt, Monitor sei LONGREAL *)"val_fss(ptrToFSS^); (* mÅûte hier nicht byteweise kopiert werden? !!! *)"lc:= 4294967295 (* hier meckert er! *) *) ;exit; END T. 
(* $FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$000028BB$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE41BAD$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE9CA66$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373F$FFE8373FÄ$00002856T.......T.......T.......T.......TT......T.......T.......T.......T.......T.......$00000A1D$0000241C$000028B2$000028A2$000028BB$0000270C$00002856$00000D57$000028C6$000028A2$FFEADBE8$000028AA$000028A2$000028C6$000028A2$000028B1úÄÇ*)
