 (* ------------------------#Modula Compiler  /4.0/#------------------------#Tree-Finish$$28.3.85  GDOS Version%8.5.85  Fehler bei Export von Variablen korrigiert$10.5.85  PrtDec zehnstellig$16.5.85  Fehler bei Export aus lokalen Modulen endgueltig (?) korrigiert$6.10.85  (TT) Assembler-Errors in 'Massm' uebertragen#22.02.86  Neuordnung der Texte$2.03.86  Real-Konstanten im Hex-Format mit HexDigit {HexDigit} 'R';-Wandlung von Reals jetzt ueber Strings-Modul#14.04.86  Err109 nachgetragen#11.07.86  Err42 entfernt#08.09.86  Oktalkonstanten implementiert;-Option $O waehlt Oktaldarstellung fuer Characters#06.10.86  alle ErrXXX geloescht;#16.10.86  statt $Oktal+ wird $Gepard- fuer Oktal-Chars abgefragt#24.10.86  Constant Expressions implementiert#28.10.86  Type Transfer in ConstExpr laesst verschiedene Laengen zu.(mit unsinnigen Ergebnissen bei Reals)$1.11.86  TravTre erkennt Relay an 0.B (Flags im Highbyte moeglich)$2.11.86  in ConCard9 'D' als Suffix fuer LONGs zugelassen$1.3.87 TT Anpassungen fÅr Atari-MOS in 'ConFact'$3.3.87 TT PushAcc/PopAcc nicht auf A7-Stack sondern auf ID-Stack, zus..Overflow-Abfrage$24. 3.87  nicht Impl. FORWARD-Deklarationen brechen mit Fehler ab/(VPKnot)$07.04.87  TT RealIsUsed wird gesetzt (ConFact)$18.04.87  TT ProtVar-Aufruf in VPKNOT$$16.06.87  ConRel: Wenn runGep & Atari-Codeerzeugung, Formatwandlung..IEEE-Fomatwandlung nur im Gepard-Modus!$24.06.87  TravTr1 durchsucht auch bei lokalen Modulen die UnterbÑume.(wer weiû, wozu man's braucht) und ruft den Knoten-Handler.auch fÅr den Qualifier bei DefMods auf.$26.06.87  Ersetzen von ^nachdeklarierte Opaues durch ^neuen Eintrag.(NewOpaque)$04.07.87  IDfromTree statt TravPrID zur Verarbeitung von IDs, die.wÑhrend TreeScan als Fehlerquelle auffallen;.Procedure FwdKnot prÅft auf lokale unimpl. FORWARDs$08.07.87  fÅr NewOpaque spezielle TreeScan-Routine TravTr2: erkennt0Verweise auf alten Opaque-Eintrag per Relay (falls Opaque erst0auf Umwegen, dann aus eigenem DefMod importiert) und ersetzt0auch die..Nicht impl. Exporte jetzt durch VPKnot erkannt (statt FinExp)$28.10.87  NewOpaque: Endlosschleifen beim Scannen von POINTER TO RECORD..0verhindert (Markierung der bearbeiteten EintrÑge in Bit 30der Kennung - VARPAR-Flag, ist im globalen Level frei).$07.11.87  OpqUsers: Open Array nachgetragen.NewOpaque: Markierung in bit 7 statt bit 3;0alle mîglichen Opq-Benutzungen werden gefunden.$16.11.87  NewOpq: Markierung jetzt nur noch bei Pointern, in Bit 2.0RÅcksetzen der Markierung durch Merken mit Pointerkette0statt durch erneutes Durchsuchen!$22.11.87 TT Ausgaberoutinen -> CompIO$15.03.88  FinVar: Anlegen der LÑngenliste fÅr Proc/Module/Tables0(FinVar legt Pointerkette durch alle EintrÑge an, die0in der LÑngenliste erscheinen mÅssen)$18.05.88  FinVar: neues Format der LÑngenliste; enthÑlt fÅr jeden1Eintrag Anfangsadresse und LÑnge.$26.05.88  FacTran: Transfer von/auf 2 Byte-SETs greift nicht mehr1auf falsches Wort im Akku zu$29.06.88  VPKnot erkennt exportierte (nicht impl.) Prozeduren am1External-Bit (bit 12) statt an bit 14.%2.07.88  DoSP: holt Ergebnisse von System-Prozeduren auch bei SETs1ungerader LÑnge richtig ab.$15.12.88  ConstExpr rausgetrennt, in separates Modul$10.12.89  Nachtrag vom 28.12.88.TravTre: rettet beim Bearbeiten des RStacks A01(vergiût jetzt hoffentlich keine lokalen Module mehr)$28.01.90 TT MovVarKnot neu; wird in M2Main.Block benutzt$05.07.90 TT OpqKnot trÑgt nun alle Opaques in Parm-Ketten nach (hîrte0bisher nach dem ersten auf), auch keine Endlosschleife mehr bei0rekursiven Prozedurtyp-Definitionen.$18.08.90 TT Anpassung des Offsets zum lok. Record-Baum$23.09.90 TT GetNameOfId findet den Namen einer ID-Beschreibung;0TravTr1 & OpqKnot gehen nicht mehr durch leere UnterbÑume0(zumindest bei OpqKnot wurde damit ein Fehler behoben);0OpqKnot berÅcksichtigt auch Long-OpenArrays und ProcType0f. lok.Procs (Kennung 44); Importliste bei Imp-Modulen wird0gekÅrzt (nur die wirklich benutzten IDs bleiben drin)$05.03.91 TT NewOpaque/OpqKnot berÅcksichtigen leere Records (fÅhrte bisher0zu AbstÅrzen).$03.06.94 TT FinishData Åbersprang unbenutzte DATAs falsch, was zu0Endlosschleifen mit Buserrors am Ende d. Speichers fÅhrte.#----------------------------------------------------- *)  (* =================================================== ,Low-Level Zeugs, Tree-Scanner("=================================================== *)  (* Dokumentation der TravTre-Routinen: #TravTr   scannt Pervasive- und aktuelles Level sowie die auf dem,Relocation Stack eingetragenen lokalen Module#TravTr0  scannt Pervasive-Level sowie die auf dem Relocation Stack,eingetragenen lokalen Module (also wie TravTr ohne akt. Level)#TravTr1  scannt nur den Unterbaum auf (A1,D2.L)##Beide Routinen verfolgen lokale BÑume von Qualifiern (lokale oder#Def-Module; deren EintrÑge mÅssen z.B. auch reloziert werden), jedoch#nicht von Records. Relay-EintrÑge werden zum Ursprung verfolgt.##TravTr kann einen Eintrag mehrfach erreichen: im lokalen Modul (Åber#den Relocation Stack) und Åber ein Relay bei exportierten Objekten.#Die Knotenhandler mÅssen durch geeignete Markierung der EintrÑge#mehrfache Bearbeitung verhindern! *)  FORWARD TravTr1; FORWARD TravTr0;  (*!*  PROZEDUR (A5) AUF GESAMTEN BAUM ANWENDEN;!*!*  Register bei Aufruf von (A5):!*    (A1,D4.L) = ^Pointerkette!*  -8(A1,D4.L) = ^Identifier!*  -8(A1,D2.L) = ^Eintrag zum Id!*)  PROCEDURE TravTr; BEGIN ASSEMBLER)MOVE.L  (A6),D2       ;GLOBAL LEVEL)BEQ     TravTr9       ; IST LEER)JSR     TravTr1 TravTr9  JMP     TravTr0 END END TravTr;  PROCEDURE TravTr0; BEGIN ASSEMBLER); Relocation Stack abarbeiten (lokale Module))MOVE.L  RSTKPTR,-(A7) TravTr3  MOVE.L  (A7)+,A0)MOVE.L  (A0)+,D2)BNE     L1)JMP     TravTr1       ;PERVASIVES L1       MOVE.L  A0,-(A7))JSR     TravTr1)BRA     TravTr3 END END TravTr0;  (*!*   wie TravTre, jedoch wird nur der Unterbaum ab (A1,D2.L) durchsucht:!*!* Vorsicht: LOCXP/SetRelay verwendet D4 um an den ggf. Relay-Eintrag zu kommen.!*)  PROCEDURE TravTr1; BEGIN ASSEMBLER !TRAVT1L MOVE.L  D2,-(A7))MOVE.L  -4(A1,D2.L),D2 ;LINKEN AST VERFOLGEN)BEQ     TravTr2)BSR     TRAVT1L !TravTr2 MOVE.L  (A7),D2)MOVE.L  -8(A1,D2.L),D2 ;RECHTEN AST VERFOLGEN)BEQ     TravTr4)BSR     TRAVT1L !TravTr4 MOVE.L  (A7)+,D2)MOVE.L  D2,D4          ;retten fuer ID-Ausgabe !TravTr5 SUBQ.L  #2,D2          ;ID WEG)CMPI.W  #$FE00,-8(A1,D2.L))BCS     TravTr5        ;noch keine Endmarke)MOVE.W  -10(A1,D2.L),D0 ;KENNUNG)TST.B   D0)BNE     TravTr7       ;KEIN RELAY)MOVE.L  -14(A1,D2.L),D2)ADDQ.L  #8,D2         ;UEBLICHEN OFFSET WIEDERHERSTELLEN)MOVE.W  -10(A1,D2.L),D0)TST.B   D0)BNE     TravTr7       ;KEIN RELAY)MOVE    #rTree2,D5    ;Fehler: Doppelte Relay-Verkettung)JMP     SyntaxErr !TravTr7 TST.W   D0)BPL     TravTr6       ;MODULA WORT)CMPI.B  #15,D0        ;lokales Modul ?)BEQ     L3)CMPI.B  #16,D0        ;QUALIFIER?)BNE     L2 L3       MOVEM.L D0/D2/D4,-(A7))MOVE.L  -14(A1,D2.L),D2)BEQ     L4            ;leer)JSR     TravTr1       ;UNTERBAUM DURCHSUCHEN L4       MOVEM.L (A7)+,D0/D2/D4 L2       JMP     (A5) !TravTr6 END END TravTr1;  (*(gefundenen ID waehrend TravTre in 'BadID' schreiben;(wahlweise Gepard- oder Atari-Stringformat.(((A1,D4.L) zeigt auf PointerKette(((A0,D0,D1,D4) *)! PROCEDURE IDfromTree;  BEGIN  ASSEMBLER.LEA     BadID,A0 (*$ ? RunGep: ADDQ.L  #1,A0        ;Platz fÅr LÑngenzÑhler *).CLR.W   D1&TP1     SUBQ.L  #1,D4.MOVE.B  -8(A1,D4.L),D0.CMP.B   #$FE,D0.BCC     TP2.MOVE.B  D0,0(A0,D1.W).ADDQ    #1,D1.BRA     TP1&TP2 (*$ ? RunGep: MOVE.B  D1,-1(A0)     ;LÑngenzÑhler  *) (*$ ? RunST:  CLR.B   0(A0,D1.W)    ;Endmarke      *)'END END IDfromTree;  PROCEDURE FLKNOT; BEGIN  ASSEMBLER)CMPI.B #29,D0          ; Asm-Label)BNE    FLKNOT1)TST.L  -14(A1,D2.L))BNE    FLKNOT1)JMP    AERR6 FLKNOT1  CMPI.B #48,D0          ; FORWARD)BNE    FLKNOT2)JSR     IDfromTree)MOVE    #rFwTyX,D5)JMP     SyntaxErr FLKNOT2 END END FLKNOT;  (*!* PRUEFEN, OB noch LABELS undefiniert oder Forward-Typen Åbrig.!*)! PROCEDURE FinLblAndFwrd; BEGIN  ASSEMBLER)LEA    FLKNOT,A5)MOVE.L (A6),D2)BEQ    EMPTY)JMP    TravTr1 !EMPTY END END FINLBLAndFwrd;   (*!*   Alle globalen Objekte in die Relozierliste eintragen.!*)  VAR ImpOffset: LONGCARD;$DataCodeOffs: LONGCARD;$CurrDataOfs: LONGCARD;  PROCEDURE movReloc;"BEGIN$ASSEMBLER);Relozierkette einer ID korrigieren)MOVE.L  D1,D0)SUB.L   D7,D0)MOVE.L  D0,(A4)+       ;^letzte Ref. gleich mit ablegen)BRA     relCont relNext  MOVE.L  D1,D0)SUB.L   D7,D0)MOVE.L  D0,(A0) relCont  LEA     0(A2,D1.L),A0  ;Adr. der vorigen Ref. nach A0)MOVE.L  (A0),D1)BNE     relNext$END"END movReloc;  PROCEDURE RelocData;"BEGIN$ASSEMBLER)MOVE.L  DataStart,A0)MOVE.L  DataCodeOffs,A3)SUBA.L  CodeStart,A3   ;A3: Beginn v. DATA rel. zum Codebeginn lup20:   CMPA.L  DataPtr,A0)BEQ     endOfD2)MOVE.L  2(A0),D1      ;^letzte Ref.)BEQ     ignore)MOVE.L  A0,-(A7))JSR     movReloc      ;Relozierkette korrigieren & eintragen)MOVE.L  (A7)+,A0)MOVE.L  A3,D0         ;D0: Adr. der. Konst rel. zum Code-Beginn)SUB.L   D7,D0         ;    ImportList-Korrektur)MOVE.L  D0,(A4)+)ADDA.W  (A0),A3 ignore:  ADDA.W  (A0),A0)ADDQ.L  #6,A0)BRA     lup20 endOfD2: MOVE.L  A3,CurrDataOfs  ; f. VPKNOT merken$END"END RelocData;  FORWARD VPKNOT;  PROCEDURE FINVAR; BEGIN ASSEMBLER)MOVE.L  A2,-(A7))MOVE.L  A3,-(A7) )MOVE.L  options,D0)BTST    #16,D0)BEQ     hcr3          ;p- gesetzt: kein Protokoll)TST.W   ProtFile)BEQ     hcr3          ;ProtokollFile nicht offen)JSR     ProtVarStart  ;Variablen ankÅndigen hcr3)MOVE.L  Header,A2)MOVE.L  22(A2),D3    ;OFFSET FUER VAR-ADRESSEN);minus der Header-LÑnge (nun CodelÑnge):)ADD.L   A2,D3)SUB.L   CodeStart,D3))MOVE.L  ImpOffset,D7))JSR     RelocData      ;zuerst die Daten aus dem DATA-Puffer relozieren))LEA     root(pc),A3    ;Root z. Verkett. d. Clienten f. d. LÑngenliste)CLR.L   (A3)))LEA     VPKNOT,A5)MOVE.L  CodeStart,A2)JSR     TravTr         ;IM GANZEN BAUM SUCHEN)CLR.L   (A4)+)); Proc-Namen-Liste korrigieren, falls vorhanden)TST.W   ProcNames)BEQ     noName         ;Name ist nicht gefragt)MOVE.L  6(A2),D0       ;^Body nxtLbl   LEA     -4(A2,D0.L),A0)MOVE.L  (A0),D0)BEQ     noName)MOVE.L  D0,D1)SUB.L   D7,D1)MOVE.L  D1,(A0))BRA     nxtLbl noName); Nun werden ExportListe & Programmcode verschoben (wg. gekÅrzter); Importliste)))MOVE.L  Header,A2)MOVE.L  42(A2),A0      ;Codebeginn)SUB.L   D7,42(A2)      ;  ...korrigiert)MOVE.L  18(A2),D0      ;Exportliste)BEQ     noExpLst)MOVE.L  D0,A0)SUB.L   D7,D0)MOVE.L  D0,18(A2)      ;  ...korrigiert noExpLst ; A0 enthÑlt nun Beginn des zu verschiebenden Bereichs)ADDA.L  A2,A0)MOVEM.L D0-D2/A0-A3,-(A7))MOVE.L  EvalStk,A3)MOVE.L  A0,(A3)+       ;Source-Start)MOVE.L  A4,D0)SUB.L   A0,D0)MOVE.L  D0,(A3)+       ;Anzahl)SUBA.L  D7,A0)MOVE.L  A0,(A3)+       ;Dest-Start)JSR     Copy)MOVEM.L (A7)+,D0-D2/A0-A3 ); Die restlichen Ptr korrigieren)SUB.L   D7,6(A2)       ;^Body)SUB.L   D7,10(A2)      ;^Modulende)SUB.L   D7,22(A2)      ;^Relozierliste)SUB.L   D7,62(A2)      ;^Data)SUBA.L  D7,A4 ); LÑngenliste anlegen & gleich korrigeren))MOVE.L  Header,A0      ;^LÑngenliste setzen)MOVE.L  A4,D0)SUB.L   A0,D0)MOVE.L  D0,38(A0))); zuerst die LÑngenliste fÅr die Konstanten aus dem DATA-Puffer)MOVE.L  DataStart,A0)MOVE.L  DataCodeOffs,A3)SUBA.L  CodeStart,A3   ;A3: Beginn v. DATA rel. zum Codebeginn lup20:   CMPA.L  DataPtr,A0)BEQ     endOfD2)MOVE.L  2(A0),D1      ;^letzte Ref.)BEQ     ignore)MOVE.L  A3,D0         ;D0: Adr. der. Konst rel. zum Code-Beginn)SUB.L   D7,D0         ;    ImportList-Korrektur)MOVE.L  D0,(A4)+)MOVEQ   #0,D0)MOVE.W  (A0),D0       ;LÑnge d. CONST)MOVE.L  D0,(A4)+)ADDA.W  D0,A3 ignore:  ADDA.W  (A0),A0)ADDQ.L  #6,A0)BRA     lup20 endOfD2:)MOVE.L  root(pc),A0)MOVE.L  A0,D0)BEQ     empty) cont     BCLR    #0,D0        ;ist es eine CONST?)BNE     isConst)MOVE.L  -8(A0),D0)SUB.L   D7,D0        ;ImpOffset (Korrektur))MOVE.L  D0,(A4)+     ;Adresse)MOVE.L  -4(A0),(A4)+ ;LÑnge cont2    MOVE.L  (A0),A0)MOVE.L  A0,D0)BNE     cont) empty    MOVEQ   #0,D0)MOVE.L  D0,(A4)+))MOVEA.L (A7)+,A3)MOVEA.L (A7)+,A2)RTS ); CONST in LÑngenliste aufnehmen geht anders: isConst  MOVE.L  D0,A0)MOVE.L  8(A0),(A4)+    ;Adresse (bereits D7-korrigiert))MOVEQ   #0,D0)MOVE.W  -2(A0),D0      ;LÑnge)MOVE.L  D0,(A4)+)BRA     cont2  root     DC.L    0 END END FINVAR;  PROCEDURE VPKNOT; BEGIN ASSEMBLER);D3: LÑnge des Codes, Offset der glob. Vars);D7: Korrektur-Offset der Importliste))BSET    #5,-10(A1,D2.L) ;IMPORTIERT?)BNE     ok              ;dann nicht))CMP.B   #15,D0        ;MODULE?)BEQ     VPKNOT1)CMP.B   #6,D0         ;PROC?)BNE.W   VPKNOT3)); Procedure))MOVE.L  -14(A1,D2.L),D5   ;Adr)BEQ     noImpl            ;Implementation fehlt)MOVE.L  -26(A1,D2.L),D1   ;^letzte Ref)BEQ     noRef             ;keine Referenz)JSR     movReloc)SUB.L   D7,D5)MOVE.L  D5,(A4)+ noRef    LEA     -26(A1,D2.L),A0   ;Pointerkette fÅr LÑngenliste aufbauen)MOVE.L  A0,(A3))MOVE.L  A0,A3)CLR.L   (A3) ok       RTS  noImpl   JSR     IDfromTree)BTST    #4,-10(A1,D2.L)    ;exportiert?)BEQ     noExp)MOVE    #rPrIpl,D5)BRA     isExp noExp    MOVE    #rUnFw,D5 isExp    JMP     SyntaxErr)); Module) VPKNOT1  MOVE.L  -30(A1,D2.L),D1   ;^letzte Ref)BEQ     noRef2            ;keine Referenz: nicht in RelocListe)JSR     movReloc)MOVE.L  -18(A1,D2.L),D0   ;Adr)SUB.L   D7,D0)MOVE.L  D0,(A4)+ noRef2   LEA     -30(A1,D2.L),A0   ;Pointerkette fÅr LÑngenliste aufbauen)MOVE.L  A0,(A3))MOVE.L  A0,A3)CLR.L   (A3))RTS) VPKNOT3  CMP.B   #17,D0)BNE     VPKNOT4)); Variable))MOVE.L  -22(A1,D2.L),D1 ; letzte Ref.)BEQ     ok)JSR     movReloc)MOVE.L  -14(A1,D2.L),D0 ; Adr.)ADD.L   D3,D0         ;VAR-OFFSET DAZU)SUB.L   D7,D0         ;ImportList-Korrektur)MOVE.L  D0,(A4)+)); Variable ggf. protokollieren))MOVE.L  options,D0)BTST    #16,D0)BEQ     hcr3          ;p- gesetzt: kein Protokoll)TST.W   ProtFile)BEQ     hcr3          ;ProtokollFile nicht offen)JSR     ProtVar       ;Variablenname/Adresse ins Protokollfile hcr3     RTS  !VPKNOT4 CMP.B   #28,D0        ;TABLE im Code-Segment)BNE     VPKNOT5)MOVE.L  -18(A1,D2.L),D1)BEQ     noRef3)JSR     movReloc)MOVE.L  -14(A1,D2.L),D0)SUB.L   D7,D0)MOVE.L  D0,(A4)+ noRef3   LEA     -18(A1,D2.L),A0   ;Pointerkette fÅr LÑngenliste aufbauen)MOVE.L  A0,(A3))MOVE.L  A0,A3)CLR.L   (A3))RTS  VPKNOT5  CMP.B   #50,D0        ;CONST hinter Code-Segment)BNE     VPKNOT2)BCLR    #2,-8-2(A1,D2.L))BEQ     hcr3           ; -> bereits bearbeitet oder unbenutzt); dieses Datum wurde in den Code kopiert)MOVE.L  CurrDataOfs,D0 ;D0: Adr. der. Konst rel. zum Code-Beginn)MOVE.L  D0,A0)SUB.L   D7,D0          ;    ImportList-Korrektur)MOVE.L  D0,-8-6(A1,D2.L) ;Adr. merken (f. FINVAR & FINEXP)); Offset zum nÑchsten Datum im Code bestimmen:)ADDA.W  -8-16(A1,D2.L),A0 ;echte LÑnge im DATA-Segment aufaddieren)MOVE.L  A0,CurrDataOfs); Relozierkette aufbauen)MOVE.L  -8-14(A1,D2.L),D1 ;^letzte Ref)BEQ     ignore         ;unbenutzt? (dann wird sie aber exportiert))JSR     movReloc       ;Relozierkette korrigieren & eintragen)MOVE.L  -8-6(A1,D2.L),(A4)+ ignore   ;Pointerkette fÅr LÑngenliste aufbauen);bei Consts geht das so: Die Verkettung geschieht Åber den); "^letzte Ref" im Tree.); So findet FINVAR am Ende zum Aufbau der LÑngenliste die Ptr); als Zeiger auf ein LÑngen-Word und eine Long-Adr.); Um dies von den Procs/Tables usw. zu unterscheiden, bei denen); der Ptr auf ein LÑngen-Long und ein Adr-Long zeigt,); wird das Bit 0 des Ptrs gesetzt.)LEA     -8-14(A1,D2.L),A0   ;A0: Adr. des nicht mehr benutzten ^Ref)ADDQ.L  #1,A0               ;als CONST markieren)MOVE.L  A0,(A3))SUBQ.L  #1,A0)MOVE.L  A0,A3)CLR.L   (A3)  VPKNOT2: END END VPKNOT;   (*$Relozierliste der importierten Vars, Procs & Consts nacharbeiten.$$In den EintrÑgen fÅr die Adr. von importierten Vars/Procs/Consts zeigt$ein Ptr auf die Stelle in der Importliste, wo der Ptr auf die$letzte Ref. des Items einzutragen ist. Dies wird hier getan.$$Auûerdem wird die Importliste so gekÅrzt, daû nur noch die$wirklich benutzten Vars/Procs/Consts drin stehen. *)  FORWARD FIKNOT;  PROCEDURE FinImp; BEGIN ASSEMBLER); Zuerst die Ptr eintragen)MOVE.L  A2,-(A7))MOVE.L  Header,A2)ADDA.L  14(A2),A2      ;^Importliste)LEA     FIKNOT,A5)JSR     TravTr         ; scannen des Relocation Stack@; ist hier eigentlich ÅberflÅssig)); Nun die Importliste kÅrzen; dazu alle Null-EintrÑge lîschen)MOVE.L  Header,A2)ADDA.L  14(A2),A2      ;^Importliste)MOVE.L  A2,A0          ; A2: Source-, A0: Dest-Pointer) nextkey  MOVE.L  (A2)+,(A0)+    ;Key)BEQ     ende           ;ende der Importlisten ImpRest4 MOVE.W  (A2)+,D0       ;Namen kopieren)MOVE.W  D0,(A0)+)CMP.B   #$FE,D0)BCS     ImpRest4 next     MOVE.W  (A2)+,(A0)+    ;ItemNr kopieren)BEQ     nextkey        ;Ende dieser Liste)MOVE.L  (A2)+,D0       ;Ref-Ptr)BEQ     delet          ;Ist Null: lîschen)MOVE.L  D0,(A0)+       ;Referenz-Ptr kopieren)BRA     next delet    SUBQ.L  #2,A0          ;ItemNr wieder weg)BRA     next  ende     MOVE.L  A2,D3)SUB.L   A0,D3          ;D3 enthÑlt nun Diff. zur neuen LÑnge (positiv))MOVE.L  D3,ImpOffset   ;merken f. FINVAR ); die Proc-, Modul-, Table- und Var-Verkettungen werden); spÑter in FINVAR korrigiert, ebenso die LÑngenliste); Auch das Verschieben und die Korrektur der Ptr im Header); kommt erst spÑter.)); Importliste korrigieren)MOVE.L  Header,A2)ADDA.L  14(A2),A2      ;^Importliste)MOVE.L  CodeStart,A5) nextkey2 TST.L   (A2)+          ;Key)BEQ     ende2          ;ende der Importlisten ImpRest2 MOVE.W  (A2)+,D0       ;Namen Åberspringen)CMP.B   #$FE,D0)BCS     ImpRest2 next2    TST.W   (A2)+          ;ItemNr)BEQ     nextkey2       ;Ende dieser Liste);Relozierkette korrigieren)MOVE.L  (A2),D1)MOVE.L  D1,D0)SUB.L   D3,D0)MOVE.L  D0,(A2)+)BRA     relCont relNext  MOVE.L  D1,D0)SUB.L   D3,D0)MOVE.L  D0,(A0) relCont  LEA     0(A5,D1.L),A0  ;Adr. der vorigen Ref. nach A0)MOVE.L  (A0),D1)BNE     relNext)BRA     next2 ende2)MOVE.L  (A7)+,A2 END END FinImp;  PROCEDURE FIKNOT; BEGIN ASSEMBLER)BTST    #13,D0        ;NUR IMPORTIERTE IDS)BEQ     FIKNOT1)CMPI.B  #6,D0         ;PROC?)BEQ     FIKNOT2)CMPI.B  #50,D0        ;CONST?)BEQ     FIKNOT5)CMPI.B  #17,D0        ;VAR?)BNE     FIKNOT1 FIKNOT4  MOVE.L  -14-8(A1,D2.L),D1 ;LETZTE REF BEI VAR)BRA     FIKNOT3 FIKNOT5  MOVE.L  -14-8(A1,D2.L),D1 ;LETZTE REF BEI CONST)BRA     FIKNOT3 FIKNOT2  MOVE.L  -18-8(A1,D2.L),D1 ;LETZTE REF BEI PROC FIKNOT3  MOVE.L  -06-8(A1,D2.L),D0 ;^IMPORTLISTE (statt Adr.))MOVE.L  D1,0(A2,D0.L)  ;EINTRAGEN FIKNOT1 END END FIKNOT;   (*!*   EXPORTLISTE NACHARBEITEN!*)  PROCEDURE FinExp; BEGIN ASSEMBLER); Die Importlist-Korrekturen wurden bei den eigenen IDs); zwar schon schon in FINVar vorgenommen, jedoch nur bei); den abgelegten Werten fÅr die Reloc-List, usw, jedoch); wurden die Original-EintrÑge bei den IDs nicht korrigiert.); Deshalb jetzt nochmal.)MOVE.L  Header,A0)MOVE.L  18(A0),D0)BEQ     FinExp2       ;KEINE EXPORTS)MOVE.L  22(A0),D2     ;OFFSET AUF GLOB.VAR);minus der Header-LÑnge (nun CodelÑnge):)ADD.L   A0,D2)SUB.L   CodeStart,D2)ADDA.L  D0,A0         ;ABS. ^EXPORTLISTE)MOVE.L  ImpOffset,D7 FinExp1  TST.W   (A0)+)BEQ     FinExp2       ;FERTIG)MOVE.L  (A0),D1       ;^ID-Beschreibung)CMPI.B  #17,-1(A1,D1.L) ;VAR?)BEQ     FinExp3)CMPI.B  #50,-1(A1,D1.L) ;CONST?)BEQ     FinExp5); Proc)MOVE.L  -6(A1,D1.L),D0)SUB.L   D7,D0)MOVE.L  D0,(A0)+      ;REL.PROC-ADR stattdessen eintragen)BRA     FinExp1 FinExp3  ; Var)MOVE.L  -6(A1,D1.L),D0 ;alt: Adr. der Var (Offset ab Null))ADD.L   D2,D0); ImpOffset ist hier bereits durch 22(A0) korrigiert)MOVE.L  D0,(A0)+       ;neu: Adr. der Var (Offset ab CodelÑnge))BRA     FinExp1 FinExp5  ; Const)MOVE.L  -6(A1,D1.L),D0 ; ADR d. Const (bereits D7-korrigiert))MOVE.L  D0,(A0)+      ;REL.CONST-ADR stattdessen eintragen)BRA     FinExp1 FinExp2(END END FinExp;  (* *   ---------------------------------- *   Alle Referenzen auf einen Opaque-Typ umhÑngen, *      wenn dieser nachdeklariert wurde. *   ---------------------------------- * *      (D0,D2) * *      D2 = rel. ^Beschreibung im ID-Baum + 10 *      D1 = zu suchender Opaque-Pointer (der Eintrag ist bereits in *            Relay auf richtigen Typ umgewandelt) *      D0 = Objekt-Kennung. 'Da TreSrc keine anonymen EintrÑge erreicht, mÅssen mîgliche'Verweise auf anonyme EintrÑge von OpqKnot gefunden und verfolgt'werden. Dies sind just die Pointer, die auch direkt auf Opaques'zeigen kînnen - mit Ausnahme der Prozedur- und Parameter-Deskriptoren:'dort zeigen die ^nÑchsten Parameter evtl. auf anonyme Verwendungen'des Opaques, die ^Typen kînnen EBENFALLS auf anonyme Verwendung'zeigen, nÑmlich in Open Arrays!''Beim Verfolgen von POINTER TO RECORD-Strukturen und bei Prozedurtypen'kînnen Endlosschleifen auftreten. Diese werden vermieden durch'Markieren der bearbeiteten Pointer-EintrÑge in Bit 2 des'Kennungsbytes ("Typ-Eintrag").''Um die Markierungen anschlieûend wieder lîschen zu kînnen, werden'die markierten EintrÑge durch eine Pointerkette verbunden. Diese'schreiben wir (Ñhem) anstelle der LÑngenangaben (immer 4) in den'Baum. *) FORWARD TravTr2;  PROCEDURE OpqKnot; BEGIN ASSEMBLER CopInf0  CMP.B   #13,D0       ;Record?)BNE     CopInf5)); lokalen Baum eines Records scannen))MOVE.L  -22(A1,D2.L),D2 ;^lokalen Baum)BEQ     CopInf9         ;wenn leer, dann RTS)JMP     TravTr2         ;durchsuchen)); Pointer: Bearbeitung markieren) CopInf5  CMP.B   #19,D0       ;PROCEDURE ?)BEQ     CopInf10)CMP.B   #20,D0       ;POINTER ?)BNE     CopInf8 CopInf10 BCLR    #2,-10(A1,D2.L) ;markieren)BEQ     CopInf9         ;war schon fertig)MOVE.L  D4,-14(A1,D2.L) ;neue Markierung: in Pointerkette)MOVE.L  D2,D4)); Beschreibung des Objektes suchen) CopInf8  LEA     OpqUsers(pc),A0 ;Liste mit Item-Beschreibung CopInf3  CMP.B   (A0)+,D0)BEQ     CopInf4      ;gefunden)ADDQ.L  #3,A0)TST.B   (A0)         ;Ende der Liste?)BNE     CopInf3      ; nein CopInf9  RTS) CopInf4  CLR.L   D0)MOVE.B  (A0)+,D0     ;Pointer-Offset in Beschreibung)SUB.L   D2,D0)NEG.L   D0)CMP.L   -8(A1,D0.L),D1 ;^unseren Opaque-Kandidaten ?)BNE     CopInf1        ;  nein)); Opaque gefunden)MOVE.L  -6(A1,D1.L),-8(A1,D0.L) ;neue Adr aus Relay drÅberschreiben)BSR.S   CopInf2        ;weitere User prÅfen)TST.B   (A0)           ;Offset zum ^mîgl. anonymen Opq-User...)BEQ     CopInf9        ;  den haben wir schon behandelt)BRA     CopInf7  CopInf1  BSR.S   CopInf2        ;weitere User prÅfen CopInf7  ;^anonymen Opq-User prÅfen)CLR.L   D2)MOVE.B  (A0),D2        ;^mîgl. anonymen Opq-User)ADD.L   D2,D0)MOVE.L  -8(A1,D0.L),D2 ;neuer ^)BEQ     CopInf9)MOVE.W  -2(A1,D2.L),D0 ;zugeh. Kennung)ADDQ.L  #8,D2          ;Åblicher Offset in TreSrc)BRA     CopInf0  CopInf2  MOVEM.L A0/D0/D2,-(A7))TST.B   1(A0))BEQ     CopInf6); es gibt einen zweiten mîgl. ^Opq-User)CLR.L   D2)MOVE.B  1(A0),D2)ADD.L   D2,D0)MOVE.L  -8(A1,D0.L),D2 ;neuer ^)BEQ     CopInf6)MOVE.W  -2(A1,D2.L),D0 ;zugeh. Kennung)ADDQ.L  #8,D2          ;Åblicher Offset in TreSrc)BSR     CopInf0 CopInf6  MOVEM.L (A7)+,A0/D0/D2)RTS ); Tabelle: ItemNr, Offset zu ^mîglichen Opaquetyp,);          Offset von dort zu mîgl ^anonymen Opaque-User) OpqUsers DC.B     6, 14, 4, 0  ;Procedure)DC.B     7, 10, 0, 4  ;Proc.Parameter)DC.B    12, 14, 0, 0  ;Array)DC.B    14, 10, 0, 0  ;Recordfeld)DC.B    17, 10, 0, 0  ;Var)DC.B    18,  6, 0, 0  ;Konstante alt)DC.B    19, 14, 4, 0  ;ProcType)DC.B    20, 10, 0, 0  ;Pointer)DC.B    32,  6, 0, 0  ;Open Array)DC.B    42,  6, 0, 0  ;Long Open Array)DC.B    44, 10, 0, 0  ;ProcType f. lok. Procs)DC.B    50, 10, 0, 0  ;Konstante neu)DC.B     0)SYNC!END END OpqKnot;  (*(speziell fÅr opqKnot:(wie TravTr1, jedoch wird bei Verfolgen eines Relays geprÅft,(ob der Verweis direkt auf (A1,D1.L) zeigt (alter Opaque-Eintrag).((D4 ist zu erhalten (enthÑlt Wurzel der Pointerkette, die die(markierten EintrÑge verbindet)!!*)  PROCEDURE TravTr2; BEGIN ASSEMBLER TravTr1L MOVE.L  D2,-(A7))MOVE.L  -4(A1,D2.L),D2 ;LINKEN AST VERFOLGEN)BEQ     TravTr2L)BSR     TravTr1L TravTr2L MOVE.L  (A7),D2)MOVE.L  -8(A1,D2.L),D2 ;RECHTEN AST VERFOLGEN)BEQ     TravTr4)BSR     TravTr1L TravTr4  MOVE.L  (A7)+,D2  TravTr5  SUBQ.L  #2,D2          ;ID WEG)CMPI.W  #$FE00,-8(A1,D2.L))BCS     TravTr5        ;noch keine Endmarke))MOVE.W  -10(A1,D2.L),D0 ;KENNUNG)TST.B   D0)BNE     TravTr7        ;KEIN RELAY)MOVE.L  -14(A1,D2.L),D0)); Eintrag ist Relay))CMP.L   D1,D0          ;Verweis auf alten Opaque-Typ?)BNE     TravTr8)MOVE.L  -6(A1,D1.L),D0 ;durch Nachdekl. ersetzen)MOVE.L  D0,-14(A1,D2.L) TravTr8  MOVE.L  D0,D2)ADDQ.L  #8,D2          ;Åblichen Offset wiederherstellen)MOVE.W  -10(A1,D2.L),D0  TravTr7  CMPI.B  #15,D0        ;lokales Modul?)BEQ     L3)CMPI.B  #16,D0        ;QUALIFIER?)BNE     L2 L3       MOVEM.L D0/D2,-(A7))MOVE.L  -14(A1,D2.L),D2)BEQ     L4            ;Unterbaum ist leer)JSR     TravTr2       ;UNTERBAUM DURCHSUCHEN L4       MOVEM.L (A7)+,D0/D2 L2       JMP     OpqKnot TravTr6 END END TravTr2;  (* Bei Nachdeklaration eines Opaques énderung aller bestehenden#Referenzen im globalen Scope veranlassen.##Das globale Scope muû das oberste auf dem Display Stack sein,#weil nur dort die Nachdeklaration erfolgen kann!##D1 = zu suchender Opaque-Pointer((der Eintrag ist bereits in Relay auf richtigen Typ umgewandelt) *)  PROCEDURE NewOpaque;  BEGIN"ASSEMBLER)MOVE.L  (A6),D2       ;globales Level)BEQ     opq1          ; ist leer)CLR.L   D4            ;Wurzel der Markierungs-Pointerkette)JSR     TravTr2)); markierte TypeintrÑge reparieren))TST.L   D4)BEQ     opq1          ;gar kein Eintrag in der Kette)MOVEQ   #4,D0#opq2  MOVE.L  -14(A1,D4.L),D2)MOVE.L  D0,-14(A1,D4.L) ;korrekte TyplÑnge eintragen)BSET    #2,-10(A1,D4.L) ;wieder als Typ markieren)MOVE.L  D2,D4)BNE     opq2          ; mehr Kettenglieder?)#opq1"END END NewOpaque;   (* in lokalen Scopes nach nicht-implementierten#FORWARD-Deklarationen suchen *)  PROCEDURE FwdKnot;  BEGIN"ASSEMBLER)CMP.B   #6,D0             ;Procedure?)BNE     done)TST.L   -14(A1,D2.L))BNE     done              ;Adresse eingetragen)JSR     IDfromTree)MOVE    #rUnFw,D5)JMP     SyntaxErr done"END END FwdKnot;   PROCEDURE MovParA3Knot; (* /D0/ *)"(* FÅr Parms auf A3 (Vars sind hier noch nicht deklariert) *)"BEGIN$ASSEMBLER(CMPI.B  #17,D0(BNE     noVar(MOVE.L  -8-6(A1,D2.L),D0        ;Offset der Variablen zu A6(BMI     error                   ;muû erstmal positiv sein(CMPI.W  #1,GLOBAL               ;lokale Proc?(BEQ     isGlobal(SUBQ.L  #4,D0                   ;dann Offset f. Stat Link abziehen(BCS     error&isGlobal(SUB.L   ParAdr,D0               ;Offset um Parm-LÑnge runterschieben(BCC     error(MOVE.L  D0,-8-6(A1,D2.L)&noVar(RTS&error(TRAP    #6(DC.W    -112          ;um internen Fehler zu melden$END"END MovParA3Knot;  PROCEDURE MovParA7Knot; (* /D0/ *)"(*#* FÅr Parms auf A7 (Vars sind hier noch nicht deklariert):#* Die Parameter mÅssen so erhîht werden, daû sie A5-relativ ansprechbar#* sind. Da der Static Link mit verschoben wird, muû lediglich immer#* 8 addiert werden.#*)"BEGIN$ASSEMBLER(CMPI.B  #17,D0(BNE     noVar(; Parm-Start berechnen in D4(ADDQ.L  #8,-8-6(A1,D2.L)&noVar(RTS&error(TRAP    #6(DC.W    -113          ;um internen Fehler zu melden$END"END MovParA7Knot;  PROCEDURE ScanForName;"BEGIN$ASSEMBLER(TST.L   D1(BNE     cont(CMP.L   D3,D2(BEQ     found(MOVE.L  D4,D2          ;und bei Relays auch diesen Eintrag prÅfen TravTr5 SUBQ.L  #2,D2          ;ID WEG(CMPI.W  #$FE00,-8(A1,D2.L)(BCS     TravTr5        ;noch keine Endmarke(CMP.L   D3,D2(BNE     cont&found(; gefunden?(CMPI.B  #$FE,-9(A1,D4.L) ; ist Name anonym?(BCC     cont             ; dann weitersuchen(MOVE.L  D4,D1&cont$END"END ScanForName;  (*!* Findet den Namen eines Idents im Baum, auch von Relays.!*   /D0,D4/!* IN:!*   (A1,D2.L): Ptr auf Ende der ID-Beschreibung!* OUT:!*   (A1,D4.L): Ptr vor Beginn des Namens (steht rÅckwÑrts im Speicher!),!*              D4 ist Null, wenn ID nicht gefunden!*) PROCEDURE GetNameOfId;"BEGIN$ASSEMBLER(MOVEM.L D1-D3/A0/A5,-(A7)(MOVE.L  D2,D3(ADDQ.L  #8,D3(MOVEQ   #0,D1(LEA     ScanForName,A5(JSR     TravTr(TST.L   D1(BEQ     notfound(SUBQ.L  #8,D1&notfound(MOVE.L  D1,D4(MOVEM.L (A7)+,D1-D3/A0/A5$END"END GetNameOfId;   FORWARD VerifyTree;  PROCEDURE VerifyItem; BEGIN ASSEMBLER);D2: ^Eintrag, D0: Kennung)CMPI.B  #31,D0)BEQ     CopInf4      ;String Const ignorieren)SUBQ.L  #2,D2)LEA     ITEMS,A0     ;Liste mit Item-Beschreibung)MOVE.B  (A0)+,D1 CopInf30 CMP.B   D1,D0)BEQ     CopInf1      ;gefunden CopInf20 TST.B   (A0)+        ;nicht gefunden: Ende des Eintrags suchen)BNE     CopInf20)MOVE.B  (A0)+,D1     ;Ende der Liste?)BNE     CopInf30     ; nein  error    JSR     IDfromTree)MOVE    #rTree,D5    ; ja, exp. Item ist nicht definiert)JMP     SyntaxErr ); Ende der Beschreibung des Items CopInf4  RTS  CopInf1  MOVE.B  (A0)+,D0     ;Beschreibung kopieren)BEQ     CopInf4      ;fertig)CMPI.B  #1,D0        ;Ptr?)BEQ     CopInf10)CMPI.B  #2,D0        ;Const.L?)BEQ     CopInf2)CMPI.B  #3,D0        ;Const.W?)BEQ     CopInf3)CMPI.B  #4,D0        ;Unterbaum?)BEQ     CopInf7)CMPI.B  #5,D0        ;^ID? (auf 1. Enum-Elem), geht wie Ptr)BEQ     CopInf10)CMPI.B  #7,D0        ;Insert? -> ignorieren)BEQ     CopInf17)CMPI.B  #8,D0        ;^ID? (Enum-Elem-Kette), geht wie Ptr)BEQ     CopInf10)BRA     CopInf4      ;sonst ists eh zu ende  CopInf17 MOVEQ   #0,D0)MOVE.B  (A0)+,D0)SUB.L   D0,D2)BRA     CopInf1  CopInf2  SUBQ.L  #4,D2)BRA     CopInf1  CopInf3  SUBQ.L  #2,D2)BRA     CopInf1  CopInf7  ; Unterbaum prÅfen)SUBQ.L  #4,D2)MOVEM.L A0/D2,-(A7))MOVE.L  0(A1,D2.L),D2)BEQ     CopInf8      ;Unterbaum ist leer)CMP.L   D3,D2  ; durch unsigned Test werden auch pos. Werte erkannt)BCS     error)JSR     VerifyTree CopInf8  MOVEM.L (A7)+,A0/D2)BRA     CopInf1  CopInf10 ; Pointer und ID prÅfen)SUBQ.L  #4,D2)MOVE.L  0(A1,D2.L),D1)BEQ     CopInf1)CMP.L   D3,D1  ; durch unsigned Test werden auch pos. Werte erkannt)BCC     CopInf1)BRA     error"END END VerifyItem;  PROCEDURE VerifyKnot;"BEGIN$ASSEMBLER)CMP.L   D3,D4)BCS     error  ; durch unsigned Test werden auch pos. Werte erkannt)CMP.L   D3,D2)BCS     error  ; durch unsigned Test werden auch pos. Werte erkannt)SUBQ.L  #8,D2)JMP     VerifyItem'error)JSR     IDfromTree)MOVE.W  #rTree,D5)JMP     SyntaxErr$END"END VerifyKnot;  PROCEDURE VerifyTree;"BEGIN$ASSEMBLER); Lokalen Baum prÅfen. Adr in D2; Untergrenze in D3)LEA     VerifyKnot,A5)JSR     TravTr1$END"END VerifyTree;  PROCEDURE VerifyWholeTree;"BEGIN$ASSEMBLER); Ganzen Baum prÅfen.)MOVE.L  TreSpc,D3)LEA     VerifyKnot,A5 next     MOVE.L  (A6)+,D2      ;GLOBAL LEVEL)BMI     TravTr8)BEQ     next)BRA     TravTr9 TravTr8  JSR     TravTr1)BRA     next TravTr9  JMP     TravTr0$END"END VerifyWholeTree;   PROCEDURE FCKNOT; BEGIN  ASSEMBLER)CMPI.B  #50,D0         ; CONST (neu))BNE     FLKNOT3)BTST    #8+4,D0        ; exportiert?)BNE     useData        ;   ja -> in DATA ablegen)BTST    #8+5,D0        ; importiert?)BNE     FLKNOT3        ;   ja -> ignorieren)TST.L   -8-14(A1,D2.L) ;^letzte Ref)BEQ     FLKNOT3        ;   Null -> ignorieren); umkopieren in DATA-Puffer useData  MOVE.L  DataPtr,A0)MOVE.W  -8-16(A1,D2.L),D0 ;BYTELAENGE)ADDQ    #1,D0)BCLR    #0,D0)MOVE.W  D0,(A0)+             ;Grîûe d. Konst)MOVE.L  -8-14(A1,D2.L),(A0)+  ;^letzte Ref)TST.W   D0)BEQ     add0w)MOVE.L  D2,-(A7) ConsID3b MOVE.L  -8-20(A1,D2.L),(A0)+ ;KONSTANTE AUS BAUM KOPIEREN)SUBQ.L  #4,D2)SUBQ.W  #4,D0)BGT     ConsID3b)BEQ     ok2); es sind 2 Byte zuviel kopiert worden)SUBQ.L  #2,A0 ok2:     MOVE.L  (A7)+,D2); Strings im DATA mÅssen immer 0-terminiert werden: add0w:   MOVE.L  -8-10(A1,D2.L),D0 ;Typ)CMP.L   StrPtr,D0)BNE     notStrng)MOVE.W  -8-16(A1,D2.L),D0 ;BYTELAENGE)BEQ     add0w2)BTST    #0,D0)BEQ     isEven); wenn String ungerade LÑnge hat, einfach letztes Byte lîschen)CLR.B   -1(A0))BRA     notStrng FLKNOT3: RTS isEven   ; bei gerader LÑnge: prÅfen, ob 0C am Ende, sonst eins anfÅgen)TST.B   -1(A0))BEQ     notStrng add0w2:  MOVE.L  A0,-(A7))MOVE.L  DataPtr,A0)ADDQ.W  #2,(A0)        ; LÑnge des Datums im DATA-Puffer um 2 erhîhen)MOVE.L  (A7)+,A0)CLR.W   (A0)+ notStrng MOVE.L  A0,DataPtr)CMPA.L  DataEnd,A0)BLS     ok)MOVE    #rDaSpc,D5     ; DATA-Puffer Åbergelaufen)JMP     SyntaxErr ok: END END FCKNOT;  (*!* Die benutzten nicht-importierten CONSTS in den Data-Puffer umtragen!* (wird nur fÅr lokale Levels benutzt - globales wird direkt am Ende!* ohne Umweg Åber DATA-Puffer an den Code angehÑngt, damit Speicherplatz!* nicht so sehr verschwendet wird).!*)  PROCEDURE FinConst; BEGIN  ASSEMBLER)LEA    FCKNOT,A5)MOVE.L (A6),D2)BEQ    EMPTY)JMP    TravTr1 !EMPTY END END FINConst;  (*!* Alle Konstanten aus dem DATA-Puffer hinter den Code (A4)!* kopieren und dann Offsets f. Relozierliste festlegen.!* Die Offsets werden, ebenso wie die der Vars, relativ zum Codebeginn!* berechnet. So braucht dann beim Relozieren im Loader keine Fallunter-!* scheidung zw. Code, DATA und Vars gemacht werden. Nur der Linker muû das!* tun, weshalb er dazu im Modulheader die Grenze zw. Code und DATA erhÑlt.!* Das Ganze geschieht in 2 Routinen: Zuerst kopiert FinishData die Daten!* vom Puffer hinter den Code, dann erzeugt RelocData die Relozierliste.!*!* ZusÑtzlich werden auch die benamten Konstanten aus den globalen BÑumen!* direkt (ohne Umweg Åber DATA-Puffer) hinter den Code kopiert.!*)  PROCEDURE CopyDataToCode; BEGIN  ASSEMBLER)CMPI.B  #50,D0         ; CONST (neu))BNE     FLKNOT3)BTST    #8+4,D0        ; exportiert?)BNE     useData        ;   ja -> in DATA ablegen)BTST    #8+5,D0        ; importiert?)BNE     FLKNOT3        ;   ja -> ignorieren)TST.L   -8-14(A1,D2.L)  ;^letzte Ref)BEQ     FLKNOT3        ;   Null -> ignorieren useData  ; umkopieren in den Code)BSET    #2,-8-2(A1,D2.L))BNE     FLKNOT3        ; -> bereits bearbeitet)MOVE.W  -8-16(A1,D2.L),D0 ;BYTELAENGE)BEQ     add0w)ADDQ    #1,D0)BCLR    #0,D0)MOVE.W  D0,-8-16(A1,D2.L) ;aufgerundete LÑnge im Tree setzen)MOVE.L  D2,-(A7) ConsID3b MOVE.L  -8-20(A1,D2.L),(A4)+ ;KONSTANTE AUS BAUM KOPIEREN)SUBQ.L  #4,D2)SUBQ.W  #4,D0)BGT     ConsID3b)BEQ     ok2); es sind 2 Byte zuviel kopiert worden)SUBQ.L  #2,A4 ok2:     MOVE.L  (A7)+,D2); Strings im DATA mÅssen immer 0-terminiert werden: add0w:   MOVE.L  -8-10(A1,D2.L),D0 ;Typ)CMP.L   StrPtr,D0)BNE     notStrng)MOVE.W  -8-16(A1,D2.L),D0 ;BYTELAENGE)BEQ     add0w2)BTST    #0,D0)BEQ     isEven); wenn String ungerade LÑnge hat, einfach letztes Byte lîschen)CLR.B   -1(A4))BRA     notStrng isEven   ; bei gerader LÑnge: prÅfen, ob 0C am Ende, sonst eins anfÅgen)TST.B   -1(A4))BEQ     notStrng add0w2:  CLR.W   (A4)+)ADDQ.W  #2,-8-16(A1,D2.L) ;neue LÑnge im Tree setzen notStrng FLKNOT3: END END CopyDataToCode;  PROCEDURE FinishData;"BEGIN$ASSEMBLER)MOVEM.L A2-A3,-(A7))MOVE.L  A4,DataCodeOffs)MOVE.L  DataStart,A0 lup20:   CMPA.L  DataPtr,A0)BEQ     endOfD2)MOVE.W  (A0)+,D0)LSR     #1,D0)TST.L   (A0)+          ; ^letzte Ref)BEQ     lup21          ;   -> wenn Null, Åberspringen)BRA     lup23 lup22:   MOVE.W  (A0)+,(A4)+ lup23:   DBRA    D0,lup22)BRA     lup20 lup21:   ADDA.W  D0,A0)ADDA.W  D0,A0)BRA     lup20 endOfD2:); nun auch die globalen CONSTs aus dem Tree umtragen)LEA    CopyDataToCode,A5)JSR    TravTr          ; ALLE verbliebenen BÑume durchgehen)MOVEM.L (A7)+,A2-A3$END"END FinishData;  (*EOF*) 
(* $00002637$00003245$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$000010EE$FFFCF6BE$00009277$FFFCF6BE$000040AF$FFFCF6BE$FFF7AB10$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFF6EC04$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$00007D80$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BE$FFFCF6BEÄ$000010EET........T.......T......T.......T.......T.......T.......T.......T.......T.......$000090DC$0000916F$FFE030A8$FFE030A8$0000917C$0000916F$0000918F$0000925A$000010F8$00001019$00001083$00001022$00001083$000010F5$00008FF0$00009012∏ÄÉ*)
