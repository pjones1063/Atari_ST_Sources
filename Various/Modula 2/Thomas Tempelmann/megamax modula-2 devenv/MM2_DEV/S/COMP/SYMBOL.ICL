  (* ------------------------#Modula Compiler  /4.3/#------------------------##File mc3: Symbol-Handling, Typdeklaration&$30.3.85     GDOS Version%5.4.85     PrtVers mit InternVersion$13.4.85     Meldung von Runtime-Fehlern$16.5.85     '~' als Symbol #11 eingetragen$29.7.85     Fetch ueberspringt DLE + SpaceCount%7.8.85     Variant Records auf neue Syntax umgestellt%8.8.85     S(uffix Option%9.8.85     ATC vorbereitet (NICHT in Identifiern)$12.8.85     Compiler-Protokoll12 Fehler bei Pointer-Deklaration behoben (^bekannte Typen1und ^Record im Record selbst) ???$15.8.85     Pointer-Fehler wirklich behoben$25.8.85     Underscore in Identifiern zugelassen#17.10.85     Special Codes beruecksichtigen;0internationale Characters in Identifiern zugelassen (?!?);0Ausgabe von Punkten entfernt#11.12.85     NoReload-Flag verhindert Nachladen#21.02.86     GetSbl setzt LastGSD2 fuer Assembler#22.02.86     Neuordnung der Texte#23.02.86     Relay-Eintraege sind jetzt durch die Kennung 0.B0markiert, Highbyte undefiniert#26.02.86     Pointer und Opaques werden als Skalar-Typen markiert0(--> Var-kompatibel mit Long)#14.04.86     Sets ueber Subrange mit neg. Elementen verboten#15.04.86     Anpassung an neue Zeichensatz-Definition (AlfaTst, UpTst)#21.04.86     GetSbl ignoriert undefinierte Ctrl's im Text#25.04.86     $10000 Array-Elemente erlaubt statt $FFFF#08.09.86     Symbol 91 '* )' eingetragen (natuerlich ohne den Space);0bedingte Kommentare angefangen;0Adress-Synchronisation bei VarDec, RecordDec eingebaut#09.09.86     Symbol 92 'Assembler' eingetragen#06.10.86     bedingte Kommentare fertig, Syntax: ? <Boolean ConstEx>;0Records mit Wort-Feldern bekommen gerade Laenge#15.10.86     Standard-Bezeichner aus Symboltabelle entfernt#17.10.86     Deklaration von SET OF ByteTyp zugelassen#18.10.86     gesperrte Symbol jetzt '@@x' wegen Kollision mit Assembler;0in SetId Redeklaration von Pervasives erlaubt;0TreSrc durchsucht Pervasive Level ZULETZT#19.10.86     IniTre benutzt LocalSearch zum Eintragen der res. Worte, damit0die TreSrc-Aenderung von gestern nicht stoert#22.10.86     Array-Deklaration laesst fuer Elementlaenge 1/2/4/8 byte0auch Long-Indexbereich zu.0VarDec laesst auch Adresse 0 fuer externe Deklaration zu0(war bisher Code fuer 'intern');0in Prozedurtyp-Deklaration Open Array und String zugelassen;0in QualIds duerfen Spaces stehen (kein CR);0in Prozedurtyp-Beschreibung wird VarPar-Flag konsistent zu0ProzedurDekl. gesetzt (bit8 = VAR, bit15 = OpenArray).#25.10.86     ConstExpr liefert jetzt Typ auf IntStack, FolgeSymbol in D3.#28.10.86     res. Wort 'STRING' in Atari-Version entfernt#25.11.86     in SetType bei sTyp43 aufrunden von SETs auf Wortlaenge weg#14. 1.87     GetForm, FindForm fuer umschaltbares RealConst-Format;0Option F(ormat) in CompOpt ausgewertet.#30. 1.87     bei sTyp38 OpArr-Parameter by Value in Prozedurtypen erlaubt#02.03.87 TT  GetSbl: Bei Atari wird im Scanmode ErrorNr=0 gesetzt#07.04.87 TT  CompOpt: Abfrage auf X+ -> XtendedCode := TRUE#12.04.87 TT  pTxtLin wird in HandleCR gesetzt; GetSbl rettet Symbol-Adr0in pTxtSym#26.06.87     énderungen an den Compileroptionen (CompOpt):1$A und $X werden nur im Gepard-Modus ausgewertet;1im Atari-Mode $Extension statt $Suffix;1$x = implementiert (ohne Rekursion/Stack).0AlfaTst & UpTst: Abfragereihenfolge geschw.optimiert,1Erkennung von Endmarken >= $FE eingebaut.#27.06.87     Vorbereitung auf Module lokal zu Prozeduren:1TreSrc addiert bei lokalen Relays ScopeDifferenz auf TIEFE;1Typedec schreibt Relays mit 0-Scopedifferenz.#28.06.87     UpTst akzeptiert '_' wieder in IDs#03.07.87     $S-Option fÅr Atari: falls Dezimalzahl folgt, wird die als1neue Stackreserve (fÅr Runtime-Checks) interpretiert#07.07.87     bei Typdeklaration in Record-Feldern deklarierte IDs werden2nicht mehr ins lokale Record-Scope eingetragen (FldLst)#14.07.87     CompOpt: (Atari) bei $S muû +-= oder Zahl stehen, sonst Fehler~#28.08.87     sTyp setzt bei Deklaration von POINTER TO unknownType vorlÑufig2NIL als TypPtr ein (wichtig, falls TreeScan wegen Nachdekl.2eines Opaques folgt!)#14.09.87 TT  Neue Comp-Option $O: O+ erlaubt Opaque-Nackdeklaration#26.10.87     TypeDec (Subrange) lîst statt rIntXp rSclXp aus.0VarRec: Tagfeld-Adresse wird synchronisiert#27.10.87     Atari: Dump erzeugt TrapCode 9 in Asm-Zeilen#03.11.87 TT  Uses-Option bei Atari nicht durch ':' terminiert#17.11.87     Seriennummern an Symboltabelle angehÑngt, Initre schiebt1SerNr auf IntStack#15.12.87     Seriennummern jetzt mit SerLead-Kennung#02.06.88 TT  bufRes-Abfrage -> bufferRes; Fetch,GetSbl: DLE-Abfrage auch1bei Atari, LF-Abfrage ebenso#10.06.88 TT  Dump: LF wird Åbersprungen, DLE umgewandelt#29.06.88     TreSrc meldet fÅr pervasive-Objekte Tiefe -1.0Record-Deklaration: die bisher erzeugten Feldnamen des2definierten Records sind wÑhrend der weiteren Deklaration2nicht bekannt. (^lokales Scope wird jetzt in 'myScope'2gespeichert und nur zum Feld-Eintragen aktiviert!).#20.07.88     sTyp82: Vergleich Ober-/Untergrenze bei Subranges wird fÅr2LongCards unsigned durchgefÅhrt.#27.09.88     sTyp34: wenn Type a=knownEnum deklariert wird, werden in2den Element-Deskriptoren ggf. die Import-Flags geloescht2(damit sie exp. werden, falls wir in einem DefMod sind!).#15.12.88     compat hierher Åbernommen##10.12.89     Nachtrag der énderungen aus einteiligem Compiler:#(1.01.89     Macke in VarRec behoben: nach jeder <variant> wird jetzt6mindestens ein '|' gefordert!'29.01.89     Symbol 'REF' statt @@1 eingetragen (Nr. 70)'02.07.89     oneParam erkennt REF-Parameter in PROC-Typen und setzt7bit9 im VarPar-Wort;'13.05.89 TT  (Nachtrag) CompOpt: $U-Option lÑût bis zu 64 Zeichen lange7Namen zu (bisher nur 10)'25.07.89 TT  HandleCR, GetForm, GetSbl: Kînnen auch 'singleLine'-Mode7(Zeilen werden einzeln von auûen Åber Prozedur mitge-7teilt und enden mit Null-Zeichen).'16.09.89     RECORD-LÑngensynchronisation, wenn Wortfelder drin sind:7hinterlÑût jetzt auch in TypeLen den sync. Wert!7(vor noLnSync in SetType)'08.11.89     Record-Felder einer FieldList (durch ',' getrennt) jetzt7wahlweise in aufsteigender Reihenfolge: Option T+7(FldLst3)##13.12.89     neues reserviertes Wort LONGARRAY (Nr. 71).0VarDec legt Variablen stets auf gerade Adressen#14.12.89 TT  NachtrÑge:2- z.Zt. Kein Debug-Trap, in Assembler-Statements2- Bei $E-Option kann nun +/-/= folgen (z.Zt. ohne Leerzeichen!)0VarDec erlaubt Vars mit LÑnge Eins doch auf geraden Adr.#18.12.89 TT  Symbol '&&' definiert (Nr. 7) - dazu '#' auf Nr. 47 verschoben0und '&' auf 19 verschoben (stîhn!); In TrePrep doppeltes '&'0erkannt#05.01.90 TT  SetType: Arrays & Records kînnen nun beliebig groû werden; auch2Array-Elems kînnen > 64KB werden; Dazu die MULU durch Long-2Mul-Routinen ersetzt; Auûerdem Subrange-Type-Bestimmung in2SetType geÑndert: es wird dazu nun 'adjustSubrange' im2expressions-Modul aufgerufen#08.01.90 TT  Sets mit mehr als 1 Byte LÑnge werden immer auf WORD gerundet#01.02.90 TT  VarDec ein wenig mehr dokumentiert#08.02.90 TT  BITNUM in compat & BitNum berÅcksichtigt; SetType legt Sets0mit neg. lowbound oder highbound>31 nicht mehr null-based0sondern lowbound-based ab.#21.04.90 TT  D0-RÅckgabe wird nun Åber $Z+ (bisher J+) gesteuert#15.06.90 TT  Char-Literals werden nun als SS-Typen (StrPtr) behandelt und0erst beim Zuweisen ggf. nach CHAR gewandelt#30.06.90 TT  BITNUM-Sets und bei $U+ auch Sets, die in ein Reg passen,0werden mit Kennung 45 statt 5 versehen (sTyp22)#18.07.90 TT  Real-Literals werden nun ggf. ins andere Format ($F) gewandelt.#30.07.90 TT  Record-Felder um einen Eintrag zum Verketten der Reihenfolge1erweitert.#18.08.90 TT  Anpassung des Offsets zum lok. Record-Baum#17.09.90 TT  Nur bei Real-Konstanten im Float-Format wird das Flag f. die1erfolgte Benutzung von Real-Konsts gesetzt, nicht jedoch1bei binÑrer Angabe des Wertes mit dem 'R'-Suffix;0Rec-Variante von Kennung 16 auf 47 verlegt#26.09.90 TT  TreSrc, LocalSearch & GetSbl liefern in D1 ggf. ^Relay-Eintrag;0GetSbl setzt TextPtr f. Error-Anzeige bei Qualifiern auf den0selektierten ID; LONGARRAY auch in PROCEDURE-Types mîglich.0$E-Option wirkt nun bei allen Modulen (bisher nur Prgmodule).0TypeDec,SetType: Ptr- und Proc-Parm-Forward-Refs nun Åber ganzen2Block hinweg mîglich.#10.10.90 TT  vorlÑufig setzt $F* das TT-FPU-Flag#17.10.90 TT  Real-Format-X-Compile geht wieder#21.10.90 TT  Nach F* und Reg kînnen weitere Options folgen; "Reg" nun case-0sensitiv.#04.11.90 TT  Abs. Var-Dekl. geht nun von $0 bis $FFFFFFFD.#11.11.90 TT  VarDec: Jede Var (auch Byte-Vars) werden auf eine gerade Adr.0gelegt.#02.03.91 TT  compat4: Vergleich nun auch Procedures mit Proc-Types#19.04.91 TT  Fetch/GetSbl: Auch alleiniges LF wird als Zeilentrenner erkannt#15.09.91 TT  allocReg vergibt An bei PROCEDURE & Opaques auch, wenn Scalar-0Kennung nicht im Typ-Feld gesetzt ist.#13.10.91 TT  ProtLine-Aufruf: Scan-Offsets stimmen jetzt.#26.10.91 TT  compat4: Kein Buserror mehr bei Proc-Typen (wg. nicht gepoptem0Longword auf Stack).#27.10.91 TT  Dump: NUL wird als End of Line erkannt (f. GME)#13.12.93 TT  Neue Kennung 50 fÅr Konstanten: nun wird auch Adr/^letzte Ref0im Tree gespeichert.#24.01.94 TT  Konstanten-Kennung 18 wird bei Skalaren im DEF-Modul benutzt,0weil die sowieso seltenst als REF-Parms benîtigt werden und0sonst nur unnîtig Platz im Imp-Modul belegen.#13.02.94 TT  SetType wertet bei PROC-Types auch $\ und $[ aus.#----------------------------------------------------- *)  (*!*   INTEGER AUF STACK!*)  PROCEDURE PUSHINT; BEGIN ASSEMBLER)MOVE.L  ISTKPTR,A0)MOVE.L  D0,-(A0))CMPA.L  #INTSTKE,A0)BGT     ok)MOVE    #rIntOv,D5)JMP     SyntaxErr !ok      MOVE.L  A0,ISTKPTR!END END PUSHINT;  (*!*   INTEGER VON STACK!*)  PROCEDURE PULLINT; BEGIN ASSEMBLER)MOVE.L  ISTKPTR,A0)MOVE.L  (A0)+,D0)MOVE.L  A0,ISTKPTR END END PULLINT;) (*!*   Integer auf Stack ansehen!*)  PROCEDURE LOOKINT; BEGIN!ASSEMBLER&MOVE.L  ISTKPtr,A0    ;OBERSTES INT AUF STACK ABFRAGEN&MOVE.L  (A0),D0!END END LOOKINT;" (*!*   D1.B AUF LETTER ODER DIGIT PRUEFEN.!*   Carry Clear = "Letter or Digit"!*)  PROCEDURE AlfaTst; BEGIN ASSEMBLER)CMPI.B  #'Z',D1        ;erst die hÑufigen FÑlle: Groûbuchstaben ?)BHI     Alfa3)CMPI.B  #'@',D1)BCC     Alfa2          ;ok, ist Groûbuchstabe)CMPI.B  #'9',D1)BHI     Alfa1)CMPI.B  #'0',D1)BCC     Alfa2 Alfa1    ORI     #1,CCR Alfa2    RTS  Alfa3    CMPI.B  #'z',D1        ;Kleinbuchstabe ?)BHI     Alfa4)CMPI.B  #'a',D1)BCC     Alfa2)CMPI.B  #'_',D1        ;zw. Groû- und Kleinb. liegt '_')BNE     Alfa1)RTS)!Alfa4   CMPI.B  #$FE,D1)BCC     Alfa1          ;Endmarke)CMPI.B  #$C0,D1)BCC     Alfa2          ;also ein Umlaut oder so!END END AlfaTst;  (*!*   D1.B AUF LETTER ODER DIGIT PRUEFEN; KLEINBUCHSTABEN WANDELN!*   Carry Clear = "Letter or Digit"!*)  PROCEDURE UpTst; BEGIN ASSEMBLER)CMPI.B  #'Z',D1        ;Groûbuchstabe ?)BHI     Alfa4)CMPI.B  #'@',D1)BCC     Alfa2)CMPI.B  #'9',D1)BHI     Alfa1)CMPI.B  #'0',D1)BCC     Alfa2 Alfa1    ORI     #1,CCR)RTS Alfa3    ANDI.B  #$DF,D1        ;Kleinschrift weg fuer Buchstaben & Umlaute Alfa2    RTS  Alfa4    CMPI.B  #'z',D1        ;Kleinbuchstabe ?)BHI     Alfa5)CMPI.B  #'a',D1)BCC     Alfa3)CMPI.B  #'_',D1)BNE     Alfa1)RTS! Alfa5    CMPI.B  #$FE,D1)BCC     Alfa1          ;Endmarke)CMPI.B  #$E0,D1)BCC     Alfa3          ;kleiner internat. Buchstabe)CMPI.B  #$C0,D1)BCC     Alfa2          ;grosser internat. Buchstabe!END END UpTst; " (*!*   ------------------------------!*   ID AUF STACK!*   ------------------------------!*)  PROCEDURE PUSHID; BEGIN ASSEMBLER)MOVE.L  IDSTKPTR,A0 !PUSHID1 MOVE.B  (A2),D1       ;ENDE DES SYMBOLS IN SOURCE?)JSR     AlfaTst)BCS     PUSHID2)MOVE.B  D1,(A0)+      ;PUSH)CMPA.L  IDSTKEPtr,A0)BHI     ER8)BRA     ok !ER8     MOVE    #rIdOv,D5)JMP     SyntaxErr !ok      ADDQ.L  #1,A2)BRA     PUSHID1 PUSHID2  CLR.B   (A0)+)MOVE.L  A0,IDSTKPTR END END PUSHID;  (* * *   -------------------------------- *   ID VON STACK HOLEN *   -------------------------------- *) PROCEDURE LookId; BEGIN ASSEMBLER)MOVEA.L IDSTKPTR,A0)MOVE.B  -(A0),D0 LookId1  MOVE.B  -(A0),D0)BNE     LookId1)ADDQ.L  #1,A0 END END LookId;) PROCEDURE PULLID; BEGIN ASSEMBLER)JSR     LookId)MOVE.L  A0,IDSTKPTR END END PULLID;) (* CR-Handling; (A2) zeigt bereits hinter CR;    (D0) *) (*   HandleCR wird seit 3.6p auch bei Null-Chars aufgerufen; *) (*   im singleLine-Mode dient dies als Zeilenende, sonst ignorieren *)  PROCEDURE HandleCR; BEGIN ASSEMBLER)TST.W   singleLineMode)BEQ     notSL)JSR     GetNextLine    ; aus CompIO notSL    ADDQ.W  #1,LINE       ;ZEILEN gesamt ZAEHLEN)ADDQ.W  #1,txtLINE       ;ZEILEN im akt. Text ZAEHLEN)MOVE.L  A2,pTxtLin)MOVE.L  Options,D0)BTST    #4,D0         ;DEBUG?)BEQ     hcr1)MOVE.L  A2,LinePtr !hcr1    BTST    #16,D0)BEQ     hcr3          ;p- gesetzt: kein Protokoll)TST.W   ProtFile)BEQ     hcr3          ;ProtokollFile nicht offen)CLR.L   D0)TST.W   CodeGen)BEQ     hcr4)MOVE.L  A4,D0)SUB.L   Header,D0)SUB.L   HeaderLen,D0  ;D0 ist relative Adresse zum echten Codebeginn !hcr4    JSR     ProtLine      ;Zeile (A2) ins Protokoll schreiben !hcr3'END END HandleCR;  (* *   ------------------------------ *   CHAR AUS TEXT HOLEN *   ------------------------------ *   D2 := next char     (D0,A2) *)  PROCEDURE Fetch; BEGIN ASSEMBLER !FetchL  MOVE.B  (A2)+,D2      ;naechstes Zeichen holen)BEQ     Fetch32)CMPI.B  #dle,D2)BNE     Fetch3)ADDQ.L  #1,A2         ;Space-Zahl nach DLE ignorieren)BRA     FetchL !Fetch3  CMPI.B  #lf,D2        ;lf?)BEQ     Fetch32)CMPI.B  #cr,D2        ;cr?)BNE     Fetch5)CMPI.B  #lf,(A2)      ;cr+lf?)BNE     Fetch32)ADDQ.L  #1,A2 !Fetch32 JSR     HandleCR)BRA     Fetch1 !Fetch5  CMPI.B  #26,D2        ;Ctrl-Z)BEQ     endoftxt)CMPI.B  #EOF,D2       ;Ctrl-C)BNE     Fetch2 endoftxt CLR.L   LinePtr)JSR     EXCLUDE)BRA     FetchL !Fetch2  CMPA.L  bufferRes,A2)BCS     Fetch1)TST.W   NoReload      ;kommt gar nicht aus dem Text?)BNE     Fetch1)CLR.L   LinePtr)JMP     RELOAD        ;JA, NACHLADEN !Fetch1 END END Fetch;  PROCEDURE FetNoSp; BEGIN!ASSEMBLER !FETL    JSR     Fetch)CMPI.B  #SPC,D2)BLS     FETL (*$ ? runGep:)CMPI.B  #160,D2)BHI     ok)CMPI.B  #128,D2)BCC     FETL ok                       *)!END END FetNoSp;  (* /// unbenutzt (*!*   ----------------------------------------!*   FormConst zur Wahl des Realformats holen!*   ----------------------------------------!*)  PROCEDURE GetForm; BEGIN ASSEMBLER)LEA     FormConst,A0)JSR     FetNoSp    ;fuehrende Spaces & Ctrls weg)SUBQ.L  #1,A2 GetForm1 MOVE.B  (A2),D1       ;ENDE DES SYMBOLS IN SOURCE?)JSR     AlfaTst)BCS     GetForm2)MOVE.B  D1,(A0)+      ;kopieren)ADDQ.L  #1,A2)BRA     GetForm1 GetForm2 MOVE.B  #$00,(A0)+ END END GetForm;  (*    ---------------------------!*    Finde FormConst im ID-Baum.!*    ---------------------------!*!*    Ergebnis: wenn CC, zeigt (A1,D2.L) auf Baumeintrag!*)  PROCEDURE FindForm; BEGIN ASSEMBLER(MOVE.L  A2,-(A7)       ;alten TextPtr retten(LEA     FormConst,A2   ;^ID(MOVE.B  (A2),D2        ;1. Zeichen fuer TreSrc(JSR     TreSrc         ;im Baum suchen(MOVE.L  (A7)+,A2&END END FindForm; *)  (* *   ------------------------------- *   NEUEN ID HOLEN *   ------------------------------- *) PROCEDURE GETID; BEGIN!ASSEMBLER$JSR     GetSbl$JMP     GETID0!END END GETID;   (*!* Bei Einsprung an dieser Stelle muû auch D1 vom GetSbl-Aufruf erhalten sein!!*) PROCEDURE GETID0; BEGIN ASSEMBLER)BNE     NGETID1)JMP     GETID1        ;Id noch unbekannt !NGETID1 BMI     ok)MOVE    #rRedef,D5         ;keine Modula-Symbole umdef.bar)JMP     SyntaxErr !ok      TST.W   WASQUAL)BEQ     ok1)MOVE    #rBdQal,D5         ;und keine QualId's)JMP     SyntaxErr !ok1     MOVE.L  (A6),D0)BEQ     GTID2         ;dieses Scope leer: Id muss aus anderem sein)CMP.L   D0,D2         ;aktuelles Scope?)BGT     GTID2)TST.W   GLOBAL)BEQ     isglob)BTST    #6,-2(A1,D1.L) ;Export-Flag im Relay gesetzt?)BEQ     isglob)MOVE    #rMPass,D5     ;multi-pass dependency)JMP     SyntaxErr isglob   MOVE    #rId2,D5       ;Id declared twice)JMP     SyntaxErr !GTID2   JMP     GETID2        ;Id war in h|herem Scope def.!END END GETID0;) PROCEDURE GETID2; BEGIN ASSEMBLER)MOVE.L  D6,D0)MOVE.L  IDSTKPTR,A0)JMP     GETID3!END END GETID2;) PROCEDURE GETID3; BEGIN!ASSEMBLER !L1      SUBQ.L  #1,D0)MOVE.B  -8(A1,D0.L),(A0))CMPI.B  #$FE,(A0)+)BCS     L1             ; < $FE: weiter geht's)CLR.B   -1(A0))MOVE.L  A0,IDSTKPTR)RTS!END END GETID3;) PROCEDURE GETID1; BEGIN ASSEMBLER)TST.W   WASQUAL)BEQ     ok2)MOVE    #rBdQal,D5         ;NICHT HINTER QUALIFIERN)JMP     SyntaxErr !ok2     MOVE.B  (A2),D1)JSR     AlfaTST)BCC     ok3)MOVE    #rIdXp,D5          ;SONDERZEICHEN)JMP     SyntaxErr !ok3     JMP     PUSHID        ;ID AUS TEXT EINTRAGEN!END END GETID1;  PROCEDURE OLDID; BEGIN!ASSEMBLER)JSR     GetSbl        ;AUCH BEKANNTE ID'S ERLAUBT)JMP     OLDID0!END END OLDID;  PROCEDURE OLDID0; BEGIN ASSEMBLER)BEQ     GTID1)JMP     GETID2 !GTID1   JMP     GETID1 END END OLDID0;) (* *   ------------------------------- *   2 ID's auf IdStack vergleichen; * *   Ergebnis im ZeroFlag, *   ein ID bleibt auf dem Stack *   ------------------------------- *) PROCEDURE CHECKID; BEGIN ASSEMBLER)JSR     PULLID)MOVE.L  A0,A5)JSR     LookId)MOVE.L  Options,D3 CheckId1 MOVE.B  (A0)+,D0)MOVE.B  (A5),D1)EOR.B   D0,D1)BEQ     ok)BTST    #3,D3)BNE     diff          ;Case Sensitive)AND.B   #$DF,D1)BNE     diff           ;Abweichung ok       OR.B    (A5)+,D0)BNE     CheckId1 diff END END CHECKID;  PROCEDURE LABEL; BEGIN ASSEMBLER)MOVE.L  A4,D0)CLR.W   D7            ;KEINE KUERZUNG HINTER EINSPRUNGSTELLE)JMP     PUSHINT END END LABEL;) PROCEDURE ForwardRef; BEGIN ASSEMBLER)MOVE.L  A4,D0)JSR     PUSHINT)JMP     PUT2 END END ForwardRef;  PROCEDURE SolveLabel;"(*#* Setzt Offset des Labels (Adr. in D0) zu Code-Adr in D1#* (also zu BRAs, die schon mit Null-Offset kodiert wurden, z.B.#* bei 'ForwardRef', bei denen sich herausstellt, daû sie doch nicht#* 'forward' hÑtten sein brauchen)#*)"BEGIN$ASSEMBLER)MOVE.L  D1,A0)SUB.L   D0,D1)CMPI.L  #$8000,D1     ;WORD?)BCS     ok)MOVE    #rStruc,D5)JMP     SyntaxErr !ok      NEG.W   D1)MOVE.W  D1,(A0)$END"END SolveLabel;  PROCEDURE BRAToLabelD0;"(*#* Codiert BRA zum Label (Adr. in D0)#*)"BEGIN$ASSEMBLER)MOVE.W  #$6000,(A4)+  ;BRA.W)MOVE.L  A4,D1)SUB.L   D0,D1)CMPI.L  #$8000,D1     ;WORD?)BCS     ok)MOVE    #rStruc,D5)JMP     SyntaxErr !ok      CMPI.W  #$80,D1       ;Short?)BCC     wd)NEG.B   D1)MOVE.B  D1,-1(A4))RTS wd       NEG.W   D1)MOVE.W  D1,(A4)+$END"END BRAToLabelD0;  PROCEDURE BRAToLabel;"(*#* Codiert BRA zum Label (Adr. auf Int-Stack)#*)"BEGIN$ASSEMBLER)JSR     PULLINT)JMP     BRAToLabelD0$END"END BRAToLabel;  PROCEDURE TOHERE0; BEGIN ASSEMBLER)SUB.L   D2,D1)CMPI.L  #$8000,D1)BCS     ok)MOVE    #rStruc,D5)JMP     SyntaxErr !ok      MOVE.L  D2,A0)MOVE.W  D1,(A0))CLR.W   D7            ;KEINE KUERZUNGEN ERLAUBEN! END END TOHERE0;  PROCEDURE TOHERE; BEGIN ASSEMBLER)MOVE.L  A4,D1)JMP     TOHERE0 END END TOHERE;  PROCEDURE SETKNG; BEGIN ASSEMBLER)TST.W   GLOBAL)BNE     SETKNG1)BSET    #9,D0         ;FLAG GLOBAL ID !SETKNG1  MOVE.W  D0,-2(A1,D6.L) END END SETKNG;  (*!*  ------------------------------!*   GET SYMBOL!*  ------------------------------!*!*  Liefert in D1 ggf. ^Relay-Eintrag bei Userdef-Items - wenn kein Relay,!*  dann D1=D2!*)  PROCEDURE GetSbl; BEGIN  ASSEMBLER*TST.L   LinePtr       ;ZEILE FUER DEBUG?*BEQ     GetSbl17*JSR     Dump !GetSbl17 MOVE.L  FINDERROR,D0*BEQ     GetSbl18      ;nicht im Find-Modus*CMP.L   A4,D0*BHI     GetSbl18      ;Fehler-Pos noch nicht erreicht (*$ ? runGep:*MOVE.W  ERRORNR,D5    ;Runtime error + 1000*SUB.W   #100,D5      *) (*$ ? runST:*MOVEQ   #0,D5        *)*JMP     SYNTAXERR !GetSbl18 BSR     GetSbl20*CLR.W   WASQUAL*TST.W   D3*BPL     GetSbl21      ;RES. WORT*CMPI.B  #$10,D3       ;MODUL-QUALIFIER*BEQ     GetSbl22*CMPI.B  #$0F,D3       ;Lok. MODUL*BNE     GetSbl21 !GetSbl22 MOVE.L  A2,-(A7)      ;*** hinter Qualifier: folgt Punkt ? srchPd    MOVE.B  (A2)+,D0*CMPI.B  #' ',D0       ;Spaces ueberspringen, CR leider nicht*BEQ     srchPd*CMPI.B  #'.',D0*BEQ     foundPd*MOVE.L  (A7)+,A2      ;Punkt nicht gefunden: Qual. selbst liefern*BRA     GetSbl21 foundPd   ADDQ.L  #4,A7         ;*** QualId: folgenden Id holen*MOVE.W  #$FFFF,WASQUAL*MOVE.L  -6(A1,D2.L),D2 skipSpc   CMPI.B  #' ',(A2)+    ;auch hinter dem '.' Spaces ueberspringen*BEQ     skipSpc*SUBQ.L  #1,A2*MOVE.L  A2,pLastSym   ;Textptr merken*MOVE.L  A2,A0*MOVE.B  (A0)+,D1*JSR     LocalSearch*BCC     GetSbl21*CLR.W   D3 !GetSbl21 MOVE.L  D2,LastGSD2   ;fuer den Assembler retten*MOVE.W  D3,OLDSBL !GetSbl23 RTS ; !GetSbl1  ADDQ.L  #1,A2 !GetSbl20 TST.W   NoReload      ;kommt gar nicht aus dem Text?*BNE     GetSbl14*MOVE.L  A2,pLastSym   ;Textptr auf Beginn des Symbols merken*CMPA.L  bufferRes,A2  ;sollten wir mal wieder nachladen?*BCS     GetSbl14*JSR     RELOAD !GetSbl14 MOVEA.L A2,A0*MOVE.B  (A0)+,D2      ;laufendes Zeichen*BEQ     GetSbl92*CMPI.B  #EOF,D2*BNE     GetSbl9*JSR     EXCLUDE       ;INCLUDE BEENDEN*TST.W   ENDTEXT*BEQ     GetSbl20*BRA     GetSbl23      ;RTS !GetSbl9  CMPI.B  #lf,D2        ;lf?*BEQ     GetSbl92*CMPI.B  #cr,D2        ;cr?*BNE     GetSbl11*CMPI.B  #lf,(A0)      ;cr+lf?*BNE     GetSbl92*ADDQ.L  #1,A2 !GetSbl92 ADDQ.L  #1,A2*JSR     HandleCR*BRA     GetSbl20 !GetSbl11 CMPI.B  #dle,D2*BNE     GetSbl24      ;DLE UND SPACE-ZAHL IGNORIEREN*ADDQ.L  #1,A2*BRA     GetSbl1 !GetSbl24 CMPI.B  #spc,D2       ;restliche Ctrl's ignorieren*BLS     GetSbl1*; MOVE    D2,D0*; AND     #$7F,D0*; CMPI.B  #spc,D0*; BCS     Getsbl1*TST     AsmMode*BEQ     NOASS         ;KEINE ASSEMBLEROPTION ->*CMPI.B  #$3B,D2       ; ";"? ALS KOMMENTAR-START?*BNE     NOASS !ASCOMM   JSR     Fetch*TST.B   D2*BEQ     GetSbl20*CMPI.B  #cr,D2*BNE     ASCOMM*BRA     GetSbl20  !NOASS    CMPI.B  #'0',D2*BCS     GetSbl3       ;<'0'*CMPI.B  #'9',D2*BLS.L   NUMBER        ;<='9' !GetSbl3  CMPI.B  #'"',D2       ;" = STRING-DELIMITER*BEQ     GetSbl5*CMPI.B  #$27,D2       ;' AUCH*BNE     GetSbl6 !GetSbl5  JSR     ASTRING*MOVE.W  #STRCONST,D3*BRA     GetSbl15 !GetSbl6  JSR     TRESRC        ;ID SUCHEN*BCS.L   NOTFND        ;NICHT IM BAUM*CMPI.W  #13,D3        ;(* ?*BNE     GetSbl13*; Anfang des Kommentars merken f. evtl. Fehlermeldung.*MOVE.W  txtLine,cmtLine*MOVE.L  A2,D0*SUB.L   pTxtLin,D0*MOVE.W  D0,cmtCol*JSR     Comment*CLR     cmtLine*BRA     GetSbl20 GetSbl13  CMP.W   #91,D3        ;*) ?*BNE     GetSbl15*SUBQ.W  #1,OpenConds  ;wir sind hoffentlich in einem Conditional*BCC     GetSbl20      ;ja, ignorieren und Folgesymbol holen*MOVE    #rBdCom,D5        ;Invalid Comment Nesting*JMP     SyntaxErr !NOTFND   MOVEQ   #0,D3 !GetSbl15 RTS !NUMBER   MOVE.W  #NUMCONST,D3(END END GetSbl;  PROCEDURE SAMESBL; BEGIN  ASSEMBLER)MOVE.W  OLDSBL,D3'END END SAMESBL;) PROCEDURE ASTRING; (* holt String aus dem Text.)D3  = Endmarke ' oder "%StrBuf := String mit Null-Endmarke%StrLen := Laengenzaehler (in Char))A2 := A2 + StrLen *) BEGIN  ASSEMBLER)CLR.W   STRLEN        ;LAENGENZAEHLER)MOVE.L  A0,A2         ;'/" UEBERSPRINGEN)MOVE.W  #MaxStrLen,D1)SUBQ.W  #1,D1)LEA     STRBUF,A0)MOVE.B  D2,D3         ;DELIMITER !STRING1 JSR     Fetch)CMP.B   D2,D3         ;ENDE?)BEQ     STRING2)CMPI.B  #CR,D2)BNE     ok)MOVE    #rStrOv,D5          ;KEIN CR ERLAUBT)JMP     SyntaxErr !ok      MOVE.B  D2,(A0)+)ADDQ.W  #1,STRLEN)DBF     D1,STRING1)MOVE    #rStrOv,D5          ;STRING TOO LONG)JMP     SyntaxErr !STRING2 CLR.B   (A0)+ END END ASTRING;) (* Textzeile fuer Debug in den Code uebernehmen *)  PROCEDURE Dump; BEGIN  ASSEMBLER)TST.L   LinePtr)BEQ     Dump3         ;war nix mit Debug)TST.W   CodeGen)BEQ     Dump3         ;nix! )TST     AsmMode       ;Assembler-Modus ?);                     BNE     isAsm)BNE     Dump3         ;erstmal keine Ausgabe, wenn Asm-Teil)MOVEQ   #0,D0);                     BRA     notAsm ; isAsm                        MOVEQ   #9,D0 ; notAsm)JSR     PUTdebug)MOVE.L  LinePtr,A0 !Dump1   MOVE.B  (A0)+,D0)BEQ     Dump2          ; end of line)CMPI.B  #CR,D0)BEQ     Dump2)CMPI.B  #LF,D0)BEQ     Dump1)CMPI.B  #DLE,D0)BNE     Dump4)MOVE.B  (A0)+,D0)SUBI.B  #33,D0)BCS     Dump1 !Dump5   MOVE.B  #' ',(A4)+)SUBQ.B  #1,D0)BCC     Dump5)BRA     Dump1 !Dump4   MOVE.B  D0,(A4)+)BRA     Dump1 !Dump2   CLR.B   (A4)+)JSR     PUT0          ;SYNC !Dump3   CLR.L   LinePtr'END END Dump;  PROCEDURE Comment; BEGIN  ASSEMBLER*MOVEQ   #0,D3         ;INCL FLAG = FALSE*JSR     Fetch*CMPI.B  #'$',D2       ;COMPILER-OPTION?*BNE     Comment4*JSR     CompOpt*BNE     Comment6      ;war Conditional und wahr: Schluss mit Komm. !Comment4 CLR.W   D4            ;KOMMENTAR-LEVEL*BRA     Comment3 !Comment1 JSR     Fetch !Comment3 CMPI.B  #'(',D2*BNE     Comment2*JSR     Fetch*CMPI.B  #'*',D2*BNE     Comment3*ADDQ    #1,D4*BRA     Comment1 !Comment2 CMPI.B  #'*',D2*BNE     Comment1*JSR     Fetch*CMPI.B  #')',D2*BNE     Comment3*DBF     D4,Comment1*TST.W   D3*BEQ     Comment5      ;KEIN INCLUDE*JMP     INCLUDE !Comment6 ADDQ    #1,OpenConds  ;Ausgang fuer wahre Conditions !Comment5(END END Comment;   PROCEDURE validateOpts;  (* Options prÅfen/auswerten *)"BEGIN$ASSEMBLER(MOVE.L  Options,D0(BTST    #9,D0           ; $I(BNE     lng(; CARDINAL/INTEGER auf Short(MOVE.L  CardRel,D0(BEQ     noy                     ; Ptr noch nicht init.(MOVE.L  SCardPtr,-6(A1,D0.L)(MOVE.L  IntRel,D0(MOVE.L  SIntPtr,-6(A1,D0.L)$noy RTS$lng ; CARDINAL/INTEGER auf Long(MOVE.L  CardRel,D0(BEQ     noy                     ; Ptr noch nicht init.(MOVE.L  CardPtr,-6(A1,D0.L)(MOVE.L  IntRel,D0(MOVE.L  IntPtr,-6(A1,D0.L)$END"END validateOpts;   PROCEDURE CompOpt; (* wertet Compileroption nach *$  aus. (D0-D2) *)"BEGIN$ASSEMBLER CompOptL   JSR     FetNoSp+CMPI.B  #'?',D2   ;@ und ? auch erlaubt+BCC     ok ER21       MOVE    #rBdOpt,D5+JMP     SyntaxErr ok         CMPI.B  #'^',D2   ;[ \ ] und ^ sind auch erlaubt+BLS     CompOpt2+CMPI.B  #'a',D2+BCS     ER21+CMPI.B  #'z',D2+BHI     ER21  CompOpt2   ANDI.B  #$1F,D2+CMPI.B  #$1F,D2     ;*** ? Conditional Comment?+BNE     CompOpt17+MOVEM.L D3-D7/A1/A3-A6,-(A7)+JSR     GetSbl+JSR     ConstExpr   ;Boolean ConstEx als Parameter+JSR     PullInt+CMPI.B  #24,-1(A1,D0.L) ;Boolean ?+BNE     Er56+CMP.W   #25,D3      ;muss ':' sein+MOVEM.L (A7)+,D3-D7/A1/A3-A6+BNE     Er10+TST.W   AccuM1+BRA.L   CompOpt18   ;Zero-Flag enthaelt Information ueber T/F Er56       MOVE    #rBolXp,D5  ;Boolean Expr expected+JMP     SyntaxErr Er10       MOVE    #rColXp,D5  ;: expected+JMP     SyntaxErr  CompOpt17  ; zuerst prÅfen, ob es ein Schalter ist, sonst Sonderauswertung+CMPI.B  #'+',(A2)+BEQ.W   CompOpt14+CMPI.B  #'-',(A2)+BEQ.W   CompOpt14+CMPI.B  #'=',(A2)+BEQ.W   CompOpt14 +(* z.Zt. wird nur $F+/- ausgewertet+CMPI.B  #6,D2       ;*** F(ormat ID?+BNE     CompOpt19+JSR     GetForm+MOVE.W  #3,UseFormat;vor naechstem Real-Zugriff neue Auswertung+BRA.L   CompOpt5+*)+; nun vorlÑufig dennoch $F* f. TT-FPU verwenden:+CMPI.B  #'*',(A2)+BNE     CompOpt19+CMPI.B  #6,D2       ;$F?+BNE     CompOpt19++JSR     Fetch+MOVEQ   #2,D0+BRA.W   setFPUMode  CompOpt19  CMPI.B  #9,D2       ;*** I(nclude File)?+BNE     CompOpt8+JSR     PUSHFN      ;FileName holen+MOVEQ   #1,D3       ;Flag file include+BRA.L   CompOpt5  CompOpt8   CMPI.B  #$12,D2       ;*** Reg?+BNE     CompOpt21+CMPI.B  #'e',(A2)+BNE     CompOpt21+CMPI.B  #'g',1(A2)+BNE     CompOpt21+MOVE.B  2(A2),D1+JSR     UpTst+BCC     ER21+ADDQ.L  #2,A2+MOVE    #1,UseRegister+BRA.L   CompOpt5  CompOpt21  CMPI.B  #$15,D2     ;*** U(ses)?+BNE     CompOpt3+LEA     usesVOLUME,A0 (*$ ? Gepard: MOVEQ   #10,D2    MOVEQ   #':',D0     ;terminiert den Namen *) (*$ ? Atari:  MOVEQ   #64,D2    MOVEQ   #',',D0     ;terminiert den Namen *)+JSR     FetchString+BRA.L   CompOpt5  CompOpt3  (*$ ? Gepard: CMP.B   #19,D2      ;*** S(uffix) ?   *) (*$ ? Atari:  CMP.B   #05,D2      ;*** E(xtension ? *).BNE     CompOpt12 (*$ ? runGep: MOVEQ   #4,D2       ;max. 4 Chars *) (*$ ? runST:  MOVEQ   #3,D2       ;max. 3 Chars *).LEA     useSufx,A0.MOVEQ   #'*',D0     ;zus. Terminator.JSR     FetchString.BRA.L   CompOpt5  CompOpt12+CMP.B   #19,D2     ;*** S(tackcheck) ?+BNE     CompOpt14+JSR     FetNoSp    ;auûer +-= kann Grîûenangabe folgen+MOVE.L  D3,-(A7)+CLR.L   D3            ;Dezimales CARDINAL holen+CLR     -(A7)         ;Flag, daû Zahl vorhanden  ConCard1   SUBI.B  #'0',D2+BCS     ConCard2      ;ENDE DER ZAHL+CMP.B   #9,D2+BHI     ConCard2      ;    -"-+EXT     D2+EXT.L   D2+MULU    #10,D3+ADD.L   D2,D3+MOVE    #1,(A7)      ; Zahl geholt+JSR     FetNoSp+BRA     ConCard1 ConCard2   ADDI.B  #'0',D2+TST     (A7)++BEQ     er21         ; keine Zahl ? -> Fehler+MOVE.L  D3,StackReserve+MOVE.L  (A7)+,D3+BRA.W   CompOpt15+ CompOpt14  MOVE.W  D2,-(A7)+JSR     Fetch+MOVE.W  (A7)+,D0+CMPI.B  #'-',D2+BNE     CompOpt4+MOVE.L  Options,D2+MOVE.L  BackOpt,D1+BCLR    D0,D1+BCLR    D0,D2+BEQ     CompOpt11   ;war schon gelîscht+BSET    D0,D1       ;war gesetzt: BackOpt setzen (*$ ? Gepard:+CMPI.B  #1,D0       ;A-?+BNE     CompOpt11+ADDQ.L  #4,A6       ;Discard AsmScope+SUBQ.W  #4,ROSCOPE   *) +BRA     CompOpt11  CompOpt4   CMPI.B  #'+',D2+BNE     CompOpt16+MOVE.L  Options,D2+MOVE.L  BackOpt,D1+BSET    D0,D1+BSET    D0,D2+BNE     CompOpt11   ;war schon gesetzt+BCLR    D0,D1       ;war gelîscht: BackOpt lîschen  (*$ ? Gepard:+CMPI.B  #24,D0      ;X+?+BNE     CompOpt13+MOVE    #1,XtendedCode CompOpt13  CMPI.B  #1,D0       ;A+?+BNE     CompOpt11+MOVE.L  ASMSCOPE,-(A6) ;AssemblerScope oeffnen+ADDQ.W  #4,ROSCOPE   *)++BRA     CompOpt11  CompOpt16  CMPI.B  #'=',D2+BNE     Er21+MOVE.L  Options,D2+MOVE.L  BackOpt,D1+BCLR    D0,D2        ;alte Einstellung - ?+BTST    D0,D1        ;alte Einstellung testen+BEQ     CompOpt11    ;ok, war -+BSET    D0,D2        ;war ++ CompOpt11  MOVE.L  D2,Options+MOVE.L  D1,BackOpt +CMPI.B  #6,D0       ;$F ?+BNE     CompOpt5 +; Bei erstem $F-/+ UseFormat setzen, sonst Fehler melden+BTST    #6,D2+SNE     D0+ANDI    #1,D0 setFPUMode TST     RealIsUsed   ;Fehler, wenn bereits REALs benutzt wurden+BNE     tooLate+CMPI    #3,UseFormat ;wiederholtes $F ?+BCS     verifyForm   ; ja+MOVE    D0,UseFormat+BRA     CompOpt5  tooLate    MOVE    #rRlLat,D5+JMP     SyntaxErr  verifyForm CMP     UseFormat,D0+BEQ     CompOpt5     ;wiederholtes $F ist erlaubt, wenn identisch+MOVE    #rRealF,D5+JMP     SyntaxErr  CompOpt5   JSR     FetNoSp CompOpt15  CMPI.B  #',',D2      ;Einsprung von Atari $S-Option+BEQ     CompOptL+CLR.W   D0           ;setze Zero-Flag CompOpt18  SNE     -(A7)        ;zurueck mit NE: Conditional, ist auszuwerten@;zurueck mit EQ: Skip bis '* )'+JSR     validateOpts+TST.B   (A7)+$END"END CompOpt;!  (*!*   ID fuer TreeSearch vorbereiten;!*   A2 zeigt auf TextBuffer, erstes Zeichen in D1!*)! PROCEDURE TrePrep;  BEGIN ASSEMBLER(LEA     SRCBUF,A0(MOVE.L  A2,IDSTART(JSR     AlfaTST(BCS     TP1        ;Sonderzeichen(MOVE.L  Options,D0(BTST    #3,D0      ;Case sensitive?(BEQ     TP2        ; nein !TP3    MOVE.B  (A2)+,(A0)+(MOVE.B  (A2),D1(JSR     AlfaTST(BCC     TP3(BRA     TP4 !TP2    JSR     UPTST(BCS     TP4(MOVE.B  D1,(A0)+(ADDQ.L  #1,A2(MOVE.B  (A2),D1(BRA     TP2 !TP1    MOVE.B  (A2)+,D0(MOVE.B  (A2),D1(MOVE.B  D0,(A0)+(CMP.B   #':',D0(BEQ     TP11(CMP.B   #'<',D0(BEQ     TP10(CMP.B   #'>',D0(BEQ     TP11(CMP.B   #'(',D0(BEQ     TP12(CMP.B   #'*',D0(BEQ     TP13(CMP.B   #'&',D0(BEQ     TP14(CMP.B   #'.',D0(BNE     TP4(CMP.B   #'.',D1(BNE     TP4(BEQ     TP8 !TP14   CMP.B   #'&',D1(BNE     TP4(BEQ     TP8 !TP10   CMP.B   #'=',D1(BEQ     TP8(CMP.B   #'>',D1(BNE     TP4(BEQ     TP8 !TP11   CMP.B   #'=',D1(BNE     TP4(BEQ     TP8 !TP13   CMP.B   #')',D1(BNE     TP4(BEQ     TP8 !TP12   CMP.B   #'*',D1(BNE     TP4 !TP8    MOVE.B  (A2)+,(A0)+ !TP4    ST.B    (A0)+&END END TrePrep;  (*!*   ID (aus SrcBuf) im Baum ab (A1.D2.l) suchen!*!*   Liefert ^ID in D2, ^auf Relay-Eintrag in D1 - wenn kein Relay, dann D2=D1!*)! PROCEDURE TreSrc0;  BEGIN ASSEMBLER(MOVE.L  Options,D0(BTST    #3,D0          ;CASE SENSITIVE?(BNE     TU1            ;JA  ; TreeSearch ohne Case Sensitivity  !ts1    LEA     SRCBUF,A0(MOVE.L  D2,D6 !ts2    SUBQ.L  #1,D2(MOVE.B  -8(A1,D2.L),D1(CMP.B   #$FE,D1(BCC     ts3       ;$FF oder $FE(CMPI.B  #'a',D1(BCS     NOLC(CMPI.B  #'z',D1(BHI     NOLC(ANDI.B  #$DF,D1 !NOLC   CMP.B   (A0)+,D1(BEQ     ts2(BCS     ts4      ;ID im Text ist groesser(MOVE.L  -4(A1,D6.L),D2(BNE     ts1(SUBQ.L  #4,D6(BRA     ts5      ;Ende des Baums !ts4    MOVE.L  -8(A1,D6.L),D2(BNE     ts1(SUBQ.L  #8,D6 !ts5    MOVE.L  D6,Hook(ORI     #1,CCR(RTS !ts3    CMPI.B  #$FE,(A0)(BCS     ts4      ;war Ende im Baum: ID im Text groesser((; gesucht und gefunden... (Ausgang mit & ohne Case Sens.)( !ts6    CMPI.B  #$FF,D1(BEQ     ts7(SUBQ.L  #1,D2 !ts7    SUBQ.L  #8,D2(MOVE.L  D2,D1          ;damit wir spÑter Åber D1 an Relay-Eintrag kommen(MOVE.W  -2(A1,D2.L),D3(TST.B   D3             ;ist das vielleicht nur ein Relay-Eintrag?(BNE     ts9            ;nein!(MOVE.W  -8(A1,D2.L),D0 ;bei lokalen Relays: Åberspr. ScopeDifferenz(MOVE.L  -6(A1,D2.L),D2(BTST    #1,-2(A1,D2.L) ;gezeigtes Objekt global?(BNE     ts8            ; ja, keine gÅltige ScopeDiff(ADD.W   D0,Tiefe       ; nein, Scope-Tiefe korrigieren !ts8    MOVE.W  -2(A1,D2.L),D3 !ts9    RTS  ; TreeSearch mit Case Sensitivity  !TU1    LEA     SRCBUF,A0(MOVE.L  D2,D6 !TU2    SUBQ.L  #1,D2(MOVE.B  -8(A1,D2.L),D1(CMP.B   #$FE,D1(BCC     TU3      ;$FF oder $FE(CMP.B   (A0)+,D1(BEQ     TU2(BCS     TU4      ;ID im Text ist groesser(MOVE.L  -4(A1,D6.L),D2(BNE     TU1(SUBQ.L  #4,D6(BRA     TU5      ;Ende des Baums !TU4    MOVE.L  -8(A1,D6.L),D2(BNE     TU1(SUBQ.L  #8,D6 !TU5    MOVE.L  D6,Hook(ORI     #1,CCR(RTS !TU3    CMPI.B  #$FE,(A0)(BCS     TU4      ;war Ende im Baum: ID im Text groesser(BRA     ts6'END END TreSrc0;( (*!*  ------------------------------!*  TREE-LEVEL (A1.D2) DURCHSUCHEN!*  ------------------------------!*!*  A2 = ^Id-Anfang, D1 = 1. Zeichen des ID!*!*   Liefert ^ID in D2, ^auf Relay-Eintrag in D1 - wenn kein Relay, dann D2=D1!*)  PROCEDURE LocalSearch; BEGIN  ASSEMBLER)JSR     TREPREP)JSR     TRESRC0)BCC     FOUND)MOVE.L  IDSTART,A2 !FOUND'END END LocalSearch;  (*!*   ----------------------------------!*   ALLE SICHTBAREN SCOPES DURCHSUCHEN!*   ----------------------------------!*!*   A2 = ^Id-Anfang, D2 = 1. Zeichen des ID!*!*   Liefert ^ID in D2, ^auf Relay-Eintrag in D1 - wenn kein Relay, dann D2=D1!*)  PROCEDURE TRESRC; BEGIN  ASSEMBLER*MOVE.B  D2,D1*JSR     TREPREP*MOVE.W  #$FFFF,TIEFE*MOVE.L  A6,-(A7) !TRESRC22 ADDQ.W  #1,TIEFE      ;aktuelles Scope ist Tiefe 0*MOVE.L  (A6)+,D2*BEQ     TRESRC22      ;leeres Level, aber auch Pervasive Scope!*BPL     TRESRC21      ;Endmarke (Modul-Scopegrenze)*JSR     TRESRC0*BCS     TRESRC22      ;noch nicht gefunden - weiter*MOVE.L  (A7)+,A6 !TRESRC20 RTS !TRESRC21 MOVE.L  (A7)+,A6*MOVE.W  #$FFFF,TIEFE*MOVEQ   #0,D2*JSR     TRESRC0       ;Pervasive TREE*BCC     TRESRC20      ;gefunden*MOVE.L  IDSTART,A2"END END TRESRC;   (*!*   ------------------------------!*   RESERVIERTE WORTE!*   ------------------------------!*)  PROCEDURE SYMBOL; BEGIN  ASSEMBLER)ACZ     'EXPORT'       ; Nr. 1)ACZ     '+')ACZ     '-')ACZ     '*')ACZ     '/')ACZ     ':=')ACZ     '&&'   ; 7)ACZ     '..')ACZ     '.')ACZ     ',')ACZ     ';')ACZ     '~')ACZ     '(*')ACZ     '(')ACZ     '['    ; 15)ACZ     '{')ACZ     '^')ACZ     '=')ACZ     '&'    ; 19)ACZ     '<>')ACZ     '<=')ACZ     '>=')ACZ     '<')ACZ     '>')ACZ     ':')ACZ     ')')ACZ     ']')ACZ     '}'    ; 28)ACZ     '|')ACZ     '!')ACZ     'IF')ACZ     'THEN')ACZ     'ELSE')ACZ     'ELSIF')ACZ     'END')ACZ     'BEGIN')ACZ     'REPEAT')ACZ     'UNTIL')ACZ     'WHILE')ACZ     'DO')ACZ     'LOOP')ACZ     'FOR')ACZ     'TO')ACZ     'BY'           ; 44)ACZ     'CASE')ACZ     'OF' (*$ ? Gepard:)ACZ     'STRING'  *) (*$ ? Atari:)ACZ     '#'       *)   ; Nr. 47)ACZ     '@@Y'          ;ehem. 'ADR')ACZ     '@@Z'          ;ehem. 'TSIZE')ACZ     'DIV')ACZ     'MODULE')ACZ     'MOD')ACZ     'IN')ACZ     'EXIT')ACZ     'WITH')ACZ     'VAR')ACZ     'CONST')ACZ     'TYPE')ACZ     'PROCEDURE')ACZ     'ARRAY')ACZ     'SET')ACZ     'POINTER')ACZ     'RECORD')ACZ     'QUALIFIED')ACZ     'RETURN')ACZ     'IMPLEMENTATION')ACZ     'DEFINITION')ACZ     'FROM')ACZ     'IMPORT')ACZ     'REF')ACZ     'LONGARRAY')ACZ     '@@3'           ;'SIZE')ACZ     '$')ACZ     '@@4'           ;'NIL')ACZ     '@@5'           ;'INC')ACZ     'PERVASIVE')ACZ     '@@6'           ;'NEW')ACZ     '@@7'           ;'DISPOSE')ACZ     '@@8'           ;'EXCL')ACZ     '@@9'           ;'INCL')ACZ     '@@A'           ;'DEC')ACZ     '@@B'           ;'ABS')ACZ     '@@C'           ;'ORD')ACZ     'TABLE')ACZ     '@@D'           ;'HIGH')ACZ     '@@E'           ;'ODD')ACZ     '@@F'           ;'EXPAND')ACZ     '@@G'           ;'SHORT')ACZ     '@@H'           ;'VAL')ACZ     'FORWARD')ACZ     '*)')DC.B    0)SYNC)DC.W    SerLead0, SerVal0, SerLead2, SerVal2 END END SYMBOL;  FORWARD ASMSBL; FORWARD BOTHSBL;  (* *   ------------------------------ *   ID-BAUM INITIALISIEREN *   ------------------------------ *) PROCEDURE INITRE; BEGIN ASSEMBLER)MOVE.L  SYMTRE,A1)CLR.L   TRESPC)MOVE.L  A2,-(A7) ; ; RESERVIERTE WORTE)MOVEQ   #1,D5       ;KENNUNG FUER 1. SYMBOL)LEA     SYMBOL,A0     ;^SYMB.TABELLE)CLR.L   -(A6))JSR     SETIDI        ;ERSTES SYMBOL EINTRAGEN)SUBQ.L  #2,D6)MOVE.W  D5,0(A1,D6.L)  ;KENNUNG EINTRAGEN)MOVE.L  D6,TRESPC)ADDQ.W  #1,D5)MOVEA.L A0,A2         ;^ID'S WEITERSTELLEN)MOVE.B  (A2),D1       ;ERSTER BUCHSTABE INITRE2  CLR.L   D2)JSR     LocalSearch)MOVE.L  A2,A0         ;^ID-NAME)JSR     SETID2)SUBQ.L  #2,D6)MOVE.W  D5,0(A1,D6.L)  ;KENNUNG EINTRAGEN)MOVE.L  D6,TRESPC)ADDQ.W  #1,D5)MOVEA.L A0,A2         ;^ID'S WEITERSTELLEN)MOVE.B  (A2),D1       ;ENDMARKE?)BNE     INITRE2       ; NEIN) ; jetzt die Seriennummern auf den IntegerStack ^^^))ADDQ.L  #1,A2)MOVE.W  A2,D0)BTST    #0,D0)BEQ     ISEVEN)ADDQ.L  #1,A2"iseven CLR.L   D0)MOVE.W  2(A2),D0)JSR     PushInt)MOVE.W  6(A2),D0)JSR     PushInt  ; AND/OR/NOT))LEA     BOTHSBL,A2    ;^SYMB.TABELLE)MOVE.W  (A2)+,D5      ;KENNUNG INITRE1  MOVE.B  (A2),D1       ;ERSTER BUCHSTABE)CLR.L   D2)JSR     LocalSearch)MOVE.L  A2,A0         ;^ID-NAME)JSR     SETID2)SUBQ.L  #2,D6)MOVE.W  D5,0(A1,D6.L)  ;KENNUNG EINTRAGEN)MOVE.L  D6,TRESPC)MOVE.L  A0,D0)BTST    #0,D0)BEQ     INITRE5)ADDQ.L  #1,D0 !INITRE5  MOVE.L  D0,A2         ;^ID'S WEITERSTELLEN)MOVE.W  (A2)+,D5      ;ENDMARKE?)BNE     INITRE1       ; NEIN  ; ASSEMBLER-SYMBOLE))MOVEQ   #FirstAsmSbl,D5)LEA     ASMSBL,A0     ;^SYMB.TABELLE)CLR.L   -(A6)         ;NEUES SCOPE)JSR     SETIDI)SUBQ.L  #2,D6)MOVE.W  D5,0(A1,D6.L)  ;KENNUNG EINTRAGEN)MOVE.L  D6,TRESPC)ADDQ.W  #1,D5)MOVEA.L A0,A2         ;^ID'S WEITERSTELLEN)MOVE.B  (A2),D1       ;ERSTER BUCHSTABE INITRE4  MOVE.L  (A6),D2)JSR     LocalSearch)MOVE.L  A2,A0         ;^ID-NAME)JSR     SETID2)SUBQ.L  #2,D6)MOVE.W  D5,0(A1,D6.L)  ;KENNUNG EINTRAGEN)MOVE.L  D6,TRESPC)ADDQ.W  #1,D5)MOVEA.L A0,A2         ;^ID'S WEITERSTELLEN)MOVE.B  (A2),D1       ;ENDMARKE?)BNE     INITRE4       ; NEIN)MOVE.L  (A6)+,ASMSCOPE)MOVE.L  (A7)+,A2 END END INITRE;) (* *   ------------------------------ *   ID IN BAUM EINTRAGEN *   ------------------------------ *) PROCEDURE SETIDI; BEGIN ASSEMBLER)MOVE.L  TRESPC,D6)MOVE.L  D6,(A6)      ;NEUES SCOPE)JMP     SETID0 END END SETIDI;) PROCEDURE SETPER; BEGIN ASSEMBLER)MOVE.L  A2,-(A7))MOVE.L  A0,-(A7))MOVE.L  A0,A2)MOVE.B  (A2),D1)CLR.L   D2            ;IM PERVASIVE LEVEL SUCHEN)JSR     LocalSearch)MOVE.L  (A7)+,A0      ;^ANFANG IM TEXT)MOVE.L  (A7)+,A2)BCC     ER18         ;DECLARED TWICE)JMP     SETID2 !ER18    MOVE    #rId2,D5)JMP     SyntaxErr END END SETPER;  PROCEDURE SETID; BEGIN ASSEMBLER)MOVE.L  A2,-(A7)      ;*** ID IM OBERSTEN LEVEL EINTRAGEN)MOVE.L  A0,-(A7))MOVE.L  A0,A2)MOVE.W  ROSCOPE,D0    ;Offset fuer ReadOnly-Scopes (Assm,With))MOVE.L  0(A6,D0.W),D2)BNE     SETID9)MOVE.L  TRESPC,D6     ;FRISCHES DISPLAY)MOVE.L  D6,0(A6,D0.W))MOVE.L  (A7)+,A0)MOVE.L  (A7)+,A2)JMP     SETID0 SETID9   MOVE.B  (A2),D1)JSR     LocalSearch   ;IM OBERSTEN LEVEL SUCHEN)MOVE.L  (A7)+,A0      ;^ANFANG IM TEXT)MOVE.L  (A7)+,A2)BCS     STID2)JSR     LoadBadID)TST.W   GLOBAL)BEQ     isglob)BTST    #6,-2(A1,D1.L) ;Export-Flag im Relay gesetzt?)BEQ     isglob)MOVE    #rMPass,D5     ;multi-pass dependency)JMP     SyntaxErr isglob   MOVE    #rId2x,D5)JMP     SyntaxErr !STID2   JMP     SETID2 END END SETID;  PROCEDURE SETID2; BEGIN ASSEMBLER)MOVE.L  Hook,D1)MOVE.L  TRESPC,D6)MOVE.L  D6,0(A1,D1.L)  ;NEUEN EINTRAG ANBINDEN)JMP     SETID0 END END SETID2;  PROCEDURE SETID0; BEGIN ASSEMBLER)CLR.L   -4(A1,D6.L)   ;LEERER ^FOLGEKNOTEN)CLR.L   -8(A1,D6.L)   ;      - " - SETID1   MOVE.B  (A0)+,D1      ;ENDE DES SYMBOLS IN SOURCE?)BEQ     SetId6        ;Zero als Endmarke)CMP.B   #$FE,D1)BCC     SETID6        ;$FE / $FF als Endmarke)MOVE.B  D1,-9(A1,D6.L) ;NICHT ID-ENDE: ZEICHEN EINTRAGEN)SUBQ.L  #1,D6         ;^NAECHSTES ZEICHEN)BRA     SETID1 SETID6   BTST    #0,D6         ;ID-ENDE: GERADE ADRESSE?)BNE     SETID12       ;NEIN)MOVE.B  #$FE,-9(A1,D6.L) ;JA, AUSGLEICHEN)SUBQ.L  #1,D6 SETID12  MOVE.B  #$FF,-9(A1,D6.L) ;ENDMARKE)SUBI.L  #9,D6         ;^BAUMENDE)MOVE.L  D6,TRESPC     ;NEUER POINTER AUF BAUMENDE END END SETID0;  (*!* Ist fÅr benutzte Bezeichner nach GetSbl/TreSrc aufzurufen.!* Legt im akt. Scope eine Kopie der ID mit Relay auf Original an,!* wenn die ID auf einem tieferen Scope kommt.!*) PROCEDURE COPYID;"BEGIN$ASSEMBLER)MOVE.W  D0,-(A7))MOVE.W  ROSCOPE,D0    ;Offset fuer ReadOnly-Scopes (Assm,With))LSR.W   #2,D0         ;durch 4 teilen)SUB.W   Tiefe,D0)BCS     copySbl       ;kommt aus tieferem Scope - Relay erzeugen)MOVE.W  (A7)+,D0)RTS copySbl  NEG.W   D0            ;Nun haben wir die Tiefe der writeable Scopes)MOVE.W  D0,-(A7))MOVE.L  D2,-(A7))LEA     SRCBUF,A0)JSR     SetID)MOVE.L  TRESPC,D6 ;!!! KANN WEG)MOVE    #$C000,D0     ;Exported-Flag setzen)JSR     SetKng)MOVE.L  (A7)+,D2)MOVE.L  D2,-6(A1,D6.L) ;Relay-Verweis auf Original-ID)MOVE.W  (A7)+,-8(A1,D6.L) ;Scope-Differenz)MOVE.W  (A7)+,D0)SUBQ.L  #8,TRESPC)MOVE.L  D6,D1$END"END COPYID;  (*!*   ID A0^ IM BAUM SUCHEN!*)  PROCEDURE SEARCHID; BEGIN ASSEMBLER)MOVE.L  A2,-(A7))MOVE.L  A0,A2)MOVE.B  (A2),D2)JSR     TRESRC)BCC     SRCID1        ;GEFUNDEN)CLR.W   D3 SRCID1   MOVE.L  (A7)+,A2 END END SEARCHID;   PROCEDURE compat4 (); BEGIN ASSEMBLER)CMP.L   SBothTyp,D0)BEQ     compat7)CMP.L   ZZTyp,D0)BEQ     compatzz)CMP.L   BothTyp,D0)BEQ     compat1)CMP.L   CardPtr,D0)BEQ     compat5)CMPI.B  #20,-1(A1,D0.L) ;POINTER?)BEQ     compat5         ; ist kompat. mit Adr)CMPI.B  #19,-1(A1,D0.L) ;PROC-Typ (19)?)BEQ     compat6)CMPI.B  #6,-1(A1,D0.L)  ;PROCEDURE?)BEQ     compat8 compat2  RTS                     ; sonst nicht kompatibel compat7  CMP.L   SIntPtr,D2)BEQ     compat2)CMP.L   SCardPtr,D2)BEQ     compat2)CMPI.B  #41,-1(A1,D2.L)        ;Bitnum?)RTS compatzz CMPI.B  #41,-1(A1,D2.L)        ;Bitnum?)BEQ     compat2)CMP.L   SIntPtr,D2)BEQ     compat2)CMP.L   SCardPtr,D2)BEQ     compat2 compat1  CMP.L   CardPtr,D2)BEQ     compat2)CMP.L   IntPtr,D2)BEQ     compat2 compat5  CMPI.B  #23,-1(A1,D2.L)        ;Address?)RTS compat6  ; Proc-Type 19: hier nur 44 zulassen, 6 kommt Åber 'compat8'); dran und darf hier nicht kommen, weil sonst als Result-Type in D2); die 6 geliefert wÅrde - es muû hier aber 19 geliefert werden.)MOVEM.L D1-D1,-(A7))CMPI.B  #44,-1(A1,D2.L))BNE     compat20 asc20    JSR     AsComp20 noGlobls TST     D1 compat20 MOVEM.L (A7)+,D1-D1     ; CCR bleibt erhalten)RTS compat8  ; Proc-Type 6: 44 immer OK, 19 nur, wenn globale Proc)MOVEM.L D1-D1,-(A7))MOVE.W  -2(A1,D2.L),D1)CMPI.B  #44,D1)BEQ     asc20)CMPI.B  #19,D1)BNE     compat20)BTST    #1,-2(A1,D0.L)  ; nur globale Procs erlaubt)BNE     asc20)BRA     noGlobls        ; D1 ist nicht Null -> liefert NE END END compat4;  PROCEDURE constTyp ();"(* liefert ZZTyp fÅr alle whole numbers *)"BEGIN$ASSEMBLER)CMP.L   SBothTyp,D0)BEQ     compat2)CMP.L   BothTyp,D0)BEQ     compat2)CMP.L   SIntPtr,D0)BEQ     compat2)CMP.L   SCardPtr,D0)BEQ     compat2)CMP.L   CardPtr,D0)BEQ     compat2)CMP.L   IntPtr,D0)BEQ     compat2)RTS compat2  MOVE.L  ZZTyp,D0$END"END constTyp;  PROCEDURE compatRR (); BEGIN ASSEMBLER)CMPI.B  #11,-1(A1,D2.L) ;SUBRANGES WEG)BNE     compat8)MOVE.L  -18(A1,D2.L),D2 ;BASETYPE compat8  CMPI.B  #11,-1(A1,D0.L))BNE     compat9)MOVE.L  -18(A1,D0.L),D0 ;BASETYPE compat9  CMP.L   D0,D2)BEQ     compat2       ;DIREKT GLEICH)JSR     compat4)BEQ     compat2)EXG     D0,D2)JSR     compat4       ;ECHTER TYP IST IN D2 compat2 END END compatRR;  PROCEDURE compatConstRR ();"(*#* wie compatRR, nur sind hier alle Zahl-Typen zueinander kompatibel,#* unabhÑngig von ihrer Grîûe -> Grîûenvergleich muû Åber extra Bounds-#* Check gemacht werden. Wird z.B. so von Subrange-Auswertung in SetType#* benutzt, der Range-check wird dann von 'adjustSubrange' erledigt.#*)"BEGIN$ASSEMBLER)CMPI.B  #11,-1(A1,D2.L) ;SUBRANGES WEG)BNE     compat8)MOVE.L  -18(A1,D2.L),D2 ;BASETYPE compat8  CMPI.B  #11,-1(A1,D0.L))BNE     compat9)MOVE.L  -18(A1,D0.L),D0 ;BASETYPE compat9  JSR     constTyp)EXG     D0,D2)JSR     constTyp)CMP.L   D0,D2)BEQ     compat2       ;DIREKT GLEICH)JSR     compat4)BEQ     compat2)EXG     D0,D2)JSR     compat4       ;ECHTER TYP IST IN D2 compat2 END END compatConstRR;  PROCEDURE compatR; BEGIN ASSEMBLER)JSR     PullInt)JMP     compatRR END END compatR;  PROCEDURE compat; BEGIN ASSEMBLER)JSR     PullInt)MOVE.L  D0,D2)JMP     compatR END END compat;) PROCEDURE TypeDec; BEGIN ASSEMBLER !TypeDec2 JSR     GetSbl           ;jetzt sollte ein ID kommen*BEQ     TYPEDE10         ; wie erwartet: noch unbekannt*BPL     TYPEDE11         ; ein Standard-Symbol (VAR, PROCEDURE...) !TYPEDE10 BSR     TypeDec0         ;ID und Deklaration verarbeiten*CMPI.W  #11,D3*BEQ     TypeDec2*MOVE    #rSemXp,D5*JMP     SyntaxErr !TYPEDE11 JMP     SAMESBL  intError  TRAP    #6*DC.W    -120           ;lîst internen Fehler aus  !TypeDec0 BEQ.L   TypeDec3       ;unbekannte IDs normal deklarieren**CMPI.B  #48,D3         ;Fwrd-Typ?*BNE     TypeDec1       ;nî**; Forward-Typ nachdeklarieren, D1 enthÑlt ^Relay-Eintrag**MOVE.L  D1,-(A7)*BSR.W   TypeDec6       ;erstmal Typ vollst. deklarieren*MOVE.L  (A7)+,D1*MOVE.L  D2,-6(A1,D1.L) ;Relay verweist nun auf neuen Typ*; Baum im akt. Level (und nur dort) durchsuchen nach Usern des*; Relays und dort den Ptr auf den neuen Typen eintragen*; Da so fast alles wie bei nachdekl. Opaques geht, nehmen wir*; einfach die selbe Routine dafÅr*JMP     NewOpaque  !TypeDec1 TST.W   GLOBAL*BNE.L   TypeDec4       ;lokales Level: keine Opaque-Nachdekl. *; Nachdeklaration eines Opaques *CMPI.B  #8,D3          ;redeclarable Opaque-Typ?*BEQ     ok1*CMPI.B  #25,D3          ;Opaque-Typ?*BNE     bad1*MOVE.L  Options,D0*BTST    #15,D0*BNE     ok1            ;o+: opaque dÅrfen erneut decl. werden bad1      MOVE    #rId2,D5       ;  nein: Id decl twice*JMP     SyntaxErr !ok1      MOVE.L  D2,-(A7)*JSR     GetSbl*CMPI.W  #18,D3         ;=*BEQ     ok2*MOVE    #rEqlXp,D5*JMP     SyntaxErr !ok2      MOVE.W  #1,newtyp*JSR     SetType*CMPI.L  #4,TypeLen      ;RICHTIGE LAENGE?*BNE     bad3*CMPI.B  #20,-1(A1,D2.L) ;POINTER*BEQ     TypeDec5*BTST    #0,-2(A1,D2.L) ; ODER SKALAR?*BNE     TypeDec5 bad3      MOVE    #rBdOpq,D5*JMP     SyntaxErr !TypeDec5 MOVE.L  (A7)+,D0*CLR.W   -2(A1,D0.L)*MOVE.L  D2,-6(A1,D0.L)*MOVE.L  D0,D1*JMP     NewOpaque     ;alte Referenzen durch neuen ^ ersetzen  !TypeDec4 TST.W   D3 !TypeDec3 JSR     GETID0*JSR     PULLID*JSR     SETID  TypeDec6  JSR     GetSbl*CMPI.W  #18,D3        ;'='*BNE     L1*MOVE.W  #1,newTyp*JMP     SetType !L1       CMPI.W  #3,IPFLAG     ;OPAQUE TYPE: DEFMODUL?*BEQ     ok4*MOVE    #rEqlXp,D5*JMP     SyntaxErr !ok4      MOVE.L  TRESPC,D6*MOVE.W  #$8519,D0     ;Opaque Type eintragen*JSR     SETKNG*MOVEQ   #4,D0*MOVE.L  D0,-6(A1,D6.L)*SUBQ.L  #6,D6*MOVE.L  D6,TRESPC*MOVE.L  D6,D2 END END TypeDec;  PROCEDURE ConsDec; BEGIN ASSEMBLER !CONSDL  JSR     GetSbl)BEQ     CONSDE10)BPL     CONSDE11 !CONSDE10 BSR     ConsDec1)CMPI.W  #11,D3        ;;)BEQ     ok)MOVE    #rSemXp,D5)JMP     SyntaxErr !ok      BRA     CONSDL !CONSDE11 RTS ; !ConsDec1 JSR     GETID0)JSR     GetSbl)CMPI.W  #18,D3        ;=)BEQ     ok1)MOVE    #rEqlXp,D5)JMP     SyntaxErr !ok1     JSR     GetSbl)BPL     noproc)CMPI.B  #6,D3         ;Eine Proc?)BEQ.W   isproc noproc:  JSR     ConstExprZZ)JSR     PULLID)JSR     SETID)MOVE.L  TRESPC,D6)MOVE.W  #$8000+50,D0)JSR     SETKNG)JSR     PULLINT)MOVE.L  D0,-10(A1,D6.L) ;^TYP)CMP.L   STRPTR,D0       ;STRING-KONSTANTE GEHT ANDERS)BEQ.S   ConsDec5)CMPI.W  #3,IPFLAG       ;wird DEF-Modul Åbersetzt?)BNE     ConsDec9)BTST    #0,-2(A1,D0.L)  ;Skalarer Wert? Dann als alte Konst. eintragen)BNE     oldconst ConsDec9 MOVE.L  -6(A1,D0.L),D0  ;LAENGE ConsDec8 MOVE.W  D0,-16(A1,D6.L) ; EINTRAGEN)CLR.L   -14(A1,D6.L)    ;^letzte Ref)CLR.L   -6(A1,D6.L)     ;f. Import-Liste (s. FINIMP, IPIMP))MOVE.L  AccuPtr,A0 ConsDec3 MOVE.L  (A0)+,-20(A1,D6.L) ;KONSTANTE IN BAUM KOPIEREN)SUBQ.L  #4,D6)SUBQ.L  #4,D0)BGT     ConsDec3)SUBQ.L  #8,D6)SUBQ.L  #8,D6 ConsDec4 MOVE.L  D6,TRESPC)JMP     SameSbl ; ConsDec5 ; Bei String-Literals steht LÑnge nicht in Typ-Kennung,); sondern in STRLEN (STRBUF = AccuPtr):)MOVEQ   #0,D0)MOVE.W  STRLEN,D0)BRA     ConsDec8  oldconst MOVE.L  D0,-(A7))MOVE.L  TRESPC,D6)MOVE.W  #$8012,D0)JSR     SETKNG)MOVE.L  (A7)+,D0)MOVE.L  D0,-6(A1,D6.L) ;^TYP)MOVE.L  -6(A1,D0.L),D0 ;LAENGE)MOVE.W  D0,-8(A1,D6.L) ; BEI CONST EINTRAGEN)MOVE.L  AccuPtr,A0 DonsDec3 MOVE.L  (A0)+,-12(A1,D6.L) ;KONSTANTE IN BAUM KOPIEREN)SUBQ.L  #4,D6)SUBQ.L  #4,D0)BGT     DonsDec3)SUBQ.L  #8,D6)MOVE.L  D6,TRESPC)JMP     SameSbl ); Alias f. Proc per Relay eintragen isproc:  MOVE.L  D2,-(A7))JSR     PULLID)JSR     SETID)MOVE.L  TRESPC,D6)MOVE.W  #$8000,D0       ;Relay)JSR     SETKNG)MOVE.L  (A7)+,-6(A1,D6.L) ;^Orig-Eintrag)SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)JMP     GetSbl  (* alte Routine f. String-Literals ConsDec5 MOVE.W  #$801F,D0)JSR     SETKNG)MOVE.W  STRLEN,D0)LEA     STRBUF,A0)MOVE.B  D0,-3(A1,D6.L) !ConsDec7 SUBQ.W  #1,D0)BMI     ConsDec6)SUBQ.L  #1,D6)MOVE.B  (A0)+,-3(A1,D6.L))BRA     ConsDec7 !ConsDec6 SUBQ.L  #3,D6)BCLR    #0,D6         ;ABRUNDEN)BRA     ConsDec4 *) END END ConsDec;  PROCEDURE allocReg;"(*#* Belegt ggf. Register fÅr die akt. Var.#* IN: D5: ^Var-Type#* OUT: D0.B: Info f. Reg-Var-Feld#*)"BEGIN$ASSEMBLER); Reg-Var vergeben)MOVE.B  -1(A1,D5.L),D0 ;TYP-Kennung)CMPI.B  #2,D0          ;LONGREAL)BEQ     regFP)CMPI.B  #40,D0         ;REAL)BEQ     regFP)CMPI.B  #5,D0          ;SET)BEQ     regSet1)CMPI.B  #45,D0         ;SET)BEQ     regDn)CMPI.B  #19,D0        ;PROCEDURE?)BEQ     regAn)CMPI.B  #8,D0         ;Opaque?)BEQ     regAn)CMPI.B  #25,D0        ;Opaque?)BEQ     regAn)CMPI.B  #20,D0        ;Pointer?)BEQ     regAn)CMPI.B  #23,D0        ;ADDRESS?)BEQ     regAn)BTST    #0,-2(A1,D5.L) ;Scalar?)BEQ     notSc          ;wenn nicht, dann Fehler regDn    MOVEQ   #0,D0         ;Data-Reg holen)BRA     getReg regFP    MOVEQ   #2,D0         ;Float-Reg holen)BRA     getReg error    MOVE.W  #rNoReg,D5)JMP     SyntaxErr regSet1  CMPI.L  #1,TypeLen    ;Set > 1 Byte? -> geht nicht)BEQ     regDn)BRA     error regAn    MOVEQ   #1,D0         ;Ptr-Reg holen getReg   JMP     getRegVar notSc    CMPI.L  #4,TypeLen    ;Typ > 4 Byte? -> kann nicht gehen)BHI     error$END"END allocReg;  PROCEDURE VarDec; BEGIN ASSEMBLER)CLR     UseRegister VarDec5  JSR     GetSbl)BEQ     VarDec10      ;UNBEKANNT: VAR-ID)BPL     VarDec11      ;RES. WORT: ENDE DER DEKL. VarDec10 BSR.L   VarDec0)CMPI.W  #11,D3        ;Sem.?)BEQ     ok)MOVE    #rSemXp,D5)JMP     SyntaxErr ok       BRA     VarDec5 VarDec11 RTS  VarDec0  CLR.W   VARCNT)TST.W   D3 ); Schleife: mit Kommata aufgezÑhlte Vars einlesen VarDec6  JSR     GETID0)ADDQ.W  #1,VARCNT     ;Anzahl der Vars bis zum ':')JSR     GetSbl)CMPI.W  #15,D3        ;[ fuer absolute Adress-Angabe ?)BEQ.W   VarDecAb      ;ja -> )MOVEQ   #-1,D0        ;Adresse -1/-2 markieren nicht-abs. Deklaration)MOVE.W  UseRegister,D1)EOR     D1,D0         ;Bit 0 lîschen bei Reg-Var)JSR     PUSHINT  VarDec2  CLR.W   UseRegister)CMPI.W  #10,D3        ;,)BNE     VarDec7)JSR     GetSbl)BRA     VarDec6 ); nun die Offsets der aufgezÑhlten Vars bestimmen VarDec7  CMPI.W  #25,D3        ;:)BEQ     ok2)MOVE    #rColXp,D5    ;: EXPECTED)JMP     SyntaxErr !ok2     MOVE.W  VARCNT,-(A7))CLR.W   newtyp        ;keine Relays fuer bekannte Typen)JSR     SetType)MOVE.W  (A7)+,VARCNT)MOVE.L  D2,D5         ;^TYPEINTRAGUNG  !VarDec3 JSR     PULLID)JSR     SETID)MOVE.W  #$8011,D1     ;KENNUNG: VAR)JSR     PULLINT)CMPI.L  #$FFFFFFFE,D0)BCS     VarDec8       ;gueltige externe Adresse))CLR.W   -(A7))LSR     #1,D0         ;Reg-Var?)BCS     memVar        ;nein)TST.W   ModFlag       ;In Proc?)BNE     memVar        ;nein, in Module -> keine Reg-Var)JSR     allocReg)ORI.W   #$20,D0       ;Flag: Var hat noch keinen Wert ('dirty'))MOVE.W  D0,(A7) memVar   ; Jeder Var eine Adr. auf dem lokalen Stack zuteilen); Damit der Compiler besser optimieren kann, wird nun IMMER, also auch); bei Byte-Vars, die Var auf eine gerade Adr. gelegt.)MOVE.L  VARSPC,D0)MOVE.L  TypeLen,D3))TST     negVarSpc)BEQ     notNeg)); Var f. neg. Offsets (absteigend) allozieren)SUB.L   D3,D0)BTST    #0,D0)BEQ     noSync2       ;gerade Adresse, keine Probleme)SUBQ.L  #1,D0         ;sonst Adr geradebiegen noSync2  MOVE.L  D0,VARSPC)BRA     VarDec4  notNeg   ; Var f. pos. Offsets (aufsteigend) allozieren)BTST    #0,D0)BEQ     noSync        ;gerade Adresse, keine Probleme)(*+CMPI.L  #1,D3+BEQ     noSync        ;Typlaenge ist Eins -> darf auf odd Adr)*))ADDQ.L  #1,D0         ;sonst Adr geradebiegen noSync   ADD.L   D0,D3)MOVE.L  D3,VARSPC)BRA     VarDec4  !VarDec8 BSET    #12,D1        ;EXTERNAL)CLR     -(A7)         ;keine Reg-Var ); Var eintragen und Ende !VarDec4 MOVE.L  D0,-6(A1,D6.L) ;ADRESSE)MOVE.W  D1,D0)JSR     SETKNG)MOVE.L  D5,-10(A1,D6.L)     ;^ TYP)CLR.L   -14(A1,D6.L)        ;^ LETZTE REFERENZ)MOVE    (A7)+,D0)ANDI    #$00FF,D0)MOVE.W  D0,-16(A1,D6.L)     ;Kennungen fÅr Register-Vars)SUBI.L  #16,D6)MOVE.L  D6,TRESPC)SUBQ.W  #1,VARCNT)BNE     VarDec3)JMP     SAMESBL ); Var auf absoluter Adr. deklarieren VarDecAb JSR     GetSbl)JSR     ConstExpr)JSR     PullInt)MOVE.L  D0,D2)MOVE.B  -1(A1,D2.L),D0 ;Typ-Deskriptor fuer Adresse)CMP.B   #34,D0        ;SHORTCARD ODER)BEQ     VarDec9)CMP.B   #35,D0)BEQ     VarDec9)CMP.B   #22,D0        ;CARDINAL?)BEQ     VarDec9)CMP.B   #30,D0)BEQ     VarDec9)MOVE    #rCarXp,D5    ;CARD EXPECTED)JMP     SyntaxErr VarDec9  MOVE.L  Accu,D0         ;Adresse merken)CMPI.L  #$FFFFFFFE,D0)BCS     VarDec92)MOVE    #rAbsAd,D5)JMP     SyntaxErr VarDec92 JSR     PUSHINT)CMPI.W  #27,D3        ;])BEQ     ok1)MOVE    #rBrkXp,D5)JMP     SyntaxErr ok1      JSR     GetSbl)BRA     VarDec2 END END VarDec;  (* Deklaration von String-Types *)  PROCEDURE SetTyp13; BEGIN ASSEMBLER)JSR     GetSbl)MOVE.L  #DEFASTR,D1   ;DEFAULT LAENGE)CMPI.W  #15,D3        ;[)BNE     sTyp10)JSR     GetSbl)JSR     ConstExpr)JSR     PullInt)CMP.L   SBothTyp,D0)BEQ     ok10 !ER67    MOVE    #rStrLn,D5)JMP     SyntaxErr !ok10    CMPI.W  #27,D3        ;])BEQ     ok11)MOVE    #rBrkXp,D5)JMP     SyntaxErr !ok11    JSR     GetSbl)MOVE.L  Accu,D1         ;LAENGE)CMPI.L  #MaxStrLen,D1)BHI     ER67 !sTyp10  MOVE.L  TRESPC,D6)MOVE.W  #$841B,D0     ;KENNUNG: STRING)JSR     SETKNG)BSET    #0,D1         ;CHAR-ZAHL UNGERADE MACHEN)MOVE.L  D1,-10(A1,D6.L) ;ZEICHENZAHL)ADDQ.L  #1,D1         ;1 WORD LAENGENZAHL)MOVE.L  D1,-6(A1,D6.L))MOVE.L  D1,TypeLen)MOVE.L  D6,D2)SUBI.L  #10,D6)MOVE.L  D6,TRESPC)CLR.L   D1)RTS'END END SetTyp13;  PROCEDURE adaptSStoCHAR;"(*#* ConstExpr liefert bei Char-Literalen nun immer den SS-Typ (StrPtr).#* Diese Funktion erwartet in D0 den Typ und wandelt ihn ggf. nach CHAR#*)"BEGIN$ASSEMBLER(CMP.L   StrPtr,D0(BNE     noChar(MOVEM.L D1/A0/A1,-(A7)(MOVE.L  AccuPtr,A0(LEA     Accu,A1(MOVEQ   #0,D1(TST     StrLen(BEQ     ok              ; Leerstring? dann nach CHAR wandeln(MOVE.B  (A0),D1         ; Character holen(CMPI    #1,StrLen       ; ist SS ein Zeichen lang? Dann CHAR(BNE     noCh2%ok MOVE.L  D1,(A1)(MOVE.L  A1,AccuPtr(MOVE.L  CharPtr,D0%noCh2(MOVEM.L (A7)+,D1/A0/A1%noChar$END"END adaptSStoCHAR;  VAR anonymTyp: BOOLEAN;  FORWARD procFlags; FORWARD procParFlags;  PROCEDURE SetType; BEGIN ASSEMBLER)CLR.W   anonymTyp)JSR     GetSbl settype0 TST     D3); Einsprung f. SetType mit bereits geholtem Symbol (v. ARRAY-Behdl))BNE     settype1)MOVE    #rIdUn,D5         ;undeclared)JMP     SyntaxErr settype1 BPL.L   sTyp1        ;Std-Symbol, wie RECORD, POINTER usw.)BTST    #10,D3)BNE     known)CMPI.B  #48,D3         ;Frwd-Typ?)BEQ     fwrdTyp2)MOVE    #rTyDXp,D5     ; Dies ist kein Typ)JMP     SyntaxErr fwrdTyp2 MOVE    #rFwTyp,D5     ; Fwrd-Typ noch nicht dekl.)JMP     SyntaxErr ; ;   BEKANNTER TYP ; !KNOWN   MOVE.L  -6(A1,D2.L),TypeLen)CMPI.B  #11,D3        ;SUBRANGE?)BEQ     sTyp30)CMPI.B  #9,D3)BEQ     sTyp31      ;ENUM)CMPI.B  #3,D3)BEQ     sTyp32      ;CHAR)CMPI.B  #34,D3)BEQ     sTyp32c     ;CARDINAL)CMPI.B  #24,D3)BEQ     sTyp33      ;BOOL)CMPI.B  #41,D3)BEQ     sTyp32b     ;BITNUM)CLR.L   D1)BRA     sTyp34 !sTyp30  MOVE.L  -14(A1,D2.L),D1 ;OBERGRENZE)SUB.L   -10(A1,D2.L),D1 ;-UNTERGRENZE)ADDQ.L  #1,D1         ;+1 = ANZ. ELEMENTE)BRA     sTyp34 !sTyp31  MOVE.L  -10(A1,D2.L),D1 ;ANZ. ELEMENTE)BRA     sTyp34 !sTyp32  MOVE.L  #256,D1)BRA     sTyp34 !sTyp32b MOVEQ   #32,D1)BRA     sTyp34 !sTyp32c MOVE.L  #65536,D1)BRA     sTyp34 !sTyp33  MOVEQ   #2,D1 !sTyp34  MOVEM.L D1/D2,-(A7))JSR     GetSbl)CMP.W   #15,D3        ;[ ? (Subrange nach neuem Standard))BEQ     isSubr)MOVEM.L (A7)+,D1/D2)TST.W   newtyp        ;muss Relay angelegt werden ?)BEQ     norelay)MOVE.L  TRESPC,D6)CLR.W   -2(A1,D6.L)   ;Relay: Typ wurde redeklariert (a = b))MOVE.L  D2,-6(A1,D6.L))CLR.W   -8(A1,D6.L)   ;falls lokal: Åbersprungene Scope-Differenz)SUBQ.L  #8,D6)MOVE.L  D6,TRESPC  (* !TT 23.09.90  entfernt, daû dies nun in PlaTre/CopInf berÅcksichtigt wird); bei Relay auf Enums ggf. Importflags loeschen!);    (falls wir in einem DefMod sind, muessen die Elemente nachher);    exportiert werden!))CMPI.B  #9,-1(A1,D2.L)  ;EnumType ?)BNE     norelay)MOVE.L  -14(A1,D2.L),D0 ;^ erstes Element enumrel  BCLR    #5,-2(A1,D0.L))MOVE.L  -12(A1,D0.L),D0 ;^ naechstes Element)BNE     enumrel *) !norelay RTS  !isSubr  ADDQ.L  #4,A7         ;die Element-Zahl vergessen wir mal)JSR     GetSbl)JSR     ConstExpr)JSR     PullInt)JSR     adaptSStoCHAR)MOVE.L  D0,D2)BTST    #0,-2(A1,D2.L))BNE     ok)MOVE    #rSclXp,D5         ;kein Skalar)JMP     SyntaxErr !ok      MOVE.L  (A7),D0       ;passt das zum angegeben Typ?)JSR     compatConstRR)BNE.L   er40          ;leider nicht)MOVE.L  (A7),D0)MOVE.L  -6(A1,D0.L),D0 ;LÑnge des Typs)BRA.L   sTyp82        ;dann mal rein ins Subrange-Vergnuegen ; ;   ARRAY ; !sTyp1   CLR.W   newtyp         ;ab jetzt bitte keine ueberfluessigen Relays)CMPI.W  #60,D3        ;ARRAY)BNE.L   sTyp2 !sTyp3   MOVE.L  TRESPC,D6)MOVE.L  D6,-(A7))MOVE    anonymTyp,-(A7))MOVE.W  #$8000,-2(A1,D6.L) ;EINTRAG IST NOCH UNGUELTIG)SUBI.L  #14,D6        ;PLATZ FUER EINTRAG RESERVIEREN)MOVE.L  D6,TRESPC)JSR     SetType       ;INDEX-TYPE HOLEN)TST.L   D1)BNE     ok5)MOVE    #rScIdx,D5         ;ILL INDEX)JMP     SyntaxErr !ok5     MOVE.L  D1,D0         ;ANZAHL ELEMENTE)JSR     PUSHINT)MOVE.L  D2,D0)JSR     PUSHINT       ;^INDEXTYPE RETTEN)JSR     SAMESBL)CMPI.W  #10,D3        ;',')BNE     sTyp4)MOVE.W  #1,anonymTyp)BSR.L   sTyp3         ;'OF ARRAY' SIMULIEREN)BRA     sTyp5 !sTyp4   CMPI.W  #46,D3        ;OF)BEQ     ok2)MOVE    #rOFXp,D5     ;OF EXPECTED)JMP     SyntaxErr !ok2     ; nun erkennen, ob wieder "ARRAY" kommt -> anonymen Typ kennzeichnen)JSR     GetSbl)CMPI.W  #60,D3        ;ARRAY)SEQ     D0)ANDI    #1,D0)MOVE.W  D0,anonymTyp)BSR     SetType0      ;BASETYPE HOLEN !sTyp5   MOVE.W  #$840C,D0)TST     (A7)+         ;anonymTyp testen)BEQ     sTyp52)BCLR    #8+2,D0       ;typeDesc-Flag bei anonymen Types lîschen sTyp52   MOVE.L  (A7)+,D6)JSR     SETKNG        ;ARRAY-KENNG)MOVE.L  D2,-14(A1,D6.L) ;^BASETYPE)JSR     PULLINT)MOVE.L  D0,-10(A1,D6.L) ;^INDEXTYPE)); pruefe, ob Index und Elemente nicht zu gross sind))MOVE.L  TypeLen,D1     ;Elemente muessen immer < 64K sein); CMPI.L  #$FFFF,D1); BLS     ok3); MOVE    #rAElOv,D5     ;Elements too large); JMP     SyntaxErr ok3      MOVEQ   #3,D0          ;teste, ob D1 Zweierpotenz bis 2^3 lp       LSR.W   #1,D1)DBCS    D0,lp          ;schiebe, bis 1-bit rauslaeuft)TST.W   D1             ;noch 1-bits uebrig?)BNE     noPwr2)MOVEQ   #3,D1)SUB.W   D0,D1          ;log2 (Elementlaenge))JSR     PullInt        ;Anzahl Indextype-Werte)ASL.L   D1,D0          ;Gesamtlaenge ausrechnen)BVS     tooLong        ;Laenge muss < 2^31 bleiben!)BRA     storeLen noPwr2   JSR     PULLINT        ;Anzahl Indextype-Werte)BRA     ok1); CMPI.L  #$10000,D0); BLS.W   ok1 tooLong  MOVE    #rArrLg,D5     ;array too large)JMP     SyntaxErr ok1      MOVE.L  TypeLen,D1 ); MULU.L  D1,D0          ;Array-Laenge)MOVE.L  D2,-(A7))MOVE.W  D0,D2)MULU    D1,D2   ; loD1 * loD0)SWAP    D0)TST.W   D0)BEQ.S   d0word  ; hiD0 = 0  ->  hiD1 * loD0 )MULU    D1,D0   ; loD1 * hiD0)SWAP    D0)TST.W   D0)BNE.S   tooLong)SWAP    D1)TST.W   D1)BNE     tooLong)ADD.L   D2,D0)BRA     mulEnd"d0word SWAP    D0)SWAP    D1)MULU    D1,D0   ; hiD1 * loD0)SWAP    D0)TST.W   D0)BNE     tooLong)ADD.L   D2,D0"mulEnd BCS     tooLong)TST.L   D0)BMI     tooLong)MOVE.L  (A7)+,D2  storeLen MOVE.L  D0,-6(A1,D6.L))MOVE.L  D0,TypeLen)MOVE.L  D6,D2)CLR.L   D1)RTS ; ;   SUBRANGE ; !sTyp2   CMPI.W  #15,D3        ;[)BNE.L   sTyp6)JSR     GetSbl)JSR     ConstExpr)JSR     PullInt)JSR     adaptSStoCHAR)MOVE.L  D0,D2)BTST    #0,-2(A1,D2.L))BNE     ok6)MOVE    #rSclXp,D5         ;KEIN SKALAR)JMP     SyntaxErr !ok6     MOVE.L  D2,-(A7))MOVEQ   #0,D0 !sTyp82  MOVE.L  D0,-(A7)     ;vorbestimmte LÑnge merken)MOVE.L  Accu,D0        ;Einsprung nach <typename> [ConstEx ..)JSR     PUSHINT)CMPI.W  #8,D3        ;.. ?)BEQ     ok7)MOVE    #rPdsXp,D5)JMP     SyntaxErr !er40    MOVE    #rBdTyp,D5)JMP     SyntaxErr !ok7     JSR     GetSbl)JSR     ConstExpr)CMPI.W  #27,D3)BEQ     ok9)MOVE    #rBrkXp,D5         ;] EXPECTED)JMP     SyntaxErr !ok9     MOVE.L  TRESPC,D6)MOVE.W  #$850B,D0)JSR     SETKNG        ;KENNUNG: SUBRANGE))JSR     PullInt)JSR     adaptSStoCHAR)MOVE.L  D0,D3              ;Type v. Obergrenze)JSR     PULLINT)MOVE.L  D0,-10(A1,D6.L)    ;UNTERGRENZE)MOVE.L  Accu,-14(A1,D6.L)    ;OBERGRENZE)MOVE.L  (A7)+,-6(A1,D6.L)  ;LAENGE (null, wenn kein Bastype bestimmt))MOVE.L  (A7)+,-18(A1,D6.L) ;Type v. Untergrenze / BaseType)MOVE.L  D6,D2)SUBI.L  #18,D6)MOVE.L  D6,TRESPC)MOVE.L  D3,D0)JSR     adjustSubrange))MOVE.L  -6(A1,D2.L),D1 ;LAENGE)MOVE.L  D1,TypeLen)MOVE.L  -14(A1,D2.L),D1 ;OBERGRENZE)SUB.L   -10(A1,D2.L),D1 ;UNTERGRENZE)ADDQ.L  #1,D1           ;Elems in Range)BNE     no2x32)SUBQ.L  #1,D1           ;bei 2^32 elems merken wir uns 2^31-1 no2x32   MOVE.L  D1,-(A7))MOVE.L  D2,-(A7))JSR     GetSbl)MOVE.L  (A7)+,D2)MOVE.L  (A7)+,D1)RTS ; ;  String ; (* !sTyp6   CMPI.W  #47,D3        ;STRING)BNE     sTyp7)JMP     SetTyp13      ;ausgelagert; wird auch fuer ProcHead gebraucht *) ; ; Enumeration ; !sTyp6   CMPI.W  #14,D3        ;(: ENUMERATION)BNE.L   sTyp17)CLR.L   D5 !sTyp18  JSR     GETID)ADDQ.W  #1,D5)JSR     GetSbl)CMPI.W  #10,D3        ;,)BEQ     sTyp18)CMPI.W  #26,D3)BEQ     ok12)MOVE    #rParXp,D5         ;) EXPECTED)JMP     SyntaxErr !ok12    MOVE.L  TRESPC,D6)MOVE.L  D6,ENUMTYPE)MOVE.W  #$8509,D0     ;ENUM)JSR     SETKNG)MOVEQ   #2,D0         ;LAENGE: 2 BYTE)MOVE.L  D0,TypeLen)MOVE.L  D0,-6(A1,D6.L) ;2 BYTE)MOVE.L  D5,-10(A1,D6.L) ;ANZAHL ELEMENTE)CLR.L   -14(A1,D6.L)  ;^ERSTES ELEMENT)SUBI.L  #14,D6)MOVE.L  D6,TRESPC)MOVE.L  D5,-(A7))SUBQ.W  #1,D5 !sTyp19  MOVE.L  D6,-(A7))JSR     PULLID)JSR     SETID)MOVE.L  TRESPC,D6)MOVE.L  (A7)+,D0)MOVE.L  D6,0(A1,D0.L)  ;^DIESES ELEMENT NACHTRAGEN)MOVE.W  #$800A,D0)JSR     SETKNG)MOVE.W  D5,-4(A1,D6.L))MOVE.L  ENUMTYPE,-8(A1,D6.L) ;^TYP)CLR.L   -12(A1,D6.L)  ;^NAECHSTES EL.)SUBI.L  #12,D6)MOVE.L  D6,TRESPC)SUBQ.W  #1,D5)BPL     sTyp19)JSR     GetSbl)MOVE.L  (A7)+,D1)MOVE.L  ENUMTYPE,D2)RTS ; ; Record ; !sTyp17  CMPI.W  #63,D3)BNE.L   sTyp22)MOVE.L  TRESPC,D6)MOVE.L  D6,-(A7)      ;^TYP)MOVE.W  #$840D,D0)JSR     SETKNG)SUBQ.L  #7,D6)SUBQ.L  #7,D6)MOVE.L  D6,TRESPC)CLR.L   TypeLen       ;LAENGE)CLR.L   RecOffset     ;Ofs der Felder zum Beginn)CLR.W   MustSync      ;wenn Wort-Feld im Record, wird MustSync = 1)CLR.L   myScope       ;neues Scope)MOVE.L  (A7),D0)LEA     -10(A1,D0.L),A0 ;^first Element-Ptr)BSR.L   FldLstS)CMPI.W  #35,D3        ;END)BEQ     ok13)MOVE    #rEndXp,D5)JMP     SyntaxErr !ok13    JSR     GetSbl)MOVE.L  (A7)+,D6)MOVE.L  TypeLen,D0)TST.W   MustSync)BEQ     noLnSync       ;Record enthaelt nur Byte-Felder)ADDQ.L  #1,D0)BCLR    #0,D0)MOVE.L  D0,TypeLen     ;!!! énderung vom 16.9.89 noLnSync MOVE.L  D0,-6(A1,D6.L) ;LAENGE DES RECORDS)MOVE.L  myScope,-14(A1,D6.L) ;^LOCAL SCOPE)MOVE.L  D6,D2)CLR.L   D1)RTS ; ; Feld-List-Sequenz (zw. RECORD und END) auswerten ; ErhÑlt in A0 eine abs. Ptr auf Verkettungsliste ; !FldLstS MOVE.L  lastElem,-(A7))MOVE.L  A0,lastElem FldLstS2 CLR.W   VARCNT        ;uebersetzt FieldListSequence)BSR     FldLst)CMPI.W  #11,D3        ; ';' ?)BEQ     FldLstS2)MOVE.L  lastElem,A0)CLR.L   (A0)           ;Ende der Feldlistseq.)MOVE.L  (A7)+,lastElem FldLstRt RTS ; ; Feld-Liste (Felder, durch Kommata aufgezÑhlt, mit Typ am Ende) auswerten ; !FldLst  JSR     GetSbl        ;uebersetzt FieldList)BEQ     FldLst2       ;ID)BMI     FldLst2)CMPI.W  #45,D3)BEQ.L   VarRec        ;CASE: Variant RECORD)CMPI.W  #15,D3        ; [)BNE     FldLstRt      ;LEERE FIELDLIST)); [x] f. Feldoffset auswerten)TST.L   TypeLen)BNE     FldLstRt       ;nur am Anfang vom Record erlaubt)TST.L   RecOffset)BNE     FldLstRt       ;nur einmal erlaubt)JSR     GetSbl)JSR     ConstExpr      ;Konst holen)JSR     PullInt)JSR     constTyp)CMP.L   ZZTyp,D0)BNE     ER40)MOVE.L  Accu,RecOffset ;Achtung: öberlauf wird nicht erkannt!)CMPI    #27,D3        ; ])BEQ     FldLst)MOVE    #rBrkXp,D5)JMP     SyntaxErr  !FldLst1 JSR     GetSbl !FldLst2 JSR     OldID0        ;erlaube zunÑchst auch bekannte IDs;?;fÑllt ggf. beim Eintragen auf?; (wenn auch mit unschîner Fehlerposition))ADDQ.W  #1,VARCNT)JSR     GetSbl)CMPI.W  #10,D3)BEQ     FldLst1)CMPI.W  #25,D3        ;:)BEQ     ok14)MOVE    #rColXp,D5         ;EXPECTED)JMP     SyntaxErr !ok14    MOVE.W  VARCNT,-(A7))MOVE.L  TypeLen,-(A7))MOVE.W  MustSync,-(A7))MOVE.L  RecOffset,-(A7))MOVE.L  myScope,-(A7)    ;IDs aus Typdekl. (Enumeration) gehîren@; nicht ins lokale Record-Scope!)JSR     SetType)MOVE.L  (A7)+,myScope)MOVE.L  (A7)+,RecOffset)MOVE.W  (A7)+,MustSync)MOVE.L  (A7)+,D4      ;bisherige Laenge des Records)MOVE.L  TypeLen,D0    ;pruefe, ob Sync: Laenge der neuen Felder)BTST    #0,D0)BNE     noSync        ;ungerade FeldLaenge: kein Problem)ORI.W   #1,MustSync   ;dieses Record muss spaeter gerade Laenge haben!dc)BTST    #0,D4)BEQ     noSync        ;gerade FeldAdresse: auch ok)ADDQ.L  #1,D4         ;FeldAdr synchronisieren !noSync  MOVE.W  (A7)+,VARCNT)MOVE.L  D2,D5         ;Feld-Typ)MOVE.L  options,D0)BTST    #20,D0        ;T+ ?)BNE     FldLst3r      ;invertiere die Reihenfolge !FldLst3 BSR.W   FIELD         ;dieses Feld in Baum eintragen)ADD.L   TypeLen,D4    ;Platz fuer dieses Feld aufaddieren)SUBQ.W  #1,VARCNT)BNE     FldLst3       ;noch'n Feld gleichen Typs in der FieldList)MOVE.L  D4,TypeLen)JMP     SameSbl  FldLst3r MOVE.L  TypeLen,D0)); MULU    VarCnt,D0)MOVE.W  D0,D2)MULU    VarCnt,D2   ; loD1 * loD0)SWAP    D0)MULS    VarCnt,D0   ; loD1 * hiD0)SWAP    D0)ADD.L   D2,D0))ADD.L   D0,D4)MOVE.L  D4,-(A7)       ; TypeLen merken)CLR.L   -(A7)          ; hier wird lastElem d. ersten Felds gemerkt)MOVE.L  lastElem,-(A7) ; merken fÅr Verkettung am Ende)CLR.L   -(A7)          ; Ref auf letzten Eintrag  F3Loop   SUB.L   TypeLen,D4)SUBQ.L  #4,A7)MOVE.L  A7,lastElem)BSR     Field)MOVE.L  (A7)+,D0       ; D6)MOVE.L  lastElem,A0)MOVE.L  (A7),D1)BNE     F3Cont); bei erstem Feld merken wir und 'lastElem')MOVE.L  lastElem,8(A7) F3Cont   MOVE.L  D1,(A0)        ; voriger Ptr)MOVE.L  D0,(A7))SUBQ.W  #1,VarCnt)BNE     F3Loop))MOVE.L  (A7)+,D0       ; D6)MOVE.L  (A7)+,A0       ; geretteter, erster lastElem)MOVE.L  D0,(A0)        ; voriger Ptr)MOVE.L  (A7)+,lastElem)MOVE.L  (A7)+,TypeLen)JMP     SameSbl ; !FIELD   MOVE.L  myScope,-(A6) ;in dieses Scope eintragen)JSR     PULLID)JSR     SETID)MOVE.W  #$800E,D0)JSR     SETKNG)CLR.L   -14(A1,D6.L)   ;^next erstmal lîschen)MOVE.L  lastElem,D0)BEQ     noLink)MOVE.L  D0,A0)MOVE.L  D6,(A0))LEA     -14(A1,D6.L),A0 ;^next Element-Ptr)MOVE.L  A0,lastElem'noLink)MOVE.L  D4,D0)ADD.L   RecOffset,D0)MOVE.L  D0,-6(A1,D6.L) ;FELDADR)MOVE.L  D5,-10(A1,D6.L) ;^TYP)MOVE.L  D6,D0          ;zurÅckgeben f. Variant-Auswertung)SUBQ.L  #7,D6)SUBQ.L  #7,D6)MOVE.L  D6,TRESPC); CMPI.L  #$7FFF,D4); BHI     ER9          ;TOO LARGE)MOVE.L  (A6)+,myScope)RTS !ER9     ; MOVE    #rRecOv,D5); JMP     SyntaxErr ; ; CASE in RECORD auswerten ; !VarRec  ; zuerst eine CASE-Kennung (47) im Baum einfÅgen)MOVE.L  TRESPC,D6)MOVE.W  #$8000+47,D0)JSR     SETKNG)MOVE.L  lastElem,A0)MOVE.L  D6,(A0))LEA     -14(A1,D6.L),A0 ;^next Element-Ptr)MOVE.L  A0,lastElem)CLR.L   -6(A1,D6.L)     ;dummy lîschen)CLR.L   -18(A1,D6.L)    ;erstmal ^Rec-Feld lîschen)MOVE.L  D6,-(A7))SUBI.L  #22,D6)MOVE.L  D6,TRESPC))CLR.W   -(A7))JSR     GetSbl)CMPI.W  #25,D3        ;:)BEQ     VarRec1)); Feld-Variable holen)TST.W   D3)JSR     GETID0        ;MUSS TAGFIELD SEIN)NOT.W   (A7))JSR     GetSbl)CMPI.W  #25,D3        ;:)BEQ     VarRec1)MOVE    #rColXp,D5         ; EXPECTED)JMP     SyntaxErr ); Typ holen !VarRec1 JSR     GetSbl)BTST    #8,D3         ;SKALAR?)BNE     ok15)MOVE    #rIdXp,D5)JMP     SyntaxErr !ok15    CMPI.B  #1,D3         ;LONGINT?)BNE     ok16)MOVE    #rRestr,D5    ; WILL ICH NICHT!)JMP     SyntaxErr !ok16    MOVE.L  D2,D5         ;^TYP SICHERN)TST.W   (A7)+         ;TAGFIELD?)BEQ     VarRec2))MOVE.L  TypeLen,D4)MOVE.L  -6(A1,D2.L),D0 ;TAGFIELD LAENGE); Synchr. der Tagfeld-Adresse)BTST    #0,D0)BNE     TagOdd        ;TagLÑnge ungerade: Adr darf ungerade sein)ADDQ.L  #1,D4         ;gerade: Adr synchr.)BCLR    #0,D4)MOVE.L  D4,TypeLen TagOdd   ADD.L   D0,TypeLen)MOVE.L  lastElem,-(A7))CLR.L   lastElem      ;beim Tag-Feld keine Verkettung, da dies schon?; im CASE-Eintrag gemacht wird.)BSR     FIELD         ;TAGFIELD EINTRAGEN, D0 liefert ^ auf Eintrag)MOVE.L  (A7)+,lastElem)MOVE.L  (A7),D2)MOVE.L  D0,-18(A1,D2.L) ;^Rec-Feld in CASE-Eintrag nachtragen  !VarRec2 ;Typ-^ in CASE-Eintrag nachtragen)MOVE.L  (A7)+,D0)MOVE.L  D5,-10(A1,D0.L) ); Neue Liste fÅr Tag-List-Verkettung aufbauen)MOVE.L  lastElem,-(A7))LEA     -22(A1,D0.L),A0)MOVE.L  A0,lastElem))JSR     GetSbl)CMPI.W  #46,D3        ;OF)BEQ     ok17)MOVE    #rOFXp,D5)JMP     SyntaxErr !ok17    CLR.L   -(A7)         ;HIER MAX.LAENGE MERKEN)MOVE.L  TypeLen,-(A7) ; ; Schleife: Varianten auswerten ; !VarRec3 JSR     GetSbl)CMPI.W  #29,D3        ;jetzt auch leere Variants erlaubt)BEQ     VarRec3       ;|)CMPI.W  #30,D3)BEQ     VarRec3       ;ODER !)CMPI.W  #33,D3        ;ELSE)BEQ     VarRec6)CMPI.W  #35,D3        ;END)BEQ.W   VarRec4)); Variante auswerten)BSR.L   Variant)MOVE.L  TypeLen,D0)CMP.L   4(A7),D0)BLS     VarRec5)MOVE.L  D0,4(A7)      ;GROESSTE LAENGE MERKEN !VarRec5 MOVE.L  (A7),TypeLen ); weitere Varianten?)CMPI.W  #29,D3)BEQ     VarRec3       ;|)CMPI.W  #30,D3)BEQ     VarRec3       ;ODER !)CMPI.W  #33,D3        ;ELSE)BEQ     VarRec6)CMPI.W  #35,D3        ;END)BEQ     VarRec4)MOVE    #rCaStr,D5)JMP     SyntaxErr ; ; ELSE auswerten ; !VarRec6 ; zuerst eine Tag-Feld-Eintrag (Kennung 46) im Baum anlegen)MOVE.L  TRESPC,D6)MOVE.W  #$8000+46,D0)JSR     SETKNG)MOVE.L  lastElem,A0)MOVE.L  D6,(A0))LEA     -18(A1,D6.L),A0 ;^next Element-Ptr)MOVE.L  A0,lastElem)MOVE.L  D6,D2)SUBI.L  #18,D6)MOVE.L  D6,TRESPC); nun Lo- und Hi-Bounds auf Maximalwerte setzen, damit ELSE); zuletzt immer zutrifft.)MOVE.L  #$80000000,-10(A1,D2.L))MOVE.L  #$7FFFFFFF,-14(A1,D2.L))LEA     -6(A1,D2.L),A0)BSR     FldLstS)CMPI.W  #35,D3        ;END?)BNE     er2)MOVE.L  TypeLen,D0)CMP.L   4(A7),D0)BLS     VarRec4)MOVE.L  D0,4(A7) ; ; Ende des CASE ; !VarRec4 ADDQ.L  #4,A7          ;ALTE LAENGE WEG)MOVE.L  (A7)+,TypeLen  ;MAXLEN UEBERNEHMEN); Ende der Tag-Liste kennzeichnen)MOVE.L  lastElem,A0)CLR.L   (A0))MOVE.L  (A7)+,lastElem); Und zurÅck...)JMP     GetSbl  !er2     MOVE    #rEndXp,D5)JMP     SyntaxErr ; er30     MOVE    #rLowHi,D5)JMP     SyntaxErr  ; ; Eine Variante auswerten ; !Variant CLR.L   -(A7)          ; Endekennung fÅr Tag-Felder dieser FldLstS)BRA     Varian3  !Varian2 JSR     GetSbl !Varian3 ; zuerst eine Tag-Feld-Eintrag (Kennung 46) im Baum anlegen); Sie wird fÅr jede einzelne Constant bzw. Constant-Range vor einer); FieldListSeq angelegt, sodaû ggf. mehrere Tag-Feld-EintrÑge auf); dieselbe Rec-Feld-Liste zeigen.)MOVE.L  TRESPC,D6)MOVE.W  #$8000+46,D0)JSR     SETKNG)MOVE.L  lastElem,A0)MOVE.L  D6,(A0))LEA     -18(A1,D6.L),A0 ;^next Element-Ptr)MOVE.L  A0,lastElem)MOVE.L  D6,-(A7))SUBI.L  #18,D6)MOVE.L  D6,TRESPC); nun die Konstanten holen und eintragen)BSR     VarLbl)MOVE.L  (A7),D2       ;^Tag-Feld-Eintrag)MOVE.L  Accu,D0)MOVE.L  D0,-10(A1,D2.L) ;Lo-Wert merken)MOVE.L  D0,-14(A1,D2.L) ;Hi-Wert erstmal wie Lo-Wert)CMPI.W  #8,D3         ;..)BNE     Varian1)MOVE.L  D0,-(A7))JSR     GetSbl)BSR     VarLbl)MOVE.L  Accu,D0)CMP.L   (A7)+,D0)BCS.L   ER30          ;LOW EXCEEDS HIGH)MOVE.L  (A7),D2       ;^Tag-Feld-Eintrag)MOVE.L  D0,-14(A1,D2.L) ;Hi-Wert merken !Varian1 CMPI.W  #10,D3        ;,)BEQ     Varian2))CMPI.W  #25,D3)BEQ     ok18)MOVE    #rReDXp,D5    ;: EXPECTED)JMP     SyntaxErr !ok18    ; Ende der Tag-Liste); Jetzt die Felder auswerten. Da hinterher alle vorigen Tag-Fields); mit dem Ptr auf die Rec-Feld-Liste besetzt werden mÅssen, wird); der erste Ptr auf dem Stack eingetragen, sodaû er hinterher); nachgetragen werden kann)CLR.L   -(A7))MOVE.L  A7,A0)MOVE.L  D5,-(A7))BSR     FldLstS       ;FieldListSequence)MOVE.L  (A7)+,D5); Nun kînnen die Rec-Feld-Verweise nachgetragen werden)MOVE.L  (A7)+,D0       ;Dies ist der Ptr auf die Rec-Feld-Liste'nextTagFld)MOVE.L  (A7)+,D2       ;^Tag-Feld-Eintrag)BEQ     endOfVariants)MOVE.L  D0,-6(A1,D2.L) ;first Rec-Field-Ptr)BRA     nextTagFld'endOfVariants)RTS ; ; Label f. Variante holen ; !VarLbl  JSR     ConstExpr)JSR     PullInt)JSR     adaptSStoCHAR)MOVE.L  D5,D2)JSR     compatRR)BNE     ER40)RTS ; ;   SET ; !sTyp22   CMPI.W  #61,D3*BNE.L   sTyp24*JSR     GetSbl*CMPI.W  #46,D3        ; OF?*BEQ     ok19*MOVE    #rOFXp,D5         ;OF EXPECTED*JMP     SyntaxErr !ok19     MOVE.L  TRESPC,D6*MOVE.W  #$8405,D0     ; Kennung 5 setzen*JSR     SETKNG*MOVE.L  D6,-(A7)*SUBQ.L  #5,D6*SUBQ.L  #5,D6*MOVE.L  D6,TRESPC*JSR     SetType*TST.L   D1*BNE     ok20 !ER78     MOVE    #rScBas,D5      ;SUBR/ENUM EXP*JMP     SyntaxErr !ok20     BTST    #0,-2(A1,D2.L)  ;Basistyp scalar?*BEQ     ER78*CMPI.L  #MAXSET,D1*BLS     ok21 !ER79     MOVE    #rSetOv,D5*JMP     SyntaxErr !ok21     CMPI.B  #11,-1(A1,D2.L) ;SUBRANGE?*BNE     sTyp42*MOVE.L  -14(A1,D2.L),D1 ;OBERGRENZE DES SUBR*MOVE.L  -10(A1,D2.L),D0 ;Untergrenze des Subrange*BMI     nobin2          ;neg.? dann kein 4-Byte-Typ*CMPI.L  #31,D1*BLS     nullbased       ;bei max. 32 Elems immer null-based ablegen nobin2    SUB.L   D0,D1           ;Untergrenze des Subr*CMPI.L  #MAXSET-1,D1*BHI     ER79            ; >= 8KB IST VERBOTEN nullbased ADDQ.L  #1,D1           ;ANZAHL BITS IM SET*; Set ist dann null-based abgelegt, wenn die Untergrenze positiv*; und die obergrenze max. 31 ist. Ansonsten muû der low-bound*; vor dem zugriff abgezogen werden. !sTyp42   MOVE.L  (A7)+,D6*MOVE.L  D2,-10(A1,D6.L) ;^SET TYPE*MOVE.L  D1,D0*LSR.L   #3,D0           ;ANZAHL BYTES FUER SET*AND.W   #7,D1*BEQ     sTyp43*ADDQ.W  #1,D0 !sTyp43   CMPI.L  #1,D0*BEQ     sTyp44*ADDQ.W  #1,D0*BCLR    #0,D0           ;AUFRUNDEN bei Set > 1 Byte sTyp44    MOVE.L  D0,-6(A1,D6.L)*MOVE.L  D0,TypeLen*; prÅfen, ob es ein SET OF BITNUM ist oder $U+ aktiv und das Set*; in ein Reg paût. Dann wird Kennung 45 statt 5 vergeben.*CMPI.B  #11,-1(A1,D2.L) ;SUBRANGE?*BNE     sTyp45*MOVE.L  -18(A1,D2.L),D2 ;Ref-typ holen sTyp45    CMPI.B  #41,-1(A1,D2.L) ; Base type = BITNUM?*BEQ     is45*CMPI.L  #4,D0           ;Grîûe <= 4?*BHI     no45*MOVE.L  Options,D0*BTST    #21,D0          ;$U+?*BEQ     no45 is45      MOVE.B  #45,-1(A1,D6.L) no45      MOVE.L  D6,D2*CLR.L   D1*RTS ; ;   POINTER ; !sTyp24  CMPI.W  #62,D3)BNE.L   sTyp35      ;TYPE DEC EXPECTED)JSR     GetSbl)CMPI.W  #43,D3)BEQ     ok22)MOVE    #rToXp,D5         ;TO EXPECTED)JMP     SyntaxErr !ok22    MOVE.L  TRESPC,D6)MOVE.W  #$8514,D0     ;Pointer gilt jetzt als Skalar (jm 26.2.86))JSR     SETKNG)MOVEQ   #4,D0)MOVE.L  D0,-6(A1,D6.L))MOVE.L  D6,-(A7))SUBQ.L  #5,D6)SUBQ.L  #5,D6)MOVE.L  D6,TRESPC)BSR     sTyp25          ; Typ holen)MOVE.L  (A7)+,D0)MOVE.L  D2,-10(A1,D0.L) ; Pointer-Eintrag: ^Typ)MOVE.L  #4,TypeLen)MOVE.L  D0,D2)CLR.L   D1)RTS  sTyp25   JSR     GetSbl)BEQ     fwrdTyp     ;FWRD)BPL     settype1    ;bekannter Typ)CMPI.B  #48,D3      ;Fwrd-Typ?)BNE     settype0    ;Std-Symbol oldFwrd  ; Schon eingetragenen Fwrd-Typen behandeln)MOVE.L  D1,-(A7)    ;^Relay-Eintrag)BRA     sTyp28 fwrdTyp  ; POINTER-VorwÑrts-Ref behandeln.); Dazu wird der Name als Relay eingetragen. Das Relay zeigt wiederum); auf "FrwdTyp" (Kennung ist 48, Typ-Flag ist gelîscht), wird dieser); Name spÑter verwendet, kann nix schiefgehen, da er weder als Typ); markiert ist noch eine verwendbare Kennung hat. Daû der Pointer); selbst unerlaubt benutzt wird, ist ebenfalls daran zu erkennen,); daû er auf einen Eintrag zeigt, bei dem das Typ-Flag gelîscht ist.); Achtung: Sobald der Typ dekl. ist, muû der Ptr auf den Typeintrag);  direkt und nicht Åber's Relay verweisen. Da bis zu diesem Zeitpunkt);  der Frwd-Typ noch nicht benutzt worden sein dÅrfte, brauchen dabei);  keine weiteren BezÅge auf den Relay-Eintrag umgehÑngt werden.)TST.W   D3)JSR     GETID0)JSR     PULLID)JSR     SETID)MOVE.L  TRESPC,D6)MOVEQ   #0,D0     ;Relay eintragen)JSR     SETKNG)MOVE.L  FrwdTyp,-6(A1,D6.L))CLR.W   -8(A1,D6.L) ; Scope-Diff. sicherheitshalber auf Null)MOVE.L  D6,-(A7))SUBQ.L  #8,D6)MOVE.L  D6,TRESPC !sTyp28  JSR     GetSbl)MOVE.L  (A7)+,D2)RTS ; ;   PROCEDURE TYPE ; !sTyp35  CMPI.W  #59,D3         ;'procedure' ?)BEQ     ok24)MOVE    #rTypDc,D5)JMP     SyntaxErr !ok24    MOVE.L  TRESPC,D6)MOVE.W  #$8413,D0)JSR     SETKNG         ;Kennung 'Prozedurtyp')CLR     D0)JSR     procFlags)OR.B    D0,-2(A1,D6.L))MOVEQ   #4,D0          ;Laenge 4 byte)MOVE.L  D0,TypeLen)MOVE.L  D0,-6(A1,D6.L) ;Laenge)CLR.L   -10(A1,D6.L)   ;^ParameterListe)CLR.L   -14(A1,D6.L)   ;^ResultType)MOVE.L  D6,-(A7))MOVE.L  D6,D5)SUBQ.L  #4,D5)SUBI.L  #14,D6)MOVE.L  D6,TRESPC)JSR     GetSbl)CMPI.W  #14,D3        ;()BNE.L   sTyp36        ;keine Parameterliste ->)JSR     GetSbl)CMPI.W  #26,D3        ;))BEQ     sTyp37        ;leere Parameterliste -> );*** Parameterliste holen )MOVE.B  #-1,RegAnCnt)MOVE.B  #-1,RegDnCnt  !sTyp39  CLR.W   VarPar)BSR.L   oneParam      ;einen Parameter holen !ok25    MOVE.L  TRESPC,D6)MOVE.W  #$8007,D0)JSR     SETKNG             ;Glied der Parameter-Kette eintragen)CLR.L   -6(A1,D6.L)        ;^naechsten erstmal leer)MOVE.L  D2,-10(A1,D6.L)    ;^Parametertyp)MOVE.W  VarPar,D3)JSR     procParFlags       ;ggf. Registerzuweisung vornehmen (f. $\+))MOVE.W  D3,-12(A1,D6.L)    ;VarPar-Flag)MOVE.L  D6,-6(A1,D5.L)     ;in vorige Kette einhaengen)MOVE.L  D6,D5)SUBI.L  #12,D6)MOVE.L  D6,TRESPC)JSR     SameSbl)CMPI.W  #10,D3        ;,)BNE     sTyp40)JSR     GetSbl)BRA     sTyp39  !sTyp40  CMPI.W  #26,D3        ;))BEQ     sTyp37)MOVE    #rParXp,D5)JMP     SyntaxErr !sTyp37  JSR     GetSbl !sTyp36  MOVE.L  (A7)+,D5      ;^PROC.TYPE)CMPI.W  #25,D3        ;:)BNE     sTyp41))JSR     GetSbl)MOVE    #1,VarPar       ;damit aus Kennung 19 nicht 44 gemacht wird)BSR.L   fpSect5         ;einfacher Typ oder String ?)MOVE.L  D2,-14(A1,D5.L) ;eintragen))MOVE.L  Options,D0)BTST    #26,D0         ;$Z- ? Dann keine D0-RÅckgabe)BEQ     noD0rtn)CMPI.L  #4,-6(A1,D2.L) ;paût Result in ein Register?)BHI     noD0rtn)BSET    #0,-2(A1,D5.L) ;ja: Bit 0 in Item-Flags setzen noD0rtn)JSR     SameSbl !sTyp41  MOVE.L  D5,D2)CLR.L   D1)RTS)); Einen formalen Parameter der ProcTyp-Dekl. holen.);  Erwartet erstes Symbol schon in D3;);  liefert VarPar-Flag in VarPar und ^Parametertyp in D2.);  Erzeugt evtl. eigene Eintraege im Baum (Strings, Open Arrays)  oneParam CMPI.W  #70,D3        ;'REF' ?)BNE     noREF)BSET    #1,VarPar)BRA     isREF noREF    CMPI.W  #56,D3        ;'VAR' ?)BNE     sTyp38)BSET    #0,VarPar isREF    JSR     GetSbl sTyp38   MOVE.W  #$8020,D0)CMPI.W  #60,D3        ;'ARRAY'?)BEQ     isVAR)CMPI.W  #71,D3        ;'LONGARRAY'?)BNE.W   fpSect5))MOVE.W  #$802A,D0 ); Open Array) isVAR    MOVE    D0,-(A7))JSR     GetSbl)CMPI.W  #46,D3        ;OF)BEQ     isOF)MOVE    #rOFXp,D5)JMP     SyntaxErr isOF     BSET    #7,VarPar)JSR     GetSbl)BSR.L   fpSect5       ;PrÅfen, ob's ein Typ ist)MOVE.L  TRESPC,D6)MOVE    (A7)+,D0)JSR     SETKNG)MOVE.L  D2,-6(A1,D6.L) ;ELEMENTTYP)MOVE.L  D6,D2)SUBQ.L  #6,D6)MOVE.L  D6,TRESPC)RTS ); einfachen Typ oder String holen  fpSect5  BTST    #10,D3        ;TYP?)BNE     fpSect3)(*+CMPI.W  #47,D3        ;STRING+BNE     noString+JSR     SetTyp13+BRA     fpSect4)*) noString TST.W   D3)BEQ     fwrdTyp         ;unbekannt: als Fwrd-Typ eintragen)BPL     typXp)CMPI.B  #48,D3)BEQ     oldFwrd         ;schon als Fwrd-Typ eingetragen typXp    MOVE    #rTyDXp,D5)JMP     SyntaxErr fpSect3  ; ggf. neue Kennung 44 bei Proc-Parms & $H+ vergeben)CMPI.B  #19,D3        ;PROC-Type?)BNE     fpSect6)TST     VarPar        ;nur bei value-Parms Kennung 44 verwenden!)BNE     fpSect6)MOVE.L  Options,D0)BTST    #08,D0         ;$H- ? Dann PROC-Type m. 4 Byte belassen)BEQ     fpSect6); Proc-Typen mit 8 Byte anlegen)MOVE.L  TRESPC,D6)MOVE.W  D3,D0         ;alte Flags Åbernehmen!)MOVE.B  #$2C,D0       ;neue Kennung: 44)JSR     SETKNG)SUBI.L  #10,TRESPC)MOVE.L  #8,-6(A1,D6.L)                 ; LÑnge auf 8 setzen)MOVE.L  D2,-10(A1,D6.L)                ; ^Proc-Typ (19) eintragen)MOVE.L  D6,D2                          ; dies ist der neue Typ  fpSect6  MOVE.L  D2,-(A7))JSR     GetSbl)MOVE.L  (A7)+,D2 fpSect4"END END SetType;    (*!*  CONSTANT FACTOR!*!* Wird in D2 "StrPtr" zurÅckgegeben, steht String-Literal-LÑnge nicht!* in der Typ-Info sondern in "StrLen"! "AccuPtr" zeigt dann auf den!* String-Puffer.!*)  VAR myRealStr: String;  PROCEDURE ConFact; BEGIN ASSEMBLER)MOVE.L  #Accu,AccuPtr)MOVE.L  A2,A0)CLR.L   D6)CLR.W   D4)TST.W   D3)BMI.L   ConsID)CMPI.W  #NUMCONST,D3  ;NUMBER)BEQ     ConFact0)CMPI.W  #73,D3        ;$)BEQ.L   ConvHEX)CMPI.W  #STRCONST,D3  ;STRING/CHAR)BEQ.L   CONCHAR)ORI     #1,CCR        ;SEC)RTS ConFact0 MOVE.B  (A0)+,D3)CMPI.B  #'%',D3)BEQ.L   ConvBIN)MOVE.B  D3,D1)AND.B   #$DF,D1)CMPI.B  #'H',D1        ;Int/Card im HexFormat?)BEQ.L   ConvHEX)CMPI.B  #'R',D1        ;Real im Hex-Format?)BEQ.L   CONRHEX)CMPI.B  #'B',D1        ;Int/Card im Oktalformat oder Hexzahl)BEQ     ConFact5)CMPI.B  #'C',D1)BNE     ConFact2       ;Char in Dez/Okt oder Hexzahl)MOVEQ   #1,D4          ;als Char vormerken, falls kein H/R kommt)BRA     ConFact2 ConFact5 MOVEQ   #2,D4          ;als Oktal vormerken, falls kein H/R kommt ConFact2 CMPI.B  #'.',D3)BNE     ConFact1)MOVE.B  (A0)+,D3      ;'.' oder '..'?)CMPI.B  #'.',D3)BNE     CONREL        ;einzelner Punkt: muss Real sein)BEQ     ConFact3      ;sonst eine der Ganzzahl-Versionen ConFact1 SUBI.B  #'0',D3)BMI.L   ConFact3)CMPI.B  #9,D3)BLS     ConFact0      ;noch Ziffer: weiter)ANDI.B  #$5F,D3       ;maskiere Lowercase weg)CMPI.B  #17,D3)BCS.L   ConFact3)CMPI.B  #22,D3)BLS     ConFact0      ;noch Hexdigit: weiter ConFact3 TST.W   D4)BEQ.L   ConCard)SUBQ.W  #1,D4)BEQ.L   ConDecC       ;CHAR in Dez/Okt-Darstellung)BNE.L   ConvOct       ;Int/Card in Oktal-Darstellung  ; Realkonstante konvertieren. ;   A2    = ^Text ;   A2   := ^hinter Realzahl ;   Accu.Q := Realkonstante  ConRel   MOVEM.L A1/A3-A6/D3-D7,-(A7) ;Modula-Umgebung herstellen)MOVEQ   #1,D7)MOVE.L  EvalStk,A3@;String auf den Stack kopieren, mit SyntaxCheck)CLR.W   D1             ;Laengenzaehler ConRel1  BSR.L   GetDigit)BEQ     ConRel1        ;Vorkommastellen holen)CMP.B   #'.',D0)BNE.L   Er32 ConRel2  BSR.L   GetDigit)BEQ     ConRel2        ;Nachkommastellen holen)CMP.B   #'E',D0)BEQ     ConRel3)CMP.B   #'e',D0)BNE     ConRel9 ConRel3  BSR.L   GetDigit)BEQ     ConRel4        ;kein Exponenten-Vorzeichen)CMP.B   #'-',D0)BEQ     ConRel5)CMP.B   #'+',D0)BNE.L   Er32           ;kein gueltiges Zeichen nach 'E' ConRel5  BSR.L   GetDigit)BNE.L   Er32           ;mind. eine Ziffer nach 'E' muss sein! ConRel4  BSR.L   GetDigit)BEQ     ConRel4        ;weitere Exp-Ziffern ConRel9  SUBQ.L  #1,A2)MOVE.L  A2,-(A7))MOVE.L  #myRealStr,(A3)+ ; ADR (str))MOVE    #SIZE (myRealStr)-1,(A3)+      ; HIGH (str))CLR.W   -(A7))MOVE.L  A7,(A3)+       ; VAR pos)CLR.W   -(A7))MOVE.L  A7,(A3)+       ; VAR valid )JSR     StrToReal ); und nun ggf. ins andere Format wandeln)MOVE    UseFormat,D0)CMPI    #3,D0)BEQ     noRconv        ;hat schon richtiges Format)TST     SysFormat       ;Format der Zahl)SNE     D1)ANDI    #1,D1)MOVE    D1,(A3)+        ;erhaltenes Format)TST     D0)SNE     D0)ANDI    #1,D0)MOVE    D0,(A3)+        ;gewÅnschtes Format)JSR     Conv'noRconv )MOVE.L  -(A3),AccuS14)MOVE.L  -(A3),Accu )TST.W   (A7)+          ;StrToReal erfolgreich?)ADDQ.L  #2,A7)BEQ.L   Er31           ;Zahl zu gross )MOVE.L  A3,EvalStk)MOVE.L  (A7)+,A2       ;Register wiederherstellen)MOVEM.L (A7)+,A1/A3-A6/D3-D7))JSR     RealConstIsUsed  ;Real-Format ist nun festgelegt)MOVE.L  RealPtr,D2     ;ErgebnisTyp ist Real)RTS (* BadSel   MOVE    #rFmtSl,D5     ;Bad Real format selector)JMP     SyntaxErr *) Er32     MOVE    #rNrFmt,D5     ;Bad Format)JMP     SyntaxErr  ; Zeichen aus dem Text auf (A3)-Stack, inc (D1), ;  Zero-Flag := "Zeichen ist Ziffer"  GetDigit MOVE.B  (A2)+,D0       ;Zeichen aus dem Text)LEA     myRealStr,A0)MOVE.B  D0,0(A0,D1.W)  ;in den String kopieren)ADDQ.B  #1,D1          ;Laenge mitzaehlen)CMPI    #79,D1)BHI.L   Er31           ;Zu gross!)CMP.B   #'0',D0)BCS     GetDig1        ;zurueck mit NE)CMP.B   #'9',D0)BHI     GetDig1        ;zurueck mit NE)CMP.B   D0,D0          ;Zero Flag = "das war eine Ziffer" GetDig1  RTS  ; CharKonstante in Dezimal- oder Oktaldarstellung konvertieren; ;  CompilerOption $G(epard) bestimmt Radix  ConDecC  MOVE.L  Options,D0)BTST    #7,D0          ;'G' = 0 ?)BEQ     ConDec1        ;ja: Oktaldarstellung ist gefragt)BSR.L   ConCard0       ;nein: Dezimal)BRA     ConDec0 ConDec1  BSR.L   ConvOct0 ConDec0  MOVE.B  (A2)+,D0       ;nach der letzten gueltigen Ziffer)CMP.B   #'c',D0        ;wuerden wir gern ein grosses oder kleines)BEQ     CONOK)CMP.B   #'C',D0        ;'C' sehen!)BEQ     CONOK)MOVE    #rNrFmt,D5)JMP     SyntaxErr ConOK    MOVE.L  Accu,D0)CMPI.L  #255,D0)BLS     CONOK1         ;Wert < 256: OK)MOVE    #rNrOv,D5)JMP     SyntaxErr ConOK1   ; MOVE.L  CHARPTR,D2   ;Ab Compiler 4.0 wird String-Literal geliefert)MOVE.L  StrPtr,D2)LEA     StrBuf,A0)MOVE.L  A0,AccuPtr)MOVE.B  D0,(A0)+)CLR.B   (A0)           ;auch Chars mÅssen 0-terminiert sein!)MOVE    #1,StrLen)RTS ; ConvOct0 CLR.L   D1            ;Oktales CARDINAL holen ohne C/L/B-Suffix ConvOct3 MOVE.B  (A2)+,D3)SUBI.B  #'0',D3)BMI     ConvOct6)CMPI.B  #7,D3)BHI     ConvOct6)CMPI.L  #$1FFFFFFF,D1)BHI.L   ER31)LSL.L   #3,D1)OR.B    D3,D1)BRA     ConvOct3 ConvOct6 MOVE.L  D1,Accu)SUBQ.L  #1,A2)RTS ; ConCard0 CLR.L   Accu          ;Dezimales CARDINAL holen ohne C/L-Suffix ConCard1 MOVE.B  (A2)+,D3)SUBI.B  #'0',D3)BMI     ConCard2      ;ENDE DER ZAHL)CMP.B   #9,D3)BHI     ConCard2      ;    -"-)BSR.L   MUL10         ;ACC1 := ACC1 * 10 + D3.B)BRA     ConCard1 ConCard2 SUBQ.L  #1,A2)RTS ; ConvHEX  BSR.L   ConvHEX0)BRA     ConCard9 ; ConvBIN  BSR.L   ConvBIN0)BRA     ConCard9 ; ConvOct  BSR.L   ConvOct0)MOVE.B  (A2)+,D0)AND.B   #$5F,D0)CMP.B   #'B',D0)BEQ     ConCard9)MOVE    #rNrFmt,D5)JMP     SyntaxErr ; ConCard  BSR     ConCard0 ConCard9 MOVE.B  (A2),D0)AND.B   #$DF,D0)CMPI.B  #'L',D0)BEQ     ConCard7     ;-> wird BothTyp (feste LÑnge f. Long))CMPI.B  #'D',D0)BEQ     ConCard7     ;-> wird BothTyp (feste LÑnge f. Long));ZZ-Typ muû noch aufbereitet werden:)MOVE.L  ZZTyp,D2)LEA     Accu,A0)MOVE.L  A0,AccuPtr)MOVE.L  (A0),2(A0))BPL     ConCard4)MOVE    #1,(A0)       ;over-Flag setzen)RTS ConCard4 CLR     (A0)          ;over-Flag lîschen)RTS ConCard7 ADDQ.L  #1,A2         ;L-SUFFIX WEG)TST.L   Accu)BMI     ConCard3      ; > MaxLInt: BothTyp geht nicht)MOVE.L  BothTyp,D2)RTS ConCard3 MOVE.L  CARDPTR,D2    ; dann LongCard, weil ja 'Long' erzwungen wird)RTS ; !MUL10   MOVE.L  Accu,D0)LSL.L   #1,D0)BCS     MULOVFL)LSL.L   #1,D0)BCS     MULOVFL)ADD.L   Accu,D0)BCS     MULOVFL)LSL.L   #1,D0)BCS     MULOVFL)ANDI.L  #$F,D3)ADD.L   D3,D0)BCS     MULOVFL)MOVE.L  D0,Accu)RTS !MULOVFL  MOVE     #rNrOv,D5*JMP      SyntaxErr ; ConvBIN0 CLR.L   D1 ConvBIN3 MOVE.B  (A2)+,D3)CMP.B   #'%',D3)BEQ     ConvBIN6)SUBI.B  #'0',D3)BMI     ConvBIN7)CMPI.B  #1,D3)BLS     ConvBIN2 ConvBIN7 MOVE   #rNrFmt,D5)JMP    SyntaxErr ConvBIN2 LSL.L   #1,D1)BCS.L   ER31)OR.B    D3,D1)BRA     ConvBIN3 ConvBIN6 MOVE.L  D1,Accu)RTS  ConvHEX0 CLR.L   D1 ConvHEX3 MOVE.B  (A2)+,D3)CMP.B   #'H',D3)BEQ     ConvHEX6)CMP.B   #'h',D3)BEQ     ConvHEX6)SUBI.B  #'0',D3)BMI     ConvHEX7)CMPI.B  #9,D3)BLS     ConvHEX2)AND.B   #$5F,D3)SUBQ.B  #7,D3)CMPI.B  #$A,D3)BCS     ConvHEX7)CMPI.B  #$F,D3)BHI     ConvHEX7 ConvHEX2 CMPI.L  #$0FFFFFFF,D1)BHI.L   ER31)BRA     CONHOK !ER31    MOVE    #rNrOv,D5)JMP     SyntaxErr ConHOK  LSL.L   #4,D1)OR.B    D3,D1)BRA     ConvHEX3 ConvHEX7 SUBQ.L  #1,A2         ;KEIN 'H' AM ENDE ConvHEX6 MOVE.L  D1,Accu)RTS) ; LongReal-Konstanten im HexFormat konvertieren, ; Format HexDigit {HexDigit} 'R', rechtsbuendig in 64 bit!  ConRHex  CLR.L   d0*CLR.L   d1 ConRHex3 MOVE.B  (A2)+,D3*CMP.B   #'R',D3*BEQ     ConRHex6*CMP.B   #'r',D3*BEQ     ConRHex6*SUBI.B  #'0',D3*BMI     er32          ;falsche Ziffer*CMPI.B  #9,D3*BLS     ConRHex2*AND.B   #$5F,D3*SUBQ.B  #7,D3*CMPI.B  #$A,D3*BCS     er32*CMPI.B  #$F,D3*BHI     er32 ConRHex2 LSL.L   #1,D0*ROXL.L  #1,D1*LSL.L   #1,D0*ROXL.L  #1,D1*LSL.L   #1,D0*ROXL.L  #1,D1*LSL.L   #1,D0*ROXL.L  #1,D1*OR.B    D3,D0*BRA     ConRHex3 ConRHex6 MOVE.L  D1,Accu*MOVE.L  D0,AccuS14*;bei BinÑrangabe von Real-Konstanten wird Real-Format nicht festgelegt*MOVE.L  RealPtr,D2*RTS)); String oder Char in '' wurde aus dem Text geholt: abliefern.  ConCHAR  (* Auch Strings der LÑnge Eins werden nun als SS-Typ behandelt-CMPI.W  #1,STRLEN  ; STRING-CONST IN '"-BNE     CONSTRG-CLR.L   D2-MOVE.B  STRBUF,D2-MOVE.L  D2,Accu-MOVE.L  CHARPTR,D2-RTS)*))LEA     STRBUF,A0)MOVE.L  A0,AccuPtr)BRA     CONSTRG ); Stringkonstante aus dem Baum in StrBuf/StrLen kopieren) ConSTRG0 LEA     STRBUF,A0)MOVE.L  A0,AccuPtr)CLR.W   D0)MOVE.B  -3(A1,D2.L),D0)MOVE.W  D0,STRLEN     ;CHAR-ZAHL)SUBQ.B  #1,D0)BMI     CONSTRG2 ConSTRG1 SUBQ.L  #1,D2)MOVE.B  -3(A1,D2.L),(A0)+)DBF     D0,CONSTRG1 ConStrg2 CLR.B   (A0)+) ConSTRG  MOVE.L  STRPTR,D2)RTS ; BADCON   ORI     #1,CCR        ;SEC)RTS ; ConsID   CMPI.B  #18,D3        ;WIRKLICH CONST (alt)?)BEQ     ConsID2)CMPI.B  #50,D3        ;WIRKLICH CONST (neu)?)BEQ     ConsID2b)CMPI.B  #31,D3        ;STRINGCONST?)BEQ     CONSTRG0      ;STRING AUS BAUM KOPIEREN)CMPI.B  #10,D3        ;ENUM ELEMENT)BEQ.W   CONENUM); CMPI.B  #5,D3         ;SET)BNE     BADCON (* ; ; SET CONSTANT MIT IDENTIFIER ;)MOVE.L  D2,-(A7))JSR     GETSBL)MOVE.L  (A7)+,D2)CMPI.W  #16,D3        ;{)BNE     BADCON)JMP     ConSet *) ; ; NAMED CONSTANT (alt, ohne Ref-Mîglichkeit) ; ConsID2  MOVE.L  -6(A1,D2.L),D0 ;TYP)MOVEQ   #0,D1)MOVE.W  -8(A1,D2.L),D1 ;BYTELAENGE)LEA     Accu,A0)CMPI.W  #AccuSize,D1)BLS     ConsID4);PrÅfen, ob Const nicht zu lang wird im Code)MOVEM.L D1/A4,-(A7))LEA     $100(A4),A4)ADDA.L  D1,A4)JSR     CodeSpc)MOVEM.L (A7)+,D1/A4)LEA     $100(A4),A0 ConsID4  MOVE.L  A0,AccuPtr ConsID3  MOVE.L  -12(A1,D2.L),(A0)+ ;KONSTANTE AUS BAUM KOPIEREN)SUBQ.L  #4,D2)SUBQ.W  #4,D1)BGT     ConsID3)MOVE.L  D0,D2)RTS ; ; NAMED CONSTANT (neu, mit Ref-Mîglichkeit) ; ConsID2b MOVE.L  -10(A1,D2.L),D0 ;TYP)MOVEQ   #0,D1)MOVE.W  -16(A1,D2.L),D1 ;BYTELAENGE)MOVE.W  D1,STRLEN)CMP.L   STRPTR,D0       ;String-Literals in STRBUF ablegen)BNE.S   ConsID2c)LEA     StrBuf,A0)CMPI.W  #MaxStrLen,D1)BHI.S   STROVFL)BRA.S   ConsID4b ConsID2c LEA     Accu,A0)CMPI.W  #AccuSize,D1)BLS     ConsID4b);PrÅfen, ob Const nicht zu lang wird im Code)MOVEM.L D1/A4,-(A7))LEA     $100(A4),A4)ADDA.L  D1,A4)JSR     CodeSpc)MOVEM.L (A7)+,D1/A4)LEA     $100(A4),A0 ConsID4b MOVE.L  A0,AccuPtr ConsID3b MOVE.L  -20(A1,D2.L),(A0)+ ;KONSTANTE AUS BAUM KOPIEREN)SUBQ.L  #4,D2)SUBQ.W  #4,D1)BGT     ConsID3b)MOVE.L  D0,D2)RTS  STROVFL  MOVE     #rSCoLg,D5)JMP      SyntaxErr ; ; ENUMERATION TYPE CONSTANT ; ConEnum  CLR.W   Accu)MOVE.W  -4(A1,D2.L),AccuM1 ;RANG)MOVE.L  -8(A1,D2.L),D2 ;^ENUM TYPE(END END ConFact; 
(* $000138A8$00010D42$FFE88047$FFF86180$FFF86180$FFF86180$FFF86180$FFF86180$FFF86180$FFF86180$FFF86180$00011827$FFF86180$000186A3$FFF86180$00014CDE$FFF86180$00009F01$FFF86180$FFED5158$0000BEAD$00008FB7$FFF86180$FFF86180$FFF86180$0000A620$FFF86180$FFF86180$FFF86180$FFF86180$FFED5158$FFF86180$0001443F$FFF86180$FFED3DC7$0000EC2E$0000BEAD$FFF86180$0000D768$FFF86180$FFF86180$00001543Ä$00011827T.......T.......T.......T.......T.......T.......T.......T.......T.......T.......$00010FB2$00011827$FFE3C5BC$00010DA3$00010F08$FFE3C5BC$00010DA3$00010F8D$00011827$0000D100$0000D10D$FFE36C8A$0000D132$0000C54C$00010E04$00010F8D§ÄÇ*)
