5.1 Bibliothek: Allgemeines                                                5 -   1
________________________________________________________


5.1  Allgemeines  zur  Bibliothek


FunktionsÅbersicht

Bevor  Sie  weiterblÑttern  und  womîglich  von  der  Funktionsvielfalt  der  Åber
einhundert Module erschlagen werden, geben wir Ihnen eine kleine öbersicht.

Einige Module kennen Sie sicher schon aus Ihrem Modula-2 Buch:

   - InOut      zur Ein-/Ausgabe Åber Tastatur und Bildschirm,
   - Terminal   ebenso (aber nur auf TOS-Bildschirm ohne GEM!)
   - Mathlib0   mit mathematischen Funktionen fÅr REALs/LONGREALs,
   - Strings    zum Arbeiten mit Zeichenketten und
   - Storage   um NEW und DISPOSE verwenden zu kînnen.

Wenn Sie Neueinsteiger in Modula-2 sind, reicht es aus, wenn Sie sich erst
einmal nur mit diesen Modulen beschÑftigen.

FÅr Fortgeschrittene folgt eine öbersicht weiterer nÅtzlicher Module:

Dateifunktionen:
    Files, Text, NumberIO, Binary, Directory.

Grafik (GEM)
    AES...,   VDI...,    GEM...,    ObjHandler,    EventHandler,    TextWindows,
    WindowBase, WindowLists, EasyGEM0, EasyGEM1.

String/Zahlen-Umwandlung:
    Convert, StrConv, Strings, FuncStrings.

Tastatur- und Zeichenauswertung:
    Characters, Keyboard.

Programmkontrolle:
    Loader, ModCtrl, PrgCtrl.

Diverse Hilfsfunktionen
    SysUtil0      - Variablenvergleiche, -lîschen, -lopieren, Bit-Funktionen
    SysUtil1       - Speicherzugriffe aller Art, auch im Supervisormodus
    SysUtil2      - SetJump/LongJump (wie in C), Supervisormodus
    Clock         - Datums-/Zeitbestimmung
    TimeConvert  - Datums-/Zeit-Ein- und Ausgabe
    Lists          - Verwaltung allgemeiner Listen
    RandomGen   - Zufallszahlenerzeugung

Alle Module sind jeweils in ihren Definitionstexten (s. Anhang) dokumentiert!
5.1 Bibliothek: Allgemeines                                                5 -  2
________________________________________________________


öbersicht der vorhandenen Module

Folgende Megamax-Module stehen Ihnen incl. Quelltexten zur VerfÅgung
(Ordner MOS):

GEMDebug    - Hilfsmodul zum schrittweisen AusfÅhren v. Modula-Programmen
TOSDebug    - wie GEMDebug, aber mit TOS- statt Fensterausgabe

GEMError    - Treibermodul zum Abfangen v. Laufzeitfehlern (komfortabel)
SimpleError  - Wie GEMError, nur einfacher (siehe Kapitel 2.6 Åber Linker)
GEMScan     - Hilfsmodul zum Anzeigen v. Laufzeitfehlern

GEMIO       - Treibermodul zur Ausgabe von InOut in ein GEM-Window
TOSIO        - Treibermodul zur Ausgabe von InOut Åber BIOS-Routinen
GEMDOSIO   - Treibermodul zur Ausgabe von InOut Åber GEMDOS-Routinen

M2Init        - Initialisierungsmodul fÅr alle gelinkten Programme
MM2Shell     - Die Shell zum SelbstverÑndern
MOSConfig   - Konfiguationsvariablen fÅr Loader, ErrBase, InOut usw.

Von folgenden Modulen haben Sie die Codeversionen erhalten (Ordner IMP):

ArgCV        - Auswertung der Argumentzeile (Command-Line)
ArgCVIO      - Auswertung der Argumentzeile mit E/A-Umleitungsmîglichkeit
Binary        - Dateisystem: E/A fÅr BinÑrdaten, Seek, FileSize
BinOps        - Vergleichsfunktionen fÅr jeweils zwei Werte
BIOS         - BIOS-Funktionen
Block         - Sehr schnelles Lîschen und Kopieren groûer Datenbereiche
Calls          - Aufruf von Modula-fremden Routinen (z.B. Betriebssystem)
Characters   - ASCII-Konstanten und Funktionen zum Auswerten von Zeichen
Clock         - Zeit- und Datumsbestimmung
Compressions- Datenkomprimierung
Console       - Wie Terminal, jedoch Ausgabe Åber GEMDOS statt BIOS
Convert       - Umwandlung Zahlen <-> Strings (siehe auch StrConv)
Directory     - Lîschen u. Umbenennen v. Dateien, Directory-Hilfsfunktionen
EasyExceptions - Komfortables Abfangen von Laufzeitfehlern
ErrBase      - Grundmodul zum Abfangen von allgemeinen Laufzeitfehlern
Excepts       - Abfangen der Exceptions des Prozessors (680x0)
FastStrings   - Alternatives Strings-Modul
FileBase      - Dateisystem: Fehlerbehandlung und Device-Treiber
FileNames    - Zusammensetzen und Analysieren von Datei- und Pfadnamen
Files          - Dateisystem: ôffnen und Schlieûen v. Dateien
FPUSupport   - FÅr Benutzung der FPU in Accessories und Coroutinen
FuncStrings   - Komfortablere String-Funktionen (Pascal-Ñhnlich)
GEMDOS     - GEMDOS-Funktionen
HdlError      - Spezielles Modul zum Abfangen von allg. Laufzeitfehlern
InOut         - Standard Ein- und Ausgabe
InOutBase    - Modul fÅr InOut-Treiber (z.B. GEMIO, TOSIO, GEMDOSIO)
5.1 Bibliothek: Allgemeines                                                5 -  3
________________________________________________________


KbdCtrl       - Direkte Tastaturabfrage/-kontrolle
Keyboard     - Auswertung von Tasten mit sog. Scan-Codes
LibFiles       - Verwaltung von Library-Dateien
Lists          - Verwaltung doppelt verketteter Listen
Loader        - AusfÅhren von Programmen, auch mit Load-Time-Linking
MathLib0     - Mathematische Grundfunktionen f. REAL-Zahlen
ModCtrl       - Modulverwaltung, Prozeduren als Prozeû starten
MOSGlobals  - System-globale Konstanten und TYPE-Definitionen
NumberIO    - Dateisystem: E/A von Zahlen in Textform
Paths         - Dateien-Suchfunktionen
PathEnv       - Directory-Umgebung: HomePath und File-Selector
PathCtrl      - Verwaltung von Pfadliste f. Paths-Modul
PrgCtrl       - Programm-/Prozeûkontrolle (siehe auch ResCtrl)
RandomGen   - Zufallszahlenbestimmung
ResCtrl       - Modulkontrolle (siehe auch PrgCtrl)
ResourceHandler - komfortable Prozeûkontrolle (setzt auf PrgCtrl, ResCtrl auf)
Runtime       - Laufzeitfunktionen, automatisch vom Compiler importiert
Storage       - Speicherverwaltung
StorBase     - Systemnahes Modul zur Speicherverwaltung
StrConv      - Erweiterte Zahlenumwandlungsfunktionen zu Convert
StringEditor  - Allg. Funktion zur komfortablen Eingabe einer Textzeile.
Strings       - String-Funktionen (siehe auch FastStrings, FuncStrings)
SysCtrl       - Hilfsroutinen fÅr den Scanner (Module GEMError, GEMScan)
SysInfo       - Ermittelt Prozessortype, Koprozessor, TOS-Version
SysTypes     - Definition v. Systemtypen
SysUtil0      - Hilfsfunktionen zum Lîschen v. Variablen, Vergleichen usw.
SysUtil1       - Speicherzugriffe aller Art, auch im Supervisormodus
SysUtil2      - SetJump/LongJump (wie in C), Super-Funktion
SysVars      - Systemvariablen des TOS
TermBase    - Treibermodul zu Terminal
Terminal      - InOut-Treiber f. TOS-Bildschirm (BIOS-Ein-/Ausgaben)
Text          - Dateisystem: E/A von Textdaten
                                           < >
TimeConvert  - Umwandlung Zeit/Datum  -  Text (s. Clock)
UserBreak    - Ermîglicht Abbrechen von Programmen Åber Tastatur
UserTrace    - Alternative zu Debug
VT52         - Escape-Sequenzen des VT-52-Emulators (f. Textausgaben)
XBIOS        - XBIOS-Funktionen
XBRA         - Bequeme XBRA-Installation
5.1 Bibliothek: Allgemeines                                                5 -  4
________________________________________________________


AES...        - AES-Funktionen des GEM
VDI...         - VDI-Funktionen des GEM
EasyGEM0    - Allgemeine GEM-Hilfsfunktionen
EasyGEM1    - Bequemer Aufruf des Datei-Selektors und der Clipboard-Funk~
                 tionen (Klemmbrett, Scrap-Directory)
EventHandler - Zentrale Verwaltung aller Events des GEM fÅr das MOS
FastGEM0    - Teils optimierte VDI-Funktionen
FileManagement - Shell-Funktionen: Kopieren, Lîschen usw.
GEMEnv      - Verwaltung der GEM-Umgebung
GEMGlobals   - Definitionen globaler GEM-Strukturen
GrafBase     - Grafische Hilfsfunktionen
KbdEvent     - Synchronisiert Tastenereignisse mit Sondertasten (Shift usw.)
LineA         - Line A-Funktionen des TOS.
ObjHandler    - Komfortabler Zugriff auf GEM-ObjektbÑume
TextWindows - Komfortable Fensterverwaltung fÅr Textausgaben
WindowBase  - Allgemeines Fenster-Kontrollmodul
WindowLists  - Verwaltet automatisch Textzeilen in einem Fenster

Die  folgenden  Module  sind  nicht  dokumentiert,  da  sie  nur  systemintern
verwendet werden und énderungen vorbehalten sind:

GEMShare    - GEM-Systemmodul
InOutFile      - Hilfsmodul fÅr InOut
MOSCtrl      - Grundmodul fÅr alle Programme
ModBase      - Hilfsmodul fÅr Loader & ModBase
SFP004       - Verwaltung f. evtl. vorhandenen Mathe-Koprozessor (68881)
SystemError  - Programmabbruch bei fatalen Fehlern (Speichermangel usw)

Module, die nicht zum MOS gehîren und jederzeit von uns oder Ihnen geÑndert
werden kînnen:

MM2ShellRsc - GEM-Resource-Konstanten, mit NRSC  ASH.PRG zu erzeugen.
                                                         _
                 Wollen Sie die Shell erweitern, dÅrfen Sie natÅrlich dabei auch
                 eine neue Resource-Datei erzeugen und verwenden, denn sie
                 wird nur  von  der  Shell  importiert,  auf  deren  Quelltext  Sie
                 ebenfalls Zugriff haben.
ShellMsg      - Hilfsmodul zur Kommunikation zw. Shell, Compiler und Linker.
                 Achtung - greifen Sie nicht in Ihren normalen Anwendungen
                 darauf zu! Erstens  sind  die  Werte  in  gelinkten  Programme
                 nicht  mehr  initialisiert  (weil  das  nur  die  Modula-Shell  tut),
                 zweitens  behalten  wir  uns  jederzeit  énderungen  daran  vor,
                 so  daû  Sie  dann  Versionskonflikte  oder  andere  Probleme
                 bekommen.
5.1 Bibliothek: Allgemeines                                                5 -  5
________________________________________________________


Beispielprogramme (im DEMO-Ordner - Dokumentation in den Quelltexten)

AccDemo     - einfache Accessory-Demo
AsmDemo    - Beispiele fÅr Aufruf der TOS-Funktionen in Assembler
Dhrystone    - Verbreitetes Testprogramm fÅr Compiler-QualitÑt (Codeerz.)
ExcDemo     - Demonstriert Anwendung des Moduls Excepts
ExcTest      - Demonstriert Anwendung des Moduls Exceptions
Hatschi       - Demonstration von Coroutinen, auch als Interrupts
InitPath       - Hilfsmodul zum Initialisieren einer Pfadliste f. Paths-Funktionen
KbdTest      - Residentes Programm f. Tastaturmakros (KbdCtrl, ModCtrl)
LocalModules - Zeigt die mîglichen Import-/Export-VerhÑltnisse
Sieve         - Auch ein Testprogramm fÅr Compiler-QualitÑt (Codeerzeugung)
TextDemo    - Demoprogramm fÅr die VDI-Textausgabe
Tiefe          - Sind/waren Sie auch ein MAD-Fan?
WdwLists     - Zeigt Anwendung von WindowLists


Hilfsprogramme (im UTILITY-Ordner - Dokumentation in den Quelltexten)

CompInit      - Ermîglicht es, den Compiler als gelinktes Programm zu starten,
                 z.B. vom GEM-Desktop aus, um mehr Speicher frei zu haben.
CmpFiles      - Kann mehrere Dateien in zwei Verzeichnissen vergleichen
Decode       - Dekodiert Dateien
DelFiles       - Lîscht mehrere Dateien auf einmal
DoSysInfo    - Zeigt Systeminformationen an (TOS-Version, Scrap-Dir usw.)
Encode       - Kodiert (komprimiert) Dateien
ExecMod      - Damit  kann  jedes  noch  ungelinkte  Programmodul  auch  vom
                 Desktop gestartet werden
GPA          - Ermittelt die Adresse von Prozeduren der Module im Speicher
LibManager   - Anlegen und Bearbeiten von Library-Dateien
LinkInit       - Ermîglicht es, den Linker als gelinktes Programm zu starten,
                 z.B. vom GEM-Desktop aus, um mehr Speicher frei zu haben
ModLoad      - Ein  nettes  Programm,  das  die  MÑchtigkeit  von  Megamax
                 Modula (speziell des Loaders) mal so richtig ausnutzt
ModList       - éhnlich Alternate-R in der Shell, aber ausfÅhrlicher
ModTrace     - Residentes  Programm.  Zeigt  alle  Module  an,  die  durch
                 Loadtime-Linking in der Shell geladen werden
Monitor       - Erlaubt den Aufruf des Templemon beim Programmstart.
PathEdit      - PrÅfen und éndern der Pfadlisten in der Shell
SetTime      - Sorgt immer fÅr korrekt  eingestellte  Zeit/Datum.  Unbedingt
                 Åbersetzen, linken und in den AUTO-Ordner kopieren (s. auch
                 Kapitel 2.7), wenn keine Uhr im Rechner vorhanden ist!
ShowKeys    - "Quick-And-Dirty"-Programm,  das  alle  Tasteninformationen
                 anzeigt (auch Scan-Codes), benutzt Keyboard & KbdCtrl.
Time          - Anzeigen und Einstellen von Datum und Zeit
Timer         - komplexere Accessory-Demo
5.1 Bibliothek: Allgemeines                                                5 -  6
________________________________________________________


Allgemeine Hinweise zu den Modulen

Die Systemmodule, Programmkontrollmodule, Dateimodule sowie einige weitere
Module bilden zusammen das "Modula Operating System", kurz MOS genannt.

Sys-Funktionen

In einigen Modulen finden sich Prozeduren, deren Namen mit Sys beginnen. Sie
ergÑnzen immer Ñhnliche Prozeduren  ohne  diesen  Prefix.  Beispiel:  SysOpen
neben Open und SysAlloc neben ALLOCATE. Wo immer dies auftritt, erzeugen
die Prozeduren Resourcen (z.B. Dateien, Speicherbereiche), die normalerweise
spÑtestens bei Beendigung des Programms (Prozeû) wieder freigegeben werden
sollen. Damit  nichts  verloren  geht,  wenn  ein  Programm  nicht  selbst  dafÅr
sorgt, bei Programmende alles wieder freizugeben bzw. zu schlieûen, wird dies
automatisch von den Modulen des MOS durchgefÅhrt. Nun gibt es FÑlle, wo
dies nicht erwÅnscht ist. Z.B. ist es mîglich, Åber  globale  Variablen  eines
anderen  Programms  (Prozeû)  Speicher  anzufordern,  der  beim  Enden  des
Programms,  das  den  Speicher  anforderte,  nicht  automatisch  freigegeben
werden soll. In diesem Fall wÑre der Speicher mit SysAlloc statt ALLOCATE
anzufordern. Die Sys... Funktionen sorgen also allgemein dafÅr, daû die damit
angelegten  Resourcen  nicht  bei  Programmende  automatisch  freigegeben
werden.  Sie  kînnen  dann  nur  durch  den  expliziten  Aufruf  der  jeweils
zugehîrigen Freigabeprozedur freigegeben werden (z.B. Close, DEALLOCATE).

Wichtig ist die Anwendung solcher Sys-Funktionen vor allem bei Programmen,
die resident bleiben (z.B. mit Hilfe der Funktion InstallModule aus ModCtrl) und
bei Accessories. Bei Accessories sollten immer, wenn mîglich, Sys-Funktionen
verwendet werden, da es sonst aufgrund eines Konzeptionsfehlers vom TOS
z.B.  passieren  kann,  daû  ein  im  ACC  angeforderter  Speicherbereich  bei
Beendigung  eines  vom  Desktop  gestarteten  Programms  wieder  freigegeben
wird, was dann zum Totalabsturz des Rechners fÅhren kann.

Systemfunktionen

Es sind einige Funktionen in den Quelltexten als systemzugehîrig oder intern
ausgewiesen.  Solche  Funktionen  dÅrfen  in  keinem  Fall  von  Ihnen  ohne
ausdrÅcklichen Hinweis von unserer Seite verwendet werden. Auch wenn Sie
glauben, zu wissen, was die Funktionen im einzelnen tun - wir mÅssen Sie
warnen, wir haben da schon bîse öberraschungen erlebt! Teilweise behalten
wir uns auch vor, diese Funktionen in spÑteren Versionen intern fÅr andere
Zwecke zu miûbrauchen.
5.1 Bibliothek: Allgemeines                                                5 -  7
________________________________________________________


öbertragung (Portierung) von Modula-2 Programmen fremder Systeme

Wenn Sie Programme von anderen Modula-2 Systemen  Åbernehmen  wollen,
kînnen ProgrammÑnderungen notwendig werden. Zum einen ist es mîglich, daû
hardwarespezifische Zugriffe stattfinden. Hier mag eine Anpassung schwierig
sein, und wir kînnen Ihnen dabei leider nicht helfen. Dann kommt es vor, daû
andere Modula-2 Compiler Datentypen in anderen Formaten verarbeiten und es
dabei  z.B.  bei  Typanpassungen  zu  verschiedenen  Ergebnissen  kommt.  Das
grîûte  Problem  liegt  aber  meistens  in  der  Verwendung  unterschiedlicher
Library-Funktionen. Hierzu einige Hinweise:

Strings

Da Herr Wirth nicht das Format von Zeichenketten festlegte, sind mehrere
Formate mîglich. HÑufig, wie auch bei Megamax Modula, beginnt das erste
Zeichen eines Strings im ersten Element eines ARRAY  0..n  OF CHAR. Die
Zeichenkette, die in solch einem Feld steht, kann entweder das gesamte Feld
ausfÅllen oder durch ein Null-Zeichen (0C) begrenzt werden. Die LÑnge einer
Zeichenkette ist also gleich der Position des ersten Null-Zeichens des Strings
oder gleich der Feldelementanzahl. Es gibt Systeme, die den gesamten unbe~
nutzten Rest des Strings mit Null-Zeichen fÅllen; bei Megamax Modula ge~
schieht dies nicht - alle Zeichen nach  einem  Null-Zeichen  in  einem  String
werden ignoriert.

Es ist theoretisch auch mîglich, daû das erste Element eines Strings immer
die  LÑnge  der  gÅltigen  folgenden  Zeichen  enthÑlt.  Dann  beginnt  das  erste
Zeichen  einer  Zeichenkette  beim  zweiten  Feldelement,  ein  abschlieûendes
Zeichen  ist  unnîtig.  Diesem  Stringformat  werden  Sie  wahrscheinlich  nicht
begegnen, hîchstens, wenn Sie Pascal-Programme Åbernehmen. In diesem Fall
mÅssen Sie beachten, daû sich bei indiziertem Zugriff auf Stringelemente die
Positionen der Zeichen alle um Eins verschieben.

Die Funktionen in einem Strings-Modul sind nicht normiert. Einige Standard~
funktionen finden sich jedoch in jeder Modula-2 Implementation. Dazu zÑhlen
Pos, Assign, Delete, Insert, Concat (Concatenate) und Length. Letztere wird
sicher nie Probleme bereiten, bei den anderen ergeben sich bis zu drei Unter~
schiede zu anderen  Systemen:  die  Reihenfolge  von  Parametern,  die  Anzahl
derselben und das Verhalten bei Fehlern (Megamax Modula liefert einen BOOLEAN-
Wert, der Fehler anzeigt, andere Systeme stoppen das Programm durch einen
Laufzeitfehler). Das einfachste ist, sich ein Hilfsmodul zu erstellen, das die
benîtigten Funktionen mit den Parametern des fremden Systems exportiert und
die Megamax-Strings-Funktionen darÅber aufruft.
5.1 Bibliothek: Allgemeines                                                5 -  8
________________________________________________________


Bildschirm E/A (Ein-/Ausgabe)

Unsere WriteHex-Routinen geben das '$'-Zeichen selbst mit aus. Wenn Sie
das stîrt, kînnen Sie statt dessen die WriteNum-Routinen verwenden, die kein
Zeichen voranstellen und auch mit Leerzeichen statt mit Nullen linksseits fÅllen
kînnen.

Die Megamax-Module Terminal, TextWindows, Text und InOut geben Zeichen,
die mit Read eingelesen wurden, nur wieder auf den Bildschirm aus, wenn sie
keine Steuerzeichen, sondern sichtbare Zeichen  sind.  Dies  hat  sich  in  der
Praxis  bewÑhrt.  Programme  fÅr  fremde  Modula-2  Systeme  kînnten  davon
abhÑngig sein, daû jedes eingelesene Steuerzeichen auf den Bildschirm wieder
ausgegeben wird, da dies ursprÅnglich so vorgeschlagen wurde. In diesem Fall
behelfen Sie sich am besten ebenfalls mit einer Hilfsfunktion, die z. B. wie
folgt aussieht:

  PROCEDURE Read ( VAR c: CHAR );
    BEGIN
      InOut.Read ( c );
      IF c <= 37C  (* hîchstwertiges Steuerzeichen *) THEN
        Write ( c )  (* Steuerzeichen ausgeben *)
      END
    END Read;

Sie kînnen aber auch das Modul Console verwenden - dies gibt jedes einge~
gebene Zeichen gleich wieder aus, aber hat auch noch andere Eigenheiten, die
Sie am besten im Definitionsmodul nachlesen.

éhnlich verhÑlt es sich mit ReadString bei TextWindows, Console und Terminal.
Bei Eingabeende mit der "Return"-Taste bleibt der Cursor hinter dem einge~
gebenen Text stehen anstatt, in die folgende Zeile vorzurÅcken. Sollte dies
stîren, kann Ñhnlich wie beim obigen Beispiel eine Hilfsprozedur ReadString
deklariert werden, die nach dem entsprechenden Aufruf in Terminal, Console
bzw. TextWindows WriteLn nachfolgend aufruft.

Umgekehrt gibt ReadString aus InOut am Ende immer CR/LF aus (springt also
in die nÑchste Zeile). Ist dies unerwÅnscht, kann es generell durch Entfernen
des WriteLn-Aufrufs in der entsprechenden Funktion in GEMIO, GEMDOSIO
oder TOSIO verhindert werden  (nach  der  énderung  muû  das  Treibermodul
nicht nur neu Åbersetzt, sondern auch in die Shell neu eingelinkt werden, damit
sich die énderung bemerkbar macht).
5.1 Bibliothek: Allgemeines                                                5 -  9
________________________________________________________


Auch  verhalten  sich  die  Readstring-Funktionen  vieler  Modula-Systeme  beim
Eingeben sehr unterschiedlich. Manche erlauben die Eingabe einer  beliebigen
Zeile bis zum DrÅcken von Return, andere beenden schon  bei  der  Eingabe
eines  Leerzeichen  oder  lesen  zwar  auf  einmal  eine  ganze  Zeile  ein,  die
folgenden  ReadString-Aufrufe  liefern  aber  immer  nur  Wort-Fragmente,  die
durch eingegebene Leerzeichen getrennt sind.

Wir haben deshalb jeweils zwei Funktionen in Terminal und TextWindows dafÅr
vorgesehen.  Da  diese  Module  als  wÑhlbare  Ein-/Ausgabetreiber  fÅr  InOut
verwendbar sind und durch die Konfigurationsmodule GEMIO und TOSIO, die
wir im Quelltext mitliefern, beliebig an InOut adaptierbar sind, brauchen sie
selbst nur zwei Grundfunktionen zu bieten:

* ReadFromLine liest eine Zeile mitsamt aller Control-Codes; bei Dateien wird
  gelesen,  bis  das  Zeilenende  erreicht  oder  der  String  gefÅllt  ist,  bei
  interaktiver Eingabe kann so lange korrigiert werden,  bis  sie  mit  Return
  abgeschlossen wird. Es gibt hier auch noch die  Funktion  ReadString,  die
  lediglich noch vorhanden ist, damit Megamax-Programme, die fÅr die alte
  System-Version  Eins,  in  der  es  noch  kein  ReadFromLine  gab,  ohne
  énderungen  weiterhin  Åbersetzbar  bleiben.  ReadString  sollte  hier  aber
  Åberhaupt  nicht  mehr  verwendet  werden,  sondern,  je  nach  Bedarf,
  ReadToken oder ReadFromLine (Normallfall).

* ReadToken ermîglicht lediglich die Eingabe eines Wortes - sobald ein Leer-
  oder Control-Zeichen (also auch Return) eingegeben wird, kehrt ReadToken
  zurÅck.

InOut greift nun Åber ein Treibermodul (z.B. GEMIO, TOSIO, GEMDOSIO) auf
diese Funktionen zu. Dazu bietet es ebenfalls die Funktionen  ReadFromLine,
ReadToken  und  ReadString:  Wie  sich  diese  Funktionen  verhalten,  wird  im
Treibermodul bestimmt. So ist es  mîglich,  ReadString  entweder  direkt  auf
ReadToken oder ReadFromLine abzubilden, oder  mit  Hilfe  von  ReadFromLine
eine gepufferte Eingabe zu realisieren, die auch bei Read-Aufrufen aus der
gepufferten Zeile liest. Das soll Sie aber nicht verwirren, deshalb sparen wir
uns nun weitere ErklÑrungen - verstehen Sie es einfach  so:  Benutzen  Sie
mîglichst nur ReadFromLine/ReadToken (egal, ob aus Terminal, TextWindows
oder InOut importiert) - wenn Sie einmal mit dem öbertragen eines Modula-
Programms von oder zu einem anderen System konfrontiert werden, werden
Sie  diese  Unterschiede  erkennen  und  dann  auch  durchschauen,  welche
énderungen Sie an den Treibermodulen vornehmen mÅssen.

Wie schon erwÑhnt, sind also ggf. die Treiber GEMIO oder TOSIO fÅr die
Konfiguration  der   InOut-Funktionen   verantwortlich:   Die   unterschiedlichen
Konfigurationen mÅssen durch abgewandelte Versionen der Module GEMIO und
TOSIO erstellt werden. So kînnte man ein JPI IO erstellen, um die TopSpeed-
                                                _
IO-Module nachzubilden, eine  HM2 IO  fÅr  HÑnisch-Modula-Programme  usw.
                                     _
Solch ein Modul muû dann als erstes Modul im Hauptprogramm - also vor
5.1 Bibliothek: Allgemeines                                                5 - 10
________________________________________________________


InOut - importiert werden. Dies wird Åbrigens auch empfohlen, wenn Sie bei
normalen Megamax-Programmen, die InOut verwenden, die Ausgaben nicht in
ein Fenster bekommen wollen: Schreiben Sie einfach

  IMPORT TOSIO; (*$E MOS *)

vor den InOut-Import. Dann wird erstens das TOSIO-Modul, wie beim Linken,
als InOut-Treiber verwendet, zweitens wird die Endung MOS erzeugt, was fÅr
einen TOS-Bildschirm (Textcursor, keine Maus) beim Starten sorgt.

Bereits  in  Planung  ist  ein  komfortableres  Konzept  fÅr  die  nÑchste  Shell-
Version: Dann kînnen Sie fÅr jedes Modul individuell die Umgebung dauerhaft
bestimmen, also seine Stack-Grîûe, die einzubindenden Treiber (sowohl fÅr's
Starten  mit  Load-Time-Linking  als  auch  beim  festen  Linken)  und  andere
nÅtzliche Konfigurationen, die von auûen bestimmbar sein sollten.

Wenn Sie Åbrigens eigene Konfigurations- oder InOut-Treibermodule (z.B. fÅr
andere Modula-Systeme) erstellt haben, senden Sie sie doch im Rahmen des
MEMOX-Service (s. Kapitel 1.5) an Application Systems! Damit helfen Sie nicht
nur  den  anderen  Megamax-Anwendern  (auch  uns,  damit  wir  uns  anderen
Dingen widmen kînnen, bei denen Sie uns nicht helfen kînnten), sondern Sie
erhalten dafÅr ja auch BeitrÑge anderer Anwender.


Hinweise zu den Quelltexten

Um Ihnen als Anwender die Mîglichkeit zu geben, den Dialog mit dem Modula-
System  nach  Ihren  WÅnschen  optimal  zu  gestalten,  haben  wir  die  dafÅr
zustÑndigen Module im Sourcetext mitgeliefert.  Die  interessantesten  Module
sind  im  folgenden  aufgefÅhrt,  es  lohnt  sich  aber  auch,  sich  die  anderen
Sourcetexte (siehe UTILITY-, DEMO- und MOS-Ordner) einmal anzusehen.


MM2SHELL.M

Dies ist die Modula-2 Shell, das Desktop des Modula-Systems. Sie kînnen
sie beliebig verÑndern und erweitern. Auûerdem lassen sich darin viele Bei~
spiele fÅr Programmieranwendungen finden, z. B. Zugriff auf GEM-Funktionen,
Aufruf von Programmen oder Dateizugriffe. Dazu gehîren auch die  Dateien
MM2SHELL.RSC und MM2SHELL.RSD, die mit Hilfe des Resource Construction
Programms  (RCP)  verÑndert  werden  kînnen.  Beachten  Sie,  daû  nach  dem
éndern der Resource  mit  dem  RCP  beim  neuen  Abspeichern  zwei  Dateien
MM2SHELL.D  und  MM2SHELL.I  erzeugt  werden,  die  die  Konstanten  der
GEM-Objekte enthalten und von der Shell importiert werden. Allerdings mÅssen
die  Modulnamen  in  den  beiden  Quelltexten  dazu  erst  von  Mm2shell  in
Mm2shellRsc umbenannt werden!
5.1 Bibliothek: Allgemeines                                                5 -  11
________________________________________________________


GEMError.I & SimpleError.I

Diese Module werden bei Bedarf beim Linken von Programmen als Treiber mit
eingebunden. Sie sorgen fÅr das Abfangen und Anzeigen aller Laufzeitfehler.
Zudem enthalten sie die  Texte  fÅr  Systemmeldungen,  die  nach  Belieben  in
Englisch oder auch Esperanto Åbersetzt werden kînnen.


MOSConfig.I

Hierin sind  globale  Variable  enthalten,  die  von  verschiedenen  MOS-Modulen
verwendet  werden.  Im  Sourcetext  kînnen  die  Voreinstellungen  nach  Ihren
Preferenzen  verÑndert  werden,  z.  B.  Datumsformat  (fÅr  Funktionen  aus
TimeConvert) oder Zahlendarstellungsformate (fÅr REAL-Darstellungen).


Bedienung der Ein-/Ausgabefunktionen

Viele Funktionen der Megamax-Bibliothek bieten auch in der Benutzung Åber~
durchschnittlichen Komfort, verglichen mit anderen Entwicklungssystemen auf
Microcomputern.

Besonders offensichtlich  ist  das  beispielsweise  bei  Verwendung  des  InOut-
Moduls durch das StdIO-Fenster, in dem die Ausgaben geschehen. Wartet das
Programm auf eine Eingabe, macht es dauernd Ausgaben oder benutzt andere
GEM-Funktionen, so daû die Event-Abfrage vom GEM regelmÑûig aktiviert wird
(beispielsweise  ist  dies  auch  durch  regelmÑûige  Aufrufe  der  Prozedur
FlushEvents aus dem Modul  EventHandler  zu  erreichen).  Das  Fenster  kann
bewegt, in seiner Grîûe verÑndert und der Ausschnitt mit der Maus bestimmt
werden.

Weniger offensichtlich sind da schon die Editiermîglichkeiten bei Benutzung der
Funktionen ReadString, ReadFromLine und ReadToken. Nicht nur, daû mit der
Taste Backspace Korrekturen mîglich sind, auch viele andere Tasten haben
eine Funktion:

    Return                Beendet Eingabe
    Enter                 Wie Return
    Undo                 Bricht Eingabe ab (liefert Leerstring)
    <
     -                    Cursor nach links
     >
    -                     Cursor nach rechts
             <
    Control  -            Zum Zeilenbeginn
              >
    Control -             Zum Zeilenende
    Insert                Ein Leerzeichen an Cursorposition einfÅgen
    Backspace            Zeichen vor Cursor lîschen
    Delete                Zeichen unter Cursor lîschen
    Esc                   Zeile lîschen
    Clr (Shift-Home)     Wie Esc
    Home                 Zeile ab Cursor lîschen
5.1 Bibliothek: Allgemeines                                                5 - 12
________________________________________________________


Ein weiteres Geheimnis, das nur diejenigen bisher erkannten, die die Doku~
mentation zu den Funktionen in Convert aufmerksam gelesen haben, wollen wir
nun lÅften:

Die Convert-Funktionen zum Umwandeln von Zeichenfolgen in Zahlen erlauben,
daû  die  Werte  mit  einem  "$"-  oder  "%"-Zeichen  angefÅhrt  werden.  Dies
bewirkt dann eine Interpretation des Wertes als hexadezimale bzw. als binÑre
Zahl.  Da  alle  Funktionen  des  Megamax-Systems,  die  Texte  in  irgendeiner
Weise in Zahlen umwandeln, letztlich auf dieses Convert-Modul zurÅckgreifen
(wozu haben wir uns schlieûlich fÅr Modula-2 entschieden?!), kînnen Sie also
auch bei einem ReadCard-Aufruf statt "21" nun "$15" oder gar "%100000101"
eingeben!


Diverse Hinweise zu den Bibliotheken

GEMDOSIO- und TOSIO-Ausgabe

Geschehen die Ein-/Ausgaben Åber das Modul InOut, kann bekanntlich beim
Linken durch die Linker-Optionen bestimmt  werden,  ob  GEMDOSIO,  TOSIO
oder GEMIO verwendet werden  soll.  Bei  Modulen,  die  mit  Loadtime-Linking
unter der Shell gestartet werden, ist diese Wahl nicht so einfach mîglich.
Normalerweise  wird  die  Konfiguration  verwendet,  mit  der  die  Shell  gelinkt
wurde:  mit  GEMIO.  Der  GEMDOS-  oder  TOSIO-Treiber  kann  dennoch
verwendet werden: Schreiben Sie folgendes in eine Zeile vor dem InOut-Import
im betreffenden Programm:
  IMPORT TOSIO; (*$E MOS *) (bzw. GEMDOSIO statt TOSIO)
Damit  wird  beim  Starten  des  Programms  automatisch  der  TOS-Modus
aktiviert.  Zu  beachten  ist  jedoch,  daû  beim  Linken  der  Import  aus  dem
Programm  wieder  entfernt  werden  muû,  wenn  dort  ein  anderes  IO-Modul
eingelinkt werden soll.

Speicheranforderung mit ALLOCATE (Storage-Modul)

Dem  kommenden  ISO-Standard  fÅr  Modula  nach  wird  ALLOCATE  keinen
Laufzeitfehler auslîsen, wenn kein Speicher mehr verfÅgbar ist, sondern den
Zeiger mit NIL beschreiben.

Zweitens  dÅrfen  Sie  nie  davon  ausgehen,  daû  der  angeforderte  Speicher
gelîscht, d.h. mit Null-Bytes gefÅllt, ist. Beachten Sie auch, daû die globalen
Variablen bei Megamax Modula-2 zwar mit Null-Werten vorbesetzt  werden,
nach  PIM  und  dem  ISO-Standard  dies  aber  nicht  gefordert  ist,  Sie  bei
Portierung Ihrer Module demnach damit rechnen mÅssen, daû dies auf einem
anderen Compiler/Rechner auch nicht der Fall ist.
5.1 Bibliothek: Allgemeines                                                5 - 13
________________________________________________________


Verwendung von AES- und VDI-Funktionen (Maus-Funktionen und FormAlert)

Sie sollten bei GEM-Programmen darauf achten, niemals auf VDI-Funktionen
zurÅckzugreifen, wenn entsprechende Funktionen im AES vorhanden sind. Denn
dort, wo das AES eigene Funktionen auf das VDI "aufsetzt", hat letztendlich
auch  das  AES  die  Kontrolle,  und  Sie  kînnen  unliebsame  Seiteneffekte
hervorrufen, wenn Sie das AES durch direktes Anwenden des VDI umgehen.

Beliebtes Beispiel ist die Kontrolle der Maus: Es gibt die VDIInput-Prozeduren
ShowMouse  und  HideMouse  sowie  GrafMouse  in  AESGraphics.  Hier  hat
demnach das AES Vorrang. Wird ein Programm vom Desktop gestartet, wird
die Maus Åber GrafMouse eingeschaltet. Wenn Sie nun in Ihrem Programm die
Maus mit HideMouse abschalten, verschwindet sie zwar, das AES erfÑhrt aber
nichts davon, denkt also, sie sei noch sichtbar. Kommt nun eine AES-Funktion
zum Zuge, die die Maus einschalten will, beispielsweise GrafMouse oder auch
FormAlert  (diese  Funktion  versucht  selbststÑndig,  die  die  Maus  immer
einzuschalten), geht das AES davon aus, die Maus sei sichtbar und teilt dem
VDI deshalb auch nicht mit, die wirklich einzuschalten. Der Effekt: Die Maus
ist nicht zu sehen. Fazit: Lassen Sie die Finger von Show- und HideMouse!

Der richtige Gebrauch der UpdateWindow-Funktion...

    ... bei der Accessory-Initialisierung

Bei der Programmierung eines jeden Accessories sollten Sie folgende Regel
beachten: Zuerst der Aufruf von InitGem, danach RegisterAccessory und - dies
ist  besonders  wichtig  -  UpdateWindow  (TRUE).  Erst  dann  dÅrfen  eine
GEM-Resource-Datei nachgeladen, Speicher angefordert und andere Betriebs~
systemressourcen "geîffnet"  werden.  Am  Ende  der  Initialisierung,  also  vor
dem Event-Aufruf, muû  dann  noch  der  Aufruf  von  UpdateWindow  (FALSE)
nachgeholt  werden!  Siehe  dazu  beispielsweise  das  Demo-Programm  Timer
(UTILITY-Ordner).

Wird  das  nicht  beachtet,  kînnen  u.U.  schon  wÑhrend  der  Initialisierung
Task-Wechsel zu anderen Accessories und insbesondere ein GEM-Programm
per Autostart-Option gestartet werden und so dann die im  Kapitel  zu  den
Sys-Funktionen beschriebenen Fehler auftreten. (Ein ausfÅhrlicher Artikel dazu
findet sich im ST-Magazin 11/90 auf Seite 68. Ein Dank an Laurenz PrÅûner,
der darin diese GEM-"Macke" aufgedeckt hat!)

    ... bei Timer-Events mit GEMDOS-Aufrufen

Bekanntlich ist UpdateWindow dann zu benutzen, wenn Sie Manipulationen am
Bildschirm  vornehmen,  also  bei  Benutzung  bestimmter  AES-  und  VDI-
Funktionen.  Ansonsten,  z.B.  bei  GEMDOS-  und  BIOS-Funktionen,  wird  dies
allgemein nicht fÅr nîtig gehalten. Das ist aber leider falsch! Wenn nÑmlich
aus bestimmten GrÅnden dabei eine Alert-Box erscheint, kînnen Accessories,
5.1 Bibliothek: Allgemeines                                                5 - 14
________________________________________________________



die  auf  einen  Timer-Event  warten,  zum  Zuge  kommen.  Diese  wiederum
kînnten  einen  GEMDOS-Aufruf  tÑtigen.  Wenn  aber  gerade  die  Haupt~
anwendung selbst einen GEMDOS-Aufruf vornahm, ergibt das einen unerlaubten
Wiedereintritt ins GEMDOS, die Folge ist ein Absturz des Rechners.

Wie  kann  es  dazu  kommen?  Die  besagte  Alert-Box  erscheint,  wenn  eine
Funktion  aufgerufen  wird,  die  den  Critical  Error  Handler  aufruft,  weil
beispielsweise keine Disk im Laufwerk  steckt  oder  weil  sie  nicht  gelesen/
beschrieben werden kann. Die FormAlert-Routine des GEM verhindert in diesen
FÑllen aber  nicht,  daû  Timer-Events  ausgewertet  werden  und  so  kann  ein
Accessory zum Zuge kommen. Der eigentliche Fehler passiert aber erst dann,
wenn  das  Accessory  einen  Wiedereintritt  ins  GEMDOS  vornimmt.  Dies  ist
praktisch immer der Fall, wenn der Critical Error Handler aktiviert wurde, weil
dann ja meist gerade ein Diskzugriff Åber die GEMDOS-Funktionen erfolgt.

Was  ist  also  zu  tun?  Wenn  Sie  Timer-Events  behandeln,  mÅssen  Sie
wÑhrenddessen   auch   alle   evtl.   vorkommenden   GEMDOS-Aufrufe   durch
UpdateWindow einklammern! Da Sie bei Verwendung der Modula-Bibliotheks~
funktionen sich dessen u.U. nicht sicher sein kînnen, klammern Sie am besten
die ganze Timer-Event-Behandlung entsprechend ein.

Sie kînnen den Fehler Åbrigens leicht probeweise hervorrufen: Nehmen Sie das
Timer-Accessory (UTILITY-Ornder) und entfernen Sie aus der Event-Schleife,
in der die Zeit neu ausgegeben wird, die UpdateWindow-Aufrufe. Installieren
Sie dann das Accessory, wie dort angegeben. Wenn Sie nun einen Diskfehler
erzeugen, indem Sie z.B. Laufwerk A: ohne eine Disk darin îffnen, werden Sie
eine Alert-Box erhalten  und  die  Uhr  wird  wÑhrenddessen  weiterlaufen.  Bei
BestÑtigung  der  Alert-Box  erhalten  Sie  dann  einen  Systemabsturz  (das
Timer-Modul ruft Åber das Clock-Modul indirekt eine GEMDOS-Funktion auf,
die die aktuelle Zeit ermittelt).

Die FPU und Accessories

Die Entwickler von Atari empfehlen, die FPU in Accessories nicht zu benutzen.
Der Grund dafÅr liegt darin, daû im TOS keine Funktionen vorgesehen sind, die
das  Benutzen  der  FPU  von  mehreren  GEM-Tasks  (Hauptprogramm  und
Accessories)  regelt.  Wenn  beispielsweise  die  Register  der  FPUmit  Werten
belegt sind, und dann ein anderes Accessory zum Zuge kÑme und auch die
FPU benutzt, wÅrde sie wahrscheinlich die Register-Werte Åberschreiben. So
denkt Atari.

Wir  haben  zur  Lîsung  das  Modul  FPUSupport  geschaffen.  Das  bietet
Funktionen  zum  Retten  und  Restaurieren  des  gesamten  FPU-Status  incl.
Register und sonstiger Einstellungen (z.B. Rundungsmodus). Wollen Sie also in
einem Accessory die FPU benutzen, sehen Sie sich dieses  Modul  an.  Dort
finden Sie die weiteren Hinweise.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 15
________________________________________________________


5.2  Programme,  Module  und  Prozesse


Das Modulkonzept

Als Programme werden im Folgenden alle die Dateien bezeichnet, die z.B. vom
Desktop aus direkt ausgefÅhrt werden kînnen. Als Module werden die vom
Modula-2 Compiler erzeugten Code-Dateien bezeichnet.

Auch Compiler fÅr andere Sprachen erzeugen in der Regel nicht sofort aus~
fÅhrbare Dateien.  Statt  dessen  mÅssen  diese  Dateien  mit  weiteren,  schon
compilierten Dateien (die die "importierten" Funktionen und Variablen enthal~
ten),  zusammengelinkt  (gebunden)  werden.  Das  TOS  (Betriebssystem  des
Atari)  bietet  nun  eine  Funktion,  mit  der  solche  Programme  geladen  und
gestartet werden kînnen. Diese wird z.B. aktiviert, wenn man eine Programm~
datei auf dem Desktop doppelt anklickt. Aber auch ein gestartetes Programm
kann wiederum ein weiteres aufrufen.

Im MOS (Modula-2 Betriebssystem) gibt es eine Funktion, die in der gleichen
Weise  Module  zum  AusfÅhren  laden  kann.  Das  Dazuladen  und  Linken  der
importierten Module wird dabei automatisch  erledigt.  Dabei  werden  nur  die
importierten Module nachgeladen, die sich noch nicht im  Speicher  befinden.
Schon  vorhandene  Module  werden  ganz  einfach  von  den  neuen  Modulen
mitbenutzt.

Damit man die Ladefunktion des MOS  Åberhaupt  benutzen  kann,  muû  erst
einmal  ein  Programm  gestartet  werden,  das  diese  Funktion  enthÑlt.  Die
Funktion kann sich nur in  einem  Programm  der  herkîmmlich  gelinkten  Art
befinden, und das Programm muû Åber die TOS-AusfÅhrungsfunktion gestartet
werden. Ein solches Programm besteht aus mehreren Modulen, die dann aber
alle schon als vorhanden registriert werden, so daû, wenn dann ein anderes
Modul  gestartet  werden  soll,  die  im  Programm  vorhandenen  Module  mit~
verwendet werden kînnen (shared code).

Praktisch sieht das also z.B. so aus: Man hat ein Hauptprogramm H1, das die
Module U1, U2 und U3 importiert. Dieses Programm soll vom normalen Desktop
aus gestartet werden kînnen. Dazu wird es mit dem Linker gebunden.

Wenn das gelinkte Programm dann durch Doppelklick gestartet wird, befinden
sich die Module H1, U1 U2 und U3 im Speicher. Enthalte U1 nun die MOS-
Funktion zum Starten weiterer Module. Dann kann z.B. in H1 programmiert
worden sein, ein Modul H2 nachzustarten. H2 importiert auûerdem U2 und U4.
Wenn es nun  Åber  die  MOS-AusfÅhrungsfunktion  gestartet  wird,  wird  das
Modul U4 nachgeladen. Die importierten Prozeduren aus U2 werden aus dem
schon vorhandenen Modul mitverwendet, lediglich die Variablen werden bei U2
ein weiteres Mal angelegt.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 16
________________________________________________________


Wenn man das gleiche unter TOS anstellen wollte, nÑmlich, daû ein Programm
ein zweites nachstartet, mÅûten beide Programme mit jeweils allen benîtigten
Modulen gelinkt sein, was bedeuten wÅrde, daû das erste Programm aus H1,
U1, U2 und U3 bestÅnde und das Nachgeladene aus H2, U2 und U4. Somit
wÅrde ein Modul zwangslÑufig doppelt im Speicher vorliegen, was unnîtigen
Speicherplatz verbrÑuchte.

Das  automatische  Linken  beim  AusfÅhren  macht  sich  besonders  bei  der
mitgelieferten Modula-Shell positiv bemerkbar. WÑhrend die Shell durch viele
importierte  Module  ziemlich  viel  Speicher  belegt,  belegen  viele  Modula-
Programme,  die  von  der  Shell  aus  gestartet  werden,  kaum  zusÑtzlichen
Speicher,  da  meistens  schon  alle  benîtigten  Module  von  der  Shell  zur
VerfÅgung gestellt werden kînnen.

Ein weiterer Vorteil liegt darin, daû durch gemeinsame Benutzung von Variablen
mehrere nacheinander gestarteten Module Daten Åbermitteln kînnen. Z.B. wird
das Modul ShellMsg von der Shell und dem Compiler importiert. Dadurch kann
der Compiler, bevor er  endet,  in  den  dort  deklarierten  Variablen  z.B.  den
Namen der erzeugten Codedatei oder bei einem Fehler den Fehlertext ablegen,
und die Shell kann diese Daten dann weiterverwenden. Diese Option (shared
data) muû allerdings erst Åber eine besondere Compiler-Direktive ($Y, s. Kap.
3.4) angewÑhlt werden.


Vom Modul zum gelinkten Programm

Die gesamten MOS-Funktionen wurden so konzipiert, daû ein Programm erst
als Modul unter der Modula-Shell getestet werden kann und am Ende, falls
dies  vonnîten  ist,  mîglichst  ohne  énderungen  mit  all  seinen  importierten
Modulen zu einem Programm zusammengelinkt werden kann, das dann  vom
Desktop aus gestartet werden kann. In wenigen FÑllen muû jedoch eine Anpas~
sung des zu linkenden Programms durchgefÅhrt werden.

Wenn  das  von  der  Shell  gestartete  Modul  mit  SetChain  einen  Nachfolger
bestimmt, kann dies nicht mehr geschehen, wenn das diese Funktion aufrufen~
de Modul gelinkt ist und Åbers TOS gestartet wird. Denn das Nachladen des
Folgeprogramms kann nur vom Aufrufer erledigt werden, und das  TOS  als
Aufrufer lÑût dies nicht  zu.  Solange  das  Modul  von  der  Shell  mittels  der
Loader-Funktion CallModule gestartet wird, kann diese Funktion nach Ende des
ersten Moduls das nÑchste nachstarten. Wenn Sie nun also  ein  Programm
geschrieben haben, das aus mehreren, sich abwechselnd nachladenden Modulen
besteht, sollten die Module nie gelinkt werden. Statt dessen sollten Sie ein
Hilfsmodul erstellen, das gelinkt wird und vom Desktop gestartet werden kann.
Es importiert lediglich die Funktion CallModule und startet  damit  das  erste
Modul. Dieses Modul kann dann wiederum andere mittels SetChain nachstarten,
da ja bei Modulende immer zum Hilfsprogramm zurÅckgekehrt wird.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 17
________________________________________________________


Allerdings kann auch die Funktion ShellWrite (Modul AESMisc) benutzt werden,
um vom Desktop gestartete Programme - Ñhnlich SetChain - zu verketten.

Ein  Fehler,  der  hÑufiger  vorkommt,  entsteht  nur  bei  optimiertem  Linken:
WÑhrend  der  Loader  jedes  importierte  Modul  vollstÑndig  einbindet  und
initialisiert, kann der optimierende Linker Module ganz entfernen, obwohl sie
importiert  werden.  Dies  passiert  beispielsweise,  wenn   sie   ein   Modul
importieren, ohne Prozeduren oder Variablen daraus zu benutzen. Initialisiert
das  Modul  in  seinem  Kîrper  Daten  importierter  Module,  wÅrden  diese
Anweisungen beim optimierten Linken verschwinden.

Dieser Effekt kann leicht daran erkannt werden, daû beim Linken solch ein
Modul erst im Fenster angezeigt, dann aber wieder gelîscht wird. In diesem
Fall braucht das Modul lediglich mit der Direktive B+ Åbersetzt werden, am
besten, indem gleich zu Beginn des Moduls (*$B+*) eingefÅgt wird.

Zur  Sicherheit  kann  auch  erstmal  das  Programm  nicht-optimiert  gelinkt
oder generell  durch  Eintragen  von  -B  in  der  Compiler-Direktiven-Zeile  der
Shell jedes Ihrer Module entsprechend Åbersetzt werden.

Wenn Sie diese SonderfÑlle berÅcksichtigen, ist ein Modul, das unter der Shell
lief, auch als "eigenstÑndiges" Programm lauffÑhig. Es stellt sich jedoch die
Frage,  was  passieren  soll,  wenn  wider  Erwarten  doch  noch  Fehler  im
Programm  auftreten.  Unter  der  Shell  werden  automatisch  Fehleranzeigen
ausgelîst. Die Funktionen sind dazu  von  der  Shell  installiert  worden.  Auch
solche Funktionen mÅssen beim Linken extra eingebunden werden. Es gibt hier
einmal die Mîglichkeit, das Modul GEMError einzubinden, das auch von der
Shell zur Fehlerbehandlung importiert wird. Wem das zuviel ist, der kann die
abgespeckte  Version  SimpleError  verwenden  oder  einen  der  mitgelieferten
Quelltexte modifizieren: Wenn die Variablen von FileBase unverÑndert bleiben,
werden  Dateien  bei   Programmende   immer   ohne   Meldung   automatisch
geschlossen, Fehler immer ignoriert, und die Files-Funktion GetStateMsg liefert
immer einfach eine Fehlernummer statt des passenden Textes. Also kann man,
falls man sich seines Dateiumgangs sicher ist, die FileBase-Operationen aus
dem eigenen GEMError entfernen.

Bei  den  Laufzeitfehlern  sollte  man  zumindest  eine  einfache  Fehlermeldung
weiterhin vornehmen, denn wenn die Fehler nicht abgefangen werden, gibt es
hîchstens diese hÑûlichen Bomben, und das Programm terminiert sofort, ohne
daû man feststellen kann, was passiert ist.

öber die Laufzeitfehlerbehandlung  existiert  ein  ausfÅhrliches  Kapitel  zu  den
Modulen Excepts, ErrBase, HdlError und EasyExceptions.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 18
________________________________________________________


Ein Sonderfall ist die Verwendung des Moduls InOut. Unter der Shell werden
Ausgaben Åber dieses Modul in einem Window  dargestellt.  InOut  importiert
selbst nicht das dafÅr verwendete Modul TextWindows,  sondern  InOutBase.
Unter der Shell sind allerdings die TextWindows-Funktionen darauf zugewiesen.
Wenn ein Programm, das InOut benutzt, gelinkt wird, muû ein Konfigurations~
modul mit eingebunden werden, das diese Prozedurvariablen initialisiert. Dazu
stehen  wahlweise  GEMIO,  TOSIO  oder  GEMDOSIO  zur  VerfÅgung.  GEMIO
importiert TextWindows und weist dessen Funktionen auf die Prozedurvariablen
in InOutBase zu, eben wie dies auch in der Shell geschieht. TOSIO dagegen
verwendet statt dessen die Funktionen aus Terminal fÅr InOut und GEMDOSIO
verwendet das Console-Modul, sodaû auch Ein-Ausgabeumlenkung von auûen
mîglich ist, beispielsweise durch die Benutzung von Command-Line-Shells. Das
bewirkt,  daû  ein  Programm,  das  TOSIO  oder  GEMDOSIO  statt  GEMIO
eingebunden  hat,  die  Ausgaben  nicht  auf  ein  Window  tÑtigt,  sondern  den
gesamten Bildschirm dafÅr verwendet. In  diesem  Fall  sollten  keine  anderen
GEM-Funktionen verwendet und das gelinkte Programm mit der Endung ".TOS"
statt ".PRG" benannt werden.

Sie kînnen vor dem Linken eines Programm durch Aufruf der Linker-Optionen
bestimmen, ob Sie GEMIO, GEMDOSIO oder TOSIO einbinden wollen. Ersteres
ist in der Anwendung optisch sicher schîner, die anderen benîtigen wegen
sparsamerer Importe weniger Speicherplatz.

Wenn Sie in dem zu linkenden Programm InOut nicht verwenden, brauchen Sie
GEMIO, GEMDOSIO bzw. TOSIO auch nicht einzubinden. Wenn Sie vergessen,
eines der Module einzubinden, obwohl InOut benutzt wird, erhalten Sie, wenn
Sie das Programm dann starten,  eine  Fehlermeldung  mit  dem  Text  "InOut
driver is missing!".


Prozesse

Wenn ein Programm unter TOS gestartet wird (also z.B. vom Desktop aus),
richtet das TOS dafÅr einen Prozeû ein (Der Prozeûbegriff ist nicht mit den
Modula-2 Coroutinen zu verwechseln!). In der Praxis bedeutet dies, daû sich
das TOS merkt, daû ein neues Programm gestartet wurde und von nun an
bestimmte   Systemresourcen   (z.B.   Speicheranforderungen,   Dateizugriffe)
diesem  Prozeû/Programm  zugeordnet  werden.  Wenn  das  Programm/der
Prozeû  endet,  kînnen  alle  Systemresourcen  des  Programms  erkannt  und
notfalls freigegeben werden (z.B. belegter Speicher wieder freigegeben, offene
Dateien geschlossen).

GegenÅber  einem  einfachen  Unterprogramm  hat  ein  Prozeû  auûerdem  den
Vorteil, daû er sich zu (fast) jeder Zeit und an jeder Programmstelle beenden
kann und die AusfÅhrung dann immer hinter der Programmstelle fortgefÅhrt
wird, die den Prozeû gestartet hat (wie bei einem Unterprogrammaufruf).
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 19
________________________________________________________


Jeder  Prozeû  erhÑlt  eine  Basepage.  Dies  ist  ein  Speicherbereich  von  256
Bytes, in denen bestimmte Daten angelegt werden, die der Prozeû ganz privat
benîtigt (Ñhnlich dem Workspace bei Modula-Coroutinen). Darin wird z.B. eine
Textzeile abgelegt, die der Aufrufer Åbergeben hat (z.B. die Argumentzeile bei
".TTP"-Programmen) und die offenen Dateien registriert.

Wenn ein Programm / Prozeû endet, kann es dem Aufrufer eine Nachricht in
Form einer INTEGER-Zahl (-32768 bis 32767) liefern. Es ist sinnvoll, negative
Werte zu liefern, wenn ein Fehler im aufgerufenen Programm auftrat, und Null,
wenn nichts Besonderes zu melden ist.

Im MOS (Modula Operating System) gibt es zwei Mîglichkeiten, einen Prozeû
zu starten. Entweder man startet ein Programm oder Modul mit der Funktion
CallModule aus dem Modul Loader oder man startet ein Unterprogramm als
Prozeû mit CallProcess aus ModCtrl. Solch ein Prozeû kann dann auf zwei
Arten  zu  Ende  gefÅhrt  werden.  Entweder  lÑuft  das  Programm  bzw.  das
Unterprogramm  bis  zum  Ende  durch  oder  es  wird  auf  irgend  eine  Weise
TermProcess  aus  PrgCtrl  aufgerufen.  Bei  normaler  Beendigung  wird  als
Ergebnis des Prozesses eine Null Åber CallModule bzw. CallProcess geliefert,
bei  Aufruf  von  TermProcess  kann  ein  selbst  gewÑhlter  Ergebniswert  (die
INTEGER-Zahl) Åbergeben werden.

TermProcess wird z.B.  automatisch  ausgefÅhrt,  wenn  ein  Programm  durch
einen Laufzeitfehler unterbricht und bei der dann angezeigten Fehlermeldung
"Quit" oder "Abbruch" angewÑhlt wird. Als Ergebniswert wird dann an  den
CallModule-   bzw.   CallProcess-Aufrufer   die   Laufzeitfehlernummer   (s.
MOSGlobals) geliefert.

CallModule  kann  sowohl  normale  Programme  als  auch  die  vom  Compiler
erzeugten, ungelinkten Module starten. Wird  ein  Modula-2  Modul  gestartet,
werden alle importierten Module, die sich noch nicht im  Speicher  befinden,
nachgeladen.  Wenn  der  Prozeû  endet,  werden  alle  nicht  mehr  benîtigten
Module  wieder  freigegeben,  d.h.,  daû  der  von  ihnen  belegte  Speicherplatz
wieder fÅr neue Daten frei wird.

Wenn man erreichen will, daû nicht bei jedem Programmaufruf mit CallModule
das Programm bzw. die Module erneut geladen werden, kann man sie mit der
Funktion LoadModule aus Loader einmal laden. Sie bleiben dann so lange im
Speicher, bis UnLoadModule aufgerufen wird oder das Programm endet, das
das Modul Loader importierte (z.B. die Shell).

Ein gestartetes Modul kann mit SetChain aus Loader selbst bestimmen, daû
nach dem eigenen Ablauf nicht zum Aufrufer zurÅckgekehrt sondern erstmal
ein anderes Programm gestartet wird. Dies Nachstarten kann aber nur von
ungelinkten Modulen aus geschehen - nach dem Ablauf eines eigenstÑndigen
Programms ist ja der Loader des MOS nicht mehr aktiv.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 20
________________________________________________________


Es gibt Anwendungen, bei denen es darauf ankommt,  ein  Programm  nach~
trÑglich und dauerhaft einzubinden. Dies kommt meist vor bei "Treibern" (z.B.
RAMdisk-Programme)  und  Monitoren  (Programme,  die  z.B.  Åber  andere
Prozesse  wachen).  Solche  Programme  installieren  Funktionen  auf  Vektoren
bzw. Prozedurvariablen,  die  von  dem  Programm,  in  das  sie  sich  einlinken,
exportiert werden. Im MOS gibt es viele Mîglichkeiten fÅr solche Programme,
z.B.  kînnen  Åber  die  Treibervariablen  in  FileBase  oder  TermBase  andere
Ein-/Ausgabefunktionen   eingebunden   oder   kurzzeitig   Konfigurationen   in
MOSConfig geÑndert werden.

Beispielsweise  soll  erreicht  werden,  daû  alle  Module,  die  der  Loader  lÑdt,
angezeigt  werden.  Dazu  exportiert  das  Modul  Loader  die  Prozedurvariable
Loading,  die  bei  jedem  Modulladen  aufgerufen  wird.  Es  gibt  nun  zwei
Mîglichkeiten. Entweder erweitert man die Shell um eine Funktion, die auf die
Loader-Variable  zugewiesen  wird  und  die  Ausgabe  der  geladenen  Module
durchfÅhrt. Will man aber sich die énderung in der Shell ersparen, muû man
ein kleines Programm erstellen, das dies Åbernimmt. Die Ausgabefunktion darf
aber nur so lange auf Loading zugewiesen sein, wie das Modul im Speicher
steht. Will man zurÅck in die Shell, um Module zu starten, damit die Funktion
sie  anzeigen  kann,  endet  aber  das  Programm  und  wird  wieder  aus  dem
Speicher entfernt.

Die Lîsung bietet die Funktion InstallModule aus ModCtrl. Sie bewirkt, daû das
Modul, das die Funktion aufruft, mitsamt seiner importierten Module resident
im Speicher bleibt, bis ModCtrl selbst aus dem Speicher verschwindet (also
wenn z.B. die Shell ablÑuft).

Wenn  also  das  Modul  vor  dem  Zuweisen  der  Loading-Variable  erst
InstallModule aufruft und dann der Prozeû beendet wird, bleibt die Ausgabe~
prozedur weiterhin aufrufbar.

Damit das Modul sich auch wieder freigeben und die Ausgabefunktion abmelden
kann, gibt es die Mîglichkeit, ein  solches  Modul  erneut  per  CallModule  zu
starten. Das Modul kann dann mit FirstModuleStart (aus ModCtrl) erfragen, ob
dies der erste Aufruf des Moduls ist, um so zu ermitteln, ob das Modul schon
resident  war.  Ist  dies  der  Fall,  gibt  es  sich  einfach  wieder  frei  (mit
ReleaseModule).
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 21
________________________________________________________


Hier das vollstÑndige Beispielprogramm:

    MODULE ShowMods;

    FROM  SYSTEM  IMPORT  ADDRESS,  ADR;  IMPORT  ModCtrl,  Loader,
       AESForms, Strings, MOSGlob;

    VAR workSpace: MemArea; oldLoading: Loader.LoadingProc;

    PROCEDURE  remove;
      BEGIN
        (* Wiederherstellen des alten Wertes: *)
        Loader.Loading:= oldLoading;
      END remove;

    PROCEDURE show ( modName, fileName: ARRAY OF CHAR;
                         codeAddr: ADDRESS; codeLen: LONGCARD;
                         varAddr: ADDRESS; varLen: LONGCARD );
      VAR s: Strings.String; ok: BOOLEAN; button: CARDINAL;
      BEGIN
        (* Hier wird jedes geladene Modul ausgegeben *)
        Strings.Concat (' 0  Lade ', fileName, s, ok);
        Strings.Append (s, '   OK  ', ok);
        AESForms.FormAlert (1, s, button);
          (* GEM ist bereits durch die Shell initialisiert *)
      END show;

    BEGIN
      IF ModCtrl.FirstModuleStart () THEN
        (* Beim 1.Start wird die Ausgabefunktion eingerichtet. *)
        workSpace.bottom:= NIL; (* der normale Stack reicht aus*)
        ModCtrl.InstallModule (remove, workSpace);
        oldLoading:= Loader.Loading; (* Retten des alten Wertes *)
        Loader.Loading:= show     (* Zuweisen der neuen Prozedur *)
      ELSE
        (* Beim wiederholten Start wird alles entfernt. *)
        remove;  (* Wiederherstellen des alten 'Loading'-Wertes *)
        ModCtrl.ReleaseModule
      END
    END ShowMods.


Im UTILITY-Ordner befindet sich ein entsprechendes Modul ModTrace.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 22
________________________________________________________


Modul- und Prozeûkontrolle

Es gibt Anwendungen, die nicht einfach ohne weiteres beendet werden dÅrfen,
sondern  bei  denen  Einstellungen,  die  wÑhrend  eines  Prozesses  verÑndert
wurden, wieder rÅckgÑngig gemacht werden mÅssen. Werden z.B. Interrupts
verwendet, dÅrfen die Interruptvektoren nach Prozeûende nicht "in die WÅste"
zeigen, weil sonst ein Systemabsturz mîglich wÑre. Da es mîglich ist, daû ein
Prozeû unbeabsichtigt, z.B. durch einen Fehler, beendet wird, kann mit der
Funktion CatchProcessTerm aus PrgCtrl eine Prozedur installiert werden, die
automatisch   bei   Beendigung   des   eigenen   Prozesses   aufgerufen   wird.
Genaugenommen wird die Prozedur dann ausgefÅhrt, wenn der Prozeû endet,
in  dem  der  CatchProcessTerm-Aufruf  erfolgte.  Werden  mehrere  solcher
Prozeduren wÑhrend eines Prozesses angemeldet, werden sie beim Prozeûende
in entgegengesetzter Anmeldungsreihenfolge aufgerufen (letztes zuerst).

Module wie Files oder Storage sorgen automatisch dafÅr, daû offen gebliebene
Dateien oder belegter Speicher freigegeben wird, wenn der Prozeû beendet
wird, unter dem die Dateien geîffnet oder der Speicher angefordert wurde.
Damit  solche  Funktionen  Åber  Beginn  und  Ende  eines  Prozesses  Bescheid
wissen, gibt es im Modul PrgCtrl die Funktion SetEnvelope zur Anmeldung einer
Prozedur, die bei Prozeûbeginn und -ende aufgerufen wird.

Im  Files-Modul  wird  beispielsweise  eine  globale  Variable,  die  das  aktuelle
Prozeûlevel bestimmt, verwaltet. Sie wird mit Hilfe der SetEnvelope-Funktion
bei jedem Prozeûbeginn erhîht und bei jedem Prozeûende wieder verringert.
Die Files.Open-Funktion merkt sich nun fÅr jede geîffnete Datei den Wert des
Prozeûlevels. Bei Prozeûende wird, bevor das Prozeûlevel heruntergesetzt wird,
erst  jede  offene  Datei  geschlossen,  die  unter  dem  gerade  zu  beendenden
Prozeûlevel erîffnet wurde.

Werden  Module  erstellt,  die  Resourcen  (z.B.  Listen,  Speicher,  Dateien)
verwalten kînnen oder selber Resourcen anlegen oder globale Vektoren (z.B.
Interrupts  oder  TRAPs)  oder  andere  globale  Einstellungen  vornehmen,  und
sollen diese Module auch in Programmen verwendet werden kînnen, die sich
speicher-resident  machen  (mit   InstallModule),   darf   zum   automatischen
Schlieûen bei Programmende nicht CatchProcessTerm, sondern CatchRemoval
aus  SysCtrl  verwendet  werden!  Siehe  dazu  auch  die  Definitionstexte  von
PrgCtrl,  SysCtrl,  ResourceHandler  sowie  das  Demo-Modul  SysLibDemo  im
DEMO-Ordner.
5.2 Bibliothek: Programme, Module und Prozesse                         5 - 23
________________________________________________________


Programm- und Prozeûinformationen, Base Page und Argumentzeile

Um zu erfahren, welche Module bei einem  Programmstart  geladen  werden,
wurde bereits die Verwendung der Funktion Loading weiter oben beschrieben.
Um die Informationen Åber die augenblicklich geladenen Module zu erhalten,
gibt es in ModCtrl die Funktion ModQuery. Ihr wird eine Prozedur Åbergeben,
die wiederholt mit den Informationen Åber alle im Speicher befindlichen Module
aufgerufen  wird.  Ein  Beispielprogramm  namens  ModList  befindet  sich  im
DEMO-Ordner.

Wenn man mit einem Debugger oder Maschinensprachemonitor von CallModule
gestartete  Prozesse  tracen  (schrittweise  verfolgen)  mîchte,  kann  man  die
Loader-Variable Monitor auf eine Prozedur zuweisen, die das Monitorprogramm
oder den Debugger aktiviert. Die Monitor-Prozedur wird immer direkt vor dem
Aufruf des von CallModule zu startenden Moduls ausgefÅhrt. Die Behandlung
der Monitor-Variablen kann in derselben Weise wie bei dem Beispielprogramm
fÅr die Loading-Variable (s.o.) geschehen. Ein Beispielprogramm Monitor wird
mitgeliefert (UTILITY-Ordner).

Den Zeiger auf die Basepage jedes Prozesses erhÑlt man mit der Funktion
GetBasePageAddr aus PrgCtrl. FÅr den Normalanwender ist daraus  nur  die
Argumentzeile interessant, die bei CallModule angegeben oder beim Start eines
Programms von der Shell bestimmt werden kann. FÅr den Zugriff darauf bietet
sich jedoch besser das Modul ArgCV an. Der Aufruf der dortigen Prozedur
InitArgCV  lîst  die  Argumentzeile  gleich  in  einzelne  Argumente  auf,  und
ArgCVIO erlaubt es zusÑtzlich, die Ein-/Ausgaben Åber InOut umzuleiten, falls
das Programm als TTP-Anwendung vom Desktop gestartet werden soll: Um
z.B. die Eingabe von  der  Datei  "BATCH.TXT"  zu  ermîglichen,  kann  in  der
Argumentzeile "<BATCH.TXT" angegeben werden. FÅr Ausgabeumleitung kann
">" oder ">>" verwendet werden: ">" bestimmt eine neue Datei, wÑhrend ">>"
das AnfÅgen an eine bestehende Datei ermîglicht. Soll die Umlenkung auch
schon vom aufrufenden Programm (z.B. Command-Shell) mîglich sein, muû das
Console-Modul, z.B. durch den InOut-Treiber GEMDOSIO, verwendet werden.
Der Desktop (und z.Zt. auch die Megamax-Shell)  prÅfen  die  Argumentzeile
nicht auf Umlenkungsanweisungen und deshalb ist es hier  ggf.  erforderlich,
ArgCVIO zu verwenden.

Mit  Accessory  aus  PrgCtrl  kann  ermittelt  werden,  ob  ein  Programm  als
Accessory (mit Suffix ".ACC") gestartet wurde.

Das Modul MOSCtrl ist fÅr den Normalanwender tabu. Es stellt die grund~
legenden Funktionen und Daten fÅr die  MOS-Prozeûkontrolle  zur  VerfÅgung
und ist nur fÅr die MOS-internen Module bestimmt.
5.2 Bibliothek: Programme, Module und  Leerseiten                       5 - 24
________________________________________________________
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 25
________________________________________________________


5.3  Laufzeitfehler-Behandlung


Was sind Laufzeitfehler ?

Laufzeitfehler kînnen unter mehreren UmstÑnden eintreten. Z. B. kann eine
Variable einen ungÅltigen Wert erhalten, eine Division durch Null erfolgen oder
ein Pointerzugriff mit einem uninitialisierten Pointer durchgefÅhrt werden.

Nun ist es in den meisten FÑllen zu aufwendig, solchen Fehlern programm~
technisch zuvorzukommen. Man mÅûte z. B. vor jeder Berechnung mit Zahlen
prÅfen, ob die Ergebnisse nicht ungÅltig werden. Statt dessen kînnen solche
PrÅfungen automatisch vom Mikroprozessor und vom Code, den der Compiler
erzeugt, vorgenommen werden. Der Vorteil liegt darin, daû der Programmierer
sich nicht selbst um die vielfÑltigen PrÅfungen kÅmmern muû. Der Nachteil ist,
daû die vom Prozessor oder vom Spezialcode des Compilers erkannten Fehler
alle eine Standard-Fehlerbehandlung durchlaufen, anstatt individuell behandelt zu
werden.

Aus diesem Grund ist es nîtig, sich beim Programmieren Gedanken darÅber zu
machen, ob absehbar mîgliche Fehler vorher erkannt werden sollen, um darauf
dann direkt zu reagieren, oder ob es ausreicht, nach einer Berechnung etc. zu
erkennen, daû Åberhaupt ein Fehler aufgetreten war.

Dazu ein Beipiel. Folgende Berechnung sei durchzufÅhren:

  lîsung:= a * b + c DIV ( d * e );

Wenn  die  Variablen  a  bis  e  alle  mîglichen  Werte  annehmen  kînnen,  sind
mehrere Fehler mîglich:

  - Ein öberlauf tritt bei der Multiplikation von a * b auf.
  - Ein öberlauf tritt bei der Multiplikation von d * e auf.
  - Ein öberlauf tritt bei der Addition von d * e und c DIV d * e auf.
  - Eine Division durch Null tritt auf, weil d oder e Null ist.

Wenn es darauf ankommt, herauszufinden, welche Variable einen illegalen Wert
hat, muû dies in aufwendiger Weise vor der Berechnung geprÅft werden. Ist
dagegen  nur  wichtig,  zu  erfahren,  ob  Åberhaupt  ein  gÅltige  Lîsung  dabei
entsteht, reicht es aus, die automatische Fehlererkennung darÅber wachen zu
lassen.

Die  automatische  Fehlererkennung  liefert  lediglich  die  Information,  daû  ein
Fehler auftrat und was der Anlaû fÅr den Fehler war. FÅr das Beispiel oben
wird  im  Fehlerfalle  nur  Åbermittelt,  daû  entweder  ein  öberlauf  oder  eine
Division durch Null den Fehler auslîste.
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 26
________________________________________________________


Fehlergruppen

Laufzeitfehler kann man in vier Gruppen (Ursachen) aufteilen:

  - Exceptions: Dies sind Fehler, die der Mikroprozessor erkennt,  z.  B.  16
    Bit-Division durch Null oder Zugriff auf nicht vorhandenen Speicherbereich.
    Der  Prozessor  hat  dafÅr  an  festen  Systemadressen  Sprungvektoren
    vorgesehen, die in einem solchen Fehlerfalle angesprungen werden. Es ist
    nicht  mîglich,  die  Erkennung  der  Fehler  durch  den  Prozessor  zu
    unterbinden.

  - Soft-Fehler:  Dazu  zÑhlen  alle  Fehler,  die  durch  extra  programmierte
    Abfragen  erkannt  werden.  Solche  Abfragen  werden  z.B.  vom  Compiler
    erzeugt (wenn nicht die Option (*$R-*) eingestellt ist) und stehen auch in
    vielen  der  mitgelieferten  Library-Module.  Sie  werden  alle  Åber  eine
    erzwungene Exception-Auslîsung gemeldet.

  - Raise-Funktionen: Damit kînnen Sie selbst Fehlermeldungen auslîsen. Dies
    ist  z.  B.  sinnvoll,  wenn  Sie  ein  Modul  mit  mathematischen  Funktionen
    programmieren. Dann kînnen Sie selbst Fehlerabfragen durchfÅhren  und
    ggf. die Funktion RaiseError aus dem Modul ErrBase aufrufen, um einen
    normalen Laufzeitfehler zu simulieren.

  - Dateifehler: Das Dateisystem des MOS prÅft in vielen FÑllen nach, ob Sie
    einen vorher aufgetretenen Fehler, z. B. einen Lesefehler, erkannt haben.
    Ist dies nicht der Fall, wird eine Fehlermeldung ausgelîst.

Die ersten drei Gruppen kînnen, da sie alle gleichartige Fehler melden, von
einer einzigen Funktion behandelt werden. Sie werden im Folgenden "allgemeine
Laufzeitfehler" genannt. Die Dateifehler treten unter anderen UmstÑnden auf
und mÅssen auch anders behandelt werden.

DarÅber hinaus faût das Modul EasyExceptions alle diese Fehler zusammen und
ermîglicht auf eine hîheren Ebene eine  sehr  komfortable  Fehlerbehandlung.
Dazu mehr am Ende dieses Kapitels.
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 27
________________________________________________________


Allgemeine Laufzeitfehler

Die Fehler der ersten  beiden  Gruppen  (s.o.)  werden  auf  dem  selben  Weg
gemeldet: Åber Exceptions. Mit dem Modul Excepts kînnen diese und auch alle
anderen Exceptions abgefangen werden. (Tritt eine Exception auf, die nicht
abgefangen wird, blitzen nur kurz ein paar hÑûliche Bomben auf dem Atari-
Bildschirm auf.) Das Modul bietet die Funktion InstallExc, mit der eine Prozedur
angemeldet werden kann, die bei Eintritt einer der anzugebenden Exceptions
aufgerufen  wird.  Wird  bei  einer  Exception  die  Prozedur  dann  aufgerufen,
bekommt sie Werte aller Prozessorregister vor der Exception Åbergeben. Sie
kann dann entscheiden, ob sie selbst reagieren will. Wenn ja, kann sie z. B.
eine Fehlermeldung anzeigen. Danach kann sie die Prozessorregister Ñndern
und mit RETURN FALSE erreichen, daû die Prozessorregister zurÅckgeladen
werden und das unterbrochene Programm fortgefÅhrt wird. Wenn sie  nicht
reagieren will, kehrt sie mit RETURN TRUE zurÅck, und es wird vom Modul
Excepts  die  Prozedur  aufgerufen,  die  vor  dem  InstallExc-Aufruf  fÅr  die
Exception angemeldet war. Diese Prozedur kann dann genauso verfahren.

Mit der Prozedur RaiseExc aus Excepts kînnen Sie eine Exception an  der
Stelle simulieren, von der der Aufruf geschieht.

Wird das Modul ErrBase eingebunden, ruft es automatisch InstallExc auf und
fÑngt alle Exceptions, die von Modula-Programmen ausgelîst werden kînnen,
ab. Es exportiert eine Prozedurvariable, die bei einer solchen Exception oder
bei Aufruf der dortigen Funktion RaiseError aufgerufen wird. Von Anwender~
programmen sollte diese globale Variable aber in der Regel nicht verwendet
werden, um Fehler abzufangen.

Statt dessen gibt es  noch  ein  weiteres  Modul,  HdlError,  das  eine  interne
Prozedur auf die Prozedurvariable aus ErrBase zuweist. Dieses Modul bietet
nun die komfortablen Funktionen zum Abfangen und Behandeln der allgemeinen
Laufzeitfehler.

CatchErrors aus HdlError erlaubt es, Prozeduren anzumelden, die bei jedem
allg.  Laufzeitfehler  aufgerufen  werden.  Die  Prozedur  bekommt  bei  einem
Laufzeitfehler  die  Fehlernummer  (alle  Fehlernummern  sind  in  MOSGlobals
definiert  und  erklÑrt),  einen  optionalen  Text,  die  Prozessordaten  von  der
Exception, die Information, ob das Programm noch fortgefÅhrt werden kann,
und  die  Angabe,  ob  die  fehlerauslîsende  Routine  oder  ihr  Aufrufer  als
Verursacher  gilt.  Der  Text  kann  v.  A.  bei  RaiseError  als  zusÑtzliche
Information  neben  der  Fehlernummer  Åbergeben  werden.  Bei  vom  Compiler
erzeugten Fehlermeldungen oder bei Exceptions ist der Text immer leer. Wird
die Prozedur aufgerufen, hat sie in der Regel drei Mîglichkeiten:
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 28
________________________________________________________


  - Sie will den Fehler nicht speziell behandeln. Dann verlÑût sie die Funktion
    mit  RETURN  TRUE.  Waren  noch  weitere,  Ñltere  CatchErrors-Aufrufe
    erfolgt,  werden  nun  deren  angemeldete  Prozeduren  in  gleicher  Weise
    aufgerufen. Ist keine weitere 'call'-Funktion vorhanden, wird das Programm
    mit der Fehlernummer als "Exitcode" (siehe PrgCtrl.TermProcess) beendet.

  - Sie hat den Fehler behandelt und mîchte erreichen, daû das Programm
    hinter der Fehlerauslîsung fortfahren kann. Dazu muû sie die Funktion mit
    FALSE verlassen. Dies sollte in der Regel  nur  getan  werden,  wenn  es
    durch eines der Argumente, die der Prozedur Åbergeben wurden, erlaubt
    wird. Vorsicht: Bei Busfehlern und Adreûfehlern kann das Programm nicht
    ohne énderung der Prozessorregister fortfahren !

  - Der Fehler wurde erkannt, und das Programm soll abgebrochen werden.
    Dann ist TermProcess aus PrgCtrl aufzurufen.

Diese Wahlmîglichkeit hat nun riesige Vorteile. Stellen Sie sich vor, Sie haben
eine Prozedur, die eine Berechnung durchfÅhrt. Sie soll ein Ergebnis liefern,
das anzeigt,  ob  die  Berechnung  fehlerfrei  verlief.  Da  nun  damit  gerechnet
werden  muû,  daû  darin  ein  Laufzeitfehler  auftreten  kann,  wird  vor  der
Berechnung mit CatchErrors eine Hilfsfunktion installiert. Tritt danach irgendein
Fehler auf, wird die Funktion als erstes aufgerufen, und sie kann entscheiden,
ob der Fehler in der Berechnung entstanden oder ein ganz anderer Fehler ist.
Je nachdem setzt sie ein Fehlerflag und lÑût die Berechnung zu Ende laufen,
oder sie lÑût den auûerordentlichen Fehler von der zuvor installierten Fehler~
behandlung  bearbeiten  (dies  fÅhrt  dann  normalerweise  zum  Anzeigen  des
Fehlers von der Standard-Fehlerbehandlung der Shell/GEMError).
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 29
________________________________________________________


Hier ein Bespielprogramm:

    VAR fehlerAufgetreten: BOOLEAN;

    PROCEDURE fehler (     nummer       : INTEGER;
                                text         : ARRAY OF CHAR;
                                verursacher: ErrBase.ErrResp;
                                abbruch     : RtnCond,
                           VAR excDaten    : Excepts.ExcDesc ): BOOLEAN;
      BEGIN
        IF nummer = MOSGlob.DivByZero THEN
          fehlerAufgetreten:= TRUE;
          RETURN FALSE  (* -> Programm fortfÅhren *)
        ELSE
          RETURN TRUE   (* -> Fehlermeldung weiterleiten *)
        END
      END fehler;

    PROCEDURE modulo ( a,b: CARDINAL; VAR c: CARDINAL; VAR ok: BOOLEAN );
        (* Berechnet den Modulo-Wert v. 'a' und 'b' und liefert die *)
        (* Lîsung in 'c'. Bei einen Fehler ('b'=0) ist 'ok' FALSE,  *)
        (* sonst TRUE.                                                          *)
      VAR stack: ARRAY  1..1000  OF CARDINAL; (* 2 KB Stack reichen *)
           wsp: MOSGlob.MemArea;
      BEGIN
        fehlerAufgetreten:= FALSE;
        wsp.bottom:= ADR ( stack );
        wsp.length:= SIZE ( stack );
        CatchErrors ( fehler, wsp );       (* Fehlerroutine anmelden *)
        (* Jetzt kann gerechnet werden: *)
        c:= a - (a DIV b) * b;
        (* Das reicht. *)
        ReleaseCatcher ( fehler );         (* Fehlerroutine abmelden *)
        ok:= NOT fehlerAufgetreten
      END modulo;

In diesem Beispielprogramm wÑre es natÅrlich einfacher und schneller, b mit
Null  zu  vergleichen.  Erst  in  komplexeren  Berechnungen  lohnt  sich  das
Verfahren. Aber mathematische Berechnungen sind nicht das einzige, bei dem
Fehler in dieser Weise vorteilhaft abgefangen werden kînnen.
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 30
________________________________________________________


Wenn nach dem Erkennen des Laufzeitfehlers im obigen Beispiel die fehlerher~
vorrufende Routine nicht weiter ausgefÅhrt werden darf, sondern gleich aus
modulo zurÅckgekehrt werden soll, kann die Funktion so abgeÑndert werden,
daû die Berechnung selbst in einer Unterfunktion durchgefÅhrt und diese dann
mit CallProcess aus ModCtrl aufgerufen wird. In fehler muû dann TermProcess
mit einem Wert ungleich Null statt "RETURN FALSE" aufgerufen werden. Statt
Åber die globale Variable fehlerAufgetreten kann dann Åber den exitCode von
CallProcess ein aufgetretener Fehler erkannt werden.

Genauso bietet sich CatchErrors an, wenn einfach verhindert werden soll, daû
Laufzeitfehler  an  den  Anwender  mit  einer  Bildschirmmeldung  gelangen  und
dadurch das Programm unterbrochen wird. Bei Berechnungen mit CARDINAL-
und INTEGER-Werten reicht es in der Regel, dem Compiler durch die Option
(*$R-*) im Quelltext mitzuteilen, keine PrÅfungen vorzunehmen. Aber z. B. bei
Benutzung von REAL-Werten werden vorcompilierte Funktionen aus dem Modul
Runtime  importiert,  die  immer  FehlerprÅfungen  vornehmen.  Hier  kann  im
Zweifelsfall nur mit CatchErrors sichergestellt werden, daû das Programm die
Kontrolle behÑlt.

Ein weiteres Beispiel fÅr die Fehlerbehandlung von Laufzeitfehlern ist das Modul
GEMError,  das  Sie  als  Quelltext  erhalten  haben.  Es  ist  z.B.  in  die  Shell
eingebunden und fÑngt als letztes Modul alle Fehler ab und zeigt sie an. Ein
gelinktes  Programm  sollte  immer  in  irgendeiner  Weise  evtl.  auftretende
Laufzeitfehler abfangen. Am einfachsten ist es, dazu GEMError einzubinden,
was normalerweise auch geschieht.


Dateifehler

Im Kapitel Åber das Dateisystem wird beschrieben, wie es dazu kommen kann,
daû eine  Fehlermeldung  fÅr  Dateifehler  ausgelîst  werden  kann.  Das  Modul
FileBase enthÑlt die Prozedurvariable HandleError, die aufgerufen wird, wenn
ein Dateifehler gemeldet werden soll. Wenn sie unverÑndert bleibt, werden alle
Dateifehlermeldungen ignoriert.

Das Modul GEMError weist auf HandleError eine Routine zu, die den Fehler
anzeigt, dem Anwender bei einem Fehler Åber den Grund und die Programm~
stelle informiert und ihm die Mîglichkeit bietet, das Programm zu beenden,
fortzufÅhren oder den  Editor  aufzurufen,  um  die  Fehlerposition  anzuzeigen.
Dazu wird von HandleError die Dateifehlernummer  und  die  Dateivariable,  in
deren Datei der Fehler auftrat, Åbergeben. ZusÑtzlich wird noch ein Argument
Åbergeben, das die Adresse der Prozedur  im  Speicher  angibt,  an  der  der
Dateifehler erkannt wurde.
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 31
________________________________________________________


In FileBase findet sich auûerdem die Prozedurvariable CloseFile. Sie wird bei
Programm-/Prozeûende fÅr jede unter dem Prozeû erîffnete und noch offen
gebliebene  Datei  aufgerufen.  Wird  sie  nicht  verÑndert,  wird  jede  offen
gebliebene Datei automatisch geschlossen. GEMError zeigt jedoch alle offenen
Dateien an und bietet die Mîglichkeit, Disk-Dateien, die mit Create angelegt
wurden, zu lîschen. Dies ist von Vorteil, wenn ein Programm, das eine Datei
erzeugt, durch einen Laufzeitfehler beendet wird. Oft ist dann die erzeugte
Datei unvollstÑndig und kann gelîscht werden.


Fehlerbehandlung mit dem Modul EasyExceptions

Dieses  Modul  ermîglicht  nicht  nur  die  Abfrage  von  Laufzeitfehlern,  eigene
Fehler kînnen auf einfache Weise selbst ausgelîst werden, und die Funktion, in
der der Fehler auftrat, kann auf bequeme Weise wieder verlassen werden.

KernstÅck der Fehlerkontrolle ist die Funktion Call. Als erstes Argument erhÑlt
sie die Prozedur, die die eigentliche Operation durchfÅhren soll. Call nimmt alle
notwendigen Installationen fÅr die Fehlerabfrage vor (Åber HdlError.CatchErrors)
und  sieht  auûerdem  einen  zentralen  RÅcksprung  fÅr  alle  Fehler  vor.  Dann
startet Call die eigentliche Prozedur. Kehrt die Prozedur ohne Fehler zurÅck,
liefert Call einen Wert, der den fehlerfreien Ablauf anzeigt. Tritt dagegen ein
Fehler  auf,  wird  die  Prozedur  sofort  abgebrochen  und  Call  liefert  einen
Fehlerwert.

Die  Fehler  kînnen  nicht  nur  durch  die  bereits  erwÑhnten  Mîglichkeiten
(RaiseError, CPU-Exception, Soft-Error, Dateifehler), sondern auch Åber die
Raise-Funktion aus EasyExceptions gemeldet werden. Die Raise-Funktion hat
einen  entscheidenden  Vorteil  gegenÅber  RaiseError:  Sie  erhÑlt  nicht  eine
INTEGER-Zahl, die vorher festgelegt werden muû, sondern einen opaque-Wert,
welcher vorher Åber die Funktion New des Moduls angefordert werden muû.
So kînnen mehrere Funktionen unabhÑngig voneinander  eigene  Fehler-Werte
mit New anfordern. Damit ist gewÑhrleistet, daû es keine öberschneidungen
bei  den  Werten  gibt.  Die  Module,  die  eigene  Fehler  Åber  Raise  auslîsen
kînnen,  mÅssen  lediglich  Variablen  oder  Funktionen  exportieren,  die  die
angeforderten Werte liefern, damit ein Vergleich mîglich ist.

Ein Beispielmodul fÅr die Anwendung von EasyExceptions findet sich im DEMO-
Ordner unter dem Namen EXCTEST.M.
5.3 Bibliothek: Laufzeitfehler-Behandlung                                  5 - 32
________________________________________________________


Fehlerbehandlung in Accessories

Gerade Accessories sollten auf mîgliche oder auch unerwartete Laufzeitfehler
vorbereitet sein: Sollte ein Accessory tatsÑchlich einmal unkontrolliert  einen
Laufzeitfehler auslîsen, ist der Atari aufgrund der dÅrftigen Konzeption seiner
Accessory-Verwaltung zum Stillstand verurteilt: Nichts geht mehr.

Also Åberlegen Sie es sich gut: Wenn Sie ein Accessory programmieren und
dies einen Fehler macht, wenn Sie gerade in der Hauptanwendung, z.B. einer
Textverarbeitung, richtig viele Daten eingegeben haben, ist es doch sicher sehr
Ñrgerlich, daû Ihre Daten nicht wegen einem Fehler in der Textverarbeitung,
sondern  wegen  einem   eigentlich   unbeteiligten   Programm   das   Nirwana
aufgesucht haben, oder?

Da  Sie  ein  vorsichtiger  Mensch  sind  -  schlieûlich  haben  Sie  sich  ja  fÅr
Modula-2 und nicht fÅr C entschieden, freut es Sie natÅrlich besonders, daû
wir Sie auch hier nicht im Stich lassen: Verwenden Sie einfach die Funktion
Call aus EasyExceptions, wie dies z.B. im DEMO-Modul AccDemo gezeigt wird.
Die Funktionen aus HdlError kînnen Sie hier nicht benutzen - sie haben in
Accessories ohne weiteres keine Wirkung.
5.4 Bibliothek: Dateisystem                                               5 - 33
________________________________________________________


5.4  Dateisystem

Das Dateisystem ermîglicht Ein-/Ausgaben von Texten und anderen Daten auf
Disk (Floppies, Harddisks). Zudem lÑût es Textein-/ausgaben auf "sequentielle"
Einheiten (Device, z. B. Bildschirm, Tastatur, Drucker, Midi-Schnittstelle) zu.

Zum Dateisystem gehîren die folgenden Module:
    - Files       ôffnen und Schlieûen von Dateien.
    - Binary     Nicht-textuelle Ein-/Ausgabe von Daten auf Diskdateien.
    - Text       Textuelle Ein-/Ausgabe auf beliebige Dateien.
    - NumberIO  Ein-/Ausgabe von Zahlen in Textform auf beliebige Dateien.
    - InOut      Ein-/Ausgabe von Text und Zahlen auf eine Standarddatei.



Dateimodi

Es gibt zwei verschiedene Modi, um auf eine Datei zuzugreifen. Die beiden
unterscheiden sich grundsÑtzlich in der Absicht, was fÅr eine Art von Daten
bearbeitet werden soll. Entweder wird beabsichtigt, nur normal lesbaren Text
ein- und auszugeben oder, es sollen Daten (ggf. incl. Text), die in der vom
Rechner verschlÅsselten Form vorliegen, in einer Datei gespeichert werden.

Beispiel: Eine Zahl kann in zwei Formen vorliegen, entweder als String, damit
sie auf dem Bildschirm anzeigbar ist, oder als rechnerkodierter Wert, z. B. in
einer CARDINAL-Variable. Nur in der rechnerinternen Form (binÑr) kann mit
ihr  gerechnet  werden,  nur  die  Textform  ist  fÅr  den  Anwender  lesbar.
Funktionen wie WriteCard wandeln die in binÑrer Form Åbergebene Zahl zur
Ausgabe erst in einen String um (fÅr Umwandlungen von binÑr dargestellten
Zahlen in Strings und umgekehrt gibt es die Module Convert und StrConv).

ZurÅck zu den zwei Dateimodi. BinÑre Daten zu speichern, spart Platz und
Zeit. Solche kodierten Daten dÅrfen aber nur in Diskdateien abgelegt, nicht
jedoch z.B. auf Bildschirm oder Drucker ausgegeben werden.

Soll  dagegen  ausschlieûlich  Text  (also  auch  Zahlen  in  Textform)  ein-  und
ausgegeben werden, ist das Medium frei wÑhlbar.
5.4 Bibliothek: Dateisystem                                               5 - 34
________________________________________________________


ôffnen einer Datei

Um auf eine Datei zugreifen zu kînnen, muû man einen Zugriff darauf anmel~
den. Dies kann mit Open oder Create aus Files geschehen. Dabei wird ein Na~
me Åbergeben, der die anzusprechende Datei bezeichnet. Der Name kann dabei
sowohl ein Disk-Dateiname sein, z. B. "A:ADRESS.DAT", als auch, wenn man
den rein textuellen Modus wÑhlt, der Name eines sequentiellen Devices. Hierzu
gehîren:
  - "CON:"  fÅr  Bildschirmausgabe  und  Tastatureingabe  mit  gleichzeitiger
              Bildschirmanzeige (mit "Echo"),
  - "KBD:"   fÅr Tastatureingabe ohne Echo,
  - "AUX:"   fÅr Ein- und Ausgabe Åber die serielle Schnittstelle,
  - "PRN:"   fÅr Ausgabe auf den Druckerport,
  - "MIDI:"  fÅr Ein- und Ausgabe Åber den Midi-Port und
  - weitere  selbstdefinierte  Namen  fÅr  eigene  Devices,  die  Åber  die  Unit-
              Variablen in FileBase konfiguriert werden kînnen (s.u.).

Beim ôffnen wird auûerdem der Zugriffsmodus angegeben. FÅr den binÑren
Zugriff kann writeOnly (nur Schreiben auf Datei), readOnly (nur Lesen) oder
readWrite(Lesen und Schreiben) angegeben werden. FÅr textuellen Zugriff ist
readSeqTxt (nur Lesen), writeSeqTxt (nur Schreiben) oder appendSeqTxt (nur
Schreiben, bei Diskdateien neue Daten an vorhandene Daten anhÑngen).

Der Unterschied zwischen Open und Create: Open îffnet stets eine vorhande~
ne Datei, wÑhrend Create versucht, eine neue Datei (bei Diskzugriff) anzule~
gen. Bei Zugriff auf sequentielle Devices, die ja stets schon vorhanden sind,
sind Open und Create gleichbedeutend.

Create hat noch einen zusÑtzlichen Parameter, der bestimmt, was passieren
soll, wenn schon eine Diskdatei unter dem angegebenen Namen existiert. Ist
dieser Parameter noReplace, heiût das, daû in diesem Fall die vorhandene Datei
erhalten bleibt und ein Fehler geliefert wird. Ist dagegen replaceOld angegeben,
wird eine eventuell schon vorhandene Diskdatei gelîscht.

Dazu einige Anwendungsbeispiele:

  -  Wenn der Zugriffsmodus readOnly oder readSeqTxt ist, wird grundsÑtzlich
     Open verwendet.

  -  Wird textuell geschrieben mit dem Modus writeSeqTxt oder appendSeqTxt,
     ist meist Create zu verwenden.

  -  Wird eine vorhandene Diskdatei mit Open im Modus readWrite, writeOnly
     oder  writeSeqTxt  geîffnet,  Åberschreiben  neu  ausgegebene  Daten  die
     alten von Beginn der Datei an.
5.4 Bibliothek: Dateisystem                                               5 - 35
________________________________________________________


Bei Open und Close wird als erster Parameter eine Variable vom TypeFile(aus
Files) erwartet. Diese Variable wird dann von den Funktionen initialisiert und ist
bei weiteren Dateioperationen stets als erstes Argument anzugeben, um damit
die geîffnete Datei zu identifizieren. Wenn man also zwei Dateien gleichzeitig
offen haben will, muû man auch zwei Variablen vom Type File deklarieren und
je eine fÅr jede Datei verwenden.


Ein-/Ausgabe von Daten

Beim ôffnen einer Diskdatei wird ein Dateizeiger angelegt, der zu Beginn auf
das erste Datum der Datei zeigt, sofern sie nicht leer ist. Ausnahme: Wenn
der Modus appendSeqTxt ist, zeigt er hinter das  Ende  der  Datei.  Werden
Daten  gelesen  oder  geschrieben,  geschieht  dies  immer  ab  der  aktuellen
Zeigerposition aufwÑrts, und der Zeiger wird dabei automatisch erhîht. Wird
eine Datei auf ein sequentielles Device geîffnet, werden die Textdaten alle in
Folge gelesen oder geschrieben.

Werden  Daten  am  Ende  einer  Diskdatei  geschrieben,  wird  die  Datei
automatisch um die erforderliche Datenmenge verlÑngert.

FÅr  BinÑrdateien  kînnen  alle  Funktionen  aus  den  Modulen  Binary,  Text
(Ausnahme:  EOL)  und  NumberIO  verwendet  werden.  In  Binary  gibt  es
Funktionen zum Schreiben von beliebigen Daten. So schreibt z. B. WriteWord
beliebige Daten mit Word-LÑnge in eine Datei, z. B. CARDINAL-, INTEGER-
oder  AufzÑhlungstyp-Variablen.  Mit  WriteBlock  kînnen  beliebige  Daten~
strukturen  geschrieben  werden,  z.B.  RECORDs  und  ARRAYs.  WriteBytes
erlaubt es, eine Adresse und die LÑnge eines Datenbereichs zum Schreiben zu
bestimmen. Ebenso gibt es passende Read...-Funktionen zum Dateilesen.

In Binary gibt es weiterhin die Funktion FileSize, die die aktuelle LÑnge einer
Datei in Bytes liefert. Die aktuelle Position des Dateizeigers kann mit FilePos
ermittelt und mit Seek neu gesetzt werden. Seek bietet sich  vor  allem  in
Kombination mit dem Zugriffsmodus readWrite an, um in einer Datei, die aus
vielen  gleichartigen,  hintereinandergereihten  Datenfeldern  besteht,  einzelne
Daten herauszugreifen oder zu  verÑndern.  Wenn  mit  Seek  der  Dateizeiger
hinter  das  aktuelle  Dateiende  positioniert  wird,  wird  die  Datei  automatisch
entsprechend erweitert.

Die Module Text und NumberIO enthalten Funktionen zur Textein-/ausgabe, wie
sie auch in InOut und Terminal vorkommen. Die Funktionen, bis auf EOL aus
Text, dÅrfen sowohl im  Text-  als  auch  im  BinÑrmodus  verwendet  werden.
Allerdings  funktioniert  die  Behandlung  des  Dateiendes  in  den  beiden  Modi
unterschiedlich.
5.4 Bibliothek: Dateisystem                                               5 - 36
________________________________________________________


Dateiende-Behandlung

Mittels der Funktion EOF  kann  ermittelt  werden,  ob  aus  einer  Datei  noch
weitere Daten gelesen werden kînnen und ob ein Fehler aufgetreten ist.

WÑhrend im Textmodus nach Erreichen des Dateiendes die Dateioperationen
unbedingt beendet werden mÅssen (da nichts anderes mehr funktioniert), kann
im  BinÑrmodus,  falls  mit  writeOnly  oder  readWrite  geîffnet  wurde,  am
Dateiende geschrieben oder auch mit Seek eine andere Position in der Datei
erreicht werden.

Auch ist die Funktion EOF  im  BinÑrmodus  jederzeit  aufrufbar,  wÑhrend  im
Textmodus dies nur erlaubt ist, wenn die Datei mit readSeqTxt - jedoch nicht
mit writeSeqTxt oder appendSeqTxt - geîffnet wurde.

Im BinÑrmodus zeigt EOF dann das Dateiende an, wenn der Dateizeiger genau
auf das Ende der Datei zeigt. So kann also schon vor einem Lesezugriff mit
dieser Funktion ermittelt werden, ob Åberhaupt noch Daten vorhanden sind.

Im Textmodus gibt es nicht unbedingt einen Dateizeiger, denn der existiert ja
nur bei Diskdateien, aber nicht bei sequentiellen Devices. Deshalb erfolgt hier
die  Dateiendeerkennung  auf  eine  andere  Weise,  und  zwar  mit  einem
bestimmten  Dateiendezeichen.  Die  Lesefunktionen  prÅfen  jedes  gelesene
Zeichen. Ist es das Dateiendezeichen, ist automatisch das Dateiende erreicht.
Daraus folgt, daû erst ein Zeichen gelesen werden muû, bevor das Dateiende
erkannt werden kann.

Bei Textdateien auf Disk wird zusÑtzlich ÅberprÅft, ob der  Dateizeiger  das
Dateiende erreicht hat, damit es keine  Probleme  gibt,  wenn  eine  Diskdatei
gelesen wird, die kein Dateiendezeichen enthÑlt.

Es gibt zwei Gruppen von Lesefunktionen, bei denen diese Unterschiede beach~
tet werden mÅssen. Auf der einen Seite die Read-Funktion, auf der anderen
die ReadString-Funktion und die Funktionen aus NumberIO.

Die Read-Funktion ist leicht durchschaubar. Im Textmodus muû nach einem
Lesezugriff geprÅft werden, ob das Dateiende erreicht ist. In dem Fall ist das
gelesene Zeichen nicht mehr zu verwenden, denn es ist lediglich das Ende~
kennzeichen.

Bei ReadString ist der erhaltene String verwendbar, es ist lediglich das Ende~
kennzeichen nicht darin enthalten. Bei den Lesefunktionen aus NumberIO ist die
Zahl gÅltig, sofern deren success-Argument TRUE ist.
5.4 Bibliothek: Dateisystem                                               5 - 37
________________________________________________________


Als Beispiel je eine Leseschleife fÅr den BinÑr- und den Textmodus:

  (* FÅr BinÑrdateien *)
  WHILE NOT Files.EOF (f) DO  (* EOF schon vor Zugriff bekannt *)
    Text.Read (f, ch);
    Verarbeite (ch)
  END;

  (* FÅr Textdateien *)
  LOOP
    Text.Read (f, ch);
    IF Files.EOF (f) THEN EXIT END;
                                  (* EOF wird erst nach Lesen erkannt *)
    Verarbeite (ch)          (* 'ch' nur gÅltig, wenn kein EOF    *)
  END;

Bei Dateien, die zum textuellen Lesen erîffnet sind, ist auûerdem die Funktion
EOL benutzbar. Sie signalisiert, wenn ein Zeilentrennzeichen gelesen wurde,
das  Dateiende  erreicht  oder  ein  Fehler  aufgetreten  ist.  Ebenso  wie  das
Dateiende  kann  auch  das  Zeilenende  erst  nach  dem  Lesezugriff  erkannt
werden und, bei Read ist dann ebenfalls das erhaltene Zeichen zu verwerfen.

Das Zeilentrennzeichen ist ein einzelnes CR (15C) oder ein CR mit einem direkt
folgenden  LF.  Das   Anwenderprogramm   braucht   also   nicht   selbst   zu
unterscheiden, ob die Eingabe z. B. von Tastatur kommt, wo normalerweise
allein mit CR die Zeile begrenzt wird, oder von einer Datei, die meist (nicht
immer) mit CR und LF eine Zeile abschlieût. Das eventuelle LF-Zeichen nach
einem CR kann beim textuellen Lesen nicht erhalten werden.

Es folgt ein Programmbeispiel fÅr textuelles Lesen einer Datei mit Read:
5.4 Bibliothek: Dateisystem                                               5 - 38
________________________________________________________


  MODULE TestPrg;

  IMPORT Files, InOut;

  PROCEDURE LeseUndDruckeText (textname: ARRAY OF CHAR);

    PROCEDURE MeinFehlerTest (f: Files.File);
      VAR msg: ARRAY  0..31  OF CHAR;
      BEGIN
        IF Files.State (f) < 0 THEN            (* ernster Fehler ? *)
          Files.GetStateMsg (Files.State (f), msg);
                                                      (* Fehlertext holen *)
          Files.ResetState (f);               (* Fehler rÅcksetzen *)
          InOut.WriteLn;
          InOut.WriteString (msg);        (* Fehlertext anzeigen *)
        END
      END MeinFehlerTest;

    VAR  f: Files.File;  ch: CHAR;

    BEGIN
      Files.Open (f, textname, Files.readSeqTxt);
      IF Files.State (f) >= 0 THEN
        LOOP
          Text.Read (f, ch);
          IF Text.EOL (f) THEN                   (* Zeichen ungÅltig *)
            IF Text.EOF (f) THEN
              MeinFehlerTest (f);                          (* Fehler ? *)
              EXIT                                (* Auf jeden Fall Ende *)
            ELSE
              InOut.WriteLn                               (* Zeilenende *)
            END
          ELSE
            InOut.Write (ch);       (* gelesenes Zeichen ausgeben *)
          END
        END;
        Files.Close (f)
      END
    END LeseUndDruckeText;

  BEGIN (* of main *)
    LeseUndDruckeText ("KBD:");         (* Eingabe von Tastatur *)
    LeseUndDruckeText ("A:TEST.TXT")   (* Eingabe v. Diskdatei *)
  END TestPrg.
5.4 Bibliothek: Dateisystem                                               5 - 39
________________________________________________________


Die Leseschleife kann auch noch eleganter programmiert werden:

      LOOP
        Text.Read (f, ch);
        CASE State (f) OF (* siehe Kap. Åber Fehlerbehandlung *)
          MOSGlobals.fOK : InOut.Write (ch)| (* Zeichen ausg. *)
          MOSGlobals.fEOL: InOut.WriteLn|       (* Zeilenende *)
          MOSGlobals.fEOF: EXIT                      (* Dateiende *)
        ELSE
          MeinFehlerTest (f);EXIT
        END
      END;

Wie aus dem Beispiel ersichtlich ist, mÅssen Zeilenbegrenzer (CR und/oder LF)
Åber die Funktion EOL abgefragt werden. Dazu muû vorher ein  Lesezugriff
erfolgt sein. Das gleiche gilt fÅr die Dateiende-Erkennung. Liefert die Funktion
EOF TRUE, dann kann mit Hilfe der Funktion State erkannt werden, ob das
Dateiende  (State(f)>=0)  erreicht  wurde  oder  ob  ein  Fehler  aufgetreten  ist
(State(f)<0).

Als letztes Beispiel die Read-Routine angepaût fÅr ReadString:

      VAR s:ARRAY  0..9  OF CHAR;

      ...

      LOOP
        Text.ReadString (f,s);
        InOut.WriteString (s);
        (* Der String ist auf jeden Fall *)
        (* brauchbar, ggf. ist er leer.  *)
        IF  Text.EOL  (f)  THEN
          IF Files.EOF (f) THEN (* Entweder Fehler o. Dateiende *)
            MeinFehlerTest (f); (* Fehler ? *)
            EXIT                     (* Auf jeden Fall Ende *)
          ELSE                       (* Zeilenende: *)
            InOut.WriteLn
          END
        END
      END;
5.4 Bibliothek: Dateisystem                                               5 - 40
________________________________________________________


Diverse Dateifunktionen (Modul "Files")

Am Ende aller Zugriffe auf eine Datei sollte sie mit Close geschlossen werden.
Vor  allem  bei  Diskdateien,  die  beschrieben  wurden,  ist  dies  unbedingt
erforderlich. Wenn Sie dies vergessen, wird bei Modulen, die von der Shell
gestartet  wurden  oder  in  die  das  Modul  GEMError  eingebunden  ist,  bei
Prozeûende eine Meldung angezeigt, die auf offen verbliebene Dateien hinweist
und sie ordnungsgemÑû schlieût.

Ist  ein  fataler  Fehler  aufgetreten  und  will  man  bereits  erzeugte  Daten
verwerfen,  kann  Remove  statt  Close  aufgerufen  werden.  Dann  werden
Diskdateien,  die  mit  Create  erzeugt  wurden,  wieder  gelîscht,  mit  Open
geîffnete Dateien werden normal, wie mit Close, geschlossen.

Mit SetEOFMode kann ausschlieûlich bei Textdateien bestimmt werden, ob und
mit  welchem  Zeichen  das  Dateiende  erkannt  werden  soll.  GetEOFMode
ermittelt die augenblickliche Einstellung fÅr eine offene Datei. Normalerweise
wird beim Lesen des Åblichen ASCII-Zeichens "ETX" (32C, $1A) das Dateiende
erkannt.

Flush  wird  nur  bei  Ausgabedateien  benîtigt.  Es  sorgt  fÅr  eine  unbedingte
Speicherung bzw. öbermittelung der ausgegebenen Daten. Denn es ist mîglich,
daû die ausgegebenen Daten zuerst in einem rechnerinternen Speicherbereich
gesammelt werden, bevor sie auf Disk geschrieben oder z. B. Åber die serielle
Schnittstelle ausgegeben  werden,  damit  eine  hîhere  Ausgabegeschwindigkeit
erreicht  werden  kann.  Nur  nach  dem  Aufruf  von  Flush  oder  Close  ist
sichergestellt, daû die Daten ihr Ziel erreicht haben. Normalerweise werden
also die Daten in einem normalen Ablauf immer ankommen, nur gibt es FÑlle, in
denen dies zu einem bestimmten Zeitpunkt gesichert sein muû. Mit anderen
Worten: Wenn Sie nicht wissen, wofÅr diese Funktion gut ist, dann werden Sie
sie auch nicht brauchen. Mir fÑllt noch etwas ein: Beispielsweise wartet Flush
bei  einer  Datei,  die  auf  "AUX:"  geîffnet  ist,  bis  alle  Daten  des  Seriell-
Datenpuffers ausgegeben sind.

SetDateTimeund  GetDateTime  setzen  bzw.  erfragen  die  Zeitangabe  einer
Datei. Bei nicht-Diskdateien wird SetDateTime ignoriert und bei GetDateTime
ein Null-Datum geliefert.

Mit GetFileName kann man den Namen, mit dem eine Datei erîffnet wurde,
ermitteln. Ist die Datei nicht offen, wird ein Leername geliefert.
5.4 Bibliothek: Dateisystem                                               5 - 41
________________________________________________________


Fehlerbehandlung im Dateisystem

SelbstverstÑndlich  sollte  man  nach  Aufruf  jeder  Dateibearbeitungsfunktion
eventuell aufgetretene Fehler prÅfen. Dies geschieht durch Aufruf der Funktion
State,  die  einen  INTEGER-Wert  liefert.  Liefert  sie  einen  negativen  Wert,
bedeutet  dies,  daû  bei  der  letzten  Dateioperation  ein  Fehler  auftrat.  Die
Fehlernummer entspricht den TOS-Fehlernummern. Des weiteren erzeugen die
MOS-Funktionen eigene Fehlernummern, die daran erkennbar sind, daû sie alle
niedriger  als  -127  sind.  Alle  Fehlernummern  sind  im  Modul  MOSGlobals
definiert und kurz erklÑrt.

Wird  nun  aus  NachlÑssigkeit  beim  Programmieren  ein  aufgetretener  Fehler
beim Dateizugriff nicht abgefragt und somit nicht erkannt, wird, sofern das
Modul GEMError vorhanden ist, beim nÑchsten Aufruf einer Dateibehandlungs~
funktion  das  laufende  Programm  unterbrochen  und  eine  Fehlermeldung
angezeigt, woraufhin das Programm beendet oder fortgefÅhrt  werden  kann,
wahlweise mit Ignorieren des Fehlers, so daû er weiterhin  bestehen  bleibt,
oder  mit  RÅcksetzen  des  Fehlers,  damit  weitere  Dateifunktionen  nicht
wiederholt den Fehler anzeigen.

Solange Sie nur kleine Programme entwickeln, reicht es auch aus, nur dort
Fehlerabfragen zu programmieren, wo stÑndig mit Fehlern gerechnet werden
muû:  z.  B.  nach  dem  ôffnen  einer  Datei,  um  zu  erfahren,  ob  die  Datei
vorhanden  ist,  oder  vor  allem  nach  Close,  da  hier  die  automatische
Fehlermeldung nicht mehr zuschlagen kann. Dagegen ist es ganz legitim und
auch  bequemer,  in  schnell  geschriebenen  Programmen  Fehlerabfragen  und
-meldungen nach Lese- und Schreiboperationen dem MOS zu Åberlassen.

Die automatische FehlerprÅfung wird von allen  Dateifunktionen  durchgefÅhrt,
auûer Open, Create, EOF, EOL, State, ResetState, GetStateMsg, GetFileName,
SetEOFMode und GetEOFMode.

Die folgenden Funktionen des Dateisystems kînnen keine Fehler auslîsen. Nach
Aufruf dieser Funktionen ist es also nicht nicht notwendig, zu prÅfen, ob ein
Fehler aufgetreten ist: EOF, EOL, FileSize, FilePos, SetEOFMode, GetEOFMode,
GetFileName, State, ResetState und GetStateMsg.

Wird ein Fehler vom Programm erkannt, muû es zuerst den Fehler mit der
Funktion ResetState rÅcksetzen, damit es nicht zu einer Fehlermeldung beim
nÑchsten Aufruf einer Dateifunktion kommt.
5.4 Bibliothek: Dateisystem                                               5 - 42
________________________________________________________


Die Funktion State liefert demnach einen positiven  Wert,  wenn  bisher  kein
Fehler aufgetreten ist. In der Regel wird eine Null geliefert, jedoch kann es
auch vorkommen, daû ein Wert grîûer Null erhalten  wird.  Dies  signalisiert
dann besondere ZustÑnde. Z. B. erhÑlt man den Wert Drei, wenn Close fÅr
eine bereits geschlossene Datei aufgerufen wurde, denn dies ist kein Fehler,
aber es kann auf der anderen Seite auch interessant sein. Auûerdem kann der
Wert Eins oder Zwei geliefert werden, wenn ein Zeilenende oder das Dateiende
erreicht worden ist. Dies kann dadurch die Verwendung von EOF und  EOL
ersetzen.

Im allgemeinen empfiehlt sich daher, nach einer Dateioperation Fehler daran zu
erkennen, ob die Funktion State einen positiven oder negativen Wert liefert,
und nicht daran, ob State den Wert Null liefert!


Zusammenfassung der Unterschiede zwischen BinÑr- und Textmodus

BinÑrdateien (readOnly, writeOnly, readWrite):
    -  Es darf nur auf Disk (Floppies, Harddisks oder andere Random Access
       Devices) zugegriffen werden.
    -  Die Funktion EOF liefert schon vor einem Zugriff, ob der Dateizeiger am
       Dateiende steht.
    -  Die  Funktion  EOL  darf  nicht  verwendet  werden.

Textdateien  (readSeqTxt, writeSeqTxt, appendSeqTxt):
    - Es dÅrfen keine  Funktionen  aus  Binary  (Dateizeigeroperationen,  byte-
       weises Lesen/Schreiben, DateilÑngenermittlung) verwendet werden.
    - Die Funktion EOF darf nicht auf Dateien angewandt  werden,  die  zur
       Ausgabe erîffnet wurden. Sie liefert erst nach einem Lesezugriff, ob
       noch weitere Daten folgen.
5.4 Bibliothek: Dateisystem                                               5 - 43
________________________________________________________


Das Modul InOut

Die  Funktionen  in  diesem  Modul  vereinfachen  die  Dateiein-/ausgabe.  Man
braucht sich um die Fehlerabfragen und die Besonderheiten der Dateibehand~
lung nicht zu kÅmmern. Normalerweise ist immer je eine Datei fÅr Ein- und
Ausgabe Åber Tastatur und Bildschirm (Textwindow) geîffnet. Es stehen alle
Åblichen Funktionen fÅr textuelle Ein- und Ausgaben zur VerfÅgung. Da alle
Ein-/Ausgaben auf jeweils eine Standarddatei gehen, braucht bei den Funktionen
keine Dateikennung (File-Variable) Åbergeben zu werden.

Mit RedirectInput und RedirectOutputkann eine Datei bestimmt werden, auf die
die folgenden Ein- oder Ausgaben gelenkt werden. Letztere Funktion hat neben
dem Dateinamen einen weiteren Parameter, der bestimmt, ob die Datei mit
writeSeqTxt oder appendSeqTxt geîffnet werden soll.

OpenInput und OpenOutput geben auf dem Bildschirm einen Text aus, der dazu
auffordert, einen Dateinamen einzugeben. Tritt beim ôffnen der Datei dann ein
Fehler auf, wird eine Fehlermeldung ausgegeben und man hat die Wahl, ob die
Dateibestimmung wiederholt werden soll. Bei OpenOutput hat man weiterhin die
Mîglichkeit, durch Eingabe eines ">" vor dem Dateinamen zu bestimmen, daû
die folgenden Daten an die angegebene Diskdatei angefÅgt werden sollen. Wird
dies nicht bestimmt, darf die Ausgabedatei nicht schon bestehen, sonst erfolgt
eine Fehlermeldung.

Alle vier Funktionen signalisieren Åber die Variable Done, ob das ôffnen der
Datei funktionierte. Wenn ein Fehler auftrat oder ein Leerstring bei OpenInput/
Output eingegeben wurde, erfolgen die weiteren Ein-/Ausgaben Åber Tastatur
bzw.  Bildschirm.  Done  ist  dann  FALSE.  War  vor  Aufruf  einer  der  vier
Funktionen  bereits  Ein-/Ausgabe  umgelenkt,  wird  die  alte  Datei  zuerst
geschlossen.

Die Ein- oder Ausgabeumleitung kînnen Sie auch vom Anwender bestimmen
lassen, indem Sie das Modul ArgCVIO importieren und die darin enthaltene
Funktion InitArgCVaufrufen. Wenn Sie dann das Programm starten, kînnen Sie
als Argumentzeile z. B. ">PRN:" angeben, um die Ausgaben auf den Drucker zu
leiten, oder "<IN.TXT >>OUT.TXT", damit die Eingaben aus der Datei "IN.TXT"
geholt und die Ausgaben an die Datei "OUT.TXT" angefÅgt werden.

CloseInput  und  CloseOutput  oder  ein  Fehler  wÑhrend  des  Dateizugriffs
 schlieûen die betroffene Datei und lenken die Ein- bzw. Ausgabe wieder auf
Tastatur bzw. Bildschirm.

Done zeigt nach den Zahleneingabefunktionen an, ob  der  eingegebene  Wert
gÅltig ist. termCH enthÑlt nach denselben Funktionen oder nach ReadString das
Zeichen, durch das die Zahlen- oder Texteingabe beendet wurde.
5.4 Bibliothek: Dateisystem                                               5 - 44
________________________________________________________


Konfiguration eigener Unittreiber

Im Modul FileBase ist ein Array namens UnitDriver deklariert. Jedes der Feld~
elemente enthÑlt einen Namen, Prozedurvariablen und weitere Daten fÅr ein
Åber das Dateisystem ansprechbares sequentielles Device (Unit).

Das erste Feld z. B. enthÑlt den Unitnamen "CON:" und die Informationen, daû
diese Unit sowohl Ein- als auch Ausgaben zulÑût. Dazu sind auf die Prozedur~
variablen fÅr zeichenweise Ein- und Ausgabe Hilfsprozeduren zugewiesen, die
die Zeichen Åber die BIOS-Funktionen des TOS weiterleiten. Weitere Felder
sind fÅr "AUX:", "PRN:", "KBD:" und "MIDI:" initialisiert. Erfreulicherweise sind
auch noch sieben freie Felder vorgesehen.

Diese Initialisierungen werden immer vom FileBase-Modul vorgenommen. Es ist
nun aber mîglich, die Ein-/Ausgabefunktionen der bestehenden Units zu Ñndern
oder auch weitere Units in die freien Feldern einzutragen. Sollten Sie  bei~
spielsweise verbesserte Routinen fÅr die serielle Schnittstelle erstellt haben,
kînnen Sie Ihre eigenen Prozeduren gegen die Standardroutinen austauschen,
ohne daû Programme, die die serielle  Schnittstelle  Åber  das  Modula-Datei~
system mit "AUX:" ansprechen, geÑndert werden mÅssen.

Wie Sie Ihre Routinen resident einbinden, erfahren Sie am Ende des Kapitels
Åber Prozesse.
5.5 Bibliothek: Grafikdarstellung im Atari ST                              5- 45
________________________________________________________


5.5  Grafikdarstellung  im  Atari  ST


Alles, was auf dem Bildschirm zu sehen ist, wird im Speicher des Rechners
durch ein Bitraster reprÑsentiert. Dieses Bitraster belegt 32 kByte und ist in
planes, was soviel wie Bitebene bedeutet, unterteilt. Aus der Anzahl der Bit~
ebenen lÑût sich leicht die Zahl der gleichzeitig (ohne Tricks)  darstellbaren
Farben errechnen. Es ist

                                                   Anzahl der Bitebenen
                            Zahl der Farben = 2
                                                                            .


Beim ST kommen normalerweise drei verschiedene Modi vor:

hohe Auflîsung: Es ist nur eine Bitebene vorhanden, woraus sich die Anzahl
                  1
der Farben zu 2   = 2 ergibt. Dieser Modus wird auch monochrome (schwarz/
weiûe) Darstellung genannt und erlaubt es, 640 x 400 einzelne Pixel (Bildpunkte)
anzusteuern;

                                                                       2
mittlere Auflîsung: Zwei Bitebenen stehen zur VerfÅgung, was zu 2   = 4 ver~
schiedenen Farben fÅhrt. Bei dieser Darstellungsart kînnen noch 640 x 200
Pixel benutzt werden. Das heiût jede Bitebene ist 640 Pixel breit und 200 Pixel
hoch;

                                                                            4
niedrige Auflîsung: Das Raster wird in vier Bitebenen aufgeteilt, wobei 2   = 16
Farben erlaubt sind. Allerdings hat eine Bitebene dann nur noch 320 x 200
Punkte.

Bei den mehrfarbigen Darstellungsmodi kann jede Farbe aus einer Palette von
512 verschiedenen Farben ausgewÑhlt werden.


Da der Atari ST keinen speziellen Textmodus besitzt, muû auch Schrift durch
ein Bitmuster reprÑsentiert werden. DafÅr  existieren  verschiedene  Zeichen~
sÑtze (fonts), die das Aussehen der einzelnen Schriftzeichen festlegen. Ist ein
Zeichensatz unproportional, so besitzen alle Zeichen die  gleiche  Breite.  Bei
einem proportionalen Font kînnen zwei verschiedene Zeichen  hingegen  auch
unterschiedliche  Breite  haben  (Dieser  Text  wurde  zum  Beispiel  mit  einem
proportionalen Zeichensatz geschrieben). Das Betriebssystem stellt drei unpro~
portionale, sogenannte Systemfonts, zur VerfÅgung. Deren Ausmaûe betragen
6 x 6, 8 x 8 und 8 x 16 Pixel. Der 6 x 6 Zeichensatz wird normalerweise fÅr
die  Beschriftung  von  Icons  (Piktogrammen)  verwendet.  Die  beiden  anderen
dienen der allgemeinen Darstellung von Schrift, wobei der 8 x 16 Font fÅr die
5.5 Bibliothek: Grafikdarstellung im Atari ST                              5- 46
________________________________________________________


hohe und der 8 x 8 Font fÅr die mittlere und niedrige Auflîsung gedacht ist.
Daraus errechnet man sofort, daû bei hoher und mittlerer Auflîsung 80 x 25
und bei niedriger 40 x 25 Zeichen angezeigt werden kînnen. Bei der Darstel~
lung von Schrift muû zwischen den Ausmaûen des eigentlichen Zeichens und
denen der Zeichenzelle (auch Zeichenbox) unterschieden werden. Die  Grîûe
der Zeichenzelle eines Zeichens des 8 x 16 Fonts betrÑgt eben genau 8 x 16
Pixel, die Grîûe des Zeichens selber, zum Beispiel eines kleingeschriebenen i,
ist in der Regel aber geringer. Eine Zeichenzelle wird durch einige horizontale
Linien unterteilt, von denen die wichtigste die base line (Grundlinie) ist, welche
bestimmt, in welcher Hîhe die Zeichen ohne UnterlÑngen aufliegen.
5.6 Bibliothek: Die Line A-Routinen                                        5- 47
________________________________________________________


5.6  Die  Line  A-Routinen

Die Line A-Routinen stellen eine Sammlung von grafischen Grundfunktionen dar.
Der Name der Routinen leitet sich von der Art und Weise ihres Aufrufes ab.
Sie werden nÑmlich durch Opcodes der Form $Axxx aufgerufen, die im 68000
eine Ausnahmebehandlung (Exception) auslîsen.

Dieser Aufruf auf Maschinenebene muû vom Modula-Programmierer natÅrlich
nicht mehr durchgefÅhrt werden. Statt dessen importiert er die entsprechen~
den Prozeduren aus dem Modul LineA. Da ein Groûteil der Parameter (zum
Beispiel Schreibmodus und Farbe) entsprechend einem $Axxx-Aufruf in einem
globalen Variablenbereich, den sogenannten Line A-Variablen, definiert werden
muû, gehîrt das Modul noch zu den Low-Level-Modulen. Aus diesem Grund
wird auch die Benutzung der komplexeren und komfortableren  VDI-Routinen
empfohlen. Nur in SonderfÑllen sollte auf die Line A-Funktionen zurÅckgriffen
werden - keinesfalls  sollten  VDI-  und  Line  A-Aufrufe  in  einem  Programm
vermischt  werden,  da  dies  zu  InkompatibilitÑten  in  folgenden  Grafik~
erweiterungen (z.B. Ganzseitenbildschirm, hîher auflîsende Farbgrafik) fÅhren
kann. Zur Entscheidungshilfe sei auf die Fachliteratur verwiesen (z.B. das Atari
ST Profibuch aus dem Sybex-Verlag). Die genaue Beschreibung der Routinen
steht im Anhang B. Hier sollen  nur  noch  die  verwendeten  Datenstrukturen
erklÑrt werden.


Der Font-Header

Die Muster aller Zeichen eines Zeichensatzes liegen in einem einzigen, aus ei~
ner Bitebene bestehenden Bitraster. Dort sind die Zeichen nebeneinander an~
geordnet, woraus folgt, daû die Breite des Rasters genau die Summe aller
Zeichenbreiten ist. Eine Zeile des Bitrasters wird auch als Scan-Zeile bezeich~
net. Die Anzahl der Scan-Zeilen entspricht der Hîhe einer Zeichenbox, also
der maximalen Hîhe eines Zeichens.

Um die Breite eines einzelnen Zeichens zu ermitteln, geht man folgendermaûen
vor: Man zieht vom ASCII-Wert des fraglichen Zeichens den ASCII-Wert des
ersten darstellbaren Zeichens (siehe minADE) ab. Die erhaltene Zahl stellt ei~
nen Feldindex fÅr die Character-Offset-Tabelle dar. Aus dieser liest man den
indizierten und den darauf folgenden Wert. Subtrahiert man nun den ersten
von dem zweiten erhaltenen Wert, so ergibt sich das gewÅnschte Ergebnis.
Auûerdem entspricht der indizierte Wert auch der x-Koordinate des Zeichens
innerhalb des Bitrasters, welches die Font-Daten enthÑlt.

Die Horizontale-Offset-Tabelle wird, falls vorhanden, wie die Character-Offset-
Tabelle indiziert und enthÑlt einen vorzeichenbehafteten Wert, um den das Zei~
chen bei der Ausgabe verschoben werden soll. Der Font-Header ist in Form
eines Verbundes (FontHeader) definiert. Die Verbund-Komponeten haben fol~
gende Bedeutung:
5.6 Bibliothek: Die Line A-Routinen                                        5- 48
________________________________________________________


Bezeichner           Bedeutung

id                     Identifikationsnummer des Zeichensatzes
size                  Grîûe des Fonts in Punkt (Maû aus der Satztechnik)
name                 Name des Zeichensatzes
minADE               Niedrigster im Zeichensatz enthaltener ASCII-Wert
maxADE              Hîchster im Zeichensatz enthaltener ASCII-Wert
topToBase            Abstand zwischen top line und base line
ascentToBase        Abstand zwischen ascent line und base line
halfToBase           Abstand zwischen half line und base line
descentToBase       Abstand zwischen descent line und base line
bottomToBase        Abstand zwischen bottom line und base line
maxCharWidth        Maximale Zeichenbreite
maxBoxWidth         Maximale Breite einer Zeichenzelle
leftOffset             Linker Offset fÅr Kursivschrift
rightOffset           Rechter Offset fÅr Kursivschrift
thickening            Anzahl der Pixel, um die ein einzelnes Zeichen bei der
                      Darstellung fetter Schrift verbreitert werden soll
underLineH           Hîhe des Striches fÅr Unterstreichungen, in Pixel
lightMask             Maske zur Erzeugung aufgehellter Schrift
                      (normalerweise $5555)
skewMask            Maske zur Erzeugung schrÑger (kursiver) Zeichen
                      (normalerweise $5555)
flags                  Die einzelnen Bits haben folgende Bedeutung:
                      Bit 0 -- Zeigt an, daû der Header zum Systemzeichen~
                                satz gehîrt
                      Bit 1  -- Zeigt an, daû die Horizontale-Offset-Tabelle
                                benutzt wird
                      Bit 2 -- Zeigt an, daû die Font-Daten im 68000-Format
                                (Low/High Byte) vorliegen, sonst im Intel-For~
                                mat (High/Low Byte)
                      Bit 3 -- Zeigt an, daû alle Zeichen des Fonts gleich breit
                                sind (also keine Proportionalschrift)

horOffsetTab         Zeiger  auf  die  Horizontale-Offset-Tabelle  (falls  diese
                      vorhanden ist)
charOffsetTab        Zeiger auf die Character-Offset-Tabelle
fontData              Zeiger auf das Bitraster, das die Bitmuster der Zeichen
                      enthÑlt
formWidth            Breite einer Scan-Zeile, also die Summe aller Zeichen~
                      breiten
formHeight           Anzahl der Scan-Zeilen
next                  Zeiger auf den Font-Header des nÑchsten Zeichensatzes
5.6 Bibliothek: Die Line A-Routinen                                        5- 49
________________________________________________________


Die Line A-Variablen

Die Line A-Variablen dienen zur öbergabe der Parameter an die Line A-Routi~
nen. Welche Variablen von einer Routine ausgewertet werden, ist bei der Be~
schreibung der betreffenden Prozedur angegeben (Siehe Anhang B).

Es folgt eine ErklÑrung aller Line A-Variablen. Die Variablen sind in einem Ver~
bund mit dem Bezeichner LineAVars zusammengefaût, der folgende Struktur
hat:

Bezeichner           Bedeutung

planes                Gibt die Anzahl der benutzten Bitebenen an. Wird von je~
                      der Routine, auûer BitBlockTransfer, ausgewertet
bytesPerLine          Anzahl der Bytes einer Bildschirmzeile (Scan-Zeile). Wird
                      von jeder Routine, auûer BitBlockTransfer,ausgewertet
contrl                 Zeiger auf das CONTRL-Array
intin                  Zeiger auf das INTIN-Array
ptsin                  Zeiger auf das PTSIN-Array
intout                 Zeiger auf das INTOUT-Array
ptsout                Zeiger auf das PTSOUT-Array
plane1                Gibt an, welchen Wert das Bit der ersten Bitebene beim
                      Setzen eines Punktes erhalten soll
plane2                Gibt an, welchen Wert das Bit der zweiten Bitebene beim
                      Setzen eines Punktes erhalten soll
plane3                Gibt an, welchen Wert das Bit der dritten Bitebene beim
                      Setzen eines Punktes erhalten soll
plane4                Gibt an, welchen Wert das Bit der vierten Bitebene beim
                      Setzen eines Punktes erhalten soll
lastLine               Wird beim Zeichnen von Linien ausgewertet und besagt,
                      ob  die  zu  zeichnende  Linie  Teil  eines  im  EXCLUSIV-
                      ODER-Schreibmodus gezeichneten Polygonzuges ist. TRUE
                      bedeutet "Linie vollstÑndig zeichnen"
lineMask              Bitmuster fÅr das Zeichnen von Linien
writingMode          Gibt an, in welchem Schreibmodus gezeichnet werden soll.
                      Siehe auch GrafBase.WritingMode
p                     Erster Punkt
q                     Zweiter Punkt
patternPtr            Zeigt auf das zu verwendende FÅllmuster. Ein FÅllmuster
                      besteht aus einer oder mehreren Bitebenen, die immer 16
                      Bit (also ein Wort) breit sind.
patternMask          Gibt an, wie viele Zeilen eine Bitebene des FÅllmusters
                                                                           n
                      besitzt. Sinnvoll sind nur Zahlen, die sich durch 2   (n >
                      0) dar-stellen lassen.
multiFill               Ist diese Variable gesetzt, so besteht das FÅllmuster aus
                      mehreren Bitebenen, sonst nur aus einer.
5.6 Bibliothek: Die Line A-Routinen                                        5- 50
________________________________________________________


clipping               Gibt an, ob der folgende Rechteckbereich als Ausgabebe~
                      grenzung benutzt werden soll. In diesem Fall werden alle
                      Punkte, die ausserhalb dieses Bereichs zu liegen kom~
                      men, unterdrÅckt.
minClip               Linker, oberer Punkt des Begrenzungsrechtecks
maxClip               Rechter, unterer Punkt des Begrenzungsrechtecks
scaleAcc             Dient  als  Startwert  fÅr  den  Schriftvergrîûerungs- und
                      verkleinerungsalgorithmus. Sollte bei gesetztem scale-Flag
                      (Siehe unten) mit $8000 vorbesetzt werden.
scaleFactor           Gibt den Vergrîûerungs- oder Verkleinerungsfaktor  an.
                      Dabei gilt fÅr die
                      Vergrîûerung: $0000 - Normale Grîûe
                                         .
                                         .       Entsprechende Zwischengrîûen
                                         .
                                      $FFFF  - Doppelte Grîûe
                      Verkleinerung: $0000 - Keine Grîûe (Schrumpfung auf
                                         .                      einen Punkt)
                                         .      Entsprechende Zwischengrîûen
                                         .
                                      $FFFE  - Normale Grîûe
scaleMode
                      Gibt an ob vergrîûert oder verkleinert werden soll. Ist
                       Bit 0 gesetzt, so wird vergrîûert, sonst wird verkleinert
monoStatus          Zeigt an, daû die Zeichen einheitliche Breite haben. Ist
                      bei proportionalen Fonts nicht der Fall
source                Linke, obere Ecke des Zeichens im Bitraster des Fonts
dest                  Linke, obere Ecke des Zeichens auf dem Bildschirm
width                 Breite des Zeichens
height                Hîhe des Zeichens
formBase             Zeiger auf den Anfang der Font-Daten (Bitraster des Fonts)
formWidth            Breite einer Scan-Zeile im Bitraster des Fonts (Angabe
                      in Bytes)
style                  Flags fÅr spezielle Texteffekte. Es bedeutet:
                      Bit 0 -- Fette Darstellung der Schrift
                      Bit 1 -- Aufgehellte Darstellung der Schrift
                      Bit 2 -- SchrÑgstellen der Schrift (Kursive Darstellung)
                      Bit 3 -- Unterstreichen der Schrift
                      Bit 4 -- Umrahmte Darstellung der Schrift
lightMask             Maske zum aufgehellten Darstellen der Schrift
skewMask            Maske fÅr kursive Schrift
weight                Anzahl der Bits, um die fette Schrift verbreitert werden
                      soll
rightOff              Rechter Offset fÅr kursive Schrift
leftOff                Linker Offset fÅr kursive Schrift
5.6 Bibliothek: Die Line A-Routinen                                        5- 51
________________________________________________________


scale                 Zeigt an, ob Schrift in ihren Ausmaûen verÑndert werden
                      soll
chup                  Gibt den Winkel zwischen der Zeichengrundlinie (base line)
                      und  der  horizontalen  Koordinatenachse,  entgegen  dem
                      Uhrzeigersinn  an.  Dabei  bedeutet  (Zwischenwerte  sind
                      nicht mîglich):
                          0  -- Normale  Darstellung
                        900  -- Drehung um 90 Grad
                      1800  -- Drehung um 180 Grad
                      2700  -- Drehung um 270 Grad
textFg                Vordergrundfarbe fÅr die Textdarstellung
scratchArea          Zeiger auf einen Speicherbereich, der bei der Vergrîûer~
                      ung/Verkleinerung von Schrift und fÅr Texteffekte ver~
                      wendet wird
scratchOff2          Offset fÅr den obigen Zeiger, falls sowohl eine Grîûen~
                      Ñnderung als auch Texteffekte erwÅnscht sind

Zu den beiden vorangegangenen Variablen ist folgendes zu sagen. Beim Durch~
fÅhren einer GrîûenÑnderung von Schrift werden

                              Breite                       2
                            8         5
                 Hîhe * (  -------   + 2)  * ( Faktor   +  1)
                            8         5
                                 8

Bytes von den Line A Routinen benîtigt.

Es stehen Hîhe und Breite fÅr die Ausmaûe der Zeichenzelle im Originalzu~
stand (in Pixel). Faktor gibt den Vergrîûerungsfaktor an (Faktor = 1.5 bedeutet
zum Beispiel eine Vergrîûerung um das Anderthalbfache). îxÑ steht fÅr die
Gauû-Klammer, also den Wert von x mit abgehackten Nachkommastellen. FÅr
Texteffekte gilt die folgende Formel, das Resultat sind wieder die benîtigten
Bytes:

                            Breite
                         8         5
               Hîhe * (  -------   + 2)
                         8         5
                               8

Nur sind mit Hîhe und Breite diesmal die Ausmaûe des Zeichens nach der An~
wendung der Effekte gemeint.

Werden nur die Texteffekte oder nur die GrîûenÑnderung genutzt, so genÅgt
es, scratchArea auf einen genÅgend groûen Speicherbereich weisen zu lassen.
Werden beide kombiniert angewandt, so muû der von scratchArea markierte
Bereich die Summe beider Formeln an Bytes umfassen und in scratchOff2 die
Anzahl der Bytes fÅr die GrîûenÑnderung stehen (es dÅrfen nur gerade Werte
verwendet werden).
5.6 Bibliothek: Die Line A-Routinen                                        5- 52
________________________________________________________


textBg                Hintergrundfarbe fÅr die Textdarstellung
copyTrans            Zeigt an, daû  die  Routine  CopyRasterForm  transparent
                      kopieren soll, sonst kopiert sie Åberdeckend


Der Deskriptor fÅr BitBlockTransfer

Der Deskriptor enthÑlt alle Parameter, die fÅr die AusfÅhrung eines BitBlock
Transfer nîtig sind. Die Definition hat den Bezeichner BBTDeskriptor und ent~
hÑlt folgende Verbund-Komponenten:

Bezeichner           Bedeutung

w                     Breite des Quellbereichs in Pixeln
h                     Hîhe des Quellbereichs in Pixeln
destPlanes            Anzahl der Bitebenen (des Zielbereichs)
setBitCol             Farbe fÅr im Quellbereich gesetzte Bits, allerdings nicht
                      als Farbindex, sondern als Bitmuster, in dem jeweils ein
                      Bit fÅr eine Bitebene steht (Bit 0 entspricht erster Bit~
                      ebene)
unsetBitCol           Farbe fÅr im Quellbereich ungesetzte Bits. Format  wie
                      oben.

                      VerknÅpfungsart fÅr Planes, bei denen das
mode00              setBitCol-Bit und das unsetBitCol-Bit gleich Null ist
mode01               setBitCol-Bit gleich Null und das unsetBitCol-Bit Eins ist
mode10               setBitCol-Bit gleich Eins und das unsetBitCol-Bit Null ist
mode11               setBitCol-Bit gleich Eins und das unsetBitCol-Bit Eins ist

Die sechs letzten Variablen sind nur fÅr transparente KopiervorgÑnge relevant.
Beim deckenden Kopieren wird setBitCol und unsetBitCol auf Null gesetzt und
die zu benutzende VerknÅpfungsart in mode00 eingetragen.

Hinweis:   Zu den VerknÅpfungsarten siehe GrafBase.BitOperation.

sourceStart          Startpunkt des Quellbereichs in Pixeln
sourceAddr           Anfangsadresse des Quellbereichs (nicht des Quellrasters)
sourceInc             Schrittweite  im  Quellbereich  in  Byte  (normalerweise:
                      Anzahl der Bitebenen des Quellbereichs * 2)
sourceWidth          Breite einer Scan-Zeile des Quellrasters in Bytes
sourceWidth2        Bei transparenter Kopie gleich Null, sonst gleich source~
                      Width
destStart             Startpunkt des Zielbereichs in Pixeln
destAddr             Anfangsadresse des Zielbereichs (nicht des Zielrasters)
destInc               Schrittweite im Zielbereich in Byte
                      (normalerweise: Anzahl der Bitebenen des Zielbereichs * 2)
5.6 Bibliothek: Die Line A-Routinen                                        5- 53
________________________________________________________


destWidth            Breite einer Scan-Zeile des Zielrasters in Bytes
destWidth2           Bei transparenter Kopie gleich Null,  sonst  gleich  dest~
                      Width
patternPtr            Zeiger auf ein FÅllmuster, das wÑhrend des Kopiervor~
                      gangs als Maske verwendt wird (Ist er NIL, so wird un~
                      maskiert kopiert.)
patternWidth         Breite einer Zeile des FÅllmusters in Byte (Der aktuelle
                      Algorithmus  scheint  Probleme  mit  dieser  Variable  zu
                      haben und nimmt evtl. immer eine Breite von 2 Byte an)
patPlaneOff           Null bedeutet, daû das FÅllmuster nur eine Bitebene be~
                      sitzt, sonst steht hier Zahl der Bytes fÅr eine Bitebene.
patternEnd           Anzahl der Zeilen des FÅllmusters (alle Bitebene zusam~
                      men) multipliziert mit patternWidth
scratch               Bereich, der von der Kopierroutine als Variablenspeicher
                      benutzt wird. Muû nicht initialisiert werden.
5.7 Bibliothek: GEM                                                        5- 54
________________________________________________________


5.7  GEM

GEM steht fÅr Graphics Environment Manager und ist schlicht und ergreifend
die  auf  dem  Atari  ST  implementierte  grafische  BenutzeroberflÑche.  Dem
Programmierer stellt sie ein umfangreiches Paket an Routinen zur VerfÅgung,
das sowohl Dialog-, Fenster-, MenÅverwaltung und Ñhnliches umfaût als auch
Prozeduren   enthÑlt,   die   eine   einheitliche   Schnittstelle   zur   Benutzung
verschiedener  Ein-  und  AusgabegerÑte  bilden.  Das  GEM  besteht  aus  zwei
groûen Bibliotheken, dem VDI und dem AES.


VDI

Das VDI (Virtual Device Interface) umfaût allgemeine Ein- und Ausgabeopera~
tionen, deren Benutzung von der aktuellen Implementierung der Routinen relativ
unabhÑngig ist.

Theoretisch  kann  man  zwischen  zwei  verschiedenen  Koordinatensystemen
wÑhlen. Im

NDC (Normalisierte GerÑtekoordinaten)-System liegt der Ursprung (0, 0) in der
linken  unteren,  Ecke  und  die  rechte  obere  Ecke  besitzt  die  Koordinaten
(32767, 32767). Dieses System hat den Vorteil einer allgemeinen Verwend~
barkeit, es ist aber im aktuellen TOS nicht implementiert;

RC (Raster Koordinaten)-System ist der Ursprung (0, 0) die linke, obere Ecke,
und die Koordinaten der rechten unteren Ecke hÑngen von der Auflîsung des
AusgabegerÑtes  ab;  sie  betragen  beispielsweise  auf  dem  monochromen
Bildschirm (639, 399).

Bei jedem Aufruf einer VDI-Prozedur muû als erster Parameter eine GerÑte~
kennung (GEMEnv.DeviceHandle) Åbergeben werden. Diese Kennung teilt dem
VDI mit, auf welchem GerÑt die Ein- oder Ausgabe stattfinden soll. Meist ist
dies  die  Kennung  fÅr  eine  virtuelle  Bildschirmarbeitsstation  (virtual  screen
workstation). Dies bewirkt eine ganz normale Ausgabe auf den Bildschirm. Wie
erhÑlt man nun solch eine Kennung? DafÅr gibt es zwei Mîglichkeiten. Erstens
kann  man  die  Routine  GEMEnv.InitGem  aufrufen  und  meldet  sich  dadurch
sowohl  beim  VDI  als  auch  beim  AES  an.  Auûerdem  erhÑlt  man,  falls  die
Anmeldung  glÅckt,  auch  noch  eine  Kennung  fÅr  eine  virtuelle  Bildschirm~
arbeitsstation, mit deren Hilfe man nun auf den Bildschirm zugreifen kann. Die
zweite  Mîglichkeit  besteht  in  einem  Aufruf  von  GEMEnv.OpenDevice.  Diese
Mîglichkeit  sollte  aber  erst  fÅr  das  zweite  und  folgende  GerÑte  benutzt
werden.

Ist man mit allen Arbeiten auf dem GerÑt fertig, so sollte dies mit GEMEnv.
CloseDevice geschlossen werden. Eine Beschreibung der Funktionsweise und
Parameter der einzelnen VDI-Prozeduren findet man im Anhang B.
5.7 Bibliothek: GEM                                                        5- 55
________________________________________________________


AES

Das AES (Application Environment Services) unterstÅtzt eine Anwendung, das
heiût  ein  vom  Benutzer  gestartetes  Programm,  bei  der  Verwaltung  von
Fenstern, Dialogboxen, MenÅs und Ñhnlichem. Auûerdem ermîglicht es teilweise
eine quasiparallele Abarbeitung mehrerer Prozesse. Dies sind einerseits bis zu
sechs  Desk-Accessories  und  andererseits  die  aktuelle  Anwendung.  Da  die
Datenstrukturen und Funktionen des AES zum Teil recht komplex sind, sollen
sie im Folgenden einzeln betrachtet werden.


Das Konzept der GEM-Resourcen

Als Resource einer Anwendung bezeichnet man die Objekte, die zur Kommuni~
kation mit der Auûenwelt dienen. Dies kînnen zum Beispiel Dialogboxen oder
MenÅzeilen  sein.  Die  GEM-Resourcen  befinden  sich  in  der  Regel  in  einem
Resource-File, das durch den Suffix .RSC  kenntlich  gemacht  wird.  Erzeugt
wird dieses File mit einem Resource Construction Set  (Siehe  auch  Anhang
C.2).  Allerdings  ist  es  auch  mîglich,  die  Resourcen  zur  Laufzeit  von
Programmen selber erstellen oder Ñndern zu lassen (siehe Modul ObjHandler).


Verwaltung der GEM-Resourcen

Liegt ein Resource-File vor, so sollte dies wÑhrend der Initialisierung der An~
wendung  mit  AESResources.LoadResource  geladen  werden.  Mit  Hilfe  von
AESResources.ResourceAddr und der Resource-Indizes kînnen jetzt die Adressen
der einzelnen ObjektbÑume und anderer Strukturen (siehe auch Abschnitt Åber
ObjektbÑume) ermittelt werden. Die Resource-Indizes kennt eine Anwendung
durch das Importieren des Definitonsmoduls, das vom Resource Construction
Set beim Speichern der Resource erzeugt wird. Die Indizes sind in dem Modul
als Konstanten deklariert. Die Bezeichner dieser Konstanten entsprechen de~
nen, die wÑhrend der Erstellung der einzelnen Objekte im Resource Construc~
tion Set eingegeben wurden. Wenn eine Resource nicht mehr gebraucht wird,
sollte ihr Speicherplatz durch AESResources.FreeResource freigegeben werden.


Die Struktur des Objektbaumes

Eine Resource besteht im wesentlichen aus ObjektbÑumen. Diese dienen sowohl
zur Beschreibung von Dialogformularen und MenÅzeilen, als auch zum Erstellen
eigener DesktopoberflÑchen. Der Objektbaum und alle seine Elemente sind im
Modul GEMGlobals definiert.
5.7 Bibliothek: GEM                                                        5- 56
________________________________________________________


ACHTUNG:    Da die Typdefinitionen von Modula  und  C  (Muttersprache  des
               GEM) teilweise nicht kompatibel sind, sind die Objektdeklarationen
               oft  sehr  allgemein  gehalten.  Zum  Beispiel  ist  Object.type  als
               CARDINAL  deklariert,  obwohl  weiter  oben  ein  Typ  ObjType
               definiert  wurde,   der   ja   eigentlich   als   Wertebereich   fÅr
               Object.type dienen soll. Der Grund dafÅr  ist  einfach,  daû  die
               Ordinalzahlen  fÅr  die  Objekttypen  erst  bei  20  anfangen,  ein
               Modula-AufzÑhlungstyp  aber  bei  Null  beginnt.  Das  ist  alles
               ungefÑhrlich,  solange  ausschlieûlich  die  Routinen  der  GEM-
               Bibliotheksmodulen  zum  Verarbeiten  der  Objekte  verwendet
               werden (Dort werden alle Typwandlungen und -transformationen
               automatisch  durchgefÅhrt).  Sobald  man  aber  direkt  auf  die
               Objektstruktur zugreifen will, sollte man sich vorher Åber  die
               interne  Darstellung  von  Variablen  durch  den  Modula-Compiler
               und das GEM informieren.

Der Baum ist ein Feld (Array) aus Objekten (Object) und wird mit Hilfe eines
Zeigers (PtrObjTree) referenziert. Der Baumindex eines Objektes  ist  nichts
weiter als nur der Feldindex innerhalb des Baumes. Ein Objekt ist ein Verbund,
der aus einer allgemeinen Objektbeschreibung (Stellung im Baum, Grîûe etc.)
und  eventuell  noch  einem  Zeiger  auf  eine  typabhÑngige  Objektspezifikation
besteht. Dieser Verbund enthÑlt folgende Elemente:

Bezeichner           Bedeutung

next                  Index  des  rechten  Nachbarobjektes,  entspricht  dem
                      nÑchsten Objekt der Nachfolgerliste (Das rechteste Ob~
                      jekt einer Nachfolgerliste enthÑlt den Index VorgÑngers)
head                  Kopf (linkestes Objekt) der Nachfolgerliste des Objekts
tail                   Ende (rechtestes Objekt) der Nachfolgerliste des Objektes

Ist eine der drei vorausgegangenen Variablen gleich NoObject, so existiert das
bezeichnete Objekt nicht. Das bedeutet fÅr head und tail, daû das Objekt keine
Nachfolgerliste und somit auch keine Nachfolger besitzt. Und fÅr next, daû
weder Nachbarn noch ein VorgÑnger existieren, das heiût das Objekt ist die
Wurzel des Baumes.

type                  Gibt an, von welchem Typ das Objekt ist
flags                  Gibt die Flags des Objektes an
state                 Bestimmt den Objektstatus
spec                  EnthÑlt die typabhÑnige Objektbeschreibung
space                 Gibt den vom Objekt belegten Rechteckbereich an. Dabei
                      ist zu beachten, daû die Position relativ zum VorgÑnger~
                      objekt angegeben wird. Nur die Koordinaten des Wurzel~
                      objektes sind absolute Bildschirmkoordinaten.
5.7 Bibliothek: GEM                                                        5- 57
________________________________________________________


Folgende Objekttypen werden unterstÅtzt:

Bezeichner           Bedeutung

boxObj                Stellt ein gefÅlltes Rechteck dar. Die Objektspezifikation
                      gibt Farbe und RandstÑrke an.
textObj               Steht  fÅr  einen  Schriftzug.  Objektspezifikation  ist  ein
                      Zeiger auf eine TEdInfo-Struktur.
boxTextObj           Stellt eine Kombination der beiden vorangegangenen Ob~
                      jekttypen dar. Spezifikation wie bei textObj.
imageObj
                      Es wird ein Bitmuster dargestellt.  Spezifikation  ist  ein
                      Zeiger auf einen BitBlock-Verbund.
progDefObj           Selbstdefinierbares  Objekt.  Spezifikation  ist  ein  Zeiger
                      auf  eine  ApplBlock-Struktur.  NÑheres  zu  diesem  Typ
                      kann  im  Definitionsmodul  von  ObjHandler  nachgelesen
                      werden.
iBoxObj               Dies ist ein Rechteck, von dem nur der Rahmen sichtbar
                      ist. Hat  dieser  die  StÑrke  Null,  so  ist  es  unsichtbar.
                      Objektspezifikation  entspricht  boxObj.  Dieser  Objekttyp
                      wird   meist   zum   Zusammenfassen   von   mehreren
                      Unterobjekten benutzt.
buttonObj             Solche Objekte werden in der Regel als Knopf in Dialog~
                      boxen benutzt. Es wird ein Text zentriert in einem weiû
                      gefÅllten Rechteck ausgegeben. Die Spezifikation ist ein
                      Zeiger auf eine Zeichenkette.
boxCharObj           Entspricht boxObj, nur wird innerhalb des Rechteckes ein
                      Zeichen zentriert dargestellt. In der Spezifikation befindet
                      sich zusÑtzlich noch der ASCII-Wert des Zeichens.
stringObj             Stellt  die  Zeichenkette  dar,  auf  die  die  Spezifikation
                      zeigt.  Wird  fÅr  die  EintrÑge  in  den  Pull-Down-MenÅs
                      verwendet.
fTextObj              Entspricht textObj, doch ist der Text hier edierbar.
fBoxTextObj          Wie fTextObj, doch wird der Text innerhalb eines gefÅll~
                      ten Rechtecks dargestellt.
iconObj               Beschreibt ein Piktogramm (Icon). Dieses besteht aus ei~
                      nem maskierten Bitmuster, einer Bildunterschrift und ei~
                      nem Zeichen. Spezifikation ist ein Zeiger auf einen Icon~
                      Block-Verbund.
titleObj               Entspricht  stringObj,  wird  allerdings  fÅr  die  MenÅtitel
                      verwendet.
5.7 Bibliothek: GEM                                                        5- 58
________________________________________________________


Es folgen die Objektflags:

Bezeichner           Bedeutung

selectFlg              Zeigt an, daû das Objekt bei einem Dialog durch einen
                      Mausklick angewÑhlt werden kann
defaultFlg             Besitzt ein Objekt  dieses  Flag,  so  wird  es  angewÑhlt,
                      wenn wÑhrend eines Dialoges die <Return>-Taste betÑtigt
                      wird.  Das  Flag  sollte  pro  Dialogformular  nur  einmal
                      vorkommen.
selectExitFlg          Bestimmt, daû der Dialog abgebrochen wird, sobald das
                       so gekennzeichnete Objekt angewÑhlt wird.
editFlg                Zeigt an, daû das Objekt einen edierbaren Text enthÑlt.
radioButFlg           Kennzeichnet eine Gruppe von Objekten, von denen immer
                      nur  eines  gleichzeitig  angewÑhlt  sein  kann.  Wird  ein
                      zweites angeklickt, so wird das erste wieder deselektiert.
                      Die Elemente der Gruppe mÅssen denselben  VorgÑnger
                      besitzen.
lastObjFlg             Bestimmt das letzte Objekt eines Baumes, also das mit
                      dem grîûten Objektindex.
touchExitFlg          Wird auf einem solchen Objekt wÑhrend des Dialoges der
                      Mausknopf gedrÅckt,  so  wird  der  Dialog  beendet.  Der
                      Knopf muû im Gegensatz zu selectExitObj nicht wieder
                      losgelassen werden.
hideTreeFlg
                      Das so gekennzeichnete Objekt und all seine Nachfolger
                      werden   von    einem    AESObjects.DrawObject    oder
                      AESObjects.FindObject ignoriert.
indirectFlg            Besagt,  daû  Object.spec  nicht  die  wirkliche  Objektbe~
                      schreibung, sondern nur einen Zeiger auf sie enthÑlt.

Folgende ObjektzustÑnde sind mîglich:

Bezeichner           Bedeutung
selectObj             Das Objekt wird invers dargestellt und gilt somit als an~
                      gewÑhlt
crossObj             Es wird ein Kreuz durch das Objekt gezeichnet
checkObj             Das Objekt wird mit einem Hacken versehen
disableObj            Das Objekt wird aufgehellt. Bezeichnet nicht anwÑhlbare
                      Objekte
outlineObj             Es wird ein Rahmen um das Objekt gezeichnet
shadowObj            Das Objekt erhÑlt beim Zeichnen einen Schatten.

Die Objektspezifikation enthÑlt grundsÑtzlich eine von zwei Strukturen. Entwe~
der ist sie ein Zeiger auf die eigentliche Beschreibung (zum Beispiel TEdInfo),
oder sie enthÑlt die Objektfarbe und die Randdicke des Objektes. Letzteres ist
5.7 Bibliothek: GEM                                                        5- 59
________________________________________________________


bei boxObj und iBoxObj der Fall, auûerdem gilt es auch fÅr boxCharObj, nur
wird hier zusÑtzlich noch der ASCII-Wert des Zeichens angegeben. Die Rand~
stÑrke kann Werte zwischen -128 und 127 annehmen, dabei wÑchst der Rand
bei positiven Werten nach innen und bei negativen nach auûen. Bei Objekten
vom Typ boxObj, iBoxObj, box CharObj und bei Objekten, die einen Zeiger auf
eine TEdInfo-Struktur als Spezifikation besitzen, besteht die Objektfarbe aus
folgenden Komponenten: Randfarbe, Farbe fÅr den Text, Schreibmodus fÅr die
Darstellung von Text (ist entweder deckend oder transparent), FÅllmuster und
FÅllfarbe. Es existieren 8 verschiedenen FÅllmuster, dabei stehen die Werte
von 1 bis 6 fÅr Punktmuster, die mit steigendem Wert immer dunkler werden.
0 bedeutet keine FÅllung und 7 vollstÑndiges FÅllen mit der FÅllfarbe.

Jetzt fehlt nur noch die Beschreibung fÅr die einzelnen Objektspezifikationen.


Die TEdInfo-Struktur

dient zur Beschreibung von edierbarem und nicht edierbarem Text. Ist der Text
nicht edierbar, so werden tmpltPtr und validPtr nicht ausgewertet.

Bezeichner           Bedeutung

textPtr               Zeiger auf die Zeichenkette, die den aktuellen Text ent~
                      hÑlt
tmpltPtr              Zeiger auf die Zeichenkette, die die Textmaske enthÑlt.
                      Der aktuelle Text wird dort in die Maske eingesetzt, wo
                      diese das '  '-Zeichen enthÑlt. Die dadurch erzeugte Zei~
                                  _
                      chenkette wird auf dem Bildschirm dargestellt
validPtr               Zeiger  auf  die  Zeichenkette,  die  bestimmt,  welche
                      Zeichen eingegeben werden dÅrfen. Dabei stehen folgende
                      Character fÅr die jeweils beschriebene Zeichenmenge:
                      9  -- Erlaubt die Ziffern von 0 bis 9
                      A -- Erlaubt alle Groûbuchstaben von A bis Z und das
                             Leerzeichen
                      a  -- Erlaubt Groû- und Kleinbuchstaben und das Leer-
                             zeichen
                      F  -- Erlaubt Filenamen  mit den Sonderzeichen "?", "*"
                             und ":"
                      P  -- Erlaubt Pfadnamen mit "Å", "?", "*" und ":"
                      p  -- Erlaubt Pfadnamen mit "Å", ":"
                      X  -- Erlaubt alle Zeichen
font                  Bestimmt den zu verwendenden Zeichensatz
                      (StandardFont oder SmallFont)
res1                  Reserviert fÅr zukÅnftige Anwendungen
just                   Bestimmt die Textausrichtung
color                 Bestimmt Farbe und Ñhnliches (siehe obige Beschreibung
                      der Objektfarbe)
5.7 Bibliothek: GEM                                                        5- 60
________________________________________________________


res2                  Reserviert fÅr zukÅnftige Anwendungen
thickness             RandstÑrke
textLen               MaximallÑnge  des  aktuellen  Textes  (abschlieûende  Null
                      mitzÑhlen)
tmpltLen              LÑnge der Textmaske (abschlieûende Null mitzÑhlen)


Die IconBlock-Struktur

bestimmt das Aussehen  von  Piktogrammen.  Das  Aussehen  des  eigentlichen
Bildchens wird durch zwei Bitmuster bestimmt, die Maske und die Daten. Dies
dient dazu, daû der Hintergrund nicht durchscheinen kann und das Objekt auch
im  invertierten  Zustand  anstÑndig  aussieht.  Die  Maske  wird  normalerweise
benutzt, um den Hintergrund dort zu lîschen, wo er nicht erwÅnscht ist; die
Daten bestimmen dann das eigentliche Aussehen des Icons.

Bezeichner           Bedeutung

mask                 Zeiger auf das Bitmuster der Maske
data                  Zeiger auf das Bitmuster der Daten
text                  Zeiger auf die Zeichenkette der Bildunterschrift
color                 Die 4 hîchstwertigen Bits enthalten den Farbindex fÅr die
                      gesetzten Datenbits, den Schriftzug und das Zeichen. Die
                      4 niederwertigen Bits geben den Farbindex fÅr die ge~
                      setzten Maskenbits und den Texthintergrund an
oneChar              ASCII-Wert des im Icon dargestellten Zeichens, ist er
                      gleich 0C, so wird nichts dargestellt
charPos              Position des Zeichens relativ zur Objektposition
iconFrame            Ausmaûe des Bitmusters. Die Position ist relativ zu der
                      des Objektes, auûerdem sollte die Breite ein Vielfaches
                      von 16 sein
textFrame            Ausmaûe des Schriftzuges. Positionsangabe ist relativ


Die BitBlock-Struktur

beschreibt ein einfaches Bitmuster.

Bezeichner           Bedeutung

data                  Zeiger auf das Bitmuster
bytes                 Breite des Bitmusters in Byte, dieser Wert muû gerade
                      sein
h                     Hîhe des Musters in Pixeln
x                     Horizontaler Offset, der es erlaubt, jedes beliebige Bit an
                      den linken Rand zu setzen
y                     Vertikaler Offset
5.7 Bibliothek: GEM                                                        5- 61
________________________________________________________


color                 Farbindex fÅr das Bitmuster


Die ApplBlock-Struktur

beschreibt ein selbstdefinierbares Objekt. Dies geschieht, indem eine Prozedur
angegeben wird, die das Objekt wahlweise zeichnet oder seinen Status Ñndert.
Der Prozedur kann ein 32 bit breiter Parameter Åbergeben werden, der das
Aussehen des Objektes nÑher beschreibt. Will man solch ein Objekt ohne die
Routinen des Moduls ObjHandler benutzen, so hat man darauf zu achten, daû
zum Zeitpunkt des Aufrufs  der  Zeichenprozedur  die  Registerbelegung  nicht
mehr den Modulakonventionen entspricht.

Bezeichner           Bedeutung

code                  Startadresse  der  Zeichenprozedur.  Die  Prozedur  be~
                      kommt beim Aufruf einen Zeiger auf einen ParmBlock-
                      Verbund Åbergeben.
parm                 Parameter fÅr die Prozedur


Das Konzept der AES-Menuleisten

Die Menuleisten werden mit Hilfe eines Objektbaumes dargestellt und sollten
mit dem Resource Construction Set erstellt werden. Die Routinen zum Benut~
zen der Pull-Down-Menus finden sich in dem Modul AESMenus. Die wichtigste
von ihnen ist MenuBar, mit ihr werden die Menus aktiviert und auch wieder
ausgeschaltet. Ein aktives Menu kann vom Anwender mit der Maus bedient
werden. Wird ein Menupunkt angewÑhlt, so erhÑlt man ein Nachrichtenereignis
mit der Kennung AESEvents.menuSelected.


Accessories

Accessories werden mit Hilfe der Prozedur AESMenus.RegisterAcc beim AES
angemeldet. Nach der Anmeldung erscheint der Titel des Accessory's in jedem
Menu und kann damit vom Benutzer angewÑhlt werden. Wird es selektiert, so
wird ihm eine Nachricht mit der Kennung AESEvents.accOpen gesendet, dabei
Åbergibt das AES zur Kontrolle die bei der Anmeldung erhaltene Accessory-
Kennung.
5.7 Bibliothek: GEM                                                        5- 62
________________________________________________________


Das Konzept der AES-Fenster

Fenster dienen zum Darstellen von Informationen, sie sind in ihrer Grîûe und
Position frei verÑnderbar und dÅrfen sich auch Åberlappen (Alle Prozeduren zur
Fensterbehandlung  findet  man  in  AESWindows).  Welche  Bedienungselemente
(Schieber,  Titelzeile  etc.)  ein  Fenster  besitzt,  wird  von  dem  Anwendungs~
programm wÑhrend der Anforderung einer Fensterkennung mit CreateWindow
festgelegt. ErhÑlt die Anwendung eine Kennung ungleich NoWindow, so war die
Anforderung  erfolgreich,  und  diese  Kennung  muû  dann  immer  als  erster
Parameter bei allen  Funktionen  angegeben  werden,  die  auf  diesem  Fenster
arbeiten  sollen.  Wird  ein  Fenster  nicht  mehr  benîtigt,  so  sollte  die
Fensterkennung mit DeleteWindow freigegeben werden.

Soll  das  Fenster  nun  auf  dem  Bildschirm  dargestellt  werden,  so  muû
OpenWindow aufgerufen werden. Es ist nun sichtbar, und die Anwendung muû
dafÅr sorgen, daû, sobald das AES eine entsprechende Nachricht schickt, der
Fensterinhalt erneuert wird. Soll das Fenster wieder verschwinden, so wird
dies  dem  AES  mittels  Close  Window  mitgeteilt.  Mit  OpenWindow  kann  es
daraufhin jederzeit wieder sichtbar gemacht werden, und der Ablauf beginnt
von Neuem. Wird ein Fenster geîffnet, in seiner Grîûe verÑndert oder ein
darÅberliegendes  Fenster  verschoben,  so  kann  es  passieren,  daû  plîtzlich
sichtbar werdende Fensterinhalte der Neuzeichnung  (redraw)  bedÅrfen.  Eine
solches  Ereignis  veranlaût  das  AES,  eine  Nachricht  zur  Neuzeichnung
AESEvents.windRedraw   zu   schicken.   Wird   diese   von   der   Anwendung
empfangen, so wird im Regelfall ein Aktualisieren des Fensters angekÅndigt und
der Mauszeiger versteckt. Jetzt wird die Rechteckliste vom AES geholt und
der angegebene Bereich neu gezeichnet. Schluûendlich  wird  der  Mauszeiger
wieder sichtbar gemacht und das Ende der Neuzeichnung gemeldet.

Die folgende Prozedur soll dies verdeutlichen; sie geht davon aus, daû dev eine
virtuelle Bildschirmarbeitsstation (siehe VDI) ist. Ihr wird die Fensterkennung
(handle) und der neuzuzeichende Bereich (frame) Åbergeben.
5.7 Bibliothek: GEM                                                        5- 63
________________________________________________________


PROCEDURE RedrawFrame (handle:CARDINAL;
                              frame:GrafBase.Rectangle);

VAR     clip : GrafBase.Rectangle;

BEGIN
               (* FÅllattribute fÅr 'Bar' bestimmen *)

  VDIAttributes.SetFillType (dev, VDIAttributes.solidFill);
  VDIAttributes.SetFillColor (dev, GrafBase.white);

               (* Aktualisierung ankÅndigen und Mauszeiger aus *)

  UpdateWindow  (TRUE);
  AESGraphics.GrafMouse (AESGraphics.mouseOff, NIL);

               (* 1. Element der Reckteckliste holen *)

  clip:=WindowRectList (handle, firstElem);

  WHILE clip.w # 0 DO      (* 'w = 0' kennzeichnet Listenende *)

               (*  Schnittbereich ermitteln und
                *  Ausgabebereich beschrÑnken
                *)
     clip:=GrafBase.ClipRect (frame, clip);
     VDIControls.SetClipping (dev, clip);

     VDIOutputs.Bar (dev, clip);  (* Bereich mit Weiû fÅllen *)

         (*  Hier kînnen noch andere Sachen gezeichnet werden *)

                (* NÑchstes Element der Rechteckliste holen *)

     clip:=WindowRectList (handle, nextElem);

  END;

  VDIControls.DisableClipping (dev);        (* Clipping aus *)

               (* Mauszeiger ein und Aktualisierungsende melden *)
  AESGraphics.GrafMouse (AESGraphics.mouseOn, NIL);
  UpdateWindow (FALSE);
END RedrawFrame;
5.7 Bibliothek: GEM                                                        5- 64
________________________________________________________


Die Funktion der anderen (Fenster betreffenden) Nachrichten kann im Definitions~
modul AESEvents und im Abschnitt Åber Ereignisse nachgelesen werden.

Neben den oben beschriebenen Fenstern existiert noch ein weiteres. Es ist das
Desktop-Fenster, welches die Kennung DeskHandle besitzt. Neuzeichnungen des
Desktops mÅssen nicht von der Anwendung durchgefÅhrt werden, sie sind Auf~
gabe des AES. Dies hat natÅrlich den Nachteil, daû das Aussehen des Desk~
tops im wesentlichen immer gleich ist. Dieser Nachteil wurde dadurch ausge~
schaltet, daû es mîglich ist, einen beliebigen Objektbaum mit SetNewDesk als
DesktopoberflÑche zu benutzen.

Bei allen Aufgaben, die von der Grîûe des Desktops abhÑngen, sollten eben
diese Ausmaûe durch einen Aufruf von WindowSize (DeskHandle, workSize)
ermittelt werden.  Es  wird  die  Bildschirmgrîûe,  abzÅglich  der  Menuzeile,  in
Pixeln geliefert.


Das Konzept der AES-Ereignisse

Die Ereignisse stellen meist Aktionen des Anwenders dar und werden mit den
Routinen des Moduls AESEvents Åberwacht. Es existiert die Mîglichkeit, die
Ereignisse entweder einzeln oder zusammen  zu  Åberwachen.  Letzteres  ge~
schieht durch MultiEvent und wird meist benutzt. Dabei stehen die folgenden
Ereignisse zur Auswahl:

keyboard -- Das Tastatur-Ereignis tritt ein, sobald eine Taste gedrÅckt wird.
Als  Ergebnis  wird  sowohl  der  IBM-Scan-Code  der  Taste  als  auch  deren
ASCII-équivalent, falls vorhanden, geliefert (siehe GEMGlobals.GemChar).

mouseButton -- Ein Mausknopf-Ereignis tritt auf, sobald eine vorher bestimmte
Kombination  der  Maustasten  gedrÅckt  ist.  Die  Maske  bestimmt,  welche
Mauskîpfe berÅcksichtigt werden sollen (Ist sie die leere Menge, so tritt das
Ereignis  auf  alle  FÑlle  ein).  Der  Status  bestimmt  nun,  welche  Knîpfe  der
Maske  gedrÅckt  sein  mÅssen,  damit  das  Ereignis  auftritt.  Auûerdem  kann
angegeben  werden,  auf  bis  zu  wie  viele  solche  sich  schnell  wiederholende
ZustÑnde  gewartet  werden  soll  (Anzahl  der  Mausklicks).  Die  minimale
Wiederholgeschwindigkeit  kann  mit  SetDClickSpeed  eingestellt  werden.  Als
Ergebnis liefert dieses Ereignis die Position der Maus, die zur Zeit gedrÅckten
Maustasten und Sondertasten der Tastatur und auûerdem, wie oft der Zustand
der Maustasten eingetreten ist (Mausklicks).

firstRect, secondRect -- Ein Maus-Ereignis tritt auf, sobald sich der Mauszei~
ger innerhalb oder auûerhalb eines bestimmten Rechteckbereichs befindet. Als
Ergebnis erhÑlt man die Position des Zeigers, die gedrÅckten Mausknîpfe und
Sondertasten der Tastatur (Dies sind <Alternate>, <Control> und  die  beiden
<Shift>-Tasten).
5.7 Bibliothek: GEM                                                        5- 65
________________________________________________________


timer -- Das Zeitgeber-Ereignis erfÅllt zwei verschiedene Funktionen. Erstens
kann die Anwendung es dazu nutzen, nach einer  gewissen  Zeitspanne  eine
Meldung zu erhalten, und zweitens kînnen damit andere Prozesse Rechenzeit
zugeteilt  bekommen.  Letzteres  nutzt  im  aktuellen  Betriebssystem  aber  nur
Accessories etwas.

message  --  Nachrichten-Ereignisse  dienen  zur  Kommunikation  mit  anderen
Prozessen, in der Regel dem AES oder einem Accessory. Ein solches Ereignis
fÅllt ein varianten Verbund vom Typ MessageBuffer, der im ersten Wort immer
die Art der Nachricht, im zweiten die Applikationsnummer des Senders und im
dritten die Anzahl der Bytes, die Åber die 16 Standardbytes hinausgehen, ent~
hÑlt.

Der Bezeichner fÅr die Applikations-Identifikationsnummer endet immer auf Id
und der fÅr die Åber 16 hinausgehenden Bytes auf Rmd (siehe MessageBuffer).

Es existieren folgende Nachrichtentypen:

unspecMessage  --  Bezeichnet  eine  nicht  vom  AES,  sondern  von  einer
beliebigen anderen Anwendung kommende Nachricht. In uMsgData steht  der
Anfang  der  Nachricht,  deren  Format  vom  Sender  abhÑngt.  Mîglicherweise
folgen noch mehr als die 16 normalen Bytes, die dann mit AESMisc.ApplRead
gelesen werden mÅssen.

menuSelected -- Diese Nachricht wird gesendet, nachdem der Anwender einen
Eintrag in einem Menu angewÑhlt hat. In selTitle steht der Index des Titels, in
dem sich der Menupunkt befindet, und in selItem steht der Index des Eintrags.
Der Menutitel muû vom Programm mit AESMenus.NormalTitle wieder normal
dargestellt werden.

windRedraw  --  Diese  Nachricht  besagt,  daû  ein  Fensterausschnitt  neu
gezeichnet werden muû (siehe auch Abschnitt Åber Fenster). Dabei steht in
rdrwHdl die Kennung des Fensters, welches aktualisiert werden soll, und in
rdrwFrame der neu zu zeichnende Rechteckbereich.

windTopped  --  Eine  Nachricht  dieser  Art  zeigt  an,  daû  ein  Fenster  vom
Anwender angeklickt wurde und es deshalb noch oben gebracht werden soll.
Dadurch  wird  es  aktiv,  das  heiût,  seine  Randelemente  werden  dargestellt.
topHdl enthÑlt die Kennung des angewÑhlten Fensters.

windClosed -- Solch eine Nachricht wird gesendet, nachdem der Anwender auf
die Schlieûbox (links oben) eines Fensters geklickt hat. Daraufhin sollte das
Fenster mit der Kennung clsHdl geschlossen werden.

windFulled -- Diese Nachricht besagt, daû die Vergrîûerungsbox (rechts oben)
des Fensters, mit der Kennung fullHdl, angeklickt wurde. Das Fenster sollte
nun in seiner Maximalgrîûe dargestellt werden.
5.7 Bibliothek: GEM                                                        5- 66
________________________________________________________


windArrowed -- Es wird mitgeteilt, daû der Benutzer auf einen Scroll-Pfeil
oder  einen  Schieber  geklickt  hat,  und  daû  der  Inhalt  des  entsprechende
Fensters (arrwHdl) jetzt verschoben werden sollte, wie es arrwMode angibt.

windHSlid -- Besagt, daû der Schieber des Fensters mit der Kennung hSldHdl
in  die  von  horPos  spezifizierte  Position  gebracht  wurde.  Der  Inhalt  des
Fensters sollte daraufhin entsprechend verÑndert werden. Die Positionsangabe
erfolgt in Promille (siehe auch  WSliderValue)  und  gilt  fÅr  den  horizontalen
Schieber.

windVSlid  --  Entspricht  windHSlid,  allerdings  ist  die  Angabe  nun  fÅr  den
vertikalen  Schieber  gedacht.  Die  Kennung  ist  vSldHdl  und  vertPos  ist  die
Position.

windSized -- Diese Nachricht wird gesendet, nachdem der Benutzer die Grîûe
eines  Fensters  verÑndert  hat.  In  sizeHdl  steht  die  Fensterkennung  und  in
sizeFrame  befinden  sich  die  neuen  Fensterausmaûe.  Zum  Zeitpunkt  dieser
Nachricht  hat  das  Fenster  noch  die  alte  Grîûe,  die  neue  muû  erst  noch
gesetzt werden.

windMoved  --  Zeigt  an,  daû  das  Fenster,  welches  die  Kennung  moveHdl
besitzt, verschoben wurde. Die neue Position, die erst noch gesetzt werden
muû, steht in moveFrame.

windNewTop -- Solch eine Nachricht wird gesendet, nachdem das Fenster mit
der Kennung nwTpHdl nach oben gebracht wurde.

accOpen  --  Diese  Nachricht  erhÑlt  ein  Accessory,  nachdem  der  ihm
zugeordnete  Menutitel  angewÑhlt  wurde.  Die   Identifikationsnummer   des
Accessories wird in aOpnMId geliefert. aOpnVoid dient nur als Platzhalter.

accClose -- Hiermit wird einem Accessory mitgeteilt, daû es vom Bildschirm
verschwinden muû. Dieser Fall kann eintreten, falls die laufende Anwendung
terminiert, der Bildschirm gelîscht wird oder die AES-Fensterbibliothek  neu
initialisiert wird.


Mit Hilfe der AESMisc.ApplWrite-Routine kann einer Anwendung eine Nachricht
Åbermittelt werden. Damit diese korrekt ankommt, muû die Applikationsnummer
des EmpfÑngers angegeben werden und dieser muû auf ein Nachrichtenereignis
warten. Die Applikationsnummer einer Anwendung kann mit Hilfe von AESMisc.
ApplFind ermittelt werden. Das  erste  Wort  der  Nachricht  sollte  den  Wert
unspecMessage besitzen, das zweite die Identifikationsnummer  des  Senders
und das dritte die  LÑnge  der  Nachricht  minus  16  Byte,  falls  die  Gesamt~
nachricht lÑnger als 16 Byte ist.
5.7 Bibliothek: GEM                                                        5- 67
________________________________________________________


MEGA-GEM oder 'Eine Modula-Anpassung des GEM'

Die  vorliegende  GEM-Bibliothek  ist  nicht  einfach  eine  Konvertierung  der
bekannten  C-Vorlagen,  sondern  sie  paût  GEM  an  Modula  an  und  nicht
umgekehrt. Dies hat den Nachteil, daû alte Programme nicht ganz so einfach
zu Åbernehmen sind, bietet dafÅr aber die Vorteile,

-- daû  die  Programme  sehr  viel  Åbersichtlicher  werden,  da  erstens  die
    Namensgebung  aussagekrÑftiger  ist  und  zweitens  sinnvolle  Verbunde
    geschaffen wurden, so daû die Prozeduren weniger Parameter besitzen und
    zum Beispiel bei der Beschreibung eines Punktes nicht mehr die x- und die
    y-Komponente  getrennt  deklariert  werden  mÅssen,  sondern  eine  einzige
    Variable vom Typ Point ausreicht;

-- daû ein Programm, das wÑhrend der Testphase abstÅrzt, ohne sich vorher
    beim GEM abzumelden, nicht gleich das gesamte System mit sich reiût,
    sondern  die  erforderlichen  Abmeldungen  automatisch  von  der  Bibliothek
    ausgefÅhrt werden;

-- daû der Benutzer sich  an  die  Programmierung  selbstdefinierter  Objekte
    oder Interruptvektoren wagen kann, ohne  erst  einmal  die  Innereien  des
    Rechners und die Funktionsweise des Mikroprozessors zu studieren;

-- daû Fehler im Programm frÅhzeitig vom Laufzeitsystem erkannt werden,
    weil eine Variable den Bereich eines AufzÑhlungstypen verlassen hat (was
    oft das Neubooten des Rechners erspart);

-- daû die Programmierung einfach komfortabler geworden ist.

Wie oben erwÑhnt, wird bei der Terminierung eines Programmes, egal ob diese
gewollt  oder  ungewollt  ist,  dafÅr  gesorgt,  daû  eventuell  noch  ausstehende
Abmeldungen  beim  GEM  durchgefÅhrt  werden.  Dies  beinhaltet  zum  Beispiel
auch, noch aktive Fenster zu schlieûen und abzumelden oder den Mauszeiger
wieder sichtbar zu machen. Dabei werden nur solche Aktionen aufgehoben, die
unter der Modulkennung des terminierenden Moduls vorgenommen wurden. Da
es  aber  Modulen  gibt,  bei  denen  diese  automatische  Abmeldung  nicht
gewÅnscht  ist,  zum  Beispiel  residente  oder  Systemmodulen,  gibt  es  die
Mîglichkeit, sich mit GEMEnv.SysInitGem anzumelden und damit eine Kennung
zu erhalten, die vor der Abmeldung geschÅtzt ist. Die An-  und  Abmeldung
geschieht in der Regel folgendermaûen:
5.7 Bibliothek: GEM                                                        5- 68
________________________________________________________


IMPORT GEMEnv;
FROM GEMGlobals IMPORT RC;

VAR      dev      : GEMEnv.DeviceHandle;
         gemHdl  : GEMEnv.GemHandle;
         success : BOOLEAN;

BEGIN
     (*  Anmelden.  Gleichzeitig erhÑlt man in 'dev' die GerÑte-
      *                 kennung fÅr eine virtuelle Arbeitsstation.
      *)

  GEMEnv.InitGem (RC, dev, success);
  IF success THEN (* Falls Anmeldung erfolgreich war, dann ...*)

                                     (* Eigene GEM-Kennung ermitteln *)

     gemHdl:=GEMEnv.CurrGemHandle ();
          .
          .                         (* Hauptprogramm ausfÅhren *)
          .
     GEMEnv.ExitGem (gemHdl); (* Abmelden *)

  ELSE

     (*  User mitteilen,
      *  daû Anmeldung beim GEM
      *  nicht erfolgreich war.
      *)

  END;
END ... .


Der Aufruf von InitGem ersetzt die Einzelaufrufe zur Anmeldung beim AES
(appl init) und das  ôffnen  einer  "virtual  workstion"  (v opnvwk)  beim  VDI.
     _                                                      _
Wenn  Sie  aber  keine  VDI-Funktionen  aufzurufen  haben  -  das  kommt
beispielsweise oft bei Accessories vor - kînnen Sie mit GemEnv.InitApplication
nur die AES-Anmeldung durchfÅhren. Mit GemEnv.OpenDevice kînnen Sie dann
immer noch nachtrÑglich das ôffnen der des Bildschirms beim VDI nachholen.
Mehr dazu im Definitionstext von GemEnv.
5.7 Bibliothek: GEM                                                        5- 69
________________________________________________________


Zur Fehlerbehandlung ist folgendes zu sagen. Tritt zum Beispiel ein Fehler auf,
weil ein ARRAY OF CHAR Åbergeben wurde, das zu wenig Elemente enthÑlt, so
wird ein ganz normaler Laufzeitfehler  ausgelîst,  in  diesem  Fall  ein  'String
Overflow'. Tritt der Fehler aber innerhalb einer ROM-Routine des GEM auf, so
meldet diese den Fehler in der Regel mit Hilfe eines INTEGER-Wertes. Dieser
Wert wird nicht direkt an das aufrufende Modul weitergeleitet, sondern der
Fehler  muû  von  diesem  durch  den  Aufruf  von  GEMEnv.GemError  erkannt
werden.  Ist  dies  geschehen,  so  kann  der  eigentliche  INTEGER-Wert  mit
GEMEnv.ErrorNumber  ermittelt  werden.  Tritt  ein  Fehler  auf,  der  nicht  mit
GemError abgefragt wird, so wird eine Fehlerroutine ausgefÅhrt. NÑheres dazu
im Defintionsmodul GEMEnv (Anhang B).

Die Aufteilung der einzelnen Routinen auf die Module entspricht der logischen
Anordnung  innerhalb  des  GEM.  Lediglich  die  Routinen  des  "Application
Manager", des "File Selector Manager", des "Scrap Manager" und des "Shell
Manager" sind in AESMisc zusammengefaût, da diese "Manager" sehr wenig
Routinen  enthalten.  Auûerdem  befinden  sich  alle  Initialisierungsroutinen  in
GEMEnv. Die Namen sind normalerweise an die orginal C-Namen angelehnt, so
daû sich ein GEM-gewohnter Programmierer innerhalb kurzer Zeit zurecht~
finden sollte.


Eine Stufe Åber GEM

Ein Grund fÅr eine BenutzeroberflÑche nach Art des GEM ist wohl, daû sich
der Programmierer einer Anwendung nicht mehr mit den Details der Ein- und
Ausgabe befassen muû. In diesem Bereich ist der Schuû beim GEM ein wenig
nach hinten losgegangen. Der Programmautor muû zwar nicht unbedingt wissen
wieviele Pixel zur Laufzeit auf dem Bildschirm vorhanden sind, doch ist er oft
mit  der  Bedienung  des  GEM  so  beschÑftigt,  daû  er  fÅr  sein  eigentliches
Problem kaum noch Zeit hat.

Um  diesen  Makel  ein  wenig  zu  beheben,  gibt  es  sieben  Module,  die  den
Umgang mit GEM ein wenig erleichtern sollen. Als erstes soll der ObjHandler
erwÑhnt werden. Dieses Modul ermîglicht es, die ObjektbÑume auf einer Ebene
zu  bearbeiten,  auf  der  es  nicht  nîtig  ist,  genau  Åber  die  Abbildung  der
Struktur im Speicher informiert zu sein. Es genÅgt, die einzelnen Objektbaum~
elemente  und  ihre  Funktion  zu  kennen.  Auch  die  Typwandlungen  und
-transformationen werden fÅr die einzelnen Variablen selbstÑndig durchgefÅhrt
(siehe auch Abschnitt Åber ObjektbÑume). Sozusagen als kleines Bonbon ist es
mit dem ObjHandler auch sehr einfach, die Mîglichkeit der selbstdefinierbaren
GEM-Objekte zu nutzen.

Das zweite Modul heiût EventHandler und nimmt dem Programmierer einen Teil
der  immer  wiederkehrenden  Tipparbeit  bei  der  Ereignisverwaltung  ab.  Es
werden fÅr jedes Ereignis einfach Prozeduren angemeldet, deren Verwaltung
vom EventHandler Åbernommen wird. Tritt nun ein Ereignis auf, so werden die
5.7 Bibliothek: GEM                                                        5- 70
________________________________________________________


zugehîrigen Prozeduren mit den entsprechenden Parametern aufgerufen. Dabei
gibt es auch die Mîglichkeit, Prozeduren anzumelden, die den Ereignisstrom
aller Module, die diese GEM-Bibliothek benutzen, Åberwachen und filtern kînnen.

Des weiteren gibt es das Modul TextWindows, das, wie der Name schon sagt,
die Verwaltung von Textfenstern Åbernimmt. Ein solches Textfenster wird von
dem   Anwendungsprogramm   wie   ein   ganz   gewîhnlicher   Textbildschirm
behandelt,  das  heiût  die  Prozeduren  entsprechen  denen  von  Terminal.  Alle
Operationen, wie das Reagieren auf Mausoperationen des Anwenders und das
Neuzeichnen  des  Fensterinhaltes  werden  von  TextWindows  automatisch
durchgefÅhrt. Als kleines Extra ist es damit mîglich, einzelne Zeichen vom
Benutzer mit Hilfe des Mauszeigers anwÑhlen zu lassen. So kann man z.B.
Textbereiche aus einem Fenster herausziehen lassen oder sie markieren.

Ein weiteres Modul trÑgt den Namen EasyGEM0 und enthÑlt eine Reihe von
Routinen, die bei der GEM-Programmierung des îfteren gebraucht werden. Die
Programmierung von Dialogboxen wird durch Routinen unterstÅtzt, die eine Box
darstellen,  einzelne  Objekte  animieren  und  die  Box  zum  Schluû  wieder
entfernen. Einfache Dialoge kînnen sogar mit einem einzigen Prozeduraufruf
abgehandelt  werden.  Auûerdem  gibt  es  Prozeduren,  die  die  Objekte  von
Dialogboxen mit Startwerten vorbelegen und die Ergebnisse auslesen.

EasyGEM1  stellt  Funktionen  zum  Verwalten  eines  Clipboards  und  einen
komfortablen Aufruf der Dateiauswahlbox (FileSelector) zur VerfÅgung.

Das Modul WindowBase dient zum Verwalten von Fenstern beliebigen Inhalts.
Das Verhalten und der  Inhalt  der  Fenster  wird  durch  eine  Reihe  von  frei
wÑhlbaren  Prozedurvariablen  bestimmt.  Die  gesamte  Fensterverwaltung  ist
dabei  weitgehend  automatisiert  worden,  so  daû  das  Programmieren  von
Fenstern mîglichst einfach  und  ohne  zuviel  Programmieraufwand  geschehen
kann.  Dennoch  wurde  darauf  geachtet,  daû  dem  Anwender  gegenÅber  den
AES-Fenstern mîglichst keine Gestaltungsmîglichkeiten verschlossen wurden.
Auch die Systemmodule WindowLists und TextWindows bauen auf WindowBase
auf.

WindowLists verwaltet Listen in einem Fenster, dies nutzt die  Modula-Shell
zum Beispiel fÅr ihre Directory-Fenster. Das  Modul  kann  immer  verwendet
werden,  wenn  eine  Liste  gleichartiger  Daten  zeilenweise  in  einem  Fenster
dargestellt werden soll, dabei wird jedem Datum eine Zeile zugeordnet.


Und ganz unten...

Wollen  Sie  selbst  AES-  oder  VDI-Funktionen  aufrufen,  entweder  weil  Sie
selbst die Kontrolle haben wollen oder weil eine neue GEM-Funktion in unserer
GEM-Bibliothek noch nicht zur VerfÅgung steht, benutzen Sie dazu das Modul
GEMBase (s. DEMO-Ordner: AESDemo & VDIDemo).
