3.1  Megamax Modula: Sprachumfang                                     3 -  1
________________________________________________________


3.  Programmieren in Megamax Modula-2

3.1     Sprachumfang

In diesem Kapitel wird detailliert beschrieben, welchen 'Dialekt' von Modula-2
der Megamax Modula-Compiler Åbersetzt und wo es bei anderen Compilern
Abweichungen geben kann. Bevor wir damit anfangen, wollen wir aber kurz
erzÑhlen, warum dieses Kapitel eigentlich nîtig ist  (wenn  Sie's  eilig  haben,
dÅrfen Sie auf der nÑchsten Seite weiterlesen).


Der Wirth'sche Standard (PIM-Standard)

Schîn wÑr's ja, wenn jeder unter 'Modula-2' ganz genau die gleiche Program~
miersprache verstehen wÅrde: Programme kînnten ohne énderung von anderen
Rechnern Åbernommen werden; wer auf einem Computer Modula gelernt hat,
kînnte jederzeit einen anderen programmieren... Die erste Definition von Modula-2
von Niklaus Wirth war tatsÑchlich schîn genau festgelegt. Trotzdem waren
nicht alle Benutzer mit dieser Definition einverstanden: Sie war nÑmlich maû~
geschneidert fÅr Wirths 'Lilith'-Computer, der z. B. nur 16 Bit-Adressen kannte
und keine Bytes adressieren mochte (also auch ASCII-Zeichen groûzÅgig in 16
Bit-Worten unterbrachte).

Von  verschiedenen  Anwendern,  die  Modula-2  auch  auf  anderen  Computern
verwenden  wollten,  lieû  sich  N.  Wirth  schlieûlich  Åberzeugen,  daû  die
Sprachdefinition etwas flexibler auf die jeweils vorhandene Hardware angepaût
werden mÅûte: FÅr die 68000-CPU brauchen wir eben 32 Bit-Adressen, mit
denen wir auch rechnen wollen; ASCII-Zeichen sollten hier in Bytes gespeichert
werden. Bei dieser Erweiterung der Sprachdefinition entschloû man sich, auch
gleich einige andere Kleinigkeiten zu Ñndern. Das Ergebnis war die 'Revision'
von Modula-2. Dann kam  eine  dritte  Auflage  des  Buchs  Programmieren  in
Modula-2, die nun allgemein als der aktuelle Standard betrachtet wird (man
bezeichnet in  auch  nach  der  dritten  Auflage  als  PIM-3  Standard).  JÅngst
erschien noch eine  vierte  Auflage,  die  aber  weniger  anerkannt  wurde,  vor
allem,  weil  sie  einige  gravierende  énderungen  (Strings,  INTEGER)  mit  sich
brachte. öbrigens stÅtzt sich auch der ISO-Standard (s.u.) auf PIM-3.

Auf diese Weise gibt es also in verschiedenen Modula-Implementationen nicht
nur  kleine  Abweichungen  je  nach  Zielrechner,  sondern  auch  noch  mehrere
PIM-Revisionen. Zudem verfÅgen viele Compiler, auch Megamax, Åber eigene
Erweiterungen in der Sprache.

Wollen Sie also portabel programmieren, damit Ihre Programme spÑter auch
auf anderen Compilern oder Rechnern mit wenig oder gar keinem Aufwand zum
Laufen zu bringen sind, mÅssen Sie sich Åber den PIM3-Standard  und  die
speziellen Erweiterungen im klaren  sein.  Aber  zuvor  noch  ein  Vorgriff  auf
einen neuen Standard, der das alles lîsen soll:
3.1  Megamax Modula: Sprachumfang                                     3 -  2
________________________________________________________


Der ISO-Standard

In naher Zukunft (ca. Anfang '91) wird ein  internationaler  Modula-Standard
definiert sein (der sogenannte ISO-Standard). Darin wird versucht, sowohl die
verschiedenen Revisionen und Ungenauigkeiten von N.Wirth zu klÑren, als auch
Sprache  und  Bibliotheken  an  die  Erfordernisse  der  realen  Computerwelt
anzupassen.  Nur  wenige  Erweiterungen  wurden  aufgenommen,  weil  man
erstmal Wirths Modula standardisieren wollte, anstatt gleich eine neue Sprache
zu schaffen. Allerdings waren einige énderungen an der Sprache notwendig,
um  beispielsweise  die  Idee  der  Verdeutlichung  von  unportablen,  rechner~
abhÑngigen Elementen durch Importe aus dem Modul SYSTEM konsequent zu
Ende zu fÅhren: Typen-Wandlung ist demnach nicht mehr implizit durch die
Funktionsschreibweise von Typen (Bsp: INTEGER (TRUE) ) sondern nur noch
mit Hilfe der Funktion CAST aus SYSTEM mîglich. Ebenso wird BITSET aus
SYSTEM kommen, statt den diversen WORD und BYTE-Jokertypen wird es nun
LOC geben usw.

Wichtig ist auch folgendes: Als Standard-Typen fÅr ganze Zahlen werden nur
noch INTEGER und CARDINAL existieren, extra Long-Typen wie LONGCARD/
LONGINT sind nicht vorgesehen. Dies hat den Vorteil, daû man sich nicht beim
Portieren  auf  einen  anderen  Rechner  mit  diesen  an  sich  gleichen  Typen
herumschlagen muû - man verwendet immer automatisch den grîûtmîglichen
Bereich, den der Rechner bietet. Wenn der zu gering ist, ist das Programm
dort sowieso nicht anwendbar.

Damit die Effizienz bei Rechnern wie Atari ST oder IBM PC nun nicht absinkt,
wird  empfohlen,  in  Zukunft  mîglichst  Unterbereichs-Typen  zu  verwenden.
Werden beispielweise nur Bereiche von 0 bis 1000 benîtigt, deklariere man die
Variablen entsprechend und der Compiler ist dann in der Lage, wie gewÅnscht
intern mit 16 Bit-Zahlen (also den bisherigen SHORTCARDs) zu rechnen - die
Effizienz bleibt erhalten, kann teilweise sogar steigen.

FÅr besondere FÑlle, in denen unbedingt feste Grîûen benîtigt werden, dÅrfen
Compiler bisherige Typen wie SHORTINT oder LONGCARD dann aus SYSTEM
exportieren.

Wir  Megamax-Entwickler  sind  selbst  im  DIN-Arbeitskreis,  der  deutschen
Abteilung fÅr die ISO-Normungsgruppe, engagiert und sind deshalb immer auf
dem laufenden. Wir haben schon jetzt einige der ISO-Erweiterungen vorweg~
genommen,  und  zwar  nur  soweit,  daû  sie  sich  nicht  mit  dem  bisherigen
PIM-Standard bzw. den Megamax-Erweiterungen beiûen.

Erst,  wenn  der  Standard  offiziell  wird,  werden  wir  ein  neues,  vollstÑndig
ISO-konformes System fertigstellen und ausliefern. Dann mÅssen Sie nochmals
mit énderungen rechnen, dafÅr aber zum letzten Mal. Wir werden uns zudem
3.1  Megamax Modula: Sprachumfang                                     3 -  3
________________________________________________________


bemÅhen,  optional  die  alten,  bisherigen  Konventionen  beizubehalten,  um  bei
schon vorhandenen Programmen den  Anpassungsaufwand  mîglichst  klein  zu
halten.


Standard gegen Erweiterungen

Nun erfahren Sie, wie Sie beides auseinander halten kînnen. Das beste wÑre
natÅrlich, Sie lesen das Buch PIM-3 besonders aufmerksam und auch zwischen
den Zeilen. Dann warten Sie noch auf den ISO-Standard, lernen den  auch
kennen, und schon kennen Sie alle TÅcken. Wir haben das aber schon fÅr Sie
durchgemacht und greifen Ihnen deshalb unter die Arme.

Im gesamten Kapitel 3, das als Referenz zur Sprache des Megamax-Compilers
dient, heben wir alle besonderen ISO- bzw. Megamax-Erweiterungen durch den
Hinweis  ISO-Erweiterung  bzw.  Megamax-Erweiterung  in  der  Beschreibung
hervor.

Megamax-Erweiterungen sind selbstverstÑndlich schwerer portabel, wenn auch
viele dieser Besonderheiten bei anderen Compilern ebenfalls als Erweiterung zu
finden  sind  (Bsp:  REF-Parameter),  wÑhrend  ISO-Erweiterungen  in  Zukunft
sicher kein Portierungs-Problem mehr sein dÅrften. ISO-Erweiterungen  sind
bis zum ISO-Standard ansonsten als Megamax-Erweiterungen zu verstehen.

Lediglich die Datentypen LONGCARD/LONGINT werden nicht hervorgehoben, sie
sind praktisch bei jedem 16/32 Bit-Compiler vorhanden.

Der Inline-Assembler (Kapitel 4) ist selbstverstÑndlich auch  eine  Megamax-
Erweiterung, ebenso sind die Compiler-Direktiven speziell auf das Megamax-
System zugeschnitten und deshalb nicht ohne weiteres portabel!
3.1  Megamax Modula: Sprachumfang                                     3 -  4
________________________________________________________


öbersicht Åber EinschrÑnkungen, Abweichungen und Erweiterungen

Megamax  Modula-2  erfÅllt  den  Modula-Standard  nach  "Programmieren  in
Modula-2", 3. Auflage, mit folgenden Unterschieden:

EinschrÑnkungen
    * TSIZE erlaubt zwar sog. Tag-Felder, ignoriert sie z.Zt. aber.
    * Durch den 1-Pass Compiler sind teilweise FORWARD-Deklarationen nîtig,
      alle anderen Bezeichner mÅssen vor ihrer Benutzung deklariert werden
      (implizite Forward-Deklarationen sind jedoch bei POINTER TO sowie bei
      Parametern von Prozedurtypen erlaubt).
Erweiterungen
    * Diverse  Erweiterungen  aus  dem  kommenden  internationalen  ISO-
      Standard fÅr Modula-2, z.B. LOC, INT, BITNUM, LENGTH.
    * Aggregate (Datenverbunde von Feldern und Records in einem StÅck).
    * Mehrdimensionale offene Felder (Open Arrays)
    * Deklaration von Register-Variablen
    * Funktionen LONG und SHORT.
    * REF-Parameter (auch sog. CONST-Parameter)
    * SYSTEM-Funktionen CODE, LOAD, STORE, DEREF
    * Datentypen LONGCARD, LONGINT, SHORTCARD, SHORTINT, BYTE.
    * Funktionsprozeduren kînnen beliebig groûe Datenstrukturen zurÅckgeben.
    * Bezeichner dÅrfen den Unterstrich (" ") enthalten.
                                             _
    * Variablen sind auf feste Adressen ablegbar.
    * Bedingte Compilierung.
    * Direktes Einbinden von Assembler-Instruktionen mîglich.
    * EXPORT in Def-Modulen weiterhin mîglich (s. PIM, 1. & 2. Auflage).
    * Long-Konstanten mit "D" oder "L" als Kennung optional.
    * Hexadezimale Werte auch durch AnfÅhren von "$" mîglich.

Datengrîûen
    * GrîûenbeschrÑnkungen:
         - Kontrollstrukturen im Code (IF - END, WITH - END, usw.) kînnen
           maximal  32  KB  LÑnge  haben.  Bedingt  dadurch  sind  Prozeduren
           meist auf diese Grîûe beschrÑnkt.
         - SETs erlauben bis zu 65536 Elemente.
         - String-Konstanten fassen bis zu 256 Zeichen.
         - Die  formalen  Parameter  kînnen  bis  zu  32  KB  auf  dem  Stack
           belegen, Open Arrays sind jedoch unbeschrÑnkt.
    * Ansonsten gibt es keine BeschrÑnkungen, insbesondere bei
         - Modulen,
         - strukturierten Daten (ARRAYs & RECORDs)
         - VAR-Parametern und Open Arrays (auch by value),
         - lokalen Variablen & Stack,
         - RÅckgabe von Strukturen bei Funktionen,
         - AufzÑhlungen (maximal 65536 Elemente),
         - Konstanten (auch Aggregate).
3.1  Megamax Modula: Sprachumfang                                     3 -  5
________________________________________________________


Standardprozeduren

Hinweise:
  NumberType  sind alle Ganzzahl-Typen (CARDINAL, INTEGER, usw.)
  OrdinalType   sind die Ganzzahlen, sowie CHAR, BOOLEAN und AufzÑhlungen
  ScalarType   nennen wir Ordinale plus POINTER

ABS (x: INTEGER/LONGINT/ REAL): ArgumentType;
    Liefert den Absolutwert (Betrag) des Arguments. Das Ergebnis ist vom
    gleichen Typ wie das Argument.

CAP (ch: CHAR): CHAR;
    Konvertiert Kleinbuchstaben in die entsprechenden Groûbuchstaben (auch die
                                                                   >
    landesspezifischen Umlaute werden berÅcksichtigt - z.B. Ñ - é ).

CHR (c: CARDINAL): CHAR;
    Liefert das Zeichen mit der Ordnungszahl c.

DEC (VAR x: ScalarType; n: NumberType);
    Vermindert x um n. Fehlt n, wird 1 dafÅr eingesetzt. Der Typ von x kann
    jeder Skalar sein, d.h. INTEGER/CARDINAL, entsprechende LONG-Typen,
    Unterbereiche  davon,  AufzÑhlungstypen,  CHAR,  BOOLEAN  und  POINTER
    (Megamax-Erweiterung) (POINTER werden immer um n und nicht etwa um
     die  Elementgrîûe  vermindert).  Ist  x  INTEGER  oder  LONGINT,  muû  n
     ebenfalls von einem dieser Typen sein, ansonsten ist ein CARDINAL oder
     LONGCARD gefordert.

DISPOSE (VAR x: PointerType);
    Gibt mit NEW belegten Speicher wieder frei. DISPOSE wird vom Compiler
    durch DEALLOCATE (x, SIZE (x^)) ersetzt (s. a. NEW).

EXCL (VAR s: SetType; i: OrdinalType);
    Entfernt Element i aus der Menge s.

FLOAT (x: NumberOrRealType): REAL;
    Liefert  die  Darstellung  des  Wertes  x  als  REAL.  Nach  PIM  sind  nur
    CARDINALs als Argument erlaubt, wir erlauben aber auch INTEGER und
    Reals (ISO-Erweiterung).

HALT;
    Beendet  die  ProgrammausfÅhrung  mit  Anzeige  einer  Fehlerbox  wie  bei
    Laufzeitfehlern. Dem Aufrufer wird die irregulÑre Beendigung durch einen
    'ExitCode' angezeigt. (siehe Kapitel 5).
3.1  Megamax Modula: Sprachumfang                                     3 -  6
________________________________________________________


HIGH (x: OpenArray): CARDINAL/LONGCARD;
    In  Prozeduren,  wenn  x  Parameter  vom  Typ  'ARRAY  OF  ...'  bzw.
     'LONGARRAY OF ...' ist: Obere Indexgrenze des Feldes x, also Elementzahl
    - 1.

INC (VAR x: ScalarType; n: NumberType);
    Siehe Beschreibung zu DEC, x wird jedoch um n erhîht.

INCL (VAR s: SetType; i: OrdinalType);
    FÅgt Element i in die Menge s ein.

INT (x: OrdinalOrRealType): SHORTINT/LONGINT;
    ISO-Erweiterung
    Analog zu der Funktion ORD wird hier ein vorzeichenbehafteter Wert von x
    geliefert. Ist x ein 4-Byte-Typ, wird  ein  LONGINT,  sonst  ein  INTEGER
    geliefert. Ist x vom Typ BYTE, wird x als vorzeichenbehafteter Wert von
    -128 bis +127 interpretiert und entsprechend zurÅckgegeben (Megamax-
    Erweiterung).

LENGTH (string: ARRAY OF CHAR): SHORTCARD/LONGCARD;
    ISO-Erweiterung
    Entspricht der Funktion Length des Moduls Strings. Ist allerdings schneller
    und kann auch in CONST-Anweisungen verwendet werden.

LFLOAT (x: NumberOrRealType): LONGREAL;
    Liefert die Darstellung des Wertes x als LONGREAL.

LONG (x: ShortType): LongType;
    Megamax-Erweiterung (aber bei vielen Compilern vorhanden)
    Wandelt einen Ausdruck von 16 Bit-Darstellung in 32 Bit-Darstellung (bzw.
    von 8 nach 16 Bit). Die erlaubten Argumente und zugehîrigen Ergebnistypen:
    CARDINAL  >>  LONGCARD           INTEGER >>  LONGINT
    WORD      >>  LONGWORD          BYTE     >>  WORD
    REAL       >>  LONGREAL

MAX (OrdinalType): OrdinalType;
    Ergibt den maximalen Wert des Typs 'OrdinalType'. Kann auch auf REAL
    und LONGREAL angewendet werden (Megamax-Erweiterung).

NEW (VAR x: PointerType);
    Reserviert Speicher fÅr x^. NEW wird vom Compiler  durch  ALLOCATE
    (x, SIZE (x^)) ersetzt (die sichtbare ALLOCATE-Funktion wird verwendet -
    ggf. muû ALLOCATE aus Storage importiert werden!).
3.1  Megamax Modula: Sprachumfang                                     3 -  7
________________________________________________________


MIN (OrdinalType): OrdinalType;
    Ergibt den minimalen Wert des Typs 'OrdinalType'. Kann auch auf REAL
    und LONGREAL angewendet werden (Megamax-Erweiterung), liefert dann
    den zu 0.0 kleinsten verschiedenen Wert.

ODD (x: OrdinalType): BOOLEAN;
    ODD (x) = "x ist ungerade". x kann von jedem ordinalen Typ sein.

ORD (x: OrdinalType): CARDINAL/LONGCARD;
    Liefert den Ordnungswert von x. x kann von jedem skalaren Typ  sein,
    siehe unter 'INC'. Das erste Element eines AufzÑhlungstyps hat die Ordnungs~
    zahl Null. Bei Anwendung auf CHAR ergibt sich der jeweilige ASCII-Wert,
    bei einem BYTE-Typ wird der Wert zw. 0 und 255 geliefert (Megamax-
    Erweiterung).

SHORT (x: LongType): ShortType;
    Megamax-Erweiterung (aber bei vielen Compilern vorhanden)
    Wandelt einen Ausdruck von 32 Bit-Darstellung in 16 Bit-Darstellung (bzw.
    von 16 nach 8 Bit). Ist das Argument in dem verkÅrzten Typ nicht darstell~
    bar, wird ein Laufzeitfehler (öberlauf) ausgelîst. Die erlaubten Argumente
    und zugehîrigen Ergebnistypen:
    LONGCARD  >>  CARDINAL            LONGINT  >>  INTEGER
    LONGWORD >>  WORD                WORD     >>  BYTE
    INTEGER     >>  BYTE (-128..127)     CARDINAL >>  BYTE (0..255)
    LONGREAL  >>  REAL

SIZE (VAR x: AnyType / t: AnyType): LONGCARD;
    Liefert Grîûe (Speicherbedarf) der Variablen x oder des Typs t in Bytes.

TRUNC (x: REAL): LONGCARD;
    Ergibt  ganzzahligen  Anteil  von  x.  Bei  Anwendung  auf  Werte,  die  als
    LONGCARD  nicht  darstellbar  sind,  wird  ein  Laufzeitfehler  (öberlauf)
                 >>
    ausgelîst.     FÅr negative Werte ist VAL (LONGINT, x) zu verwenden.

VAL (OrdinalOrRealType; x: OrdinalOrRealType): OrdinalOrRealType;
    Die  VAL-Funktion  erlaubt  die  Wandlung  eines  Ausdrucks  <x>  in  den
    entsprechenden Wert des angegebenen Zieltyps  (erstes  Argument).  FÅr
    Ausdruck und Zieltyp sind alle ordinalen Datentypen und Reals zulÑssig. Ist
    die BereichsprÅfung aktiviert, wird bei Konvertierung des Werts auf einen
    kleineren Wertebereich Code erzeugt, der dann ggf. einen Fehler anzeigt.
3.1  Megamax Modula: Sprachumfang                                     3 -  8
________________________________________________________


Standardtypen: Grîûe und Wertebereich

Typ                  Grîûe/Byte    Wertebereich
SHORTINT          2               - 2^15  ..  2^15 - 1
SHORTCARD        2                     0  ..  2^16 - 1
LONGCARD         4                     0  ..  2^32- 1
LONGINT            4               - 2^31  ..  2^31 - 1
REAL                4               +/-2.71E-20 .. +/-9.22E+18
LONGREAL          8               +/-4.57E-1240 .. +/-1.75E+1240
CHAR               1               CHR (0) ..  CHR (255)
BOOLEAN           2               TRUE, FALSE
AufzÑhlungen        2               maximal 65536 Elemente
BITSET              2               SET OF  0..15 
SET OF ...          1 bis 8192      wie LONGINT, aber max. 65536 Elemente.

Die  Typen  INTEGER  und  CARDINAL  werden  wahlweise  auf  SHORTCARD/
SHORTINT oder LONGCARD/LONGINT abgebildet.


Standardkonstanten (Megamax-Erweiterung)

MaxCard        =   2^16 - 1      =          65535
MaxInt          =   2^15 - 1      =          32767
MinInt           = - 2^ 15         =        - 32768
MaxLCard       =   2^32 - 1     =   4294967295
MaxLInt         =   2^31 - 1     =   2147483647
MinLInt          = - 2^31          = - 2147483648

Diese Konstanten  kînnen  jedoch  auch  durch  die  Funktionen  MIN  und  MAX
ermittelt werden und  sollten  in  Hinblick  auf  den  ISO-Standard  nicht  mehr
benutzt werden.


Typen CARDINAL und INTEGER

Normalerweise  sind  diese  Typen  mit  SHORTCARD  und  SHORTINT  (s.u.)
identisch. Das heiût, jeweils beide Namen kînnen bei Bedarf gemischt werden.
Sie belegen dann jeweils zwei Byte (16 Bit). Wahlweise kînnen sie auch auf
LONGCARD  bzw.  LONGINT  abgebildet  werden,  indem  die  Direktive  $I+
verwendet wird (siehe Kap 3.4). Sie haben dann deren grîûeren Wertebereich
(32 Bit) und belegen 4 Byte.

Compiler-intern werden bei Verwendung von INTEGER/CARDINAL diese Typen
immer sofort in einen der SHORT-/LONG-Typen umdefiniert, je nach aktueller
Einstellung der Direktiven. Wird beispielsweise ein Definitionsmodul Åbersetzt,
wÑhrend  CARDINAL  auf  LONGCARD  abgebildet  wird,  sind  alle  darin  mit
CARDINAL definierten Datentypen im Folgenden auf jeden Fall kompatibel zu
3.1  Megamax Modula: Sprachumfang                                     3 -  9
________________________________________________________


LONGCARD und nur dann kompatibel zu CARDINAL, sofern die entsprechende
Abbildung Åber die Compiler-Direktive ($I+) gewÑhlt ist.

Die Bibliotheken des Megamax-Systems sind alle mit der Standardeinstellung
Åbersetzt  worden  ($I-),  das  heiût,  CARDINAL  entspricht  SHORTCARD  und
INTEGER entspricht SHORTINT.

Anwendung findet diese Option beispielsweise, wenn Module von einem Modula-
System portiert werden, wo INTEGER und CARDINAL einen grîûeren Werte~
bereich als 16 Bit aufwiesen (meist dann 32 Bit). Dann kînnen diese Module
einfach ohne énderung mit der Direktive fÅr die  LONG-Abbildung  Åbersetzt
werden,  ohne  daû  BereichsÅberlÑufe/-beschrÑnkungen  befÅrchtet  werden
mÅssen.


Typen SHORTCARD und SHORTINT

Diese Typen entsprechen CARDINAL und INTEGER  bei  den  meisten  16-Bit-
Rechnern.  Sie  belegen  immer  zwei  Byte  und  haben  16  signifikante  Bits.
Normalerweise sind INTEGER und CARDINAL auf diese Typen abgebildet, das
heiût, daû sie identisch sind.

Wertebereich SHORTINT:     -32768 .. 32767
Wertebereich SHORTCARD:         0 .. 65535


Typen LONGCARD und LONGINT

Analog  zu  SHORTINT  und  SHORTCARD  sind  die  Typen  LONGINT  und
LONGCARD zum Rechnen mit 32 Bit-Zahlen definiert. Alle Operationen, die auf
INTEGER  bzw.  CARDINAL  mîglich  sind,  sind  auch  mit  LONGINTs  bzw.
LONGCARDs zulÑssig. Konstanten dieser Typen sind durch ein nachgestelltes L
gekennzeichnet, z. B. -127L, 0L, 12345678L. (Im letzten Fall darf das L auch
fehlen, da der Wertebereich die Zahl eindeutig als Long-Typ identifiziert.) Statt
L kann wahlweise ein D als Suffix verwendet werden, wie in einigen anderen
Modula-Implementationen vorgeschrieben.

Wertebereich LONGINT:    -2147483648 .. 2147483647
Wertebereich LONGCARD:             0L .. 4294967295

Beachten   Sie   bitte,   daû   die   LONG-Typen   nicht   kompatibel   zu   den
entsprechenden 16 Bit-Typen INTEGER und CARDINAL sind, daû also in einem
arithmetischen Ausdruck 32- und 16-Bit-Typen nicht vermischt werden dÅrfen.
Lediglich Konstanten sind kompatibel zu beiden Grîûen. Die Umwandlung von
Variablen, Funktionsergebnissen usw, kann mit der VAL-Funktion geschehen (s.
3.2). Bequemer ist die Verwendung der Funktionen SHORT und LONG, die im
folgenden Absatz beschrieben werden.
3.1  Megamax Modula: Sprachumfang                                     3 - 10
________________________________________________________


Bei Zuweisungen sind die KompatibilitÑtsforderungen gelockert: Die Zuweisung
eines 16-Bit-Wertes auf eine 32-Bit-Variable ist ohne weiteres mîglich. In der
umgekehrten Richtung kînnte ein öberlauf auftreten, der erst zur Laufzeit des
Programms   feststellbar   ist.   Um   zu   verhindern,   daû   eine   ungewollte
Vermischung der 16- und 32-Bit-Typen zu unerwarteten Laufzeitfehlern fÅhrt,
verlangt der Compiler hier die explizite Anpassung mittels der SHORT- oder
der VAL-Funktion. Dies kann jedoch Åber eine Compiler-Direktive unterbunden
werden  (s.  Kapitel  Åber  die  Compiler-Direktiven).  Dann  lÑût  der  Compiler
Zuweisungen von 32- auf 16-Bit-Typen zu und generiert dazu Code, der bei
einem  zu  groûen  Wert  einen  Laufzeitfehler  meldet  (sofern  nicht  die
Generierung von BereichsprÅfungen deaktiviert ist).


Typen REAL und LONGREAL

éhnlich wie SHORTINT  und  LONGINT,  sind  auch  die  beiden  Real-Typen  zu
unterscheiden. REAL hat einen sehr kleinen Wertebereich, Berechnungen damit
sind dafÅr aber deutlich schneller (nur bei den Grundrechenarten!) als die mit
den viel genaueren LONGREALs. REALs haben nur 24 Bits fÅr die Mantisse
(incl. Vorzeichen), so daû beachtet werden muû, daû Rundungsfehler  schon
beim  Umwandeln  von  LONGINT-Werten  auftreten  kînnen.  öbrigens  gilt
allgemein fÅr Real-Typen, daû immer kleine Rundungsfehler bei Berechnungen
zu erwarten sind. So sollten Sie beispielsweise nie auf den Wert Null (0.0)
direkt vergleichen, sondern besser ein Intervall abfragen (also  z.B.  IF  ABS
(real) < 0.001 statt IF real = 0.0).

In AusdrÅcken  kînnen  REALs  und  LONGREALs  nicht  gemischt  werden,  sie
mÅssen mit der VAL-Funktion oder FLOAT/LFLOAT einander angepaût werden.
Nur Real-Konstanten passen sich immer automatisch an den benîtigten Typ an.

Zuweisungen lÑût Megamax Modula-2 zwischen beiden Typen beliebig zu. Der
ISO-Standard dagegen  wird  hierzu  immer  die  Konvertierung  mit  der  VAL-
Funktion oder FLOAT/LFLOAT verlangen. Wir haben hier die Lockerung, weil
die   Megamax-Bibliothek   z.Zt.   die   Real-Funktionen   ausschlieûlich   mit
LONGREAL-Parametern versehen hat und eine Handhabung von Variablen des
REAL-Typs sonst sehr umstÑndlich wÑre.


Funktionen SHORT und LONG

Megamax-Erweiterung (aber bei vielen Compilern vorhanden)

Die   Funktionen   wandeln   zwischen   Paaren   von   Datentypen,   die   zwar
unterschiedliche  LÑngen  haben,  aber  jeweils  sich  entsprechende  innere
Struktur. Es gibt fÅnf solcher Paare:
3.1  Megamax Modula: Sprachumfang                                     3 -  11
________________________________________________________


SHORT (LONGINT)    = SHORTINT;       LONG (SHORTINT)   = LONGINT;
SHORT (LONGCARD)  = SHORTCARD;     LONG (SHORTCARD)= LONGCARD;
SHORT (LONGWORD) = WORD;            LONG (WORD)       = LONGWORD;
SHORT (WORD)       = BYTE;             LONG (BYTE)        = WORD;
SHORT (LONGREAL)  = REAL;             LONG (REAL)        = LONGREAL;

Die SHORT-Funktion erzeugt bei aktivierter BereichsprÅfung (siehe Compiler-
Direktiven)  zusÑtzlichen  Code,  der  beim  KÅrzen  von  Werten  der  Typen
LONGCARD,  LONGINT  und  LONGREAL  prÅft,  ob  der  Wert  in  die  kleinere
Darstellung paût. Wenn nicht, wird dann ein Laufzeitfehler angezeigt.

Beim KÅrzen von LONGWORD und WORD werden jeweils die hîherwertigen
Bits/Bytes  abgeschnitten,  entsprechend  werden  von  der  LONG-Funktion  bei
BYTE und WORD die oberen Bits/Bytes mit Null aufgefÅllt.


KompatibilitÑt von ADDRESS, POINTER, LONGCARD, Opaque

Adressen und Zeiger (POINTER) werden als 32-Bit-Werte dargestellt. Daher
ist der Typ ADDRESS (s. 3.2) nicht mit CARDINAL, sondern mit LONGCARD
kompatibel;  dies  erlaubt  das  Rechnen  mit  Speicheradressen  im  gesamten
adressierbaren  Bereich.  Opaque-Typen  (Typen,  deren  genaue  Definition  in
einem   Definitionsmodul   verschwiegen   wird)   kînnen   als   32-Bit-Typen
implementiert werden; insbesondere ist also eine Implementation als POINTER
mîglich.


Angaben von Speichergrîûen

Ebenso  wie  die  Adressen  werden  auch  die  LÑngen  von  Speicherbereichen
immer  als  32-Bit-Zahl,  also  als  LONGCARD,  angegeben.  Das  gilt  fÅr  die
Standardfunktion SIZE, fÅr einige Prozeduren aus dem SYSTEM-Modul (s. 3.2)
und auch fÅr zahlreiche Prozeduren der Megamax-Bibliothek.

Beispiel:
    PROCEDURE SIZE (VAR v: AnyType): LONGCARD;


Funktionen MIN und MAX

Die Standardfunktionen MIN und MAX akzeptieren als Argument jeden skalaren
Typ sowie REAL und LONGREAL. Sie liefern den minimalen bzw. maximalen
Wert des Typs.

Achtung: MIN (REAL) liefert den betragsmÑûig kleinsten darstellbaren Wert; die
absolut kleinste darstellbare Realzahl ist -MAX(REAL).
3.1  Megamax Modula: Sprachumfang                                     3 - 12
________________________________________________________


Exportlisten in Definitionsmodulen, PERVASIVE Export, lokale Module

In der revidierten Modula-Syntax dÅrfen Definitionsmodule keine EXPORT-Listen
mehr enthalten. Alle  Bezeichner,  die  im  Definitionsmodul  deklariert  werden,
werden  qualifiziert  exportiert.  Diese  Konvention  wird  auch  vom  Megamax
Modula-Compiler eingehalten.

Der Megamax-Compiler erlaubt jedoch weiterhin die Angabe einer EXPORT-
Liste, so daû Definitionsmodule nach dem alten Standard unverÑndert Åbersetzt
werden kînnen. Wird eine EXPORT-Liste spezifiziert, so bleiben alle dort nicht
aufgefÅhrten Bezeichner nach auûen unsichtbar.

Durch  eine  Export-Liste  mit  dem  SchlÅsselwort  PERVASIVE  werden  die
aufgefÅhrten  Bezeichner  so  exportiert,  daû  ein  Import  des  Moduls  die
Bezeichner Åberall sichbar werden lÑût, also auch automatisch in den lokalen
Modulen. Das Runtime-Modul wendet dies an, um seine Hilfsfunktionen Åberall
hin  sichtbar  zu  machen.  Der  Compiler  erzeugt  lediglich  automatisch  die
Anweisung IMPORT Runtime (sofern nicht $N+ verwendet wird) und schon ist
beispielsweise HALT aus Runtime Åberall sichtbar.

Exportierte Prozeduren, die dann erst in einem lokalen Modul implementiert
werden  sollen,  kînnen  sowohl  aus  dem  lokalen  Modul  exportiert  als  auch
umgekehrt importiert werden. Die erste Lîsung ist die allgemein verbreitete,
die andere wird beibehalten, da der alte Megamax-Compiler nur sie zulieû.

Beispiele fÅr die mîglichen Importe/Exporte bei lokalen Modulen finden Sie in
der Datei LOCALMOD.M im DEMO-Ordner.


Syntax eines Variant-Records

Die Syntax eines Variant-Records lautet seit PIM-3 nicht mehr

   FieldList = .. | CASE  ident ":"  qualident OF ..    sondern
   FieldList = .. | CASE  ident  ":" qualident OF .. .

Wenn Sie also keinen Feldnamen (ident) fÅr das Auswahlfeld angeben, muû
trotzdem ein ":" vor dem Typ des Auswahlfeldes stehen.  Das  erlaubt  eine
eindeutige Erkennung, ob ein Feldname vorhanden ist oder nicht. Beispiele:

   RECORD                                    RECORD
      CASE : BOOLEAN OF                      CASE male: BOOLEAN OF
          TRUE:    r: REAL |                        TRUE: rank: CARDINAL |
        FALSE: lo, hi: LONGCARD                  FALSE: maidenname: Name
      END                                       END
   END;                                       END;
3.1  Megamax Modula: Sprachumfang                                     3 - 13
________________________________________________________


Unterbereichs-Deklaration

GemÑû  der  neuen  Modula-Syntax  (PIM-3)  kann  bei  der  Deklaration  von
Unterbereichstypen  der  Basistyp  explizit  angegeben  werden.  Insbesondere
erlaubt dies, Unterbereichen den Typ INTEGER oder LONGINT zu geben, auch
wenn sie keine negativen Elemente enthalten. Die neue Syntax lautet

SubrangeType =  qualident  " " ConstExpression ".." ConstExpression " "
Beispiel:   TYPE  PosInt  =  INTEGER  0 .. MaxInt ;


FORWARD-Deklaration

Der Megamax Modula-öbersetzer ist ein Ein-Pass-Compiler. Soll eine Prozedur
aufgerufen werden, bevor sie deklariert wurde, ist deshalb eine FORWARD-
Deklaration erforderlich, die dem Compiler die vorgesehene Parameterliste der
Prozedur mitteilt. Ihre Syntax lautet

ForwardDeclaration =   ( FORWARD ident  FormalParameters  )
                       | ( PROCEDURE ident  FomalParameters  ; FORWARD )

Die erste Formulierung stammt vom Gepard-Modula-Compiler, die zweite ist
die  allgemein  bei  Ein-Pass-Compilern  Åbliche  Form  (Pascal-Syntax).  Wir
empfehlen daher die Verwendung der zweiten Form, die in Zukunft auch von
allen Modula-Compilern nach ISO-Norm verstanden wird.

Bei der spÑteren Implementation der Prozedur muû der komplette Prozedurkopf
mit Parameterliste nochmals wiederholt werden (wie das auch bei Prozeduren
erforderlich ist, die im Definitionsmodul deklariert wurden). Beispiel:

PROCEDURE  SagHallo (wie: ARRAY OF CHAR; wann: CARDINAL);
   FORWARD;
 ...
     (* von hier an kann SagHallo nun benutzt werden *)
PROCEDURE  SagHallo (wie: ARRAY OF CHAR; wann: CARDINAL);
   BEGIN ...
   END SagHallo;


Externe Variable

Megamax-Erweiterung (auch bei vielen anderen Compilern anzutreffen)

Normalerweise hat man keine Einfluû darauf, wo Compiler und Linker die Vari~
ablen (ebenso wie den Programmcode) ablegen. Man greift einfach darauf zu.
3.1  Megamax Modula: Sprachumfang                                     3 - 14
________________________________________________________


FÅr systemnahe Programmierung ist es oft wÅnschenswert, auf feste Spei~
cherstellen zuzugreifen. Die gÑngige Methode ist dabei, einen POINTER auf den
gewÅnschten Datentyp zu deklarieren und dann die Adresse darauf zuzuweisen.
Dann kann Åber den Pointer zugegriffen werden. Einfacher ist es bei Megamax
Modula:  Variablen  werden  einfach  feste  Adressen  zugewiesen,  indem  beim
Deklarieren der Variablen hinter dem Namen und  vor  dem  Doppelpunkt  die
Adresse in eckigen Klammern angegeben wird. Beispiel:

  VAR palmode  $448 : CARDINAL; (* 0: NTSC (60Hz), sonst: PAL (50Hz) *)
        farbTabelle $FF8240 : ARRAY  0..15  OF WORD;

Fast alle interessanten und dokumentierten Systemadressen von Registern und
Variablen des TOS sind normalerweise zugriffsgeschÅtzt, d.h. daû beim Zugriff
darauf ein Bus-Fehler (Zugriff auf unbekannte Adresse) ausgelîst wird. Um
dies zu umgehen, muû man in den Supervisor-Modus gelangen,  z.B.  durch
Calls.CallSupervisor. Eine andere, einfachere Lîsung wÑre, die Funktionen aus
SysUtil1 zu verwenden.


Funktions-Prozeduren

ISO-Erweiterung

Damit sind Prozeduren gemeint, die  ein  Ergebnis  als  Funktionswert  liefern.
Entgegen  Wirths  EinschrÑnkung,  nur  einfache  Datentypen  als  Ergebnis  zu
liefern, kann der Megamax-Compiler jeglichen Datentyp zurÅckgeben. So sind
grîûere  Strukturen  oder  Felder  kein  Problem.  Die  Module  StrConv  und
FuncStrings machen sich diesen Vorteil zunutze, um  bequemer  mit  Strings
umzugehen.

Beispielsweise  lieûe  sich  ein  Datentyp  COMPLEX  mitsamt  der  Åblichen
Funktionen fÅr die Operatoren auf diesen Typ:

TYPE  COMPLEX = RECORD  re, im: REAL  END;
PROCEDURE Add ( a, b: COMPLEX ): COMPLEX;
PROCEDURE Mul ( a, b: COMPLEX ): COMPLEX;

So lÑût sich dann sehr komfortabel damit rechnen. Z.B. sÑhe die Anweisung
  a:= b + c * d
folgendermaûen aus:
  a:= Add ( b, Mul ( c, d ));
3.1  Megamax Modula: Sprachumfang                                     3 - 15
________________________________________________________


Lokale Prozeduren als aktuelle Parameter

Megamax-Erweiterung

Standard-Modula  erlaubt  aus  technischen  und  SicherheitsgrÅnden  nur  die
Zuweisung globaler Prozeduren an Variablen und Parameter des PROCEDURE-
Typs. Die Sprache Pascal, die keine Prozedur-Variablen kannte, sondern nur
Parameter dieses Typs, erlaubte dafÅr die öbergabe lokaler Prozeduren an die
Parameter.  Nach  einem  persînlichen  GesprÑch  von  uns  mit  N.  Wirth
(September '89 auf einem internationalen Treffen von Modula-Entwicklern in
Bled, Jugoslawien) Åber diese EinschrÑnkung bei Modula machte N. Wirth den
Vorschlag, mit einfachen Mechanismen beide Mîglichkeiten zu kombinieren und
dies auch in der ISO-Normungsgruppe als Spracherweiterung aufzunehmen. Ob
dies Feature wirklich in den ISO-Standard aufgenommen wird, ist noch nicht
sicher,  wir  haben  dem  jedoch  schon  vorgegriffen  und  es  erfolgreich
implementiert.

Folgende Regeln sind zu beachten: Auf eine Prozedur-Variable dÅrfen weiterhin
nur  globale  Prozeduren,  auf  Prozedur-Parameter  bei   Funktionsaufrufen
beliebige Prozeduren (soweit sie Typ-gleich sind, natÅrlich) zugewiesen werden.
Der Compiler vermag dafÅr zu sorgen, daû ein formaler Prozedur-Parameter
weiterhin auf eine Prozedur-Variable (gleichen Typs) zugewiesen werden kann,
trotzdem  aber  erkannt  wird,  wenn  es  sich  dabei  nicht  um  eine  globale
Prozedur handelte, um in diesem Fall einen Laufzeitfehler anzuzeigen.

Allerdings ist diese Erweiterung nur anwendbar, wenn beim öbersetzen der
Funktion mit dem Prozedur-Parameter  die  Compiler-Direktive  $H+  aktiv  ist
(siehe Kapitel 3.4).

Es muû aber darauf geachtet werden, daû sowohl bei FORWARD-Deklarationen
als  auch  in  Definitionsmodulen  die  Direktiven-Einstellungen  mit  der  bei  der
Implementation  Åbereinstimmen.  Das  gleiche  gilt,  wenn   Prozedur-Typen
deklariert werden: Wenn also ein Versionskonflikt bei einer Zuweisung einer
Prozedur angezeigt wird, sind nicht nur die Parameter auf öbereinstimmung,
sondern auch die Einstellung der $H-Direktive zu vergleichen.

Viele Funktionen der Megamax-Bibliothek wurden mit dieser Option Åbersetzt,
so  daû  Sie  bequem  auch  lokale  Prozeduren,  beispielsweise  bei  Call  aus
EasyExceptions, verwenden kînnen.
3.1  Megamax Modula: Sprachumfang                                     3 - 16
________________________________________________________


Zuletzt noch ein Anwendungsbeispiel:

  (*$H+*)
  PROCEDURE RufeNmal (prozedurAufruf: PROC; n: CARDINAL);
    VAR c: CARDINAL;
    BEGIN
      FOR c:= 1 TO n DO
        prozedurAufruf ()
      END
    END RufeNmal;

  PROCEDURE schreibeNmal (text: ARRAY OF CHAR; n: CARDINAL);

    PROCEDURE schreibeText;
      BEGIN
        WriteString (text);
        WriteLn
      END schreibeText;

    BEGIN (* schreibeNmal *)
      RufeNmal (schreibeText, n);
    END schreibeNmal;

  BEGIN (* Hauptprogramm *)
    schreibeNmal ('Hallo', 4)
    ...

In  diesem  Beispiel  akzeptiert  die  Routine  RufeNmal  die  lokale  Prozedur
schreibeText von schreibeNmal. Wird sie nun aufgerufen, kann sie wiederum
ganz normal auf die umgebenden Variablen, also auch text, zugreifen, so als
ob sie direkt in schreibeNmal aufgerufen worden wÑre. Nach dem normalen
Modula-Standard ginge das nicht und man mÅûte den text in einer globalen
Variablen zwischenspeichern, damit schreibeText darauf zugreifen kînnte.


Zuweisungen von LONGs auf SHORTs

Nomalerweise  erlaubt  Megamax-Modula  aus  SicherheitsgrÅnden  nicht  die
implizite Zuweisung von LONGCARD- oder LONGINT-Werten auf SHORTCARD-
oder SHORTINT-Variablen. Dies kann jedoch Åber die Direktive $K+ (siehe Kap.
3.4) ermîglicht werden.


Bedingungen fÅr Laufvariablen von FOR-Schleifen

Der Compiler legt seit Version 4.0 Laufvariablen von FOR-Schleifen mîglichst
in  Registern  ab,  anstatt  sie  im  Speicher  zu  halten.  Dies  bringt  teilweise
deutliche Geschwindigkeitsvorteile.
3.1  Megamax Modula: Sprachumfang                                     3 - 17
________________________________________________________


Allerdings sind auch einige Bedingungen daran geknÅpft, die schon immer bei
Pascal und Modula galten, aber bisher nur selten ernst genommen wurden:

Die  Laufvariable  muû  eine  einfache,  lokale  Variable  sein.  Sie  darf  weder
exportiert/importiert  noch  Feld  eines  Records  sein.  Zuweisungen  darauf
innerhalb der Schleife sind ebenfalls nicht erlaubt, nach dem Schleifenende ist
der Wert wirklich undefiniert (und nicht etwa letzter Schleifenwert plus Eins,
oder sowas).

Der  Compiler  zeigt  bei  Verletzung  dieser  Regeln  entsprechende  Fehler~
meldungen an, so daû eine eventuelle Korrektur schnell erledigt ist. Allerdings
kann er das z.Zt. nicht in Assembler-Teilen. FÅr solche kritischen Situationen
gibt es deshalb die Direktive $J (s. Kapitel 3.4).

Beispiel:  Eine  globale  Schleifenvariable  darf  keinesfalls  auûerhalb  der  FOR-
Schleife im Text abgefragt werden, weil ggf. der Wert in einem Register liegt
und die globale Variable nicht verÑndert wÅrde. Beispiel:

    VAR laufvar: CARDINAL;
    PROCEDURE prozedur;
      BEGIN
        IF laufvar = 4 THEN ... END   (* dieser Zugriff ist nicht erlaubt! *)
      END prozedur;
    BEGIN
                  :
      FOR laufvar = 1 TO 10 DO prozedur END


SETs

Seit  der  Revision  von  PIM  kînnen  Sets,  die  mit  geschweiften  Klammern
formuliert werden, nicht mehr  nur  Konstanten  sondern  beliebige  AusdrÅcke
enthalten. Beispiele:

  VAR set: BITSET; c, d: CARDINAL;
  BEGIN
        :
    set =  c ;
    (* anstatt: *)
        :
    set =   ; INCL (set, c);

    set =  c..d ;

Die letzte Zeile zeigt, daû auch ganze Elementbereiche in einem StÅck markiert
werden kînnen. Ist dabei c grîûer als d, bleibt die Menge leer - es wird also
nicht etwa ein Laufzeitfehler gemeldet!
3.1  Megamax Modula: Sprachumfang                                     3 - 18
________________________________________________________


Mehrdimensionale offene Felder (Open Array)

ISO-Erweiterung

Damit kînnen nun auch mehrdimensionale Felder als offene Felder mitsamt der
Grîûen aller  Dimensionen  Åbergeben  werden.  Die  HIGH-Werte  der  tieferen
Dimensionen sollten dabei immer mit dem Zugriff auf das erste Feld mit dem
Index Null ermittelt werden. Beispiel:

    PROCEDURE showMatrix (matrix: ARRAY OF ARRAY OF INTEGER);
      BEGIN
               :
        FOR x = 0 TO HIGH (matrix) DO
                 :
          FOR y = 0 TO HIGH (matrix 0 ) DO
            WriteInt (matrix x,y , 4)
          END;
          WriteLn
        END
      END showMatrix;

    VAR mat1:  ARRAY  1..4  OF  1..2  OF INTEGER;
         mat2: ARRAY  1..3  OF  1..3  OF INTEGER;

    BEGIN
      showMatrix (mat1);
      showMatrix (mat2);
    END


Grîûe von INTEGER und CARDINAL

Diese Typen kînnen wahlweise auf SHORTINT/SHORTCARD (Voreinstellung)
oder auf LONGINT/LONGCARD (Direktive $I+, s. Kap. 3.4) abgebildet werden.


Datengrîûe bei offenen Feldern (Open Array)

Megamax-Erweiterung

Normalerweise kînnen an ein Open Array maximal 65536 Elemente Åbergeben
werden, bei offenen Feldern, deren Elemente nur ein Byte groû sind (BYTE,
CHAR), sind aus EffizienzgrÅnden sogar nur 32768 Elemente erlaubt! Wenn
Sie beispielsweise ein ARRAY  1..50000  OF BYTE an ein ARRAY OF BYTE-
Parameter Åbergeben wollen, wird der Compiler eine Fehlermeldung anzeigen.
Zur  Abhilfe  kînnen  Sie  das  Open  Array  mit  LONGARRAY  statt  ARRAY
deklarieren. Das teilt dem Compiler mit, einen LONGCARD-Wert statt eines
SHORTCARD  als  HIGH-Wert  zu  verwenden,  so  daû  die  Elementanzahl
unbegrenzt groû sein kann.
3.1  Megamax Modula: Sprachumfang                                     3 - 19
________________________________________________________


Beispiel:
   PROCEDURE Clear (VAR data: LONGARRAY OF BYTE);

An diese Funktion kann auch ein Array mit mehr als 32 KB Grîûe Åbergeben
werden.


Value Constructors (Aggregate)

ISO-Erweiterung

Damit kînnen strukturierte Daten, wie Felder und Records, in einem StÅck aus
AusdrÅcken geformt werden. Dies ist nicht neu: Bereits SETs konnten schon
immer mit der Form SetTyp  elem1, elem2, ...  erzeugt werden.

Die Syntax fÅr allgemeine Aggregate lehnt sich an die der SETs an: Zuerst
kommt der Typ der Struktur, danach in geschweiften Klammern die einzelnen
Elemente der Struktur, wie Parameter bei einem Funktionsaufruf.

Bei Feldern (ARRAYs) werden einfach alle Feldelemente aufgezÑhlt. Statt der
EinzelaufzÑhlung ist mit dem reservierten  Wort  BY  auch  die  Angabe  eines
Wiederholungsfaktors  (Replikator)  mîglich.  Das  Feld  muû  immer  vollstÑndig
aufgefÅllt werden. Beispiel:

  TYPE Feld = ARRAY  1..10  OF CARDINAL;
  CONST Leerfeld = Feld   0 BY 10  ;
  VAR f: Feld;
  BEGIN
     :
    f = Leerfeld;
     :
    f = Feld   10, 20, 30, 40 BY 7  ;

Bei Verwendung des Replikators (BY) fÅr einen Funktionsaufruf wird aber nur
der  Funktionswert  entsprechend  oft  eingesetzt,  nicht  etwa  die  Funktion
mehrfach aufgerufen! Beispielsweise initialisiert
    :
   f = Feld   Random() BY 10  
das Feld nicht etwa mit zehn verschiedenen Random-Werten, sondern zehnmal
mit dem einmalig ermittelten Zufallswert!

Bei RECORDs werden die Elemente in der Reihenfolge angegeben, in der ihre
Felder  deklariert  wurden.  Bei  Record-Varianten  (CASE)  muû  auch  das
Selektionsfeld  immer  passend  mit  angegeben  werden,  damit  der  Compiler
entscheiden kann, fÅr welchen CASE-Fall die folgenden Elemente angegeben
werden. Beispiel:
3.1  Megamax Modula: Sprachumfang                                     3 - 20
________________________________________________________


  TYPE Rec = RECORD
                  a, b, c: CARDINAL;
                  CASE : BOOLEAN OF
                    TRUE:   ch: CHAR |
                    FALSE:  lc: LONGCARD
                  END
               END;
  VAR r: Rec;
  BEGIN
       :
     r  = Rec  1, 2, 3, TRUE, 'z' ;
     (* dies entspricht: *)
     WITH r DO
          :        :        :         :
        a = 1;  b = 2;  c = 3;  ch = 'z'
     END;


Verkettung von String-Konstanten

ISO-Erweiterung

String-Konstanten  kînnen  verkettet  werden.  Damit  ist  es  beispielsweise
mîglich,  Sonderzeichen  in  einen  String  einzufÅgen.  Als  Operator  wird  das
Plus-Zeichen verwendet.

Vorsicht: Dies ist nicht mit der String-Verkettungsmîglichkeit bei Pascal zu
verwechseln, wo mit dem Plus-Operatur auch Variablen zusammenfÅgbar sind
- dazu sind in Modula die Funktionen des Strings-Moduls vorgesehen!

Beispiele:
  CONST Bing = 7C;
           text = "Hallo" + Bing; (* String mit Ctrl-G f. Ton-Ausgabe *)

  WriteString ("Hi!" + Bing);
  (* statt bisher: WriteString ('Hi'); Write (Bing); *)

Generell kînnen nur String-Literale verkettet werden, das sind alle Zeichen~
ketten aus einfachen oder doppelten AnfÅhrungszeichen und Zeichenkonstanten
in  der  Oktaldarstellung  mit  angefÅgtem  "C".  Die  Funktion  CHR()  liefert
beispielsweise den Typ CHAR und kann deshalb nicht mit verkettet werden.
3.1  Megamax Modula: Sprachumfang                                     3 - 21
________________________________________________________


Funktion LENGTH

ISO-Erweiterung

LENGTH  hat  einen  String  als  Argument  und  liefert  seine  LÑnge,  wie  die
Length-Funktion des Strings-Moduls. Ihre Vorteile:
  * Sie kann in CONST-AusdrÅcken benutzt werden. Beispiel:
         CONST str = "bla bla";
         VAR    feldFuerStr: ARRAY  0..LENGTH (str)  OF CHAR;
  * Sie ist immer schneller als die Length-Funktion aus Strings.

Sie liefert,  je  nach  Grîûe  des  Strings,  SHORTCARD  bzw.  LONGCARD  als
Ergebnis.


Funktionen FLOAT und LFLOAT

ISO-Erweiterung

Nach PIM erlaubt FLOAT nur CARDINAL als Argument,  nun  sind  aber  alle
Ganzzahl-  und  Real-Typen  zugelassen.  FLOAT  liefert  ein  REAL-Ergebnis.
Analog dazu liefert LFLOAT LONGREAL-Werte. Die Funktionen haben demnach
den selben Effekt wie VAL (REAL/LONGREAL, argument), jedoch sind sie
nicht auf CHARs und AufzÑhlungstypen zugelassen.

Damit eignen sich FLOAT und LFLOAT nicht nur zur Wandlung zw. CARDINAL/
INTEGER und Reals, sondern auch zum Konvertieren von REAL und LONGREAL
in AusdrÅcken. Beispiel:

      VAR  sr: REAL;  lr: LONGREAL;
      BEGIN
          :
        lr = lr + LFLOAT (sr);


Funktion INT

ISO-Erweiterung

INT ist eine kÅrzere Form fÅr VAL (INTEGER, argument); alle Typen sind, wie
bei  VAL,  zugelassen.  INT  und  ORD  lassen  sich  sehr  praktisch  zum
Konvertieren zwischen CARDINAL und INTEGER und  AusdrÅcken  verwenden.
Beispiel:

      VAR  int: INTEGER;  card: CARDINAL;
      BEGIN
           :
        int = int * INT (card);
3.1  Megamax Modula: Sprachumfang                                     3 - 22
________________________________________________________


KompatibilitÑt bei Open Arrays

Megamax-Erweiterung

Wenn sich Wirth in PIM auch nicht prÑzise darÅber auslÑût, hat er jedoch bei
einer Anfrage von ISO klargestellt, daû auf ein ARRAY OF Typ nicht einzelne
AusdrÅcke des Typs Typ zuweisbar sind, sondern nur echte Felder (ARRAYs)
dieses Typs. Das heiût nach ISO, auf ein ARRAY OF CHAR darf nicht eine
einzelne  CHAR-Variable  zugewiesen  werden  (allerdings  schon  eine  String-
Konstante der LÑnge Eins, wie z.B. "a").

Megamax Modula-2 erlaubt jedoch auch die Zuweisung einzelner Elemente des
Array-Typs.


KompatibilitÑt von Strings

Megamax-Erweiterung

Bei String-Variablen, also ARRAY  0..n  OF CHAR, sind die Regeln  fÅr  die
ZuweisungskompatibilitÑt  etwas  gelockert:  Die  Variablen  mÅssen  nicht  den
selben  Typ  haben,  sondern  lediglich  dieselbe  Grîûe  aufweisen.  Das  heiût,
folgendes Beispiel ist in Megamax-Modula legal:

   VAR a: ARRAY  0..9  OF CHAR;
        b: ARRAY  0..9  OF CHAR;
   BEGIN
       :
     a = b;


Erweiterte Syntax

Durch die Anwendung der Compiler-Direktive $A+ werden die Syntax-Regeln
gelockert:
  * Variable,  die  an  VAR-Parameter  Åbergeben  werden  sollen,  kînnen  mit
    einem Typ-Transfer versehen werden. Beispiele:
        ReadCard ( CARDINAL ( wordVar ) );
        INC ( CAST ( CHAR, byteVar ) );
  * Nach einem Funktionsaufruf (auch Typ-Transfer usw.) kînnen die Ergeb~
    nisse weiterhin selektiert, dereferenziert, indiziert bzw. - bei Funktionen -
    aufgerufen werden. Beispiele:
                 :
        cardVar  = ArrayTyp ( pointer^ )  n ;
                 :
        cardVar  = returningRecord().cardElement;
                 :
        cardVar  = CAST (PtrToCard,addressVar)^;
                 :
        cardVar  = FunctionTyp (addressVar) ();  (* Funktionsaufruf *)
3.1  Megamax Modula: Sprachumfang                                     3 - 23
________________________________________________________


REF-Parameter

Megamax-Erweiterung (auch bei einigen anderen Compilern vorhanden)

Eine SchwÑche von Modula liegt darin, daû aktuelle Parameter nur als Wert-
oder  Referenz-Parameter  verwendbar  sind.  Bei  der  öbergabe  von  Wert-
Parametern  werden  immer  lokale  Kopien  der  Daten  angelegt,  damit  die
aufgerufene  Funktion  die  Werte  Ñndern  kann,  ohne  die  Originaldaten  zu
beeinflussen. Sollen nun sehr groûe Datenmengen, beispielsweise umfangreiche
ARRAYs, als Parameter Åbergeben werden, tritt erstens oft die Zeitspanne fÅr
den  Kopiervorgang  negativ  in  Erscheinung,  zweitens  kann  es  leicht  zu
Stack-öberlÑufen kommen, da die Kopien ja auf dem Stack angelegt werden.

Abhilfe  kann  man  sich  dadurch  schaffen,  daû  man  die  Referenz  auf  die
Originaldaten Åbergibt, indem entweder ein POINTER darauf Åbergeben oder
der formale Parameter mit VAR versehen wird. NatÅrlich geht das nur, wenn
auch  sichergestellt  wird,  daû  die  aufgerufene  Funktion  die  Daten  nicht
verÑndert, wenn sie es nicht soll. Dies ist aber leider nicht kontrollierbar. Ein
weiterer Nachteil liegt darin, daû an VAR-Parameter keine Konstanten oder
Funktionsergebnisse Åbergeben werden kînnen.

Die Lîsung ist nun, REF statt VAR vor den formalen Parameter zu schreiben.
Dann weiû  der  Compiler,  daû  er  die  Daten  nach  Mîglichkeit  als  Referenz
Åbergeben soll, also keine lokale Kopie anzulegen braucht, und zusÑtzlich kann
er Åberwachen, daû die Daten in der Funktion nicht verÑndert werden, indem
er Zuweisungen darauf und die öbergabe an Prozeduren mit VAR-Parametern
nicht zulÑût. Allerdings erlaubt er den Zugriff auf den Parameter mittels der
CADR-Funktion - da diese aus SYSTEM importiert  werden  muû  und  somit
auffÑllt, kînnen Sie als Programmierer leicht selbst prÅfen, ob ein  illegaler
Schreibzugriff auf die Daten geschieht.

Beim öbertragen eines Programms auf  einen  Compiler,  der  REF-Parameter
nicht kennt, entstehen keine Probleme: Lîschen Sie einfach alle Vorkommen
von REF. Dann werden die Daten wieder lokal kopiert, so daû bis auf einen
evtl. grîûeren  Stack-Bedarf  keine  weiteren  ProgrammÑnderungen  notwendig
werden.

Zu beachten:

Allerdings ist Vorsicht bei der Verwendung von REF-Parametern geboten: Man
kann nicht Åberall, wo bisher value-Parameter verwendet wurden, nun einfach
REF  einsetzen.  Denn  sonst  das  sogenannte  kann  alias-Problem  auftreten.

Beispiel:

    PROCEDURE proc (in: ARRAY OF CHAR; VAR out: ARRAY OF CHAR);
3.1  Megamax Modula: Sprachumfang                                     3 - 24
________________________________________________________


Wenn hier nun REF bei in eingesetzt wird, kînnte es zu Fehlern kommen, wenn
proc mit zwei identischen Variablen aufgerufen wird, also beispielsweise

    proc ( datum, datum );

Greift proc nÑmlich auf in zu und verÑndert gleichzeitig out, wÅrde auch in
indirekt verÑndert, weil in ja direkt  auf  das  Åbergebene,  verÑnderte  datum
zugreift.

Wie kann man diesem Effekt vorbeugen?

* Erste Regel: REF ist kein Ersatz fÅr value-Parameter, sondern ein  VAR-
  Parameter,  der  auch  Konstant-Zuweisungen  erlaubt.  Nach  dieser  Regel
  erkennt man leicht: WÅrde man VAR beim in-Parameter einsetzen, wÑre das
  alias-Problem leichter erkennbar.

* Zweitens: Nur bei Prozeduren, die zusÑtzliche VAR-Parameter haben, kann
  dieses  Problem  entstehen.  Nur  dann  braucht  Åberhaupt  die  obige  Regel
  beachtet zu werden.

Beispiel fÅr eine Anwendung der REF-Parameter:

    MODULE RefBsp;
    FROM InOut IMPORT WriteString, WriteCard, ReadString, Done;
    PROCEDURE spaces (REF str: ARRAY OF CHAR): CARDINAL;
      (* ZÑhlt die Leerzeichen im String "str" *)
      VAR idx, n: CARDINAL;
      BEGIN
        n:= 0;
        FOR idx:= 0 TO HIGH (str) DO
          IF str  idx  = " " THEN INC (n) END
        END;
        RETURN n
      END spaces;
    VAR s: ARRAY  0..99  OF CHAR;
    BEGIN
      LOOP
        ReadString (s);
        IF NOT Done THEN EXIT END;
        WriteString ("Der eingegebene String enthÑlt ");
        WriteCard (spaces (s), 0);
        WriteString (" Leerzeichen.");
        WriteLn;
      END
    END RefBsp.
3.2 Megamax Modula: Interne Datenformate                             3 - 25
________________________________________________________


3.2  Interne  Datenformate

Ablage von Strukturen im Speicher, Unterschiede zu anderen Compilern

Hier wird im einzelnen erklÑrt, wie es  sich  mit  der  Aufteilung  der  unter~
schiedlich  groûen  Datenelemente  in  Strukturen  verhÑlt  und  worauf  bei  der
öbertragung (Portierung) von Modula-Programmen anderer Implementierungen
zu achten ist.


Sets und BITSET

Bei Sets werden oft speicheraufteilungsabhÑngige Annahmen gemacht. Daher
ist es allein aus GrÅnden der leichteren Handhabung und Portierbarkeit bei den
680x0 CPUs oft wÅnschenswert, daû ein BITSET 16 Elemente faût und diese
genau  den  Bits  eines  Maschinenworts  entsprechen.  Dagegen  spricht  aber,
SETs mit mehr als 32 Elementen, die Megamax Modula-2 auch ermîglicht, in
dieser Form abzulegen. Je nach Prozessortyp (68000, wie im Atari ST, oder
68030, wie im Atari TT) bieten sich unterschiedliche Formate  an,  um  den
jeweils  optimalen  Geschwindigkeitsgewinn  zu  erlangen.  Um  nun  dem  oft
ausgesprochenen Wunsch unserer Anwender nachzukommen, bieten wir einen
Kompromiû: SETs mit bis zu 32 Elementen werden im Speicher so angelegt,
daû  die  Bit-ZÑhlung  beim  niederwertigsten  Byte  im  untersten  Bit  mit  Null
beginnt. Dies entspricht der Åblichen Bit-Numerierung von Byte-, Word- und
Long-Daten bei den 680x0-Prozessoren.

Beispiel fÅr BITSET:
   Byte-Offset im Speicher:            0            |             1
   Bit-Nummern:           7  6  5  4  3  2  1  0  |  7  6  5  4  3  2  1  0
   SET-Elemente:          15 14 13 12 11 10 9  8  |  7  6  5  4  3  2  1  0

Bei  SETs  mit  mehr  als  32  Elementen  ist  die  Aufteilung  ganz  einfach
undefiniert. Wir behalten uns vor, je nach Prozessortyp, fÅr den der Compiler
Code erzeugen soll, ein anderes Format zu wÑhlen. Sie dÅrfen also keinesfalls
auf die einzelnen Elemente  solcher  SETs  in  Assembler  oder  durch  andere
Tricks zugreifen! Haben Sie groûe Bit-Felder, die ein  festes  Format  haben
mÅssen, z.B. um auf eine Bitmap einer Grafik zuzugreifen, mÅssen Sie sich
damit behelfen, ARRAYs aus kleinen SETs (bis 32 Elemente) zu bilden.

LONG-Werte

Manche Compiler erlauben es, in AusdrÅcken LONG-Werte (z.B. LONGCARD)
mit  WORD-Werten  (z.B.  CARDINAL)  zu  mischen.  Auch  kînnen  manchmal
LONG-Werte  auf  SHORT-Variablen  zugewiesen  werden.  Unser  Compiler
erlaubt dies z.Zt. nur bei Konstanten. In anderen FÑllen muû explizit durch die
Standardfunktionen LONG und SHORT (bequemer als VAL) oder VAL (portabler)
umgewandelt werden.
3.2 Megamax Modula: Interne Datenformate                             3 - 26
________________________________________________________


Beispiel:
  VAR card: CARDINAL; longcard: LONGCARD;
  BEGIN
         :
    card = SHORT ( longcard * 2 DIV LONG (card) );


Packen von BYTE-Daten

Byte-Daten  sind  alle  diejenigen,  deren  Basistyp  ein  Byte  groû  ist,  also
beispielsweise CHAR und SET OF  0..7 .

Der Prozessor im Atari ST, der 68000, ist daraufhin optimiert, mit Word-
und  Long-Daten  umzugehen.  Zugriffe  auf  Byte-Daten  sind  verhÑltnismÑûig
ineffektiv. Aus diesem Grund versucht der Compiler, Daten, die grîûer als ein
Byte sind, mîglichst als Word- bzw. Long-Daten anzusprechen, anstatt alles
immer Åber byteweisen Zugriff zu erledigen. Dies fÅhrt aber zu einer neuen
EinschrÑnkung: Word- (und damit auch Long-) Zugriffe sind nur mîglich, wenn
solche Daten auf geraden Adressen liegen. Versucht man, Word-Zugriffe auf
ungeraden Adressen durchzufÅhren, strÑubt sich der Prozessor, indem er eine
Exception auslîst, was in der Shell zur Fehleranzeige Zugriff auf ungerade
Adresse fÅhrt.

Werden nun Strukturen, die Byte-Daten enthalten, definiert und verwendet, hÑlt
der Compiler bestimmte Konventionen ein, um eine solche Fehlermeldung zu
vermeiden:

EnthÑlt ein RECORD  Byte-Daten,  werden  sie  immer  auf  das  nÑchste  freie
Byte-Feld im  Record  gelegt.  Andere  Daten  werden  zuerst  immer  synchro~
nisiert, d.h. sie werden immer auf gerade Adressen gelegt - ggf. bleibt davor
ein Byte unbenutzt.

öbersetzt der Compiler Zuweisungen von Strukturen, erzeugt er in der Regel
Word-Kopieranweisungen. Lediglich bei reinen Byte-Strukturen, die Åber Pointer
dereferenziert oder als REF-/VAR-Parameter Åbergeben werden, erzeugt er
sicherheitshalber Byte-Kopieranweisungen. Damit besteht also nie die Gefahr,
daû ein Adreû_Zugriffsfehler auftritt.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 27
________________________________________________________


3.3   Das  SYSTEM-Modul

Megamax Modula stellt einige Datentypen und Funktionen zur VerfÅgung, die
besonders die systemnahe Programmierung unterstÅtzen. NaturgemÑû wird die
öbertragbarkeit Ihrer Modula-Programme auf andere Rechner gefÑhrdet, wenn
Sie zu freigiebig von solchen maschinennahen Konstrukten Gebrauch machen.
N. Wirth hat darum  vorgeschlagen,  diese  nicht  als  Standardfunktionen  und
-typen anzubieten, sondern den Import aus einem speziellen Modul SYSTEM zu
verlangen. Damit kann man schon im Kopf eines Moduls erkennen, ob es von
Funktionen Gebrauch macht, die eventuell hardware- oder compiler-spezifisch
sind.

Ein DEFINITION MODULE SYSTEM werden Sie allerdings auf den Megamax-
Disketten nicht vorfinden - das  SYSTEM-Modul  ist  Teil  des  Compilers,  da
seine Funktionen teilweise speziellen Regeln gehorchen und gar nicht in Modula
zu beschreiben wÑren. Wir versuchen's aber trotzdem,  um  einen  öberblick
Åber das Modul zu geben - Sie kînnen sich die Definition so vorstellen:

DEFINITION MODULE SYSTEM;

CONST   CompilerVersion = 4;      (* 5 bei vollst. ISO-Norm-Compiler *)
CONST   CompilerSubVersion = .. ; (* Revisionsnummer *)

TYPE LOC;  BYTE;  WORD;  LONGWORD;
TYPE ADDRESS = POINTER TO WORD;

PROCEDURE TSIZE (AnyType; ... ): LONGCARD;
PROCEDURE CAST (AnyType; x: AnyType2): AnyType;
PROCEDURE ADR (VAR x: AnyType): ADDRESS;
PROCEDURE CADR (constOrVar: AnyType): ADDRESS;

TYPE BITNUM;
PROCEDURE SHIFT (VAR x: SetOfBitnumType; n: INTEGER);
PROCEDURE ROTATE (VAR x: SetOfBitnumType; n: INTEGER);

PROCEDURE CALLSYS (trap:  0..15 ; parms: AnyType ... ): LONGWORD;
PROCEDURE CALLEXT (addr: ADDRESS; parms: AnyType ... ): LONGWORD;

PROCEDURE CODE (n1: CARDINAL; n2: CARDINAL; ... );
PROCEDURE LOAD (x: LONGWORD; reg:  0..15 );
PROCEDURE STORE (reg:  0..15 ; VAR x: AnyType);
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 28
________________________________________________________


PROCEDURE NEWPROCESS (p: PROC; a: ADDRESS; n: LONGCARD;
                               VAR q: ADDRESS);
PROCEDURE TRANSFER (VAR from, to: ADDRESS);
PROCEDURE IOTRANSFER (VAR from, to: ADDRESS; vector: ADDRESS);
PROCEDURE IOCALL (vector: ADDRESS);
PROCEDURE LISTEN ();

EXPORT ASSEMBLER;

END SYSTEM.

Da die meisten Exporte des SYSTEM-Moduls im  Modula-Standard  eindeutig
charakterisiert sind, sollen hier die folgenden Anmerkungen genÅgen:


Type ADDRESS

Noch ist ADDRESS als POINTER TO WORD definiert, die ISO-Norm verlangt
hier aber POINTER TO LOC. Achten Sie deshalb darauf,  daû  Sie  nie  eine
Address-Variable dereferenzieren (mit "^"), weil damit jetzt noch ein Word,
bald (beim ISO-Compiler) aber ein Byte angesprochen wird!


Typen LONGWORD, WORD, BYTE und LOC

ISO- und Megamax-Erweiterungen

Wird in der Parameterliste einer  Prozedur  ein  Parameter  vom  Typ  WORD
deklariert,  so  lassen  sich  dieser  Prozedur  alle  Datentypen  Åbergeben,  die
intern  als  16-Bit-Wert  dargestellt  werden  (das  sind  CARDINAL,  INTEGER,
BOOLEAN, AufzÑhlungstypen, Unterbereiche dieser Typen, SETs mit 9 bis 16
Elementen).

Analog  kînnen  an  einen  LONGWORD-Parameter  beliebige  32-Bit-Typen
Åbergeben  werden.  Dies  sind  LONGCARD,  LONGINT,  Unterbereiche  davon,
ADDRESS, POINTER, PROC und andere Prozedurtypen, SETs mit 17 bis 32
Elementen.

Ein BYTE-Parameter dient (wie zu erwarten war) dazu, beliebige 8-Bit-Typen
an eine Prozedur zu Åbergeben; dies kînnen CHAR und SETs mit bis zu 8
Elementen sein.

LOC ist in der ISO-Norm der neue Joker-Typ und ersetzt praktisch BYTE. In
Zukunft  sollte  daher  nur  noch  LOC  statt  BYTE,  WORD  und  LONGWORD
verwendet werden, denn LOC ist als kleinster gemeinsamer Datentyp definiert.
öbrigens: Die Definition nach Wirth hatte dies schon mit WORD beabsichtigt,
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 29
________________________________________________________


nur leider miûinterpretierten viele Compiler-Hersteller den Universal-Datentyp
WORD mit der Bezeichnung Word als 2-Byte-Datum bei vielen Mikroprozes~
soren. Daraus folgte dann, daû WORD meist zwei Byte belegte und nun nicht
mehr 1-Byte-Typen, wie CHAR, einfach auf einenWORD-Parameter zuweisbar
waren. Deshalb wurde nun von ISO LOC fÅr diesen Zweck definiert.

Beachten Sie bitte, daû diese 'Joker'-Typen nur in Prozedur-Parameterlisten
diese  besondere  Funktion  haben.  Zuweisung  oder  z.  B.  Addition  eines  16
Bit-Typs auf ein WORD sind nicht erlaubt; dazu mÅssen explizite Typtransfer-
Funktionen aufgerufen werden. An einen ARRAY OF LOC-Parameter  kînnen
beliebige Daten Åbergeben werden.


Funktionen ADR und TSIZE

ADR liefert die Adresse einer Variablen. TSIZE liefert die Grîûe (in Byte) eines
Typs. Ist der Typ ein Record mit Varianten, kînnen nach Modula-Syntax noch
die sog. Tags der Varianten angegeben werden, Megamax Modula-2 ignoriert
sie z.Zt. aber und liefert in jedem Fall die maximale Gesamtgrîûe des Typs.


Konstante CompilerVersion und CompilerSubVersion

Megamax-Erweiterung

Diese Werte eignen sich besonders zur Abfrage beim bedingten Compilieren (s.
Kap. 3.4 Åber Direktiven). Beide Werte werden auch vom Compiler beim Start
im Ausgabefenster und im Protokoll angezeigt. Jedes Mal, wenn gravierende
Funktionserweiterungen am Compiler vorgenommen werden,  erhîhen  wir  die
CompilerVersion um Eins. Z.Zt. ist sie vier, nach offiziellem Erscheinen der
ISO-Norm werden wir einen vollstÑndig angepaûten Compiler mit der Version
fÅnf verîffentlichen.  Die  CompilerSubVersion  wird  bei  kleineren  énderungen
und Korrekturen erhîht, die aber die grundsÑtzliche Funktionsweise von bereits
fÅr die Version erstellten Programmen nicht beeintrÑchtigen dÅrfte.


Type BITNUM und Funktionen SHIFT und ROTATE

ISO-Erweiterung

Der  Typ  BITNUM  wird  voraussichtlich  im  ISO-Standard  definiert  und  ist
ausschlieûlich fÅr SETs vorgesehen. BITNUM ist in etwa definiert als
  TYPE  BITNUM  =  CARDINAL  0..31 ;
Jedoch sind Variablen vom Typ BITNUM nicht kompatibel mit CARDINAL, eine
Konvertierung, z.B. mit VAL, ist notwendig. Lediglich Konstanten von 0 bis 31
sind kompatibel zum BITNUM-Typ.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 30
________________________________________________________


Der Zweck ist, mit Sets dieses  Typs  eine  eindeutige  Zuordnung  von  Set-
Elementen  auf  die  Bit-Struktur  des  Speichers  zu  definieren,  um  darauf
portabel, zumindest zwischen verschiedenen Compilern des gleichen Rechners,
zugreifen zu kînnen.

Bei Megamax-Modula entspricht des interne Struktur eines BITNUM-Sets genau
dem normaler Sets mit bis zu 32 Elementen.

Die Funktionen SHIFT und ROTATE erlauben das Verschieben und Rotieren der
Elemente  (Bits)  von  BITNUM-Sets.  Der  jeweils  erste  Parameter  ist  eine
Variable vom Typ SET OF BITNUM  a..b  (a und b liegen zw. 0 und 31), der
zweite  Parameter  ist  fÅr  die  Angabe  der  Schub-/Rotierweite  vorgesehen.
Positive  Werte  schieben/rotieren  zu  den  hîherwertigen  Elementpositionen,
negative umgekehrt. Beispiel:

  TYPE Feld = SET OF BITNUM  2..6 ;
  VAR  x: Feld;
  BEGIN
    x:= Feld  2..4 ;       (* Bits in feld:  x00111xx *)
    SHIFT (x, 1);         (* Bits in feld:  x01110xx *)
    ROTATE (x, -2);     (* Bits in feld:  x10011xx *)
    SHIFT (x, 2);         (* Bits in feld:  x01100xx *)


Funktion CAST (AnyType; x: SourceType): AnyType;

ISO-Erweiterung

Die CAST-Funktion erlaubt die Wandlung  eines  Ausdrucks  <x>  in  den  ent~
sprechenden Wert  des  angegebenen  Zieltyps  <AnyType>.  FÅr  Ausdruck  und
Zieltyp sind alle Datentypen zulÑssig, die intern durch 1, 2 oder 4 Byte dar~
gestellt  werden  oder  identische  Grîûen  besitzen.  Der  Compiler  paût  den
Ausdruck <x> nur der LÑnge des Zieltyps an und nimmt keine weiteren Umset~
zungen vor. Es wird keine BereichsprÅfung (Rangecheck) durchgefÅhrt.

Wir  empfehlen,  zur  Typenwandlung  die  CAST-Funktion  grundsÑtzlich  den
Typtransfer-Funktionen  der  Form  AnyType  (x:  SourceType),  z.B.  INTEGER
(TRUE),  vorzuziehen.  Zum  einen  bietet  die  CAST-Funktion  eine  grîûere
FlexibilitÑt, da sie automatische LÑngenanpassungen durchfÅhrt. Zum anderen
ist ihre Benutzung durch den Import aus SYSTEM schon im Modulkopf sichtbar.
(Da  die  interne  Darstellung  der  Datentypen  implementationsabhÑngig  ist,
bedeutet  die  Anwendung  von  Typumwandlungen  immer  ein  Risiko  fÅr  die
PortabilitÑt von Programmen!)
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 31
________________________________________________________


Funktion CADR

Megamax-Erweiterung

CADR steht fÅr constant address. Diese Funktion hat die selbe Funktion wie
ADR, nur erlaubt sie nicht nur Variable als Argument, sondern auch Konstante.
Die Konstante wird dann im Code abgelegt und ihre Adresse zurÅckgegeben.
Da der Wert im Code liegt, der niemals verÑndert werden darf, sollte diese
Funktion entsprechend auch nur verwendet werden, wo dies sichergestellt ist.

Die typische Anwendung findet sich bei der öbergabe von String-Konstanten
als Argument bei den SYSTEM-Funktionen CALLSYS und CALLEXT (s.u.). Aber
sie erlaubt beispielsweise auch die Adreûermittelung bei REF-Parametern (was
ADR nicht erlaubt), um - natÅrlich nur lesend - mit Zeigern auf den formalen
Parameter zuzugreifen.


Prozeduren CODE, LOAD und STORE

Megamax-Erweiterung

Wollen  Sie  auf  die  Register  der  CPU  zugreifen  oder  kleine  Maschinen~
anweisungen oder Tabellen in den Code einfÅgen, ohne den Inline-Assembler zu
benutzen,  kînnen  Sie  sich  dieser  Funktionen  bedienen.  Sie  sind  auch  in
Ñhnlicher Form bei anderen Modula-Compilern fÅr den Atari ST vorhanden und
verhelfen dadurch ggf. zu leichterer Portierbarkeit (beispielsweise sind sie beim
HÑnisch-Modula in gleicher Weise und Funktion vorhanden, TDI-Modula bietet
REGISTER und  SETREG  statt  STORE  bzw.  LOAD).  Allerdings  ist  trotzdem
Vorsicht geboten - interne  Regeln  des  jeweiligen  Compilers  (nÑheres  siehe
Kapitel 4 Åber den Assembler) kînnen dem trotzdem einen Strich durch die
Rechnung machen!

CODE hat einfach beliebig viele, mit Kommata getrennte SHORTCARD (16-Bit)-
Parameter, die alle Konstante sein mÅssen und direkt in den Code eingefÅgt
werden, wie beim DC.W-Pseudo-Op des Assemblers.

LOAD lÑdt den Wert des im ersten Argument angegebenen Ausdrucks in das
danach  angegebene  Register.  Der  Ausdruck  muû  einen  Wert  der  Grîûe
zwischen einem und vier Byte erzeugen und wird immer auf 4 Byte expandiert.
Die Register-Nummer ist als Konstante anzugeben: 0 bis 7  stehen  fÅr  die
Datenregister D0 bis D7, 8 bis 15 fÅr die Adreûregister A0 bis A7.

STORE speichert das zuerst angegebene Register (s. LOAD) in die daraufhin
angegebene Variable, die maximal eine Grîûe von 4 Byte haben darf.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 32
________________________________________________________


Prozeduren CALLSYS und CALLEXT

Megamax-Erweiterung

Sie dienen zum Aufruf externer Funktionen, also solchen, die nicht in Modulen
des Megamax-Systems implementiert und deshalb importierbar sind. Dies sind
hauptsÑchlich die Funktionen des Betriebssystems TOS (GEMDOS, BIOS usw.).
Wir  haben  natÅrlich  fÅr  diese  Betriebssystem-Routinen   Prozeduren   in
Megamax-Modulen   erstellt,   die   dann   die   Routinen   ihren   besonderen
Konventionen entsprechend aufrufen. Sie finden sich in den Modulen GEMDOS,
BIOS, XBIOS, LineA sowie den AES- und VDI-Modulen.

Allerdings kann es immer mal vorkommen, daû Sie nicht diese vorbereiteten
Modula-Prozeduren aufrufen wollen, oder  in  einer  kommenden  TOS-Version
neue  Funktionen  enthalten  sind,  fÅr  die  wir  noch  keine  Modula-Prozedur
vorgesehen haben.

Die  Routinen  gliedern  sich  dabei  in  mehrere  Gruppen  (GEM,  LineA  sowie
GEMDOS  &  BIOS  &  XBIOS),  die  alle  auf  verschiedene  Weise  aufgerufen
werden mÅssen. FÅr die GEMDOS/BIOS/XBIOS-Aufrufe ist  dabei  CALLSYS
vorgesehen:  Der  erste  Parameter  gibt  die  TRAP-Nummer  an,  also  1  fÅr
GEMDOS,  13  fÅr  BIOS  und  14  fÅr  XBIOS  (die  TRAP-Nummer  muû  eine
Konstante zwischen Null und 15 sein). Danach kînnen beliebig viele weitere
Parameter folgen (wie in der Sprache C, s.u.). Alle diese Werte werden auf
den  A7-Stack  geladen,  und  danach  wird  die  gewÅnschte  TRAP-Instruktion
ausgefÅhrt.

FÅr den Fall, daû eine Routine aufgerufen werden soll, die nicht Åber einen
TRAP erreicht wird, sondern mit einer JSR-Instruktion gerufen wird, und die
auch die Parameter auf dem A7-Stack erwartet, kann CALLEXT verwendet
werden: Statt einer TRAP-Nummer wird hier als erster Parameter die Adresse
der Routine angegeben.

Sie kînnen CALLSYS (und CALLEXT) sowohl als Prozedur aufrufen als auch
als Funktion in einem Ausdruck verwenden. Im zweiten Fall wird der RÅck~
gabewert der externen Funktion aus dem Register D0 als Funktionsergebnis
verwendet, und zwar als LONGWORD-Typ. Das bedeutet, daû Sie den Wert
noch mittels der CAST-Funktion in den benîtigten Typ wandeln mÅssen.

FÅr externe Routinen, die auf eine andere Weise ihre Parameter erwarten,
sind  auûerdem  noch  Funktionen  im  Modul  Calls  vorhanden,  speziell  fÅr
individuelle  GEM-Aufrufe  eignen  sich  die  Grundfunktionen  in  den  Modulen
AESBase und VDIBase.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 33
________________________________________________________


FÅr   die   Parameter   bei   CALLSYS   und   CALLEXT   gelten   noch   einige
Besonderheiten:
  * Jedes Argument darf die Grîûe von vier Byte nicht Åberschreiten, sonst
    erfolgt eine Fehlermeldung. Bei Strings wird beispielsweise ihre Adresse
    mit  der  SYSTEM-Funktion  ADR  (oder  CADR  bei  String-Konstanten)
    Åbergeben.
  * Untypisierte  Zahl-Konstanten  werden,  wenn  sie  zwischen  -32768  und
    65535 liegen, als SHORTCARD bzw. SHORTINT auf den Stack geladen,
    grîûere  Werte  entsprechend  als  LONGCARD  bzw.  LONGINT.  Soll  ein
    kleiner Wert als Long-Wert Åbergeben werden, ist ihm ein "L" oder "D"
    anzuhÑngen (Bsp: 0L fÅr eine Null-Konstante mit 32 Bit) oder man muû sie
    mit VAL oder LONG anpassen.
    Byte-Daten wie CHAR werden auf dem Stack auf der niedrigeren Adresse
    der  beiden  Bytes  eines  Stack-Words  abgelegt.  Die  meisten  Parameter
    erwarten trotz Byte-Parametern aber ein Word auf dem Stack (beispiels~
    weise alle TOS-Funktionen). Dazu wird in der Regel ein Byte-Datum zu
    einem Word-Datum expandiert. Wollen Sie also beispielsweise die GEMDOS-
    Funktion "Conout" aufrufen, mÅssen Sie das  auszugebende  Zeichen  als
    SHORTCARD-Wert Åbergeben, z.B. durch "ORD (character)".

Beispiele:

    CALLSYS (1, 2, ORD("A") );                    (*  Conout ("A")        *)
    CALLSYS (1, 9, CADR("text"));                 (*  Conws ("text")      *)
          :                                                     :
    char  = CAST (CHAR, CALLSYS (13, 2, 2);    (*  char  = Bconin (2)  *)


Prozeduren NEWPROCESS, TRANSFER, IOTRANSFER, LISTEN und IOCALL

PROCEDURE NEWPROCESS (p: PROC; a: ADDRESS; n: LONGCARD;
                               VAR q: ADDRESS);
PROCEDURE TRANSFER (VAR from, to: ADDRESS);
PROCEDURE LISTEN ();

Die Prozeduren erlauben die Einrichtung und AusfÅhrung von Coroutinen, wie
sie im Modula-Standard definiert sind. Hier nur zwei  Anmerkungen  zu  den
Parametern: Die Deskriptoren fÅr die Coroutinen <q>, <from>, <to> sind nach
der  revidierten  Sprachdefinition  nicht  mehr  vom  Typ  PROCESS,  sondern
ADDRESS. Die LÑnge des Arbeitsbereiches <n> fÅr NEWPROCESS wird - wie
alle Speichergrîûen - als LONGCARD angegeben.

Die Funktionen und Coroutinen dÅrfen nur im Usermode ausgefÅhrt werden!
Dies ist der Normalfall und nur zu beachten, wenn Sie teilweise absichtlich im
Supervisor-Modus arbeiten.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 34
________________________________________________________


FÅr sogenannte Monitore kann in bekannter Weise im Modulkopf hinter dem
Modulnamen in eckigen Klammern eine Zahl von eins bis sieben, entsprechend
der Interrupt-PrioritÑten der 68000-CPU, angegeben werden. Alle Prozeduren
innerhalb dieses Moduls werden dann mit der betreffenden  Interrupt-Maske
ausgefÅhrt.

LISTEN erlaubt es, in Monitor-Modulen (mit Angabe der Interrupt-PrioritÑt im
Modulkopf)  kurzfristig  Interrupts  mit  niedrigem  Vorrang  zuzulassen.  Die
Interrupt-PrioritÑt, die im Modulkopf angegeben wurde, wird dabei kurzzeitig
um Eins verringert.

Ein Anwendungsbeispiel zeigt das Modul HaTschi im DEMO-Ordner.


PROCEDURE IOTRANSFER (VAR from, to: ADDRESS; vector: ADDRESS);

Vorsicht:
IOTRANSFER  erhÑlt  die  absolute  Adresse  des  Vektors  und  nicht  die
Vektornummer wie bei den meisten anderen Modula-Systemen auf dem ST!

                        >
Ist die Vektoradresse  = 1024, wird automatisch erkannt, daû der Einsprung
nicht durch eine Exception, sondern durch  einen  normalen  Unterprogramm~
aufruf erfolgen wird. Somit ist IOTRANSFER auch auf andere Systemvektoren,
z.B. die VBL-Queue, anwendbar.

Sobald nach der IOTRANSFER-Installation der RÅcktransfer stattfindet, egal,
ob Åber den installierten Vektor oder Åber einen expliziten TRANSFER-Aufruf,
wird der alte Vektor wieder hergestellt. öblicherweise ist daher vor Beendigung
des Programms  ein  globales  Flag  zu  setzen  und  dann  ein  TRANSFER  zur
Funktion, die den IOTRANSFER auslîste, damit diese dann nach Erkennung des
Flags mit TRANSFER zurÅckkehrt, um den Vektor nicht wieder zu verÑndern.
Der Vektor muû auf jeden  Fall  bei  Beendigung  des  Programms  restauriert
werden. Dazu sollte CatchProcessTerm (Modul PrgCtrl) benutzt werden, um
auch bei unerwarteten ProgrammabbrÅchen den alten Vektor wiederherstellen
zu kînnen. (Siehe Hatschi im DEMO-Ordner).

Die Coroutine wird je nachdem, ob sie durch einen expliziten TRANSFER oder
durch einen Aufruf Åber den angegebenen Vektor im User- bzw. im Supervisor-
Modus ausgefÅhrt.
3.3 Megamax Modula: SYSTEM-Modul                                    3 - 35
________________________________________________________


PROCEDURE IOCALL (vector: ADDRESS);

Megamax-Erweiterung

Diese Funktion darf nur nach einer IOTRANSFER-Funktion ausgefÅhrt werden.
Sie dient dazu, die Routinen aufzurufen, die vor dem IOTRANSFER-Aufruf auf
der anzugebenden Vektoradresse aktiv waren. Wenn man sie z.B. regelmÑûig
(200 Hz) Åber den EtvTimer-Vektor (Adr. $400) aufrufen lassen will, kann
man  ihn  mit  der  IOTRANSFER-Funktion  belegen.  Da  sich  aber  auch  noch
weitere, GEMDOS-interne Funktionen dieses Vektors bedienen, mÅssen auch
sie regelmÑûig ausgefÅhrt werden. Um dies zu erreichen, braucht nur IOCALL
wÑhrenddessen  aufgerufen  werden.  Die  angegebene  Routine  wird  dann  im
Supervisormodus ausgefÅhrt.


Benutzung der FPU in Coroutinen

Bei einem Prozeûwechsel mit TRANSFER/IOTRANSFER werden nur die Register
des  Hauptprozessors  (680x0)  gerettet/restauriert.  Die  Register  und  Ein~
stellungen einer eventuell verwendeten FPU aber nicht! Wird in mehreren, sich
abwechselnden  Coroutinen  die  FPU  benutzt,  mÅssen  die  FPU-Register  "von
Hand" mittels der Funktionen des Moduls FPUSupport umgeschaltet werden.
Mehr dazu im Definitionstext des Moduls.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 36
________________________________________________________


3.4   Compilerdirektiven  (-optionen)

Sie haben zahlreiche Mîglichkeiten, die Arbeitsweise des Modula-Compilers zu
beeinflussen.  Dazu  gibt  es  eine  Reihe  von  "Schaltern",  die  Sie  hin-  und
herschalten kînnen. Zum Beispiel kînnen Sie entscheiden...

- wie pingelig der Compiler auf korrekte Groû-/Kleinschreibung achten soll;
- wieviel Aufwand er treiben soll, um Laufzeitfehler zu entdecken;
- ob Sie bei der Fehlersuche zusÑtzliche UnterstÅtzung haben mîchten.

Vor der öbersetzung jedes Moduls werden die Schalter auf ihre Voreinstellung
gebracht (siehe "öbersicht aller  Direktiven").  Im  allgemeinen  sind  die  Vor~
einstellungen  so  gewÑhlt,  daû  maximale  Sicherheit  beim  öbersetzen  und
anschlieûendem  Programmlauf  besteht.  Diese  Voreinstellung  kann  in  der
Compiler-Parameter-Box der Shell verÑndert werden.

Weiterhin kînnen  Compiler-Direktiven  an  beliebiger  Stelle  im  Programmtext
stehen.  Sie  werden  dann  immer  ab  dieser  Stelle  gÅltig.  Auf  diese  Weise
kînnen die Direktiven auch innerhalb eines Programms beliebig oft umgeschaltet
werden, um z.B. nur bei der öbersetzung einzelner Prozeduren die Fehler~
prÅfung auszuschalten.

Die  Direktiven  sind  natÅrlich  alle  Megamax-spezifisch,  also  nicht  ohne
énderungen auf andere Compiler Åbertragbar!


Syntax einer Compilerdirektive in der Compiler-Parameter-Box

In der Direktiven-Eingabezeile kînnen nur Schalter, jedoch keine Direktiven, die
einen Text als Argument haben (z.B.  Include,  Use),  bestimmt  werden.  Die
Syntax ist recht einfach: Der jeweilige Buchstabe, der auch im Programmtext
(s.u.) fÅr die Direktive Verwendung findet, wird wahlweise mit einem Plus-
oder Minuszeichen eingeleitet. Werden mehrere Direktiven eingegeben, mÅssen
sie durch Leerzeichen getrennt werden!

Beispieltext zum Abschalten der Bereichs- und der StackprÅfungen:
   -r -s                    (Achtung: Leerzeichen zw. den Direktiven beachten!)

Wird der Compiler als eigenstÑndiges Programm gestartet, z.B. durch Linken
zusammen mit dem Modul CompInit (s. UTILITY-Ordner), kînnen diese Direk~
tiven in gleicher Form in der Argumentzeile Åbergeben werden.

Die Direktiven in der Compiler-Optionen-Box sind lediglich Voreinstellungen fÅr
jedes einzelne Modul - sobald  im  Programmtext  eines  Moduls  eine  gegen~
sÑtzliche Direktive erscheint, bestimmt sie die neue Einstellung.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 37
________________________________________________________


Syntax einer Compilerdirektive im Programmtext

Compilerdirektiven sehen aus wie Kommentare, deren erstes Zeichen ein $ ist.
Dann wird die gewÅnschte Option durch einen Buchstaben gewÑhlt, gefolgt von
+, - oder = zur Einstellung des Schalters. Ein Schalter wird mit + ein- und mit
- ausgeschaltet; mit = setzen Sie den Schalter auf die Position vor der letzten
Umschaltung  zurÅck.  (Allerdings  wird  nur  ein  Schalterzustand  gespeichert;
mehrere = in Folge sind also nicht zulÑssig!)

Sollen weitere Optionen folgen, dann kînnen sie jeweils durch Kommata ge~
trennt angegeben werden; ist das nÑchste Zeichen nach +/- kein Komma, so
wird der Rest des Textes bis zur Klammer *) als Kommentar interpretiert.
Leerzeichen werden Åberall ignoriert, auûer zwischen (* und $. (Wenn dort ein
Leerzeichen steht, ignoriert der Compiler die Option als normalen Kommentar -
eine einfache Mîglichkeit also, eine Compileroption  schnell  mal  'ungÅltig'  zu
machen.)

Alles klar? Sonst helfen bestimmt einige Beispiele beim Umgang mit Compiler~
optionen:

richtig: (*$ R+ *)
        (*$ c-, r-, q+ *)           mehrere Optionen durch Komma trennen
        (*$ R- Rangecheck aus*)   nach der letzten Option Kommentar mîglich
falsch: (* $ R+ *)                  Kommentar! (Leerzeichen vor $)
        (*$ R+, Rangecheck an *) hinter Komma muû weitere Option folgen!
        (*$ R+ Q- *)                Q+ ist Kommentar (Komma fehlt)

Nachdem  Sie  nun  wissen,  wie  eine  Compileroption  aussieht,  soll  verraten
werden, was sich damit  machen  lÑût.  Folgende  Optionen  stehen  Ihnen  zur
VerfÅgung:


Groû-/Kleinschreibung (Case Sensitivity)

Die Definition von Modula-2 schreibt vor, daû zwischen Groû- und Kleinschrei~
bung  streng  unterschieden  wird.  Hallo  und  HALLO  sind  also  verschiedene
Bezeichner; das reservierte Wort REPEAT muû stets groûgeschrieben werden;
bei importierten Bezeichnern (z.B. WriteLn) ist ebenfalls genau auf die Schreib~
weise zu achten. Auch der Megamax Modula-Compiler besteht normalerweise
auf diesen Unterscheidungen. Falls Ihnen diese 'Case Sensitivity' aber lÑstig
wird, kînnen Sie sie mit (*$ C- *) abschalten - dann verhÑlt sich der Compiler
so, wie Sie es vielleicht schon von Pascal-öbersetzern gewohnt sind.

Voreinstellung: (*$ C+ *)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 38
________________________________________________________


BereichsprÅfungen (Range Checking)

Der Compiler erzeugt bei der  öbersetzung  Ihrer  Programme  auch  68000-
Anweisungen, die zur Laufzeit der Programme bestimmte Fehlerquellen ÅberprÅ~
fen und ggf. eine Fehlermeldung auslîsen. Im einzelnen werden ÅberprÅft:

    * öberlÑufe beim Rechnen mit ordinalen Typen;
    * Zuweisung illegaler Werte auf ordinale Typen;
    * Zugriff auf Feldelemente auûerhalb des deklarierten Feldes.
    * korrekte Selektion bei CASE-Anweisungen (fehlt der ELSE-Zweig  und
      wird keine der Marken angesprungen, ist das ein Fehler!)

Diese  PrÅfungen  erleichtern  bei  der  Erstellung  eines  neuen  Programms
die Fehlersuche sehr; allerdings kosten sie natÅrlich etwas Zeit und RAM-Platz.
Wenn  Sie  ein  Programm  vollstÑndig  ausgetestet  haben,  kînnen  Sie  mit
(*$ R- *) die BereichsprÅfung ausschalten. Im Normalfall gewinnen Sie damit
10..20% Platz und Geschwindigkeit; in einzelnen FÑllen kann der Effekt deutlich
grîûer (oder kleiner) sein.

Beachten Sie bitte, daû auch in der Einstellung (*$ R- *) manche Fehler noch
erkannt und gemeldet werden - die Prozeduren des RUNTIME-Moduls, etwa
fÅr  REAL-Arithmetik,  prÅfen  weiterhin  auf  öberlauf.  Das  Abschalten  der
BereichsprÅfung bietet also keine GewÑhr dafÅr, daû vom Modula-System keine
Fehlermeldungen mehr erscheinen. Wenn sie fÅr alle FÑlle von Laufzeitfehlern
gerÅstet sein wollen, mÅssen Sie die Fehler selbst abfangen - lesen Sie dazu
das Kapitel Åber Laufzeitfehlerbehandlung (Kapitel 5).

Voreinstellung: (*$ R+ *)


Stack-PlatzprÅfung

Eine Sonderrolle bei den PrÅfungen, die der Compiler in die erzeugten Pro~
gramme einbaut, nimmt die öberwachung des verfÅgbaren Stack-Bereichs ein.
WÑhrend des Programmablaufs werden nicht nur Prozedurparameter Åber den
Stack Åbergeben, sondern auch alle lokalen Variablen dort angelegt. Insbeson~
dere bei rekursiven Algorithmen besteht die Gefahr eines Stack-öberlaufs.

Zu Beginn jeder aufgerufenen Prozedur wird ÅberprÅft, ob der  Stack  noch
Platz fÅr die neuen lokalen Variablen und eine Reserve fÅr evtl. folgende Parame~
terÅbergaben bietet. (Der benîtigte Reserve-Platz kann natÅrlich nur abgeschÑtzt
werden, s.u.) Diese PrÅfung kînnen Sie durch Angabe von (*$ S- *) unter~
drÅcken. Da ein unerkannter StackÅberlauf meist fatale Folgen hat, sollten Sie
dies nur in begrÅndeten FÑllen tun!
3.4 Megamax Modula: Compilerdirektiven                                 3 - 39
________________________________________________________


Wird wÑhrend des Programmlaufs dank der Stack-PrÅfung eine entsprechende
Fehlermeldung angezeigt,  kann  der  dem  Programm  zur  VerfÅgung  gestellte
Stack-Bereich in der Shell leicht auf einen grîûeren Wert eingestellt werden
(Umgebungs-Info-Box bzw. Linker-Parameter-Box).

Auûer der Åblichen Schalterfunktion bietet die S-Option aber noch die Mîglich~
keit, die geforderte Platzreserve auf dem Stack einzustellen. In aller Regel
kann der voreingestellte Wert unverÑndert bleiben. Soll jedoch eine Prozedur
(z.B. als Coroutine) mit einem sehr kleinen Stackbereich  auskommen,  kann
diese AbschÑtzung zu groûzÅgig sein. Zur Umstellung des Wertes geben Sie
hinter dem S eine CARDINAL-Zahl (dezimal) an.

Achtung!  Mit  der  S-Option  kann  nicht  der  zu  verwendende  Stack-Bereich
bestimmt werden, sondern nur die Grenze, wieviel freier Stack verbleiben muû,
bevor ein Fehler gemeldet werden soll! Die Bestimmung des reellen  Stack-
Bereichs erfolgt in der Shell Åber die Parameter-Dialoge.

Voreinstellung: (*$ S+, S 512 *)


Testhilfen (Debugging)

Wahrscheinlich  ist  das  Fehlersuchen  in  (fast)  fertigen  Programmen  nicht
gerade  Ihre  LieblingsbeschÑftigung.  Testausgaben  ins  Programm  schreiben,
Åbersetzen, ausprobieren, noch  mehr  Testausgaben,  noch  mal  Åbersetzen...
Das kînnte Ihnen der Rechner eigentlich auch abnehmen!

Kann er auch, und zwar dann, wenn Sie die 'verdÑchtigen' Programmteile mit
der Optionseinstellung (*$ D+ *) Åbersetzen! In den Programmcode werden
dann zusÑtzliche Anweisungen eingefÅgt, die

- den Text jeder bearbeiteten Programmzeile anzeigen;
- darunter die Werte aller berechneten arithmetischen AusdrÅcke ausgeben;
- von der Tastatur aus Einzelschrittbetrieb einschalten lassen.

Statt dessen (oder auch zusÑtzlich) kann die Direktive $E+ verwendet werden,
um bei jedem Ein-/Austritt einer Prozedur deren Namen anzeigen zu lassen.

Der  Umgang  mit  der  Debug-Option  wird  im  Kapitel  2.5  beschrieben.  Hier
mîchten wir nur noch schnell darauf hinweisen, daû Programme im Debug-
Modus deutlich langsamer laufen und mehr Platz fÅr den Code brauchen - Sie
sollten mit der Debug-Option also sparsam umgehen.

Voreinstellung: (*$ D-, E- *)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 40
________________________________________________________


Lokale Prozeduren als aktuelle Parameter

Die im Kapitel 3.1 beschriebene Spracherweiterung lÑût sich mit $H+ nutzen.

Voreinstellung: (*$ H- *)


Erweiterte Syntax

Die im Kapitel 3.1 beschriebene Spracherweiterung lÑût sich mit $A+ nutzen.

Voreinstellung: (*$ A- *)


Zuweisungen von LONGs auf SHORTs

Durch $K+ erlaubt Megamax Modula-2 die Zuweisung von LONGCARD- oder
LONGINT-Werten auf SHORTCARD- oder SHORTINT-Variablen.

Voreinstellung: (*$ K- *)


Automatische Register-Optimierung bei FOR-Schleifen

Wie  schon  in  Kapitel  3.1  beschrieben,  werden  bestimmte  Bedingungen  an
Laufvariablen fÅr FOR-Schleifen geknÅpft. Nur wenigen ist dies bisher bewuût
gewesen, noch weniger hielten sich daran, hîchstens aus Zufall. Durch unsere
neue  automatische  Register-Verwendung  bei  FOR  stieûen  wir  nun  auf  den
Grund  dieser  EinschrÑnkungen:   Nur   so   ist   Åberhaupt   eine   effiziente
Optimierung der FOR-Schleife mîglich, besonders in Hinblick auf die Register-
Verwendung.

Sollten  Sie  in  Zukunft  also  einmal  auf  eine  der  Compiler-Fehlermeldungen
stoûen,  die  etwas  an  Ihrer  FOR-Variable  herummÑkeln,  bereinigen  Sie
entweder das öbel oder unterbinden Sie die Register-Belegung durch Verwen~
dung der Direktive $J-.

Sollten Sie einmal unerklÑrliche Fehler in Ihrem Programm vermuten, sollten
Sie ebenfalls zuerst die $J- Direktive einsetzen (am besten  als  -J  in  der
Direktiven-Zeile der Compiler-Parameter-Box), um zu prÅfen, ob der Fehler
dann immer noch auftritt. Ist der Fehler dann behoben,  kann  es  entweder
daran liegen, daû eine in Assembler erstellte Funktion eines der geschÅtzten
Register (D3-D7, A4-A6) verÑndert hat, oder daû eine sonstige Verletzung der
FOR-Regeln vorliegt, die der Compiler nicht erkennen konnte (wahrscheinlich
durch Einsatz von Assembler-Routinen).

Voreinstellung: (*$ J+ *)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 41
________________________________________________________


Optimierte RÅckgabe von Funktionsergebnissen im Register

Sicher haben Sie schon gelernt, daû Register fÅr  Optimierung,  speziell  fÅr
hîhere AusfÅhrungsgeschwindigkeit, stehen. So ist es wÅnschenswert, so oft
wie mîglich die Prozessor-internen Register statt den normalen Speicher fÅr
die Ablage von Variablen und Zwischenergebnissen zu verwenden.

Eine einfache und wirksame Mîglichkeit ist, Funktionsergebnisse nicht auf dem
Stack (im Speicher), sondern in einem Register zu liefern, sofern sie hinein~
passen. Was da intern passiert, wollen wir an dieser Stelle nicht erklÑren,
wohl aber, warum wir so lange um den heiûen Brei herumschreiben: Bisher
wurden beim Megamax-System alle Parameter  und  Ergebnisse  im  Speicher
Åbergeben. Viele von uns erstellte Prozeduren in der Modul-Bibliothek wurden
in Assembler programmiert. Auch einige Anwenderprogramme von Ihnen mîgen
in Assembler  unsere  Prozeduren  aufrufen.  WÅrde  man  nun  die  öbergabe~
konventionen pauschal Ñndern, gÑbe  es  viel  Arbeit,  alle  Assembler-Routinen
anzupassen.

Zweitens  mÅssen  die  Funktion  und  ihr  Aufruf  zueinander  passend  kodiert
werden.  Das  bedeutet,  daû  auch  PROCEDURE-Typen  schon  die  Aufruf-/
öbergabekonvention festgelegt haben mÅssen.

Deshalb bleiben wir in der Regel erstmal bei der alten öbergabekonvention.
Optional kann Åber eine Direktive ($Z+) eine Funktions-Prozedur so deklariert
werden, daû sie ihr Ergebnis im Register statt im Speicher zurÅckgibt. Dann
muû aber darauf geachtet werden, daû sowohl bei FORWARD-Deklarationen,
als auch in Definitionsmodulen die Einstellungen mit der bei der Implementation
Åbereinstimmen  mÅssen.  Das  gleiche  gilt,  wenn  Prozedur-Typen  deklariert
werden: Wenn also ein Versionskonflikt bei einer Zuweisung einer Funktions-
Prozedur angezeigt wird, sind nicht nur die Parameter auf öbereinstimmung,
sondern auch die Einstellung der $Z-Direktive zu vergleichen.

Voreinstellung: (*$ Z- *)


SET-Format

SETs bis 32 Bit werden in einem definierten Format auf die Bits des Prozes~
sors abgebildet (s. Anhang, interne Datenformate). Alte Compiler bis einschlieû~
lich Version 3 legten SETs aber in einem anderen Format ab. Um Anpassungen
alter Programme zu erleichtern, kann mit der Direktive $U- das alte Format
eingestellt werden. Die aktuelle Einstellung ist nur relevant fÅr die Typdeklara~
tion von SETs; BITSET liegt nur im neuen Format vor! Ersatzweise ist nach
$U- ein neuer Typ als SET OF  0..15  zu deklarieren, und die betroffenen
BITSET-Verwendungen sind dann durch diesen neuen Typ zu ersetzen.

Voreinstellung: (*$ U+ *)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 42
________________________________________________________


Register-Variable

Durch das einfache Ein-Pass Konzept des Compilers kann  er  leider  (noch)
nicht selbsttÑtig entscheiden, wann  es  gÅnstig  ist,  Variablen  Åber  mehrere
Anweisungen hinweg in den nur begrenzt zur VerfÅgung stehenden Registern
der CPU zu halten. Statt dessen legt er sie immer im Speicher ab, was mehr
Zeit und ProgrammlÑnge benîtigt.

DafÅr ist Ihnen aber mîglich, dem Compiler von vornherein mitzuteilen, daû er
bestimmte Variablen in Registern halten soll. Dies wird erreicht, indem vor die
betreffende  Variable  bei  ihrer  Deklaration  die  Direktive  (*$ Reg *)  gesetzt
wird. Dann wird die Variable in der gesamten Prozedur im Register gehalten.

Allerdings gibt es dabei einige Restriktionen, die vom Compiler auch geprÅft
werden, und bei denen er dann ggf. eine Fehlermeldung anzeigt:

  * Nur lokale Variablen kînnen in Registern gehalten werden.
  * Die lokalen Variablen dÅrfen jeweils nicht mehr als 4 Byte belegen.
  * Es darf weder die Adresse solch einer Variable mit ADR ermittelt, noch
    darf sie an einen VAR-Parameter Åbergeben werden.
  * Auf  eine  Register-Variable  darf  nicht  in  einer  dazu  lokalen  Prozedur
    zugegriffen werden.
  * Kommt in der Prozedur eine WITH-Anweisung vor, muû dazu mindestens
    ein  nicht-temporÑres  Adreû-Register  noch  frei  sein.  Da  z.Zt.  nur  ein
    solches Adreû-Register zur VerfÅgung steht, heiût das: Bei Verwendung
    von WITH darf keine  POINTER-Variable  als  Register-Variable  deklariert
    werden.

Die nicht-temporÑren Register, die  sich  damit  als  Register-Variable  eignen,
sind zur Zeit: D3 bis D7 und A4. Die Daten-Register (D3-D7) werden fÅr
skalare  Register-Variablen  verwendet,  Adreû-Register  (A4)  fÅr  POINTER.
Werden  mehr  Register-Variablen  deklariert,  als  Register  dafÅr  vorgesehen
bzw. frei sind, kommt keine Fehlermeldung, sondern es werden nur die zuerst
deklarierten Variablen auf die entsprechenden Register aufgeteilt, die restlichen
bleiben im Speicher, wie sonst auch.

Es gibt Datentypen, die sich theoretisch als Register-Variablen eignen, aber
z.Zt. nicht vom Compiler unterstÅtzt werden. Ihre Deklaration als Register-
Variable erzeugt keine Fehlermeldung. So kînnen Sie schon jetzt Variablen fÅr
Register  vorsehen,  die  erst  in  spÑteren  Compiler-Versionen  entsprechend
benutzt werden - eine vorsorgliche Optimierung.

Bei  zeitintensiven  Prozeduren  lohnt  es  sich  oft,  mit  ein  paar  Blicken
abzuschÑtzen,  welche  Variablen  in  jeder  einzelnen  Prozedur  am  hÑufigsten
benutzt werden (z.B. in Schleifen), um diese dann als Register-Variablen zu
deklarieren.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 43
________________________________________________________


Beispiel:

  (* folgende Funktion liefert TRUE, wenn das Åbergebene Feld
   * nur Nullwerte enthÑlt:
   *)
  PROCEDURE nullFeld (VAR feld: ARRAY OF CARDINAL): BOOLEAN;
    VAR (*$Reg*) c: CARDINAL;
         (*$Reg*) ptr: POINTER TO CARDINAL;
    BEGIN
      ptr:= ADR (feld);     (* Startadresse vom Feld ermitteln *)
      (* nun alle Werte einzeln prÅfen *)
      FOR c:= 0 TO HIGH (feld) DO
        IF ptr^ # 0 THEN
          RETURN FALSE
        END;
        INC (ptr, SIZE (ptr^))
      END;
      RETURN TRUE
    END nullFeld;

Im  obigen  Beispiel  brÑuchte  'c'  nicht  als  Register-Variable  deklariert  zu
werden, weil die Laufvariable schon automatisch von der FOR-Anweisung im
Register gehalten wird.


Mathe-Koprozessor (FPU)

Ist im Atari ST oder Atari TT ein Mathe-Koprozessor vorhanden (z.B. SFP004
von Atari f. den ST bzw. 68882 im TT) kann er automatisch genutzt werden.
Dazu muû der Compiler allerdings anderen Code erzeugen als ohne eine solche
FPU (Floating Point Unit). Das bedeutet:  Um  die  FPU  zu  nutzen,  muû  ein
Programm speziell dafÅr Åbersetzt werden, umgekehrt kann ein fÅr die FPU
Åbersetztes Programm nicht in einem Rechner ohne diese Zusatz-Hardware
ablaufen.

Das hîrt sich erst einmal nachteilig an. Wir sind beim Megamax-System dazu
gezwungen, weil wir bei Verwendung der FPU mit ihrem internem Darstellungs-
Format (nach IEEE-Norm) arbeiten mÅssen, wÑhrend wir ohne die FPU mit
unserem  eigenen  Format  rechnen,  das  in  der  reinen  Software-Auswertung
gegenÅber dem IEEE-Format schneller ist. Beide Formate sind demnach nicht
kompatibel und erfordern deshalb unterschiedliche Behandlungen und Bibliotheks~
module (so sind in den Ordnern ST FPU und TT FPU gesonderte Module fÅr
                                     _             _
das IEEE-Format enthalten).

Aber wir haben daraus einen Vorteil gezogen: Da der Compiler nun Åber die
Existenz der FPU informiert wird,  kann  er  sich  darauf  einstellen  und  ihre
besonderen FÑhigkeiten besser nutzen, als dies durch einen reinen Austausch
3.4 Megamax Modula: Compilerdirektiven                                 3 - 44
________________________________________________________


der  normalen  Real-Laufzeitfunktionen  mîglich  wÑre.  Ein  Beispiel:  Die  FPU
besitzt 8 Register, in denen sie Real-Werte speichert. Greift sie auf diese
internen Register zu, geht das viel schneller als der Zugriff auf die Variablen
im  Speicher,  wo  Variablen  normalerweise  abgelegt  werden.  WÑhrend  die
Zwischenergebnisse  bei  der  Software-Lîsung  ohne  FPU  immer  wieder  im
Speicher abgelegt werden mÅssen, kann der Compiler bei der FPU diese Werte
in den Registern ablegen. So wird der Geschwindigkeitsvorteil umso grîûer, je
komplexer ein Ausdruck wird. Auûerdem sollen beim Megamax-System auch
Register-Variable fÅr Reals mîglich werden (beachten Sie die Hinweise in der
Datei LIESMICH.TXT), was nochmals einen deutlichen Vorteil bringt.

Die Wahl des Real-Formats bzw. der FPU kann auf zwei Arten geschehen:
Wird keine besondere Direktive verwendet ($F), wird das Format verwendet,
das in der Shell in der Umgebungs-Info-Box unter Real-Format angezeigt wird.
Diese Shell-Einstellung ist fest beim Linken der Shell bestimmt worden (durch
Wahl der Module ausschlieûlich aus dem IMP-Ordner bzw. durch Verwendung
derer aus dem Ordner FPU) und kann nicht verÑndert  werden.  Das  IEEE-
Format steht dabei fÅr die FPU-Verwendung, das Megamax-Format  fÅr  die
Software-Lîsung.

Wer eine FPU besitzt, linke sich also (siehe Linken der Shell, Kap. 2) eine
Shell mit den FPU-Modulen und starte dann diese Shell zum öbersetzen neuer
Module, die die FPU nutzen sollen.

Wer keine FPU besitzt, kann die FPU-Shell nicht benutzen, weil sie nur mit
einer FPU lauffÑhig ist. Die Direktive $F ist hier die Lîsung: $F- erzeugt Code
fÅr die Software-Lîsung, $F+ fÅr die FPU-Verwendung. Die Direktive muû vor
der ersten Benutzung von Reals stehen und darf nicht mehrmals im Modul mit
verschiedenen  Einstellungen  vorkommen,  sonst  meldet  der  Compiler  einen
Fehler. Nur wenn die Direktive nicht im Text oder in der Direktiven-Zeile der
Shell vorkommt, wird das Format verwendet, das in der Shell bestimmt ist.

Voreinstellung: Format der Shell verwenden


Ausgaben des Compilers (Quiet Compilation)

WÑhrend  der  öbersetzung  protokolliert  der  Compiler  auf  dem  Bildschirm,
welches Modul er gerade bearbeitet und welche Prozedur jeweils  Åbersetzt
wird. Diese Ausgaben kînnen Sie durch Setzen von (*$ Q+ *) abschalten; in
dieser Einstellung wird Ihnen der Compiler nur noch anzeigen, wenn  er  zu
einem neuen Quell-Textfile wechselt (s. Include-Option). Bei der öbersetzung
groûer Programme kînnen Sie so den öberblick behalten, wie weit der Compiler
gekommen ist, ohne daû die Ausgabe durch die Auflistung der einzelnen Proze~
duren gestîrt wird. (Ein biûchen schneller geht's ohne die Ausgaben auch!)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 45
________________________________________________________


Die Voreinstellung dieser Option wird Åbrigens in der Shell in der Compiler-
Parameter-Box mit dem Schalter Ausgabe der Kurzmeldungen gewÑhlt.

Voreinstellung: (*$ Q- *)


Zugriff auf lokale Variable (Linking)

Diese Option ist nur fÅr Benutzer des integrierten 68000-Assemblers interes~
sant! Daher geht auch diese Beschreibung hier schon etwas 'ans Eingemachte';
Nur-Modula-Programmierer dÅrfen sie gerne Åberspringen:

Zu Beginn jedes Prozedurrumpfes erzeugt der Compiler Maschinencode, der
die lokalen Variablen der Prozedur anlegt und - falls vorhanden - die Prozedur~
parameter in die entsprechenden Variablen Åbernimmt. Wenn Sie eine komplette
Prozedur in Assembler implementieren wollen, kann es effizienter sein, statt
lokaler Variablen CPU-Register zu verwenden und auch alle Prozedurparameter
direkt in CPU-Register zu Åbernehmen. Dazu kann mit (*$ L- *) der Code zur
Parameter-öbernahme unterdrÅckt werden. Wie Sie mit Assembler-Anweisungen
an die Parameter herankommen, wird in Kapitel 4.3 verraten.

Beachten Sie aber unbedingt, daû Prozeduren, in denen mit Modula-Befehlen
auf lokale Variable zugegriffen wird, in aller Regel unter (*$ L+ *) Åbersetzt
werden  mÅssen!   Also   bitte   nicht   vergessen,   die   Link-Option   wieder
zurÅckzusetzen! Es ist, schon zur besseren Abtrennung maschinenspezifischer
Programmteile, empfehlenswert, Assembler- und Modula-Prozeduren in einem
Programm nicht bunt zu mischen, sondern in Blîcken zu gruppieren. Oft ist es
sinnvoll,  alle  Assembler-Prozeduren  in  einem  separaten  Modul  zusammen~
zufassen.

Voreinstellung: (*$ L+ *)


Wahl der Namens-Endung (Extension)

Der Compiler speichert Åbersetzte Module stets  unter  dem  auf  8  Zeichen
gekÅrzten Modulnamen als Dateinamen ab. Die Extension (Endung des Namens
nach dem '.') wird dabei normalerweise automatisch bestimmt:

MOD fÅr einfache Programm-Module,
IMP fÅr Implementations-Module,
DEF fÅr Definitionsmodule.

Soll Ihr Programm unter einer anderen Extension gespeichert werden, kînnen
Sie irgendwo im Programm  (am  besten  direkt  hinter  dem  Modulkopf)  eine
$Extension-Option setzen. Beispiel: (*$ E MTP *) bewirkt, daû der Dateiname
auf '.MTP' endet.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 46
________________________________________________________


Dauerhaft Ñndern kînnen Sie die Endungen auch durch Anpassung der Shell-
Source, indem Sie dort nach den bisher verwendeten Endungen suchen und sie
ersetzen. Auûerdem mÅssen Sie dann noch die betreffenden Variablen in den
Modulen MOSConfig und ShellMsg, am besten durch Zuweisungen im Shell-
Initialisierungs-Code,  entsprechend  setzen  (beachten  Sie  dazu  die  Doku~
mentation in den Definitions-Texten).


Einschieben externer Textfiles (Include File)

Die Include-Option betÑtigt keinen 'Schalter' im Compiler und hat daher eine
etwas andere Syntax als ihre Verwandten. Durch Angabe von (*$ I FileName *)
weisen Sie den Compiler an, an der aktuellen Textposition zunÑchst die Datei
FileName  einzuschieben.  Nach  der  Bearbeitung  dieses  Textes  (hoffentlich
bezeichnet   FileName   eine   Textdatei!)   kehrt   der   Compiler   dann   zur
ursprÅnglichen Datei zurÅck.

Der  FileName  ist  immer  komplett  mit  Laufwerks-  und  evtl.  Ordnernamen
anzugeben. Wie Åblich dÅrfen in der Options-Klammer weitere Optionen folgen
(durch Komma getrennt, z. B. so: (*$ I A:Teil2.Doc, Q+ *)). Diese Optionen
werden dann ausgewertet, bevor das eingeschobene Textfile bearbeitet wird;
sie beeinflussen also bereits die Verarbeitung des Einschubs.

Include-Anweisungen dÅrfen geschachtelt werden, d. h. der eingeschobene Text
darf ebenfalls einen Einschub benutzen, in dem ein Einschub benutzt werden
darf, in dem... Das geht allerdings nicht ewig so weiter: Maximal 15 Include-
Schachtelungen sind erlaubt.

WofÅr  braucht  man  nun  eigentlich  Include-Anweisungen?  HÑufig  benutzte
Prozeduren oder Typdeklarationen sollten Sie lieber  in  ein  separates  Modul
schreiben, statt sie in einem Include-File bei jeder Benutzung neu zu Åbersetzen
(... und bei jeder Verbesserung Ihrer Standard-Prozeduren noch einmal alle
Benutzerprogramme zu compilieren!). Eine der nÅtzlichsten Anwendungen, die
wir selbst fÅr Include-Anweisungen haben, beruht darauf, daû der Compiler
auch mehrere Module in einer Textdatei akzeptiert: Um nach grîûeren énderun~
gen ein ganzes System von Modulen (z.B. das MOS) neu zu Åbersetzen, genÅgt
eine Datei, die nur aus Include-Optionen fÅr alle Module besteht.

Beispiel fÅr das Compilieren mehrerer Module auf einmal:

  (*$ I QUEUES.D *)
  (*$ I QUEUES.I  *)
  (*$ I TESTQ.M *)

Wird eine Datei, die nur die obigen drei Zeilen enthÑlt, compiliert, bearbeitet
der Compiler nacheinander alle drei Module.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 47
________________________________________________________


Bibliotheksvorgabe (Use Library)

Die importierten Definitionsmodule sucht der Compiler im Normalfall auf allen
Pfaden, die in der Shell-Info-Datei (Kapitel 2.2) angegeben sind. Mîchten Sie
einzelne  Definitionsmodule  auf  anderen  Pfaden  erreichen,  oder  haben  Sie
verschiedene Versionen einer Definition in Ihren Bibliotheksordnern, dann ist die
gezielte Angabe des Suchpfades nÅtzlich. Durch Angabe von (*$ U pathname
*) veranlassen Sie den Compiler, die im Folgenden benîtigten Definitionsmodule
zunÑchst auf dem Pfad pathname zu suchen. Falls diese Suche keinen Erfolg
hat, wird wieder die Åbliche Pfadliste durchsucht.


Protokoll mit Statistik

Wird  eine  Protokolldatei  beim  Compilieren  erzeugt,  kînnen  durch  (*$V+*)
Informationen Åber Compilierrate, -zeit usw. am Ende des Protokolls abgelegt
werden. Ist nur die Statistik erwÅnscht, kann das Listing zu Beginn mit $P-
unterdrÅckt werden; ganz am Ende muû es aber  mit  $P+  wieder  aktiviert
werden!


Bedingte Compilierung

Erstellt man grîûere Programme fÅr verschiedene Konfigurationen, ist es oft
notwendig, verschiedene Code-Teile dafÅr zu verwenden. Anstatt fÅr jeden Fall
ein separates Modul erstellen zu mÅssen, kînnen die verschiedenen Code-Se~
quenzen in einem Quelltext stehen und dann beim Compilieren durch "Schalter"
ein- oder ausgeklammert werden. Dazu wird erstmal der Programmteil wie ein
Kommentar eingeklammert, dann wird am Kommentarbeginn die Compileroption
$? eingetragen, gefolgt von einer Boolean expression (logischer Ausdruck) und
einem Doppelpunkt. Ist der Ausdruck beim Compilieren falsch (FALSE), bleibt
der Kommentar bestehen - der Programmteil wird nicht Åbersetzt. Ist  der
Ausdruck  wahr  (TRUE),  ignoriert  der  Compiler  die  Kommentarklammerung.
Beispiel fÅr bedingte Compilierung:

  CONST  MehrAls512KB =TRUE;
  TYPE
    (*$?      MehrAls512KB: Feld = ARRAY OF  1..40000  OF Daten; *)
    (*$? NOT MehrAls512KB: Feld = ARRAY OF  1..10000  OF Daten; *)

In diesem Beispiel wird z.B. ein Datenfeld definiert, das normalerweise 40000
Elemente enthalten soll. Im  Falle,  daû  das  Programm  auf  einem  Atari  mit
nur 512KB eingesetzt wird, wÅrde das Feld zu viel Speicher belegen - dort soll
nur ein Feld mit 10000  Elementen  verwendet  werden.  Dies  ist  im  Beispiel
dadurch zu erreichen, daû beim Compilieren je nach Zielrechner die Konstante
MehrAls512KB entsprechend definiert wird.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 48
________________________________________________________


System-Module mit "shared data"

Diese  Option  ist  fÅr  Sie  nur  interessant,  wenn  Sie  System-Module
programmieren  oder  in  Ihren  Programmen  Gebrauch  vom  Loadtime-Linking
machen  wollen:  Normalerweise  wird  jedes  Modul,  das  von  einer  Haupt~
anwendung  importiert  wird,  beim  Start  der  Anwendung  initialisiert,  indem
dessen Modulkîrper ausgefÅhrt wird. Wenn sie nun aber in der Anwendung ein
weiteres Modul als Anwendung starten (mit Hilfe der Funktion CallModule aus
dem Modul Loader), wÅrden alle von ihm importierten Module neu initialisiert,
auch wenn sie schon in der aufrufenden Anwendung vorhanden und initialisiert
waren. Das heiût aber auch, daû dann beispielsweise keine DatenÅbergaben
Åber gemeinsam benutzte Module mîglich sind, weil bei der Initialisierung auch
alle globalen Variablen neu angelegt (und gelîscht) werden.

Damit  nun  verschachtelte  Module-Anwendungen  auf  die  gleichen  Daten
zugreifen kînnen, mÅssen solche Module, die nur einmal anfangs initialisiert
werden sollen, mit der Direktive $Y+ Åbersetzt werden. NatÅrlich funktioniert
dies nur, wenn die Module mit CallModule gestartet werden und nicht schon zu
einem fertigen Programm gelinkt sind.

Ein Beispiel ist das Modul ShellMsg: Es wird sowohl von der Shell als auch von
Linker, Compiler, Make, usw, benutzt. Diese Programme tauschen  Åber  die
dortigen Variablen ihre Parameter und Ergebnisse aus. Die Programme werden
Åber CallModule in der Shell gestartet und ShellMsg wurde mit der Option $Y+
Åbersetzt, damit dabei die Variablen nicht jedesmal neu initialisiert werden.

Ebenso  kînnen  Sie  selbst  eine  Anwendung  A  schreiben,  die  die  Funktion
CallModule des  Loaders  verwendet,  um  eine  weitere  Sub-Anwendung  B  zu
starten (diese muû dann aber ein ungelinktes Modul/Programm sein!). Dann
stehen die vom aufrufenden Programm A importierten Module auch dem neuen
Programm B zur VerfÅgung. Alle beiderseits importierten Module, die mit $Y+
Åbersetzt wurden, werden dabei beim Start von B nicht  erneut  initialisiert.
Damit kînnen Sie erreichen, daû die Hauptanwendung A und die von ihr als
eine  Art  Unterprogramm  gestartete  neue  Anwendung  B  Åber  gemeinsame
Module Daten austauschen. So kînnten beide das selbe (mit $Y+ Åbersetzte)
Modul importieren, aus dem globale Variablen exportiert werden: Das Haupt~
programm A schreibt Werte in diese Variablen, das dann davon gestartete
neue Programm B importiert ebenfalls das Modul, und dadurch, daû der Loader
das fÅr die Hauptanwendung bereits geladene Modul auch dem neuen Modul B
zur VerfÅgung stellt, ohne es neu zu initialisieren, kann es  auf  die  Werte
zugreifen, die die Hauptanwendung A hineingeschrieben hat.

Voreinstellung: (*$ Y- *)
3.4 Megamax Modula: Compilerdirektiven                                 3 - 49
________________________________________________________


Entfernung nicht benîtigter Module beim optimierten Linken

Bindet der Linker ein Programm mit vollstÑndiger Optimierung, entfernt er alle
Module, die keine benîtigten Prozeduren oder Variablen exportieren. Das ist
beim  Linken  daran  zu  erkennen,  daû  solche  Modulnamen  wieder  aus  dem
Fenster gelîscht werden. Mit der Entfernung verschwindet auch sein Initiali~
sierungscode (Modulkîrper), weil der in der Regel nur interne Initialisierungen
vornehmen  soll  und  daher  nicht  mehr  benîtigt  wÅrde.  Nun  gibt  es  aber
Anwendungen,  bei  denen  ein  Modul  nichts  anderes  tun  soll,  als  externe
Variablen zu initialisieren. Solche Module nennen wir in der Regel Treiber oder
Konfigurationsmodule. Da diese  Treiber  nicht  beim  Optimieren  verschwinden
dÅrfen, mÅssen dafÅr besondere Vorkehrungen getroffen werden.

Eine Mîglichkeit - die "sauberere" - ist, solche Module in den Linker-Optionen
als Treibermodule einzutragen. Dann werden sie nicht entfernt.

Die andere Mîglichkeit besteht darin, das betroffene Modul im Quelltext mit
der Option $B+ zu versehen. Wird das Modul dann vom Hauptmodul importiert,
wird  es  keinesfalls  vom  Linker  entfernt  (wie  dies  auch  beim  niemals
optimierenden Loader beim Starten mit Load-Time-Linking geschieht).


Compiler-Warnungen

Bisher gibt es nur eine  Warnung  seitens  des  Compilers,  und  die  tritt  bei
falscher  Verwendung  von  REF-Parametern  auf  (siehe  Abschnitt  Åber  REF-
Parameter weiter oben). Und sie ist nicht mal als Warnung ausgewiesen - sie
bricht die öbersetzung in jedem Fall ab. Naja. Auf jeden Fall ist die Fehler~
meldung  teilweise  sehr  lÑstig,  beispielsweise,  wenn  ein  REF-Parameter  als
VAR-Parameter an eine weitere Funktion Åbergeben wird, von der man aber
genau weiû, daû sie das Datum nicht verÑndern wird. Dies kommt beispiels~
weise bei den FastStrings-Funktionen vor, die immer noch VAR- statt REF-
Parameter haben, weil die REF-öbergabe noch nicht optimal implementiert ist.
Um in einem solchen Fall die Fehlermeldung zu unterbinden, kann die Option
$W- vor dem - sonst - illegalen Zugriff verwendet werden. Dahinter sollte
dann  aber  wieder  mit  $W+  (Standard-Einstellung)  oder  $W=  der  normale
Zustand fÅr Warnungen hergestellt werden.
3.4 Megamax Modula: Compilerdirektiven                                 3 - 50
________________________________________________________


öbersicht: Compilerdirektiven

Syntax-Beispiel:  (*$ R-, S-  Kommentar: alle PrÅfungen aus *)


Schalter

     Vor-
Name      Bedeutung               ErlÑuterungen
    einst
 A -  Erweiterte Syntax   A+ lockert einige Syntax-Regeln.
 B  -  Body Requirement    B+  verhindert  das  Entfernen  des  Modulkîrpers
                                beim optimierten Linken
 C +  Case Sensitivity      C-  hebt Unterscheidung von Groû-/Kleinschrift auf
 D -  Debugging            D+  erzeugt Zusatzcode zur Fehlersuche
 E  -  Procedure Trace     E+ erzeugt Code zur Anzeige von Prozeduraufrufen
 F  -  Float-Format         F+ dient zur Verwendung einer FPU
 H -  Local Procedures    H+ erlaubt lokale Prozeduren als Parameter
 I  -  Integer-Size         I+ ordnet CARDINAL/INTEGER den LONG-Typen zu
 J  +  Optimized Code      J- verhindert evtl. kritische Optimierungen
 K  -  Long-Short-Assign  K+ erlaubt Zuweisung von Long- auf Short-Variable
 L  +  Parameter Linking   L-  erlaubt ParameterÅbernahme von Assembler
 M +  Prozedurnamen      M- spart Platz, aber Prozedurnamen kînnen dann
                                nicht mehr bei Fehlern angezeigt werden. Beim
                                vollst. optimierten Linken werden alle Prozedur~
                                namen automatisch entfernt.
 N -  No Runtime          N+ verhindert den autom. Runtime-Import
 P  +  Protokoll             P-  nimmt Programmteile aus dem Protokoll aus
 Q -  Quiet Compilation    Q+ schaltet Ausgaben beim öbersetzen ab
 R  +  Range Checking      R-  spart Code fÅr BereichsprÅfungen
 S +  Stack Checking      S- spart Code fÅr Stackplatz-PrÅfungen;
                              S 512 setzt geforderte Stackplatz-Reserve
 T  +  Record Ordering     T- reiht Felder mit KommataaufzÑhlung rÅckwÑrts
 U +  Set Format          U- wÑhlt altes SET-Format (Compiler Version 3)
 V -  Verbose Protocol    V+ erzeugt Statistik am Ende der Protokolldatei
 W +  Warnings            W- verhindert Fehlermeldung bei REF-Parametern
 X -  Extended Asm       X+ erlaubt 68020 & 68881 Mnemonics (nur  bei
                                erweitertem Compiler / Assembler)
 Y -  System-Module      Y+ erlaubt "shared data"
 Z -  Value Return Mode  Z+ lÑût Funktionsergebnisse im Register liefern.


Sonstige Direktiven

 E      Extension           E xyz  setzt Endung der Codedatei auf '.xyz'
 I       Include              I filename  fÅgt Datei filename ein
 U      Uses Library        U path  lÑût Definitionsmodule auf path suchen
 ?       Conditional Comp.  ?constExpr:  Åbersetzt Folgendes nur bedingt
 Reg    Register Var.       deklariert Variable, die im Register zu halten sind
