A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


Anhang

Der Anhang ist vor allem zum Nachschlagen wÑhrend der Arbeit mit Megamax
Modula gedacht. Oft finden Sie ErlÑuterungen zu den hier abgedruckten Daten
in den entsprechenden vorhergehenden Kapiteln des Handbuchs.


A.1   Fehlermeldungen  des  Compilers

Die  folgenden  Fehlermeldungen  werden  nach  einem  Fehler  auch  im  Editor
angezeigt. Hier finden Sie aber zusÑtzliche ErlÑuterungen oder Tips zu einigen
Meldungen, die sonst vielleicht etwas knapp die Fehlerursache beschreiben.


Fehler im Modulkopf und im Textformat

    100 :  Moduldeklaration erwartet
                Programm beginnt nicht mit   DEFINITION | IMPLEMENTATION  
                MODULE.
    101 :  Bezeichner erwartet
                Statt   eines   Bezeichners   steht   ein   SchlÅsselwort   oder
                Satzzeichen.
    102 :  Modulname erwartet
                Statt   eines   Modulnamens   steht   ein   SchlÅsselwort   oder
                Satzzeichen.
    103 :  IMPORT erwartet
                Nach FROM <Modulname> wird IMPORT erwartet.
    104 :  Qualifizierter Name hier nicht erlaubt
                Bezeichner dÅrfen hier keine fÅhrenden Qualifier haben.
    105 :  Falscher Bezeichner am Blockende
                Modul-/Prozedurname nach END stimmt nicht  mit  dem  Kopf
                Åberein. Evtl. fehlt ein END zu einer Kontrollstruktur.
    106 :  Fehlerhafte Kommentar-Schachtelung
                Mehr Kommentarklammern geschlossen als geîffnet.
    107 :  Fehler in Compiler-Direktive
                Syntaxfehler in einer Compiler-Direktive. Siehe Kapitel 3.4.
    108 :  Unerwartetes Ende des Quelltextes (evtl. fehlendes '*)')
                Ende des Quelltextes mitten im Modul; auch bei nicht korrekt
                abgeschlossenen Kommentaren.


Fehler im Deklarationsteil

    200:  Fehler im Deklarationsteil
                TYPE, CONST, VAR, PROCEDURE oder MODULE erwartet.
    201 :  Bezeichner doppelt deklariert
                Bezeichner  ist  auf  dieser  Ebene  schon  deklariert  (evtl.
                importiert,  evtl.  auch  durch  einen  AufzÑhlungstyp   schon
                verdeckt vorhanden/importiert).
    202:  Bezeichner ... doppelt deklariert
                s. Fehler 202
    203:  Bezeichner erwartet, SchlÅsselwort gefunden
                Der deklarierte Bezeichner ist als SchlÅsselwort reserviert.
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


    204:  Fehler in Typdeklaration
                Syntaktischer Fehler in der Typdeklaration.
    205:  Undeklarierter Bezeichner
                Der  Bezeichner  ist  noch  nicht  vorher  im  Text  deklariert
                worden.
    206:  Falsches Symbol (vielleicht vorher fehlendes ';' oder '!')
                Gefundenes Modul-Wort hier unzulÑssig.
    207:  ';' erwartet (vielleicht auf voriger Zeile)
    208:  ':' erwartet
    209:  '=' erwartet
    210 :  '..' erwartet
    211 :  ' ' erwartet
    212 :  >schlieûende eckige Klammer< erwartet
                ' ' erwartet.
    213 :  OF erwartet
    214 :  END erwartet
    215 :  Array-Index muû Unterbereich oder AufzÑhlung sein
    216 :  SET-Basistyp muû Unterbereich oder AufzÑhlung sein
    217 :  Opaque-Typen mÅssen LONGWORD-kompatibel sein
                Opaque-Typen mÅssen als 32 Bit-Typ implementiert werden.
    218 :  Untergrenze grîûer als Obergrenze
    219 :  Unter- oder Obergrenze liegt auûerhalb des gÅltigen Bereichs
    220:  Cardinal-Konstante erwartet
                ZZ,   CARDINAL,   SHORTCARD   oder   LONGCARD-Konstante
                erwartet.
    221 :  Falsche Grîûenangabe bei TABLE-Deklaration (B, W, L, oder D)
                Nach TABLE muû ein Punkt und dann B, W, L oder D stehen.
    222:  FORWARD-Deklaration ... nicht implementiert
                Die FORWARD-deklarierte Prozedur wurde nicht implementiert.
    223:  String-Konstante erwartet
                Ein String-Literal wurde erwartet.
    224:  ' ' erwartet
    225:  POINTER-Deklaration: Ungelîste VorwÑrts-Referenz von ...
                Der Typ der "POINTER TO <Typ>"-Deklaration muû im selben
                Block (Modul, Prozedur) deklariert werden.
    226:  Prozedurtyp-Deklaration: Ungelîste VorwÑrtsreferenz von ...
                Parameter- und RÅckgabetypen von Prozedurtypen mÅssen im
                selben Block (Modul, Prozedur) deklariert werden.
    227:  Verschiedene Real-Formate spezifiziert
                Pro Modul darf nur ein Real-Format ($F+ oder $F-) definiert
                werden.
    228:  F-Direktive muû vor der Benutzung von Reals stehen
                Sobald Reals (AusdrÅcke oder Konstanten) benutzt wurden, ist
                keine Formatbestimmung mehr mîglich.
    229:  Register-Variable bei diesem Typ nicht verwendbar
                Variablen dieses Typs kînnen nicht im Register gehalten werden.
    230:  Typ-Bezeichner erwartet
                MIN,  MAX,  TSIZE,  CAST  und  VAL  erwarten  zuerst  einen
                Typ-Namen; In TYPE-Deklarationen wird zuerst ein Typ-Name
                erwartet.
    231 :  Typ-Bezeichner noch nicht deklariert
                Der Typ wurde bisher nur in POINTER TO oder Prozedurtyp~
                Deklarationen verwendet und  ist  selbst  noch  nicht  deklariert
                worden.
    232:  Typ-Bezeichner ... nicht deklariert
                s. Fehler 231
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________



Fehler in Konstanten (Literalen)

    300:  Konstante erwartet
    301 :  UnzulÑssiger Konstanten-Typ
    302:  Zahl zu groû
    303:  Falsches Zahlenformat
    304:  öberlauf in Mantisse
                Fehlerhafte Real-Konstante.
    305:  öberlauf im Exponenten
                Fehlerhafte Real-Konstante.


Fehler in Anweisungen

    400:  Fehlerhaftes Statement (Anweisung)
    401 :  DO erwartet
    402:  UNTIL erwartet
    403:  THEN erwartet
    404:  TO erwartet
    405:  ':=' erwartet
    406:  '.' erwartet
    407:  Boolescher Ausdruck erwartet
    408:  EXIT ohne LOOP
    409:  Fehlendes RETURN in dieser Funktion
    410 :  Record-Bezeichner erwartet
    411 :  CASE-Marke doppelt deklariert
    412 :  CASE-Selektor muû skalar sein
    413 :  '!' oder END erwartet
    414 :  Variable erwartet
    415 :  Prozedur liefert ein Ergebnis
                Das  Ergebnis  dieser  Funktionsprozedur  muû   ausgewertet
                werden.
    420:  SchleifenzÑhler muû ordinal sein
                Die FOR-Variable muû ordinal sein.
    421 :  Inkrement muû Ganze-Zahl-Konstante sein
                Der  BY-Wert  der  FOR-Schleife  muû  eine  CARDINAL-  oder
                INTEGER-Konstante sein.
    422:  Schleifenvariable muû einfache, lokale, Variable sein
                Die FOR-Variable muû im selben Level deklariert worden sein.
                Sie darf weder ex- noch importiert und auch kein Record- oder
                Array-Element sein.
    423:  Auf Schleifenvariable wurde in lokaler Prozedur zugegriffen
                FOR-Variablen dÅrfen nicht auûerhalb der FOR-Schleife benutzt
                werden.
    424:  Schleifenvariable und obere Grenze mÅssen identischen Typ haben
                Der Typ der FOR-Variable muû identisch mit dem der Ober~
                grenze sein.

    430:  Ganzzahl-Konstante erwartet
                Der BY-Wert des ARRAY-Aggregats muû eine CARDINAL- oder
                INTEGER-Konstante sein.
    431 :  BY-Wert liegt auûerhalb des gÅltigen Bereichs
                Der BY-Wert des ARRAY-Aggregats muû grîûer als Null aber
                nicht grîûer als die noch verbliebene Anzahl Felder sein.
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


Fehler in AusdrÅcken

    500:  Typen sind nicht zuweisungskompatibel
                Der Typ des Ausdrucks ist nicht kompatibel zur Ziel-Variable
                bzw. zum Ziel-Parameter.
    502:  Fehler in Faktor (fehlerhafter Ausdruck)
    503:  '-' nicht erlaubt
    504:  '(' erwartet
                Die Prozedur erwartet eine Argumentliste.
    505:  ')' erwartet
                Im   Ausdruck:   so   viele   Klammern   sind   nicht   geîffnet;
                Bei Prozeduraufruf: So viele Argumente erwartet die Prozedur
                nicht.
    506:  ',' erwartet
                Bei Prozeduraufruf wurden zu wenig Argumente Åbergeben.
    510 :  Zahl (CARDINAL, INTEGER, REAL) erwartet
    511 :  CHAR-Typ erwartet
    512 :  Ganzzahl (CARDINAL, INTEGER) erwartet
    513 :  INTEGER oder REAL erwartet
    514 :  REAL oder LONGREAL erwartet
    515 :  REAL oder ordinaler Typ erwartet
    516 :  Skalarer Typ erwartet
    517 :  Dieser Bezeichner ist nicht vom ARRAY-Typ
    518 :  Dieser Bezeichner ist nicht vom RECORD-Typ
    519 :  Dieser Bezeichner ist nicht vom POINTER-Typ
    520:  SET OF BITNUM-Typ erwartet
                SHIFT und ROTATE erlauben nur SETs vom BITNUM-Typ.
    521 :  Prozedur oder Variable vom Prozedur-Typ erwartet
    522:  Variable oder Konstante erwartet
    523:  String-Typ erwartet
    524:  Grîûe der Variable paût nicht zum Register
                LOAD und STORE nur auf Typen mit maximal 32 Bit anwendbar.
    525:  Skalar oder Adresse erwartet (Datumsgrîûe max. 4 Byte)
                CALLSYS und CALLEXT erlauben keine Strukturen als Argumente.
    526:  Falsche String-LÑnge
    527:  Falscher Indextyp
                ARRAY durch falschen Typ indiziert.
    528:  Prozedur liefert kein Ergebnis
                Diese Prozedur hat keinen RÅckgabewert.
    529:  Nur SETs, ARRAYs und RECORDs kînnen konstruiert werden
                Der Bezeichner vor dem " " ist kein strukturierter Typ.
    530:  Lokale oder Standardprozedur nicht erlaubt (nur globale)
                Nur  globale  Prozeduren  sind  auf   Prozedur-Variable   und
                -Parameter zuweisbar.
    532:  Benutzte Z-Direktiven stimmen nicht Åberein
                Alle   Prozedurkopf-Definitionen   (Definitionsmodul,   Forward-
                Dekl.,  Prozedurtyp-Dekl.  und  Prozedur-Implem.)  mÅssen  mit
                derselben Z-Direktiven-Einstellung Åbersetzt werden.
    533:  Pointer noch nicht vollstÑndig deklariert
                Der Pointer kann nicht dereferenziert werden, weil der Typ aus
                der POINTER TO-Deklaration noch nicht deklariert worden ist.
    540:  Typkonflikt zwischen den Operanden
                Es wurden zwei Operanden verschiedenen Typs verknÅpft.
    541 :  Falscher Operator oder Operandentyp
                Operation auf diesem Operanden-Typ nicht definiert.
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


    542:  Nur '=' und '<>' sind auf diesen Typ anwendbar
                Gilt fÅr Opaque-, POINTER- und Prozedur-Typen.
    543:  Negation nur bei Integer-Typen erlaubt
                Das  Minus-Zeichen  kann  nur  bei  INTEGER-  und  Real-Typen
                angewandt werden.
    550:  Zu wenige Parameter beim Aufruf
                Bei Prozeduraufruf wurden zu wenige Argumente Åbergeben.
    551 :  Typ muû identisch mit VAR-Parameter sein
                Der Typ des Arguments muû mit dem Parameter identisch sein
                oder  dieselbe  Grîûe  haben.  Bei  Parametern  vom  Typ  LOC,
                BYTE,   WORD   oder   LONGWORD   muû   nur   die   Grîûe
                Åbereinstimmen, bei Parametern vom Typ ADDRESS muû  ein
                POINTER-Typ Åbergeben werden.
    552:  HIGH-Funktion nur auf 'Open Array' anwendbar
                HIGH() nur auf offene formale Parameter anwendbar. Verwende
                SIZE().
    553:  SIZE-Funktion nicht auf 'Open Array' anwendbar
                SIZE()  ist  nicht  auf  offene  Felder  anwendbar.  Verwende
                HIGH().
    554:  'Open Array' kann nur an 'Open Array'-Parameter Åbergeben werden
                Ein offenes Feld kann nicht auf normale Strukturen zugewiesen
                werden.
    555:  Argument hat zu wenig Array-Dimensionen
                Der Parameter erwartet mehr Dimensionen als das Argument
                enthÑlt.
    556:  Array-Grîûe muû ganzes Vielfaches von Joker-Grîûe sein
                Bei ARRAY OF WORD/LONGWORD muû Argument eine durch
                zwei bzw. vier teilbare Grîûe haben.
    557:  LONGARRAY kann nicht an Short-Index Åbergeben werden
                Parameter muû LONGARRAY OF statt ARRAY OF annehmen.
    558:  Parameter-Typ noch nicht deklariert
                Die  Prozedur  kann  nicht  aufgerufen  werden,  weil  einer  der
                Parameter des Prozedurtyps noch nicht deklariert wurde.
    559:  RÅckgabe-Typ noch nicht deklariert
                Die Prozedur kann nicht aufgerufen werden, weil der RÅckgabe-
                Typ des Prozedurtyps noch nicht deklariert wurde.
    560:  Parm- oder Return-Typ des Prozedurtyps noch nicht deklariert
                Der  Prozdurtyp  kann  nicht  ausgewertet  werden,  da  seine
                Parameter- und RÅckgabe-Typen noch nicht deklariert wurden.
    561 :  Datenumwandlung nicht mit diesen Typen mîglich
                VAL erlaubt diese Datenumwandlung nicht.
    562:  Typ-Konvertierung nur zwischen Typen gleicher LÑnge
                Die Form "<Typname> (<Ausdruck>)" verlangt gleiche Grîûen.
    563:  CAST nur bei gleichen Grîûen oder Skalaren mîglich
                CAST  kann  bei  diesen  Typ  die  Grîûenumwandlung  nicht
                eindeutig vornehmen.
    570:  Verwendung von geschÅtzter Variable hier nicht erlaubt
                REF-Parameter und FOR-Variable: ADR() nicht erlaubt.
    571 :  Zuweisung auf geschÅtzte Variable nicht erlaubt
                Die  Zuweisung,  die  öbergabe  an  VAR-Parameter  und  die
                Verwendung als FOR-Variable ist bei REF-Parametern und bei
                bereits benutzten FOR-Variablen nicht erlaubt.
    572:  Hier darf keine Register-Variable verwendet werden
                Verwendung bei  ADR()  und  WITH  sowie  öbergabe  an  VAR-
                Parameter hier nicht erlaubt.
    573:  Zugriff auf Register-Variable in lokaler Prozedur nicht mîglich
                Register-Variable kînnen nur im Code der selben Ebene benutzt
                werden.
    574:  Auf die Variable ist noch kein Wert zugewiesen worden
                Inhalt der Variable ist an dieser Stelle noch undefiniert.
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


Rechenfehler in Konstant-AusdrÅcken

    580:  Konstante zu klein/groû fÅr Zuweisung bzw. Typwandlung
    581 :  Division durch Null in konstantem Ausdruck
    582:  String zu groû fÅr Zuweisung bzw. Typwandlung
    583:  BereichsÅberschreitung des REAL-Wertes
    584:  Fehler in konstantem Ausdruck: ...
    585:  Konstante liegt auûerhalb des Operandenbereichs
    586:  Arithmetischer öberlauf
    587:  Index liegt auûerhalb des Feldbereichs
    588:  Index/Subrange-Bereiche Åberschneiden sich nicht


Semantische Fehler bei IMPORT und EXPORT

    700:  Exportierter Bezeichner ... nicht deklariert
    701 :  Interner Fehler beim Exportieren von ...
                Die Åbersetzte Definitions-Datei ist fehlerhaft.
    702:  Importierter Bezeichner nicht re-exportierbar
    703:  Exportierte Prozedur ... nicht implementiert
    704:  Prozedur-Implementation weicht von der Definition ab
                Die Prozedurkîpfe sind verschieden. Beachte auch die öberein~
                stimmung der Direktiven $H und $Z!
    705:  PERVASIVE Import in Definitionsmodulen nicht erlaubt
                Ein Modul, das PERVASIVE exportiert, kann nur in Implemen~
                tationsmodule importiert werden.
    706:  Fehler beim Importieren
                Compiler-interner Fehler.
    707:  Definitionsmodul nicht verfÅgbar
                Das  Åbersetzte  Definitionsmodul  ist  nicht  zu  finden.  Siehe
                Kapitel 2.4.
    708:  Definitionsmodul zu dieser Implementation fehlt
    709:  Definitionsmodul 'Runtime' fehlt
    710 :  Importierter Bezeichner nicht im Definitionsmodul
    711 :  System-Prozedur/-Variable ... aus Runtime-Modul fehlt
                Wahrscheinlich  wurde  eine  veraltete  Version  des  Runtime-
                Moduls vom Compiler verwendet.
    712 :  Definitionsmodul hat falsches Format
                Die Datei des Åbersetzten Definitionsmoduls ist defekt.
    713 :  Altes Modulformat (Definitionsmodul neu Åbersetzen!)
                Importiertes  Definitionsmodul  wurde  mit  veralteter  Compiler-
                Version Åbersetzt.
    714 :  Bezeichner ... doppelt exportiert
                Evtl. wird ein AufzÑhlungstyp und dazu seine Elemente nochmals
                exportiert.

öberschreiten von GrîûenbeschrÑnkungen sowie Restriktionen

    800:  String Åberschreitet Zeilenende
    801 :  Array zu groû (max. 2^31 Byte)
                Welcher Computer hat denn so viel Speicher?!
    802:  SETs kînnen max. 2^16 Elemente haben
    803:  Kein Platz fÅr EXPORT
                Speicherplatz reicht nicht (Platz schaffen, z.B. geladene Module
                freigeben).
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________



    804:  Kein Platz fÅr IMPORT (zu viele Importe)
                Speicherplatz reicht nicht (Platz schaffen, z.B. geladene Module
                freigeben).
    805:  Definitionsmodul zu groû (öberlauf der Link-Tabelle)
                Speicherplatz reicht nicht (Platz schaffen, z.B. geladene Module
                freigeben).
    806:  öberlauf des Integer-Stacks
                Schachtelungstiefe oder CASE-Labelliste zu groû.
    807:  öberlauf des Bezeichner-Stacks
                Schachtelungstiefe zu groû.
    808:  Zu viele Datei-Inklusionen
                Maximal 15 geschachtelte Include-Anweisungen.
    809:  Kontrollstruktur zu lang
                Max. CodelÑnge fÅr Schleifen und Verzweigungen ist 32 KB.
    810 :  Sprung zu weit (Prozedur zu groû)
                Zu viele / zu groûe lokale Prozeduren.
    811 :  Kein Platz mehr fÅr Code
                Speicherplatz reicht nicht (Platz schaffen, z.B. geladene Module
                freigeben).
    812 :  Datenstruktur zu groû fÅr 'Open Array'-Parameter
                'ARRAY OF ...'-Parameter mÅssen durch SHORTCARD indizier~
                bar sein. Ggf. den Parameter in 'LONGARRAY OF ...' Ñndern.
    813 :  Ausdruck zu aufwendig
                Vereinfache  den  Ausdruck  durch  Aufteilung  mit  Zwischen~
                ergebnissen.
    814 :  Konstante zu groû (max. 32 KB)
    815 :  String-Konstante zu groû (max. 256 Zeichen)
    816 :  LONGINT kann hier nicht verwendet werden
                RECORD-Deklaration: LONGINT z.Zt. nicht fÅr CASE-Selektor
                geeignet.
    817 :  TABLE-Deklaration nur auf globalem Level erlaubt
    818 :  Blockschachtelungstiefe zu groû
                Zu viele verschachtelte FOR- und WITH-Anweisungen (max. 40).
    819 :  AusdrÅcke der Argumente zu aufwendig
                Ausdruck  bei  CALLSYS/CALLEXT  zu  kompliziert.  Aufteilen;
                Zwischenvariablen verwenden.
    820:  BOOLEAN-Ausdruck zu komplex
                Vereinfache  den  Ausdruck  durch  Aufteilung  mit  Zwischen~
                ergebnissen.
    821 :  Argumente sind auf 32 KB Gesamtgrîûe beschrÑnkt
                Z.Zt. maximal 32 KB als Wert-Parameter pro Prozedur mîglich.


Interne Fehler. Bei Auftreten bitten wir um Nachricht. Abhilfe folgt prompt.

    850:  Funktion noch nicht vollstÑndig implementiert
    851 :  Interner Verifikationsfehler
    852:  Interner Fehler: ...
    853:  Zeitweilige Restriktion: ...
    854:  Interner Fehler: Stack-Pointer sind inkonsistent (Code: ...)
    855:  Interner Fehler: Registerbelegung ist inkonsistent (Code: ...)
    856:  Interner Fehler beim Exportieren eines AufzÑhlungselements
A.1  Fehlermeldungen des Compilers                                      Anhang
________________________________________________________


Fehlermeldungen des Assemblers

    901 :  Falsche Adressierungsart
                Die Adressierungsart ist bei dieser Instruktion nicht zulÑssig.
    902:  Falsche Operandengrîûe
                Die Datengrîûe ist bei dieser Instruktion nicht zulÑssig.
    903:  Verzweigung (Bcc/BSR) zu weit
                Verwende Bcc.W fÅr max. 32768 Byte Sprungweite (Default ist
                Bcc.B mit max. 128 Byte Sprungweite).
    904:  UnzulÑssiges Symbol
    905:  Label (Marke) erwartet
                Sprungziel muû lokales Assembler-Label sein.
    906:  Label ... nicht definiert
                Benutzte  Labels  mÅssen  in  derselben  Prozedur  deklariert
                werden.
    907:  Zahl erwartet
    909:  Ungerade Adresse unzulÑssig (SYNC verwenden!)
                Word-  oder  Longword-Zugriff  auf  ungerade  Adresse.  FÅge
                SYNC vorher ein.
    910 :  Modula-SchlÅsselwort nicht erlaubt
                Modula-SchlÅsselworte sind auch im Assembler reserviert.
    911 :  Kurze Verzweigung (Bcc/BSR) hier nicht erlaubt
                Kurzer Sprung Åber LÑnge Null nicht zulÑssig. Verwende Bcc.W.
    912 :  Label (Marke) doppelt deklariert
                Im selben Block doppelt definiert.
    913 :  Logisch falsche Adressierung (evtl. undeklarierte Variable)
                Auch  PC-relativer  Zugriff  auf  globales  Objekt  oder  absolute
                Adressierung eines lokalen Objekts.
    914 :  Fehlerhafter Ausdruck
    916 :  öberlauf des Operanden (auch undefinierte Konstante)
    917 :  68020-Mnemonic nicht erlaubt (verwende $X+)
                68020-Instruktionen  kînnen  nur  mit  speziell  erweitertem
                Assembler (erhÑltlich auf Anfrage) und erst nach der Direktive
                $X+ verwendet werden.
    918 :  String zu lang
    919 :  Diese Anweisung kann z.Zt. nicht kodiert werden
                Diese 68010/68020-Instruktion (MOVES) wird nicht Åbersetzt.
    920:  Unsinnige 68020-Adressierungsart
    921 :  68020 Adressierung nicht erlaubt (verwende $X+)
                Siehe Fehler 917
    923:  Funktion liefert Ergebnis in D0 -> '/' an Funktionsnamen anfÅgen!
                Aufrufe von Funktionen, die mit $Z+ Åbersetzt wurden, mÅssen
                durch AnfÅgen von '/' kenntlich gemacht werden.
    924:  Innerhalb vom WITH-Block kein Variablenzugriff mîglich
                Innerhalb  eines  WITH  ist  der  Zugriff  auf  die  umgebenden
                Variablen nicht mehr genau bestimmbar.
A.2  Fehlermeldungen zur Laufzeit                                         Anhang
________________________________________________________


A.2  Fehlermeldungen  zur  Laufzeit

Allgemeine Laufzeitfehler

    -1:    GeneralErr
                  Nicht nÑher spezifizierter Fehler
    -2:   BusFault
                  Zugriff auf nicht existente Adresse oder geschÅtzten Spei~
                  cherbereich (mîglicherweise hat ein Pointer den Wert NIL)
    -3:   OddBusAddr
                  Wortweiser Zugriff auf ungerade Adresse
    -4:   IllegalInstr
                  CPU traf auf unbekannte Instruktion
    -5:   DivByZero
                  Division durch Null
    -6:   OutOfRange
                  ARRAY-Index oder Prozedur-Parameter auûerhalb des zulÑs~
                  sigen Intervalls
    -7:    Overflow
                  öberlauf bei einer Berechnung
    -8:   StringOverflow
                  String faût Daten nicht
    -9:   NoValidRETURN
                  Funktions-Prozeduren  mÅssen  immer  mit  einer  expliziten
                  RETURN-Anweisung enden, die das Ergebnis definiert.
    -10:   OutOfStack
                  Nicht mehr genug Platz zum  Anlegen  lokaler  Variablen  am
                  Beginn eines Prozedurrumpfes.
    -11:   HALTInstr
                  HALT - Breakpoint erreicht
    -12:   FileSystemErr
                  Fehler im Dateisystem
    -13:   OutOfMemory
                  Kein genÅgender Speicherplatz mehr
    -14:   IllegalCall
                  Unerlaubter Funktionsaufruf
    -15:   CoroutineRtn
                  Coroutinen mÅssen durch einen TRANSFER beendet werden,
                  nicht durch RETURN oder Erreichen des Prozedurendes.
    -16:   InternalFault
                  Interner Fehler
    -17:   IllegalProcVar
                  Undefinierte PROCEDURE - Variable
    -18:   IllegalPointer
                  Uninitialisierte POINTER - Variable
    -19:   UserBreak
                  Abbruch vom Anwender
    -20:  IllegalState
                  Interner Statusfehler
    -21:   Exception
                  CPU erzeugte diverse Exception
    -22:  GenFPErr
                  Nicht nÑher bestimmter Floating-Point-Fehler
    -23:  CaseSelectErr
                  Fehlende CASE-Marke oder ELSE-Zweig
A.2  Fehlermeldungen zur Laufzeit                                         Anhang
________________________________________________________


    -24:  ConfigErr
                  Konfigurationsfehler, z.B. keine FPU (Koprozessor) vorhanden
    -25:  IllegalClosure
                  Zuweisung lokaler (inaktiver?) Prozedur an Proc-Variable

Dateifehler

    4:     fNotDeleted
                  bei Directory.Delete: Datei nicht vorhanden
    3:     fWasNotOpen
                  bei Files.Close: Datei war nicht offen
    2:     fEOF
                  Dateiende erreicht
    1:     fEOL
                  Zeilenende erreicht
    0:     fOK
                  Kein Fehler
    -1:    fError
                  Allgemeiner Fehler
    -2:   fDriveNotReady
                  Laufwerk nicht ansprechbar
    -3:   fUnknownCmd
                  Unbekannte Funktion
    -4:   fCRCError
                  PrÅfsummenfehler
    -5:   fBadRequest
                  Unerlaubte Funktionsanforderung
    -6:   fSeekError
                  Diskzugriff: Medium defekt
    -7:    fUnknownMedia
                  Diskzugriff: Unbekanntes Format
    -8:   fSectorNotFound
                  Diskzugriff: Sektor nicht vorhanden
    -9:   fNoPaper
                  Drucker: Papier fehlt
    -10:   fWriteFault
                  Diskzugriff: Schreibfehler
    -11:   fReadFault
                  Diskzugriff: Lesefehler
    -12:   fGenError
                  Diskzugriff: Allgemeiner Fehler
    -13:   fWriteProtected
                  Diskzugriff: Schreibschutz aktiv
    -14:   fMediaChanged
                  Diskzugriff: Diskette wurde gewechselt
    -15:   fUnknownDevice
                  Unbekanntes GerÑt (bei RWAbs und MediaChange)
    -16:   fBadSectorsOnFormat
                  Fehlerhafte Sektoren beim Formatieren / Verifizieren
    -17:   fInsertOtherDisk
                  Andere Disk (A: <-> B:) einlegen
    -32:  fInvalidFunctionNr
                  Unerlaubte Funktionsnummer
    -33:  fFileNotFound
                  Datei nicht gefunden
A.2  Fehlermeldungen zur Laufzeit                                         Anhang
________________________________________________________


    -34:  fPathNotFound
                  Directory nicht gefunden
    -35:  fTooManyOpen
                  Zu viele Dateien geîffnet
    -36:  fAccessDenied
                  Zugriff verwehrt / undurchfÅhrbar
    -37:  fInvalidHandle
                  Unerlaubte Zugriffskennung
    -39:  fInsufficientMemory
                  Zu wenig Speicher
    -40:  fInvalidMemBlkAddr
                  Unbekannte Speicherblockadresse
    -46:  fInvalidDrive
                  Unerlaubtes Laufwerk
    -48:  fDiffDrives
                  Rename: Source- und Dest-LW sind verschieden
    -49:  fNoMoreFiles
                  Fsnext(): Keine weiteren Dateien
    -64:  fRangeError
                  Seek: BereichsÅberschreitung
    -65:  fInternalError
                  Interner Fehler
    -66:  fBadFormatOfPrg
                  Illegales Format der Programmdatei
    -67:  fResizeFailure
                  Mshrink: Speicherblock nicht vergrîûbar
    -128: fOutOfMem
                  Nicht genÅgend Speicherplatz frei
    -129: fFileExists
                  Datei existiert schon
    -130: fNoReadAllowed
                  Lesezugriff nicht erlaubt
    -131:  fFileNotClosed
                  Datei noch offen
    -132: fFileNotOpen
                  Datei nicht offen
    -133: fInternalErr1
                  Interner Fehler
    -134: fInternalErr2
                  Interner Fehler
    -136: fBadOp
                  Zugriff in falschem Modus
    -137: fBadAccess
                  Lese- bzw. Schreibzugriff nicht erlaubt
    -138: fEndOfFile
                  Dateiende Åberschritten
    -139: fDoubleUndo
                  Wiederholter 'UndoRead'-Aufruf
    -140: fNameTooLarge
                  Dateiname ist zu lang
    -141:  fDiskFull
                  Kein Speicherplatz auf Disk mehr
    -142: fIllegalCall
                  Unerlaubter Funktionsaufruf
A.2  Fehlermeldungen des Loaders                                        Anhang
________________________________________________________



Zur Meldung von Laufzeitfehlern zeigt das Megamax Modula-System ein Fehler~
box, die auch Mîglichkeiten zum Suchen der Fehlerposition im Text bietet. Die
Bedienung dieser Box ist im Kapitel 2.5 (Debugger - Suchen der Fehlerposition)
erlÑutert.


Fehlermeldungen des Loaders

<Modul> nicht vorhanden.
<Modul> beim Importieren in <Klient> nicht gefunden.
 Die Modul-Datei ist weder resident noch auf den Suchpfaden zu finden.
<Modul> ist defekt.
 Das Modul hat fehlerhafte Daten.
Unerlaubte Daten in <Modul>.
Unerlaubtes Layout von <Modul>.
 Die Datei ist entweder kein Modulcode oder der Code eines alten Compilers.
Versionskonflikt zwischen <Modul> und <Client>.
 Die Module wurden nicht mit dem selben Def-Modul Åbersetzt. (S. Kap. A-10)
Kein ausreichender Speicherplatz mehr.
<Modul> ist resident und schon initialisiert.
 Das Modul kann nicht nochmal als Programm gestartet werden.
Unerlaubter Modulname.
Zu viele verschachtelte Modulaufrufe.
 Maximal 15 verschachtelte CallModule-Aufrufe mîglich.
Programm ist nicht ausfÅhrbar.
 Die Datei enthÑlt keinen gÅltigen Progammcode.
Programm nicht gefunden.
Laufzeitfehler wÑhrend Initialisierung.
 Vor dem Start des Hauptprogramms trat ein Laufzeitfehler auf.
Laufzeitfehler wÑhrend Deinitialisierung.
 Nach Beendigung des Programms trat ein Laufzeitfehler auf.
<Modul> ist komprimiert.
 Das Modul kann nicht imp. werden, da die erforderlichen Link-Daten fehlen.
<Modul> hat falsches Real-Format.
 Das Modul verwendet ein anderes Real-Format als die zuvor geladenen Module.
<Modul>: FPU nicht vorhanden.
 Das Modul benîtigt eine FPU, die nicht im Rechner vorhanden ist.


Fehlermeldungen des Make

Diese finden Sie am  Ende des Kapitels 2 zum Make.
A.3 Interne Datenformate                                                  Anhang
________________________________________________________


A.3  Interne  Datenformate

Typ               Grîûe/Bytes      Anmerkungen

CARDINAL            2              CARDINAL =  0 .. 0FFFFH 
INTEGER              2              INTEGER =  8000H .. 7FFFH 
CHAR                 1              CHAR =  0C .. 377C 
BOOLEAN            2              FALSE = 0, TRUE = 1
LONGINT             4              LONGINT =   80000000H.. 7FFFFFFFH 
LONGCARD           4              LONGCARD =  0L .. 0FFFFFFFFH 
LONGREAL           8              Format s. unten
REAL                 4              Format s. unten
AufzÑhlung            2              Zahlwerte 0 .. ORD (MAX(AufzÑhlTyp))
Unterbereich         (*)             Grîûe wie der Basistyp
Opaque               4
POINTER TO ...      4
BITSET               2              SET OF  0..15 ; Format s. unten
SET                  (*)             Grîûe = (Elementzahl + 15) DIV 16
LOC                  1
BYTE                 1
WORD                2
LONGWORD          4
ADDRESS            4


SET-Format  (s. auch Kapitel 3.2)

Wir gehen aus von einer Deklaration TYPE MySet = SET OF BaseType. Ein
SET vom Typ MySet enthÑlt dann die Bits 0 .. ORD (MAX (MySet)) sowie evtl.
einige unbenutzte Bits, um das SET auf BytelÑnge aufzurunden. (Achtung: Die
Bits ab 0 sind immer enthalten, auch wenn der BaseType ein Unterbereich mit
Untergrenze > 0 ist!). Jedem SET-Element entspricht also ein Bit, das den
Wert 1 bekommt, wenn das Element im SET enthalten ist.

Wichtig ist die Anordnung der Bits: EnthÑlt das SET maximal 32 Elemente,
sind diese entsprechend als Bits wie in einem 32 Bit-Wert  (z.B.  Register)
abgelegt. Bei grîûeren SETs ist die Anordnung undefiniert und kann je nach
Compiler-Version variieren.

Das  Setzen  eines  Bits  in  einer  BITSET-Variablen  aus  einem  Assembler~
programm sieht also so aus:

   ; *** INCL (BitSetVar, k)    in Assembler
   MOVE.W     BitSetVar, D0         ; Variable ins Register laden
   MOVE.W     k, D1                  ; Index des Elements holen
   BSET         D1, D0                ; Bit / Element setzen
   MOVE.W     D0, BitSetVar         ; Und neuen Wert wieder speichern
A.3 Interne Datenformate                                                  Anhang
________________________________________________________


REAL-Formate

LONGREALs  werden  in  64  Bit  dargestellt  mit  normalisierter  Mantisse
                                                               +
0.5 < M < 1.0 und Exponent E zur Basis 2. Also: Longreal =   M * 2 ^ E.
                                                               -

Wertebereich:            - 14.6E1240  ..  4.6E1240
relative Genauigkeit:        13.5 Stellen

      Bit     Funktion
      63
          6
      ..
             Exponent E (vorzeichenbehaftetes Integer, Basis ist 2)
          6
      51
      50     frei
      49     Zero-Flag:   1 = "Zahl ist ungleich Null"
      48     Vorzeichen:  1 = "Zahl ist negativ"
      47     Mantisse M
          6
       ..
             (auûer bei 0.0 stets linksbÅndig, d.h. Bit 47 = 1.
          6
      00      Bit 47 hat die Real-Wertigkeit 0.5)

      Eine Null wird durch gelîschte Bits 48 bis 63 dargestellt.

REALs werden in 32 Bit dargestellt mit normalisierter Mantisse 0.5 < M < 1.0,
invertiertem  Vorzeichen  S  und  Exponent  E  zur  Basis  2  mit  Bias  64.
Also: Real-Wert = NOT (S) * M * 2^(E-64).

Wertebereich:            - 9.2E18 .. 9.2E18
relative Genauigkeit:        7 Stellen

      Bit     Funktion
      31     Mantisse M
          6
       ..
             (kann auch denormalisiert sein, d.h.  Bit 31 muû nicht gesetzt sein;
          6
       8      Bit 31 hat die Real-Wertigkeit 0.5)
       7     invertiertes Vorzeichen:  0 = "Zahl ist negativ"
       6
          6
      ..
             Exponent E (vorzeichenbehaftetes Integer, Basis ist 2, Bias 64)
          6
       0
      Sind alle 32 Bit gelîscht, wird 0.0 dargestellt.


Hinweis:
  Bei Verwendung des Mathe-Koprozessors (FPU) werden die IEEE-Formate
  fÅr 64 und 32 Bit statt der hier beschriebenen verwendet!

  Die Konvertierung zwischen beiden Formaten kann mit dem Modul RealCtrl
  erfolgen.
A.4  Registerbelegung zur Laufzeit                                        Anhang
________________________________________________________


A.4  Registerbelegung  zur  Laufzeit

        D0..   Zwischenspeicher (kînnen in Assemblerteilen benutzt werden,
       D2                        behalten jedoch i. a. ihre Werte nicht)
        D3..   Zwischenspeicher, mÅssen bei  RÅckkehr aus Prozeduren
        D7                        ihren alten Wert wieder enthalten!
       A0     Zwischenspeicher
       A1     Zwischenspeicher
       A2     Zwischenspeicher
       A3     reserviert - Zeiger auf Parameter-Stack
       A4     muû nach RÅckkehr aus Prozeduren alten Wert  enthalten!
       A5     reserviert - Verwaltung der lokalen Variablen
       A6     reserviert - Zeiger auf aktuelle lokale Variablen
       A7     reserviert - Zeiger auf CPU-Stack
A.5 öbersicht Compileroptionen                                            Anhang
________________________________________________________


A.5   öbersicht:  Compileroptionen


Syntax-Beispiel:  (*$ R-, S-  Kommentar: alle PrÅfungen aus *)

Schalter

     Vor-
Name      Bedeutung               ErlÑuterungen
    einst
 A -  Erweiterte Syntax   A+ lockert einige Syntax-Regeln.
 B  -  Body Requirement    B+  verhindert  das  Entfernen  des  Modulkîrpers
                                beim optimierten Linken
 C +  Case Sensitivity      C-  hebt Unterscheidung von Groû-/Kleinschrift auf
 D -  Debugging            D+  erzeugt Zusatzcode zur Fehlersuche
 E  -  Procedure Trace     E+ erzeugt Code zur Anzeige von Prozeduraufrufen
 F  -  Float-Format         F+ dient zur Verwendung einer FPU
 H -  Local Procedures    H+ erlaubt lokale Prozeduren als Parameter
 I  -  Integer-Size         I+ ordnet CARDINAL/INTEGER den LONG-Typen zu
 J  +  Optimized Code      J- verhindert evtl. kritische Optimierungen
 K  -  Long-Short-Assign  K+ erlaubt Zuweisung von Long- auf Short-Variable
 L  +  Parameter Linking   L-  erlaubt ParameterÅbernahme von Assembler
 M +  Prozedurnamen      M- spart Platz, aber Prozedurnamen kînnen dann
                                nicht mehr bei Fehlern angezeigt werden. Beim
                                vollst. optimierten Linken werden alle Prozedur~
                                namen automatisch entfernt.
 N -  No Runtime          N+ verhindert den autom. Runtime-Import
 P  +  Protokoll             P-  nimmt Programmteile aus dem Protokoll aus
 Q -  Quiet Compilation    Q+ schaltet Ausgaben beim öbersetzen ab
 R  +  Range Checking      R-  spart Code fÅr BereichsprÅfungen
 S +  Stack Checking      S- spart Code fÅr Stackplatz-PrÅfungen;
                              S 512 setzt geforderte Stackplatz-Reserve
 T  +  Record Ordering     T- reiht Felder mit KommataaufzÑhlung rÅckwÑrts
 U +  Set Format          U- wÑhlt altes SET-Format (Compiler Version 3)
 V -  Verbose Protocol    V+ erzeugt Statistik am Ende der Protokolldatei
 W +  Warnings            W- verhindert Fehlermeldung bei REF-Parametern
 X -  Extended Asm       X+ erlaubt 68020 & 68881 Mnemonics (nur  bei
                                erweitertem Compiler / Assembler)
 Y -  System-Module      Y+ erlaubt "shared data"
 Z -  Value Return Mode  Z+ lÑût Funktionsergebnisse im Register liefern.

Sonstige Direktiven

 E      Extension           E xyz  setzt Endung der Codedatei auf '.xyz'
 I       Include              I filename  fÅgt Datei filename ein
 U      Uses Library        U path  lÑût Definitionsmodule auf path suchen
 ?       Conditional Comp.  ?constExpr:  Åbersetzt Folgendes nur bedingt
 Reg    Register Variable   LÑût Variable bevorzugt im Register ablegen
A.6 Backus-Naur-Notation                                                 Anhang
________________________________________________________



A.6  Backus-Naur-Notation

Zur Beschreibung der Syntax einer Programmiersprache eignet sich neben den
grafischen Syntaxdiagrammen die sogenannte 'Erweiterte  Backus-Naur-Form'
(EBNF).  In  diesem  Handbuch  finden  Sie  eine  vollstÑndige  Modula-Syntax~
beschreibung sowohl als Diagramme (Anhang A.7) als auch in EBNF (Anhang
A.8); in den Kapiteln 3 und 4 zitieren wir gelegentlich einzelne Elemente der
Syntax nur in EBNF. Auûerdem finden Sie im Anhang A.9 eine Darstellung der
Codefile-Formate in EBNF. Sie sollten sich also im folgenden schnell mit der
EBNF vertraut machen, falls Sie sie bisher nicht verwenden:

Ein  Programm  besteht  aus  syntaktischen  Einheiten,  z.B.  SchlÅsselworten,
Zeichen, oder auch aus einer Folge oder mehrfachen Wiederholung einfacherer
Syntaxeinheiten. Die EBNF erlaubt die Beschreibung solcher Konstrukte.

* Besteht das Konstrukt A aus der Aneinanderreihung der Konstrukte B und C,
so lautet seine Beschreibung in EBNF A = BC. (Wer hÑtte das gedacht ?!)

* Besteht A aus B oder (alternativ) aus C, wird es als A = B|C beschrieben.
Sind B oder C ihrerseits zusammengesetzt, etwa in Form einer Aneinander~
reihung,  und  soll  diese  Form  ausgeschrieben  werden,  dann  mÅssen  runde
Klammern gesetzt werden. Beispiel: A = B| (DE). - A besteht aus B oder aber
der Folge DE.

* Auûerdem kann EBNF eine Option beschreiben: A =  B  bedeutet: A besteht
aus B oder gar nichts (leeres Konstrukt).

* Schlieûlich gibt es die Mîglichkeit der Wiederholung: A =  B  besagt: A
besteht aus beliebig oft wiederholter Aneinanderreihung von B. Auch nullmalige
Wiederholung (also A als leeres Konstrukt) ist hier erlaubt!

* Bei der Beschreibung der Modula-Syntax hat es sich eingebÅrgert, daû die
SchlÅsselworte groû geschrieben werden (wie ja auch in Modula selbst), wÑhrend
zusammengesetzte  Konstrukte  Namen  in  gemischter  Groû-/Kleinschreibung
bekommen. Satzzeichen, die in Modula vorkommen, werden in AnfÅhrungszeichen
geschrieben, damit man sie von den EBNF-Zeichen unterscheiden kann.

Um mit der EBNF vertraut zu werden, sollten Sie sich in den folgenden Abschnit~
ten A.7 und A.8 einige Konstrukte in grafischer und EBNF-Darstellung ansehen
und vergleichen.
A.7 Modula-Syntaxdiagramme                                              Anhang
________________________________________________________


A.7    Modula-Syntaxdiagramme















          Aus technischen GrÅnden mÅssen Sie leider diesmal auf die
              Syntaxdiagramme verzichten. Wir geloben Besserung.
A.8  Modula-Syntax in EBNF                                               Anhang
________________________________________________________


A.8    Modula-Syntax  in   EBNF

ident                  = letter  letter | digit .
number               = integer | longInt | real.
integer                = digit  digit  | octalDigit  octalDigit  ('B'|'C') |
                          digit  hexDigit  'H' | '$' hexDigit  hexDigit .
longInt                = integer ('L'|'D').
real                   = digit  digit  '.'  digit   ScaleFactor .
ScaleFactor           = 'E'  '+'|'-'  digit  digit .
hexDigit               = digit | 'A'|'B'|'C'|'D'|'E'|'F'.
digit                   = octalDigit | '8'|'9'.
octalDigit              = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'.
string                 = ""  character  "" | ' '  character  ' '.
                          '               '    "              "
qualident              = ident  '.' ident .
ConstantDeclaration   = ident '=' ConstExpression.
ConstExpression      = expression.
TypeDeclaration       = ident '=' type.
type                   = SimpleType | ArrayType | RecordType | SetType |
                          PointerType | ProcedureType.
SimpleType            = qualident | enumeration | SubrangeType.
enumeration           = '(' IdentList ')'.
IdentList              = ident  ',' ident .
SubrangeType         =  qualident 
                          ' ' ConstExpression '..' ConstExpression ' '.
ArrayType             = ARRAY SimpleType  ',' SimpleType  OF type.
RecordType           = RECORD FieldListSequence END.
FieldListSequence     = FieldList  ';' FieldList .
FieldList               =  IdentList ':' type |
                          CASE  ident  ':' qualident OF variant  '|' variant 
                           ELSE FieldListSequence  END .
variant                =  CaseLabelList ':' FieldListSequence .
CaseLabelList         = CaseLabels  ',' CaseLabels .
CaseLabels            = ConstExpression  '..' ConstExpression .
SetType               = SET OF SimpleType.
PointerType           = POINTER TO type.
ProcedureType        = PROCEDURE  FormalTypeList .
FormalTypeList        = '('    VAR|REF  FormalType
                               ','  VAR|REF  FormalType    ')'  ':' qualident .
VariableDeclaration   = IdentList ':' type.
designator            = qualident  '.' ident | ' ' ExpList ' ' | '^' .
ExpList                = expression  ',' expression .
expression            = SimpleExpression  relation SimpleExpression .
relation               = '='|'#'|'<>'|'<'|'<='|'>'|'>='| IN.
AddOperator          = '+' | '-' | OR.
MulOperator          = '*' | '/' | DIV | MOD | AND | '&'.
SimpleExpression     =  '+' | '-'  term  AddOperator term .
A.8  Modula-Syntax in EBNF                                               Anhang
________________________________________________________


term                  = factor  MulOperator factor .
factor                 = number | string | valueConstrutor | '(' expression ')' |
                          designator  ActualParameters  | NOT factor|~factor.
valueConstructor      = recordConstructor | arrayConstructor | setConstructor.
setConstructor        =  qualident  setDefinition.
setDefinition          = ' '  member  ',' member   ' '.
member               = expression  '..' expression .
recordConstructor    = qualident recordDefinition.
recordDefinition       = ' ' element  ',' element  ' '.
arrayConstructor     = qualident arrayDefinition.
arrayDefinition        = ' ' repeatedElem  ',' repeatedElem  ' '.
repeatedElem         = element   BY ConstExpression  .
element               = expression | arrayDefinition | recordDefinition |
                          setDefinition.
ActualParameters     = '('  ExpList  ')'.
statement             =  assignment | ProcedureCall | IfStatement |
                          CaseStatement | WhileStatement | RepeatStatement |
                          LoopStatement | ForStatement | WithStatement |
                          AssemblerStatement | EXIT | RETURN  expression  .
assignment            = designator ':=' expression.
ProcedureCall         = designator  ActualParameters .
StatementSequence   = statement  ';' statement .
IfStatement           = IF expression THEN StatementSequence
                           ELSIF expression THEN StatementSequence  
                           ELSE StatementSequence   END.
CaseStatement       = CASE expression OF case  '|' case 
                           ELSE StatementSequence  END.
case                  =  CaseLabelList ':' StatementSequence .
WhileStatement       = WHILE expression DO StatementSequence END.
RepeatStatement      = REPEAT StatementSequence UNTIL expression.
ForStatement         = FOR ident ':=' expression TO expression
                           BY ConstExpression  DO StatementSequence END.
LoopStatement        = LOOP StatementSequence END.
WithStatement        = WITH designator DO StatementSequence END.
AssemblerStatement  = ASSEMBLER AssemblerLine  AssemblerLine  END.
AssemblerLine        =  ident   OpCode  Operand  .
ProcedureDeclaration = ProcedureHeading ';' block ident.
ProcedureHeading     = PROCEDURE ident  FormalParameters .
ForwardDeclaration   = FORWARD ident  Formalparameters  |
                          ProcedureHeading ';' FORWARD.
block                  =  declaration   BEGIN StatementSequence  END.
declaration            = CONST  ConstantDeclaration ';'  |
                          TYPE  TypeDeclaration ';'  |
                          VAR  VariableDeclaration ';'  |
                          ProcedureDeclaration ';' | ForwardDeclaration ';' |
                          ModuleDeclaration ';'.
A.8  Modula-Syntax in EBNF                                               Anhang
________________________________________________________


FormalParameters    = '('  FPSection  ';' FPSection   ')'  ':'qualident .
FPSection             =  VAR|REF  IdentList ':' FormalType.
FormalType           =  ARRAY OF | LONGARRAY OF  qualident.
ModuleDeclaration     = MODULE ident  priority  ';'  import   export 
                          block ident.
priority                = ' ' ConstExpression ' '.
export                = EXPORT  QUALIFIED | PERVASIVE   IdentList ';'.
import                =  FROM ident  IMPORT IdentList ';'.
DefinitionModule       = DEFINITION MODULE ident ';'  import   export 
                           definition  END ident '.'.
definition              = CONST  ConstantDeclaration ';'   |
                          TYPE  ident  '=' type  ';'  |
                          VAR  VariableDeclaration ';'  |
                          ProcedureHeading ';'.
ProgramModule       = MODULE ident  priority  ';'  import  block ident '.'.
CompilationUnit       = DefinitionModule |  IMPLEMENTATION  ProgramModule.
A.9  Aufbau der Codemodule                                              Anhang
________________________________________________________


A.9  Aufbau  der  Codemodule


Hinweise zur Notation und verwendeten Begriffen:

Zur Beschreibung des Formats wird eine Art Backus/Naur-Notation verwendet:
In  geschweiften Klammern  stehen Teile, die beliebig oft wiederholt werden
kînnen (auch null Mal). In  eckigen Klammern  stehende Teile kînnen einfach
oder gar nicht auftreten.

Durch  "^Objekt"  wird  ein  Pointer  auf  das  Objekt  bezeichnet.  Wenn  nicht
anders angegeben, ist der Wert des Pointers stets relativ zum Anfang des
Moduls zu verstehen.

Der "Key" eines Moduls wird vom Compiler vergeben, um verschiedene Versionen
eines Moduls unterscheiden zu kînnen. Er wird beim öbersetzen eines Definitions~
modules errechnet  und  aus  dem  Definitionsmodul  sowohl  in  die  zugehîrige
Implementation als auch in alle Klienten-Module Åbernommen.

Der "linearisierte Baum" im Definitionsmodul enthÑlt die Beschreibungen  der
exportierten Objekte.

Ein "Item" bezeichnet ein beliebiges Objekt aus dem linearisierten Baum. Items
kînnen  z.B.  Variablen,  Typen,  Prozeduren,  Konstanten  beschreiben.  Items
werden "anonym" eingetragen, wenn der Programmierer ihnen keine expliziten
Namen gegeben hat (etwa bei Typbeschreibungen, die direkt in einer Variablen~
deklaration  angegeben  werden).  Die  "Item-Nr"  wird  beim  Linearisieren  des
Baums durch AbzÑhlen vergeben.

Achtung: Seit Compiler-Version 3.7 wird vor dem eigentlichen Modulcode noch
eine Kennung abgelegt, um die Dateien eindeutig identifizieren zu kînnen. Bei
allen vom Compiler erzeugten Dateien ist diese Kennung acht Zeichen lang, und
sie enthÑlt den Text "MM2Code", abgeschlossen mit einem Null-Zeichen.
A.9  Aufbau der Codemodule                                              Anhang
________________________________________________________


Format von Programm-/Implementations-Modulen:

Format des Modulkopfes:

    8 byte   Datei-Kennung        "MM2Code" (gehîrt nicht zum Modul)
    1 byte   Layout Nr.            2 seit Compiler 3.6, erhîht bei
                                     énderung des Modulformats
    1 byte   Kennung               Bits 0-1: 1 = Programm
                                               2= Implementation
                                     Bit 4:    1 = Prozedurnamen im Code
                                     Bit 5-6  0 = keine Reals, 1= MM2-Reals,
                                               2 = ST-FPU, 3= TT-FPU.
                                     Bit 7:    1 = 68020/881 Instr. im Code
    4 byte   Key                    VersionsschlÅssel, Dummy bei Pgm-Modul
    4 byte   ^ Modul-Rumpf       StartAdr bei AusfÅhrung
    4 byte   ^ Modul-Ende         Platz fÅr nÑchstes Modul
    4 byte   ^ Import-Liste        (s.u.)
    4 byte   ^ Export-Liste        (s.u.)
    4 byte   ^ Relozier-Liste       auch Start der glob. Variablen
     4 byte   ^ Sourcefile-Namen   Name des zugehîrigen Quelltextes
     4 byte   ^ Modulnamen        Name aus dem Programmkopf
     4 byte   ^ Symbolfile-Namen   z. Zt. unbenutzt, immer Null
    4 byte   ^ Proc-LÑngen-Liste  LÑnge jeder globalen Prozedur
    4 byte   ^ Code-Start         Ende des Headers
    4 byte   Options               Options, die wÑhrend des öbersetzen aktiv
                                     waren (hierÅber erfÑhrt der Linker beispiels-
                                     weise die Einstellung der $B-Option)
       ...     Modul-, Source-, Symbolname
              Importliste
               Export-Liste 
              Modul-Code
              Relozier-Liste
              Proc-LÑngen-Liste


Format der Modul-, Source- und Symbolfile-Namen:

     1 byte   Name in ASCII-Bytes
     1 byte   Endmarke 0
A.9  Aufbau der Codemodule                                              Anhang
________________________________________________________


Format der Import-Liste (Pgm/Impl.Modul):

    4 byte    Key des importierten Moduls
  2*n byte   Name des Moduls  $FE  $FF

    2 byte    Item-Nr. des Imports (nur Variablen/Prozeduren sind enthalten)
    4 byte   ^ letzte Referenz auf importiertes Item
    2 byte   Endmarke $0000

    4 byte   Endmarke $00000000


Format der Export-Liste (Impl.Modul):

    2 byte    Item-Nr
    4 byte   Adresse des Items (rel. zum Modulanfang, nur Variablen
              und Prozeduren stehen in der Exportliste)
    2 byte   Endmarke $0000


Format der Relozier-Liste fÅr Variablen/Prozeduren:

    4 byte    ^ letzte Referenz
    4 byte   Adresse, rel. zum Modulanfang
    4 byte   Endmarke $00000000


Anmerkungen:

- bei Programmmodulen ist der Pointer auf die Exportliste = 0.L

- bei Implementationen ohne Export besteht die Exportliste nur aus der
  Endmarke = 0.W
A.9  Aufbau der Codemodule                                              Anhang
________________________________________________________


Format von Definitions-Modulen:

Format des Modulkopfes:

   8 byte    Datei-Kennung        "MM2Code" (gehîrt nicht zum Modul)
   1 byte     Layout Nr.             5 seit Compiler 4.0, erhîht bei
                                     énderung des Modulformats
   1 byte     Kennung               immer 3 = DefModul
   2 byte    Qualification Flag      1 = qualified | (auch Module ohne EXPORT)
                                     2 = pervasive |
                                     0 = unqualified
   4 byte     Key
   4 byte    ^ linearisierten Baum (relativ zum Modulanfang)
   2 byte     Anzahl der definierten Items
   4 byte    ^ Import-Liste (relativ zum Modulanfang)
   4 byte    Platzbedarf der definierten Variablen
   4 byte    ^ Modulnamen
   4 byte    ^ Ende des Headers
   4 byte    ^ Source-Name
     ...      Modulname (Format wie in Implementationsmodulen),
             Importliste, linearisierter Baum


Format der Import-Liste (Def.Modul):

    4 byte   Key des importierten Moduls
    2 byte   Anzahl der im importierten Modul definierten Items

    2 byte   Item-Nr. des Imports (bit 15 = "Item ist Var/Proc")
    2 byte   eigene Item-Nr. fÅr dieses Item
    2 byte   Endmarke $0000

    4 byte   Endmarke $00000000


Format des linearisierten Baumes:

    2 byte    Item-Nr. des folgenden Items
              (bit 15 = "dieses Objekt wird exportiert")
    2 byte   ^nÑchste Item-Nr.
              (relativ zur Position dieses ^)
  2*n byte   Name des Items  $FE  $FF
              (Name leer bei anonymen EintrÑgen, $FE dient als Sync)
    2 byte   Kennung (s.u.)
  2*m byte  Item-Beschreibung (s.u.)
    2 byte    Endmarke $0000
A.9  Aufbau der Codemodule (Beschreibung der Items)                   Anhang
________________________________________________________


Beschreibung der Items im linearisierten Baum:

Das erste Byte der Kennung enthÑlt acht Flag-Bits:
  Bit 7    benutzerdefiniertes Item (also kein Standard-Symbol)
  Bit 6    exportiertes Item
  Bit 5    importiertes Item
  Bit 4    bei Variablen: Externe Variable  (feste Adresse)
  Bit 3    bei lokalen Variablen: REF-/VAR-Parameter
           bei Prozeduren: Parameter auf A7 statt A3 Åbergeben
  Bit 2    Item ist ein Typ-Descriptor (gelîscht bei impliziten Typen o. Name)
  Bit 1    globales Item;
  Bit 0    bei Types: skalarer Typ;
           bei Variablen: schreibgeschÅtzt (z.B. REF-Parameter)

Das andere Byte gibt die Typ-Nr. des Items an.

Aufbau der einzelnen Item-Beschreibungen:

Art           Typ-Nr.
______________________________________________________
     8
Relay          |  0 | ^eigentliche Item-Beschreibung |
LONGINT      |  1  | Grîûe.L |
LONGREAL    |  2 | Grîûe.L |
CHAR         |  3 | Grîûe.L |
    1
ZZ            |  4 | Grîûe.L |
           7
SET OF ...    |  5 | Grîûe.L | ^ElementTyp |
Prozedur      |  6 | Adr.L | ^1.Parameter | ^ResultTyp | dummy.L |
                                                                           2
Parameter    |  7 | ^nÑchster Parameter | ^ParamterTyp | ParFlags.W   |
        3
Opaque       |  8 | Grîûe.L |
Enumeration  |  9 | Grîûe.L | Anzahl Elemente.L | ^1.Element |
Enum-Element| 10 | OrdWert.W | ^Enum-Typ | ^nÑchstes Element |
Subrange     | 11  | Grîûe.L | Untergrenze.L | Obergrenze.L | ^BasisTyp |
ARRAY ...     | 12 | Grîûe.L | ^IndexTyp | ^ElementTyp |
RECORD ...   | 13 | Grîûe.L | ^erstes Feld | <^lokaler Baum der Felder> |
RECORD-Feld | 14 | relAdr.L | ^Typ | ^nÑchstes Feld |
Lok. Modul    | 15 | ^lok.Baum |            (nur Compiler-intern verwendet)
Qualifier      | 16 | ^lok.Baum |            (nur Compiler-intern verwendet)
                                                    6
Variable       | 17 | Adr.L | ^VarTyp | dummy.L |   VarFlags.B | UsedDepth.B |
Konstante     | 18 | ^Typ | Grîûe.W | Wert... (in Long-Portionen) |
Prozedur-Typ | 19 | Grîûe.L | ^1.Parameter | ^ResultTyp |
POINTER...    | 20 | Grîûe.L | ^BasisTyp |
WORD        | 21 | Grîûe.L |
LONGCARD   | 22 | Grîûe.L |
ADDRESS     | 23 | Grîûe.L | ^BasisTyp |
BOOLEAN     | 24 | Grîûe.L |
        4
Opaque       | 25 | Grîûe.L |
LONGWORD  | 26 | Grîûe.L |
String         | 27 | Grîûe.L | Zeichenzahl.L |
TABLE...      | 28 | Adr.L |
Asm-Label    | 29 | ...                     (nur Compiler-intern verwendet)
LongBoth      | 30 | Grîûe.L |
String-Const  | 31 | Zeichenzahl.B |  char.B  |
Open-Array   | 32 | ^ElementTyp |
INTEGER      | 33 | Grîûe.L |
CARDINAL    | 34 | Grîûe.L |
ShortBoth     | 35 | Grîûe.L |
A.9  Aufbau der Codemodule (Beschreibung der Items)                   Anhang
________________________________________________________


Std-Funktion  | 36 | F-Nr.W |              (nur Compiler-intern verwendet)
Std-F.-Parm  | 37 | ...                     (nur Compiler-intern verwendet)
BYTE          | 38 | Grîûe.L |
BYTE(signed)  | 39 | Grîûe.L |              (nur Compiler-intern verwendet)
REAL          | 40 | Grîûe.L |
BITNUM       | 41 | Grîûe.L |
LongOpen-Arr| 42 | ^ElementTyp |
Any Type      | 43 | Grîûe.L |              (nur Compiler-intern verwendet)
          5
Proc-Typ      | 44 | Grîûe.L | ^Proc-Typ (m. Kennung 19) |
            7
SET OF ...    | 45 | Grîûe.L | ^ElementTyp |
Tag-Feld      | 46 | ^REC-Feld | Untergrenze.L | Obergrenze.L | ^Tag-Feld |
REC-Variante | 47 | dummy.L | ^Typ | ^nÑchstes Feld | ^REC-Feld | ^Tag-Feld |

Anmerkungen:
1)  Der Typ ZZ ist nur fÅr ordinale Konstanten vorgesehen: Er umfaût den
   Bereich von MIN (LONGINT) bis MAX (LONGCARD) und besteht deshalb aus
   33 signifikanten Bits. Der Wert liegt im Baum als ein Record aus einem
   WORD und einem LONGWORD-Wert. Ist das WORD Null, ist der Long-
   Wert als LONGINT, sonst als LONGCARD zu interpretieren.
2) Bit 8 gesetzt -> Parameter ist "VAR"-Parameter
   Bit 9 gesetzt -> Parameter ist "REF"-Parameter
   Bit 7 gesetzt -> Bits 0-5 enthalten Reg-Nr, in der das Arg. Åbergeben wird.
3) Beschreibt einen im eigenen Modul definierten opaquen Typ (Compiler-intern).
4) Beschreibt einen ex-/importierten opaquen Typ.
5) Der Prozedur-Typ mit der Nr. 44 ist fÅr value-Parameter vorgesehen, die
   auch eine Zuweisung von lokalen Prozeduren erlauben (Grîûe: 8 Byte).
6) "VarFlags" und "UsedDepth" sind nur im Compiler temporÑr vorhanden.
   Die Bits in VarFlags:
      Bit 7: Reg-Var; Bit 6: z.Zt. im Reg; Bit 5: dirty; Bit 0..4: Reg-Nr.
   In UsedDepth wird der tiefste Scope-Level aller Zugriffe gespeichert.
7) SETs mit Kennung 45 kommen nur bei Grîûen bis 32 Bit vor. Die Kennung
   5 beschreibt die grîûeren SETs mit byteweiser Anordnung (kommt aber
   durch die Direktive $U- auch bei SETs unter 32 Bit vor).
8) Sog. Relays entstehen, wenn beispielsweise zuerst die Originalbeschreibung
   anonym, also namenlos, in den Baum eingetragen wird und spÑter der Name
   doch benîtigt und nachgetragen wird: Dann wird der Name zusammen mit
   der Relay-Kennung und dem Verweis auf die eigentliche Beschreibung im
   Baum angefÅgt.

 * Die "Grîûe" gibt bei Types ihre LÑnge in Bytes an. Sie ist in der Regel
   konstant.
 * ".L" bedeutet einen Long-Wert (4 Byte), ".W" einen Word-Wert (2 Byte)
   und ".B" einen Byte-Wert.
 * Die mit "^" bezeichneten EintrÑge sind Word-Daten (2 Byte) und verweisen
   auf die Item-Nummer der zugehîrigen Beschreibung.
 * Item-Nummern mit dem Wert "0" bedeuten, daû das betreffende Item nicht
   verwendet wird.
A.9  Aufbau der Codemodule (Relozieren und Linken)                     Anhang
________________________________________________________


Das Relozieren:

Der  68000-Prozessor  bietet  zwar  fÅr  alle  Befehle   auch   PC-relative
Adressierung an, leider ist dabei der Bereich auf +/- 32 KB beschrÑnkt, so
daû grîûere Programme oder Datenmengen darÅber nicht adressiert werden
kînnen. Deshalb verwendet der Modula-Compiler zur Adressierung von globalen
Prozeduren und Variablen die absolute Adressierung.

NatÅrlich ist wÑhrend des öbersetzungsvorgangs nicht bekannt, wo das Modul
spÑter im Speicher liegen wird. Daher kînnen die absoluten Adressen noch
nicht berechnet werden. Stattdessen werden die 32 Bit, die bei jedem Aufruf
fÅr  die  Adresse  zur  VerfÅgung  stehen,  zum  Anlegen  einer  Zeigerkette
verwendet. Sie enthÑlt jeweils einen Verweis auf die vorrige Referenz auf die
selbe angesprochene Prozedur/Variable. FÅr jede globale Var/Proc zieht sich
also eine Zeigerkette rÅckwÑrts durch die Code-Datei. Am Ende der Code-
Datei wird dann eine Relozierkette angehÑngt, die wiederum fÅr jede Var/Proc
einen Zeiger auf den Anfang der zugehîrigen Zeigerkette sowie ihre relative
Adresse enthÑlt.

Beim Laden des Moduls geht der Loader die Relozierkette durch, indem er aus
der  (nun  bekannten)  Startadresse  des  Moduls  und  der  relativen  Adresse
jeweils die absolute Lage der Var/Proc bestimmt. Dann wird die Zeigerkette
verfolgt und alle Zeiger werden durch diese Adresse ersetzt. Nachdem die
gesamte Relozierkette abgearbeitet ist, kann sie durch Variablen oder weitere
Module Åberschrieben werden.

Das Linken:

Wenn  ein  Programm  aus  mehreren  Modulen  besteht,  die  untereinander
Prozeduren oder Variablen austauschen, mÅssen die Adressen der importierten
Objekte ebenfalls vor dem Start des Programms nachgetragen werden.

Dazu werden - genau wie beim  Relozieren  der  eigenen  Vars/Procs  -  alle
Referenzen auf diese Objekte zunÑchst  durch  Zeigerketten  verbunden.  Hier
kann der Compiler aber nun nicht feststellen, auf welcher relativen Adresse
die Objekte im importierten Modul liegen (die Implementation des importierten
Moduls ist ja nicht bekannt, sondern nur seine Definition).

Deshalb wird neben der Relozierliste eine extra Importliste fÅr jedes impor~
tierte Modul angelegt, die neben dem bekannten Zeiger auf die Zeigerkette
jeweils eine Item-Nummer enthÑlt. Diese Item-Nr. wird  vom  Compiler  beim
öbersetzen  eines  Definitionsmoduls  vergeben  und  sowohl  in  den  eigenen
Implementationsmodul-Code  und  eben  in  die  importierenden  Module  Åber~
nommen.  Im  der  Implementation  tauchen  sie  in  der  Export-Liste  auf,
zusammen mit der relativen Adresse der exportierten Var/Proc. Der Loader
durchsucht also beim  Linken  zweier  Module  nach  Åbereinstimmenden  Item-
Nummern und findet auf diese Weise die Referenz-Zeigerkette und die darin
nachzutragende (relative) Adresse.
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


A.10    BegriffserlÑuterungen

Eigentlich sollte dieses Kapitel nur zum Nachschlagen unverstÑndlicher Begriffe
dienen. Mittlerweile ist hier aber so viel an Fachwissen eingeflossen, daû es
sich auch fÅr einen erfahrenen Programmierer  lohnen  dÅrfte,  das  gesamte
Kapitel einmal durchzustîbern.


Algorithmus
    Der Algorithmus bestimmt einen Funktionsablauf, eine Vorgehensweise. Ein
    Programm  besteht  aus  vielen  Algorithmen,  aber  auch  das  gesamte
    Programm kann als ein komplexer Algorithmus angesehen werden.

Argumentzeile
    Auch "Command-Line" genannt.
    So nennt sich der Text, der optional beim Starten von Programmen mit
    der Endung TTP vom Desktop (bzw. auch mit Endung MTP oder durch das
    Festhalten der Shift-Taste beim Start in der Megamax-Shell) eingegeben
    werden  kann.  Es  gibt  auch  Programme  (Shells),  z.B.  vornehmlich  auf
    MSDOS-,  CP/M-  oder  UNIX-Rechnern,  bei  denen  jedes  zu  startende
    Programm nicht mit der Maus aus einem MenÅ, sondern durch Eingabe
    ihres Namens in einer Eingabezeile, gestartet werden. Aus diesem Ñlteren
    Konzept  geht  auch  die  Argumentzeile  hervor:  Man  kann  hinter  dem
    Programmnamen  weiteren  Text  eingeben,  der  dann  dem  gestarteten
    Programm in seiner Base Page Åbergeben wird. In der Megamax-Bibliothek
    ermîglicht beispielsweise das Modul ArgCV die Abfrage dieser Argument~
    zeile.

    Beispielsweise wertet fast jeder Editor seine Argumentzeile aus: Ist sie
    nicht leer, interpretiert er das erste Wort darin als einen Dateinamen und
    versucht, die Datei als Text zu laden. Weitere evtl. in der Zeile enthaltene
    Worte werden je nach Editor als weitere Textnamen (z.B. TEMPUS) oder
    andere Informationen interpretiert.

    Das Atari-Desktop unterstÅtzt neben den Programmen mit TTP-Endung die
    Argumentzeile  noch  auf  eine  andere  Weise:  Wird  ein  Programm  im
    Desktop  unter  Anwendung  anmelden  fÅr  eine  bestimmte  Dateiendung
    vorgesehen, wird bei einem Doppelklick auf eine Datei mit jener Endung
    das benannte Programm gestartet und der angeklickte Dateiname in der
    Argumentzeile Åbergeben.

Base Page
    Jedes Programm hat solch einen 256 Byte groûen Puffer im Speicher. In
    ihm speichert das TOS alle zum Programm-Prozeû gehîrigen Informationen,
    wie beispielsweise die offenen Dateien, die aktuellen Pfade und auch die
    Argumentzeile. Der dynamisch belegte Speicher (durch GEMDOS-Funktion
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


    malloc bzw. Storage-Funktion ALLOCATE) des Programms wird ebenfalls
    Åber diese Base Page identifiziert.

    Das TOS hat eine Systemvariable, die immer den geraden aktiven Prozeû
    anzeigt: Es ist ein Zeiger auf die aktuelle Base Page. Theoretisch mÅûte
    auch beim Aktivieren eines Accessories diese Systemvariable auf dessen
    Base Page zeigen - leider hat hier das TOS einen Fehler: Der Zeiger wird
    nicht vom TOS umgesetzt, das gestartete Hauptprogramm bleibt weiterhin
    das "aktive", so daû beispielsweise eine énderung der aktuelle Pfade im
    Accessory sich auch auf die Hauptanwendung auswirkt und angeforderter
    Speicher  nicht  dem  Accessory  sondern  dem  Hauptprogramm  gehîrt  -
    endet das Hauptprogramm, wird auch der vom  Accessory  angeforderte
    Speicher freigegeben.

Betriebssystem
    Das Betriebssystem ist eine Sammlung grundlegender Funktionen, die von
    extern gestarteten Programmen aufgerufen werden kînnen,  damit  nicht
    jedes Programm alle Grundfunktionen selbst nochmal enthalten muû. Eine
    wichtige  Aufgabe  von  Betriebssystemen  ist,  Zugriffe  von  verschiedenen
    Programmen  auf  dieselben  Ressourcen  des  Computers  zentral  zu
    koordinieren, damit sich die Programme  nicht  gegenseitig  in  die  Quere
    kommen.  Jede  Programmiersprache,  auch  Megamax  Modula-2,  bietet
    ebenfalls  Grundfunktionen,  die  wiederum  auf  die  des  Betriebssystems
    zurÅckgreifen.

Booten
    Durch  Druck  auf  den  RESET-Taster  beim  Atari  ST  (meist  hinten  am
    GehÑuse)  oder  durch  Einschalten  wird  er  gebootet.  Dabei  wird  das
    Betriebssystem initialisiert (bzw. ein Initialisierungsprogramm im Betriebs~
    system gestartet) und danach ein Anwendungsprogramm gestartet. Beim
    Atari ST ist das normalerweise der GEM-Desktop, zuvor werden aber im
    Rahmen der vorbereitenden Initialisierung noch Programme gestartet, die
    sich  im  AUTO-Ordner  befinden,  und  solche,  die  sich  im  Wurzel-
    Verzeichnis der Boot-Disk befinden und die Extension ACC (Accessories)
    tragen.  Es  gibt  zwei  Arten  des  Bootens:  Den  Warmstart  und  den
    Kaltstart.  Der  Kaltstart  initialisiert  den  Rechner  vollstÑndig,  inkl.  dem
    Lîschen des Speichers. Er wird immer beim Einschalten durchgefÅhrt. Der
    Warmstart lîscht nicht den Speicher erneut, so daû nach einem fatalen
    Programmfehler  mit  etwas  Aufwand  ggf.  noch  Daten  im  Speicher  zu
    retten  sind.  Er  kann  durch  Druck  auf  den  RESET-Taster  ausgelîst
    werden.

Code, Object-File
    Ein  Code  bzw.  eine  Objekt-Datei  ist  eine  vom  Compiler  Åbersetzte
    Source. Der Code ist nicht mehr als Text lesbar, sondern ist eine kodierte
    Form,  die  Instruktionen,  Anweisungen  enthÑlt,  die  z.B.  von  einem
    Mikroprozessor, wie dem 68000 im Atari ST, verstanden und ausgefÅhrt
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


    werden kînnen. Allerdings spricht man bei Object-Files und Codes meist
    von einer Mischung solcher Instruktionen und zusÑtzlicher Informationen,
    die  fÅr  einen  Linker  bestimmt  sind.  Bei  Compiler-Sprachen  sind  diese
    Codes  Åbersetzte  Module,  die  der  Linker  dann  zu  einem  Programm
    zusammenfÅgen kann.

Desktop
    Der Desktop bei einem GEM-Programm ist das Feld unter der MenÅleiste.
    Sinnbildlich  steht  der  Desktop  fÅr  die  SchreibtischoberflÑche,  auf  der
    BlÑtter  (in  Form  von  Fenstern)  und  Symbole  fÅr  Aktenordner  usw.
    herumliegen.

Dir, Directory
    Directory  (Abk.:  Dir)  ist  die  engl.  Bezeichnung  fÅr  Disk-Verzeichnisse.
    Diese kînnen das Wurzel-Verzeichnis oder ein Ordner auf einem Laufwerk
    sein.

Disk
    Die Disk - Abk. fÅr Diskette; auch Hard-Disk, RAM-Disk oder sonstiger
    Massenspeicher.

Extension, Extender, Endung, Suffix
    Alle diese Begriffe bezeichnen den optionalen, durch einen Punkt  ange~
    hÑngten Typen-Bezeichner  an  einem  Dateinamen.  Viele  Endungen  haben
    eine feste Verwendung, um die Art und Verwendbarkeit von Dateien zu
    beschreiben: PRG, APP, TOS und TTP kennzeichnen  vom  GEM-Desktop
    ausfÅhrbare Programme,  TXT  und  DOC  weisen  auf  Dateien  mit  direkt
    lesbarem Text hin. Auch  beim  Megamax-System  sind  einige  bestimmte
    Endungen vergeben: Dateien, die auf M2P enden (Bsp: MM2SHELL.M2P),
    enthalten Parameter-Dateien fÅr die Shell, MOD sind unter der Shell als
    Programm ausfÅhrbare Module.

GEM-Datei-Selektor, File-Selektor
    Der Datei-Selektor dient zum menÅorientierten AuswÑhlen von Dateien. Er
    wird Åber die GEM-Funktion 'fsel input' (bei Megamax: GEMEnv.SelectFile)
                                       _
    aufgerufen und zeigt dann ein Inhaltsverzeichnis, aus dem eine Datei mit
    der Maus bequem ausgesucht werden kann. Er erscheint beispielsweise,
    wenn mit einem der Megamax-Editoren eine neue, noch unbenannte Datei
    geladen werden soll.

GEM-Desktop
    Als GEM-Desktop bezeichnen wir die Anwendung, die normalerweise nach
    dem  Einschalten  des  Atari  ST  gestartet  wird,  und  von  der  dann  alle
    weiteren  Programme  gestartet  werden  kînnen.  Der  GEM-Desktop  ist
    ebenfalls eine Shell, wie die Megamax-Shell.
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


Heap
    So nennt man den Speicherbereich, der einem laufenden Programm fÅr
    dynamische  Speicheranforderungen  zur  VerfÅgung  steht.  Er  wird  vom
    Betriebssystem  (GEMDOS)  verwaltet.  öber   die   GEMDOS-Funktionen
    Malloc,  Mfree  und  Mshrink  kînnen  Teile  von  ihm  von  Programmen
    reserviert und wieder freigegeben werden. Modula-Programme sollten aber
    die dafÅr vorgesehenen Funktionen des Moduls Storage verwenden. Dieses
    Modul arbeitet mit den GEMDOS-Funktionen zusammen, macht aber eine
    zusÑtzliche  Verwaltung,  die  bei  vielen  kleinen  HÑppchen  nicht  nur
    platzsparender und schneller ist,  sondern  auch  sicherer,  weil  es  einen
    prinzipiellen  Fehler  des  GEMDOS  lîst:  Es  dÅrfen  beim  GEMDOS  pro
    Prozeû nur ca. 20-40 Blîcke angefordert sein, sonst passieren je nach
    TOS-Version  mehr  oder  weniger  unschîne  Dinge  (ab  TOS  kann  es
    beispielsweise u.U. zu der Meldung Out of internal  memory  kommen  -
    dann steht der Rechner, und man kann nur noch die Reset-Taste drÅcken).
    Vorsicht: Gehen Sie nie davon aus, daû Speicher, der vom Heap ange~
    fordert wurde, gelîscht, d.h. mit Null-Werten beschrieben, ist!

Key
    Der  Modul-Key  wird  vom  Compiler  beim  öbersetzen  eines  Definitions~
    moduls errechnet und dann in der erzeugten Code-Datei abgelegt (4 Byte).
    Zur Berechnung werden die maûgebenden Namen und Strukturen heran~
    gezogen.  Jede  énderung  an  einem  Bezeichner-Namen  oder  seiner
    Definition erreicht die Berechnung eines anderen Key-Wertes.

    In  den  Codes  aller  Module,  die  nun  dieses  Modul  importieren,  wird
    wiederum  auch  dieser  Key-Wert  gespeichert.  So  ist  eine  Beziehung
    zwischen dem importierten Modul und seinem Klienten erreicht. Werden
    nun diese Module vom Loader oder Linker zusammengefÅgt, werden die
    Key-Werte der importierenden Module mit dem Original-Key des importier~
    ten Moduls verglichen. Sind sie nicht identisch, bedeutet das, daû nicht alle
    diese Module unter derselben Definition Åbersetzt wurden. Das kînnte zu
    fatalen  Fehler  im  Programm  fÅhren,  so  daû  Linker  bzw.  Loader  den
    Bindevorgang mit der Fehlermeldung "Versionskonflikt" abbrechen.

Literale
    ISO definiert drei Arten von Konstant-Typen, auch Literale genannt: Z (im
                                                                             Z
    Handbuch meist ZZ), S (SS) und R  (RR). ZZ sind Ganzzahl-Konstanten,
                            S            R
    wie 12 oder -456. RR sind entsprechend fÅr Real-Konstanten (12.0 oder
    -3.001)  vorgesehen.  SS  steht  schlieûlich  fÅr  String-Konstanten,  also
    "abc",  "1",  ""  (Leerstring)  und  auch  7C  (ehemals  Zeichenkonstanten).
    ZZ-Typen sind zu SHORTINT, SHORTCARD, LONGINT  UND  LONGCARD
    kompatibel, RR zu  REAL  und  LONGREAL,  SS  zu  String-Typen  (ARRAY
     0..n  OF  CHAR)  und  zu  CHAR.  Wird  ein  Leerstring  auf  eine  CHAR-
    Variable  zugewiesen,  wird  daraus  das  String-Abschluûzeichen   (bei
    Megamax: 0C).
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


Modul
    In  einem  Modul  sind  in  der  Regel  mehere  Funktionen  (Prozeduren)
    versammelt,  die  einen  logischen  Zusammenhang  haben.  So  enthÑlt  das
    Standard-Modul Storage Funktionen zum Reservieren und Verwalten von
    Speicherbereichen,  das  Modul  InOut  bietet  Funktionen  zur  einfachen
    Ein-/Ausgabe auf den Bildschirm.

Ordinale
    Hierzu zÑhlt man alle unstrukturierten Datentypen, die abzÑhlbar sind, wie
    CARDINAL, INTEGER, AufzÑhlungstypen, BOOLEAN und CHAR.

Programm, Anwendung
    Das Programm ist in der Regel eine Sammlung von Funktionen, meist aus
    mehreren  Modulen.  WÑhrend  ein  Modul  nur  eine  Funktionssammlung
    darstellt,  ist  ein  Programm  eine  ablauffÑhe  Anwendung.  Ein  Programm
    kann  gestartet  werden,  dann  fÅhrt  es  die  darin  zusammengefaûten
    Funktionen und Algorithmen aus.

Prozeû
    Verwechseln  Sie  Prozeû  nicht  mit  Coroutinen.  Letztere  sind  die  von
    N.Wirth   in   Modula-2   eingefÅhrten   Pseudo-Prozesse,   die   durch
    NEWPROCESS  eingerichtet  werden.  Unter  einem  Prozeû  verstehen  wir
    dagegen  ein  laufendes  Programm  mitsamt  seiner  Umgebung.  Solche
    Prozesse  werden  durch  die  GEMDOS-Funktion  Pexec  gestartet.  Die
    Megamax-Bibliothek bietet zwei komfortable Funktionen zum Starten eines
    Prozesses: Loader.CallModule startet gelinkte Programmdateien und auch
    ungelinkte  Megamax-Module  von  Disk,  ModCtrl.ExecProcess  startet  in
    gleicher Weise Prozeduren innerhalb eines Programms (beides sind sog.
    Tochter-Prozesse, weil sie vom Vater-Prozeû gestartet werden und bei
    Prozeûende auch wieder zum Aufruf des Vaters zurÅckkehren).

resident
    Resident bedeutet "gegenwÑrtig". Von residenten Modulen wird gesprochen,
    wenn sie zum jenem Zeitpunkt in ihrer Umgebung vorhanden, aktiv sind.
    Konkret bedeutet das: Wenn ein Programm, z.B. die Shell, gestartet wurde
    und nun ablÑuft, sind die Module, aus denen dieses Programm besteht,
    resident  in  der  Shell  vorhanden.  Dem  gegenÅber  gibt  es  Module,  die
    dazu-geladen werden, aber nicht resident sind, weil sie nicht zur augen~
    blicklichen Umgebung, also der Shell, gehîren.

Ressourcen
    Die  Ressourcen  sind  die  grundlegenden  Betriebsmittel  eines  Computers
    oder  eines  Programms.  Beispiele  fÅr  Ressourcen:  Die  verschiedenen
    Hardware-Gegebenheiten, wie der Arbeitsspeicher (fÅr den die Speicher~
    verwaltung des Betriebssystems zustÑndig ist, um  ihn  fÅr  verschiedene
    Programme  bei  Bedarf  aufzuteilen),  der  Bildschirm,  die  Tastatur,  die
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________


    Schnittstellen, die Tonausgabe usw. Eine  gelÑufigere  Ressource  ist  die
    GEM-Resource,  die  eine  Sammlung  von  GEM-Objekten  (Dialogboxen,
    MenÅzeilen, Texte, Desktop-Symbole usw.) enthÑlt, mit einem "Resource-
    Construction-Program"  erstellt  und  von  den  GEM-Funktionen  des  TOS
    verwaltet werden kann.

RR
    Siehe Literale

Skalare
    Hierzu  zÑhlen  wir  im  Handbuch  alle  ordinalen  Datentypen,  sowie  alle
    Joker-Typen  (LOC,  BYTE,  WORD,  LONGWORD)  und  die  Zeiger-Typen
    (ADDRESS, POINTER TO...).

Shell
    Eine  Anwendung,  von  der  aus  andere  Anwendungen  koordiniert  und
    angesprochen werden kînnen. Beispiele fÅr Shells sind der GEM-Desktop
    und  die  Megamax-Shell.  Es  gibt  auch  Commandline-Shells:  Sie  haben
    dieselbe  Funktion,  ermîglichen  aber  die  Bedienung  generell  nicht  Åber
    GEM-Objekte, wie Symbole, MenÅleisten und Fenster, sondern durch eine
    Art Terminal, in dem die Funktionen und Programmaufrufe durch Eingabe
    von Befehlen in Worten erfolgt.

Source
    Der oder die Source ist der engl. Ausdruck fÅr eine Textdatei, die ein
    Programm, ein Modul oder auch nur einzelne Routinen oder Definitionen
    formuliert.  Sie  wird  im  Deutschen  auch  als  Quelltext  oder  Quelle
    bezeichnet.

SS
    Siehe Literale

Terminal, Console
    So  bezeichnen  wir  GEM-Anwender  die  Kombination  einer  einfachen
    Ausgabeeinheit fÅr Text (ohne Grafik) und  einer  Tastatur  als  Eingabe~
    einheit. Programme, die die Extension "TOS" oder "TTP" haben, laufen in
    solch  einem  Terminal-Modus:  Sie  bieten  keine  GEM-Bedienung,  wie
    Verwendung der Maus und  Anzeige  der  Informationen  in  Fenstern  und
    Symbolen, sondern nur schlichte, blockorientierte Textausgabe.

TOS
    Das TOS ist das Betriebssystem des Atari ST. Es besteht aus aus dem
    grafischen Teil (GEM, das wiederum aus AES und VDI besteht) und dem
    Datei-Verwaltungsteil   (GEMDOS).   Diese   Teile   kînnen   von   anderen
    Programmen ohne weiteres verwendet werden. Dann gibt es noch die sog.
    Treiber, wie Line-A und das BIOS  (inkl.  XBIOS).  Diese  Treiber  dienen
A.10  BegriffserlÑuterungen                                                Anhang
________________________________________________________



    lediglich als Grundfunktionen fÅr GEMDOS und GEM und  sollten  in  der
    Regel  nicht  (vor  allem  gilt  das  fÅr  die  Line-A  Routinen)  von  anderen
    Programmen  verwendet  werden,  weil  sie  auf  spÑteren  Versionen  des
    Betriebssystems  TOS  ggf.  nicht  mehr  in  dieser  Form  vorhanden  sind.
    Dagegen sind die Funktionen von GEM und GEMDOS garantiert auch in
    zukÅnftigen TOS-Versionen verfÅgbar.

Treiber
    Ein Treiber ist eine Funktionseinheit (Modul, Funktionssammlung), die die
    Vermittlung  zwischen  einer  definierten,   portablen   (standardisierten),
    Schnittstelle und der verÑnderlichen Umgebung herstellt. Treiber im TOS,
    wie  das  BIOS,  bieten  den  standardisierten  GEMDOS-Funktionen  (die
    wurden  von  "Digital  Research"  entwickelt  und  sind  auch  fÅr  andere
    Computer  in  derselben  Form  verfÅgbar)  den  Zugriff  auf  die  Atari-
    spezifischen Ressourcen, wie Ein-/Ausgabeeinheiten (Bildschirm, Tastatur,
    Disk) und dem Arbeitsspeicher.

Umgebung
    Die  Umgebung  ist  alles,  was  ein  Programm  auûerhalb  seiner  selbst
    implementierten Algorithmen und Funktionen vorfindet. Diese Umgebung ist
    in der Regel verÑnderbar, wÑhrend das Programm selbst eine festgelegte
    Form hat. So gehîren der freie Speicherplatz, die Ausgabemîglichkeiten
    und Grîûe des Bildschirms, die Åber die Tastatur eingebbaren Zeichen, die
    verfÅgbaren  Massenspeicher  und  auch  das  Betriebssystem  zu  der
    Umgebung jedes Programms. Bei Megamax Modula kann jedes Programm
    Åber Treiber-Module komfortabel auf verschiedene Umgebungen angepaût
    werden, ohne daû das Programm selbst dazu geÑndert werden mÅûte.

Versionskonflikt
    Siehe unter Key.

ZZ
    Siehe Literale
A.10  Lehrseite                                                            Anhang
________________________________________________________


Leerseite
    Eine  Leerseite  ist  in  der  Regel  eine  Seite,  die  leer  ist.  Ausnahmen
    bestÑtigen die Regel.
A.11  Anpassen alter Megamax Modula Programme                       Anhang
________________________________________________________


A.11    Anpassung  alter  Programme


Hier erfahren Sie, wie Sie Ihre alten Modula-Programme, die mit dem System
der  Version  1  (Compiler-Version  3)  auf  das  neue  System  der  Version  2
(Compiler-Version 4) Åbertragen.

Sie sind leider gezwungen, alle Ihre alten Module neu zu Åbersetzen. Machen
Sie  sich  zuvor  mit  der  Bedienung  von  ModRef  (Kap.  2.7)  vertraut,  das
Programm kann Ihnen dabei eine groûe Hilfe sein.

Auf  die  meisten  notwendigen  énderungen  wird  Sie  der  Compiler  selbst
hinweisen. Sie mÅssen dann nur die entsprechenden Korrekturen vornehmen.
Meist mÅssen Sie eine Funktion nun aus einem anderen Modul importieren oder
einen Parameter ergÑnzen.

Schwierig wird es, wenn Sie Funktionen der Megamax-Bibliothek in Assembler
aufgerufen haben und sich dort nun Parameter geÑndert haben. In diesem Fall
kann Ihnen der Compiler nicht helfen - Sie mÅssen die betroffenen Stellen
selbst finden und anpassen.


énderungen am Compiler von Version 3 auf Version 4.

Folgende énderungen werden vom Compiler nicht als Fehler angezeigt, mÅssen
aber angepaût werden, damit die Programme wie bisher laufen:

Bei eingeschaltetem Range-Check ($R+) wird nun ein Laufzeitfehler angezeigt,
wenn bei einer CASE-Anweisung keine der Selektionen zutrifft und auch kein
ELSE-Zweig besteht. Abhilfe: Entweder die Module mit $R- Åbersetzen ("-R"
in der Direktiven-Zeile der Compiler-Box) oder leere ELSE-Zweige einfÅgen.

Ebenso  werden  nun  öber-/UnterlÑufe  bei  INC  und  DEC  bei  $R+  erkannt.
Normalerweise ist das sicher auch erwÅnscht, so daû hierauf kaum geachtet
werden muû.

Die Compiler der Version 3 kannten nur einen Real-Typ (64 Bit) namens REAL.
Dieser heiût nun LONGREAL. Bei alten Programmen sollten Sie deshalb alle
Vorkommen von REAL durch LONGREAL ersetzen. Analog muû auch FLOAT
nach LFLOAT umbenannt werden!

SETs mit mehr als 8 Elementen werden nun anders angeordnet. FÅr Zugriffe
auf  externe  Sets  (Hardware-Bits,  GEM-Sets)  mÅssen  die  Set-Definitionen
entweder angepaût oder mit der Option $U- (s. Compiler-Direktiven) Åbersetzt
werden. Vorsicht auch mit dem Operieren auf diesen Sets in Assembler!
A.11  Anpassen alter Megamax Modula Programme                       Anhang
________________________________________________________


Die  Elemente  von  RECORDs  werden  nun  immer  in  ihrer  Deklarationsfolge
abgelegt, auch wenn sie mit Kommata aufgezÑhlt werden. Die alte, umgekehrte
Reihenfolge kînnen Sie mit der Direktive $T- wiedererlangen.

Die weiteren FÑlle werden vom Compiler erkannt, so  daû  nach  ihnen  nicht
extra gesucht zu werden braucht:

Was frÅher VAL war, heiût nun CAST. Wurde VAL benutzt, muûte es aus
SYSTEM importiert werden. Da VAL nun nicht mehr in SYSTEM ist, wird der
Compiler  den  Import  sofort  bemÑkeln.  Ersetzen  Sie  dann  einfach  alle
Vorkommen von VAL durch CAST. In wenigen FÑllen kann es vorkommen, daû
auch CAST nicht mehr erlaubt ist - informieren Sie sich dann im Kapitel des
Compiler Åber CAST.

Strings ungleicher LÑnge sind nicht mehr zuweisungskompatibel. Benutzen Sie
Assign aus dem Strings-Modul!

Laufvariablen fÅr FOR unterliegen nun einigen EinschrÑnkungen. Mehr dazu im
Kapitel zum Compiler. Abhilfe  lÑût  sich  meist  durch  EinfÅhren  einer  neuen
lokalen Variable leisten.

ASSEMBLER muû nun aus SYSTEM importiert werden.

Das Format der erzeugten Definitions-Codemodule wurde leicht verÑndert: Die
eigene Item-Nr. in der Import-Liste ist nun nur noch zwei statt vier Byte groû.


énderungen in der Bibliothek von Systemversion 1 auf Version 2.

Hinweis: Wenn ein Bezeicher nicht mehr in dem bisherigen Modul vorhanden
ist,  sondern  nun  aus  einem  anderen  Modul  exportiert  wird,  kînnen  Sie
beispielsweise im Gepard-Editor den Cursor auf den Bezeichner bewegen und
dann mit der Taste F6 nach dem Bezeichner in der gesamten Bibliothek suchen
lassen  (allerdings  dÅrfen  die  Åbersetzten  Definitionsmodule  dazu  nicht
komprimiert sein, s. Kap. 2.4).

Diverse Module
 *  FileBase.ErrMsgField  heiût  nun  MOSConfig.FileErrMsg;  ErrBase.MsgField
    heiût nun MOSConfig.RuntimeErrMsg.
 *  Die Funktionen WriteNum, ConvNum und NumToStr erlauben nun am Ende
    die Angabe des FÅll-Zeichens. Zur Anpassung ist hier "0" anzugeben.
 *  ReadReal akzeptiert nun Variablen vom Typ REAL - fÅr LONGREALs ist
    ReadLReal hinzugekommen.

Calls
 *  CallSystem und CallExternal  wurden  entfernt,  statt  dessen  kînnen  nun
    CALLSYS und CALLEXT aus SYSTEM verwendet werden.
A.11  Anpassen alter Megamax Modula Programme                       Anhang
________________________________________________________


Clock
 *  Die Typen Time und Date befinden sich nun im Modul MOSGlobals.

Directory
 *  Der Eintrag path bei DirQueryProc ist nun ein REF-Parameter. Wenn Sie
    DirQuery   benÅtzen,   muû   demnach   die   angegebene   Prozedur   das
    SchlÅsselwort "REF" beim path-Parameter erhalten.
 *  DirQuery liefert nicht mehr den Wert Null, wenn keine passenden Dateien
    gefunden werden, sondern den Wert FÅnf (MOSGlobals.fNoMatchingFiles).
    Wer wie empfohlen Fehler bisher durch den Test auf negative Werte und
    nicht durch Null-Vergleich erkannte, dÅrfte damit keine Probleme haben.
 *  Das   AufzÑhlungselement   writtenAndClosedAttr   wurde   in   archiveAttr
    umbenannt.
 *  Die Typen Drive und DriveSet befinden sich nun im Modul MOSGlobals.
 *  Die Funktionen SplitPath und SplitName sind nun im Modul FileNames.

Excepts
 *  ExcDesc wurde nach MOSGlobals Åbertragen.

GemEnv
 *  Die Funktion SuspendedProcess wurde entfernt, da sie unbrauchbar war.
 *  Die FileSelect-Routine befindet sich nun im Modul PathEnv und hat einen
    zusÑtzlichen String-Parameter title, der ab TOS 1.4 als Text oben in der
    Auswahlbox erscheint. Bei Ñlteren TOS-Versionen erscheint kein Text -
    der Parameter wird ignoriert. Zur einfachen Anpassung setzen Sie hier
    einfach einen Leerstring ein.

Keyboard
 *  Die  Typen  zur  Beschreibung  der  Tastencodes  befinden  sich  nun  in
    MOSGlobals; die Read-Funktionen wurden entfernt (s. KbdCtrl).

KbdCtrl
 *  Das Conterm-Bit muû nun von auûen gesetzt werden, z.B. mit der dortigen
    Funktion ExtendedMode (TRUE).

Loader
 *  Bei CallModule und LoadModule wurden die Parameter verÑndert. Hinzu~
    gekommen ist ein Zeiger auf ein selbstdefiniertes "Environment", der in
    der Regel Null (oder NIL) sein sollte! Weggefallen ist der Parameter fÅr
    die  Stack-Grîûe.  Diese  und  auch  einige  weitere  zum  Hauptprogramm
    gehîrende  Informationen  (z.B.  Treiber-Module)  werden  in  BÑlde  bei
    jeweiligen Programm fest vorbestimmbar sein. Solange diese Mîglichkeit
    noch nicht gegeben ist, wird die Stack-Grîûe durch die Loader-Variable
    "DefaultStackSize" bestimmt.
A.11  Anpassen alter Megamax Modula Programme                       Anhang
________________________________________________________



M2Init
 *  In Systemversion 1 erhielt M2Init in A0 einen Zeiger auf die base page
    Åbergeben - nun geschieht dies nur noch bei Accessories; ist der Wert
    Null, ist es kein Accessory-Start und man erhÑlt den Zeiger auf die base
    page Åber die Adressierung 4(A7). Auûerdem wird nun in A2 der Zeiger
    auf den PDB Åbergeben, dieser lag bisher immer bei einem  konstanten
    Abstand vom Codebeginn aus.

Paths
 *  Die  Definitionen  von  PathList  und  PathEntry  stehen  nun  im  Modul
    PathCtrl.
 *  Die  Funktionen  StdPaths,  SetPaths,  New-  und  PrevStdPaths  wurden
    entfernt, statt dessen muû nun eine eigene Variable fÅr die entsprechende
    Liste deklariert werden.
 *  Der FileSelector fÅr SearchFile wird nun im Modul PathEnv definiert.

SysCtrl
 *  Der  Supervisor-TRAP-Handler  ist  entfernt  worden.  Nur  TRANSFER/
    IOTRANSFER benutzen nun noch einen  TRAP-Vektor.  Dieser  kann  jetzt
    einfacher durch VerÑndern der  Variable  CoroutineTrapNo  in  MOSConfig
    bestimmt werden.

SYSTEM
    IOTRANSFER belÑût die Coroutine im Supervisor-Modus, wenn sie durch
    einen Interrupt (Exception) aktiviert wurde.

TimeConvert
 *  Die Funktion TimeToString hat nun einen optionalen Format-Parameter. Zur
    Anpassung geben Sie einen Leerstring an.

XBIOS
 *  SuperExec hat nun einen PROC- statt ADDRESS-Parameter. Damit entfÑllt
    das lÑstige Typwandeln, wenn eine Modula-Prozedur  darÅber  aufgerufen
    werden soll.
