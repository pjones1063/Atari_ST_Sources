2.1  Bedienung: Los geht's                                                2 -  1
________________________________________________________


2.      Bedienung  des  Systems


Wir haben uns bemÅht, die Verwendung von Fremdwîrtern zu vermeiden oder
diese  mit  öbersetzungen  zu  versehen.  Aber  gerade  im  Computerjargon
kommen viele aus dem Englischen Åbernomme AusdrÅcke vor, die kaum direkt
Åbersetzbar sind oder Einsteigern gar nicht bekannt sein kînnen. Stoûen Sie in
diesem Handbuch auf solche AusdrÅcke, sehen Sie doch einfach nach, ob wir
dazu eine BegriffserlÑuterung im Anhang dieses Buchs  nachgetragen  haben.
Wir haben uns bemÅht, diese AusdrÅcke kursiv hervorzuheben.


2.1    Los  geht's  -
          Installieren  und  Ausprobieren


Voraussetzungen

Wir gehen davon aus, daû Sie vor Ihrem Atari ST-Computer sitzen und neben
diesem  Handbuch  die  mitgelieferten  Disketten  zur  Hand  haben.  (Die  Regi~
strierkarte, die der Lieferung beilag, haben Sie bestimmt schon ausgefÅllt, um
in den Genuû aller Updates und Erweiterungen zu Megamax Modula zu kom~
men?)

Auûerdem sollten Sie einige leere Disketten bereithalten, um Backup- (Sicher~
heits-) und Arbeitskopien anzulegen: 4 doppelseitige Disketten  fÅr  Backups;
zusÑtzlich 2 Disketten fÅr die Zusammenstellung maûgeschneiderter Arbeits~
disketten. (NatÅrlich genÅgt auch etwas Platz auf einer Festplatte...)

Einige Worte zur Konfiguration des Rechners: FÅr ein komfortables Arbeiten
mit Megamax Modula ist eine freie RAM-KapazitÑt von  2  MByte  und  einer
Festplatte wÅnschenswert.

Die Benutzung von Megamax Modula auf einem Atari mit nur 512 KByte RAM
ist nicht mîglich. Voraussetzung dafÅr wÑre eine gegenÅber der mitgelieferten
stark verkleinerte Shell, die kein GEM benutzt.  Eine  solche  Shell  ist  zwar
schnell erstellt, aber wir weisen lieber darauf hin, den Atari auf mindestens
1 MByte aufzurÅsten. In den Fachzeitschriften lassen sich einfach einzubauende
Speichererweiterungen schon fÅr ca. DM 300.- finden.
2.1  Bedienung: Los geht's                                                2 -  2
________________________________________________________


Die Modula-Disketten

Die Aufteilung und Anzahl der mitgelieferten Disketten variiert von Zeit zu Zeit,
so daû wir Ihnen hier nur alle zumindest vorhandenen Dateien und Ordner auf~
zeigen, um Ihnen die öbersicht zu erleichtern. In der Regel werden die Disket~
ten zweiseitig beschrieben - wenn Sie sie nicht in den Computer einlesen kîn~
nen, wenden Sie sich bitte an Ihren HÑndler, damit er Ihnen die Disketten auf
einseitige umkopiert, oder an Application Systems. öber weitere Besonderheiten
und zusÑtzliche Dateien werden Sie in der Datei LIESMICH.TXT informiert, die
sich auf einer der Disketten befindet.

    GEP ED           Ordner, der den Gepard-Editor enthÑlt:
         _
       GEP ED.MOD     Der Gepard-Editor (nur unter der Shell zu starten!)
           _

    GME               Ordner; enthÑlt die Dateien fÅr den Editor "GME"
       GME.MOD         Der Editor
       ...IMP              Zum GME gehîrende Module
       GMEMENUE.RSC  Die GEM-Resource-Datei fÅr den GME

    SRC               Ordner mit Quelltexten. EnthÑlt vier Ordner fÅr:
       D                  Definitions-Texte. Achtung: Sind ggf. erst zu dekom-
                           primieren (siehe HINWEIS-Text auf der Diskette)
       DEMO             Diverse Demonstrationsprogramme
       MOS              Quellen zum Megamax-System, die Sie bei Bedarf
                           selbst modifizieren kînnen (z.B. die Shell)
       UTILITY           Diverse Hilfsprogramme

    SYS               Ordner mit Modulen und anderen Systemdateien:
       IMP                Ordner mit den Åbersetzten Implementations-Modulen
                           (werden beim AusfÅhren vieler Programme unter der
                           Shell benîtigt)
       MOD              Ordner mit Compiler, Linker, Make usw.
       DEF               Ordner mit Åbersetzten Definitions-Modulen (werden
                           vom Compiler beim öbersetzen benîtigt):
         MM2DEF.M2L     EnthÑlt die unverÑnderlichen DEF-Module der Mega-
                             max-Bibliothek in komprimierter Form.
         MM2SHELL.DEF   Ein einzelnes DEF-Modul: Es definiert die Resource-
                             Indices der Shell und kann sich Ñndern, wenn die
                             GEM-Resource modifiziert wird.
       MODULA.ERR      Textdatei mit Fehlermeldungen fÅr den Compiler

    USER              Ordner fÅr Ihre eigenen (Quelltext-) Dateien.
       DEF               Hier kommen Åbersetze Definitions-Module rein
       IMP                Dito fÅr Implementations-Module
       MOD              Dito fÅr Haupt-Module
                        Die Quelltexte sollten auch hier im Ordner USER abgelegt
                        werden.
2.1  Bedienung: Los geht's                                                2 -  3
________________________________________________________


    TMP               Ordner, in dem die Shell interne Dateien zwischenzeitlich
                        ablegt (auch das Make-Programm!).

    TEMPLMON.Vxx   Ordner mit Maschinensprache-Monitor.

    MM2SHELL.PRG   Die Modula-Shell (BedienungsoberflÑche)
    MM2SHELL.RSC   GEM-Resource-Datei fÅr die Shell
    MM2SHELL.RSD   Zusatzdatei zur Resource-Datei
    MM2SHELL.M2P   Parameter-Datei fÅr die Shell
    MM2SHELL.M2B   Batch-Datei - wird beim Shell-Start ausgefÅhrt
    MM2SHELL.HLP   Textdatei mit Hilfestellungen fÅr die Shell-Bedienung

    LIESMICH.TXT     Diese Datei unbedingt lesen! (z.B. nach dem Shell-Start
                        durch einen Doppelklick in den Editor laden)

    NRSC ASH.PRG   Programm zum Bearbeiten von GEM-Resourcen
          _
    NRSC.RSC         Resource-Datei zum Programm
           Das  "Resource  Construction"-Programm  wird  zur  Erstellung  von
           GEM-Menues und anderen GEM-Objekten benîtigt. Mehr dazu finden
           Sie in den Kapiteln 5 und C.2.

    HD INST.PRG     Hiermit  kann  das  Modula-System  bequem  auf  der
       _
                        Festplatte installiert werden.

    DEMO enthÑlt einige Beispielprogramme, die Ihnen vielleicht den Einstieg in
    Megamax Modula erleichtern. In UTILITY finden sich einige Hilfsprogramme,
    die Sie compilieren sollten, um dann die erzeugten Code-Dateien auf ihre
    Arbeitsdisk (Ordner SYSÅMOD) zu kopieren. Sehen Sie sich  alle  diese
    Dateien an, z.B., indem Sie sie in den Editor laden. Sie enthalten alle eine
    Information zu Beginn des Textes.

    Der Ordner MOS ist eher fÅr fortgeschrittene Benutzer interessant: Er
    enthÑlt die Quelltexte einiger Module, die Sie verÑndern kînnen, um die
    Konfiguration der Bibliotheken und der Entwicklungsumgebung (Shell) Ihren
    eigenen WÅnschen anzupassen.

    Besonders hilfreich ist der Ordner D. Er enthÑlt die Definitionstexte, die
    auch  im  Kapitel  B  dieses  Handbuchs  abgedruckt  sind.  Aus  Erfahrung
    wissen wir, daû man oft Funktionen nachschlagen will und es dann beim
    Åblichen Schreibtischchaos recht  unbequem  ist,  im  Handbuch  herumzu~
    blÑttern. Wenn Sie genÅgend Massenspeicher (Festplatte) haben, reicht es
    nun  aus,  im  Editor  ein  neues  Fenster  zu  îffnen  und  den  benîtigten
    Definitionstext hineinzuladen. Der  Gepard-Editor  erlaubt  es  sogar,  nach
    exportierten Bezeichnern zu suchen und dann die entsprechende Definitions-
    Textdatei  anzuzeigen  (mit  der  F6-Taste,  wenn  der  Cursor  auf  dem
    gesuchten Bezeichner steht!).
2.1  Bedienung: Los geht's                                                2 -  4
________________________________________________________


Installieren von Megamax Modula

Auf die Gefahr hin, daû wir Sie langweilen: Haben Sie schon Backup-Kopien
aller gelieferten Disketten gemacht? Die Disketten sind nicht kopiergeschÅtzt.
Es  sollte  also  keine  Schwierigkeiten  bereiten,  Kopien  anzufertigen  und  die
Originale in Sicherheit zu bringen. Vorsicht: Vor dem Kopieren sollten Sie die
Originale schreibschÅtzen (Loch ist offen), um sie bei einer Verwechslung nicht
gleich zu lîschen!

Mit den Kopien in der Hand kînnen Sie sich jetzt Ihre Arbeitsdisketten zusam~
menstellen. Wir beschreiben zwei verschiedene Rechner-Konfigurationen:
* Atari ST mit mindestens 1 MByte RAM, mindestens 720 KByte Diskettenplatz
* Atari ST mit mindestens 1 MByte RAM, Festplatte


Atari ST mit mindestens 1 MByte RAM, mindestens 720 KByte Diskettenplatz

Die gelieferten Disketten sind bereits sinnvoll aufgeteilt. Auf der Disk mit der
Shell   befinden   sich   neben   den   fÅr   die   Shell   notwendigen   Dateien
(MM2SHELL.M2P,  MM2SHELL.M2B,  MM2SHELL.RSC)  auch  die  Module,  die
resident  geladen  werden:  der  Compiler  (im  SYSÅMOD-Ordner)  und  beide
Editoren (Ordner GEP ED bzw. GME). Die andere Diskette enthÑlt dann die
                       _
zum Arbeiten benîtigten Dateien, wie  Definitions-Codes  (MM2DEF.M2L)  und
importierte Module (Ordner SYSÅIMP). Ihre selbst Åbersetzten Dateien werden
im USER-Ordner abgelegt, worin Sie auch Ihre Quelltexte ablegen kînnen.

Sie kînnen also die Shell von der einen Diskette starten; ist sie fertig, kann
die  andere  Disk  eingelegt  werden,  um  dann  eigene  Programme  oder  die
mitgelieferten Programme in den Ordnern DEMO und UTILITY zu Åbersetzen
und zu starten.

Beachten  Sie  aber,  daû  die  Parameter-Datei  der  Shell  auf  der  Boot-Disk
abgelegt ist. Wenn Sie den MenÅpunkt Parameter ...speichern wÑhlen oder die
Parameter beim Verlassen der Shell speichern wollen, mÅssen Sie zuvor die
Boot-Disk einlegen. Es passiert zwar nichts schlimmes, wenn Sie dies nicht
befolgen, allerdings wÅrde beim erneuten Start der Shell von der Boot-Disk
wieder die alte Parameter-Datei geladen werden. Notfalls kînnen Sie die Datei
auch einfach auf die Boot-Disk zurÅckkopieren.

Ein Ñhnliches Disketten-Problem entsteht bei der  Benutzung  des  GME.  Der
Editor benîtigt beim Start seine Resource-Datei GMEMENUE.RSC. Wenn Sie
nur ein Laufwerk haben, mÅssen Sie aufpassen, daû beim Start des Editors
eine Disk mit dieser Datei im Ordner  GME  einliegt.  Wollen  Sie  Texte  von
anderen Disketten vom Laufwerk A: lesen, mÅssen Sie erst den Editor starten
(TastendrÅcke:  Control-P,  Esc,  Return,  Control-E)  und  erst  dann  die  Disk
wechseln und im Editor die gewÅnschte Datei laden.
2.1  Bedienung: Los geht's                                                2 -  5
________________________________________________________


Besser ist es dann schon, zwei Laufwerke zu verwenden - dann braucht auch
die Boot-Disk mit der Shell und ihrer Parameter-Datei nicht entfernt werden,
so daû das vorher beschriebene Problem ebenfalls nicht entsteht. Allerdings
mÅssen dazu erst einige Parameter in der Shell und die Suchpfade geÑndert
werden.

MÅssen aus Platzmangel mal  die  geladenen  Programme  (z.B.  Compiler  und
Editor) entfernt werden, werden sie bei erneuter Benutzung auf der gerade
eingelegten Diskette gesucht. Ggf. mÅssen Sie sich Editor und Compiler dazu
auf die Arbeitsdisk kopieren, damit Sie nicht jedesmal extra die Disk mit der
Shell wieder einlegen mÅssen.

Das Programm HD INST.PRG auf einer der Disketten wird beim Arbeiten nicht
                   _
benîtigt und kann daher von dort entfernt werden, um Platz auf der Disk zu
gewinnen.

Um das Modula-System nach Ihren WÅnschen zu konfigurieren, lesen Sie bitte
Åber die Parameter von Shell, Editor  und  Compiler  sowie  Åber  die  Batch-
Dateien fÅr die Suchpfad-Bestimmung in Kapitel 2.2 nach.

Im  Ordner  MAXIDISK.4MB  finden  Sie  eine  RAM-Disk,  die  sogar  die  darin
gespeicherten Daten komprimieren kann. Sobald Sie mit der  Bedienung  und
Konfiguration  vertraut  sind,  kînnen  Sie  sich  eine  Boot-Disk  erstellen,  die
automatisch die RAM-Disk einrichtet und die von Ihnen benîtigten Definitions~
module sowie die Fehlerdatei MODULA.ERR in die RAM-Disk kopiert. Wenn Sie
dann  die  Suchpfade  entsprechend  einstellen,  kînnen  Sie  das  öbersetzen
erheblich beschleunigen.


Atari ST mit mindestens 1 MByte Speicher und Festplatte

Hier ist alles ganz einfach. Sie brauchen lediglich auf der Festplatte irgendwo
einen Ordner fÅr das  Modula-System  anzulegen  ("MM2"  wÑre  ein  schîner
Name) und dann alle Dateien, so wie sie auf den Disketten angeordnet sind,
                                                          1
hineinzukopieren. Auf der Festplatte sollten dazu ca. 3 /  MB frei sein. Damit
                                                            2
es  auch  dabei  keine  Schwierigkeiten  gibt,  haben  wir  das  Programm
HD INST.PRG  vorbereitet.  Es  braucht  nur  gestartet  zu  werden  und  dann
   _
sollten Sie, wie vom Programm aufgefordert, die vier Disketten nacheinander
einlegen. Dann werden einfach alle Dateien auf die Festplatte kopiert. Weitere
Konfigurationen  brauchen  erstmal  nicht  vorgenommen  werden.  Sie  sollten
spÑter aber noch die Definitions-Module in der Library decomprimieren. Lesen
Sie dazu Kapitel 2.4.

Schon ist alles vorbereitet - die Shell kann nun gestartet werden. Erst, wenn
Sie die Strukturen der Ordner Ñndern wollen, mÅssen Sie die Parameter in
der Shell und die Suchpfade im Batch (MM2SHELL.M2B) anpassen. Doch dazu
sollten Sie erstmal Kapitel 2.2 durchlesen!
2.1  Bedienung: Los geht's                                                2 -  6
________________________________________________________


Speicherplatzmangel?!

Wenn  Sie  nun  die  Shell  starten,  sollten  nach  dem  Laden  von  Compiler
und  Editor  mindestens  noch  200  KB  (ca.  200.000  Byte)  Speicher  frei
sein,  sonst  werden  sich  bald  Compiler,  Editor  oder  Linker  diesbezÅglich
beschweren.  Vor  allem,  wenn  Sie  ein  Fan  von  Accessories  oder  AUTO-
Ordner-Programmen sind und Ihr Rechner nur Åber 1 MB Speicher verfÅgt,
kann es dazu kommen. Den noch freien Speicher kînnen Sie Åber den MenÅ~
punkt Info/Umgebungsinformationen erfahren.

Sie haben bei zu knappem Speicher keine Datenverluste zu befÅrchten! Reicht
der Speicher im Editor nicht mehr, kann immer noch der bisher erzeugte Text
gesichert werden, bei Compiler, Linker und anderen Dienstprogrammen kann
die  Operation  ja  sowieso  wiederholt  werden.  Um  den  freien  Speicher  zu
vergrîûern, haben Sie verschiedene Mîglichkeiten:

* Geben Sie die sonst noch geladenen Programme aus dem Speicher frei (das
  zu startende Programm selbst braucht nicht entfernt werden). Dazu îffnen
  Sie das Resident-Fenster (Taste R) und ziehen die angezeigten Programme
  in den Abfalleimer. Dauerhaft kînnen Sie auf das  Laden  der  Programme
  ganz  verzichten,  indem  Sie  die  Load-Anweisungen  aus  dem  Shell-Batch
  entfernen (siehe Kapitel 2.2).

* Verwenden Sie den Gepard-Editor. Er benîtigt und belegt (als residentes
  Programm)  deutlich  weniger  Speicher  als  der  GME.  Ersetzen  Sie  dann
  die  Anweisung  LOAD  GME  durch  LOAD  GEP ED  in  der  Batch-Datei
                                                      _
  MM2SHELL.M2B. Diese énderung kann mit dem Editor durchgefÅhrt werden.

* Verzichten  Sie  auf  andere  residente  Programme,  wie  Accessories  oder
  AUTO-Ordner-Programme (z.B. Cache).

* Starten Sie den Compiler bzw. den Linker als gelinktes Programm von einer
  anderen Shell aus. Diese Lîsung ist zwar nicht so komfortabel wie mit der
  Megamax-Shell, aber lîst dafÅr auch die grîûten Platzprobleme. Siehe dazu
  die ErlÑuterungen in den Quelltexten von LinkInit und CompInit (LINKINIT.M &
  COMPINIT.M im UTILITY-Ordner).
2.1  Bedienung: Los geht's                                                2 -  7
________________________________________________________


Mehr Geschwindigkeit...

Haben Sie keine Platzprobleme, kînnen Sie Ihr System auf Geschwindigkeit
trimmen. Hier einige Tips:

Wenn Sie eine Festplatte haben, verwenden Sie unbedingt TOS 1.4 (Rainbow-
TOS, enthÑlt u.A. die Zahl 1989 in der Info-Box des Desktops) oder hîher. Die
Ñlteren TOS-Versionen sind sehr, sehr langsam beim Speichern und Laden.
Das TOS 1.4 gibt es bei fast jedem Atari-HÑndler; oder sehen Sie mal in die
Kleinanzeigen der Computerzeitschriften.

Haben Sie TOS 1.4 (oder hîher), verwenden Sie das Cache-Programm von
Atari! Es heiût beispielsweise CACHE90.PRG und gehîrt in den AUTO-Ordner.
GegenÅber den meisten  anderen  Caches  puffert  dieser  nicht  wahllos  jeden
Sektor,  sondern  gezielt  FAT  und  Verzeichnisse.  Da  Megamax  Modula-2
intensiver als jedes andere Programm auf die Verzeichnisse zugreift, macht
sich der Atari-Cache hier besonders gut bemerkbar. Zudem: Da es im Grunde
kein Disk-Treiber ist, sondern lediglich die Puffer des GEMDOS erweitert, ist
es prinzipbedingt jedem anderen Cache Åberlegen.

Wie gesagt, Megamax Modula-2 greift hÑufig auf die Dateiverzeichnisse zu, um
Modulcodes  und  -definitionen  zu  laden.  Deshalb  sollten  die  am  hÑufigsten
benîtigten Dateien mîglichst schnell gefunden werden. Dazu sollten  Sie  die
Suchpfade entsprechend ordnen: Am Besten wÑre es, wenn sich alle Dateien
im jeweils ersten Suchpfad befÑnden.

Sie sollten die  Definitionsdateien  in  der  Bibliothek  MM2DEF.M2L  entpacken.
Mehr dazu im Kapitel 2.4.

öberhaupt  genieût  die  Bibliotheksdatei  einen  Sonderstatus:  Beim  Start  des
Compilers  wird  sie  einmal  geîffnet,  das  gesamte  Verzeichnis  wird  in  den
Speicher  geladen.  Die  darin  befindlichen  Dateien  werden  am  Schnellsten
gefunden.  Sie  kînnen  Ihre  eigenen  Definitionsmodule  auch  in  diese  Datei
einfÅgen (mit dem LibManager, s. Kap. 2.4).

Benutzen  Sie  Turbo  ST  oder  Quick  ST.  Dies  sind  Programme,  die  die
GEM-Bildschirmausgaben um ein Vielfaches beschleunigen. Wir empfehlen Ihnen
Quick  ST,  das  auch  Erweiterungen  wie  Hyperscreen/Overscan  und  GDOS
unterstÅtzt. Sie erhalten Quick ST gegen Einsendung eines Schecks Åber 25
US Dollar bei folgender Adresse:

        Branch Always Software
        14150 N.E. 20th St. #302
        Bellevue
        WA 98007
        USA
2.1  Bedienung: Los geht's                                                2 -  8
________________________________________________________


Namenskonventionen

Falls Sie schon mit anderen Modula-2-Systemen gearbeitet haben, wollen wir
Sie gleich darauf hinweisen, daû wir  andere  Endungen  bei  den  Dateinamen
verwenden. Die Quelltexte haben alle nur einen Buchstaben als Endung, und
zwar M fÅr Haupt-, I fÅr Implementations- und D fÅr Definitionsmodule. Die
entsprechenden Code-Dateien haben  MOD,  IMP  bzw.  DEF  als  Endung.  Der
Name der Code-Datei wird nicht aus dem der Quelldatei gebildet, sondern aus
den ersten acht Buchstaben des Modulnamens, der im Quelltext steht.

Wenn Sie gerne andere Endungen verwenden wollen, brauchen Sie lediglich die
Variablen im Quelltext der Shell (MM2SHELL.M) zu Ñndern (suchen Sie dort
nach den z.Zt. verwendeten Endungen), Åbersetzen und die Shell neu zu linken
(siehe dazu Kapitel 2.6). NatÅrlich mÅssen Sie auch noch die Endungen der
mitgelieferten Dateien alle Ñndern, auch die in der Library (MM2DEF.M2L).


Mathe-Koprozessor (FPU, SFP004, Atari TT)

WÑhrend der Atari TT serienmÑûig Åber eine FPU verfÅgt, kînnen Sie sie beim
Atari ST/STE nachrÅsten (z.B. SFP004 von Atari). Beim ST wird in der Regel
ein 68881, beim TT ein 68882 eingesetzt. Beide sind weitgehend identisch, so
daû wir beim Prozessortyp keine Unterschiede machen brauchen.

Allerdings wird eine FPU im ST anders angesteuert als im TT. Aus GrÅnden,
die im Kapitel Åber den Compiler (Kap. 3.4,  F-Direktive)  weiter  ausgefÅhrt
werden, mÅssen Sie die Shell bzw. alle gelinkten Programme mit den dafÅr
angepaûten FPU-Modulen binden, um die FPU auch nutzen zu kînnen. Dazu
verwenden Sie je nach Rechnertyp die Module aus den Ordnern ST FPU bzw.
                                                                       _
TT FPU.
   _

Das einfachste ist, die Module aus einem der Ordner in den IMP-Ordner zu
kopieren.  Dabei  werden  allerdings  die  "normalen"  Module,  die  keine  FPU
benutzen, Åberschrieben. Wenn Sie schon mit  der  énderung  der  Pfadlisten
vertraut sind, tragen Sie besser den passenden FPU-Ordner als jeweils ersten
Suchpfad bei DefaultPath und ImpPath ein. Dann werden die Dateien dieses
Ordners bevorzugt verwendet.

Linken  Sie  dann  die  Shell  neu,  damit  Programmodule,  die  unter  der  Shell
Åbersetzt und per Loadtime-Linking  gestartet  werden,  auch  gleich  die  FPU
mitbenutzen kînnen. Wie Sie die Shell linken, erfahren Sie in Kapitel 2.6; oder
starten Sie einfach den Batch LINKSHEL.M2B.

Mit den FPU-Modulen gelinkte Programme kînnen Sie nicht auf Rechnern ohne
die entsprechende Hardware einsetzen! Sie werden dann eine Fehlermeldung
erhalten.
2.1  Bedienung: Los geht's                                                2 -  9
________________________________________________________


Ein erstes Programm

Um Megamax Modula richtig nutzen zu kînnen, sollten Sie als nÑchstes die
Kapitel 2.2 (Shell), 2.3 (Editor) und 2.4 (Compiler) lesen. Bevor Sie grîûere
Programme schreiben, verdient auch Kapitel 3 Ihre Aufmerksamkeit. Aber viel~
leicht sind Sie im  Moment  einfach  neugierig,  ob  Ihr  neues  Modula-System
Åberhaupt funktioniert? Dann tun Sie doch erstmal folgendes...

Shell starten

Bereiten  Sie  den  Atari  vor,  wie
oben fÅr Ihre Rechner-Konfiguration
beschrieben, und legen Sie ggf. die
Diskette  mit   MM2SHELL.PRG   in
Laufwerk   A   ein.   Starten   Sie
MM2SHELL.PRG     durch     einen
Doppelklick.  Nach  einiger  Zeit  er~
scheint eine ArbeitsflÑche, die dem
GEM-Desktop Ñhnelt:

Programm eingeben

Auf der ArbeitsflÑche finden Sie unter anderem eine Box Aktuelle Datei. Im
Namensfeld sollte hinter TEXT kein Name stehen. Um dies ggf. zu erreichen,
kînnen  Sie  das  Feld  doppelt  anklicken  oder  Control-P  drÅcken.  Daraufhin
kînnen Sie dann einen Text eingeben - drÅcken Sie Esc und dann Return als
BestÑtigung. Dann ist das Feld der Aktuellen Datei leer.

Nun soll der Editor gestartet werden. Dazu halten Sie entweder
die  rechte  Maustaste  gedrÅckt,  wÑhrend  mit  der  linken  das
Editieren-Symbol  doppelt  angelickt  wird,  oder  Sie  drÅcken
Control-E. Damit wird die - leere - aktuelle Datei bearbeitet.

Geben Sie nun das folgende Programm im Editor ein - bitte mit korrekter
Groû- und Kleinschreibung!
2.1  Bedienung: Los geht's                                                2 - 10
________________________________________________________



Programm sichern

Wenn     das     komplette
Programm   eingegeben   ist,
fahren Sie mit der Maus den
MenÅpunkt  Datei  an,  und
wÑhlen  Sie  den  Unterpunkt
Sichern  oder  Sichern  als.
Damit  wird  die  Datei  im
Speicher wieder zurÅck auf
Disk geschrieben.


                                             Da  dem  Editor  aber  bisher  noch
                                             kein  Name  fÅr  die  Datei  bekannt
                                             war,  fragt  er  zuerst  danach.  Es
                                             erscheint  der  GEM-Datei-Selektor,
                                             in  dem  nun  ein  Name  fÅr  den
                                             Programmtext     anzugeben     ist.
                                             Nehmen   wir   ERSTESPR.M   und
                                             speichern es im Ordner USER.






Nun kann der Editor verlassen werden. Dazu ist
entweder Alternate-X zu drÅcken oder im MenÅ
Beenden anzuwÑhlen.




Programm Åbersetzen

Damit  von  nun  an  in  der  Shell
das Ansprechen der Datei einfacher
wird,  machen  wir  das  Modul  zur
Arbeitsdatei, indem N gedrÅckt oder
der  entsprechende  MenÅpunkt  in
der Shell angewÑhlt wird.

Nun ist ein kleines Feld auf dem Desktop der Shell erschienen. Darin soll der
Name der Textdatei eingetragen werden. Dies kann manuell durch die Taste P
oder durch einen Doppelklick auf das Feld vorgenommen werden.
2.1  Bedienung: Los geht's                                                2 - 11
________________________________________________________


Bequemer ist es allerdings erstmal,
wenn  Sie  das  Verzeichnis  vom
Laufwerk  mit  der  Datei   îffnen
(Doppelklick  auf  das  Disk-Symbol)
und  dann  die  Datei,  wie   beim
Kopieren, auf das Feld ziehen.

Nun genÅgt ein Doppelklick auf das AusfÅhren-Symbol oder ein
Druck auf die Taste A, um das Programm zu Åbersetzen und
dann zu starten (natÅrlich kann das öbersetzen auch erst durch
einen  separaten  Compiler-Aufruf  erreicht  werden).  Der  Compiler  wird
gestartet und zeigt in etwa folgendes Bild:










Nehmen wir aber  vorsichtshalber  an,  daû  das  Programm  nicht  auf  Anhieb
fehlerfrei ist. In diesem Fall wird der Editor automatisch aufgerufen und zeigt
Ihnen mit dem Cursor die Fehlerposition an. Auûerdem ist oben in invertierter
Schrift die Fehlermeldung des Compilers zu sehen. Korrigieren Sie den Text,
und  gehen  Sie  dann  erstmal  wieder  vor,  wie  schon  beschrieben  (Text
speichern, Editor verlassen, Programm ausfÅhren/Åbersetzen).

Zur AusfÅhrung des Programms ist eigentlich nicht viel zu sagen:  Daû  die
Ausgaben in ein Fenster geschrieben werden, haben Sie schon selbst bemerkt.
Vielleicht haben Sie auch schon ausprobiert, daû das Fenster vergrîûert und
verschoben werden kann, wie Sie das so kennen? Die Standardausgaben (Åber
das Modul InOut) fÅhren immer auf dieses Standard-Fenster, solange Sie un~
ter der Shell arbeiten (und nicht TOSIO extra importieren). ZusÑtzlich steht
ein Window-Modul zur VerfÅgung, mit dem Sie auch mehrere Fenster beliebi~
ger Grîûen handhaben kînnen. (Auûerdem gibt's ein Terminal-Modul, das ohne
Fenster arbeitet.)
2.1  Bedienung: Los geht's                                                2 - 12
________________________________________________________


Nun wollen wir das Programm erweitern. Wir befinden uns in
der Shell. Dort aktivieren Sie erneut den Editor. Das geht nun
entweder durch Doppelklick auf das Editieren-Symbol oder die
Taste E.

ZurÅck im Editor, Ñndern Sie die WriteString-Anweisungen:



Nun soll erneut Åbersetzt werden. Dies kînnte mit dem MenÅpunkt Ende &
Comp veranlaût werden: Der Editor speichert den Text automatisch, und der
Compiler beginnt mit der öbersetzung. Aber es geht auch noch schneller: Der
Editor erlaubt  es,  den  Compiler  zu  starten,  ohne  den
Text zu speichern und den Editor zu verlassen. Allerdings
wird  dann  auch  mehr  Speicherplatz  benîtigt.  Diese
Funktion  wird  im  MenÅ  durch  Compilieren  oder  durch
DrÅcken von Alternate-D aktiviert. Wenn allerdings der
Speicher  zum  öbersetzen  nicht  ausreicht,  meldet  der  Compiler  einen
entsprechenden  Fehler  und  Sie  mÅssen  mit  der  Funktion  Ende  &  Comp.
vorliebnehmen.

Nun wird der Compiler aber einen Fehler melden: Der Cursor steht auf dem
Wort Space, und die Meldung oben weist darauf hin, daû dieser Bezeichner
unbekannt ist. Er muû natÅrlich erst importiert werden. Dazu fÅgen Sie hinter
dem InOut-Import noch folgende Zeile ein:



Wenn Sie wieder den Compiler starten, sollte er diesmal alles ohne Fehler
Åbersetzen. Verlassen Sie diesmal den Editor mit dem Befehl Ende & Ausf.
(Tastenbefehl:  Alternate-A).  Der  Text  wird  automatisch  gespeichert,  der
Compiler Åbersetzt das Programm (wenn Sie das nicht schon vorher im Editor
getan haben), und dann wird das Programm ausgefÅhrt.

Wenn Ihr Spieltrieb noch nicht erschîpft ist, kînnen Sie ja mal einen Lauf~
zeitfehler im Programm erzwingen (beispielsweise durch eine Division  durch
Null) - was dann passiert, kînnen Sie im Kapitel 2.5 nachlesen.

Spaûeshalber kînnen Sie auch mal das Make (s. Kapitel 2.7) ausprobieren:
Aktivieren Sie im Tools-MenÅ der Shell das Programm ModRef, oder drÅcken
Sie dazu die Taste F1. In der dann erscheinenden Selektor-Box wÑhlen Sie ein
Programmodul aus, z.B. das neu erstellte ERSTESPR.M oder auch eines aus
dem DEMO- oder UTILITY-Ordner. Das Programm wird dann nach kurzer Zeit
wieder die Selektor-Box zeigen, worauf Sie entweder  noch  weitere  Module
auswÑhlen oder das Programm durch Klick auf den Abbruch-Knopf beenden. Es
wurde nun eine Datei mit der Endung M2M in dem Verzeichnis erzeugt, wo Sie
das erste Modul ausgewÑhlt haben.
2.1  Bedienung: Los geht's                                                2 - 13
________________________________________________________


Suchen Sie die Datei mit der Endung M2M im Inhaltsverzeichnis, und ziehen
Sie  sie  dann  auf  das  AusfÅhren-Symbol.  Erst  wird  das  Make-Programm
gestartet,  dann  werden  alle  Module,  die  Sie  vorher  ausgewÑhlt  hatten,
Åbersetzt und daraufhin das erste Hauptmodul gestartet. Wiederholen Sie dies,
wird  das  Modul  gestartet,  ohne  erneut  Åbersetzt  zu  werden  -  das  Make
erkennt, daû die Module bereits Åbersetzt sind.

Allerdings hat die Anwendung des Make hier noch keinen groûen Sinn - bei
einzeln zum AusfÅhren gebrachten Dateien funktioniert diese  Erkennung,  ob
das Modul schon Åbersetzt ist, sowieso schon direkt von der Shell aus ohne
Verwendung des Make. Und alle Module, die importiert werden, sind Bestand~
teile des Megamax-Systems und deshalb auch schon Åbersetzt. Erst, wenn
mehrere eigene Module importiert werden, lohnt es sich, das Make intensiver
zu nutzen. Mehr dazu in Kapitel 2.7.

Noch ein Tip zum Starten von Programmen, deren Namen Sie zwar wissen
aber  sie  nicht  erst  umstÑndlich  suchen  wollen,  vielleicht  sogar  erst  noch
Åbersetzen mÅssen. Wenn wir Ihnen hier erzÑhlen, Sie sollen beispielsweise
das  Programm  TEXTDEMO  starten,  kînnen  Sie  davon  ausgehen,  daû  sich
dessen Quelltext in dem Ordner DEMO oder UTILITY befindet. So kînnen Sie
nun eine Arbeitsdatei wÑhlen (Taste N) und dort den Quelltextnamen (ohne den
Ordnernamen) eingeben (Taste P). Dieser wird in der Regel aus den ersten
acht Buchstaben des Modulnamens und  der  Endung  ".M"  bei  Hauptmodulen
gebildet. Bei unserem Beispiel also TEXTDEMO.M. Nun drÅcken Sie einfach die
Taste A oder machen einen Doppelklick aus das AusfÅhren-Symbol. Dann wird,
falls das Modul noch nicht Åbersetzt wurde, der Compiler automatisch aktiviert,
daraufhin wird das Programm gestartet.
2.1  Bedienung: Los geht's                                                2 - 14
________________________________________________________

















                               Diese Seite ist leer

























          Trifft dies nicht zu, gehen Sie bitte wie folgt vor:
          Beschaffen Sie ein Blatt Papier (DIN A5). PrÅfen Sie, ob das Blatt leer, d.h., frei von
          Buchstaben, ist. Lochen Sie das Blatt mittig. Ein BÅrolocher leistet hierbei gute Dienste.
          Heften Sie das von Ihnen erzeugte Blatt auf diese Seite. Sie muû vollstÑndig verdeckt
          werden. Danke.
          VersÑumen Sie nicht, diesen Hinweis auf dieser Seite nachzutragen, damit die Betriebssicherheit
          Ihres Handbuchs auch weiterhin gewÑhrleistet bleibt.
2.2  Bedienung: Shell                                                     2 - 15
________________________________________________________


2.2    Shell

öber die Modula-Shell steuern Sie die einzelnen  Komponenten  des  Modula-
Systems: Editor, Compiler, Linker... Die Shell unterstÅtzt Sie dabei nicht nur
durch die GEM-BenutzeroberflÑche, sondern erledigt vieles auch automatisch
fÅr Sie - etwa den Aufruf des Editors nach öbersetzungsfehlern oder das
"heimliche" Linken (Binden) eines Moduls vor der AusfÅhrung.


Aufruf der Shell

Wir gehen davon aus, daû Sie sich eine Arbeitsdiskette zusammengestellt ha~
ben  (siehe  Kapitel  2.1).  Wenn  Sie  alle  dort  beschriebenen  Vorbereitungen
getroffen haben, klicken Sie die Modula-Shell MM2SHELL.PRG doppelt an. Das
Laden der Shell kann - je nach Konfiguration - eine Weile dauern, falls weitere
Module resident geladen werden (siehe 2.1). Wenn die Shell betriebsbereit ist,
meldet sie sich mit einer MenÅzeile und einem neuen Desktop. Es ist zu beach~
ten,  daû  sich  im  Verzeichnis  der  Shell  zumindest  immer  die  Dateien
MM2SHELL.RSC und MM2SHELL.M2P befinden.


Das Shell-Desktop

Das  Monitor~
bild,  das  die
Shell     Ihnen
zeigt, erinnert
Sie      wahr~
scheinlich  ein
wenig  an  das
GEM-Desktop:
Am     oberen
Rand des Bild~
schirms   gibt
es eine MenÅ~
zeile; darunter
eine  Arbeits~
flÑche, auf der  allerlei  GerÑte  'herumstehen'.  Verschaffen  wir  uns  erstmal
einen öberblick Åber das Inventar:

Die Diskettensymbole erfÅllen eine Funktion, die Sie schon vom
GEM kennen - sie reprÑsentieren die Massenspeicher, also Dis~
ketten, Festplatte oder RAM-Disk. Wenn Sie einen Kasten dop~
pelt anklicken, wird das Inhaltsverzeichnis in einem Fenster angezeigt. Die Na~
men der Symbole werden Åbrigens von denen des GEM-Desktops Åbernommen.
2.2  Bedienung: Shell                                                     2 - 16
________________________________________________________



Ebenso  vertraut  sollte  Ihnen  der  Abfalleimer  sein.  Wie  beim
GEM-Desktop kann auch hier alles Mîgliche hineingeworfen wer~
den.

Einige Unterschiede zum Desktop gibt es aber doch. Die Inhaltsverzeichnisse
kînnen nur als Text dargestellt werden und nicht auch als Symbole (Icons).
Auch eine Sortierung nach Datum, Grîûe oder Extension ist z. Zt. nicht mîg~
lich (aber wenn Sie wollen, kînnen Sie das selbst Ñndern - doch dazu mehr im
Kapitel FÅnf). Einzelne Dateien lassen sich wie gewohnt selektieren (einfach
anklicken) oder als Objekte auf andere schieben. Die Erweiterung der Selektion
geschieht, wie Åblich, durch Festhalten der Shift-Taste beim Anklicken. Auf
dem GEM-Desktop ist es auûerdem mîglich, mehrere Dateien auf einmal zu
selektieren,  indem  neben  die  Datei-Symbole  bzw.  -Namen  gezeigt  und  mit
festgehaltener Maustaste ein Gummiband um die gewÅnschten Dateien gezogen
wird. In der Modula-Shell kann nicht neben die Namen geklickt werden - statt
dessen wird diese Multi-Selektion durch Festhalten der Control-Taste erreicht.

Wird eine einzelne Datei selektiert, erscheint ihr Name
Åbrigens auch in der Anzeigebox fÅr die aktuelle Datei.
Je nachdem, ob es eine ausfÅhrbare Datei ist (Program~
me, Module, Make-, Batch- und Parameter-Dateien) oder nicht, wird sie als
CODE oder TEXT eingetragen. Die aktuelle Datei spielt bei der Aktivierung der
Shell-Funktionen Åber Tastaturkommandos eine Rolle. Sie kann auch manuell
bestimmt werden durch Control-P oder einen Doppelklick auf das Anzeigefeld.

Teilweise wird die aktuelle  Datei  auch  durch  andere  Shell-Operationen  neu
definiert. Beispielsweise wird nach der Compilierung eines Moduls der erzeugte
Code zur aktuellen Code-Datei, so daû sich dann, ohne langes Suchen in den
Disk-Verzeichnissen nach der Datei, das Modul bequem durch Control-A oder
einen Doppelklick auf das AusfÅhren-Symbol bei gleichzeitigem Festhalten der
rechten Maus-Taste starten lÑût.

Hinter dem Resident-Symbol verbirgt sich der Zugriff auf  die
residenten und geladenen Module in der Shell. Durch das ôffnen
(Doppelklick) erhÑlt man ein Fenster, das die z. Zt. geladenen
Module und Programme zeigt - es sind Kopien der ausfÅhrbaren Code-Dateien,
die von Disk geladen wurden, um schneller verfÅgbar zu sein. Genauso wie die
Dateien  der  Disk-Inhaltsverzeichnisse  kînnen  die  geladenen  Module  durch
Ziehen in den Abfalleimer aus dem Speicher (der Shell) entfernt werden oder
umgekehrt  Code-Dateien  aus  Disk-Fenstern  auf  das  Resident-Symbol  oder
dessen Fenster gezogen werden, um sie neu zu laden. Das Resident-Fenster
kann auch durch DrÅcken der Taste R geîffnet werden.
2.2  Bedienung: Shell                                                     2 - 17
________________________________________________________


Durch  Festhalten  der  Alternate-Taste  beim  ôffnen  des  Resident-Fensters
werden - statt nur der dazugeladenen - alle Module, die zum dem Zeitpunkt
geladen oder resident in der Shell eingelinkt sind, angezeigt - diese residenten
Module kînnen jedoch nicht entfernt werden (das erreichen Sie nur, indem Sie
die Shell, in welche sie alle fest eingebunden sind, verlassen).

Auf das Linken gehen wir in Kapitel 2.6 intensiver ein - hier nur
als Information, daû damit das Linker-Programm gestartet wird,
welches ein Modul so vorbereitet, daû es danach auch auûerhalb
der Modula-Shell ausgefÅhrt werden kann. Ein Doppelklick oder Druck auf die
Taste L bewirkt das Linken der aktuellen Arbeitsdatei.

Bleibt noch das Scannen-Symbol, das zur Suche nach Laufzeit~
fehlern dient. NÑheres dazu in Kapitel 2.5. Um den Scanner fÅr
die Arbeitsdatei zu starten, kann ein Doppelklick darauf erfolgen
oder die Taste S gedrÅckt werden.  Nach  einem  erfolgten  Laufzeitfehler  in
einem Programm  kann  der  dabei  gefÅhrte  Fehler-Dialog  durch  zusÑtzliches
Festhalten der Shift-Taste nochmal aktiviert werden.

Schlieûlich finden Sie auf dem Bildschirm die Symbole Editieren, Compilieren
und AusfÅhren, deren Bedeutung Sie bereits im Kapitel "Ein erstes Programm"
erfahren haben. Auch sie werden  durch ihre Anfangsbuchstaben E, C und A
Åber die Tastatur oder durch Doppelklick aktiviert, um die betreffende Opera~
tion mit der aktiven Arbeitsdatei auszulîsen.

Die Arbeitsdateien sind ein bequemes Mittel, um abwech~
selnd verschiedene Module zu bearbeiten. Es kînnen bis
zu  zehn  von  ihnen  in  der  Shell  angesprochen  werden.  Die  Arbeitsdateien
werden in kleinen Feldern angezeigt, die durch Anklicken oder durch DrÅcken
der zugehîrigen Tastenziffer angewÑhlt werden kînnen.

Ist  eine  Arbeitsdatei  selektiert  (die  Ziffer  des  Feldes  ist  zur  Kontrolle
invertiert),  kann  ein  bequemer  Doppelklick  auf  die  Symbole  Editieren,
Compilieren, AusfÅhren, Linken oder Scannen, oder der Druck auf einen der
entsprechenden Anfangsbuchstaben, die gewÅnschte  Operation  bezÅglich  der
Arbeitsdatei  auslîsen.   Dieselben   Funktionen   kînnen   durch   zusÑtzliches
Festhalten der Control-Taste oder der rechten Maus-Taste statt dessen auf
die aktuelle Datei angewandt werden.

NatÅrlich muû eine Datei nicht erst zur aktuellen oder Arbeitsdatei ernannt
werden, um sie beispielsweise in den Editor zu laden. Wie beim Kopieren von
Dateien kînnen die EintrÑge aus den Fenstern auch direkt auf die Symbole
gezogen werden.

Ein  Doppelklick  auf  Dateien  ist  auch  mîglich:  Je  nach  Art  der  Datei
- ausfÅhrbar oder nicht  -  wird  sie  gestartet  oder  in  den  Editor  geladen.
Dateien ohne Extension werden dabei wie Code-Dateien behandelt.
2.2  Bedienung: Shell                                                     2 - 18
________________________________________________________



Zu  Beginn  sind  noch  keine  Arbeitsdatei-
Felder auf dem Desktop vorhanden. Diese
mÅssen erst durch DrÅcken der Taste N
oder  AnwÑhlen   des   MenÅpunkts   neue
Arbeitsdatei erzeugt werden. Entsprechend
kînnen  sie  mit  lîsche  Arbeitsdatei  oder
der Taste Delete wieder entfernt werden.

Ein Modul wird alsdann als Arbeitsdatei bestimmt, indem entweder eine Quell~
textdatei auf ein solches Arbeitsfeld gezogen oder nach DrÅcken der Taste P
ihr Name manuell eingegeben wird.

Die  restlichen  Funktionen  des  Datei-MenÅs  entsprechen  denen  des  GEM-
Desktops,  die  jeweils  rechts  aufgefÅhrten  Tastencodes  dokumentieren  eine
optionale Anwahl Åber die Tastatur.

öbrigens  kînnen  alle  Objekte  einschlieûlich  der  Arbeitsdateifelder  auf  dem
Shell-Desktop beliebig positioniert werden, beim Verlassen der Shell werden
dann - auf Wunsch - alle Einstellungen gesichert.


AusfÅhren von Programmen und anderen Dateien

Zum AusfÅhren einer Datei ziehen Sie beispielsweise den Eintrag aus dem Datei~
verzeichnis auf das AusfÅhren-Symbol. Auf diese Weise kînnen Sie sowohl
Åbersetzte Module ausfÅhren, die dann automatisch mit den benîtigten Impor~
ten gebunden werden, als auch komplett gebundene (gelinkte) Programme. Eine
andere Mîglichkeit, Dateien zu starten, besteht darin, einen Doppelklick auf
den Eintrag im Fenster durchzufÅhren.

Es ist auch mîglich, Quelltextdateien zum AusfÅhren zu bringen - in diesem
Fall wird erst nach dem vermutlichen Code-Dateinamen gesucht (dieser wird
aus  dem  Quelltext-Namen  und  den  mîglichen  Endungen  der  Code-Module
gebildet); wird er gefunden und ist das Datum der Code-Datei jÅnger als das
der Quelltextdatei, wird die Code-Datei sofort ausgefÅhrt, ansonsten wird vor~
her der Quelltext automatisch Åbersetzt. Dies funktioniert auch bei der aktiven
Arbeitsdatei (die ja immer ein Quelltext sein muû), indem ein Doppelklick auf
das AusfÅhren-Symbol getÑtigt oder die Taste A gedrÅckt wird. Voraussetzung
fÅr die FunktionalitÑt dieses Mechanismus ist eine allzeit korrekt eingestellte
Systemzeit im Computer. Wie dies erreicht wird, erfahren Sie im Kapitel 2.7
bei der Anwendung des Make.
2.2  Bedienung: Shell                                                     2 - 19
________________________________________________________


Neben echten Code-Dateien und deren Quelltexten kînnen auûerdem Make-,
Batch- und Parameter-Dateien "ausgefÅhrt" werden:

* Wird eine Make-Datei (Endung M2M) ausgefÅhrt, startet die Shell das Make-
  Programm, welches dann prÅft, ob Module, die in der Make-Datei aufge~
  fÅhrt sind, neu Åbersetzt werden mÅssen (siehe Kapitel 2.7). Ist dies der
  Fall, startet die Shell daraufhin den Compiler,  der  dann  alle  notwendigen
  Module Åbersetzt - es sei denn, es tritt ein Fehler  auf:  Dann  wird  der
  Vorgang abgebrochen, der Fehler im Editor angezeigt, und der Make-Vorgang
  muû nach der Korrektur wiederholt werden.

* Eine Batch-Datei (Endung M2B) enthÑlt eine Reihe von Anweisungen, die mit
  einem Texteditor erstellt werden kînnen. Mit ihr kînnen die Suchpfade fÅr
  Compiler, Editor und Programme sowie die EintrÑge des Tool-MenÅs bestimmt
  und andere Programme  (auch  Compiler,  Linker,  Make)  gestartet  werden.
  NÑheres weiter unten.

* Eine Parameter- oder Projekt-Datei hat die Endung M2P und enthÑlt die Ein~
  stellungen der Shell, wie Arbeitsdateien,  Fensterpositionen,  Parameter  fÅr
  Editor, Shell, Compiler usw. Diese Dateien werden von der Shell durch das
  Sichern  der  Einstellungen  erzeugt.  Wird  eine  solche  Datei  "ausgefÅhrt",
  werden alle darin enthaltenen Einstellungen von der Shell Åbernommen.

Diese Art des AusfÅhrens von Quelltexten, Make-, Batch- und Parameterdateien
ist  auch  bei  den  im  Tools-MenÅ  eingetragenen  Funktionen  mîglich:  Wird
beispielsweise  eine  Datei  DEMO.M2M  als  Tool  eingetragen,  wird  bei  ihrer
Aktivierung Åber das Tools-MenÅ der Make-Vorgang eingeleitet, so, als wenn
die Datei auf das AusfÅhren-Symbol gezogen oder doppelt angeklickt worden
wÑre.


AusfÅhren speziell von Code-Dateien

Vom GEM-Desktop her ist Ihnen bekannt, daû Dateien mit den Endungen APP,
PRG, TOS und TTP ausfÅhrbar sind. Diese Programme sind mit anderen Ent~
wicklungssystemen (natÅrlich auch mit Megamax Modula-2) erstellt worden und
haben alle ein einheitliches Dateiformat, das vom Betriebssystem (GEMDOS)
verstanden wird, und somit kînnen sie vom Desktop oder auch von anderen
BenutzeroberflÑchen (Shells) aus bequem gestartet werden. Diese Programme
haben alle erforderlichen Routinen fest eingebunden und definieren beispiels~
weise auch ihren eigenen Stack-Bereich.

Vom  Modula-Compiler  Åbersetzte  Module  sind  dagegen  noch  nicht  gelinkt
(gebunden), so daû sie auch nicht ohne weiteres vom GEM-Desktop oder einer
anderen Shell gestartet werden kînnen, weil sie in der Regel dieses fremde
Format nicht kennen. Deshalb verdienen diese Code-Module  auch  keine  der
bekannten  Programm-Endungen.  AusfÅhrbar  sind  die  Åbersetzten  Module
2.2  Bedienung: Shell                                                     2 - 20
________________________________________________________


(natÅrlich nur die Haupt- und Implementations-, jedoch nicht die Definitionsmo~
dule) unter der Shell aber trotzdem, dank des sogenannten Loaders, welcher
ein in der Shell eingebundenes Modul darstellt, das eine dynamische Bindung
der benîtigten Module und andere Vorbereitungen, beispielsweise das Anlegen
eines Stacks, automatisch durchfÅhrt.

Die Åbersetzen Code-Module kînnen, entsprechend den gelinkten Programmen,
die Endungen MOD (analog zu APP und PRG), MOS (TOS) oder MTP (TTP)
tragen.  Wird  also  eine  Datei  mit  einer  dieser  Endungen  unter  der  Shell
ausgefÅhrt, wird sie wie die gelinkten Programme unter dem  GEM-Desktop
behandelt: Bei MOS-Dateien wird der TOS-Modus (weiûer Hintergrund, Maus
aus, Blinke-Cursor an) aktiviert, bei MTP-Dateien wird zusÑtzlich nach einer
Kommandozeile  (Argumentzeile)   fÅr   das   Programm   gefragt.   Wird   ein
Code-Modul an den Linker zum Binden Åbergeben, erzeugt dieser passend zur
Endung  den  entsprechenden  Programmnamen  (Bsp:  "TEST.MOS"  wird  zu
"TEST.TOS").

Falls Ihnen Åbrigens andere Endungen besser vertraut sind (OBJ, OBM, SYM,
usw.),  kînnen  Sie  in  Kapitel  FÅnf  nachlesen,  wie  einfach  Sie  dies  dem
Megamax-System beibringen kînnen.

Der Linker kennt noch eine weitere Endung: Aus MAC  erzeugt  er  gelinkte
Dateien der Endung ACC; dies ist vorteilhaft, wenn Sie Accessories erzeugen
wollen - diese dÅrfen in der Regel nicht ausgefÅhrt, sondern nur als ACC-
Dateien beim Booten des Rechners vom GEM aktiviert werden (es sei denn,
Sie verwenden die Funktion PrgCtrl.Accessory() zur Abfrage, ob das Programm
als normale Anwendung oder als Accessory gestartet wurde).

Durch das Festhalten der Shift-Taste beim Starten erhalten Sie die Mîglichkeit
zur Eingabe einer Argumentzeile (Command Line) auch bei Programmen der
Endungen MOD, MOS, APP, PRG und TOS.

Ein Problem, das noch nicht ganz zufriedenstellend gelîst wurde, ist die Wahl
des aktuellen Verzeichnisses fÅr zu startende Programme. So gibt es Pro~
gramme, die als Hilfsprogramme der Shell dienen und  die  oft  gerne  stan~
dardmÑûig auf den in der Shell aktuellen Pfad (der durch das oberste offene
Disk-Fenster  bestimmt  wird)  zugreifen  wollen,  beispielweise,  wenn  sie  den
GEM-Datei-Selektor anzeigen. Andererseits gibt es Anwendungen, die weitere,
dazu gehîrende Dateien nachladen wollen, wie zum Beispiel GEM-Resource-
Dateien (Endung RSC). Damit sie diese Dateien finden, ist es in der Regel so
zu lîsen, daû sie im Verzeichnis gesucht werden, in dem auch das Programm
selbst steht. Davon macht beispielsweise auch die Modula-Shell Gebrauch: Sie
sucht bei ihrem Start die Dateien MM2SHELL.RSC und MM2SHELL.M2P im zu
dem Zeitpunkt aktuellen Verzeichnis,  welches  normalerweise  auch  dasjenige
ist, in welchem die Shell selbst steht, weil ja auch im GEM-Desktop das ent~
sprechende Fenster obenauf offen liegen muû, damit die Shell gestartet werden
kann.
2.2  Bedienung: Shell                                                     2 - 21
________________________________________________________


Nun gibt es aber auch beim GEM-Desktop die Mîglichkeit, Programme nicht
aus dem vordersten, aktiven Fenster zu starten: Zielt man beim Starten auf
ein Programm in einem inaktiven Fenster und hÑlt dabei die rechte Maus-Taste
fest, wird das Programm gestartet, wÑhrend das vordere Fenster den aktuellen
Pfad  bestimmt.  Dies  machte  sogar  den  Entwicklern  des  TOS  bei  ATARI
Schwierigkeiten, denn je nach Version des TOS gibt es verschiedene Resultate:
Einmal wird das Programm Åberhaupt nicht gestartet, ein anderes Mal kann es
seine RSC-Datei nicht finden.

Die Megamax-Shell geht nun so vor: Wird das Programm von einem Fenster
gestartet,  wird  immer  der  Pfad  zum  aktuellen,  von  dem  das  Programm
stammt. Ebenso wird verfahren, wenn eine Arbeitsdatei gestartet wird. Wird
die  aktuelle  Datei  aufgerufen,  hÑngt  der  aktuelle  Pfad  vom  eingegebenen
Dateinamen  ab:  Ist  ein  Pfadname  im  Dateinamen  enthalten,  wird  dieser
aktiviert. Ist kein Pfadname enthalten, wird wiederum derjenige verwendet, von
dem das Programm gestartet wird (das funktioniert, weil die Programme dann
in den Ordnern gesucht werden kînnen). Dies macht bei der aktuellen Datei
nur dann einen Unterschied, wenn ihr Name manuell eingegeben wurde (durch
Doppelklick  auf  dessen  Feld  oder  mittels  Control-P);  beim  Benennen  der
aktuellen Code-Datei durch Anklicken im Fenster oder nach einem Make- oder
öbersetzungsvorgang wird immer der vollstÑndige Pfadname mit Åbernommen.

Wollen Sie also ein bestimmtes Programm starten, das Sie nicht erst in den
Ordnern suchen wollen, brauchen Sie nur die aktuelle Datei zu  bestimmen,
indem Sie den Namen des Programms (mit Endung, aber ohne Pfad) eingeben
(Control-P) und dann starten (Control-A). Wollen Sie gar erreichen, daû ein
Programm  einen  bestimmten  aktuellen  Pfad  erhÑlt,  kann  dieser  bei  der
Bestimmung der aktuellen Datei als Pfad mit eingegeben werden. Dann wird
dieser Pfad zum aktuellen, das Programm wird jedoch, wenn es dort nicht
vorhanden  ist,  weiterhin  in  den  anderen  Ordnern  gesucht  und  von  dort
gestartet.

Bei den Systemprogrammen (Compiler, Linker, Make, Editor) und den unter
dem Tools-MenÅ eingetragenen Programmen verhÑlt es sich noch etwas anders.
Da die Systemprogramme als feste Bestandteile des Entwicklungssystems mit
der Shell  in  besonderer  Weise  kommunizieren  bzw.  die  Tools  oft  Ñhnliche
Funktionen erfÅllen,  kann  ihnen  der  aktuelle  Pfad  praktisch  egal  sein.  Aus
diesem Grund wird bei ihren Aufrufen normalerweise kein neuer aktueller Pfad
eingestellt, statt dessen bleibt der Pfad der Shell (oberstes Fenster) aktiv.
Damit nun aber auch andere Editoren oder Tools ihre benîtigten Dateien (z. B.
RSC) nachladen kînnen, gibt es auch hier die Mîglichkeit, ihren aktuellen Pfad
zu definieren: Ist ein Systemprogramm oder ein Tool mit einem Pfadnamen
eingetragen, wird dieser Pfad beim Start aktiviert, ansonsten wird der Pfad
der Shell beibehalten.
2.2  Bedienung: Shell                                                     2 - 22
________________________________________________________


Um allgemein das Wechseln des Aktuellen Pfades beim Start eines Programms
zu verhindern, muû die Alternate-Taste bei Aktivierung der AusfÅhren-Funktion
festgehalten werden.


Programmaufruf und -abbruch bei gelinkten Programmen

Wird   ein   gelinktes   Programm   ausgefÅhrt,   geschieht   dies,   wie   vom
GEM-Desktop her gewohnt: Das Programm wird in den Speicher geladen, falls
dies nicht schon vorher geschehen ist (siehe Laden von Code-Dateien), dann
wird  dessen  BSS-Bereich  (Speicher  fÅr  die  globalen  Variablen)  gelîscht,
zuletzt  wird  es  gestartet.  Endet  das  Programm,  wird  zur  Megamax-Shell
zurÅckgekehrt.

Tritt ein fataler Fehler im aufgerufenen, gelinkten Programm auf, so daû eine
68000-Exception (Bus-Fehler, Adreû-Fehler und weitere von dem Programm
nicht abgefangene Fehler) ausgelîst wird, erscheint statt der vom Desktop-
Start gewohnten Bîmbchen die Scanner-Box (siehe Kapitel 2.5), in der aber
dann  keine  Lokalisation  der  Fehlerstelle  Åber  Back  und  Frwd  mîglich  ist.
WÑhlen Sie dann Quit, finden Sie sich in der Shell wieder. Dann kann es aber
sein, daû die Maus nicht  mehr  sichtbar  ist  oder  andere  unsinnige  Effekte
eintreten. Wenn die Shell noch auf Eingaben reagiert, verlassen Sie die Shell,
z. B. mit Control-Q. Oft stellt dann  das  GEM-Desktop  den  Normalzustand
wieder her, so daû Sie die Megamax-Shell erneut starten kînnen. Bei solchen
AbstÅrzen von Progammen ist es aber in der Regel immer das Sicherste, so
bald wie mîglich einen Neustart des Rechners, beispielsweise durch DrÅcken
des RESET-Tasters, zu veranlassen, weil es mîglich ist, daû das fehlerhafte
Programm auch Speicherbereiche, die dem TOS oder der Shell reserviert sind,
unkontrollierbar  Åberschrieben  hat,  was  sich  teilweise  erst  sehr  spÑt
bemerkbar macht.


Das Binden der Module

Wird ein vom Compiler Åbersetztes Modul gestartet, mÅssen zuerst die von
ihm importierten Module dazugebunden (gelinkt) werden.  Dies  wird  von  der
Prozedur CallModule des Loader-Moduls, die die Shell zum Starten sowohl von
gelinkten Programmen als auch von ungelinkten Modulen aufruft, automatisch
erledigt: Jedes benîtigte Modul wird in den Speicher geladen, wird ein Modul
von  mehreren  anderen  importiert,  wird  es  selbstverstÑndlich  nur  einmal
geladen.  Danach  werden  die  Module  gebunden,  das  heiût,  die  Referenzen
zwischen den Modulen (dies sind die importierten Prozeduren und Variablen)
werden fest verkettet. Diesen Vorgang nennt man Load-Time-Linking, weil das
Binden (Linken) der einzelnen Objekt-Module bei jedem Laden in den Speicher
von neuem erfolgt. Dem gegenÅber steht das einmalige Linken im voraus, bei
dem das Ergebnis als eine Datei (gelinktes Programm) erzeugt wird.
2.2  Bedienung: Shell                                                     2 - 23
________________________________________________________


Auf den ersten Blick nun erscheint es ineffektiv, bei jedem Start das Linken
durchzufÅhren,  anstatt  dies  einmal  zu  tun:  Wird  das  Programm  mehrmals
nacheinander ohne énderungen gestartet, vergeht viel mehr Zeit  durch  das
wiederholte  Laden  der  einzelnen  Code-Module  statt  der  einen  gelinkten
Programmdatei. Dies trifft aber nur bedingt zu. Ein Vorteil im dynamischen
(Load-Time-) Linken liegt darin, daû die Fehlerbehandlung (Debugging) einfacher
zu  gestalten  ist,  zweitens  kînnen  so  mehrere,  abwechselnd  gestartete
Progamme  leichter  Informationen  untereinander  austauschen,  und  zu  guter
Letzt ist es oft auch zeitsparender. Das kommt daher:

Der Loader (bzw. dessen Funktion CallModule) lÑdt jedes benîtigte Modul nur
einmal, auch wenn es von mehreren Modulen importiert wird. Dies ist sinnvoll
und  findet  bei  auch  jedem  normalen  Linker  anderer  Entwicklungssysteme
Verwendung.

Die Megamax-Shell besteht nun wiederum selbst aus vom Megamax-Compiler
Åbersetzten Modulen, die lediglich durch den Linker in eine Datei zusammengefÅgt
wurden. Nun bietet es sich an, diese schon im Speicher befindlichen Module bei
Bedarf  mitzubenutzen,  genauso  wie  dies  mit  den  nachgeladenen  Modulen
geschieht. Bedingung ist lediglich, daû das Loader-Modul, das selbst ja auch
Bestandteil  der  Shell  ist,  ausreichend  Informationen  Åber  die  in  der  Shell
befindlichen Module erhÑlt. Dies wurde beim Linken der Shell durch eine beson~
dere Einstellung (Linken ohne Optimierung) erreicht.

Wird also der Loader aufgerufen, ein Modul zu starten (z. B. durch Ansprechen
der AusfÅhren-Funktion der Shell), geht er wie bereits oben beschrieben vor:
Zuerst wird nachgesehen, ob sich das geforderte Modul schon im Speicher
befindet. Normalerweise ist dies beim Hauptmodul noch nicht der Fall,  also
wird es nachgeladen und der Loader merkt sich, daû dieses Modul nun geladen
ist. Dann wird nachgesehen, welche Module importiert werden. Bei denen wird
genauso verfahren: Ist das Modul noch nicht im Speicher, wird es geladen und
dessen Importe ebenfalls berÅcksichtigt.

Ist ein Modul schon im Speicher, wird es nicht weiter verfolgt - in diesem Fall
kann  davon  ausgegangen  werden,  daû  alle  seine  Importe  ebenfalls  schon
geladen sind. Es ist also nicht mîglich, auch nicht mit den Lade-/Entlade-
Funktionen des Loader-Moduls bzw. der Shell,  daû  am  Ende  ein  Modul  im
Speicher verbleibt, dessen Importe nicht ebenfalls alle geladen sind!

Nach diesen Lade-Regeln nun werden die  in  der  Shell  vorhandenen  Module
immer als bereits geladen (speziell: resident) behandelt. Daraus folgt, daû ein
Modul, das nur Module importiert, die schon in der Shell befindlich eingebunden
sind, praktisch keine Ladezeit mehr hat, weil lediglich das Hauptmodul selbst
von Disk geladen werden muû - das Binden dieses Moduls mit denen der Shell
geht so schnell, daû Sie davon nichts merken.
2.2  Bedienung: Shell                                                     2 - 24
________________________________________________________


Nach der Bindung aller Module werden zuerst, wie bei gelinkten Programmen,
alle globalen Variablen gelîscht (Pointer auf NIL, REALs auf 0.0) und dann alle
Modulkîrper aufgerufen, das am tiefsten liegende von den anderen importierte
Modul  wird  zuerst,  das  oberste,  von  der  Shell  ausgewÑhlte  Modul  zuletzt
initialisiert. Bei zirkularen Importen (A importiert B, B wiederum A) ist die
Reihenfolge undefiniert und kann jederzeit wechseln.

Wollen Sie die Mîglichkeit nutzen, daû mehrere durch CallModule gestartete
Anwendungen (Module) Daten Åber gemeinsam importierte Module austauschen
(shared  data),  mÅssen  Sie  verhindern,  daû  diese  gemeinsamen  Module
jedesmal neu  initialisiert  werden  und  neuen  Speicherplatz  fÅr  ihre  globalen
Variablen  erhalten.  Das  erreichen  Sie,  indem  Sie  solche  Module  mit  einer
besonderen Compiler-Direktive ($Y+, siehe Kapitel 3.4) Åbersetzen.

WÑhrend der gesamten Initialisierungsphase und beim Start des Hauptmoduls
wird ein Stack verwendet, dessen Grîûe in Info/Umgebung unter Stackgrîûe...
(fÅr Load-Time-Linking) einstellbar ist. Tritt wÑhrend des Programmlaufs ein
Stack-öberlauf-Fehler auf, kann der Stack also ohne NeuÅbersetzung fÅr den
nÑchsten Start verÑndert werden.  Die  Systemprogramme  (Compiler,  Linker,
Make sowie die Editoren GME und GEP ED) verwenden Åbrigens eine eigene,
                                          _
fest in der Shell definierte Stackgrîûe.
2.2  Bedienung: Shell                                                     2 - 25
________________________________________________________


Resident-Laden von Code-Dateien

Wenn ein gestartetes Modul abgelaufen ist, wird es wieder aus dem Speicher
entfernt. Auch die von ihm importierten Module, die noch von der Diskette
nachgeladen wurden, bleiben natÅrlich nicht im Speicher - bei einem  neuen
Start des Moduls wird alles erneut geladen. Um bei hÑufiger Benutzung eines
Moduls diese Ladezeiten zu eliminieren, kînnen Sie Module in den Speicher
laden.   Dazu   dient   das   Resident-Symbol   auf   der   ArbeitsflÑche.   Das
Resident-Symbol  funktioniert  ganz  Ñhnlich  wie  die  Diskettensymbole.  Sie
kînnen...

* einen Dateieintrag auf das Ladesymbol schieben, um das Modul
in den Speicher zu laden (Control-R lÑdt die aktuelle Datei). Es
ist auch mîglich, gelinkte Programme auf diese Weise zu laden;

* das Ladesymbol doppelt anklicken, um ein Fenster mit dem Verzeichnis der
geladenen Module zu îffnen;

* EintrÑge aus diesem Fenster mit der Maus auf das AusfÅhren-Symbol schie~
ben oder doppelt anklicken, um sie auszufÅhren. Allerdings ist es auch mîglich,
ein Modul aus einem ganz normalen Dateifenster zur AusfÅhrung zu bringen -
die Shell (der Loader) ÅberprÅft, ob das Modul schon geladen ist, und fÅhrt
ggf. die geladene Version aus.

* Auûerdem ist es mîglich, EintrÑge aus dem Verzeichnis der geladenen Mo~
dule in den Abfalleimer zu schieben, um sie wieder aus dem RAM zu lîschen.
Beachten Sie aber, daû das Ladesymbol keine normale RAM-Disk darstellt -
beim Laden werden die Module bereits fÅr die AusfÅhrung vorbereitet (gelinkt);
daher ist es nicht mîglich, ein geladenes Modul auf ein Diskettensymbol zu
schieben oder an den Linker zu Åbergeben!

Ein anderer Weg, Module und gelinkte Programme resident laden zu lassen, ist
das Eintragen eines LOAD-Kommandos in eine Batch-Datei (s. Abschnitt weiter
unten in diesem Kapitel). Dies ist eine bequeme Mîglichkeit, regelmÑûig benîtigte
Module resident in den Speicher zu laden, solange man sich in der Modula-
Shell befindet.

Die  so  geladenen  Module  werden  zwar  in  die  schon  residenten  Module
eingebunden (gelinkt), jedoch nicht intitialisiert! Die Initialisierung mit  Aufruf
der Modulkîrper wird weiterhin so vorgenommen, wie unter Binden der Module
beschrieben, also als wenn sie jedesmal bei Bedarf doch  von  Disk  geladen
werden wÅrden.

Zum Schluû noch ein Tip: WÑhrend der Programmentwicklung kînnen Sie den
Entwicklungszyklus (Edieren -  öbersetzen  -  Testen)  deutlich  beschleunigen,
falls Ihr Programm Module importiert, die nicht bereits in der Shell vorhanden
2.2  Bedienung: Shell                                                     2 - 26
________________________________________________________


sind (das merken Sie an den Diskettenzugriffen vor jedem Programmstart):
Dann sollten Sie die importierten Module laden. Das Programm, an dem Sie
gerade arbeiten, sollte dagegen nicht geladen sein - die geladene Version hat,
wie oben gesagt, immer Vorrang vor  dem  neu  Åbersetzten  Modul  auf  der
Diskette.

Das Laden ist meist dem Ablegen eines Moduls in der RAM-Disk vorzuziehen:
Ein Modul aus der RAM-Disk wird zur AusfÅhrung jeweils ein zweites Mal in
den RAM kopiert und belegt dann doppelten Platz. Allerdings wird beim Laden
bereits Platz fÅr die globalen Variablen reserviert, der belegt bleibt, solange
das Modul im RAM verbleibt. Dies wiederum macht sich bei wenigen Program~
men deutlich bemerkbar (beispielsweise bei dem Programmeditor TEMPUS von
CCD).


Laden gelinkter Programme

Das Laden von gelinkten Programmen wird prinzipiell durch eine Sonderfunktion
des  GEMDOS  ermîglicht.  Aufgrund  einer  konzeptionellen  SchwÑche  bei
besagter Funktion ist aber deren Anwendung leider nicht so "idiotensicher" wie
die des Ladens von Megamax-Modulen.

Das Problem ergibt sich bei der Reservierung des Stacks fÅr die Programme:
Ein gelinktes Programm, das normal gestartet wird, wird an den Beginn des
grîûten freien Speicherbereichs geladen. Wird es dann aufgerufen, erhÑlt es
erstmal den gesamten freien Speicher hinter dem Programmcode fÅr sich als
reservierten Speicher. Daraufhin berechnet es den fÅr sich selbst benîtigten
Speicher und gibt den Rest wieder frei. Der selbst benîtigte Speicher besteht
in der Regel aus dem Platz fÅr die globalen Variablen und dem Stack des
Programms.

Wird ein solches Programm nur geladen, muû der Loader, der dies organisiert,
dafÅr sorgen, daû nur so viel Platz fÅr das Programm reserviert bleibt, wie es
spÑter beim Start benîtigen wird, damit der Rest des Speichers frei bleibt fÅr
weitere Anwendungen. Aufgrund der Konventionen aber  muû  das  Programm
erwarten kînnen, daû es den benîtigten Speicher fÅr die Variablen und den
Stack  direkt  hinter  dem  Programmcode  vorfindet  (fÅr  die  Experten:  Die
Relozierung, die das GEMDOS beim Laden vornimmt, nimmt auch sofort die
Adreûbestimmung der globalen Variablen im BSS-Segment - welches in der
Regel direkt hinter dem Programmcode oder dem DATA-Segment liegt - vor,
so daû dieser Bereich spÑter nicht mehr an eine andere Stelle verschoben
werden kann). Hier liegt das Problem:  Es  ist  zwar  allgemein  mîglich,  den
benîtigten Platz fÅr die globalen Variablen zu ermitteln, die Stack-Grîûe aber
kann  nicht  vorausgesehen  werden.  So  muû  also  beim  Laden  abgeschÑtzt
werden, wieviel Platz der Stack spÑter benîtigen wird. Zuviel Platz kann dem
Programm nicht schaden, nur wird der Platz ja schon beim Laden reserviert,
so daû der verbleibende freie Speicher ggf. unnîtig eingeschrÑnkt wird.
2.2  Bedienung: Shell                                                     2 - 27
________________________________________________________


Ist der Stack zu klein gewÑhlt, ist es mîglich (aber nicht sicher), daû das
geladene  Programm  wÑhrend  seines  Aufrufs  fehlerhaft  arbeitet  oder  gar
abstÅrzt (Programm reagiert nicht mehr auf Eingaben, oder es erscheinen die
Bîmbchen und das Programm kehrt in die Shell zurÅck).

Gegebenenfalls  muû  also  zuerst  ein  geladenes  Programm  mit  Vorsicht
angewendet werden (jedenfalls sollte es bei Unsicherheit nicht mit wichtigen
Originaldaten arbeiten, die es ja zerstîren kînnte).

Die meisten Fremdprogramme verwenden einen Stack von 8 bis 16 KByte (auch
Tempus kommt beispielsweise mit einem Stack von 8KB, =8192, zurecht). So
reicht  es  oft  aus,  zur  Sicherheit  den  Stack  beim  Laden  in  dieser  Grîûe
vorzusehen. Erst,  wenn  sich  ungewîhnliche  Effekte  bei  der  Benutzung  der
geladenen Programme zeigen, sollte der Stack jeweils vor dem erneuten Laden
durch Verdoppelung erhîht werden.

Die Bestimmung des Stacks  beim  Laden  von  gelinkten  Programmen  erfolgt
durch den Wert, den auch der Loader beim Start von Modulen verwendet. Er
kann in den Umgebungsinformationen unter Stack-Grîûe fÅr Load-Time-Linking
bestimmt oder durch die Anweisung STACKSIZE in Batch-Dateien, am besten
direkt vor dem Laden des Programms mit LOAD, auf einen besonderen Wert
gesetzt werden.
2.2  Bedienung: Shell                                                     2 - 28
________________________________________________________


Die MenÅzeile der Shell

Die  MenÅzeile  am  oberen  Bildschirmrand  bietet  die  MenÅpunkte  MM2Shell,
Datei, Parameter, Info und ggf. Tools an. Unter MM2Shell erreichen Sie wie
Åblich die Accessories sowie eine Meldung Åber die Version der Shell. Der
MenÅpunkt Datei wurde schon weiter oben behandelt.

Unter Parameter finden sich:

Shell: Siehe unten.
Editor: Siehe Kapitel 2.3
Compiler: Siehe Kapitel 2.4
Linker: Siehe Kapitel 2.6
speichern: Sichert die Einstellungen aller Parameter, der Symbol- und Fenster~
  positionen  und  der  Umgebungseinstellungen,  jedoch  nicht  den  Status  der
  geladenen Module, der Åber die MenÅzeile abrufbaren Tools und der Such~
  pfade  (diese  Einstellungen  sind  Åber  die  Batch-Dateien  bestimmbar).  Die
  Einstellungen  werden  in  der  Datei  gesichert,  die  zu  dem  Zeitpunkt  als
  Parameterdatei unter Parameter/Shell... eingestellt ist.

Die Raute bei den Tastenangaben im Parameter-MenÅ zeigt Åbrigens an, daû
diese Funktionen mit der Alternate-Taste in Verbindung mit dem Buchstaben zu
erreichen sind, wÑhrend der Pfeil fÅr die Control-Taste steht.


Unter Info finden sich:

Umgebung: Siehe unten.
Hilfe: Zeigt den Inhalt der Textdatei MM2SHELL.HLP an, falls sich diese im
  Verzeichnis der Shell befindet.


Unter Tools kînnen Sie bis zu zehn eigene ausfÅhrbare
Dateien eintragen (mittels der Anweisung Tool in  einer
Batch-Datei). Diese erscheinen dann  unter  dem  Tools-
MenÅpunkt und kînnen auch Åber die Funktionstasten an~
gewÑhlt werden.
2.2  Bedienung: Shell                                                     2 - 29
________________________________________________________


Die Shell-Parameter (Parameter/Shell...)

Erzeuge Fenster:
Wurzel îffnet  Fenster  bei
Doppelklick  in   gewohnter
Weise.  Der  aktuelle  Pfad
kann  statt  dessen   ent~
weder  durch  die  hiesige
Standardeinstellung    oder
durch Festhalten der Shift-
Taste   beim   Doppelklick
geîffnet werden.

Kopier- und LîschbestÑtigung bestimmen, ob bei den entsprechenden Dateiope~
rationen eine BestÑtigung gefordert werden soll.

Abbruch mit Control-C: Ist diese Option aktiv, kînnen von der Shell gestartete
Programme mit Control-C abgebrochen werden, wÑhrend sie Ein- oder Ausga~
ben Åber die Module TextWindows oder InOut durchfÅhren. Auch ist es dann
mîglich, mit Control-Enter Programme zu jeder Zeit abzubrechen - dies sollte
aber nur dann geschehen, wenn Control-C nicht wirkt und das Programm nicht
gerade Betriebssystemaufrufe (z.B. Zugriff auf die Disk oder Grafikausgaben
auf dem Bildschirm) durchfÅhrt, da es sonst zu Fehlverhalten des Systems
kommen kann. NÑhere Informationen im Definitionstext des Moduls UserBreak.

Anwender eines Drucker-Spoolers oder der Flexdisk sollten die Option Maximaler
Kopierpuffer gegebenenfalls deaktivieren, ansonsten bietet es sich fast immer
an, diese Option zu nutzen, denn dadurch wird bei KopiervorgÑngen fast der
gesamte  Speicherplatz  verwendet,  um  den  Kopiervorgang  mîglichst  schnell
durchzufÅhren.

Unter Make wird der Name des Make-Programms eingetragen - dies ist in der
Regel MM2Make.

In Temp. Pfad sollte ein Ordnername eingetragen werden, in dem die Shell und
die Hilfsprogramme kurzzeitig kleine Dateien ablegen kînnen. So  legt  Make
dort beispielsweise die Steuerdatei der evtl. zu Åbersetzenden Module fÅr den
Compiler ab. Nach Mîglichkeit sollte dieser Pfad auf einem schnellen GerÑt
liegen, also eher auf einer RAM-Disk als einer Diskette - ein Pfad auf der
Harddisk reicht natÅrlich auch aus.

Die Batch-Datei (mit der Endung M2B) ist diejenige, die ausgefÅhrt wird, wenn
die  darunter  angegebene  Parameterdatei  (teilweise  auch  als  Projekt-Datei
bezeichnet) aktiviert oder "ausgefÅhrt" wird. Diese  wiederum  kann  aktiviert
werden, indem sie - vorausgesetzt, sie hat die Dateiendung M2P - auf ge~
wohnte  Weise  (Doppelklick,  Ziehen  auf  das  AusfÅhren-Symbol,  Starten  als
Tool)  "ausgefÅhrt"  wird.  Einen  Sonderstatus  genieût  die  Parameterdatei
2.2  Bedienung: Shell                                                     2 - 30
________________________________________________________


MM2SHELL.M2P: Sie wird beim Starten der Shell, wenn sie  sich  in  deren
Verzeichnis befindet, automatisch ausgefÅhrt. Somit muû die Batch-Datei, die
beim Start der Shell ausgefÅhrt werden soll, nicht zwingend "MM2SHELL.M2B"
heiûen, sondern lediglich als Batch-Datei der Parameterdatei MM2SHELL.M2P
definiert sein.

Um eine neue Parameter- oder Batch-Datei zu erstellen, kînnen Sie folgen~
dermaûen  vorgehen:  Tragen  Sie  eine  beliebige  Datei  der  Endung  M2B  als
Batch-Datei und ebenso eine der Endung M2P (z. B. MM2SHELL.M2P fÅr die
Autostart-Parameter) als Parameterdatei ein. Dann verlassen Sie den Shell-
Parameter-Dialog und wÑhlen Parameter/speichern... an. So werden die aktu~
ellen Einstellungen unter der gewÑhlten Parameterdatei gesichert.


Die Umgebungsinformationen (Info/Umgebung...)

Letzter  Code/LÑnge  infor~
mieren Åber die vom letzten
Compileraufruf erzeugte Code-
Datei und dessen LÑnge.

Normalerweise    wird    der
aktuelle   Pfad   durch   das
oberste,   geîffnete   Disk-
Fenster bestimmt. Ist jedoch
keins offen,  kann  der  Pfad
hier abgelesen oder auch geÑndert werden. Das éndern des Pfades hat keinen
Erfolg, wenn ein Fenster geîffnet ist - dieses hat dann Vorrang.

Die Default-Make-Datei wird aktiviert, wenn in der Shell die Taste M gedrÅckt
wird oder wenn vom Editor (GEP_ED oder GME) aus die Make-Funktion ange~
wÑhlt wird. Das Aktivieren einer Make-Datei bewirkt den Aufruf des Make-
Programms, welches dann aufgrund der Informationen aus der Make-Datei (mit
Endung M2M) prÅft, ob Dateien zu Åbersetzen sind und daraufhin dann den
Compiler dazu aufruft. NÑheres in Kapitel 2.7.

Die Stack-Grîûe fÅr das Load-Time-Linking wird den Anwendungsmodulen zur
VerfÅgung gestellt, wenn sie unter der Shell gestartet werden (gelinkte Program~
me haben bereits intern eine feste Einstellung - beim Linken von Megamax-
Modulen kann dieser Wert ebenfalls bestimmt werden, allerdings in den Lin~
ker-Optionen). Der anfangs eingestellte Wert von 16 K Bytes kann zu klein
sein, wenn das Programm rekursiv arbeitet oder groûe Datenstrukturen als
lokale Variablen verwendet (Sie erfahren dies dann wÑhrend des Programm~
laufs durch die Fehlermeldung "Stack-öberlauf").

Taste nach TOS-Programmen: Wartet beim Ende von TOS-Programmen auf
einen Tastendruck, damit eventuelle Ausgaben noch gelesen werden kînnen.
2.2  Bedienung: Shell                                                     2 - 31
________________________________________________________


Der aktuell freie Speicherplatz wird in zwei Werten angezeigt. Der linke gibt
den grîûten  zusammenhÑngenden  Bereich,  der  rechte  den  gesamten  freien
Platz an.


Tasten-Funktionen

Zusammenfassend haben folgende Tasten in der Shell eine Funktion:

Anfangsbuchstaben der Symbole: Sie bearbeiten alle die jeweils aktive Arbeits~
datei, es sei denn, es wird zusÑtzlich die Control-Taste gedrÅckt - dann wird
stattdessen die aktuelle Datei bearbeitet.

  A        AusfÅhren (von Programmen, Modulen, Make, Batch, Projektdateien)
                 Wird dabei Shift festgehalten, kann eine Argumentzeile (wie
                 bei  TTP  bzw.  MTP-Programmen)  eingegeben  werden,  beim
                 Festhalten von Alternate bleibt der aktuelle Pfad erhalten.
  C        Compilieren (öbersetzen)
  +         Compilieren, dann AusfÅhren
  E        Laden der Datei in den Editor
  L         Linken (Binden der Module zu einem Programm)
  S        Aktivieren des Scanners
                 Falls  vorher  bei  einem  Programmaufruf  ein  Laufzeitfehler
                 auftrat und die Scanner-Dialogbox erschien, kann durch Ein~
                 gabe von Shift-S der letzte Dialog wiederholt werden, um eine
                 andere Textposition anzuscannen (siehe Kapitel 2.5).
  P        Eingabe der Arbeits- oder aktuellen Datei Åber Tastatur.

Weitere spezielle Funktionen, die nicht aus den MenÅzeilen ersichtlich sind:

  M        Make-Vorgang mit der Default-Make-Datei einleiten.
  Ctrl-R   Laden der aktuellen Code-Datei.
  R        Anzeige der geladenen Module und gelinkten Programme.
  Alt-R    Anzeige aller im Speicher vorhandenen (residenten) Module.

Bleiben noch folgende versteckte Funktionen:

  Esc      Neuanzeige des Inhalts des obersten Fensters, z.B. nach Wechseln
            einer Diskette;
            WÑhrend des Starts der Shell kann durch Druck auf diese Taste
            verhindert werden, daû Programme durch den Start-Batch geladen
            werden.
  Home    Schlieût das Verzeichnis des aktiven Fensters.
  Clr       (Shift-Home)  Schlieût  das  aktive  Fenster.  Werden  beide  Shift-
            Tasten festgehalten, werden alle Fenster geschlossen.
  Ctrl-Q   Beenden der Shell ohne Nachfrage zum Sichern der Einstellungen.
2.2  Bedienung: Shell                                                     2 - 32
________________________________________________________


Batch-Dateien

In Batch-Dateien kînnen hÑufig benîtigte Shell-Operationen und -Einstellungen
beschrieben und dann jederzeit zur AusfÅhrung gebracht werden. Auûerdem
werden hiermit die Suchpfade der Dateien fÅr Shell, Editor, Compiler, Linker
und Make eingegeben. Die Batch-Datei ist ein normaler ASCII-Text, der alle
Anweisungen  im  Klartext  enthÑlt,  daher  kînnen  Sie  diese  Datei  mit  dem
mitgelieferten Editor bearbeiten.

Eine besondere Batch-Datei ist diejenige, die in den Shell-Parametern unter
Batch-Datei  eingetragen  ist:  Sie  wird  automatisch  beim  Start  der  Shell
ausgefÅhrt. öblicherweise enthÑlt diese Datei Anweisungen, um Module (auch
gelinkte Programme) zu laden und um vor allem die Suchpfade zu bestimmen,
damit Åberhaupt ein Arbeiten in der Shell mîglich ist.

Im  folgenden  wird  zunÑchst  die  Syntax  der  Batch-Dateien  beschrieben  (in
Backus-Naur-Form, siehe Anhang A.6); anschlieûend erlÑutern wir die Funktion
der einzelnen Anweisungen:

Syntax der Batch-Dateien

anweisung  =    IF SHELLSTART anweisung <cr> |
                    _
                  WAIT text <cr> |
                  * text <cr> |

                  SETPATH pfad <cr> |
                  SETDRIVE laufwerk <cr> |
                  SETDIR pfad <cr> |

                  DELETETOOLS <cr> |
                  TOOL dateiname <cr> |

                  LOAD dateiname <cr> |
                  UNLOAD dateiname <cr> |

                  STACKSIZE cardinal <cr> |
                  EXEC dateiname  argument  <cr> |
                  IF EXITCODE integer anweisung <cr> |
                    _

                  DEFOUT   pfad   <cr> |
                  IMPOUT   pfad   <cr> |
                  MODOUT   pfad   <cr> |
                  MAINOUTPUTPATH   pfad   <cr> |

                  COMPILE dateiname <cr> |
                  MAKE   dateiname   <cr> |
2.2  Bedienung: Shell                                                     2 - 33
________________________________________________________


                  LINKSTACKSIZE cardinal <cr> |
                  NO OPTIMIZE <cr> |
                     _
                  PART OPTIMIZE <cr> |
                       _
                  FULL OPTIMIZE <cr> |
                       _
                  DRIVER   '+' | '-'   dateiname <cr> |
                  DELETEDRIVERS <cr> |
                  LINK dateiname <cr> |

                  DEFAULTPATH pfad-liste <cr> |
                  DEFPATH pfad-liste <cr> |
                  IMPPATH pfad-liste <cr> |
                  MODPATH pfad-liste <cr> |
                  SOURCEPATH pfad-liste <cr>  .

pfad-liste  =     <cr> Leerzeichen  Leerzeichen  pfad   .
pfad        =     laufwerk       'Å'         name | '..'   'Å'   .
dateiname  =   pfad name
name       =   prefix   '.' suffix              (einfacher Dateiname ohne Pfad )
laufwerk   =   Buchstabe ':'
prefix      =   Bis zu acht Buchstaben oder Ziffern
suffix      =   Bis zu drei Buchstaben oder Ziffern
argument  =   Ein Wort (Text, der nicht durch Leerzeichen unterbrochen ist)
text        =   Beliebiger Text
cardinal    =   Positive, ganze Zahl (0 bis 2^32-1)
integer     =   Ganze Zahl (-32767 bis 32768)

Die Anweisungen sowie alle Teile von Datei- und Pfadnamen dÅrfen sowohl in
Groû- als auch Kleinbuchstaben geschrieben sein.

Um einen Batch sowohl fÅr die Erstinitialisierung fÅr die Shell als auch allge~
mein verwendbar zu machen, ist es teilweise notwendig, bestimmte Funktionen
darin  nur  beim  Start  der  Shell  durchzufÅhren.  Wird  die  Anweisung
IF SHELLSTART vor eine normale Anweisung gestellt, wird sie nur berÅck~
  _
sichtigt, wenn der Batch beim Starten der Shell automatisch ausgefÅhrt wird.

Mit WAIT wird der dahinter stehende Text in einer Alert-Box angezeigt und
erst bei BestÑtigung des OK-Knopfs wird der Batch weiter abgearbeitet.

Teilweise  ist  es  wÅnschenswert,  bestimmte  Disk-Verzeichnisse  als  aktuelle
Pfade einzustellen. Jedes Laufwerk kann dabei ein eigenes aktuelles Verzeichnis
haben, zusÑtzlich gibt es ein aktuelles Laufwerk; das aktuelle Laufwerk bestimmt
mit seinem aktuellem Verzeichnis (Dir) den aktuellen Pfad. SETDRIVE wÑhlt
mit  einem  angefÅgten  Laufwerksbuchstaben  das  aktuelle  Laufwerk,  SETDIR
bestimmt, falls beim Pfadnamen  kein  Laufwerk  angegeben  ist,  das  aktuelle
Verzeichnis des aktuellen Laufwerks, sonst den Pfad des angegebenen Lauf~
werks - das aktuelle Laufwerk wird jedoch nicht gewechselt (so kann damit das
2.2  Bedienung: Shell                                                     2 - 34
________________________________________________________


Verzeichnis auf einem anderen Laufwerk bestimmt werden). SETPATH schlieû~
lich setzt den aktuellen Pfad, also das aktuelle Laufwerk mitsamt dem Ver~
zeichnis.

War  das  zu  kompliziert?  Dann  andersrum:  Normalerweise  verwenden  Sie
SETPATH.  Damit  geben  Sie  Laufwerk  und  Verzeichnis  an,  die  dann  zum
aktuellen werden. Das hat die gleiche Funktion wie die Eingabe des aktuellen
Pfads in den Umgebungsinformationen.

Wollen Sie aber auch die Pfade der anderen Laufwerke festlegen, verwenden
Sie fÅr jedes Laufwerk SETDIR. Das wÑre beispielsweise nÅtzlich, wenn Sie die
Disk-Fenster in der Shell mit Shift bzw. der Einstellung Erzeuge Fenster auf
aktuellem Pfad (s. Shell-Parameter) îffnen wollen - dann wird der mit SETDIR
fÅr das Laufwerk bestimmte Pfad  geîffnet.  Ebenso  wird  beim  GEM-Datei-
Selektor  ab  TOS  1.4  beim  Anklicken  eines  Laufwerks  dessen  aktuelles
Verzeichnis angezeigt.

Die EintrÑge im Tools-MenÅ kînnen mit TOOL bestimmt werden. Bis zu zehn
Tools kînnen eingetragen werden. Die MenÅeintrÑge werden nacheinander auf~
gefÅllt. Die dort aufgefÅhrten Programme kînnen durch die MenÅanwahl oder
eine  Funktionstaste  bequem  ausgefÅhrt  werden.

FÅr die Dateinamen bei TOOL gilt: Wird ein Pfad angegeben, wird beim Start
des Programms der Pfad zum aktuellen Pfad, ansonsten bleibt der in der Shell
gerade aktuelle Pfad erhalten.

Um alle Tools-EintrÑge zu lîschen, dient die Anweisung DELETETOOLS.

Die LOAD-Anweisung veranlaût die Shell, das angegebene Modul in den Spei~
cher zu laden, so, als ob es auf das Resident-Symbol gezogen wÅrde. Die
Module stehen dann zum direkten Aufruf oder auch zum Import  in  andere
Module  zur  VerfÅgung  und  mÅssen  nicht  wiederholt  von  Diskette  geladen
werden. Besonders  interessant  ist  die  Mîglichkeit,  Editor  und  Compiler  zu
laden - der Aufruf ist anschlieûend ohne Wartezeit mîglich. UNLOAD gibt ge~
ladene Module entsprechend wieder frei.

Mit EXEC kann ein Programm oder Modul gestartet werden. Wenn es endet,
wird hinter der EXEC-Anweisung in der Batch-Datei fortgefahren. Nach der
RÅckkehr kann Åber IF EXITCODE der RÅckgabewert des Progamms geprÅft
                        _
werden.  Nur,  wenn  er  zutrifft,  wird  die  dahinter  stehende  Anweisung
ausgefÅhrt.  Dies  kann  zum  Beispiel  Verwendung  finden,  um  auf  abnorme
Abbruchbedingungen  eines  Programms  zu  reagieren:  Jedes  Programm  kann
beim Terminieren einen Integer-Wert zurÅckgeben. Bei Megamax-Programmen
kann dies Åber die Prozedur TermProcess aus dem Modul PrgCtrl geschehen.
Jedes Programm das normal terminiert, liefert als RÅckgabewert  (Exitcode)
Null. Nun kînnten Sie ein Programm schreiben, das mit einem anderen Wert
2.2  Bedienung: Shell                                                     2 - 35
________________________________________________________


terminiert, um beispielsweise damit dem Aufrufer anzuzeigen, daû ein anderes
Programm gestartet werden soll. Nehmen wir an, das Programm heiût A und
wenn es den Wert Eins zurÅckgibt, soll B gestartet werden. Also ist ein Batch
zu schreiben, der die folgenden beiden Zeilen enthÑlt:
      EXEC  A
      IF EXITCODE  1  B
        _
Wird dieser Batch gestartet, lÑût er A ausfÅhren. Terminiert A, wird B nur
gestartet, wenn der Exitcode von A Eins ist.

STACKSIZE erlaubt die Einstellung der Stackgrîûe, die gestarteten Programmen
zur  VerfÅgung  gestellt  wird.  Normalerweise  wird  die  Stack-Grîûe  in  den
Umgebungsinfomationen (s.o.) bestimmt, jedoch kann es notwendig sein, diesen
Wert vor dem Starten bestimmter Module mit dem EXEC-Befehl zu Ñndern.

Ein Modula-Programm kann  mit  COMPILE  und  einem  angefÅgten  Quelltext-
(Source-) Namen Åbersetzt werden. Tritt dabei ein öbersetzungsfehler auf,
wird eine entsprechende Meldung angezeigt. Der Fehler kann dann wahlweise
ignoriert werden, so daû der Batch bei der nÑchsten Anweisung fortfÑhrt oder
der Editor gestartet wird (dann ist die Batch-Abarbeitung abgebrochen  und
muû bei Bedarf erneut gestartet werden).

Mit  DEFOUT,   IMPOUT,   MODOUT   und   MAINOUTPUTPATH   kînnen   die
Ausgabepfade des Compilers abweichend von der Standard-Einstellung (siehe
Kapitel  2.4,  Compiler)  bestimmt  werden.  Allerdings  werden  sie  nicht
automatisch am Ende des Batch-Laufs wieder auf ihre alten Werten gestellt.
DEFOUT, IMPOUT und MODOUT  kînnen  nicht  rÅckgÑngig  gemacht  werden,
hîchstens   durch   Neudefinition   der   Suchlisten   (DEFPATH,   IMPPATH,
MODPATH). Dagegen kann MAINOUTPUTPATH  durch  eine  leere  Pfadangabe
wieder ungÅltig gemacht werden. Nach einem Compiler-Fehler mit Aufruf des
Editors (oder Abbruch des Batch-Laufs) wird diese Anweisung allerdings nicht
mehr ausgefÅhrt - dann muû ggf. die Einstellung des Ausgabe-Pfads in den
Compiler-Optionen (Parameter/Compiler) rÅckgÑngig gemacht werden.

Der Make-Vorgang kann durch die Anweisung MAKE gestartet werden. Wird
kein  Name  einer  Make-Datei  (Endung  M2M,  mit  Hilfsprogramm  ModRef
erstellt) angegeben, wird die Default-Make-Datei der Umgebungsinformationen
verwendet, ansonsten die angegebene.  Bei  einem  Fehler  in  der  Make-Datei
oder beim darauf folgenden öbersetzungsvorgang wird so verfahren, wie schon
oben bei der COMPILE-Anweisung beschrieben.

Um ein Programm im Batch zu binden, ist LINK zu verwenden. Der dahinter
anzugebende Modulname darf eine Pfadangabe enthalten. Ist dies der Fall, wird
die zu erzeugende gelinkte Programmdatei auf dem angegebenen Pfad erzeugt,
ansonsten dort, woher das angegebene Modul stammt. Der Optimierungsgrad,
die Stack-Grîûe, die das gelinkte Programm verwenden soll sowie die einzu~
bindenden Treiber-Module werden normalerweise in der Dialogbox des Linkers
2.2  Bedienung: Shell                                                     2 - 36
________________________________________________________


(Parameter/Linker) bestimmt (dazu mehr in Kapitel 2.6 Åber den Linker). Diese
Eintragungen kînnen aber optional auch vom Batch verÑndert werden (natÅrlich
mÅssen sie vor dem betreffenden Linker-Aufruf abgearbeitet werden!):

LINKSTACKSIZE bestimmt mit der angegebenen Zahl die Stackgrîûe fÅr das
zu linkende Programm; sie sollte mindestens 2000 (Bytes) betragen. Mit einer
der Anweisungen NO OPTIMIZE, PART OPTIMIZE oder FULL OPTIMIZE wird
                      _                  _                      _
keine, verkÅrzte bzw. vollstÑndige Optimierung des Programms erreicht. Nach
DRIVER  kann  ein  Treiber-  (Konfigurations-)  Modul  angegeben  werden.
Insgesamt  kînnen  bis  zu  acht  solcher  Module  eingetragen  werden.  Dem
Modulnamen hinter  DRIVER  kann  ein  Plus-  oder  Minuszeichen  vorangestellt
werden  (ohne  Leerzeichen!),  je  nachdem  wird  es  als  selektiertes  oder
abgeschaltetes Modul eingetragen (nur selektierte Module werden beim Linken
als Treiber mit eingebunden) ist kein solches Zeichen vor dem Namen, wird
das Modul als selektiert Åbernommen. Ein bereits konfiguriertes Modul wird
nicht doppelt eingetragen, sondern die neue Definition Åberschreibt dann die
alte. Durch  die  Anweisung  DELETEDRIVERS  kînnen  allerdings  alle  Treiber-
Eintragungen gelîscht werden.

Um die weiteren EintrÑge der Batch-Datei zu erklÑren, holen wir etwas weiter
aus - als Vorwarnung spendieren wir eine neue öberschrift:


Suchpfade und Pfadlisten

Zu guter Letzt kînnen Sie in der Batch-Datei verschiedene Pfadlisten angeben -
also Listen von Directories, die beim Suchen verschiedener Dateitypen abge~
sucht werden sollen. Vier dieser Pfadlisten werden ausschlieûlich vom Modula-
System selbst (Compiler, Linker) benutzt:

DEFPATH       fÅr Åbersetzte Definitionsmodule:
                 Hier sucht der Compiler die Definitionsdateien (Endung DEF)
                 der importierten Module.
                 Im ersten angegebenen Pfad legt der Compiler neu erzeugte
                 (Åbersetzte) Definitionsdateien ab.

IMPPATH       fÅr Åbersetzte Implementationsmodule,
MODPATH      fÅr Åbersetzte Haupt- (Programm-) Module:
                 Auf  diesen  beiden  Pfadlisten  sucht  der  Linker  (nicht  der
                 Loader!)  nach  einzubindenden  Modul-Codes,  die  vom  zu
                 linkenden Programm importiert werden.
                 Im ersten angegebenen Pfad legt der Compiler neu erzeugte
                 (Åbersetzte) Implementations- bzw. Haupt-Modul-Codes ab.

SOURCEPATH  fÅr alle Quelltexte (Sourcen):
                 Hier suchen Compiler und Editor nach den Quelltexten, wenn
                 diese nicht auf dem angegebenen Pfad zu finden sind.
2.2  Bedienung: Shell                                                     2 - 37
________________________________________________________


Die Modula-Shell selbst (bzw. deren Loader) sucht alle Module, die ausgefÅhrt
werden sollen, in der DEFAULTPATH-Liste. Das gilt auch fÅr Module, die per
LOAD-Anweisung in der Batch-Datei geladen werden sollen. Eventuelle LOAD-
Anweisungen in der Batch-Datei, die beim Shell-Start automatisch ausgefÅhrt
wird,  sollten  also  hinter  der  dort  -  notwendigerweise  -  aufgefÅhrten
DEFAULTPATH-Definition stehen.

Auûerdem steht die DEFAULTPATH-Liste Systemprogrammen, wie dem Make,
zur VerfÅgung: Die Variable StdPaths im Modul ShellMsg enthÑlt eine kodierte
Form dieser Liste (vom Datentyp PathList). In der Dokumentation (Definitions~
modul) zum Modul Paths erfahren Sie, wie Sie durch einfachen Aufruf einer
Prozedur eine Datei in allen Verzeichnissen dieser (oder auch einer anderen)
Pfadliste suchen lassen kînnen. Um auf einfache Weise anwenderfreundliche
Programme zu verwirklichen, ist die Benutzung dieser Suchfunktion vor dem
Zugriff  auf  Dateien  sehr  empfehlenswert.  Um  die  Pfadliste  fÅr  gelinkte
Programme, also auûerhalb der Shell, anzulegen, gibt es das Modul InitPathList
im UTILITY-Ordner.

Vorsicht!
      Es ist unbedingt darauf  zu  achten,  daû  nach  einer  Pfadlisten-
      Anweisung  die  in  den  folgenden  Zeilen  aufgefÅhrten  Pfade  alle
      mindestens  um  ein  Leerzeichen  eingerÅckt  sind  und  keine
      Leerzeilen bis zum Ende der Liste vorkommen!

Die Syntax der Pfadnamen wird weiter unten erklÑrt fÅr den Fall, daû Sie mit
ihr noch nicht vertraut sind.

Wird ein Pfadname mit einem Sternchen (und einem darauf folgenden Ordner-
Trennstrich,  also  "*Å")  angefÅhrt,  wird  es  von  den  Systemprogrammen
(Compiler, Make, Shell usw.) durch den Pfad der Shell ersetzt (dieser steht im
Modul ShellMsg). Damit kînnen die Pfade so angegeben werden, daû die Shell
zusammen mit ihren Unterverzeichnissen problemlos in jeden beliebigen Ordner
(einer ausreichend groûen Harddisk) kopiert werden kann und erstmal keine
Korrekturen an den Pfadlisten vorgenommen zu werden brauchen, um mit dem
System arbeiten zu kînnen. Dies wurde Åbrigens auch bei der Zusammen~
stellung des Megamax-Systems  auf  Ihren  erworbenen  Disketten  ausgenutzt
(siehe die Batch-Datei MM2SHELL.M2B).

Am  Ende  der  Pfadliste  kann  ein  Fragezeichen  als  Dateiname  eingetragen
werden.  Dies  bewirkt,  daû  die  GEM-Dateiauswahl-Funktion  (File-Selektor)
aufgerufen wird, wenn eine gesuchte Datei nicht auf den vorigen Pfaden der
Liste gefunden werden kann.
2.2  Bedienung: Shell                                                     2 - 38
________________________________________________________


Der Aufbau einer Pfadangabe ist zwar nicht Megamax-spezifisch,  soll  aber
doch noch kurz erlÑutert werden:

* Die Laufwerksangabe durch Laufwerksbuchstaben und Doppelpunkt ist optio~
nal; wenn sie fehlt, wird das gerade aktive Laufwerk benutzt.

* Der folgende SchrÑgstrich gibt an, daû vom Stamm-Inhaltsverzeichnis (auch
Wurzel- oder Root-Directory) des Laufwerks ausgegangen wird. Fehlt er, dann
beginnt der Pfad im gerade aktiven Verzeichnis, das sich der Atari zu jedem
Laufwerk einzeln merkt.

*  Beginnen  Sie  im  aktiven  Verzeichnis,  so  kînnen  Sie  zunÑchst  ins
Åbergeordnete Verzeichnis heraufsteigen, indem Sie '..Å' folgen lassen.

* Nachdem nun der Ausgangspunkt des Pfades definiert ist, kînnen Sie sich
von dort beliebig tief in Ordner (Subdirectories) 'hineinwÅhlen'. Die Ordnerna~
men werden in der Reihenfolge angegeben, in der Sie immer tiefer in sie 'hin~
eintauchen'. Zur Trennung der Namen dient wieder der SchrÑgstrich.

* Am Ende eines Pfadnamens sollte immer ein SchrÑgstrich stehen (ggf. fÅgt
die Shell beim Einlesen des Pfades selbst einen an).

Um die Verwirrung etwas zu lindern, hier ein Beispiel. Betrachten wir folgende
Directory-Struktur:

      Disk A:             <Wurzel>
                             5 8
                  MODULA      ZAEH
                     5 8
              SHELL     LIBRARY
                           5 8
                       IMP      DEF

Angenommen, Sie wollen einen Pfad ins 'DEF'-Verzeichnis konstruieren (etwa
fÅr die DEFPATH-Liste in der Batch-Datei). Die ausfÅhrlichste Angabe wÑre
"A:ÅMODULAÅLIBRARYÅDEFÅ".  Das  funktioniert  natÅrlich  nur,  solange  die
Diskette in Laufwerk A bleibt... Aber  Sie  wissen  ja,  daû  gerade  die  Shell
gestartet worden ist - also wird sicher das richtige Laufwerk gerade aktiv
sein. Daher genÅgt die Angabe "ÅMODULAÅLIBRARYÅDEFÅ".

Beide  oben  genannten  Pfade  beginnen  im  Wurzelverzeichnis.  Wenn  der
MODULA-Ordner in einen anderen Ordner hineinkopiert wird (oder wenn Sie
LIBRARY und SHELL  direkt  ins  Wurzelverzeichnis  legen),  schicken  Sie  den
Rechner auf den Holzweg. Noch flexibler ist es daher, den Pfad relativ zum
aktiven  Verzeichnis  (SHELL,  nehmen  wir  an)  anzugeben!  ..ÅLIBRARYÅDEFÅ
tut's,  solange  der  LIBRARY-Ordner  neben  dem  SHELL-Ordner  in  einem
Åbergeordneten Verzeichnis steht.
2.2  Bedienung: Shell                                                     2 - 39
________________________________________________________


Umgang mit mehreren Projekten

Unter einem Projekt bei Megamax Modula-2 verstehen wir die Arbeit an einem
Programmpaket, das mehrere Module umfaût und das seine eigene, individuelle
Umgebung hat.

Ein Beispiel: Nehmen wir an, Sie arbeiten abwechselnd an zwei Programmen,
das eine sei ein kleines Terminal-Programm (zur Daten-Kommunikation Åber
Telefon), das andere ein Grafikprogramm zur Darstellung von physikalischen
VorgÑngen. Nun bietet es sich an, die jeweils projekt-spezifischen Dateien in
getrennten Ordner zu sammeln. Denken wir uns, Sie hÑtten zwei Ordner auf
Ihrer  Harddisk  (ja,  sowas  braucht  man  heutzutage),  je  einen  fÅr  jedes
Programmpaket,  in  denen  die  jeweiligen  Quelltext-Dateien  abgelegt  werden
sollen.

Da die beiden Programme vielleicht auch verschiedene Optionen (Stack-Grîûe,
Treiber-Module usw.) benîtigen, sollten Sie sich dafÅr je eine Projekt-Datei
anlegen. Diese Projekt-Dateien sind praktisch die Parameter-Dateien mit den
Endungen M2P.  Wenn  Sie  alles  richtig  installiert  haben,  kînnen  Sie  durch
einfache Aktionen zwischen Ihren beiden Projekten hin- und herwechseln und
finden bei beiden die individuellen Einstellungen und Arbeitsdateien vor.

Kommen wir also zum Erstellen einer Projekt-Datei. Zuerst erstellen Sie eine
Batch-Datei, die die gewÅnschten Suchpfade enthÑlt. Nehmen Sie am besten
Ihre Standard-Batch-Datei MM2SHELL.M2B und verÑndern Sie die Pfadlisten
darin, so daû die zusÑtzlichen Ordner fÅr das jeweilige Projekt berÅcksichtigt
werden. Am besten ist es, diese Pfade immer als erstes in die Listen  zu
schreiben,  damit  sie  Vorrang  vor  den  restlichen  haben.  Speichern  Sie  die
Batch-Datei dann unter einem anderen Namen wieder ab.

Daraufhin  tragen  Sie  den  Namen  hinter  der  Batch-Datei  in  den  Shell-
Parametern ein. Dann vergeben Sie auch einen neuen Namen fÅr die dortige
Parameter-Datei. Nun kînnen Sie Ihr Disk-Verzeichnis des  Projekt-Ordners
îffnen, die verwendeten Quelltexte als Arbeitsdateien eintragen und sonstige
Parameter einstellen, beispielsweise die  Stack-Grîûe  oder,  wenn  das  feste
Linken  des  Programms  îfter  benîtigt  wird,  auch  die  Linker-Optionen
(verwendete Konfigurationsmodule usw.).

Sehr nÅtzlich ist auch das Erzeugen einer Make-Datei zum Hauptmodul des
Projekts  (siehe  Kapitel  2.7  zum  Erstellen  einer  Make-Datei),  die  dann  als
Default-Make in den Umgebungsinformationen eingetragen wird.

Sind alle Einstellungen vorgenommen, kann durch DrÅcken von Control-X, der
Anwahl des MenÅpunkts Parameter sichern oder einfach durch Verlassen der
Shell mit Parameter-Sicherung  die  vorher  als  Parameter-Datei  eingegebene
Projekt-Datei  gespeichert  werden.  Wenn  Sie  dann  die  Shell  neu  aufrufen,
2.2  Bedienung: Shell                                                     2 - 40
________________________________________________________


wird  erstmal  wieder  die  Standard-Einstellung  aus  der  Parameter-Datei
MM2SHELL.M2P  vorgenommen.  Sie  kînnen  nun  aber  jederzeit  die  neu
angelegte Projekt-Datei ausfÅhren, um deren Einstellungen wieder hervorzu~
holen, z.B. indem Sie die Projekt-Datei im Disk-Inhaltsverzeichnis suchen und
durch Doppelklick oder durch Ziehen auf das AusfÅhren-Symbol aktivieren. Ein
anderer,  sehr  bequemer  Weg  ist,  die  oft  verwendeten  Projekt-Dateien  als
Tools in der Standard-Batch-Datei einzutragen.

Sie kînnen sogar schon beim Start der Shell dafÅr sorgen, daû statt  der
Standard-Parameter-Datei MM2SHELL.M2P eine andere verwendet wird: Dazu
mÅssen Sie die Shell unter dem GEM-Desktop fÅr Dateien der Endung M2P
anmelden. Dann genÅgt ein Doppelklick auf die Projekt-Datei, um die Shell zu
starten und das Projekt sofort vor sich  zu  haben.  Um  dies  zu  erreichen,
klicken  Sie  im  GEM-Desktop  die  Shell  MM2SHELL.PRG  einfach  (also  nicht
starten!) an. Dann wÑhlen Sie in der MenÅzeile Extras/Anwendung anmelden.
Dort  geben  Sie  dann  als  geforderte  Endung  "M2P"  ein  und  klicken  auf
installieren. Zuletzt wÑhlen Sie Arbeit sichern an. Daraufhin kînnen Sie nun
auf jede M2P-Datei doppelt klicken, um die Shell damit zu starten. (Bei Ñlteren
TOS-Versionen mÅssen Sie aber darauf achten, daû sich die Projekt-Dateien
im  Verzeichnis  der  Shell  befinden,  da  diese  sonst  nicht  gefunden  wird.
Probieren Sie dies ggf. aus.)
2.2  Bedienung: Shell                                                     2 - 41
________________________________________________________


Fehlermeldungen der Shell

Beim Programmieren kann erfahrungsgemÑû einiges schiefgehen. Im Megamax
Modula-System gibt es vier Kategorien von Fehlermeldungen, die  in  solchen
FÑllen erscheinen kînnen.

* Ladefehler kînnen auftreten, wenn ein Modul ausgefÅhrt werden soll und nicht
alle benîtigten Module zur VerfÅgung stehen. Die  Fehlermeldungen  beginnen
mit '<Modulname> konnte nicht ausgefÅhrt werden', gefolgt von einer Beschreibung
des Problems. Diese Meldungen werden vom  Loader  erzeugt;  ErlÑuterungen
finden Sie im Kapitel 5.

* Laufzeitfehler treten bei der AusfÅhrung fehlerhafter Anwenderprogramme
auf. Die Fehlerbeschreibung, der Modul- und der Prozedurname werden ange~
zeigt. Sie kînnen sich entscheiden zwischen

    Back/Forward:
    erlauben die Suche nach der Fehlerposition im Text (siehe 2.5);
    Exit
    verlÑût die Fehlersuche und bietet drei weitere Mîglichkeiten:

    Cont
    setzt das Programm fort. Bei manchen fatalen Fehlern ist eine sinnvolle
    Fortsetzung nicht mîglich, und diese Option wird nicht angeboten.
    Quit
    bricht das Programm ab und kehrt zurÅck zur Shell.
    Edit
    lÑût die durch Forward/Back bestimmte Fehlerstelle suchen und im Editor
    anzeigen, sofern der Quelltext des Moduls vorhanden ist. (siehe 2.5)

Eine kommentierte Liste der Fehlermeldungen steht im Anhang A.2.

*  öbersetzungsfehler  entstehen  natÅrlich  beim  Compilieren.  Eine  Liste  der
Fehlermeldungen  enthÑlt  der  Anhang  A.1;  wie  Sie  auf  öbersetzungsfehler
reagieren kînnen, beschreibt Kapitel 2.4.

* Bedienungsfehler in der Shell. So kommen Meldungen, wenn Sie mehr als
sieben  Fenster  îffnen,  mehr  als  zehn  Arbeitsdateien  anfordern,  mehr
Programme laden wollen, als freier Speicher zur VerfÅgung steht, usw. Die
Meldungen sind alle selbsterklÑrend.
2.2  Bedienung: Shell                                                     2 - 42
________________________________________________________





















                               Diese Seite wurde blank geputzt.
2.3  Bedienung: Editor                                                    2 - 43
________________________________________________________


2.3   Editor


EinfÅhrung

Als Teil des Megamax Modula-Systems haben Sie auch einen eigenen Editor
erhalten (genau genommen sogar zwei!). Er dient zur Eingabe (und Korrektur)
der  Programmtexte.  Die  Texte  werden  als  Standard-ASCII-Dateien  (direkt
lesbare Textdateien) abgelegt und dem Compiler Åbergeben.

Der Editor ist speziell zum Schreiben von Programmtexten konzipiert worden.
Ihre  Briefe  werden  Sie  vielleicht  auch  weiterhin  mit  einer  speziellen
Textverarbeitung  schreiben  wollen;  zum  Programmieren  bietet  Ihnen  der
Megamax-  Editor  aber  eine  Reihe  nÅtzlicher  Sonderfunktionen  bei  Åber~
sichtlicher Bedienung.


Wahl des Editors

Prinzipiell kînnen Sie jeden Editor verwenden, der normale Textdateien erzeugt
- die optimale Zusammenarbeit mit Shell und Compiler des Modula-Systems
erlauben allerdings nur die beiden mitgelieferten Editoren. (Die Zusammenarbeit
der Programme wird durch die Shell organisiert. Da Sie diese im Quelltext
erhalten, kînnen Sie auch eine Anpassung fÅr Ihren Lieblingseditor vornehmen,
wenn Sie sich nicht umstellen mîchten - die wichtigste énderung dÅrfte die
öbergabe der Fehlerposition und -meldung betreffen.)

Unser Standard-Editor heiût GME. Unter anderem erlaubt er, mehrere Texte
im  Speicher  zu  bearbeiten,  bietet  jedoch  bisher  noch  keine  echten  GEM-
Fenster,  statt  dessen  werden  die  Texte  auf  Befehl  abwechselnd  auf  dem
Bildschirm angezeigt. Die Bedienung ist dem Konzept des legendÑren Editors
Word-Star nachempfunden. Der GME ist einfach zu bedienen, vor allem wegen
seiner GEM-MenÅleiste, deswegen empfehlen wir den Programmier-Einsteigern
diesen Editor zur Benutzung.

Alternativ bieten wir einen kompakteren und schnelleren Editor, der allerdings
mehr Eingewîhnung verlangt: Der Gepard-Editor (GEP ED). Auch er arbeitet
                                                         _
optimal  mit  dem  Entwicklungssystem  zusammen.  Er  ist,  wie  der  GME,  in
Modula geschrieben, hat jedoch einige deutliche  Optimerungen  in  Assembler
erfahren. Er belegt nur ca. 50KByte (GME: 150) des Speichers in der Shell
und ist deshalb bei knappem Speicher dem GME vorzuziehen.
2.3  Bedienung: Editor                                                    2 - 44
________________________________________________________


Der GME wurde aus einem Universaleditor  entwickelt,  der  auch  zur  Text~
verarbeitung geeignet war. DemgegenÅber ist der Gepard-Editor speziell auf
das Programmentwickeln zugeschnitten und bietet keine GEM-OberflÑche - fÅr
die  Veteranen:  Sein  Konzept  ist  dem  des  UCSD-Programmeditors  nach~
empfunden, nur ist er wesentlich schneller. Der Editor ist gewîhnungsbedÅrftig,
aber  unglaublich  effektiv  fÅr  Vielprogrammierer  -  wir  Megamax-Entwickler
verwenden ihn alle!

Beide Editoren erlauben es, den Programmtext im  Speicher  zu  Åbersetzen,
ohne daû der Text abgespeichert und der Editor verlassen zu werden braucht.
Dies verkÅrzt die Turn-Around-Zeit (Zeit zwischen Editieren, öbersetzen und
Starten) deutlich.

Auch Tempus (von CCD) lÑût sich sehr bequem als Editor verwenden. Einzig
die Fehleranzeige vom Compiler beherrscht er nicht - die Shell sieht aber eine
Option vor, so daû Compilerfehler  vor  dem  Editor-Start  angezeigt  werden.
Nach einer BestÑtigung mit der Return-Taste wird der Editor gestartet und er
zeigt dann die Fehlerposition im geladenen Text an.

Bei Tempus kînnen Sie ein Programm zwar nicht im Speicher direkt Åberset~
zen lassen, aber der Komfort kommt auch hier nicht zu kurz: DrÅcken Sie
Control-1 (Sie mÅssen die Eins vom rechten Ziffernblock verwenden!), wird der
Text automatisch gespeichert, Tempus verlassen und automatisch der Compiler
gestartet, der dann den Programmtext Åbersetzt, den Sie von der Shell an den
Editor beim Aufruf Åbergeben hatten (und das ist in der Regel auch der, den
Sie dann mit Control-1 zum öbersetzen abspeichern lassen). Control-2 teilt
der Shell mit, daû sie nach erfolgreicher öbersetzung dieses Modul starten
soll,  Control-3  bewirkt  nicht  das  öbersetzen  des  geladenen  Programms,
sondern aktiviert das Default-Make, das in der Shell auch Åber die Taste M
auslîsbar ist. Schlieûlich lÑût Control-4 nach dem - erfolgreichen - Make-Lauf
das Programm wiederum gleich starten.

Leider lassen sich die Versionen 2.00 bis 2.04 von Tempus nicht resident in
der Shell laden: Beim wiederholten Start in der Shell wÅrde er nicht mehr
funktionieren. Wenden Sie sich in diesem Falle ggf. an CCD, um eine neuere,
korrigierte Version zu erhalten. Alle anderen Versionen lassen sich resident
laden, aber benîtigen sehr (wirklich sehr) viel mehr Speicher als die Programm~
datei lang ist. Auch hier sollten Sie sich nicht verwirren lassen - das muû so
sein!
2.3  Bedienung: Editor                                                    2 - 45
________________________________________________________


Vorbereitungen und Parameter fÅr den Editor

Bevor der Editor Ihres Ver~
trauens von der Shell richtig
aufgerufen   werden   kann,
muû    zumindest    dessen
Dateiname bekannt  gemacht
werden.      Unter      dem
MenÅpunkt Parameter/Editor
sind  alle  Optionen  fÅr  den
Editor erreichbar. Hier kann
hinter Editor:  dessen  Name
eingetragen werden. Soll der
GME verwendet werden, kann dieser Name, wie im Bild zu sehen, verwendet
werden. FÅr den  Gepard-Editor  ist  GEP ED  einzutragen,  bei  allen  anderen
                                            _
Editoren ist ihr vollstÑndiger Dateiname inclusive seiner Endung zu verwenden
(Tempus: TEMPUS.PRG). Bei Editoren, die andere Dateien nachladen mÅssen,
wie eine RSC-Datei oder Konfigurationen, muû auûerdem deren Pfadname mit
angegeben werden. Haben Sie beispielsweise einen Editor namens EDIT.PRG,
der im Ordner C:ÅTEXTE mitsamt seiner Resource-Datei EDIT.RSC steht, ist
C:ÅTEXTEÅEDIT.PRG einzutragen.

Die mitgelieferten Editoren kînnen, da sie mit dem Megamax-Modula-System
erstellt  wurden,  auf  die  Pfadlisten  in  ShellMsg  zugreifen,  speziell  auf  die
Suchpfade fÅr die Quelltexte (Åber SourcePath in Batch zu bestimmen). So
brauchen  Sie  beim  Laden  eines  Textes  diesen  nicht  erst  in  den  vielen
Verzeichnissen zu suchen, statt dessen sucht der Editor die Datei selbstÑndig
auf den Source-Pfaden. Wird ein anderer Editor verwendet, kann die Shell das
Åbernehmen, wenn sie beim Editor-Aufruf den Dateinamen Åbergibt. Dazu muû
nur die Option Shell durchsucht Source-Pfade fÅr den Editor aktiviert sein.
Dann reicht es beispielsweise, in der Shell mit Control-P den Namen eines
Textes ohne dessen Pfad einzutippen und dann den Editor mit Control-E zu
starten.

Wenn Editoren es nicht vermîgen, eine Fehlermeldung beim Aufruf Åbergeben
zu bekommen, um sie dann anzuzeigen, muû die Shell dies erledigen. Dazu
dient der Schalter Shell zeigt Compiler-Fehler vor Editor-Aufruf an.  Ist  er
eingeschaltet, zeigt die Shell nach einem Compiler-Fehler diesen an, und erst
nach DrÅcken der Return-Taste wird der Editor gestartet. VertrÑgt der Editor
die  Fehlermeldung  nicht  (z.B.  TEMPUS),  muû  auûerdem  weiter  unten  bei
Argumentzeile der Schalter Fehlermeldung deaktiviert sein.

Die TemporÑren Dateien dienen zur öbergabe von Informationen an den Editor
und zurÅck an die Shell. Der einzige uns bekannte Editor, der diese Art der
ParameterÅbergabe unterstÅtzt ist der Emacs-Editor. Der ist programmierbar,
und so hat ein Megamax-Anwender ein Programm erstellt, das es erlaubt, von
der  Shell  Textname,  Fehlermeldung  und  -position  anzunehmen  und  beim
2.3  Bedienung: Editor                                                    2 - 46
________________________________________________________


Verlassen die Shell wiederum zum Compiler-Start zu veranlassen, wie dies
auch bei den von den beiden Megamax-Editoren mîglich ist. Sind Sie an dieser
EMACS-Einbindung interessiert, wenden Sie sich an Application Systems.

In  der  Argumentzeile  an  den  Editor  kînnen  Textname,  Fehlermeldung  und
-position  vom  Compiler  bzw.  von  der  Shell  beim  Aufruf  an  den  Editor
Åbergeben werden. Die Megamax-Editoren erlauben alle öbergaben. TEMPUS
beispielsweise  erlaubt  die  Angabe  der  Cursorposition,  jedoch  nicht  die  der
Meldung, sodaû diese dann zu deaktivieren wÑre.

Wollen Sie einen Editor verwenden, der noch andere  Bedingungen  an  seine
Benutzung stellt, z.B. daû bei der Fehlerposition die Werte fÅr Spalte und Zeile
zu vertauschen wÑren, kînnen Sie dies selbst an der Shell-Source vornehmen:
Der Editor-Aufruf wird in der Funktion hdedit vorbereitet. Die Fehlermeldung
vom Compiler wird bei einem der Aufrufe von hdedit aufbereitet. Nach der
Anpassung muû die Shell neu Åbersetzt und dann gelinkt werden. Zum Linken
bietet  sich  der  Batch  LINKSHEL.M2B  an,  der  dazu  alle  erforderlichen
Parameter einstellt.


Aufruf des Editors

Den Editor kînnen Sie auf drei Wegen starten:

    * Aus der Shell: Klicken Sie das Editor-Symbol auf der Ar~
    beitsflÑche an (Editieren der Arbeitsdatei)  oder  legen  Sie
    einen Dateinamen auf dem Editor-Symbol ab. Wollen Sie ein
    neues Dokument beginnen, so geben Sie zunÑchst einen leeren Namen an.

    * Nach öbersetzungsfehlern: Je nach Wahl der Editor-Optionen ruft die
    Shell den Editor sofort auf oder bietet Ihnen erst den Aufruf des Editors
    an. Wenn Sie dann diese Option wÑhlen, wird automatisch der fehlerhafte
    Text geladen, der Cursor wird an der Fehlerstelle positioniert, und in der
    Kopfzeile des Editors erscheint eine Fehlerbeschreibung.

    * Nach Laufzeit-Fehlern: Wenn Ihnen der Text des fehler~
    haften Programms zur VerfÅgung steht, kînnen Sie  nach
    Laufzeitfehlern die Scanner-Funktion wÑhlen. Der Compiler
    ermittelt die Textposition,  an  der  der  Fehler  auftrat,  und  zeigt  Ihnen,
    genau wie bei öbersetzungsfehlern, die Fehlerstelle mit Beschreibung im
    Editor.


Bedienung des Editors

Die Bedienung der beiden Editoren wird in separaten Anleitungen beschrieben,
die Sie im Anhang finden.
2.4  Bedienung: Compiler                                                 2 - 47
________________________________________________________


2.4    Compiler

Hier erlÑutern wir die eigentliche Handhabung des Modula-Compilers. Wenn Sie
sich Åber den Åbersetzten Sprachumfang oder die Compiler-Optionen in Quell~
texten informieren wollen, lesen Sie bitte Kapitel 3 dieses Handbuchs.


Aufruf des Compilers

Der Compiler wird aus der Shell gestartet, indem Sie
* eine Textdatei aus einem Disk-Fenster mit der Maus greifen
  und auf das Compiler-Symbol schieben;
* das Compiler-Symbol doppelt anklicken, um die Arbeitsdatei zu Åbersetzen;
* die Taste C drÅcken, um die Arbeitsdatei zu Åbersetzen (o. Ctrl-C fÅr die
  aktuelle Datei).

Der Pfad der Quelldatei muû nicht angegeben werden - der Compiler sucht die
Datei automatisch auf den Source-Pfaden (SourcePath in der Batch-Datei).

Falls die angegebene Textdatei vom Compiler nicht gelesen werden kann, fragt
der Compiler Sie nochmals nach einem Datei-Namen. Durch eine Leereingabe
kînnen Sie den Compiler dann auch wieder verlassen. Wenn der Text gefunden
wird, beginnt der Compiler die öbersetzung.

Die  Endungen  (Suffix,  Extension)  der  Quelldatei-Namen  sind  beliebig.  Bei
Megamax Modula verwenden wir in der Regel
  .M  fÅr Haupt-Modul-Quellen (Bsp: MSHELL.M, TEXTDEMO.M),
  .I   fÅr Implementationsmodul-Quellen (Bsp: DEBUG.I, MOSCONFI.I),
  .D  fÅr Definitionsmodul-Quellen (Bsp: INOUT.D, DEBUG.D).

Benîtigte Definitionsmodule  werden  automatisch  gesucht.  Als  Name  werden
dabei die ersten 8 Zeichen des Modulnamens (also nicht des Dateinamens!),
gefolgt von der Extension .DEF, angenommen. Diese Dateien werden auf allen
Pfaden  gesucht,  die  Sie  in  der  Batch-Datei  als  DefPath  angegeben  haben
(siehe Kapitel 2.2 - Shell).
2.4  Bedienung: Compiler                                                 2 - 48
________________________________________________________


Die erzeugten Dateien

Den  Namen  der  erzeugten  Code-Datei  bestimmt  der  Compiler  ebenfalls
automatisch. Wieder werden die ersten 8 Zeichen des Modulnamens verwendet;
die Extension lautet

  .MOD  fÅr Programm-Modul-Codes,
  .DEF   fÅr Definitions-Codes und
  .IMP   fÅr Implementations-Codes.

Andere  Endungen  kînnen  Sie  Åber  die  Compileroption  $E  einstellen  (siehe
Kapitel 3.3, Compileroptionen), z.B. MOS oder MTP (Ñquivalent zu TOS und
TTP bei gelinkten Programmen, wÑhrend MOD wie PRG behandelt wird).

Die Standard-Endungen kînnen Sie aber auch verÑndern - nÑheres dazu in
Kapitel 5.

Der  Ausgabepfad  fÅr  das  Åbersetzte  Modul  wird  normalerweise  Åber  die
Suchpfade bestimmt, die in der Batch-Datei stehen, welche beim Start der
Shell ausgefÅhrt wird: Der Compiler wÑhlt jeweils den ersten Pfad aus der
Pfadliste fÅr Definitions-, Implementations- oder Programm-Module. öber die
Batch-Anweisungen  DEFOUT,  IMPOUT  und  MODOUT  kînnen  aber  auch
individuelle  Ausgabepfade  eingestellt  werden  -  sind  dahinter  keine  Pfade
angegeben, wird die Code-Datei in das Verzeichnis geschrieben, aus dem die
jeweilige Quell-Datei stammt.

Ist allerdings ein Pfad Åber die Batch-Anweisung MainOutputPath oder Åber die
Compiler-Parameter  in  der  Shell  (siehe  folgenden  Abschnitt  Compiler-
Parameter)  eingegeben,  hat  dieser  Vorrang  vor  allen   anderen   Pfad-
Bestimmungen!


öbersetzungsfehler

Findet der Compiler in dem Åbersetzten Programmtext einen Fehler, bricht er
den öbersetzungsvorgang ab und meldet dies der Shell, die dann entweder den
Editor  sofort  aufruft  oder  erst  ein  Fenster  îffnet,  in  dem  sie  Ihnen  die
Fehlermeldung  prÑsentiert  und  Sie  vor  die  Wahl  stellt,  die  Fehlerstelle  im
Editor zu korrigieren oder die öbersetzung ganz abzubrechen.

Um als Fehlermeldung eine Beschreibung des Problems ausgeben zu kînnen,
benîtigt der Compiler die Fehlerdatei. Sie heiût normalerweise 'MODULA.ERR'
Fehlt diese Datei, dann wird nur eine Fehlernummer angezeigt, deren Bedeu~
tung Sie im Anhang A.1 des Handbuchs nachschlagen kînnen. Dort finden Sie
zu vielen Fehlermeldungen auch zusÑtzliche Hinweise, die bei der Behebung des
Fehlers helfen kînnen.
2.4  Bedienung: Compiler                                                 2 - 49
________________________________________________________


Compiler-Parameter

öber die Anwahl Parameter/
Compiler im MenÅ der Shell
kînnen Sie die globalen Op~
tionen  des  Compilers  ein~
stellen.

Ist  Ausgabe  der  Kurzmel~
dungen  mit  einem  HÑkchen
versehen, werden die Namen
der importierten Module, der
Åbersetzten Prozeduren und
die  Anzahl  der  Åbersetzten
Zeilen ausgegeben. Die gleiche Funktion kann  in  Programmtexten  durch  die
Compileroption $Q gesteuert werden (siehe 3.3, Compilerdirektiven; dort finden
Sie auch Tips zur Anwendung dieser Option).

Ausgabepfad:  Soll  ein  Åbersetztes  Modul  nicht  auf  dem  Pfad  gespeichert
werden,  der  in  der  Start-Batch-Datei  fÅr  die  entsprechende  Modulart
angegeben ist, kann hier ein anderer Pfad eingetragen werden, der dann auf
alle erzeugten Modularten wirkt. Dieser Pfad kann auch mit dem Batch-Befehl
MAINOUTPUTPATH bestimmt werden. Siehe auch Kapitel 2.2 zu den Batch-
Anweisungen.

Die Direktiven erlauben die Beeinflussung des Verhaltens des Compilers beim
öbersetzen. Beispielsweise kînnen Sie bestimmen, ob zusÑtzlicher Code fÅr
LaufzeitprÅfungen erzeugt werden soll. NÑheres zur Funktion den Direktiven in
Kapitel 3.4. Statt die Direktiven in den Quelltext einzufÅgen, kînnen sie hier in
der Eingabezeile voreingestellt werden. Jeder Direktiven-Buchstabe muû dabei
mit  einem  Plus-  bzw.  Minuszeichen  eingeleitet  werden,  mehrere  Direktiven
werden  durch  Leerzeichen  getrennt.  Im  Bild  sehen  Sie  beispielsweise  die
Direktiven $Z+ und $R-.

In der Library MM2DEF.M2L sind (fast) alle Åbersetzten Definitionsdateien der
Megamax-Bibliotheken  zusammengefaût.  Dies  spart  Platz  auf  der  Disk  und
beschleunigt den öbersetzungsvorgang. Normalerweise sollte deshalb der Name
der  Datei  (mit  Pfad)  unter  Bibliothek  eingetragen  sein.  Ist  eine  Bibliothek
angegeben, haben die darin enthaltenen DEF-Dateien immer Vorrang vor den
separaten Definitions-Modulen in den Ordnern, die in der Pfadliste DefPath im
Batch angegeben werden kînnen! Unter UmstÑnden kann dies nicht erwÅnscht
sein - dann braucht einfach nur der Bibliotheksname gelîscht zu werden. Zur
Kontrolle, woher ein Definitionsmodul beim öbersetzen geladen wird, kann die
Anzeige der Kurzinformationen aktiviert werden.

Die Textdatei mit den Fehlermeldungen fÅr den Compiler wird in Fehlerdatei
eingetragen, ggf. mitsamt dem Pfad.
2.4  Bedienung: Compiler                                                 2 - 50
________________________________________________________


Protokoll: Auf Wunsch erzeugt der Compiler  ein  öbersetzungsprotokoll.  Die
Ausgabebreite  (Anzahl  Spalten)  und  der  Name  der  Protokolldatei  (mit
Pfadangabe) kînnen eingestellt werden. Der Inhalt der Protokolldatei wird in
einem speziellen Abschnitt auf einer der folgenden Seiten beschrieben.


Definitions-Codes: Bibliothek und Komprimierung

Die  Åbersetzten  Definitionsmodule  werden  vom  Compiler  praktisch  immer
benîtigt,  darÅber  hinaus  stîren  sie  nur,  weil  sie  sonst  in  keiner  Weise
Verwendung finden.

Deshalb haben wir es ermîglicht, daû die Definitions-Codes alle in einer Datei
zusammengefaût werden kînnen. Damit ist das Weiterkopieren einfacher, es
werden nicht unzÑhlige Verzeichnis-EintrÑge auf der Disk verschwendet, und
der Compiler kann sogar schneller darauf zugreifen.

Diese Datei, in der die Definitions-Codes zusammengefaût sind, nennen  wir
Bibliotheks-Datei oder auch Library (das ist engl. und heiût in etwa das selbe).
Das Lesen der einzelnen Definitionen aus der Library ist fÅr den Compiler sehr
einfach.  DemgegenÅber  ist  es  aber  aufwendig,  stÑndig  neue  Dateien  darin
einzufÅgen  oder  auszutauschen.  Darum  bietet  es  sich  an,  nur  solche
Definitionen in die Library einzufÅgen, die keines stÑndigen Erneuerns bedÅrfen.
Die trifft vor allem auf die beim Megamax-System mitgelieferten MOS-Module
zu - die Ñndern hîchstens wir, und das kînnen wir dann gerade noch selbst
bewÑltigen.  Sie  selbst  kînnen  also  auch  Definitions-Codes  hinzufÅgen,  nur
sollten Sie sich dieses Aspekts bewuût sein - wird die Definition verÑndert,
muû sie in der verwendeten Library aktualisiert werden, denn der Compiler
kann neu Åbersetzte Definitionen nicht automatisch in der Library ablegen, und
die Library hat immer  Vorrang  vor  den  Definitions-Codes  in  den  normalen
Verzeichnissen.

Die Definitions-Codes in die Library-Datei einzufÅgen, hat also zwei Vorteile:
Erstens sind sie darin hÅbsch  und  unauffÑllig  verpackt,  zweitens  kann  der
Compiler schneller darauf zugreifen, als dies bei den Einzeldateien mîglich ist.
NatÅrlich mÅssen Sie nicht alle Ihre Definitions-Codes in die Library quetschen,
denn der Compiler kann  sie  selbstverstÑndlich  auch  finden,  wenn  sie  ganz
normal  einzeln  in  den  Verzeichnissen  vorliegen:  Der  Compiler  sucht  beim
Importieren  zuerst  in  der  Library,  dann  in  der  DefPaths-Liste,  welche  im
Batch (meist MM2SHELL.M2B) bestimmt werden kann.

Mit dem Utility-Programm LibManager (ggf. erst Åbersetzen!) kînnen Sie die
Library  bearbeiten.  Sie  kînnen  sich  deren  Inhalt  ansehen  sowie  Dateien
einfÅgen, herauskopieren oder lîschen. Das Programm  ist  menÅgefÅhrt  und
daher (hoffentlich) selbsterklÑrend.
2.4  Bedienung: Compiler                                                 2 - 51
________________________________________________________


Eine weitere Optimierung besteht darin, die Definitionen zu komprimieren. Die
Codes in der mitgelieferten Library  MM2DEF.M2L  sind  bereits  komprimiert.
Dadurch ergibt sich eine Platzersparnis von ca. 55%. Der Compiler erkennt
beim Importieren automatisch, ob die Definitions-Codes komprimiert sind, und
expandiert sie dann selbststÑndig.

Jeder Definitions-Code kann komprimiert werden - der Compiler macht keinen
Unterschied, ob die Datei in der Library oder als Einzeldatei vorliegt.

Allerdings  hat  die  Kodierung  auch  einen  Nachteil:  Durch  das  notwendige
Expandieren dauert die Bearbeitung solcher Importe lÑnger. Sind Sie stolzer
Besitzer  einer  Hard-Disk,  sollten  Sie  daher  die  Dateien  der  Library  alle
dekomprimieren, damit der Compiler damit keine unnîtige Zeit mehr verbringen
muû.


Dekomprimieren der Dateien in der Library

Mit den Programmen Encode und Decode (UTILITY-Ordner) kînnen die Dateien
(eigentlich jede beliebige Datei) gepackt und wieder entpackt  werden.  Beide
Programme sind sehr einfach anzuwenden: Beim Start wird nach einer Datei~
angabe gefragt. Geben Sie dann entweder die einzelne Datei  an  oder  ver~
wenden Sie Wildcards (z.B. D:ÅMM2ÅDEFÅ*.*), um mehrere Dateien in einem
Verzeichnis auf einmal anzusprechen. Wundern Sie sich nicht, daû das Kompri~
mieren relativ lange dauert - wir haben bisher  nur  die  Dekomprimierungs-
Algorithmen zeitlich optimiert, weil dies erstmal am wichtigsten war.

Wollen Sie nun die gepackte Library MM2DEF.M2L dekomprimieren, kînnen Sie
nicht einfach die ganze Datei auf einmal entpacken. Statt dessen mÅssen Sie
erst mit dem LibManager alle Dateien herauskopieren, dann diese Einzeldateien
alle mit Decode dekomprimieren und am Ende alle Dateien wieder zu einer
neuen Library zusammenfÅgen (wiederum durch Verwendung von LibManager).


Protokoll

Ein öbersetzungsprotokoll kann bei der Suche nach Laufzeitfehlern oder auch
beim Verstehen eines fremden Programms nÅtzlich sein, da es  neben  dem
Quelltext noch zusÑtzliche Angaben enthÑlt.

Ein typisches Compilerprotokoll sieht z. B. so aus:

Megamax Modula Compiler 3.4h                            02-Nov-87   18:59

       1     0    D            MODULE Beispiel;
       2    0    D
2.4  Bedienung: Compiler                                                 2 - 52
________________________________________________________


       3    0    D            VAR     a: CARDINAL;
       4    0    D                      l: LONGCARD;
       5    0    D
       6    0    D            PROCEDURE square (c: CARDINAL): LONGCARD;
       7     1     D              BEGIN
       8    1     $00146           RETURN LONG (c) * LONG (c)
       9    1     $0015A        END square;
      10    0    D
      11     0    D            BEGIN
      12    0    $0016A        a := 55;
      13    0    $00174        l := square (a)
      14    0    $00180      END Beispiel.

Global variables:
                   $00002      l
                   $00000      a

Die erste Spalte enthÑlt durchlaufende Zeilennummern fÅr den Text. Dann folgt
ein ZÑhler fÅr die Schachtelungstiefe von  Prozeduren  und  Modulen,  dessen
Nutzen Sie bei etwas komplizierteren  Programmen  als  dem  obigen  Beispiel
erkennen werden.

Die dritte Spalte gibt die Adresse des Zeilenanfangs im Codemodul an. Diese
Angabe ist immer relativ zum Modulanfang zu verstehen. Die gleiche relative
Adresse meldet Ihnen das System auch, wenn ein Laufzeitfehler auftritt - im
Protokoll kînnen Sie so auf einen Blick die Fehlerzeile orten.  (Eine  andere
Mîglichkeit der Fehlersuche bietet allerdings der Scanner - siehe Kapitel 2.5
'Debugger'.) Wenn Deklarationszeilen Åbersetzt werden, erscheint statt einer
Adresse ein "D" im Protokoll.

Durch das EinfÅgen der zusÑtzlichen Spalten in das Protokoll passen die fol~
genden Zeilen des Programmtextes oft nicht mehr komplett auf eine Zeile von
80 Zeichen. Der Compiler bricht dann im Protokoll den Rest der Zeile um.
Wenn Sie allerdings das Protokoll (z.B. auf einem Drucker) mit mehr als 80
Zeichen Breite ausgeben wollen, kînnen Sie das Format im Parameter-MenÅ
auf andere ZeilenlÑngen einstellen.

Am Schluû der Protokolldatei folgt eine Liste der globalen Variablen mit den
jeweiligen relativen Adressen (die erste Variable liegt auf der rel. Adresse 0).

Die Startadressen der globalen Variablen und der Module kînnen Sie durch
verschiedene  Funktionen  in  den  Modulen  Loader  und  ModCtrl  ermitteln
(Beispielprogramme in Ordnern DEMO & UTILITY: GPA, ModList und TraceMod).
In  der  Shell  werden  durch  Alternate-R  jedes  vorhandene  Modul  sowie  die
Startadressen und LÑngen des Codes angezeigt, ebenso wie mit ModList.
2.5  Bedienung: Debugger                                                 2 - 53
________________________________________________________


2.5    Debugger

Megamax  Modula  unterstÅtzt  Sie  bei  der  Fehlersuche  durch  spezielle
Debugging-Funktionen  (die  öbersetzung  "Entwanzen"  kennen  Sie  vermutlich
schon). Ein spezielles  Debugger-Programm  werden  Sie  allerdings  vergeblich
suchen - beim Suchen helfen Ihnen der Compiler persînlich und das Imple~
mentations-Modul Debug. Diese Debug-Funktionen ersparen Ihnen die Åbliche
Fehlersuche bei compilierten Sprachen durch EinfÅgen diverser Testausgaben in
den Programmtext; sie helfen auch beim AufspÅren vertrackter Probleme.

FÅr  "harmlosere"  FÑlle  bietet  Megamax  Modula  eine  weitere  Hilfe  bei  der
Fehlersuche:  das  Auffinden  der  Programmstelle  im  Test,  an  der  ein
Laufzeitfehler  auftrat.  Diese  Scan-Funktion  ist  im  letzten  Abschnitt  dieses
Kapitels beschrieben.


öbersetzen im Debug-Modus

Wollen Sie ein Programm 'debuggen', fÅgen Sie bitte als erstes ein 'IMPORT
Debug' in die Importliste ein (falls das Programm im TOS-Modus lÑuft, also die
Endung MOS oder MTP hat, importieren Sie besser TOSDebug). Das Modul
Debug enthÑlt die Laufzeitfunktionen, die bei der Fehlersuche benîtigt werden,
und muû daher im RAM zur VerfÅgung stehen.

Mit der Compiler-Option (*$D+*) im Programmtext schalten Sie den Compiler
in  den  Debug-Modus  um.  FÅr  alle  Programmzeilen,  die  in  diesem  Modus
Åbersetzt werden, erzeugt der Compiler zusÑtzlichen Code, so daû diese Zeilen
schrittweise,  mit  Ausgabe   des   Programmtextes   und   der   berechneten
AusdrÅcke, ausgefÅhrt werden kînnen.

NatÅrlich  braucht  dieser  zusÑtzliche  Code  auch  zusÑtzlichen  Platz  im
Åbersetzten Modul. Auûerdem ist die AusfÅhrung von Programmen im Debug-
Modus wesentlich langsamer als im Normalfall - das 'Debuggen' einer 5000
mal durchlaufenen Schleife beschert Ihnen nicht nur jede Menge Bildschirm~
ausgaben sondern auch eine ausgedehnte Kaffeepause.

Sie  sollten  daher  die  Mîglichkeit  nutzen,  gezielt  einzelne  Programmteile
zwischen (*$D+*) und (*$D-*) einzuschlieûen und zu untersuchen. Oft ist es
sinnvoll,  zunÑchst  das  Hauptprogramm  zu  ÅberprÅfen  und  herauszufinden,
welche Prozedur fehlerhaft ist. In einem weiteren Compilerlauf kann dann diese
Prozedur im Debug-Modus Åbersetzt werden.
2.5  Bedienung: Debugger                                                 2 - 54
________________________________________________________


AusfÅhren im Debug-Modus

Ein  Programm,  das  im  Debug-Modus  Åbersetzt  wurde,  enthÑlt  zusÑtzliche
TRAP-Anweisungen,  die  das  Modul  'Debug'  abfÑngt.  'Debug'  sorgt  fÅr  die
Ausgabe  der  ausgefÅhrten  Zeilen  und  berechneten  AusdrÅcke;  zusÑtzlich
erlaubt das Modul die Beeinflussung der AusfÅhrung Åber die Tastatur.

Die  normale  Anzeige  jeder  Programmzeile  besteht  aus  der  Textzeile  des
Programms; darunter werden alle in dieser Zeile berechneten arithmetischen
AusdrÅcke ('Expressions' in der Syntaxbeschreibung) in der Reihenfolge ihrer
Berechnung  ausgegeben.  Die  Reihenfolge  dieser  Ausgaben  ist  nicht  immer
einfach zu Åberblicken und soll am folgenden Beispiel erlÑutert werden:

IF ORD(a) = b+c THEN d:=e; f:=h+(2*g)END;

Nach  dem  IF  steht  laut  Modula-Syntax  eine  'Boolean  Expression',  die
ausgegeben  wird.  Bei  der  Berechnung  dieses  Ausdrucks  wird  jedoch  eine
weitere 'Expression' ausgerechnet, nÑmlich das Argument der Funktion ORD -
dessen Wert erscheint also als erste Ausgabe. Der Wert b+c wird dagegen
nicht  angezeigt,  denn  links  und  rechts  vom  Gleichheitszeichen  stehen
syntaktisch nur Simple Expressions.

Die  im  THEN-Teil  berechneten  AusdrÅcke  erscheinen  natÅrlich  nur,  wenn
dieser Zweig ausgefÅhrt wird. Der erste Ausdruck ist der auf <d> zugewiesene
Wert, also <e>. Bei der Berechnung des Ausdrucks, der auf <f> zugewiesen
wird, ist wiederum ein zusÑtzlicher Ausdruck auszuwerten: In Klammern steht
laut Syntaxdiagramm wieder eine 'Expression'. Also wird erst der Wert <2*g>
ausgegeben, dann <h+2*g>.

Auûer 'Expressions' werden noch die Werte von Variablen angezeigt, die als
Parameter an Prozeduren Åbergeben werden.

Allgemeiner Tip: Wenn mehr (oder weniger) Werte ausgegeben werden, als Sie
erwarten,  sehen  Sie  im  Syntaxdiagramm  nach,  wo  wirklich  'Expressions'
stehen. Um die Ausgabe eines Teilausdrucks zu erzwingen, ist es oft mîglich,
ihn  in  Klammern  zu  setzen  -  innerhalb  der  Klammern  wird  wieder  eine
vollstÑndige Expression erwartet und ausgegeben.
2.5  Bedienung: Debugger                                                 2 - 55
________________________________________________________


Leertaste   veranlaût AusfÅhrung und Ausgabe der nÑchsten Zeile
            oder schaltet von laufender AusfÅhrung auf Einzelschritt.
<Return>    schaltet von Einzelschritt auf laufende AusfÅhrung.
<H>         wÑhlt Ausgabe von Skalaren als Hexadezimalzahlen.
<D>         wÑhlt Ausgabe von Skalaren als Dezimalzahlen.
<S>         Eingabe einer Schrittweite: die eingegebene Anzahl Zeilen
            wird ohne Ausgaben (schneller) ausgefÅhrt.
<A>         aktiviert die Ausgabe wieder, wenn sie durch <S>
            unterdrÅckt wurde.
<L>         schaltet zusÑtzliche Ausgabe der Zeilenadresse zu jeder
            Programmzeile ein/aus.
<R>         veranlaût einmalige Ausgabe aller CPU-Register.

Die  gleichen  Kontrollfunktionen  kînnen  statt  von  der  Tastatur  auch  vom
laufenden Programm aus umgeschaltet werden. Dazu kînnen Steuervariablen
aus dem Modul 'Debug' importiert und verÑndert werden. Das erfordert zwar
einige zusÑtzliche Anweisungen im Programm, erleichtert aber manchmal die
gezielte  Fehlersuche  sehr  -  z.B.  wenn  die  Debug-Ausgaben  erst  aktiviert
werden  sollen,  wenn  eine  Variable  einen  bestimmten  Wert  hat  oder  eine
Prozedur mit vorgegebenen Argumenten aufgerufen wurde. Die Funktion der
Steuervariablen im einzelnen:

Continous:  BOOLEAN   =  "laufende AusfÅhrung ohne Warten"
Active:     BOOLEAN   =  "folgende <Step> Schritte ohne Anzeige ausfÅhren"
Step:       LONGCARD =   Anzahl der Schritte, die ohne Anzeige auszu~
                             fÅhren sind (zusÑtzlich muû Active = FALSE sein)
LineAddr:   BOOLEAN   =  "zu jeder Programmzeile Adresse ausgeben"
Hex:        BOOLEAN   =  "Skalare als Hexadezimalzahlen ausgeben"


Der Scanner - Suchen der Fehlerposition

In vielen FÑllen werden Sie das Debug-Modul zur Fehlersuche
aber gar nicht benîtigen - es gibt noch eine einfache und oft
wesentlich  schnellere  Mîglichkeit,  Programmierfehlern  auf  die
Spur zu kommen. Oft genÅgt es ja zu wissen, welche Stelle des Programms
(im  Text)  gerade  ausgefÅhrt  wurde,  als  ein  Laufzeitfehler  auftrat.  Dabei
unterstÅtzt Sie der 'Scanner', den Sie auf der Shell-ArbeitsflÑche als Lupe
abgebildet sehen.

Hinter dem Scanner verbirgt sich in Wirklichkeit wiederum  der  Compiler  -
allerdings  in  einer  Betriebsart,  die  keine  Codedatei  erzeugt,  sondern  nur
so  lange  'ins  Blaue'  Åbersetzt,  bis  eine  bestimmte  Adresse  im  erzeugten
Codemodul erreicht ist. Dann stoppt der Scanner und ruft den Editor auf, um
die erreichte Textstelle zu zeigen.
2.5  Bedienung: Debugger                                                 2 - 56
________________________________________________________


Wenn  ein  Laufzeitfehler  auftritt,  ermittelt  das  Modula-System,  in  welchem
Modul und auf welcher relativen Adresse innerhalb des Moduls die AusfÅhrung
unterbrochen wurde. Sie kînnen wÑhlen:

* Exit, um die angezeigte Fehlerposition im Programmtext zu suchen.
* Back, um statt der angezeigten Fehlerposition die Position des Aufrufers zu
  sehen (s.u.);
* Frwd, um entsprechend wieder die Position des nÑchsttieferen Aufrufs zu
  bekommen.

Nach Wahl von Exit haben Sie nochmals die Mîglichkeit, durch Quit zur Shell
zurÅckzukehren oder durch Cont das Programm doch fortzusetzen. Durch Edit
schlieûlich starten Sie den Scanner, der Ihnen die gefundene Fehlerstelle dann
im Editor prÑsentiert.

Gelegentlich  mÅssen  Sie  noch  etwas  mehr  tun,  um  den  Ursprung  eines
Laufzeitfehlers zu finden: Unter  UmstÑnden  ruft  das  fehlerhafte  Programm
eine Prozedur (evtl. in einem anderen Modul) mit falschen Parametern auf, und
erst dort wird der Fehler ausgelîst. Dann interessiert Sie natÅrlich nicht die
Position in der Prozedur, sondern die des falschen Aufrufs. In diesem  Fall
klicken Sie in der ScannerBox bitte nicht Exit, sondern Back an - eine neue
Scanner-Box  zeigt  Ihnen  Modulnamen  und  Adresse  des  Aufrufers.  Dieses
RÅckverfolgen  zum  Aufrufer  kînnen  Sie  wiederholen,  bis  das  'verdÑchtige'
Modul erreicht ist. Sind Sie in der Aufrufer-Kette zu weit 'geklettert', dann
kînnen  Sie  mit  Frwd  wieder  tiefer  steigen.  Wenn  Sie  den  eigentlichen
Verursacher des Fehlers gefunden haben, wÑhlen Sie Exit, und nach einem
Scannerlauf wird die Position in diesem Modul angezeigt.


Manuelles Starten des Scanners

Bei der oben beschriebenen Bedienung des Scanners ist das Scanner-Symbol
auf der ArbeitsflÑche noch gar nicht benutzt worden. In zwei FÑllen kommt
dieses Symbol zur Anwendung:

* Wenn Sie nach einem Laufzeitfehler eine Adresse aus der  Aufruferkette
ausgewÑhlt haben (durch 'Back'/'Forward'), die sich nach dem Scannen nicht
als  der  eigentliche  Verursacher  des  Fehlers  herausstellt.  In  diesem  Fall
mîchten  Sie  wahrscheinlich  noch  eine  andere  Adresse  aus  der  Kette
untersuchen.

* Wenn nach einem fatalen Laufzeitfehler die Shell und der  Scanner  nicht
mehr funktionieren (etwa nach öberschreiben wichtiger Speicherbereiche). Die
Fehlerposition im Code sollten Sie in jedem Fall noch erfahren; nach einem
Neustart  der  Shell  lÑût  sich  die  zugeordnete  Textstelle  dann  durch  einen
manuellen Scanner-Aufruf (mit Eingabe der Adresse von Hand) feststellen.
2.5  Bedienung: Debugger                                                 2 - 57
________________________________________________________


Wollen Sie erneut die Aufrufkette zum vorangegangenen Laufzeitfehler sehen,
dann mÅssen Sie das Scanner-Symbol bei festgehaltener Shift-Taste anwÑhlen
(z.B. mit Shift-S). Sie sehen dann die oben beschriebene Scanner-Box.

öbergeben Sie dagegen eine Datei an den Scanner, indem Sie sie auf das
Symbol schieben, so bekommen Sie die Mîglichkeit, eine Fehleradresse  von
Hand einzugeben. Gemeint ist hier immer die relative Adresse innerhalb des
Moduls, wie sie auch nach Laufzeitfehlern angezeigt wird. Um die Arbeitsdatei
zu scannen, brauchen Sie das Scanner-Symbol nur doppelt anklicken.

Fragt der Scanner nach der relativen Position, ist der vorher beim Laufzeit~
fehler angezeigte Wert einzugeben. Dabei ist zu beachten, daû der Wert, wie
bei  der  Anzeige,  mitsamt  dem  "$"-Zeichen  eingegeben  wird,  da  dies  eine
Hexadezimalzahl kennzeichnet.
2.5  Bedienung: Debugger                                                 2 - 58
________________________________________________________





















                               Auch diese Seite war zu kostbar,
                                     um leer zu bleiben.
2.6  Bedienung: Linker                                                    2 - 59
________________________________________________________


2.6    Linker

Funktion

In Kapitel 1.4 haben wir schon beschrieben,  warum  das  Megamax  Modula-
System eigentlich ohne Linker auskommt: Der Loader als Teil der Entwicklungs~
umgebung sorgt fÅr automatisches Load Time Linking, wenn Sie aus der Shell
ein Programm starten.

Wollen Sie  aber  ein  Modula-Programm  als  eigenstÑndige  TOS-  oder  PRG-
Anwendung verwenden, dann muû es komplett mit allen benutzten Modulen in
einer  Codedatei  abgelegt  werden,  damit  das  TOS  damit  zurechtkommt.
Auûerdem mÅssen noch einige zusÑtzliche Anweisungen eingefÅgt werden, um
fÅr die Module die gleiche Laufzeitumgebung bereitzustellen, wie sie bei Aufruf
aus der Shell herrscht.

Eine solche Codedatei erzeugt der  Linker  -  erfreulicherweise  kann  er  das
vollautomatisch.  Sie  Åbergeben  ihm  nur  den  Namen  des  Hauptmoduls;  der
Linker lÑdt alle importierten Module dazu und fÅgt zusÑtzlich  ein  spezielles
Initialisierungs-Modul  ein.  Das  resultierende  Programm  kann  dann  vîllig
unabhÑngig  vom  Modula-System,  z.B.  unter  dem  GEM-Desktop,  gestartet
werden;  daher  kînnen  Sie  Programme  in  dieser  Form  auch  an  Dritte
weitergeben, die das Megamax Modula-System nicht besitzen  (siehe  Kapitel
1.5).

Bedienung

Der Linker wird aufgerufen wie alle anderen Systemprogramme: Legen Sie mit
der Maus eine Code-Datei auf dem Linker-Symbol auf der ArbeitsflÑche ab
(oder klicken Sie das Linker-Symbol an, um die Arbeitsdatei zu Åbergeben).
Bevor Sie den Linker starten, sollten Sie aber ÅberprÅfen, ob folgende Voraus~
setzungen erfÅllt sind:

* Von allen Modulen, die in das Programm importiert werden, muû das Åber~
setzte Implementationsmodul vorhanden sein. ZusÑtzlich werden evtl. weitere
Module benîtigt (siehe folgenden Abschnitt Konfigurationsmodule). Die Imple~
mentationsmodule werden auf den Pfaden der ImpPath-Liste (siehe Kap. 2.2,
Batch-Dateien) gesucht.

* Das fertig gelinkte Programm wird auf dem Pfad gespeichert, der fÅr das
Åbergebene Hauptmodul angegeben wurde. (Sie kînnen hier bewuût einen Pfad
-  durch  Doppelklick  auf  das  "aktuelle  Datei"-Fenster  oder  Control-P  -
angeben, auf dem das Hauptmodul gar nicht zu finden ist, um die Ausgabe zu
lenken;  das  Hauptmodul  wird  dann  auf  allen  Pfaden  der  ModPath-Liste
gesucht).  Auf  der  Zieldiskette  muû  genÅgend  Platz  sein  -  durch  die
zusÑtzlichen Module wird das  gelinkte  Programm  im  allgemeinen  wesentlich
grîûer als das ursprÅngliche Modul.
2.6  Bedienung: Linker                                                    2 - 60
________________________________________________________


Wenn keine Schwierigkeiten auftreten, baut der Linker auf dem Bildschirm eine
Liste der importierten Module auf. Zuerst werden dabei stets die Konfigura~
tions-Module (s.u.) aufgenommen, gefolgt von ihren Importen. Dann folgen das
von Ihnen angegebene Hauptmodul und dessen Importe. Schlieûlich meldet der
Linker den erfolgreichen Ablauf und speichert das fertige Programm ab.

Fertig - mehr zu Bedienen gibt's in der Regel nicht! Es sei denn, Sie werden
mit einer der folgenden Fehlermeldungen konfrontiert:


Fehlermeldungen

Alle Meldungen beginnen mit der Angabe, welches Modul das Problem ausgelîst
hat  und  von  welchem  anderen  Modul  es  benîtigt  wurde:  "Importing
<FehlerModul>  into  <KundenModul>".  Dann  folgt  eine  Fehlerbeschreibung.
Allgemein gilt: Der Linker interessiert sich immer fÅr Åbersetzte Implemen~
tationsmodule - alle Probleme kînnen sich also nur auf diese Dateien beziehen.

Module not found
    Das  Åbersetzte  Implementationsmodul  wurde  auf  keinem  der  Pfade
    gefunden, die in der IMPPATH-Pfadliste in der Shell-Info definiert sind.
Wrong module format
    Die  geladene  Datei  ist  kein  korrekt  aufgebautes  Implementationsmodul;
    vermutlich ist die Datei beschÑdigt.
Error in relocating list
    Die  Relozierliste  (Bestandteil  jedes  Åbersetzten  Moduls)  ist  fehlerhaft;
    vermutlich ist die Datei beschÑdigt.
Bad module layout
    Das  Modul  wurde  mit  einer  alten  Compilerversion  Åbersetzt,  die  ein
    anderes Dateiformat erzeugt. Modul neu Åbersetzen!
File is damaged
    Beim Laden des Moduls ist ein Lesefehler aufgetreten.
Wrong module version
    Die gefundene Version des Moduls paût zu einem anderen Definitionsmodul
    als beim öbersetzen des Kundenmoduls vorlag. (Das Modul exportiert nicht
    genau die Bezeichner, die das Kundenmodul erwartet.) Ggf. beide Module
    neu Åbersetzen!
Out of memory
    Der Hauptspeicher reicht nicht aus.  Evtl.  vorhandene  Accessories  oder
    RAM-Disk entfernen.
Too many modules (list overflow)
    Mehr als die in den Parametern eingestellte Anzahl Module sollen gebunden
    werden. Erhîhen Sie den Wert Max. Module unter Parameter/Linker und
    wiederholen Sie den Linker-Aufruf.

Auûerdem  sind  I/O  Error-Meldungen  mîglich.  Sie  enthalten  jeweils  eine
Beschreibung des Fehlers und beziehen sich stets auf die Ausgabe-Datei.
2.6  Bedienung: Linker                                                    2 - 61
________________________________________________________


Linker-Optionen

Beim  MenÅpunkt  Parameter
kann unter Linker eine Dia~
logbox geîffnet werden, die
das Einstellen aller Optionen
beim Linken zulÑût.

In den acht Treiber-Feldern
werden  die  Initialisierungs-
und    Konfigurations-Module
eingetragen, die weiter unten
ausfÅhrlich  behandelt  wer~
den.  Die  Stackgrîûe  wird
ebenfalls spÑter erlÑutert. Der Wert hinter Max. Module bestimmt, wie viele
Module maximal  zu  linken  sein  werden.  Ist  dieser  Wert  zu  klein  gewÑhlt,
meldet der Linker einen Fehler und Sie mÅssen den Wert erhîhen. Er sollte
aber auch nicht unnîtig groû gewÑhlt werden, weil je nach seiner Grîûe mehr
oder  weniger  Speicherplatz  von  vornherein  vom  Linker  reserviert  wird.
Besonders, wenn mangels Speicher îfter die Fehlermeldung Out of memory
beim Linken erscheint, sollten Sie diesen Wert so klein wie mîglich halten.


Treiber- bzw. Konfigurations-Module

ZusÑtzlich zu den Modulen, die Sie explizit (durch IMPORT-Anweisungen) in
Ihren  Programmen  benutzen,  kann  der  Linker  noch  weitere  Module  in  die
Code-Datei einbinden. Mindestens ein solches Modul wird (fast) immer benîtigt,
um vor dem Start des Modula-Programms die Laufzeitumgebung vorzubereiten.
Weitere  Module,  die  mitgeliefert  wurden,  stellen  Ausgabefunktionen  auf
unterster Ebene fÅr TOS- oder GEM-Umgebung bereit.

Das System ist bereits so konfiguriert, daû alle Programme 'gelinkt' werden
kînnen, ohne daû Sie sich um diese zusÑtzlichen Module kÅmmern mÅûten. Sie
kînnen  die  Konfiguration  dieser  Module  aber  von  der  Shell  aus  mit  dem
MenÅpunkt Parameter/Linker einstellen. In der Dialogbox (s.o.) existiert eine
Liste  fÅr  mit  acht  Treibern.  Vor  jeden  dieser  Treiber  kînnen  Sie  durch
Anklicken ein HÑkchen setzen oder lîschen - nur die so markierten Modul~
namen werden beim Linken eingebunden. Normalerweise  sind  fÅnf  der  acht
mîglichen Namen eingetragen:

M2Init sorgt fÅr die Vorbereitung der Laufzeitumgebung. Dieses Modul muû in
jedem Codefile enthalten sein - bitte nur 'abschalten', wenn es extra verlangt
wird, wie z.B. beim Linken von MoreMem (UTILITY-Ordner) oder wenn  Sie
selber die Initialisierung in Ihrem Modul vornehmen wollen.
2.6  Bedienung: Linker                                                    2 - 62
________________________________________________________


GEMError Åbernimmt die Behandlung von Laufzeitfehlern. Wenn dieses Modul
vorhanden ist, werden Laufzeitfehler in einer Alert-Box mit Fehlerbeschreibung
und -position angezeigt. GEMError kann nur sinnvoll bei keine Optimierung oder
verkÅrzende Optimierung mit eingelinkt werden. Wird vollstÑndig optimiert, ist
statt dessen SimpleError einzubinden.

SimpleError ist eine einfachere Fehlerbehandlung als GEMError, die, falls Åber~
haupt ein Fehlerabfangen erwÅnscht ist, bei vollstÑndig optimierten Programmen
gewÑhlt werden muû.

Um Platz zu sparen, kînnen Sie GEMError bzw. SimpleError auch weglassen -
dann erscheinen bei Laufzeitfehlern nur die allseits bekannten Bîmbchen.

GEMIO enthÑlt Ausgabefunktionen, auf die sich das InOut-Modul stÅtzt. Diese
Funktionen lenken die Ausgabe auf ein Fenster, wie Sie es vom Arbeiten mit
der  Megamax  Modula-Shell  kennen.  Leider  ist  die  UnterstÅtzung  dieser
'hÅbschen' Ausgabe recht aufwendig, und die fertige Code-Datei wird relativ
lang.  Daher  kînnen  Sie,  wenn  Ihr  Programm  sonst  keine  GEM-Funktionen
benutzt,  ohne  ProgrammÑnderung  wahlweise  auch  TOS-Ausgabe  Åber  das
TOSIO-Modul wÑhlen:

TOSIO  enthÑlt  die  gleichen  Ausgabefunktionen  wie  GEMIO,  allerdings  fÅr
Ausgabe auf dem TOS-Bildschirm (schwarz auf komplett weiûem Grund mit
Textcursor, keine GEM-Funktionen, keine Maus). Wenn Sie dieses Modul statt
GEMIO aktivieren, geben alle InOut-Funktionen auf dem TOS-Bildschirm aus.
Damit das GEM-Desktop die richtigen Initialisierungen beim Starten durchfÅhrt,
sollte das fertig gebundene Programm von '.PRG' in '.TOS' umbenannt oder von
vornherein  das  Modul  durch  die  Option  $E  MOS  im  Quelltext  als  TOS-
Programm klassifiziert werden.

Achtung: TOSIO verwendet die BIOS-Funktionen zur Bildschirm-Ein-/Ausgabe
und erlaubt somit keine Datei-Umleitung (I/O-Redirection) von auûen, z.B. Åber
eine  Command-Shell.  DafÅr  kann  solch  ein  Programm  nicht  einfach  durch
Eingabe von Control-C abgebrochen werden.

GEMDOSIO ist, ebenso wie TOSIO, fÅr TOS- und TTP-Programme zustÑndig.
Es  erlaubt  die  Umlenkung  von  Ein-/Ausgaben  Åber  das  Modul  InOut  von
auûerhalb  (beispielsweise  Åber  eine  Command-Shell)  und  den  Programm~
abbruch Åber Control-C, da die Ein-/Ausgaben Åber die GEMDOS-Funktionen
geschehen. Ist Ihnen der Sinn dieser Anwendung nicht klar, verwenden Sie
besser TOSIO!

Nochmal in Kurzform: Benutzen Sie M2Init immer; entweder GEMError oder
SimpleError  wenn  ordentliche  Fehlermeldungen  gewÅnscht  sind;  entweder
GEMIO,  TOSIO  oder  GEMDOSIO,  wenn  InOut-Funktionen  benutzt  werden.
(Falls das Programm InOut gar nicht benutzt, sollten diese IO-Module weg~
gelassen werden, um das Programm nicht unnîtig zu vergrîûern.)
2.6  Bedienung: Linker                                                    2 - 63
________________________________________________________


Komprimierung (Optimierung) des zu erzeugenden Programms

Durch die Wahl einer der vier gezeigten
Optionen lÑût sich bestimmen, inwieweit
die   zusammengefÅgten   Module   im
erzeugten     Programm     komprimiert
werden sollen.

Die erste Einstellung keine Optimierung fÅgt die Module ohne Komprimierung
zusammen. Zudem werden die Informationen Åber alle Module mit eingebunden,
die  benîtigt  werden,  wenn  das  Loadtime  Linking  vom  gelinkten  Programm
verwendet werden soll. Diese Option ist also zu wÑhlen, wenn ein Programm
erzeugt wird, das den Loader importiert, um andere Module starten zu kînnen,
z.B. bei der Shell dieses Systems (MM2Shell).

Alternativ  zu  keiner  Optimierung  kînnen  auch  nur  Prozedurnamen  entfernt
werden.  Dadurch  bleiben  die  Module  vollstÑndig  erhalten,  nur  werden  die
Symboltabellen, die die einzelnen Prozedurnamen enthalten, entfernt. Loadtime
Linking ist dann weiterhin mîglich, nur ist das Scanning (s. Kap 2.5, Debugger)
und die Anzeige der Prozedurnamen bei Laufzeitfehlern nicht mehr mîglich.
Diese Komprimierung ist  fÅr  Sie  meist  nicht  von  Interesse.  Lediglich  beim
Linken der Shell (sofern Sie daran énderungen vorgenommen haben) sollten
Sie sie anstatt keiner Optimierung anwenden,  weil  Sie  dabei  ca.  10  KByte
einsparen.  Da  Sie  im  Allgemeinen  bei  Fehlern  in  den  MOS-Modulen  keine
Korrekturen vornehmen kînnen, kînnen Sie bei diesen Modulen ja ruhig auf die
Mîglichkeit zum Scanning verzichten. Auf Module, die per Loadtime Link von
der Shell gestartet werden, hat dies keinen Einfluû.

Die  Option  Prozedurnamen  erhalten  erzeugt  kompaktere  Programme.  Dabei
werden alle Funktionen entfernt, auf die es keine Referenz zur Laufzeit gibt.
Das  gelinkte  Programm  enthÑlt  demnach  nur  Module  mit  Funktionen,  die
aufgerufen werden kînnen und Module mit exportierten Variablen, die von den
benîtigten Prozeduren benutzt werden. ZusÑtzlich enthalten sind, wie bei den
vorigen Optionen,die Informationen Åber die Module, die fÅr eine Laufzeitfehler~
analyse  (Anzeige  der  Prozedur-  und  Modulnamen  und  der  aufrufenden
Prozeduren) mittels des Moduls GEMError benîtigt werden. In dieser Form ist
kein Load-Time-Linking vom gelinkten Programm aus mîglich.

Wenn weder vom Loadtime Linking (Starten von Modulen mittels des Loaders),
noch von der komfortablen  Fehleranalyse  (Import  von  GEMError)  Gebrauch
gemacht  werden  soll,  kann  die  letzte  Einstellung  vollstÑndige  Optimierung
gewÑhlt  werden.  Sie  erzeugt  die  kompaktesten  Programme,  indem  im
Unterschied  zur  vorigen  Option  die  Informationen  zur  Fehleranalyse  weg~
gelassen  werden.  Damit  eventuelle  Fehler  trotzdem  ordentlich  angezeigt
werden, muû SimpleError statt GEMError eingebunden werden.
2.6  Bedienung: Linker                                                    2 - 64
________________________________________________________


Vorsicht:

Bei der vollstÑndigen Optimierung entfernt der Linker alle Module vollstÑndig,
die zwar importiert werden, aus denen aber keine Prozeduren oder Variablen
wirklich benutzt werden. Das heiût: Importieren Sie ein Modul, das in seinem
Initialisierungscode (Kîrper) lediglich Variablen anderer Module initialisiert oder
importierte Prozeduren dort aufruft, verschwinden diese Anweisungen!

Dieser  Effekt  tritt  nur  beim  optimierten  Linken  auf.  Haben  Sie  also  ein
Programm, das ungelinkt unter der Shell oder nicht-optimiert gelinkt fehlerfrei
lÑuft, optimiert gelinkt aber nicht funktioniert, prÅfen Sie, ob die beschriebene
Situation bei Ihnen vorkommt. Sie kînnen es auch daran erkennen, daû solche
Module beim Linken zwar erst beim  Einladen  angezeigt  werden,  dann  aber
wieder vom Bildschirm gelîscht werden, weil sie vollstÑndig entfernt wurden.

Um  dies  zu  verhindern,  mÅssen  Sie  die  wegoptimierten  Module  mit  der
Direktive B+ Åbersetzen, entweder durch $B+ im Quelltext oder durch -B in
der Eingabezeile fÅr Direktiven in der Compiler-Parameter-Box.

Zusammenfassend seien pauschal diese Regeln zu befolgen:

* Accessories sollten mîglichst kurz sein und dÅrfen nie mit einem Fehler
abbrechen,  da  dann  das  gesamte  System  nicht  mehr  funktionsfÑhig  ist.
Deshalb ist am besten nach eingehendem Testen das Modul mit der Option
$R-  zu  compilieren,  um  Platz  zu  sparen,  und  das  Programm  dann  mit
vollstÑndiger Optimierung und  ohne  Fehlermodule  zu  linken  (also  in  Linker-
Optionen nur M2Init aktivieren).

* Die Shell MM2Shell wird mit der Einstellung keine Optimierung  oder  nur
Prozedurnamen  entfernen  und  den  Modulen  M2Init,  GEMIO  und  GEMError
gebunden. Max. Module sollte den Wert 100 haben. Falls der Linker nicht linken
will,  weil  der  freie  Speicher  nicht  ausreicht,  entfernen  Sie  die  resident
geladenen  Programme  (z.B.  Compiler  und  Editor).  Wenn  das  nicht  reicht,
entfernen Sie Ihre Accessories, residente Programme im AUTO-Ordner und
ggf. auch eine vorhandene RAM-Disk (dann mÅssen die Suchpfade ImpPath und
ModPath  ggf.  die  Pfadnamen  fÅr  die  IMP-  und  MOD-Dateien  auf  den
Laufwerken A: oder B: enthalten, damit die Modulcodes dann von Disk geladen
werden kînnen).

* Sonstige Programme kînnen in der Regel mit der vollstÑndigen Optimierung
gelinkt werden, um zu erreichen, daû die Programme mîglichst wenig Platz auf
Disk und im Speicher beim AusfÅhren belegen. Zur Sicherheit sollte allerdings
das Modul SimpleError mit eingebunden werden, damit in einem unerwarteten
Fehlerfall das Programm sich nicht gleich mit Bîmbchen verabschiedet, sondern
statt dessen eine Meldung zeigt, um was fÅr einen Fehler es sich handelt. Ist
allerdings  mit  Laufzeitfehlern  zu  rechnen,  ist  es  sinnvoller,  verkÅrzende
Optimierung zu wÑhlen und GEMError einzubinden. Dann ist bei einem Fehler
2.6  Bedienung: Linker                                                    2 - 65
________________________________________________________


die  Lokalisation  der  Ursache  einfacher.  Da  aber  in  diesem  Fall  meist  nur
Prozedurnamen, aber kein 'Offset' zum nachtrÑglichen Scannen in der Shell
angezeigt werden kann, ist im ungÅnstigsten Fall keine Optimierung zu wÑhlen.
Dann werden auch die Offsets bei Fehlern immer angezeigt. In der Shell kann
dann z.B. durch Ziehen des Quelltextes des zu scannenden Moduls auf die
Scan-Box der Offset eingegeben werden, um den Scanner zu aktivieren.

* Bei allen normalen Programmen, auch Accessories, muû M2Init als erstes
Treibermodul  eingebunden  werden,  weil  dieses  Modul  dafÅr  sorgt,  den
ÅberflÅssigen Speicher freizugeben, die globalen Variablen (das BSS Segment)
zu lîschen und die einzelnen Module zu initialisieren (die Modulkîrper werden
alle nacheinander aufgerufen).

*  Es  ist  immer  darauf  zu  achten,  daû  die  Module  GEMIO,  TOSIO  oder
GEMDOSIO nur dann eingebunden zu werden brauchen, wenn das Modul InOut
verwendet wird. Ansonsten erzeugt das Einbinden dieser Module nur unnîtig
lange Programme.


Stack-Grîûe

Ebenso wie bei Modulen, die unter der Shell mit Loadtime-Linking gestartet
werden, kann die Stackgrîûe auch fÅr gelinkte Programme bestimmt werden
(siehe auch Kap. 2.2, Kommandozeile). Ist der Wert Null eingetragen, wird die
Standard-Grîûe verwendet, die in M2Init bestimmt ist (normalerweise  8192
Bytes). War beim Starten eines Moduls unter der Shell ein grîûerer Stack
nîtig, so ist dieser in der Regel genauso beim Linken in der Linker-Parameter-
Box einzustellen. Ist der Stack des gelinkten Programms zu klein, wird eine
entsprechende Fehlermeldung wÑhrend des  Programmlaufs  angezeigt,  sofern
GEMError bzw. SimpleError mit eingebunden wurde.


Binden von Accessory-Programmen

öbrigens: Accessories (Endung ACC) kînnen ohne weiteres mit dem Linker
erzeugt werden, ihre Endung muû nur ggf. auf ACC angepaût werden, wenn
nicht schon im Programmtext mit einer Zeile wie (*$E MAC *) die Endung fÅr
den Linker vorbereitet wird. Mit Hilfe der Funktion PrgCtrl.Accessory kann das
Programm gar abfragen, ob es nun  als  normales  PRG-Programm  oder  als
Accessory  mit  Endung  ACC  gestartet  wurde,  und  entsprechend  reagieren
(Accessories mÅssen sich zusÑtzlich in die MenÅleiste eintragen und dÅrfen
nicht terminieren!).
2.6  Bedienung: Linker                                                    2 - 66
________________________________________________________


Fast Load-, Fast Code- und Fast Memory-Flags

In neueren TOS-Versionen werden drei neue Kennungen im Programmkopf von
gelinkten  Programmen  ausgewertet.  Das  Fast  Load-Flag  (seit  TOS  1.4)
bestimmt, ob ein Programm es nîtig hat, daû beim Start seine TPA gelîscht,
also mit Null-Bytes beschrieben werden soll. Die  TPA  ist  der  grîûte  freie
Speicherblock, in dem das Programm selbst auch steht. Sie ist Bestandteil des
Heaps; dem Speicher, der mit dem Storage-Modul angefordert werden kann.
Ist das Flag gesetzt, wird die TPA  nicht  gelîscht.  Modula-Programme,  die
unter der Shell vom Loader gestartet werden, erhalten den Heap nie gelîscht,
so brauchen Sie es in der Regel auch nicht, wenn sie gelinkt gestartet werden.
Daher kann das Fast Load-Flag immer aktiviert bleiben.

Die Flags fÅr Fast Code und Fast Memory bestimmen bei Atari TT-Rechnern,
ob  der  "schnelle"  Speicher  dieses  Computers  mitbenutzt  werden  darf.
EinschrÑnkungen  gibt  es  hier  nur  selten,  beispielsweise,  wenn  Sie  die
Videospeicher-Adresse in einen anderen Bereich legen wollen, denn dies darf
nur im "normalen" Speicher der ersten 16 MByte geschehen - das Fast RAM
liegt aber oberhalb der ersten 16 MB.

Fast Code bestimmt, ob der Programmcode im schnellen Speicher  ablaufen
darf,  Fast  Memory,  ob  bei  Speicheranforderungen  (vom  Heap)  auch  der
schnelle Speicher vergeben werden darf. Funktioniert ein Programm nicht auf
dem TT, sollten Sie zuerst diese Flags probeweise abschalten.


Arbeitsweise des Linkers

  Bekanntermaûen wird der Linker dazu verwendet, um aus einem Hauptpro~
gramm und seinen Bibliotheken ein Programm zu erzeugen, das auch auûerhalb
der Megamax-Shell ausfÅhrbar ist.

  Die Mindestanforderung an den Linker ist dabei, das Hauptmodul mit allen
importierten  Modulen  zusammenzufÅgen  und  die  Adressen  der  "externen"
Prozeduren und Variablen zu verketten. Auûerdem mÅssen die Relozierinfor~
mationen  der  einzelnen  Module  vom  fÅr  das  Loader-Modul  verstÑndlichen
Format in das TOS-Format umgewandelt werden. Dann kann daraus eine Datei
erzeugt werden, in der am Anfang noch Informationen abgelegt werden, wie
lang der Programm- und der Variablenbereich sind und wo im Programmcode
der Kîrper des Hauptmoduls liegt, also des Teils, in dem mit der AusfÅhrung
begonnen werden soll.

  Nur reicht das in der Regel nicht aus, denn so wird zwar das Hauptmodul
beim Starten des gelinkten Programms ausgefÅhrt, aber die ihm untergeordne~
ten Module wurden nicht initialisiert. Es ist notwendig, zusÑtzlich die Kîrper
der anderen Module vorher auszufÅhren. Aus diesem Grund legt der Linker
2.6  Bedienung: Linker                                                    2 - 67
________________________________________________________


zwischen dem  Programmcode  und  der  Reloziertabelle  noch  eine  Liste  aller
Adressen der Kîrper ab, und zwar in ihrer hierarchischen Reihenfolge, mit
dem tiefsten Modul beginnend. Damit diese Kîrper nun ausgefÅhrt werden, muû
ein weiteres Modul eingebunden werden; wir empfehlen M2Init.

  M2Init, dessen Kîrper als erstes Modul ausgefÅhrt wird, weil es vom Linker
als Hauptmodul verstanden wird, sorgt auûerdem fÅr richtige Initialisierung des
Programms. Zuerst ermittelt es, ob es  als  Accessory  gestartet  wurde;  in
diesem Fall fordert es erst einmal Speicher an, um ihn als Stack verwenden
zu kînnen. Im anderen Fall hat es bereits den gesamten freien Speicher als
Stackbereich erhalten und verkleinert ihn deshalb erstmal und gibt den unbe~
nutzten Bereich an das System zurÅck.

  Der Linker hat dafÅr gesorgt, daû in dem Adreûregister A0 die Adresse der
Base-Page und in A1 die Adresse der Liste mit den Verweisen auf die Kîrper
der anderen Module Åbergeben werden. So ruft M2Init dann alle von ihm selbst
importierten Modulkîrper auf (sie stehen zu Beginn der Liste, die mit einem
NIL-Zeiger abschlieût) und dann eine Prozedur aus dem Modul MOSCtrl, um
ihr die Adresse einer Tabelle mitzuteilen, welche ebenfalls vom Linker erzeugt
wurde, und in welcher, sofern nicht vollstÑndige Optimierung gewÑhlt wurde,
die Informationen Åber alle vorhandenen Module enthalten sind (z.B. Modulname,
Adresse und LÑnge im Speicher, usw.). Diese Tabelle wird vom Modul ModBase
verwaltet und von ModCtrl und Loader mitverwendet. Sie wird z.B. benîtigt,
um bei einer Fehleranzeige durch GEMError den Modulnamen  und  ggf.  den
Prozedurnamen zu ermitteln.

  Ist die Initialisierung des MOS-Systems abgeschlossen, werden die restlichen
Modulkîrper  ausgefÅhrt  (die  Liste  wird  fortgesetzt  und  wiederum  mit  NIL
abgeschlossen), wobei der letzte Kîrper das eigentliche Hauptmodul ist.

  Nun ist es theoretisch unnîtig, immer die importierten  Module  vollstÑndig
einzubinden, da normalerweise nicht alle Prozeduren (zumindest bei den mitge~
lieferten Bibliotheksmodulen) verwendet werden. Deshalb gibt es die Mîglich~
keit, die Programme optimiert  zu  linken.  Beim  Megamax  Modula-2  gibt  es
zwei Stufen der Optimierung. Beide haben gemeinsam, daû alle Prozeduren, die
keinesfalls  benîtigt  werden,  vor  dem  Zusammenbinden  aus  den  Modulen
entfernt werden. Ergibt sich dabei, daû trotz Import-Anweisung eines Moduls
aus diesem weder Prozeduren noch Variablen verwendet werden, wird sogar
das gesamte Modul nicht eingebunden (dies ist daran zu erkennen, daû solche
Modulnamen im Fenster nach dem Optimiervorgang wieder verschwinden). Dies
ist u.a. bei Modulen der Fall, die nur Konstanten enthalten (z.B. MOSGlobals).

  Soll ein Modul nicht komplett wegoptimiert werden kînnen, obwohl es keine
Funktionen und Variablen exportiert, aber beispielsweise in seinem Modulkîrper
Variablen, die es aus anderen Modulen importiert hat, initialisiert oder auch
dort importierte Funktionen aufruft, muû in seinem Quelltext - am besten zu
Beginn - die Compiler-Option $B+ aufgefÅhrt werden!
2.6  Bedienung: Linker                                                    2 - 68
________________________________________________________


  Ob eine Prozedur benîtigt wird, erkennt der Linker daran, daû er nachsieht
- ausgehend von jedem Modulkîrper - welche Prozeduraufrufe darin vorkom~
men.  Diese  gefundenen  Prozeduren  werden  nun  wiederum  selbst  alle  auf
weitere Aufrufe ÅberprÅft (eine an sich ganz einfache Sache). Es werden dabei
auch Prozeduren ermittelt, die zwar als Aufrufe von aufgerufenen Prozeduren
gefunden werden, jedoch nie ausgefÅhrt werden, weil eine damit verbundene
Bedingung niemals eintritt - aber dies kann der Linker nicht herausfinden und
optimiert sie deshalb nicht weg.

  Alle Prozeduren, die auf diesem Wege nicht gefunden wurden, werden als
nicht benîtigt deklariert und somit beim  Binden  aus  den  Modulen  entfernt.
Lokale  Prozeduren  werden  Åbrigens  immer  zusammen  mit  ihren  globalen
VÑtern behandelt. Es kann nicht erkannt werden, daû lokale Prozeduren nicht
benîtigt werden. Es wird nur auf die globalen RÅcksicht genommen und die
lokalen mÅssen mitziehen (informatisches MachtgefÅge). Prozeduren, die auf
dem Ñuûersten Scope von lokalen Modulen ihren Platz haben, werden natÅrlich
wie  globale  Prozeduren  behandelt.  Bitte  erwarten  Sie  aber  nicht,  daû  die
lokalen  Modulkîrper  auch  entfernt  werden,  wenn  das  globale  Modul  keine
Variablen oder Prozeduren aus dem lokalen Modul verwendet!

  Die  beiden  Optimierungsmodi  unterscheiden  sich  nur  darin,  daû  beim
"vollstÑndigen Optimieren" auch  die  Informationen  Åber  die  Module  fÅr  das
Modul  ModBase  und  die  Prozedurnamen  entfernt  werden,  wohingegen  beim
anderen Modus diese Daten erhalten bleiben, um dem Modul  GEMError  die
gewohnte AusfÅhrlichkeit bei der Anzeige von Laufzeitfehlern zu bieten.
2.7  Bedienung: Make und ModRef                                        2 - 69
________________________________________________________


2.7    Make  und   ModRef


Prinzip eines Make

Das Make ist ein Hilfsprogramm, das nicht unbedingt zur Programmentwicklung
benîtigt wird, das aber bei umfangreicheren Programmprojekten sehr hilfreich
ist.

Arbeiten Sie an einem Programm, das aus  mehreren  Modulen  besteht,  die
hÑufig geÑndert werden, mÅssen Sie ja immer darauf achten, diese énderungen
vor einem neuen Programmstart zu Åbersetzen. Bei gleichzeitigen énderungen
in  mehreren  Modulen  kann  es  vorkommen,  daû  Sie  dann  ein  Modul  zu
Åbersetzen vergessen. Bei DefinitionsÑnderungen erhalten Sie dann meistens
eine Fehlermeldung vom Loader (welchen die Shell  dann  anzeigt)  oder  vom
Linker, daû  ein  Versionskonflikt  zwischen  den  Modulen  vorliegt.  Im  ungÅn~
stigeren Fall wird nichts bemerkt und beim Start des Programms machen sich
dann  die  vermeintlichen  énderungen  nicht  bemerkbar,  was  zu  groûer
Verwirrung fÅhren kann.

In diesem FÑllen ist es also notwendig, alle betroffenen Module neu zu Åber~
setzen. Weiû man nicht, welche das sind, ist das dann sehr zeitaufwendig. Ein
Make versucht nun, anhand bestimmter Anhaltspunkte selbst herauszufinden,
welche Module nach erfolgten énderungen neu zu Åbersetzen sind. Hierzu gibt
es  verschiedene  Verfahren.  So  kînnte  beispielsweise  der  Editor  jedes
geÑnderte Modul irgendwie markieren, indem es seinen Namen in eine Datei
schreibt. Dann kînnte das Make diese Module alle compilieren lassen. Da das
Megamax-System  aber  jeden  beliebigen  Editor  zur  Programmentwicklung
zulassen soll, wÅrde dies Verfahren nicht helfen, weil kein Fremdeditor solch
eine Markierung vornehmen wÅrde.


Arbeitsweise von Make

Die  einzige  Markierung,  die  jeder  Editor  automatisch  nach  einer  énderung
vornimmt,  liegt  darin,  daû  beim  Abspeichern  jedes  geÑnderten  Textes  das
Betriebssystem (GEMDOS) die aktuelle Tageszeit und das Datum der Datei mit
im Inhaltsverzeichnis speichert. So kann jedem Text angesehen werden, wann
er zuletzt - wahrscheinlich  nach  einer  énderung  -  gespeichert  wurde.  Da
ebenso die vom Compiler Åbersetzten Code-Dateien beim Abspeichern mit der
aktuellen Zeit vermerkt werden, kann das Make durch Vergleich der Zeiten
von Text- und Code-Datei entscheiden, welche Datei jÅnger ist: Ist ein Text
jÅnger,  muû  er  compiliert  werden,  wurde  er  daraufhin  Åbersetzt,  ist  der
resultierende Code jÅnger, woraufhin das Make beim wiederholten Start nun
alles als aktualisiert erkennt.
2.7  Bedienung: Make und ModRef                                        2 - 70
________________________________________________________


Darin liegt also das prinzipielle Vorgehen beim Megamax-Make. Voraussetzung
ist selbstverstÑndlich, daû Datum und Zeit immer stimmen, damit  ein  nach
einer öbersetzung verÑnderter Text auch wirklich eine spÑtere Zeit als die
seines Codes erhÑlt. Besitzen Sie einen Mega-ST, brauchen Sie sich  keine
Sorgen  darum  zu  machen,  weil  diese  Rechner  eine  Batterie-gepufferte
Echtzeituhr enthalten, die auch beim Ausschalten des Computers weiterlÑuft
(vorausgesetzt,  Sie  haben  auch  eine  geladene  Batterie  eingesetzt).  Den
Besitzern von anderen ST-Computern bieten sich mehrere Lîsungen: Auch fÅr
diese Rechner gibt es einsteckbare, nicht-flÅchtige Echtzeituhren zu kaufen.
VerfÅgen Sie nicht Åber so einen Zusatz, mÅssen Sie die Zeit nach jedem
Rechnerstart  (auch  beim  Druck  auf  den  RESET-Taster)  neu  stellen.  Dazu
kînnen  Sie  beispielsweise  das  bei  Ihrem  Atari  mitgelieferte  Accessory
CONTROL.ACC  verwenden.  Ebensogut  kînnen  Sie  auch  aus  dem  UTILITY-
Ordner das Programm Timer (Dateiname: TIMER.M) compilieren, linken und als
Accessory mit der Endung ACC auf ihre Boot-Disk kopieren.

Am komfortabelsten fÅr Anwender ohne Echtzeituhr ist  es,  das  Programm
SetTime aus dem UTILITY-Ordner zu verwenden: Es muû Åbersetzt und gelinkt
und dann in den AUTO-Ordner kopiert werden. Schalten Sie den Rechner neu
ein, erkennt das Programm, daû noch keine gÅltige Zeit eingestellt ist  und
fordert Sie dazu auf. Wenn Sie dann spÑter den Rechner neu booten, ohne ihn
auszuschalten  (z.B.  durch  Druck  auf  den  RESET-Taster),  ÅbertrÑgt  das
Programm die im Tastatur-Chip des Atari gespeicherte Zeit (die erst beim
Ausschalten des Atari verloren geht) automatisch an das GEMDOS, welches
fÅr die Zeit der Dateien zustÑndig ist, eine erneute Eingabe bleibt Ihnen damit
erspart.

Das Verfahren des Zeitvergleichs bei den Dateien ist allerdings nicht optimal:
Es kann ja auch vorkommen, daû in einem Modultext nur énderungen an der
Dokumentation vorgenommen werden, so daû keine NeuÅbersetzung notwendig
wÑre. Das ist eben ein kleiner Seiteneffekt, der wohl auch von Ihnen akzeptiert
werden kann, oder? Nebenbei: Achten Sie auf die Dokumentationen  zu  den
mitgelieferten Editoren. So bietet Ihnen beispielsweise der Gepard-Editor die
Mîglichkeit, den Text mit "K" zu speichern. Dann wird die vorige Zeit der
Datei beibehalten, so daû Make nicht darauf anspricht.

Nun ist das Problem der Markierung von énderungen an den Modulen gelîst.
Aber es gibt noch  ein  weiteres:  éndern  Sie  ein  Definitionsmodul,  das  von
weiteren  Modulen  importiert  wird,  an  denen  Sie  aber  keine  énderungen
vornehmen, mÅssen diese trotzdem Åbersetzt werden. Damit das Make dies
erkennen  kann,  muû  es  Åber  die  augenblicklichen  Import-VerhÑltnisse  der
beteiligten Module informiert sein. Es bietet sich an, ausgehend vom Haupt~
modul des Programms, alle importierten Module zu beschreiben, wiederum mit
deren Importen usw. Diese Beschreibung erfolgt in einer Datei, die dann vom
Make ausgewertet wird:
2.7  Bedienung: Make und ModRef                                        2 - 71
________________________________________________________


Das Make sieht sich zuerst die Definitionstexte in der Reihenfolge an, in der
sie importiert werden: Die Module, die selbst keine mehr importieren zuerst,
die, die von keinem  anderen  importiert  werden  zuletzt.  Ist  dabei  ein  Text
jÅnger als sein Code, oder existiert der Code gar noch nicht, wird es zur
öbersetzung markiert. Alle Definitionen, die ein markiertes Modul importieren,
werden  ebenfalls  markiert.  Dann  wird  ebenso  bei  den  Implementationen
verfahren: Ist die eigene Definition oder die eines Imports markiert oder ist
der Text jÅnger als der Code, bzw. fehlt der Code, wird es auch markiert.
Zuletzt werden alle markierten Module in eine Textdatei geschrieben und das
Make sorgt dafÅr, daû die Module vom Compiler Åbersetzt werden.


Erstellung einer Make-Datei (ModRef)

In der Make-Datei wird  das  Hauptmodul  mitsamt  aller  importierter  Module
beschrieben. Um solch eine Datei zu erzeugen, kann das Programm ModRef
verwendet werden. Am besten melden Sie ModRef als Tool an (siehe Kap. 2.2,
Batch-Dateien).

Wird ModRef ausgefÅhrt, zeigt es den GEM-Datei-Selektor, mit dem dann ein
Hauptmodul (Åblicherweise Dateien mit der Endung "M") ausgewÑhlt  werden
kann.  Dann  liest  das  Programm  den  Quelltext  ein  und  registiert  all  seine
Importe. Danach werden all die importierten Module gesucht, und zwar sowohl
die Code-Dateien von Definition und Implementation als auch die zugehîrigen
Quelltexte.  Dabei  werden  Module  ignoriert,  deren  Definitions-Codes  in  der
unter den Compiler-Parametern eingetragenen Bibliotheks-Datei enthalten sind.
Das hat den Effekt, daû solche Module dann nicht mehr vom Make geprÅft zu
werden brauchen, was bei den in der Bibliothek enthaltenen Megamax-Modulen
auch nicht mehr nîtig ist, da ihre  Codes  sowohl  vorhanden  sind  als  auch
normalerweise nicht verÑndert werden.

Werden  Texte  von  Modulen  nicht  gefunden,  werden  sie  auch  nicht  in  der
Make-Datei  berÅcksichtigt,  zur  Sicherheit  erfolgt  aber  ein  Hinweis  vom
ModRef, daû es bestimmte Dateien nicht finden konnte. Wenn Sie vor dem
Start  von  ModRef  nur  bestimmte  Verzeichnisse  als  Suchpfade  fÅr  die
Quelltexte eintragen (z.B. mit Hilfe von PathEdit), kînnen Sie bequem Modul~
sammlungen fÅr verschiedene Projekte auseinander halten.

Sind  alle  Importe  festgestellt,  erscheint  der  Datei-Selektor  von  Neuem.
Normalerweise ist nun Abbruch zu wÑhlen, woraufhin eine Make-Datei erzeugt
wird, die den Namen des Hauptmoduls trÑgt, jedoch mit der Endung M2M. Die
Datei  wird  im  selben  Verzeichnis  abgelegt  in  der  auch  der  Quelltext  des
Hauptmoduls  steht.  Statt  des  Abbruchs  kann  auch  ein  weiteres  Modul
angewÑhlt werden. Dann wird dieses Modul samt seiner Importe ebenfalls in
die Make-Datei aufgenommen. Damit wird erreicht, daû bei einem Make auch
zusÑtzliche zum Projekt gehîrende Module gemaked werden kînnen.
2.7  Bedienung: Make und ModRef                                        2 - 72
________________________________________________________


Wollen  Sie  gar  alle  Module  aus  einem  Verzeichnis  in  die  Make-Datei
aufnehmen,  kînnen  Sie  den  Modulnamen  mit  Wildcards  eingeben,  also
beispielsweise *.M fÅr alle Hauptmodule des Verzeichnisses.

Muû hÑufig die selbe Make-Datei neu erzeugt werden (s.u.), kann dies Åber
einen Batch vereinfacht werden: Schreiben Sie einen Batch, der die folgende
Zeile enthÑlt:
  ModRef  <Quelltextnamen>
Melden Sie diese Textdatei (mit Endung M2B!) am besten als Tool an. Wird
dieser Batch ausgefÅhrt, wird nicht mehr mit dem Datei-Selektor nach dem
Quelltextnamen gefragt, sondern der angegebene verwendet. Es kînnen auch
mehrere  Textnamen  hintereinander  aufgefÅhrt  werden,  um  dasselbe  zu
erreichen, wie durch die wiederholte Auswahl mit dem Datei-Selektor.

Es ist darauf zu achten, daû bei jeder énderung der Import-Strukturen der
beteiligten  Module  die  Make-Datei  neu  erzeugt  wird!  Wird  dies  vergessen,
arbeitet das Make zwar meist einwandfrei, trotzdem zeigen sich beim Start
des Programms oft Fehler, wie beispielsweise Versionskonflikte.


Anwendung von Make

Das  Make-Programm  heiût  MM2Make  und  wird  in  den  Shell-Parametern
eingetragen. Der Aufruf erfolgt, indem eine Make-Datei  (Endung  M2M)  zur
AusfÅhrung gebracht wird, indem sie also beispielsweise aus einem Fenster auf
das AusfÅhren-Symbol gezogen wird. SelbstverstÑndlich kînnen Make-Dateien
auch als Tool angemeldet sein.

Einen Sonderstatus genieût die Make-Datei, die als Default-Make eingetragen
ist (unter Info/Umgebung). Sie kann jederzeit durch die Taste M in der Shell
oder durch eine Sonderfunktion beim Verlassen der Editoren (siehe Kapitel 2.3)
aktiviert werden.

Bei  der  Aktivierung  des  Make  wird  zuerst  die  betroffene  Make-Datei
eingelesen,  dann  werden,  wie  oben  beschrieben,  die  DatumseintrÑge  der
Dateien geprÅft. Am Ende wird eine Datei, die alle zu Åbersetzenden Texte
auffÅhrt, unter dem Namen MAKE.M2C im temporÑren Pfad (einzustellen in
den Shell-Parametern) abspeichert. Sind keine Dateien zu Åbersetzen, liefert
MM2Make den ExitCode Eins, sonst Null. Daran erkennt die Shell dann, ob sie
daraufhin  den  Compiler  aufrufen  soll.  Der  Åbersetzt  dann  die  geforderten
Module alle auf einmal.

Zeigt das Make also den Fehler Ausgabedatei konnte nicht angelegt werden an,
liegt es meistens daran, daû der temporÑre Pfad nicht auf ein vorhandenes,
beschreibbares Verzeichnis zeigt.
2.7  Bedienung: Make und ModRef                                        2 - 73
________________________________________________________


Stîût  der  Compiler  beim  öbersetzen  auf  einen  Fehler,  wird  der  Editor
gestartet, um ihn wie gewohnt anzuzeigen. Ist der Fehler korrigiert, kann das
Make fortgesetzt werden, indem der Editor mit dem Kommando zum Make
verlassen wird. In diesem Fall wird nicht das Default-Make sondern die aktive
Make-Datei wieder verwendet, mit der ein erneuter Make-Aufruf stattfindet.

Wird der Editor nach einem Fehler nicht mit dem Make-Kommando verlassen,
erinnert die Shell daran, daû der Make-Vorgang noch nicht abgeschlossen ist,
und bietet Ihnen an, diesen fortzufÅhren oder abzubrechen.

Sind syntaktische Fehler in der Make-Datei vorhanden, oder kînnen benîtigte
Dateien nicht gefunden werden, wird das Make abgebrochen und entweder die
Fehler auf dem Bildschirm angezeigt oder der Editor geladen, um dort den
Fehler in der Make-Datei anzuzeigen.


Alle Module unbedingt Åbersetzen (Build )

Wollen Sie alle Module einer Make-Datei unabhÑngig von ihrem Datum Åber~
setzen, kînnen Sie dies dem Make-Programm durch öbergabe der Option "-B"
mitteilen. Entweder starten Sie das Make-Programm manuell (im Batch oder
durch Doppelklick) und Åbergeben in der Argumentzeile den Make-Dateinamen
zusammen mit -B oder Sie tragen -B hinter dem Namen der Make-Datei in
den Umgebungsinformationen ein. Das hat sogar den Vorteil, daû  das  "-B"
nach dem Make wieder daraus entfernt wird - denn einmal reicht's ja wohl.


Fehlermeldungen des Make

Zu wenig Speicher.
  Abhilfe: Residente Module/Programme entfernen.
Make-Datei ist leer.
  Die eingelesene Make-Datei enthÑlt keine Daten
... hat ungÅltiges Datum.
  Die Zeit der angezeigten Datei liegt hinter der aktuellen Zeit.
Dateifehler: ...
  Fehler beim Einlesen oder Anlegen der Datei.
Modul ist doppelt deklariert.
  Jedes Modul darf nur einmal in der Make-Datei deklatiert werden.
... wurde nicht oder unvollstÑndig deklariert.
  Das Modul ist bei IMPORT angebeben aber nicht deklariert.
Datei(en) nicht gefunden.
  Die Datei(en) sind nicht auf den entspr. Suchpfaden zu finden.
Ausgabedatei konnte nicht angelegt werden. (Stimmt "Temp.Pfad"?)
  Wahrscheinlich ist der Temp. Pfad in den Shell-Parametern ungÅltig.
Syntaxfehler.
  Wahrscheinlich wurde zuvor ein Semikolon bei einer Modulliste vergessen.
2.7  Bedienung: Make und ModRef                                        2 - 74
________________________________________________________


Syntax der Make-Dateien

moduldefinition =
  <modulname> ( -IGNORE | codedefinition )

codedefinition =
  ( -MOD | -IMP | -DEF ) <dateiname>
    -MAIN  
  ( -NOSRC | sourcedefinition )

sourcedefinition =
  -SOURCE <dateiname>
    -INC <dateiliste)  
    -USES <dateiliste)  
    -IMPORT <modulliste)  

dateiliste =
    dateiname   ";"

modulliste =
    modulname   ";"

Jedes in der Modulliste (nach -IMPORT) vorkommende  Modul  muû  definiert
sein! Wird es mit -IGNORE definiert, wird es vom Make ignoriert. Mit -INC
kînnen Dateien bestimmt werden, die mittels der Include-Direktive mit in den
Modulsource eingebettet sind. Mit -USES kînnen weitere abhÑngige Dateien,
z.B. Resource-Dateien, aufgefÅhrt werden. -NOSRC besagt, daû der Quelltext
zu  diesem  Code  vom  Make  nicht  berÅcksichtigt  werden  soll.  Die  Kennung
-MAIN sollte nur bei einem Modul auftauchen.  Damit  wird  das  Hauptmodul
markiert, das nach einem erfolgreichen Make-Prozeû ggf. gestartet werden
kann.
