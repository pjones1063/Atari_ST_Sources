10 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
20 rem
30 rem             WARRIORS OF LIGHT
40 rem
50 rem        Take a chance, roll the dice
60 rem          Is this hell or paradise?
70 rem
80 rem      (C) Wonderful Industries 2018-22
90 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
100 rem
110 rem 
120 rem ******* Initialise *******
130 mode 0 : hide on : VER$="0.66E" : QQQ=free : rem Save free memory at the outset
140 key off : click off : flash off : curs off : palette $0,$666,$700 : FLIP=start(5)+28 : PODGE=start(15)+28 : QUARPLAY=start(14)+28
150 if ste<1 then wipe physic : wipe back : V1$="               You must be using an STE to run WARRIORS OF LIGHT."+chr$(0) : dreg(7)=6 : dreg(0)=72 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(1)=0 : dreg(2)=0 : call PODGE : V1$="                                Hit key to exit."+chr$(0) : dreg(7)=6 : dreg(0)=160 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(1)=0 : dreg(2)=1 : call PODGE : wait key : default : end 
160 V1$="                         WARRIORS OF LIGHT, ver. "+VER$+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=32 : dreg(1)=0 : dreg(2)=1 : call PODGE
170 V1$="              Build date: 31 March 2022, the 35th day of the war"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=72 : dreg(1)=0 : dreg(2)=0 : call PODGE
180 V1$="       This is a development build, so if it wigs out and wrecks your ST,"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=112 : dreg(1)=0 : dreg(2)=0 : call PODGE
190 V1$="                     you have nobody but yourself to blame."+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=120 : dreg(1)=0 : dreg(2)=0 : call PODGE
200 V1$="                        (C) Wonderful Industries 2018-22"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=176 : dreg(1)=0 : dreg(2)=0 : call PODGE
210 dim CTL(24),C(15)
220 dim CURLOC$(4),XT(4),YT(4),CANVECT(4),MVECT(4),CURVECT(4),SUBGRIDM(5,5),SUBGRIDT(5,5),FIZZOG$(16) : NUMCRIT=0
230 dim FACE(4),RELFACE(4,4) : STDM=1 : WT=3 : MAGIC=2
240 for ZX=1 to 4 : for ZY=1 to 4 : read RELFACE(ZX,ZY) : next ZY : next ZX
250 dim VECTGRID(4,5,5) : for C=1 to 4 : for Y=1 to 5 : for X=1 to 5 : read VECTGRID(C,X,Y) : next X : next Y : next C
260 dim CREDSCRL$(354) : for ZZ=0 to 354 : read CREDSCRL$(ZZ) : next ZZ
270 rem Insert loop here to read stereo intensity table
280 dim CAUSE$(13) : for ZZ=0 to 13 : read CAUSE$(ZZ) : next ZZ
282 dim OBJSAUCEX(320),OBJSAUCEY(320) : rem Don't need w and h because they're always a 64*24 block
285 for ZZ=1 to 315 : read OBJSAUCEX(ZZ),OBJSAUCEY(ZZ) : next ZZ
290 rem Insert loop here to read dialogue wodge
300 rem on error goto 16280 : rem We don't need to handle errors elegantly yet.
310 reserve as screen 8 : reserve as screen 9 : reserve as screen 13
320 if drive$="A" or drive$="B" then FLOP=true else FLOP=false
330 if FLOP=true then dir$="\" : rem We need to keep track of this given that it needs to know about a floppy drive when we do save/load.
340 open in #1,"credlogo.eph" : LL=lof(#1) : CREDLOGO$=input$(#1,LL+2) : close #1
350 rem open in #1,"faces.eph" : for ZZ=1 to 16 : line input #1,LL$ : PORTRAIT$(ZZ)=input$(#1,val(LL$)+2) : next ZZ : close #1
360 bload "settings.cfg",varptr(CTL(0))
370 load "wi2021.mbk",13 : unpack 13,8 : palette $0,$666,$700 : erase 13
380 load "menu2.mbk",13 : unpack 13,9 : palette $0,$666,$700
390 erase 13
400 rem We now have a scroller for credits so don't bother with this.
410 rem Don't unpack here
420 M8=start(8) : M9=start(9) : M2=start(2)
430 open in #1,"dethnite.4v" : LL=lof(#1) : close #1 : reserve as work 7,LL : bload "dethnite.4v",start(7)
440 wipe back : wipe physic : wipe logic
450 get palette (8)
460 for ZZ=64 to 0 step-1
470 blit M8,96,0,224,128,logic,96,0-(ZZ*2) : blit M8,0,128,320,200,logic,0,128+ZZ
480 wait vbl : next ZZ : rem The Wonderful Industries Noise is the F minor bass arpeggio with an elecpiano note on the final C 3 octaves above. Must get a proper mic to record this. Or record directly from my keyboard.
490 for ZZ=1 to 145 : wait vbl : next ZZ : wipe logic
500 dreg(0)=0 : call 14 : dreg(0)=5 : dreg(1)=4 : call 14 : rem Don't start the music until after the ident
510 dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14
520 rem This is deprecated now we have the credit scroller
530 rem ******* The Main Menu ********
540 palette $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$112,$223,$334,$446,$7
550 hide on : FF=6
560 blit M9,0,0,320,144,back,0,0 : fastcopy back,physic
570 for ZZ=0 to 50 : wait vbl : next ZZ : rem Insert a "foosh!" sound effect here
580 for ZZ=1 to 10 : flash ZZ,"(400,4)(500,4)(520,4)(630,4)(740,4)(750,4)(770,4)(776,4)(774,4)(760,4)(740,4)(630,4)(520,4)(500,4)(400,4)(300,4)" : wait vbl : wait vbl : wait vbl : wait vbl : next ZZ
590 for ZZ=0 to 50 : wait vbl : next ZZ
600 for ZZ=200 to 144 step-4 : blit M9,0,144,320,200,physic,0,ZZ : wait vbl : next ZZ : rem Insert a "clang!" sound effect here
605 blit M9,0,144,320,200,back,0,144
610 change mouse STDM : show on 
620 setrtim 0 : ZF=0
630 reset zone : pen 14
640 set zone 1,11,148 to 88,169 : set zone 2,122,148 to 199,169 : set zone 3,232,148 to 310,169 : set zone 4,67,174 to 144,196 : set zone 5,178,174 to 256,196
650 repeat : Z=zone(0) : MB=mouse key : until MB>0
690 if MB=1 and Z>0 then on Z gosub 1080,780,1170,850,1150 : rem Spaghetti code ftw
700 goto 630
770 return 
780 rem ******* Begin new game *******
790 flash off : fade 5 : change mouse WT
800 for WW=1 to 45 : wait vbl : next WW : wipe back : wipe logic : wipe physic
810 dreg(0)=2 : call QUARPLAY : dreg(0)=3 : call QUARPLAY : erase 7
820 load "interf6.mbk",13 : unpack 13,8 : erase 13
830 fade 5,$0,$662,$743,$532,$421,$310,$200,$600,$21,$42,$63,$112,$223,$334,$446,$15 : for WW=1 to 45 : wait vbl : next WW
840 goto 1900
850 rem ******* Credits Scroller ********
860 fade 1 : for ZZ=0 to 15 : wait vbl : next ZZ
870 dreg(0)=2 : call QUARPLAY : dreg(0)=3 : call QUARPLAY : erase 7
880 open in #1,"credits.4v" : LL=lof(#1) : close #1 : reserve as work 7,LL : bload "credits.4v",start(7) : M7=start(7)
890 dreg(7)=4 : areg(0)=physic : call PODGE : dreg(7)=4 : areg(0)=back : call PODGE : hide on : mouseoff 
900 dreg(0)=0 : call 14 : dreg(0)=5 : dreg(1)=4 : call 14 : dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14 : rem Begin credits music
910 dreg(7)=3 : areg(0)=varptr(CREDLOGO$) : areg(1)=logic : dreg(0)=96 : dreg(1)=10 : dreg(2)=0 : call PODGE
920 for ZZ=0 to 10 : ZY=104+(ZZ*8) : V1$=CREDSCRL$(ZZ)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=ZY : dreg(1)=0 : dreg(2)=0 : call PODGE : next ZZ
930 fade 1,$0,$666,$0,$0,$0,$0,$0,$0,$0,$300,$600,$112,$223,$334,$446,$7 : for ZZ=0 to 610 : wait vbl : next ZZ
940 fade 1 : for ZZ=0 to 15 : wait vbl : next ZZ
950 dreg(7)=4 : areg(0)=logic : call PODGE : colour 1,$666
960 ZZ=11 : repeat 
970 HH=hardkey : dreg(7)=6 : V1$=CREDSCRL$(ZZ)+chr$(0) : areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=190 : dreg(1)=0 : dreg(2)=0 : call PODGE
980 skopy 1,logic,0,2,320,200,logic,0,0 : wash logic,0,198,320,200 : wait vbl : skopy 1,logic,0,2,320,200,logic,0,0 : wash logic,0,198,320,200 : wait vbl : skopy 1,logic,0,2,320,200,logic,0,0 : wash logic,0,198,320,200 : wait vbl : skopy 1,logic,0,2,320,200,logic,0,0 : wash logic,0,198,320,200 : wait vbl 
990 inc ZZ : until ZZ=354
1000 if ZZ=354 then for A=1 to 130 : wait vbl : next A
1010 dreg(0)=2 : call QUARPLAY : dreg(0)=3 : call QUARPLAY : erase 7 : fade 1
1020 for ZZ=1 to 15 : wait vbl : next ZZ : dreg(7)=4 : areg(0)=physic : call PODGE : mouseon 
1030 open in #1,"dethnite.4v" : LL=lof(#1) : close #1 : reserve as work 7,LL : bload "dethnite.4v",start(7)
1040 dreg(0)=0 : call 14
1050 dreg(0)=5 : dreg(1)=4 : call 14
1060 dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14
1070 goto 530
1080 rem ******* Gorgeous Animated Intro *******
1090 rem Yeah, this requires more drawing than I'm capable of.
1100 hide on : M$=screen$(back,0,0 to 320,200) : wipe back : wipe logic : wipe physic
1110 ink 13 : polyline 32,40 to 40,32 to 280,32 to 288,40 to 288,160 to 280,168 to 40,168 to 32,160 to 32,40
1111 dreg(7)=6 : V1$="   I N S E R T   I N T R O   H E R E "+chr$(0)
1112 areg(0)=varptr(V1$) : areg(1)=logic : dreg(0)=96 : dreg(1)=96 : dreg(2)=0 : call PODGE
1120 for ZZ=0 to 259 : wait vbl : next ZZ
1121 wipe logic
1130 quick screen$ back,0,0,M$,0 : fastcopy back,physic : show on : M$=""
1140 return 
1150 rem ******* Quittin' Time ********
1160 fade 5 : for WW=1 to 100 : wait vbl : next WW : dreg(0)=2 : call 14 : dreg(0)=3 : call 14 : default : clear key : end 
1170 rem ******* Settings page ********
1180 areg(0)=back : areg(1)=M9 : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE : rem flash off
1185 for A=0 to 15 : C(A)=colour(A) : next A
1186 flash off : for A=0 to 15 : colour A,C(A) : next A
1190 dreg(0)=2 : call QUARPLAY : dreg(0)=3 : call QUARPLAY
1200 reset zone 
1220 rem colour 1,$666 : colour 13,$445 : colour 6,$600 : colour 2,$334
1230 ink 0 : polygon 16,24 to 24,16 to 144,16 to 160,8 to 176,16 to 296,16 to 304,24 to 304,176 to 296,184 to 176,184 to 160,192 to 144,184 to 24,184 to 16,176 to 16,24
1240 ink 13 : polyline 16,24 to 24,16 to 144,16 to 160,8 to 176,16 to 296,16 to 304,24 to 304,176 to 296,184 to 176,184 to 160,192 to 144,184 to 24,184 to 16,176 to 16,24
1250 V1$="S E T T I N G S"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=24 : dreg(1)=128 : dreg(2)=1 : call 15 : ink 6 : draw 128,32 to 186,32 : draw 128,34 to 186,34
1260 dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=24 : dreg(1)=128 : dreg(2)=2 : call 15
1270 V1$="Move Forward"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=56 : dreg(1)=32 : dreg(2)=0 : call 15
1280 V1$="Reverse"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=64 : dreg(1)=32 : dreg(2)=0 : call 15
1290 V1$="Left Turn"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=72 : dreg(1)=32 : dreg(2)=0 : call 15
1300 V1$="Right Turn"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=80 : dreg(1)=32 : dreg(2)=0 : call 15
1310 V1$="Strafe Left"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=88 : dreg(1)=32 : dreg(2)=0 : call 15
1320 V1$="Strafe Right"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=96 : dreg(1)=32 : dreg(2)=0 : call 15
1330 V1$="Inventory"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=104 : dreg(1)=32 : dreg(2)=0 : call 15
1340 V1$="Quick Slot 1"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=112 : dreg(1)=32 : dreg(2)=0 : call 15
1350 V1$="Quick Slot 2"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=120 : dreg(1)=32 : dreg(2)=0 : call 15
1360 V1$="Pause Menu"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=128 : dreg(1)=32 : dreg(2)=0 : call 15
1370 V1$="Spellbook"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=136 : dreg(1)=32 : dreg(2)=0 : call 15
1380 V1$="  Key Bindings"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=40 : dreg(1)=32 : dreg(2)=1 : call 15 : ink 2 : draw 40,49 to 88,49
1390 V1$="  Difficulty"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=40 : dreg(1)=192 : dreg(2)=1 : call 15 : ink 2 : draw 200,49 to 240,49
1400 V1$=" Casual   Normal   Tough   Sadistic"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=56 : dreg(1)=160 : dreg(2)=0 : call 15
1410 V1$="  Auto Save"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=80 : dreg(1)=192 : dreg(2)=1 : call 15 : ink 2 : draw 200,89 to 236,89
1420 V1$=" Frequent   Level Change   Never"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=96 : dreg(1)=160 : dreg(2)=0 : call 15
1430 V1$="  Auto Map"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=120 : dreg(1)=192 : dreg(2)=1 : call 15 : ink 2 : draw 200,129 to 232,129
1440 V1$=" Real Adventurer   Quiche Eater"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=136 : dreg(1)=160 : dreg(2)=0 : call 15
1450 V1$=" D O N E"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=172 : dreg(1)=144 : dreg(2)=1 : call 15 : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=172 : dreg(1)=144 : dreg(2)=2 : call 15
1460 ink 13 : polyline 144,165 to 176,165 to 195,184 to 176,184 to 160,192 to 144,184 to 125,184 to 144,165
1470 rem Update all
1475 wash back,96,48,112,144
1480 for ZZ=1 to 21 step 2 : F=(((ZZ+1)/2)*8)+48 : V1$=left$(str$(CTL(ZZ)),4)+chr$(0)
1490 dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=F : dreg(1)=96 : dreg(2)=0 : call 15
1500 next ZZ
1510 ink 13 : box 94,54 to 114,146 : ink 6
1511 ink 0 : box 162,54 to 190,66 : box 198,54 to 226,66 : box 234,54 to 258,66 : box 266,54 to 302,66 : box 162,94 to 194,106 : box 202,94 to 256,106 : box 266,94 to 290,106 : box 162,134 to 226,146 : box 234,134 to 284,146
1520 ink 6 : on CTL(22) goto 1530,1540,1550,1560
1530 box 162,54 to 190,66 : goto 1570
1540 box 198,54 to 226,66 : goto 1570
1550 box 234,54 to 258,66 : goto 1570
1560 box 266,54 to 302,66 : goto 1570
1570 on CTL(23) goto 1580,1590,1600
1580 box 162,94 to 194,106 : goto 1610
1590 box 202,94 to 256,106 : goto 1610
1600 box 266,94 to 290,106 : goto 1610
1610 if CTL(24)=true then box 162,134 to 226,146 else box 234,134 to 284,146
1620 set zone 99,144,165 to 176,184
1630 for ZZ=1 to 11 : set zone ZZ,96,56+((ZZ-1)*8) to 112,64+((ZZ-1)*8) : next ZZ
1635 set zone 21,162,54 to 190,66 : set zone 22,198,54 to 226,66 : set zone 23,234,54 to 258,66 : set zone 24,266,54 to 302,66
1636 set zone 31,162,94 to 194,106 : set zone 32,202,94 to 250,106 : set zone 33,266,94 to 290,106
1637 set zone 41,162,134 to 226,146 : set zone 42,234,134 to 284,146
1638 fastcopy back,physic
1640 repeat : MB=mouse key : Z=zone(0) : until MB=1
1650 if Z<1 then 1640
1660 if Z=99 then 1730
1670 if Z>0 and Z<12 then 1690
1671 if Z>20 and Z<30 then Z=Z-20 : on Z goto 1721,1722,1723,1724
1672 if Z>30 and Z<40 then Z=Z-30 : on Z goto 1725,1726,1727
1673 if Z=41 then 1728
1674 if Z=42 then 1729
1680 goto 1640
1690 ZY=56+((Z-1)*8) : ink 6 : bar 96,ZY to 112,ZY+8 : hide on 
1700 trap 13,2, .w 2 : KK=dreg(0) : rem This doesn't need a loop because the trap call is okay on its own
1710 CTL(Z*2)=KK : CTL((Z*2)-1)=KK
1720 show on : goto 1470
1721 CTL(22)=1 : goto 1470
1722 CTL(22)=2 : goto 1470
1723 CTL(22)=3 : goto 1470
1724 CTL(22)=4 : goto 1470
1725 CTL(23)=1 : goto 1470
1726 CTL(23)=2 : goto 1470
1727 CTL(23)=3 : goto 1470
1728 CTL(24)=true : goto 1470
1729 CTL(24)=false : goto 1470
1730 get palette (9) : areg(0)=M9 : areg(1)=back : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=192 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
1740 if FLOP=false then bsave "settings.cfg",varptr(CTL(0)) to varptr(CTL(0))+96
1750 dreg(0)=0 : call 14
1760 dreg(0)=5 : dreg(1)=4 : call 14
1770 dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14
1780 for ZZ=1 to 10 : flash ZZ,"(400,4)(500,4)(520,4)(630,4)(740,4)(750,4)(770,4)(776,4)(774,4)(760,4)(740,4)(630,4)(520,4)(500,4)(400,4)(300,4)" : wait vbl : wait vbl : wait vbl : wait vbl : next ZZ : rem Foosh sound effect here as well please!
1790 setrtim 0 : goto 630
1895 rem This is where character generation begins
1896 windel 3
1897 goto 1900
1898 rem ******* Loading screen *******
1899 rem REDACTED until we actually are up to this, save some memory.
1900 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-
1910 rem
1920 rem     Character Generation
1930 rem
1940 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-
1950 hide : flash off 
1960 open in #1,"venganza.4v" : LL=lof(#1) : close #1
1970 load "chargen.mbk",13 : unpack 13,9 : erase 13 : change mouse STDM
1980 reserve as work 7,LL : bload "venganza.4v",start(7)
1990 dreg(0)=0 : call 14
2000 dreg(0)=5 : dreg(1)=4 : call 14
2010 fade 5 : for AA=1 to 45 : wait vbl : next AA
2020 M9=start(9) : areg(0)=M9 : areg(1)=back : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
2030 dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14
2040 fade 5,$0,$662,$743,$532,$421,$310,$200,$600,$21,$42,$63,$112,$223,$334,$446,$15 : for NN=1 to 45 : wait vbl : next NN
2050 show 
2060 pen 1
2070 ST=50 : DE=50 : RV=50 : SA=50 : IN=50
2080 PTL=44 : reset zone 
2090 set zone 1,94,54 to 202,65
2100 set zone 2,94,70 to 120,80
2110 set zone 3,96,96 to 112,104
2120 set zone 4,144,96 to 160,104
2130 set zone 5,96,104 to 112,112
2140 set zone 6,144,104 to 160,112
2150 set zone 7,96,112 to 112,120
2160 set zone 8,144,112 to 160,120
2170 set zone 9,96,120 to 112,128
2180 set zone 10,144,120 to 160,128
2190 set zone 11,96,128 to 112,136
2200 set zone 12,144,128 to 160,136
2210 set zone 14,127,180 to 194,199
2220 set zone 15,192,152 to 208,160 : set zone 16,288,152 to 304,160
2230 set zone 17,192,160 to 208,168 : set zone 18,288,160 to 304,168
2240 rem Must insert portrait zones (maybe draw up and down arrows in red for portrait?)
2250 wash back,112,96,144,136 : wash back,208,152,288,168
2260 MXHP=SA/2+ST/3+RV/5 : MXMANA=(IN+IN+IN+RV)/8 : SATIETY=100
2270 wash back,48,144,80,152 : wash back,112,144,144,152
2280 wash back,144,160,176,170 : V1$=str$(PTL)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=160 : dreg(1)=144 : dreg(2)=0 : call PODGE
2290 V1$="  "+str$(ST)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=96 : dreg(1)=112 : dreg(2)=0 : call PODGE
2300 V1$="  "+str$(DE)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=104 : dreg(1)=112 : dreg(2)=0 : call PODGE
2310 V1$="  "+str$(RV)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=112 : dreg(1)=112 : dreg(2)=0 : call PODGE
2320 V1$="  "+str$(SA)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=120 : dreg(1)=112 : dreg(2)=0 : call PODGE
2330 V1$="  "+str$(IN)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=128 : dreg(1)=112 : dreg(2)=0 : call PODGE
2340 V1$=str$(MXHP)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=144 : dreg(1)=48 : dreg(2)=0 : call PODGE
2350 V1$="  "+str$(MXMANA)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=144 : dreg(1)=112 : dreg(2)=0 : call PODGE
2360 skopy 1,back,16,88,192,168,logic,16,88
2370 repeat : MB=mouse key : Z=zone(0) : wait vbl : until MB<>0
2380 on Z gosub 2400,2500,2600,2550,2690,2640,2780,2730,2870,2820,2960,2910,3030,3040
2390 wait vbl : goto 2250
2400 inverse on : locate 12,7 : M=0 : NAME$=""
2410 hide 
2420 print space$(13); : locate 12,7
2430 repeat 
2440 M$=input$(1) : locate 12+M,7 : print M$; : NAME$=NAME$+M$
2450 inc M
2460 until M>=13 or M$=chr$(13)
2470 inverse off : locate 12,7 : print space$(13); : locate 12,7 : print NAME$;
2480 show 
2490 return 
2500 locate 12,9
2510 if GEN$="M" then GEN$="F" else GEN$="M"
2520 print " ";GEN$;" "; : rem Must remember to tweak portrait choice here
2530 wait vbl 
2540 repeat : MB=mouse key : until MB=0 : return 
2550 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=96 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=96 : dreg(2)=8 : call PODGE : wait vbl 
2560 if ST>=80 then 2590
2570 if PTL<1 then 2590
2580 if ST<80 and PTL>0 then inc ST : dec PTL
2590 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=96 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=96 : dreg(2)=8 : call PODGE : wait vbl : return 
2600 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=96 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=96 : dreg(2)=8 : call PODGE : wait vbl 
2610 if ST<=20 then 2630
2620 if ST>20 then dec ST : inc PTL
2630 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=96 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=96 : dreg(2)=8 : call PODGE : wait vbl : return 
2640 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=104 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=104 : dreg(2)=8 : call PODGE : wait vbl 
2650 if DE>=80 then 2680
2660 if PTL<1 then 2680
2670 if DE<80 and PTL>0 then inc DE : dec PTL
2680 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=104 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=104 : dreg(2)=8 : call PODGE : wait vbl : return 
2690 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=104 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=104 : dreg(2)=8 : call PODGE : wait vbl 
2700 if DE<=20 then 2720
2710 if DE>20 then dec DE : inc PTL
2720 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=104 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=104 : dreg(2)=8 : call PODGE : wait vbl : return 
2730 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=112 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=112 : dreg(2)=8 : call PODGE : wait vbl 
2740 if RV>=80 then 2770
2750 if PTL<1 then 2770
2760 if RV<80 and PTL>0 then inc RV : dec PTL
2770 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=112 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=112 : dreg(2)=8 : call PODGE : wait vbl : return 
2780 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=112 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=112 : dreg(2)=8 : call PODGE : wait vbl 
2790 if RV<=20 then 2810
2800 if RV>20 then dec RV : inc PTL
2810 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=112 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=112 : dreg(2)=8 : call PODGE : wait vbl : return 
2820 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=120 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=120 : dreg(2)=8 : call PODGE : wait vbl 
2830 if SA>=80 then 2860
2840 if PTL<1 then 2860
2850 if SA<80 and PTL>0 then inc SA : dec PTL
2860 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=120 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=120 : dreg(2)=8 : call PODGE : wait vbl : return 
2870 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=120 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=120 : dreg(2)=8 : call PODGE : wait vbl 
2880 if SA<=20 then 2900
2890 if SA>20 then dec SA : inc PTL
2900 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=120 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=120 : dreg(2)=8 : call PODGE : wait vbl : return 
2910 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=128 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=128 : dreg(2)=8 : call PODGE : wait vbl 
2920 if IN>=80 then 2950
2930 if PTL<1 then 2950
2940 if IN<80 and PTL>0 then inc IN : dec PTL
2950 dreg(7)=8 : areg(0)=back : dreg(0)=96 : dreg(1)=128 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=96 : dreg(1)=128 : dreg(2)=8 : call PODGE : wait vbl : return 
2960 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=128 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=128 : dreg(2)=8 : call PODGE : wait vbl 
2970 if IN<=20 then 2990
2980 if IN>20 then dec IN : inc PTL
2990 dreg(7)=8 : areg(0)=back : dreg(0)=144 : dreg(1)=128 : dreg(2)=8 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=144 : dreg(1)=128 : dreg(2)=8 : call PODGE : wait vbl : return 
3000 rem Traits up/down
3010 rem Portrait up/down 
3020 wipe M9 : load "inve2.mbk",13 : unpack 13,9 : erase 13 : INV$=screen$(9,16,0 to 208,192)
3030 dreg(0)=2 : call 14 : dreg(0)=3 : call 14 : erase 9 : end 
3040 hide : rem <<<<<<<<<<< THIS IS WHERE TO HOP TO WHEN LOADING OLD GAME
3050 dreg(0)=2 : call 14 : dreg(0)=3 : call 14 : erase 7
3060 wipe M9 : load "inve2.mbk",13 : unpack 13,9 : erase 13 : INV$=screen$(9,16,0 to 208,192)
3070 CHP=MXHP : CMANA=MXMANA
3080 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
3090 rem
3100 rem  Stub initialiser for Warriors
3110 rem
3120 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
3130 click off : flash off 
3140 hide on : DAMAGE=0 : STATUSFX=0 : ZZ$=""+chr$(0)
3141 dim BADSTUFF$(7) : BADSTUFF$(0)="Hungry" : BADSTUFF$(1)="Poisoned" : BADSTUFF$(2)="Sick" : BADSTUFF$(3)="Blinded" : BADSTUFF$(4)="Slowed" : BADSTUFF$(5)="Bleeding" : BADSTUFF$(6)="Hardening" : BADSTUFF$(7)="Paralysed"
3150 M1=start(1) : M8=start(8) : clw 
3160 open in #1,"demise.4v" : LL=lof(#1) : close #1
3170 reserve as work 7,LL : bload "demise.4v",start(7) : rem We keep the death music in memory at all times
3180 open in #1,"objdir5.csv" : input #1,A$,B$,C$,D$,E$,F$,G$,H$,I$,J$,K$,L$,M$,N$,O$,P$,Q$,R$,S$,T$,U$,V$,W$,X$ : rem Need to disregard the first line
3190 dim OBJNAME$(150),OBJICN(150),OBJHERE(150),OBJNEAR(150),OBJFAR(150),OBJVFAR(150),OBJVVFAR(150),PROJNEAR(150),PROJFAR(150),PROJVFAR(150),PROJVVFAR(150),OBJTYPE$(150),BUFF(150),BUFFAMOUNT(150),DAMTYPE(150),OBJAF(150),OBJDF(150),OBJAC(150),OBJFX(150),VERB$(150),STRREQ(150),INREQ(150),RESREQ(150),PAWS(150)
3194 dim LEVNAME$(15),LEVFILE$(15),LEVDISK(15)
3200 dim INVX(16),INVY(16),PLAC$(4),PLACL$(2),PLACR$(2),BUT$(3),BUTL$(2),BUTR$(2),LOCKPANEL$(10,4),LOCKL$(10,2),LOCKR$(10,2),TELEP$(2,4),DCR$(3,4),DCR4A$(3),DCR4B$(3),HOLE$(3),PLATE$(3),SLOGZN$(3),ANGWLL$(4),ANGWLR$(4),DCRDESC$(3)
3210 dim MNAME$(60),MMHP(60),MBEHAV(60),MWT(60),MHT(60),MSPD(60),MGRAF$(60),MFRAME$(4,10,4),M(4),MXOFS(70),MYOFS(70)
3220 dim PROJPOSX(4,3),PROJPOSY(4,3) : PROJPOSX(1,1)=64 : PROJPOSX(1,3)=160 : PROJPOSX(1,2)=112 : PROJPOSX(2,1)=80 : PROJPOSX(2,2)=112 : PROJPOSX(2,3)=144 : PROJPOSX(3,1)=84 : PROJPOSX(3,2)=112 : PROJPOSX(3,3)=132 : PROJPOSX(4,1)=76 : PROJPOSX(4,2)=112 : PROJPOSX(4,3)=124 : PROJPOSX(0,1)=48 : PROJPOSX(0,2)=112 : PROJPOSX(0,3)=176
3230 PROJPOSY(0,2)=72 : PROJPOSY(1,2)=80 : PROJPOSY(2,2)=88 : PROJPOSY(3,2)=92 : PROJPOSY(4,2)=94
3240 for AA=0 to 4 : PROJPOSY(AA,1)=PROJPOSY(AA,2) : PROJPOSY(AA,3)=PROJPOSY(AA,2) : next AA
3250 INVX(1)=38 : INVY(1)=146 : INVX(2)=57 : INVY(2)=146 : INVX(3)=76 : INVY(3)=146 : INVX(4)=95 : INVY(4)=146 : INVX(5)=114 : INVY(5)=146 : INVX(6)=133 : INVY(6)=146 : INVX(7)=152 : INVY(7)=146 : INVX(8)=171 : INVY(8)=146
3251 INVX(9)=38 : INVY(9)=165 : INVX(10)=57 : INVY(10)=165 : INVX(11)=76 : INVY(12)=165 : INVX(12)=95 : INVY(12)=165 : INVX(13)=114 : INVY(13)=165 : INVX(14)=133 : INVY(14)=165 : INVX(15)=152 : INVY(15)=165 : INVX(16)=171 : INVY(8)=165
3253 TICS=0 : T0CS=0 : MSHUF=0
3260 Z=1 : repeat : input #1,A$,B$,C$,D$,E$,F$,G$,H$,I$,J$,K$,L$,M$,N$,O$,P$,Q$,R$,S$,T$,U$,V$,W$,X$
3270 OBJNAME$(Z)=A$ : OBJICN(Z)=val(B$) : OBJHERE(Z)=val(C$) : OBJNEAR(Z)=val(D$) : OBJFAR(Z)=val(E$) : OBJVFAR(Z)=val(F$) : OBJVVFAR(Z)=val(G$) : PROJNEAR(Z)=val(H$) : PROJFAR(Z)=val(I$) : PROJVFAR(Z)=val(J$) : PROJVVFAR(Z)=val(K$) : OBJTYPE$(Z)=L$ : BUFF(Z)=val(M$) : BUFFAMOUNT(Z)=val(N$)
3272 DAMTYPE(Z)=val(O$) : OBJAF(Z)=val(P$) : OBJDF(Z)=val(Q$) : OBJAC(Z)=val(R$) : OBJFX(Z)=val(S$) : VERB$(Z)=T$ : STRREQ(Z)=val(U$) : INREQ(Z)=val(V$) : RESREQ(Z)=val(W$) : PAWS(Z)=val(X$)
3275 STBUFF=0 : DEBUFF=0 : INBUFF=0 : SABUFF=0 : REBUFF=0 : HPBUFF=0 : MANABUFF=0
3280 inc Z : until eof(1)=true : TALOBJS=Z
3290 close #1
3300 reserve as work 6,131176 : M6=start(6) : rem We need to make sure a bank is free for the player journal. Maybe hive off 2 and 4 to external files that we load in? That way we can use 2 for chobjects and 4 for sounds and thus 6 for the player journal.
3310 open in #1,"monstdir.csv"
3320 Z=1 : repeat 
3330 input #1,MNAME$(Z),MWT$,MHT$,MBH$,MAF$,MDF$,MSPD$,MMHP$,MRES$,MATK$,MGRAF$(Z)
3340 MWT(Z)=val(MWT$) : MHT(Z)=val(MHT$) : MBEHAV(Z)=val(MBH$) : MSPD(Z)=val(MSPD$) : MMHP(Z)=val(MMHP$) : inc Z
3350 until eof(#1) : close #1
3360 INH=-2 : rem This is the value for when there is nothing in hand
3370 LEVNAME$="" : TLSET$="" : FLR$="" : GATE$="" : STAIR$="" : SPEC$="" : GRFSKIP=false
3380 dim THROWX(50),THROWY(50),THROBJ(50),THRVECT(50) : THROWN=0
3390 dim INVE(16) : HELM=0 : NECK=0 : BELT=0 : ARMR=0 : WEPN=0 : SHLD=0 : FEET=0
3400 QS1=0 : QS2=0 : INVE(2)=6 : rem For testing purposes only, excise when it really starts
3410 dim DPOS(35,35),OBJGRID(35,35,4),MGRID(35,35),MX(70),MY(70),MSTAT(70),MHP(70),MTYPE(70),MFACE(70),TSLM(70),M0RIGX(70),M0RIGY(70),MCHP(70),MTIC(70),ATK(70)
3420 setrtim 0 : dim LOCKX(30),LOCKY(30),LTARGX(30),LTARGY(30),LOCKTYPE(30),KTYPE(10),LOCKSTAT(30) : for ZZ=0 to 30 : LOCKSTAT(ZZ)=0 : next 
3430 for ZZ=1 to 10 : KTYPE(ZZ)=ZZ+3 : next ZZ
3440 dim XLL(4,4),XLS(4,4) : rem These are the co-ordinates to draw locks on walls
3450 XLL(1,2)=96 : XLL(2,2)=96 : XLL(3,2)=96 : XLL(4,2)=96 : XLL(4,1)=48 : XLL(4,0)=0 : XLL(4,3)=144 : XLL(4,4)=192
3460 XLL(2,1)=0 : XLL(2,3)=192 : XLL(3,1)=32 : XLL(3,3)=176 : XLS(1,1)=32 : XLS(1,3)=160
3470 dim PLACX(30),PLACY(30),PLACTXT$(30)
3480 VART=true
3490 dim WALL$(8),FLCG$(4),WALLMSK$(8),VAULT$(4)
3500 dim LSW$(10),RSW$(10),LSWMSK$(10),RSWMSK$(10)
3510 dim OPD$(4),CLD$(4),OPDB$(4),CLDB$(4),OPDMSK$(4),CLDMSK$(4),OPDBMSK$(4),CLDBMSK$(4)
3520 dim SUP$(4),SDN$(4),SUPMSK$(4),SDNMSK$(4) : VISITED=0
3530 dim CHESTX(30),CHESTY(30),NCHEST(30),CNTENTS(30,8),CHESTSTAT(30),CHOPN$(4),CHSHUT$(4)
3540 open in #1,"levdir.csv" : input #1,MEH$,MEH$,MEH$,MEH$,MEH$
3550 for C=0 to 15 : input #1,LEVNAME$(C),MEH$,MEH$,LEVFILE$(C),LD$ : LEVDISK(C)=val(LD$) : next C : close #1
3560 rem CURLOC$(1)=LEVFILE$(0) : rem This is for when we start to integrate the levels more tightly
3570 CURLOC$(1)="PRISON" : rem Must start on level 0 in LEVDIR.CSV when finished.
3580 erase 9
3590 XT(1)=17 : YT(1)=32 : rem These are the start coordinates for development purposes only
3600 FACE(1)=1 : rem 1=north, 2=east, 3=south, 4=west
3610 change mouse WT
3620 MAP$="" : TLSET$="" : FLR$="" : GATE$="" : STAIR$=""
3630 fade 5 : for MM=1 to 25 : wait vbl : next MM
3640 pen 13
3650 fade 5,$0,$662,$743,$532,$421,$310,$200,$600,$21,$42,$63,$112,$223,$334,$446,$15
3660 M8=start(8) : areg(0)=M8 : areg(1)=back : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE : areg(0)=M8 : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
3670 INFL1$=screen$(8,0,0 to 16,192) : INFL2$=screen$(8,16,0 to 208,1) : INFL3$=screen$(8,16,192 to 208,200) : INFL4$=screen$(8,208,0 to 320,200) : areg(0)=M8 : dreg(7)=4 : call PODGE
3680 dim EXTX(4),EXTY(4),EXTLOC$(4),ENTRX(4),ENTRY(4),ENTF$(4)
3690 dreg(7)=6 : V1$="Initialising Dungeon. Please wait."+chr$(0) : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=191 : dreg(1)=16 : call PODGE : skopy 1,back,16,191,304,200,physic,16,191
3700 reserve as screen 9 : M9=start(9) : load "ephemera.mbk",13 : unpack 13,9 : erase 13 : get palette (9)
3710 rem Must remember to podge the portrait here and put it in the hole.
3720 RES$=screen$(9,0,168 to 64,200) : REL$=screen$(9,64,168 to 128,200) : Q$=screen$(9,128,168 to 192,200)
3730 for ZZ=1 to 10
3740 YA=(ZZ-1)*16 : YZ=(ZZ)*16
3750 LOCKPANEL$(ZZ,1)=screen$(9,0,YA to 32,YZ) : LOCKPANEL$(ZZ,2)=screen$(9,32,YA to 64,YZ) : LOCKPANEL$(ZZ,3)=screen$(9,64,YA to 80,YZ) : LOCKPANEL$(ZZ,4)=screen$(9,80,YA to 96,YZ)
3760 LOCKL$(ZZ,1)=screen$(9,96,YA to 112,YZ) : LOCKR$(ZZ,1)=screen$(9,112,YA to 128,YZ) : LOCKL$(ZZ,2)=screen$(9,128,YA to 144,YZ) : LOCKR$(ZZ,2)=screen$(9,144,YA to 160,YZ)
3770 next ZZ : rem Leave M9 alone because it contains the meters both empty and full, which are podged in part upon taking damage or expending mana
3780 rem open in #1,"teleport.ent" : for DIST=1 to 4 : for FR=1 to 2
3790 rem line input #1,LL$ : LL=val(LL$)
3800 rem TELEP$(FR,DIST)=input$(#1,LL+2)
3810 rem next FR : next DIST : close #1
3820 rem ******* Load a new level *******
3830 OLDWL$=TLSET$ : OLDFLR$=FLR$ : OLDGT$=GATE$ : OLDSTR$=STAIR$ : OLDDEC$=SPEC$ : reserve as screen 13 : reserve as screen 12 : M12=start(12) : M13=start(13)
3840 hide on : change mouse WT
3850 ink 15
3860 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
3870 M$=CURLOC$(1)+".LOC" : open in #1,M$
3880 input #1,LEVNAME$
3890 dreg(7)=6 : V1$="Loading Level: "+LEVNAME$+chr$(0) : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
3900 input #1,TLSET$
3910 input #1,DCR1$
3920 input #1,DCR2$
3930 input #1,DCR3$
3940 input #1,CHESTICLE$
3950 input #1,BELOW$
3960 input #1,MNN$ : NUMCRIT=val(MNN$)
3970 if TLSET$=OLDWL$ then GRFSKIP=true else GRFSKIP=false
3980 input #1,NUMXIT$ : N=val(NUMXIT$)
3990 for ZZ=1 to N : input #1,EX$,EY$,EL$,IX$,IY$
4000 EXTX(ZZ)=val(EX$) : EXTY(ZZ)=val(EY$) : EXTLOC$(ZZ)=EL$ : ENTRX(ZZ)=val(IX$) : ENTRY(ZZ)=val(IY$)
4010 next : for ZZ=0 to 20 : LOCKSTAT(ZZ)=0 : next ZZ
4020 input #1,NUMLOCK$ : NUMLOCKS=val(NUMLOCK$)
4030 for ZZ=1 to NUMLOCKS : input #1,LT$,LX$,LY$,TX$,TY$
4040 LOCKTYPE(ZZ)=val(LT$) : LOCKX(ZZ)=val(LX$) : LOCKY(ZZ)=val(LY$) : LTARGX(ZZ)=val(TX$) : LTARGY(ZZ)=val(TY$)
4050 next 
4060 input #1,NUMPLAC$ : NUMPLACS=val(NUMPLAC$)
4070 for ZZ=1 to NUMPLACS : input #1,PX$,PY$,PLACTXT$(ZZ)
4080 PLACX(ZZ)=val(PX$) : PLACY(ZZ)=val(PY$)
4090 next ZZ
4100 input #1,MTS1$,MTS2$,MTS3$,MTS4$
4110 M(1)=val(MTS1$) : M(2)=val(MTS2$) : M(3)=val(MTS3$) : M(4)=val(MTS4$)
4120 input #1,NC$ : NUMCRIT=val(NC$)
4130 for MM=1 to NUMCRIT
4140 input #1,T$,X$,Y$,F$,S$,HP$ : MTYPE(MM)=val(T$) : M0RIGX(MM)=val(X$) : M0RIGY(MM)=val(Y$) : MFACE(MM)=val(F$) : MSTAT(MM)=val(S$) : MHP(MM)=MMHP(MTYPE(MM)) : MGRID(M0RIGX(MM),M0RIGY(MM))=MM
4150 next MM
4160 input #1,NC$ : NUMCHESTS=val(NC$)
4170 for CC=1 to NUMCHESTS : input #1,CX$,CY$,CC$,CC1$,CC2$,CC3$,CC4$,CC5$,CC6$,CC7$,CC8$ : CHESTX(CC)=val(CX$) : CHESTY(CC)=val(CY$) : NCHEST(CC)=val(CC$) : CNTENTS(CC,1)=val(CC1$) : CNTENTS(CC,2)=val(CC2$) : CNTENTS(CC,3)=val(CC3$) : CNTENTS(CC,4)=val(CC4$) : CNTENTS(CC,5)=val(CC5$) : CNTENTS(CC,6)=val(CC6$) : CNTENTS(CC,7)=val(CC7$) : CNTENTS(CC,8)=val(CC8$)
4180 next CC : close #1
4190 open in #1,CHESTICLE$+".ENT"
4200 for DIST=1 to 4
4210 line input #1,LL$ : LL=val(LL$) : CHOPN$(DIST)=input$(#1,LL+2) : next DIST
4220 line input #1,LL$ : LL=val(LL$) : CHOPN4A$=input$(#1,LL+2) : quick screen$ M13,0,0,CHOPN4A$,0 : areg(0)=M13 : call 5
4230 CHOPN4B$=screen$(13,256,0 to 320,40) : wipe M13
4240 for DIST=1 to 4
4250 line input #1,LL$ : LL=val(LL$) : CHSHUT$(DIST)=input$(#1,LL+2) : next DIST
4260 line input #1,LL$ : LL=val(LL$) : CHSHUT4A$=input$(#1,LL+2) : quick screen$ M13,0,0,CHSHUT4A$,0 : areg(0)=M13 : call 5
4270 CHSHUT4B$=screen$(13,256,0 to 320,40) : wipe M13
4280 close #1
4290 open in #1,DCR1$+".ENT"
4300 for DIST=1 to 4 : line input #1,LL$ : LL=val(LL$) : DCR$(1,DIST)=input$(#1,LL+2) : next DIST : line input #1,LL$ : LL=val(LL$) : DCR4A$(1)=input$(#1,LL+2) : line input #1,DCRDESC$(1) : close #1
4310 quick screen$ M13,0,0,DCR4A$(1),0 : areg(0)=M13 : call 5 : DCR4B$(1)=screen$(13,256,0 to 320,40) : wipe M13
4320 open in #1,DCR2$+".ENT"
4330 for DIST=1 to 4 : line input #1,LL$ : LL=val(LL$) : DCR$(2,DIST)=input$(#1,LL+2) : next DIST : line input #1,LL$ : LL=val(LL$) : DCR4A$(2)=input$(#1,LL+2) : line input #1,DCRDESC$(2) : close #1
4340 quick screen$ M13,0,0,DCR4A$(2),0 : areg(0)=M13 : call 5 : DCR4B$(2)=screen$(13,256,0 to 320,40) : wipe M13
4350 open in #1,DCR3$+".ENT"
4360 for DIST=1 to 4 : line input #1,LL$ : LL=val(LL$) : DCR$(3,DIST)=input$(#1,LL+2) : next DIST : line input #1,LL$ : LL=val(LL$) : DCR4A$(3)=input$(#1,LL+2) : line input #1,DCRDESC$(3) : close #1
4370 quick screen$ M13,0,0,DCR4A$(3),0 : areg(0)=M13 : call 5 : DCR4B$(3)=screen$(13,256,0 to 320,40) : wipe M13
4380 rem ******* Monster Graphics Loading *******
4390 for ZM=1 to 4 : if M(ZM)=0 then goto 4470
4400 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
4410 FF$=MGRAF$(M(ZM))+".MOB" : dreg(7)=6 : V1$="Loading "+FF$+chr$(0) : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
4420 open in #1,FF$
4430 for DIST=1 to 4 : for FR=1 to 6
4440 line input #1,LL$ : LL=val(LL$)
4450 MFRAME$(ZM,FR,DIST)=input$(#1,LL+2)
4460 next FR : next DIST : close #1
4470 next ZM
4480 areg(0)=M8 : dreg(7)=4 : call PODGE
4490 rem ******* Wall Graphics Loading *******
4500 if GRFSKIP=true then goto 5480
4510 reserve as screen 10 : reserve as screen 11 : load TLSET$+"1.NEO",13 : M10=start(10) : M11=start(11)
4520 rem dreg(7)=14 : areg(0)=M13 : areg(1)=M11 : call PODGE : rem Let's keep this to one side for now
4530 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
4540 dreg(7)=6 : V1$="Loading tileset "+TLSET$+chr$(0) : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
4550 WALL$(1)=screen$(13,0,16 to 160,176) : WALL1A$=screen$(13,0,16 to 16,176) : WALL1B$=screen$(13,144,16 to 160,176)
4560 LSW$(1)=screen$(13,160,0 to 176,192)
4570 LSW$(2)=screen$(13,176,0 to 208,192)
4580 LSW$(3)=screen$(13,208,0 to 224,192)
4590 LSW$(4)=screen$(13,224,0 to 240,192)
4600 RSW$(1)=screen$(13,304,0 to 320,192)
4610 RSW$(2)=screen$(13,272,0 to 304,192)
4620 RSW$(3)=screen$(13,256,0 to 272,192)
4630 RSW$(4)=screen$(13,240,0 to 256,192)
4640 for M=0 to 7 : dreg(M)=0 : next 
4650 areg(0)=M13 : call 5
4660 WALL$(5)=screen$(13,160,16 to 320,176) : WALL5A$=screen$(13,160,16 to 176,176) : WALL5B$=screen$(13,304,16 to 320,176)
4670 LSW$(6)=screen$(13,0,0 to 16,192)
4680 LSW$(7)=screen$(13,16,0 to 48,192)
4690 LSW$(8)=screen$(13,48,0 to 64,192)
4700 LSW$(9)=screen$(13,64,0 to 80,192)
4710 RSW$(6)=screen$(13,144,0 to 160,192)
4720 RSW$(7)=screen$(13,112,0 to 144,192)
4730 RSW$(8)=screen$(13,96,0 to 112,192)
4740 RSW$(9)=screen$(13,80,0 to 96,192)
4750 load TLSET$+"2.NEO",13 : wipe M11
4760 rem Since we aren't using the blitter here we don't need this
4770 FLCG$(1)=screen$(13,0,96 to 192,192) : FLCG$(2)=screen$(13,0,0 to 192,96)
4780 SLOGZN$(0)=screen$(13,192,183 to 288,200)
4790 SLOGZN$(1)=screen$(13,192,152 to 288,183)
4800 SLOGZN$(2)=screen$(13,192,136 to 256,152)
4810 SLOGZN$(3)=screen$(13,192,124 to 256,136)
4820 HOLE$(1)=screen$(13,192,93 to 288,124)
4830 HOLE$(2)=screen$(13,192,77 to 256,93)
4840 HOLE$(3)=screen$(13,192,65 to 256,77)
4850 PLATE$(1)=screen$(13,192,30 to 288,61)
4860 PLATE$(2)=screen$(13,192,14 to 256,30)
4870 PLATE$(3)=screen$(13,192,2 to 256,14)
4880 areg(0)=start(13) : call 5
4890 FLCG$(3)=screen$(13,128,96 to 320,192) : FLCG$(4)=screen$(13,128,0 to 320,96)
4900 load TLSET$+"3A.NEO",13 : load TLSET$+"4A.NEO",12 : rem dreg(7)=14 : areg(0)=M13 : areg(1)=M11 : call PODGE : dreg(7)=14 : areg(0)=M12 : areg(1)=M10 : call PODGE
4910 WALL$(2)=screen$(13,0,0 to 96,96) : WALL2A$=screen$(13,48,0 to 96,96) : WALL2B$=screen$(13,0,0 to 48,96)
4920 WALL$(3)=screen$(13,96,0 to 160,64)
4930 WALL$(4)=screen$(13,160,0 to 224,40)
4940 WALL4A$=screen$(13,160,40 to 224,80)
4950 LSW$(5)=screen$(13,224,0 to 240,40)
4960 LSW$(10)=screen$(12,224,0 to 240,40)
4970 RSW$(5)=screen$(13,240,0 to 256,40)
4980 RSW$(10)=screen$(12,240,0 to 256,40)
4990 OPD$(2)=screen$(13,0,96 to 96,192)
5000 OPD$(3)=screen$(13,96,96 to 160,159)
5010 OPD$(4)=screen$(13,160,160 to 224,200)
5020 OPD4A$=screen$(13,96,160 to 160,200)
5030 OPDB$(2)=screen$(12,0,96 to 96,192)
5040 OPDB$(3)=screen$(12,96,96 to 160,159)
5050 OPDB$(4)=screen$(12,160,160 to 224,200)
5060 OPDB4A$=screen$(12,96,160 to 160,200)
5070 m blit M13,0,96,96,192,M13,224,104 : CLD$(2)=screen$(13,224,104 to 320,200)
5080 m blit M13,96,96,160,159,M13,224,40 : CLD$(3)=screen$(13,224,40 to 288,104)
5090 m blit M13,160,160,224,200,M13,160,80 : CLD$(4)=screen$(13,160,80 to 224,120)
5100 m blit M13,96,160,160,200,M13,160,118 : CLD4A$=screen$(13,160,118 to 224,158)
5110 m blit M12,0,96,96,192,M13,224,104 : CLDB$(2)=screen$(13,224,104 to 320,200)
5120 m blit M12,96,96,160,159,M13,224,40 : CLDB$(3)=screen$(13,224,40 to 288,104)
5130 m blit M12,160,160,224,200,M13,160,80 : CLDB$(4)=screen$(13,160,80 to 224,120)
5140 m blit M12,96,160,160,200,M13,160,118 : CLDB4A$=screen$(13,160,118 to 224,158)
5150 areg(0)=M13 : call 5
5160 WALL$(6)=screen$(13,224,0 to 320,96) : WALL6A$=screen$(13,224,0 to 272,96) : WALL6B$=screen$(13,272,0 to 320,96)
5170 WALL$(7)=screen$(13,160,0 to 224,64)
5180 WALL$(8)=screen$(13,96,0 to 160,40)
5190 SUP$(2)=screen$(12,0,0 to 96,96)
5200 SUP$(3)=screen$(12,96,0 to 160,64)
5210 SUP$(4)=screen$(12,160,0 to 224,40)
5220 SUP4A$=screen$(12,160,40 to 224,80)
5230 SDN$(2)=screen$(12,224,104 to 320,200)
5240 SDN$(3)=screen$(12,224,40 to 288,104)
5250 SDN$(4)=screen$(12,160,80 to 224,120) : SDN4A$=screen$(12,160,120 to 224,160)
5260 areg(0)=M12 : dreg(7)=4 : call PODGE : wait vbl 
5270 screen$(12,0,0)=OPD4A$ : screen$(12,0,40)=OPDB4A$ : screen$(12,0,80)=WALL4A$ : screen$(12,0,120)=CLD4A$ : screen$(12,0,160)=CLDB4A$
5280 screen$(12,256,0)=SUP4A$ : screen$(12,256,40)=SDN4A$
5290 areg(0)=M12 : call 5
5300 OPD4B$=screen$(12,256,0 to 320,40) : OPDB4B$=screen$(12,256,40 to 320,80) : WALL4B$=screen$(12,256,80 to 320,120) : CLD4B$=screen$(12,256,120 to 320,160) : CLDB4B$=screen$(12,256,160 to 320,200)
5310 SUP4B$=screen$(12,0,0 to 64,40) : SUP4B$=screen$(12,0,40 to 64,80)
5320 areg(0)=M12 : dreg(7)=4 : call PODGE : areg(0)=M13 : dreg(7)=4 : call PODGE : load TLSET$+"5.NEO",13
5330 PLAC$(1)=screen$(13,176,146 to 240,179) : PLACL$(1)=screen$(13,176,180 to 208,200) : PLACR$(1)=screen$(13,208,180 to 240,200) : PLACL$(2)=screen$(13,240,180 to 256,200) : PLACR$(2)=screen$(13,256,180 to 272,200)
5340 OPD$(1)=screen$(13,0,0 to 160,144) : DSL1$=screen$(13,160,0 to 320,144) : DSL2$=screen$(13,160,48 to 320,144) : DSL3$=screen$(13,160,96 to 320,144) : m blit M13,128,145,160,200,M13,128,17 : OPDB$(1)=screen$(13,0,0 to 160,144)
5350 quick screen$ M13,0,0,OPD$(1),0 : m blit M13,0,0,160,144,M12,0,0 : CLD$(1)=screen$(12,0,0 to 160,144) : m blit M13,128,145,160,200,M12,128,17 : CLDB$(1)=screen$(12,0,0 to 160,144)
5360 areg(0)=M12 : dreg(7)=4 : call PODGE : screen$(12,0,0)=PLAC$(1) : reduce 12 to 12,0,0,192,160 : PLAC$(2)=screen$(12,0,0 to 48,25) : screen$(12,0,0)=PLAC$(1) : reduce 12 to 12,0,0,160,100 : PLAC$(3)=screen$(12,0,0 to 32,17) : screen$(12,0,0)=PLAC$(1) : reduce 12 to 12,0,0,96,80 : PLAC$(4)=screen$(12,0,0 to 16,8)
5370 load TLSET$+"6.NEO",13
5380 SDN$(1)=screen$(13,0,0 to 160,144) : SUP$(1)=screen$(13,160,0 to 320,144)
5390 areg(0)=M12 : dreg(7)=4 : call PODGE : load TLSET$+"7A.NEO",12 : rem This bit is probably going to need some jiggery pokery
5400 ANGWLL$(0)=screen$(12,112,129 to 160,192) : ANGWLR$(0)=screen$(12,160,129 to 208,192) : ANGWLL$(2)=screen$(12,224,129 to 240,169) : ANGWLR$(2)=screen$(12,240,129 to 256,169)
5410 fastcopy M12,M13 : areg(0)=M13 : call 5
5420 ANGWLL$(4)=screen$(12,112,129 to 160,192) : ANGWLR$(4)=screen$(12,160,129 to 208,192)
5430 blit M13,288,129,320,200,M13,0,0 : blit M13,256,129,288,141,M13,0,72 : blit M13,256,129,288,141,M13,0,84 : blit M13,224,129,256,200,M13,0,96 : GATEPOST$=screen$(13,0,0 to 32,168) : wipe M13
5440 blit M12,0,0,160,128,M13,0,0 : blit M12,160,0,320,16,M13,0,128
5450 rem Must remember to grab wall decorations from screen 7
5460 erase 10 : erase 11 : erase 12 : erase 13 : rem Free up some RAM
5470 QQ=free : rem Maybe forcing a garbage collection will stop it bus erroring
5480 rem ******* Load the map *******
5490 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
5500 dreg(7)=6 : V1$="Loading map for "+CURLOC$(1)+chr$(0) : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
5510 load CURLOC$(1)+".MBK",10 : M10=start(10) : kopy M10,varptr(DPOS(0,0)),5184 : kopy M10+5184,varptr(OBJGRID(0,0,0)),20736 : kopy M10+25920,varptr(MGRID(0,0)),5184
5520 if NUMCRIT<=0 then goto 5540
5530 for QQ=1 to NUMCRIT : MGRID(M0RIGX(QQ),M0RIGY(QQ))=QQ : MX(QQ)=M0RIGX(QQ) : MY(QQ)=M0RIGY(QQ) : next QQ
5540 erase 10
5550 if INH>0 then ZZ=OBJICN(INH)+3 else ZZ=36
5560 change mouse ZZ
5570 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
5580 quick screen$ back,0,0,INFL1$,0 : quick screen$ back,16,0,INFL2$,0 : quick screen$ back,16,192,INFL3$,0 : quick screen$ back,208,0,INFL4$,0 : fastcopy back,physic : update off : rem And the throbber goes away also
5588 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
5590 rem ***** This is the drawing routine *****
5600 HERE=DPOS(XT(1),YT(1))
5610 if HERE<-6 then goto 12490 : rem Handle pits and stairs
5620 on FACE(1) goto 5621,6050,6451,6861
5621 OBJHRL=OBJGRID(XT(1),YT(1),1) : OBJHRR=OBJGRID(XT(1),YT(1),2)
5622 OBJAHLL=OBJGRID(XT(1)-1,YT(1)-1,4) : OBJAHL=OBJGRID(XT(1),YT(1)-1,3) : OBJAHR=OBJGRID(XT(1),YT(1)-1,4) : OBJAHRR=OBJGRID(XT(1)+1,YT(1)-1,3)
5623 OBJADLL=OBJGRID(XT(1)-1,YT(1)-1,2) : OBJADL=OBJGRID(XT(1),YT(1)-1,1) : OBJADR=OBJGRID(XT(1),YT(1)-1,2) : OBJADRR=OBJGRID(XT(1)+1,YT(1)-1,1)
5624 if YT(1)-2<1 then goto 5770
5625 OBJFHLL=OBJGRID(XT(1)-1,YT(1)-2,4) : OBJFHL=OBJGRID(XT(1),YT(1)-2,3) : OBJFHR=OBJGRID(XT(1),YT(1)-2,4) : OBJFHRR=OBJGRID(XT(1)+1,YT(1)-2,3)
5626 OBJFDVL=OBJGRID(XT(1)-1,YT(1)-2,1) : OBJFDLL=OBJGRID(XT(1)-1,YT(1)-2,2) : OBJFDL=OBJGRID(XT(1),YT(1)-2,1) : OBJFDR=OBJGRID(XT(1),YT(1)-2,2) : OBJFDRR=OBJGRID(XT(1)+1,YT(1)-2,1) : OBJFDVR=OBJGRID(XT(1)+1,YT(1)-2,2)
5627 if YT(1)-3<1 then goto 5770
5628 OBJVFVL=OBJGRID(XT(1)-1,YT(1)-3,3) : OBJVFLL=OBJGRID(XT(1)-1,YT(1)-3,4) : OBJVFL=OBJGRID(XT(1),YT(1)-3,3) : OBJVFR=OBJGRID(XT(1),YT(1)-3,4) : OBJVFRR=OBJGRID(XT(1)+1,YT(1)-3,3) : OBJVFVR=OBJGRID(XT(1)+1,YT(1)-3,4)
5629 OBJVVFVL=OBJGRID(XT(1)-1,YT(1)-3,1) : OBJVVFLL=OBJGRID(XT(1)-1,YT(1)-3,1) : OBJVVFL=OBJGRID(XT(1),YT(1)-3,1) : OBJVVFR=OBJGRID(XT(1),YT(1)-3,2) : OBJVVFRR=OBJGRID(XT(1)+1,YT(1)-3,1) : OBJVVFVR=OBJGRID(XT(1)+1,YT(1)-3,2)
5630 if YT(1)-4<1 then goto 5770
5631 if XT(1)-2>0 then OBJSDXL=OBJGRID(XT(1)-2,YT(1)-4,4)
5632 OBJSDVL=OBJGRID(XT(1)-1,YT(1)-4,3) : OBJSDLL=OBJGRID(XT(1)-1,YT(1)-4,4) : OBJSDL=OBJGRID(XT(1),YT(1)-4,3) : OBJSDR=OBJGRID(XT(1),YT(1)-4,4) : OBJSDRR=OBJGRID(XT(1)+1,YT(1)-4,3) : OBJSDVR=OBJGRID(XT(1)+1,YT(1)-4,4)
5633 if XT(1)+2<35 then OBJSDXR=OBJGRID(XT(1)+2,YT(1)-4,3)
5770 AHEAD=DPOS(XT(1),YT(1)-1) : MAHEAD=MGRID(XT(1),YT(1)-1)
5780 BHIND=DPOS(XT(1),YT(1)+1) : MBHIND=MGRID(XT(1),YT(1)+1)
5790 LS=DPOS(XT(1)-1,YT(1)) : MLS=MGRID(XT(1)-1,YT(1))
5800 RS=DPOS(XT(1)+1,YT(1)) : MRS=MGRID(XT(1)+1,YT(1))
5810 LD=DPOS(XT(1)-1,YT(1)-1) : MLD=MGRID(XT(1)-1,YT(1)-1)
5820 RD=DPOS(XT(1)+1,YT(1)-1) : MRD=MGRID(XT(1)+1,YT(1)-1)
5830 if YT(1)-2<0 then goto 7280
5840 LMD=DPOS(XT(1)-1,YT(1)-2) : MLMD=MGRID(XT(1)-1,YT(1)-2)
5850 CMD=DPOS(XT(1),YT(1)-2) : MCMD=MGRID(XT(1),YT(1)-2)
5860 RMD=DPOS(XT(1)+1,YT(1)-2) : MRMD=MGRID(XT(1)+1,YT(1)-2)
5870 if YT(1)-3<0 then goto 7280
5880 CLFD=DPOS(XT(1)-1,YT(1)-3) : MCLFD=MGRID(XT(1)-1,YT(1)-3)
5890 CCFD=DPOS(XT(1),YT(1)-3) : MCCFD=MGRID(XT(1),YT(1)-3)
5900 CRFD=DPOS(XT(1)+1,YT(1)-3) : MCRFD=MGRID(XT(1)+1,YT(1)-3)
5910 if XT(1)-2>0 then LLFD=DPOS(XT(1)-2,YT(1)-3) else LLFD=0
5920 if XT(1)-2>0 then MLLFD=MGRID(XT(1)-2,YT(1)-3) else MLLFD=0
5930 if XT(1)+2<35 then RRFD=DPOS(XT(1)+2,YT(1)-3) else RRFD=0
5940 if XT(1)+2<35 then MRRFD=MGRID(XT(1)+2,YT(1)-3) else MRRFD=0
5950 if YT(1)-4<0 then goto 7280
5960 if XT(1)-2>0 then VFARR=DPOS(XT(1)+2,YT(1)-4) else VFARR=0
5970 if XT(1)-2>0 then MVFARR=MGRID(XT(1)+2,YT(1)-4) else MVFARR=0
5980 VFAHD=DPOS(XT(1),YT(1)-4) : MVFAHD=MGRID(XT(1),YT(1)-4)
5990 VFAHL=DPOS(XT(1)-1,YT(1)-4) : MVFAHL=MGRID(XT(1)-1,YT(1)-4)
6000 VFAHR=DPOS(XT(1)+1,YT(1)-4) : MVFAHR=MGRID(XT(1)+1,YT(1)-4)
6010 if XT(1)+2<35 then VFALL=DPOS(XT(1)-2,YT(1)-4) else VFALL=0
6020 if XT(1)+2<35 then MVFALL=MGRID(XT(1)-2,YT(1)-4) else MVFALL=0
6030 goto 7280
6040 rem NORTH END
6050 OBJHRL=OBJGRID(XT(1),YT(1),2) : OBJHRR=OBJGRID(XT(1),YT(1),4)
6051 OBJAHLL=OBJGRID(XT(1)+1,YT(1)-1,3) : OBJAHL=OBJGRID(XT(1)+1,YT(1),1) : OBJAHR=OBJGRID(XT(1)+1,YT(1),3) : OBJAHRR=OBJGRID(XT(1)+1,YT(1)+1,1)
6052 OBJADLL=OBJGRID(XT(1)+1,YT(1)-1,4) : OBJADL=OBJGRID(XT(1)+1,YT(1),2) : OBJADR=OBJGRID(XT(1)+1,YT(1),4) : OBJADRR=OBJGRID(XT(1)+1,YT(1)+1,2)
6053 if XT(1)+2>35 then goto 6180
6054 OBJFHLL=OBJGRID(XT(1)+2,YT(1)-1,3) : OBJFHL=OBJGRID(XT(1)+2,YT(1),1) : OBJFHR=OBJGRID(XT(1)+2,YT(1),3) : OBJFHRR=OBJGRID(XT(1)+2,YT(1)+1,1)
6055 OBJFDVL=OBJGRID(XT(1)+2,YT(1)-1,2) : OBJFDLL=OBJGRID(XT(1)+2,YT(1)-1,4) : OBJFDL=OBJGRID(XT(1)+2,YT(1),2) : OBJFDR=OBJGRID(XT(1)+2,YT(1),4) : OBJFDRR=OBJGRID(XT(1)+2,YT(1)+1,2) : OBJFDVR=OBJGRID(XT(1)+2,YT(1)+1,4)
6056 if XT(1)+3>35 then goto 6180
6057 OBJVFVL=OBJGRID(XT(1)+3,YT(1)-1,1) : OBJVFLL=OBJGRID(XT(1)+3,YT(1)-1,3) : OBJVFL=OBJGRID(XT(1)+3,YT(1),1) : OBJVFR=OBJGRID(XT(1)+3,YT(1),3) : OBJVFRR=OBJGRID(XT(1)+3,YT(1)+1,1) : OBJVFVR=OBJGRID(XT(1)+3,YT(1)+1,3)
6058 OBJVVFVL=OBJGRID(XT(1)+3,YT(1)-1,2) : OBJVVFLL=OBJGRID(XT(1)+3,YT(1)-1,4) : OBJVVFL=OBJGRID(XT(1)+3,YT(1),2) : OBJVVFR=OBJGRID(XT(1)+3,YT(1),4) : OBJVVFRR=OBJGRID(XT(1)+3,YT(1)+1,2) : OBJVVFVR=OBJGRID(XT(1)+3,YT(1)+1,4)
6059 if XT(1)+4>35 then goto 6180
6060 if YT(1)-2>0 then OBJSDXL=OBJGRID(XT(1)+4,YT(1)-2,3)
6061 OBJSDVL=OBJGRID(XT(1)+4,YT(1)-1,2) : OBJSDLL=OBJGRID(XT(1)+4,YT(1)-1,1) : OBJSDL=OBJGRID(XT(1)+4,YT(1),2) : OBJSDR=OBJGRID(XT(1)+4,YT(1),1) : OBJSDRR=OBJGRID(XT(1)+4,YT(1)+1,2) : OBJSDVR=OBJGRID(XT(1)+4,YT(1)+1,1)
6062 if XT(1)-2>0 and YT(1)+4<36 then OBJSDXR=OBJGRID(XT(1)-2,YT(1)+4,2)
6180 AHEAD=DPOS(XT(1)+1,YT(1)) : MAHEAD=MGRID(XT(1)+1,YT(1))
6190 BHIND=DPOS(XT(1)-1,YT(1)) : MBHIND=MGRID(XT(1)-1,YT(1))
6200 LS=DPOS(XT(1),YT(1)-1) : MLS=MGRID(XT(1),YT(1)-1)
6210 RS=DPOS(XT(1),YT(1)+1) : MRS=MGRID(XT(1),YT(1)+1)
6220 LD=DPOS(XT(1)+1,YT(1)-1) : MLD=MGRID(XT(1)+1,YT(1)-1)
6230 RD=DPOS(XT(1)+1,YT(1)+1) : MRD=MGRID(XT(1)+1,YT(1)+1)
6240 if XT(1)+2>35 then goto 7280
6250 LMD=DPOS(XT(1)+2,YT(1)-1) : MLMD=MGRID(XT(1)+2,YT(1)-1)
6260 CMD=DPOS(XT(1)+2,YT(1)) : MCMD=MGRID(XT(1)+2,YT(1))
6270 RMD=DPOS(XT(1)+2,YT(1)+1) : MRMD=MGRID(XT(1)+2,YT(1)+1)
6280 if XT(1)+3>35 then goto 7280
6290 CLFD=DPOS(XT(1)+3,YT(1)-1) : MCLFD=MGRID(XT(1)+3,YT(1)-1)
6300 CCFD=DPOS(XT(1)+3,YT(1)) : MCCFD=MGRID(XT(1)+3,YT(1))
6310 CRFD=DPOS(XT(1)+3,YT(1)+1) : MCRFD=MGRID(XT(1)+3,YT(1)+1)
6320 if YT(1)-2>0 then LLFD=DPOS(XT(1)+3,YT(1)-2) else LLFD=0
6330 if YT(1)-2>0 then MLLFD=MGRID(XT(1)+3,YT(1)-2) else MLLFD=0
6340 if YT(1)+2<35 then RRFD=DPOS(XT(1)+3,YT(1)+2) else RRFD=0
6350 if YT(1)+2<35 then MRRFD=DPOS(XT(1)+3,YT(1)+2) else MRRFD=0
6360 if XT(1)+4>35 then goto 7280
6370 VFAHD=DPOS(XT(1)+4,YT(1)) : MVFAHD=MGRID(XT(1)+4,YT(1))
6380 VFAHL=DPOS(XT(1)+4,YT(1)-1) : MVFAHL=MGRID(XT(1)+4,YT(1)-1)
6390 VFAHR=DPOS(XT(1)+4,YT(1)+1) : MVFAHR=MGRID(XT(1)+4,YT(1)+1)
6400 if YT(1)-2>0 then VFALL=DPOS(XT(1)+4,YT(1)-2) else VFALL=0
6410 if YT(1)-2>0 then MVFALL=MGRID(XT(1)+4,YT(1)-2) else MVFALL=0
6420 if YT(1)+2<35 then VFARR=DPOS(XT(1)+4,YT(1)+2) else VFARR=0
6430 if YT(1)+2<35 then MVFARR=MGRID(XT(1)+4,YT(1)+2) else MVFARR=0
6440 goto 7280
6450 rem EAST END
6451 OBJHRL=OBJGRID(XT(1),YT(1),4) : OBJHRR=OBJGRID(XT(1),YT(1),3)
6452 OBJAHLL=OBJGRID(XT(1)+1,YT(1)+1,1) : OBJAHL=OBJGRID(XT(1),YT(1)+1,2) : OBJAHR=OBJGRID(XT(1),YT(1)+1,1) : OBJAHRR=OBJGRID(XT(1)-1,YT(1)+1,2)
6453 OBJADLL=OBJGRID(XT(1)+1,YT(1)+1,3) : OBJADL=OBJGRID(XT(1),YT(1)+1,4) : OBJADR=OBJGRID(XT(1),YT(1)+1,3) : OBJADRR=OBJGRID(XT(1)-1,YT(1)+1,4)
6454 if YT(1)+2>35 then goto 6590
6455 OBJFHLL=OBJGRID(XT(1)+1,YT(1)+2,1) : OBJFHL=OBJGRID(XT(1),YT(1)+2,2) : OBJFHR=OBJGRID(XT(1),YT(1)+2,1) : OBJFHRR=OBJGRID(XT(1)-1,YT(1)+2,2)
6456 OBJFDVL=OBJGRID(XT(1)+1,YT(1)+2,4) : OBJFDLL=OBJGRID(XT(1)+1,YT(1)+2,3) : OBJFDL=OBJGRID(XT(1),YT(1)+2,4) : OBJFDR=OBJGRID(XT(1),YT(1)+2,3) : OBJFDRR=OBJGRID(XT(1)-1,YT(1)+2,4) : OBJFDVR=OBJGRID(XT(1)-1,YT(1)+2,3)
6457 if YT(1)+3>35 then goto 6590
6458 OBJVFVL=OBJGRID(XT(1)+1,YT(1)+3,2) : OBJVFLL=OBJGRID(XT(1)+1,YT(1)+3,1) : OBJVFL=OBJGRID(XT(1),YT(1)+3,2) : OBJVFR=OBJGRID(XT(1),YT(1)+3,1) : OBJVFRR=OBJGRID(XT(1)-1,YT(1)+3,2) : OBJVFVR=OBJGRID(XT(1)-1,YT(1)+3,1)
6459 OBJVVFVL=OBJGRID(XT(1)+1,YT(1)+3,4) : OBJVVFLL=OBJGRID(XT(1)+1,YT(1)+3,3) : OBJVVFL=OBJGRID(XT(1),YT(1)+3,4) : OBJVVFR=OBJGRID(XT(1),YT(1)+3,3) : OBJVVFRR=OBJGRID(XT(1)-1,YT(1)+3,4) : OBJVVFVR=OBJGRID(XT(1)-1,YT(1)+3,3)
6460 if YT(1)+4>35 then goto 6590
6461 if XT(1)+2<35 then OBJSDXL=OBJGRID(XT(1)+2,YT(1)+4,1)
6590 AHEAD=DPOS(XT(1),YT(1)+1) : MAHEAD=MGRID(XT(1),YT(1)+1)
6600 BHIND=DPOS(XT(1),YT(1)-1) : MBHIND=MGRID(XT(1),YT(1)-1)
6610 LS=DPOS(XT(1)+1,YT(1)) : MLS=MGRID(XT(1)+1,YT(1))
6620 RS=DPOS(XT(1)-1,YT(1)) : MRS=MGRID(XT(1)-1,YT(1))
6630 LD=DPOS(XT(1)+1,YT(1)+1) : MLD=MGRID(XT(1)+1,YT(1)+1)
6640 RD=DPOS(XT(1)-1,YT(1)+1) : MRD=MGRID(XT(1)-1,YT(1)+1)
6650 if YT(1)+2>35 then goto 7280
6660 LMD=DPOS(XT(1)+1,YT(1)+2) : MLMD=MGRID(XT(1)+1,YT(1)+2)
6670 CMD=DPOS(XT(1),YT(1)+2) : MCMD=MGRID(XT(1),YT(1)+2)
6680 RMD=DPOS(XT(1)-1,YT(1)+2) : MRMD=MGRID(XT(1)-1,YT(1)+2)
6690 if YT(1)+3>35 then goto 7280
6700 CLFD=DPOS(XT(1)+1,YT(1)+3) : MCLFD=MGRID(XT(1)+1,YT(1)+3)
6710 CCFD=DPOS(XT(1),YT(1)+3) : MCCFD=MGRID(XT(1),YT(1)+3)
6720 CRFD=DPOS(XT(1)-1,YT(1)+3) : MCRFD=MGRID(XT(1)-1,YT(1)+3)
6730 if XT(1)+2<35 then LLFD=DPOS(XT(1)+2,YT(1)+3) else LLFD=0
6740 if XT(1)+2<35 then MLLFD=MGRID(XT(1)+2,YT(1)+3) else MLLFD=0
6750 if XT(1)-2>0 then RRFD=DPOS(XT(1)-2,YT(1)+3) else RRFD=0
6760 if XT(1)-2>0 then MRRFD=MGRID(XT(1)-2,YT(1)+3) else MRRFD=0
6770 if YT(1)+4>35 then goto 7280
6780 VFAHD=DPOS(XT(1),YT(1)+4) : MFVAHD=MGRID(XT(1),YT(1)+4)
6790 VFAHL=DPOS(XT(1)+1,YT(1)+4) : MVFAHL=MGRID(XT(1)+1,YT(1)+4)
6800 VFAHR=DPOS(XT(1)-1,YT(1)+4) : MVFAHR=MGRID(XT(1)-1,YT(1)+4)
6810 if XT(1)+2<35 then VFALL=DPOS(XT(1)+2,YT(1)+4) else VFALL=0
6820 if XT(1)+2<35 then MVFALL=MGRID(XT(1)+2,YT(1)+4) else MVFALL=0
6830 if XT(1)-2>0 then VFARR=DPOS(XT(1)-2,YT(1)+4) else VFARR=0
6840 if XT(1)-2>0 then MVFARR=MGRID(XT(1)-2,YT(1)+4) else MVFARR=0
6850 goto 7280
6860 rem SOUTH END
6861 OBJHRL=OBJGRID(XT(1),YT(1),3) : OBJHRR=OBJGRID(XT(1),YT(1),1)
6862 OBJAHLL=OBJGRID(XT(1)-1,YT(1)+1,2) : OBJAHL=OBJGRID(XT(1)-1,YT(1),4) : OBJAHR=OBJGRID(XT(1)-1,YT(1),2) : OBJAHRR=OBJGRID(XT(1)-1,YT(1)-1,4)
6863 OBJADLL=OBJGRID(XT(1)-1,YT(1)+1,1) : OBJADL=OBJGRID(XT(1)-1,YT(1),3) : OBJADR=OBJGRID(XT(1)-1,YT(1),1) : OBJADRR=OBJGRID(XT(1)-1,YT(1)-1,3)
6864 if XT(1)-2<1 then goto 7000
6865 OBJFHLL=OBJGRID(XT(1)-2,YT(1)+1,2) : OBJFHL=OBJGRID(XT(1)-2,YT(1),4) : OBJFHR=OBJGRID(XT(1)-2,YT(1),2) : OBJFHRR=OBJGRID(XT(1)-2,YT(1)-1,4)
6866 OBJFDVL=OBJGRID(XT(1)-2,YT(1)+1,3) : OBJFDLL=OBJGRID(XT(1)-2,YT(1)+1,1) : OBJFDL=OBJGRID(XT(1)-2,YT(1),3) : OBJFDR=OBJGRID(XT(1)-2,YT(1),1) : OBJFDRR=OBJGRID(XT(1)-2,YT(1)-1,3) : OBJFDVR=OBJGRID(XT(1)-2,YT(1)-1,1)
6867 if XT(1)-3<1 then goto 7000
6868 OBJVFVL=OBJGRID(XT(1)-3,YT(1)+1,2) : OBJVFLL=OBJGRID(XT(1)-3,YT(1)+1,4) : OBJVFL=OBJGRID(XT(1)-3,YT(1),2) : OBJVFR=OBJGRID(XT(1)-3,YT(1),4) : OBJVFRR=OBJGRID(XT(1)-3,YT(1)-1,2) : OBJVFVR=OBJGRID(XT(1)-3,YT(1)-1,4)
6869 OBJVVFVL=OBJGRID(XT(1)-3,YT(1)+1,1) : OBJVVFLL=OBJGRID(XT(1)-3,YT(1)+1,3) : OBJVVFL=OBJGRID(XT(1)-3,YT(1),1) : OBJVVFR=OBJGRID(XT(1)-3,YT(1),3) : OBJVVFRR=OBJGRID(XT(1)-3,YT(1)-1,1) : OBJVVFVR=OBJGRID(XT(1)-3,YT(1)-1,3)
6870 if XT(1)-4<1 then goto 6180
6871 if YT(1)+2<35 then OBJSDXL=OBJGRID(XT(1)-4,YT(1)+2,2)
6872 OBJSDVL=OBJGRID(XT(1)-4,YT(1)+1,4) : OBJSDLL=OBJGRID(XT(1)-4,YT(1)+1,2) : OBJSDL=OBJGRID(XT(1)-4,YT(1),4) : OBJSDR=OBJGRID(XT(1)-4,YT(1),2) : OBJSDRR=OBJGRID(XT(1)-4,YT(1)-1,4) : OBJSDVR=OBJGRID(XT(1)-4,YT(1)-1,2)
6873 if YT(1)-2>0 then OBJSDXR=OBJGRID(XT(1)-4,YT(1)-2,4)
7000 AHEAD=DPOS(XT(1)-1,YT(1)) : MAHEAD=MGRID(XT(1)-1,YT(1))
7010 BHIND=DPOS(XT(1)+1,YT(1)) : MBHIND=MGRID(XT(1)+1,YT(1))
7020 LS=DPOS(XT(1),YT(1)+1) : MLS=MGRID(XT(1),YT(1)+1)
7030 RS=DPOS(XT(1),YT(1)-1) : MRS=MGRID(XT(1),YT(1)-1)
7040 LD=DPOS(XT(1)-1,YT(1)+1) : MLD=MGRID(XT(1)-1,YT(1)+1)
7050 RD=DPOS(XT(1)-1,YT(1)-1) : MRD=MGRID(XT(1)-1,YT(1)-1)
7060 if XT(1)-2<0 then goto 7280
7070 LMD=DPOS(XT(1)-2,YT(1)+1) : MLMD=MGRID(XT(1)-2,YT(1)+1)
7080 CMD=DPOS(XT(1)-2,YT(1)) : MCMD=MGRID(XT(1)-2,YT(1))
7090 RMD=DPOS(XT(1)-2,YT(1)-1) : MRMD=MGRID(XT(1)-2,YT(1)-1)
7100 if XT(1)-3<0 then goto 7280
7110 CLFD=DPOS(XT(1)-3,YT(1)+1) : MCLFD=MGRID(XT(1)-3,YT(1)+1)
7120 CCFD=DPOS(XT(1)-3,YT(1)) : MCCFD=MGRID(XT(1)-3,YT(1))
7130 CRFD=DPOS(XT(1)-3,YT(1)-1) : MCRFD=MGRID(XT(1)-3,YT(1)-1)
7140 if YT(1)+2<35 then LLFD=DPOS(XT(1)-3,YT(1)+2) else LLFD=0
7150 if YT(1)+2<35 then MLLFD=MGRID(XT(1)-3,YT(1)+2) else MLLFD=0
7160 if YT(1)-2>0 then RRFD=DPOS(XT(1)-3,YT(1)-2) else RRFD=0
7170 if YT(1)-2>0 then MRRFD=MGRID(XT(1)-3,YT(1)-2) else MRRFD=0
7180 if XT(1)-4<0 then goto 7280
7190 VFAHD=DPOS(XT(1)-4,YT(1)) : MFVAHD=MGRID(XT(1)-4,YT(1))
7200 VFAHL=DPOS(XT(1)-4,YT(1)+1) : MVFAHL=MGRID(XT(1)-4,YT(1)+1)
7210 VFAHR=DPOS(XT(1)-4,YT(1)-1) : MVFAHR=MGRID(XT(1)-4,YT(1)-1)
7220 if YT(1)+2<35 then VFALL=DPOS(XT(1)-4,YT(1)+2) else VFALL=0
7230 if YT(1)+2<35 then MVFALL=MGRID(XT(1)-4,YT(1)+2) else MVFALL=0
7240 if YT(1)-2>0 then VFARR=DPOS(XT(1)-4,YT(1)-2) else VFARR=0
7250 if YT(1)-2>0 then MVFARR=MGRID(XT(1)-4,YT(1)-2) else MVFARR=0
7260 goto 7280
7270 rem WEST END
7280 rem This is the moment of truth
7290 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-
7300 AA=XT(1)+YT(1)+FACE(1) : if btst(0,AA) then A=4 : AA=2 : B=5 : goto 7320 : rem Faster than arsing about with modulo
7310 A=0 : B=0 : AA=0
7320 reset zone 
7330 set zone 1,48,153 to 112,171 : set zone 2,112,153 to 208,171
7340 set zone 3,32,171 to 112,192 : set zone 4,112,171 to 208,192
7350 set zone 9,164,70 to 180,90
7360 set zone 10,236,123 to 299,177
7370 rem 3=WALL, 4=SIGN, 5=LOCK, 6=WALLDECOR, 7=STANDSWITCH, 8/9=CHESTICLE, 10/11/12=DECOR
7380 if AHEAD<=0 then set zone 54,32,16 to 192,160
7390 if AHEAD=4 then set zone 94,80,80 to 144,112
7400 if AHEAD=5 then set zone 94,96,80 to 128,112
7410 if AHEAD=8 or AHEAD=9 then set zone 94,48,96 to 176,160
7420 if AHEAD>=10 and AHEAD<=12 then set zone 94,48,32 to 176,160
7430 if MAHEAD<>0 then set zone 93,48,32 to 176,160 : rem Assume attack zone is always full size even if monster isn't
7440 M2=start(2) : M8=start(8) : areg(0)=M8 : dreg(7)=4 : call PODGE
7450 dreg(7)=3 : areg(0)=varptr(FLCG$(1+AA)) : areg(1)=M8 : dreg(0)=16 : dreg(1)=100 : dreg(2)=0 : call PODGE : dreg(7)=3 : areg(0)=varptr(FLCG$(2+AA)) : areg(1)=M8 : dreg(0)=16 : dreg(1)=0 : dreg(2)=0 : call PODGE
7460 if VFAHD=0 then 7610
7470 if VFAHD>=3 and VFAHD<=6 then quick screen$ M8,80,76,WALL$(4+A),1
7480 if VFAHD=4 then quick screen$ M8,96,88,PLAC$(4),1
7490 if VFAHD=5 then OFS=0 : DIST=4 : gosub 13020
7500 if VFAHR>=3 and VFAHD<=3 then quick screen$ M8,128,76,RSW$(5),1 : goto 7520
7510 if VFAHR>=3 and VFAHD>=7 then quick screen$ M8,128,76,RSW$(5),1
7520 if VFAHL>=3 and VFAHD<=3 then quick screen$ M8,80,76,LSW$(5),1 : goto 7540
7530 if VFAHL>=3 and VFAHD>=7 then quick screen$ M8,80,76,LSW$(5),1
7540 if VFAHD=1 then quick screen$ M8,80,76,CLDB$(4),1
7550 if VFAHD=2 then quick screen$ M8,80,76,CLD$(4),1
7560 if VFAHD=-1 then quick screen$ M8,80,76,OPDB$(4),1
7570 if VFAHD=-2 then quick screen$ M8,80,76,OPD$(4),1
7580 if VFAHD>=10 and VFAHD<=12 then quick screen$ M8,80,76,DCR$(VFAHD-9,4),1
7590 if VFAHD=8 then quick screen$ M8,80,96,CHOPN$(4),1
7600 if VFAHD=9 then quick screen$ M8,80,96,CHSHUT$(4),1
7603 if OBJSDL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDL))),OBJSAUCEX(OBJVVFAR(OBJSDL)),0,OBJSAUCEX(OBJVVFAR(OBJSDL))+16,16,M8,96,96,4096
7607 if OBJSDR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDR))),OBJSAUCEX(OBJVVFAR(OBJSDR)),0,OBJSAUCEX(OBJVVFAR(OBJSDR))+16,16,M8,120,96,4096
7610 if MVFAHD>0 then quick screen$ M8,96,81,MFRAME$(MTYPE(MVFAHD),RELFACE(FACE(1),MFACE(MVFAHD)),4),1
7620 if VFAHR=0 then 7750
7630 if VFAHR>=3 and VFAHR<7 then quick screen$ M8,112,76,WALL4A$,1
7640 if VFAHR=4 then quick screen$ M8,144,88,PLAC$(4),1
7650 if VFAHR=5 then OFS=1 : DIST=4 : gosub 13020
7660 if VFARR>=3 and VFAHR<=3 then quick screen$ M8,160,76,ANGWLR$(2),1 : goto 7680
7670 if VFARR>=3 and VFAHR>=7 then quick screen$ M8,160,76,ANGWLR$(2),1
7680 if VFAHR=1 then quick screen$ M8,112,76,CLDB4A$,1
7690 if VFAHR=2 then quick screen$ M8,112,76,CLD4A$,1
7700 if VFAHR=-1 then quick screen$ M8,112,76,OPDB4A$,1 : goto 7720
7710 if VFAHR=-2 then quick screen$ M8,112,76,OPD4A$,1 : goto 7720
7720 if VFAHR>=10 and VFAHR<=12 then quick screen$ M8,112,76,DCR4A$(VFAHR-9),1
7730 if VFAHR=8 then quick screen$ M8,112,96,CHOPN4A$,1
7740 if VFAHR=9 then quick screen$ M8,112,96,CHSHUT4A$,1
7743 if OBJSDRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDRR))),OBJSAUCEX(OBJVVFAR(OBJSDRR)),0,OBJSAUCEX(OBJVVFAR(OBJSDRR))+16,16,M8,144,96,4096
7747 if OBJSDVR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDVR))),OBJSAUCEX(OBJVVFAR(OBJSDVR)),0,OBJSAUCEX(OBJVVFAR(OBJSDVR))+16,16,M8,168,96,4096
7750 if MVFAHR>0 then quick screen$ M8,128,81,MFRAME$(MTYPE(MVFAHR),RELFACE(FACE(1),MFACE(MVFAHR)),4),1
7760 if VFAHL=0 then 7890
7770 if VFAHL>=3 and VFAHL<=6 then quick screen$ M8,48,76,WALL4B$,1
7780 if VFAHL=4 then quick screen$ M8,48,88,PLAC$(4),1
7790 if VFAHL=5 then OFS=-1 : DIST=4 : gosub 13020
7800 if VFALL>=3 and VFAHL<=3 then quick screen$ M8,48,76,ANGWLL$(2),1 : goto 7820
7810 if VFALL>=3 and VFAHL>=7 then quick screen$ M8,48,76,ANGWLL$(2),1
7820 if VFAHL=1 then quick screen$ M8,48,76,CLDB4B$,1
7830 if VFAHL=2 then quick screen$ M8,48,76,CLD4B$,1
7840 if VFAHL=-1 then quick screen$ M8,48,76,OPDB4B$,1
7850 if VFAHL=-2 then quick screen$ M8,48,76,OPD4B$,1
7860 if VFAHL>=10 and VFAHL<=12 then quick screen$ M8,48,76,DCR4B$(VFAHL-9),1
7870 if VFAHL=8 then quick screen$ M8,48,96,CHOPN4B$,1
7880 if VFAHL=9 then quick screen$ M8,48,96,CHSHUT4B$,1
7883 if OBJSDLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDLL))),OBJSAUCEX(OBJVVFAR(OBJSDLL)),0,OBJSAUCEX(OBJVVFAR(OBJSDLL))+16,16,M8,72,96,4096
7887 if OBJSDVL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDVL))),OBJSAUCEX(OBJVVFAR(OBJSDVL)),0,OBJSAUCEX(OBJVVFAR(OBJSDVL))+16,16,M8,48,96,4096
7890 if MVFAHL>0 then quick screen$ M8,48,81,MFRAME$(MTYPE(MVFAHL),RELFACE(FACE(1),MFACE(MVFAHL)),4),1
7900 if VFALL=0 then 8010
7910 if VFALL>=3 and VFALL<=6 then quick screen$ M8,0,76,WALL$(4+A),1
7920 if VFALL=4 then quick screen$ M8,0,88,PLAC$(4),1
7930 if VFALL=5 then OFS=-2 : DIST=4 : gosub 13020
7940 if VFALL=1 then quick screen$ M8,0,76,CLDB$(4),1
7950 if VFALL=2 then quick screen$ M8,0,76,CLD$(4),1
7960 if VFALL=-1 then quick screen$ M8,0,76,OPDB$(4),1
7970 if VFALL=-2 then quick screen$ M8,0,76,OPD$(4),1
7980 if VFALL>=10 and VFALL<=12 then quick screen$ M8,0,76,DCR$(VFALL-9,4),1
7990 if VFALL=8 then quick screen$ M8,0,96,CHOPN$(4),1
8000 if VFALL=9 then quick screen$ M8,0,96,CHSHUT$(4),1
8003 if OBJSDXL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVVFAR(OBJSDXL))),OBJSAUCEX(OBJVVFAR(OBJSDXL)),0,OBJSAUCEX(OBJVVFAR(OBJSDXL))+16,16,M8,24,96,4096
8010 if MVFALL>0 then quick screen$ M8,0,81,MFRAME$(MTYPE(MVFALL),RELFACE(FACE(1),MFACE(MVFALL)),4),1
8020 if VFARR=0 then 8130
8030 if VFARR>=3 and VFARR<=6 then quick screen$ M8,160,76,WALL$(4+A),1
8040 if VFARR=4 then quick screen$ M8,192,88,PLAC$(4),1
8050 if VFARR=5 then OFS=2 : DIST=4 : gosub 13020
8060 if VFARR=1 then quick screen$ M8,160,76,CLDB$(4),1
8070 if VFARR=2 then quick screen$ M8,160,76,CLD$(4),1
8080 if VFARR=-1 then quick screen$ M8,160,76,OPDB$(4),1
8090 if VFARR=-2 then quick screen$ M8,160,76,OPD$(4),1
8100 if VFARR>=10 and VFARR<=12 then quick screen$ M8,160,76,DCR$(VFARR-9,4),1
8110 if VFARR=8 then quick screen$ M8,160,96,CHOPN$(4),1
8120 if VFARR=9 then quick screen$ M8,160,96,CHSHUT$(4),1
8123 if OBJSDXR>0 then blitter merge M2+160*(OBJSAUCEY(OBJVVFAR(OBJSDXR))),OBJSAUCEX(OBJVVFAR(OBJSDXR)),0,OBJSAUCEX(OBJVVFAR(OBJSDXR))+16,16,M8,192,96,4096
8130 if MVFARR>0 then quick screen$ M8,160,81,MFRAME$(MTYPE(MVFARR),RELFACE(FACE(1),MFACE(MVFARR)),4),1
8140 if CLFD>=3 and CLFD<=6 and CCFD<3 then quick screen$ M8,80,0,LSW$(4+B),1 : goto 8160
8150 if CLFD>=3 and CLFD<=6 and CCFD>=7 then quick screen$ M8,80,0,LSW$(4+B),1
8160 if CLFD=4 then quick screen$ M8,80,88,PLACR$(2),1
8170 if CRFD>=3 and CRFD<=6 and CCFD<3 then quick screen$ M8,128,0,RSW$(4+B),1 : goto 8200
8180 if CRFD>=3 and CRFD<=6 and CCFD>=7 then quick screen$ M8,128,0,RSW$(4+B),1
8190 if CRFD=4 then quick screen$ M8,128,88,PLACR$(2),1
8200 if CRFD<3 and RRFD>=3 and RRFD<=6 then quick screen$ M8,160,64,ANGWLR$(0+A),1 : goto 8220
8210 if CRFD>=7 and RRFD>=3 and RRFD<=6 then quick screen$ M8,160,64,ANGWLR$(0+A),1
8220 if CLFD<3 and LLFD>=3 and LLFD<=6 then quick screen$ M8,16,64,ANGWLL$(0+A),1 : goto 8240
8230 if CLFD>=7 and LLFD>=3 and LLFD<=6 then quick screen$ M8,16,64,ANGWLL$(0+A),1
8240 if CCFD>=3 and CCFD<=6 then dreg(7)=3 : areg(0)=varptr(WALL$(3+A)) : areg(1)=M8 : dreg(0)=80 : dreg(1)=64 : dreg(2)=0 : call PODGE
8250 if CCFD=4 then quick screen$ M8,96,84,PLAC$(3),1
8260 if CCFD>=10 and CCFD<=12 then quick screen$ M8,80,64,DCR$(CCFD-9,3),1
8270 if CCFD=8 then quick screen$ M8,80,96,CHOPN$(3),1
8280 if CCFD=9 then quick screen$ M8,80,96,CHSHUT$(3),1
8290 if CRFD>=3 and CRFD<=6 then dreg(7)=3 : areg(0)=varptr(WALL$(3+A)) : areg(1)=M8 : dreg(0)=144 : dreg(1)=64 : dreg(2)=0 : call PODGE
8300 if CRFD=4 then quick screen$ M8,160,84,PLAC$(3),1
8310 if CRFD>=10 and CRFD<=12 then quick screen$ M8,144,64,DCR$(CRFD-9,3),1
8320 if CRFD=8 then quick screen$ M8,144,99,CHOPN$(3),1
8330 if CRFD=9 then quick screen$ M8,144,99,CHSHUT$(3),1
8340 if CLFD>=3 and CLFD<=6 then dreg(7)=3 : areg(0)=varptr(WALL$(3+A)) : areg(1)=M8 : dreg(0)=16 : dreg(1)=64 : dreg(2)=0 : call PODGE
8350 if CLFD=4 then quick screen$ M8,32,84,PLAC$(3),1
8360 if CLFD>=10 and CLFD<=12 then quick screen$ M8,16,64,DCR$(CLFD-9,3),1
8370 if CLFD=8 then quick screen$ M8,16,96,CHOPN$(3),1
8380 if CLFD=9 then quick screen$ M8,16,96,CHSHUT$(3),1
8390 if CLFD=1 and LMD>=3 then quick screen$ M8,16,64,CLDB$(3),1
8400 if CLFD=2 and LMD>=3 then quick screen$ M8,16,64,CLD$(3),1
8410 if CLFD=-1 and LMD>=3 then quick screen$ M8,16,64,OPDB$(3),1
8420 if CLFD=-2 and LMD>=3 then quick screen$ M8,16,64,OPD$(3),1
8430 if CLFD=-7 then wash M8,32,80,64,112 : quick screen$ M8,16,64,SDN$(3),1
8440 if CLFD=-8 then wash M8,32,80,64,112 : quick screen$ M8,16,64,SUP$(3),1
8450 if CRFD=1 and RMD>=3 then quick screen$ M8,144,62,CLDB$(3),1
8460 if CRFD=2 and RMD>=3 then quick screen$ M8,144,64,CLD$(3),1
8470 if CRFD=-1 and RMD>=3 then quick screen$ M8,144,64,OPDB$(3),1
8480 if CRFD=-2 and RMD>=3 then quick screen$ M8,144,64,OPD$(3),1
8490 if CRFD=-7 then wash M8,160,80,192,112 : quick screen$ M8,144,64,SDN$(3),1
8500 if CRFD=-8 then wash M8,160,80,192,112 : quick screen$ M8,144,64,SUP$(3),1
8510 if CCFD=1 then quick screen$ M8,80,64,CLDB$(3),1
8520 if CCFD=2 then quick screen$ M8,80,64,CLD$(3),1
8530 if CCFD=-1 then quick screen$ M8,80,64,OPDB$(3),1
8540 if CCFD=-2 then quick screen$ M8,80,64,OPD$(3),1
8550 if CCFD=-7 then wash M8,96,80,192,112 : quick screen$ M8,80,64,SDN$(3),1
8560 if CCFD=-8 then wash M8,96,80,192,112 : quick screen$ M8,80,64,SUP$(3),1
8570 if CCFD=5 then OFS=0 : DIST=3 : gosub 13020
8580 if CRFD=5 then OFS=1 : DIST=3 : gosub 13020
8581 if CLFD=5 then OFS=-1 : DIST=3 : gosub 13020
8582 if OBJVVFVL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFVL))),OBJSAUCEX(OBJVFAR(OBJVVFVL)),0,OBJSAUCEX(OBJVFAR(OBJVVFVL))+16,16,M8,24,104,4096
8583 if OBJVVFLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFLL))),OBJSAUCEX(OBJVFAR(OBJVVFLL)),0,OBJSAUCEX(OBJVFAR(OBJVVFLL))+16,16,M8,54,104,4096
8584 if OBJVVFL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFL))),OBJSAUCEX(OBJVFAR(OBJVVFL)),0,OBJSAUCEX(OBJVFAR(OBJVVFL))+16,16,M8,84,104,4096
8585 if OBJVVFR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFR))),OBJSAUCEX(OBJVFAR(OBJVVFR)),0,OBJSAUCEX(OBJVFAR(OBJVVFR))+16,16,M8,128,104,4096
8586 if OBJVVFRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFRR))),OBJSAUCEX(OBJVFAR(OBJVVFRR)),0,OBJSAUCEX(OBJVFAR(OBJVVFRR))+16,16,M8,144,104,4096
8587 if OBJVVFVR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVVFVR))),OBJSAUCEX(OBJVFAR(OBJVVFVR)),0,OBJSAUCEX(OBJVFAR(OBJVVFVR))+16,16,M8,168,104,4096
8600 if MCCFD>0 then quick screen$ M8,80,71,MFRAME$(MTYPE(MCCFD),RELFACE(FACE(1),MFACE(MCCFD)),3),1
8610 if MCLFD>0 then quick screen$ M8,32,71,MFRAME$(MTYPE(MCLFD),RELFACE(FACE(1),MFACE(MCLFD)),3),1 : rem Must ensure we somehow shift this by 8 pixels rt
8620 if MCRFD>0 then quick screen$ M8,144,71,MFRAME$(MTYPE(MCRFD),RELFACE(FACE(1),MFACE(MCRFD)),3),1
8621 if OBJVFVL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFVL))),OBJSAUCEX(OBJVFAR(OBJVFVL)),0,OBJSAUCEX(OBJVFAR(OBJVFVL))+16,16,M8,20,112,4096
8622 if OBJVFLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFLL))),OBJSAUCEX(OBJVFAR(OBJVFLL)),0,OBJSAUCEX(OBJVFAR(OBJVFLL))+16,16,M8,51,112,4096
8623 if OBJVFL>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFL))),OBJSAUCEX(OBJVFAR(OBJVFL)),0,OBJSAUCEX(OBJVFAR(OBJVFL))+16,16,M8,82,112,4096
8624 if OBJVFR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFR))),OBJSAUCEX(OBJVFAR(OBJVFR)),0,OBJSAUCEX(OBJVFAR(OBJVFR))+16,16,M8,127,112,4096
8625 if OBJVFRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFRR))),OBJSAUCEX(OBJVFAR(OBJVFRR)),0,OBJSAUCEX(OBJVFAR(OBJVFRR))+16,16,M8,157,112,4096
8626 if OBJVFVR>0 then blitter merge M2+(160*OBJSAUCEY(OBJVFAR(OBJVFVR))),OBJSAUCEX(OBJVFAR(OBJVFVR)),0,OBJSAUCEX(OBJVFAR(OBJVFVR))+16,16,M8,188,112,4096
8630 if RMD>=3 and RMD<=6 and CMD<3 then quick screen$ M8,144,0,RSW$(3+B),1 : goto 8650
8640 if RMD>=3 and RMD<=6 and CMD>=7 then quick screen$ M8,144,0,RSW$(3+B),1
8650 if RMD=4 and CMD<3 then quick screen$ M8,144,80,PLACR$(2),1
8660 if LMD>=3 and LMD<=6 and CMD<3 then quick screen$ M8,64,0,LSW$(3+B),1 : goto 8680
8670 if LMD>=3 and LMD<=6 and CMD>=7 then quick screen$ M8,64,0,LSW$(3+B),1
8680 if LMD=4 and CMD<3 then quick screen$ M8,64,80,PLACL$(2),1
8690 if CMD=0 then 8811
8700 if CMD=1 then quick screen$ M8,64,48,CLDB$(2),1
8710 if CMD=2 then quick screen$ M8,64,48,CLD$(2),1
8720 if CMD=-1 then quick screen$ M8,64,48,OPDB$(2),1
8730 if CMD=-2 then quick screen$ M8,64,48,OPD$(2),1
8740 if CMD=-7 then wash M8,80,64,144,128 : quick screen$ M8,64,48,SDN$(2),1
8750 if CMD=-8 then wash M8,80,64,144,128 : quick screen$ M8,64,48,SUP$(2),1
8760 if CMD>=10 and CMD<=12 then quick screen$ M8,64,48,DCR$(CMD-9,2),1
8770 if CMD=8 then quick screen$ M8,64,96,CHOPN$(2),1
8780 if CMD=9 then quick screen$ M8,64,96,CHSHUT$(2),1
8790 if CMD>=3 and CMD<=6 then dreg(7)=3 : areg(0)=varptr(WALL$(2+A)) : areg(1)=M8 : dreg(0)=64 : dreg(1)=48 : dreg(2)=0 : call PODGE
8800 if CMD=4 then quick screen$ M8,96,80,PLAC$(2),1
8810 if CMD=5 then DIST=2 : OFS=0 : gosub 13020
8811 if OBJFDL>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDL))),OBJSAUCEX(OBJFAR(OBJFDL)),0,OBJSAUCEX(OBJFAR(OBJFDL))+32,16,M8,80,124,4096
8812 if OBJFDR>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDR))),OBJSAUCEX(OBJFAR(OBJFDR)),0,OBJSAUCEX(OBJFAR(OBJFDR))+32,16,M8,112,124,4096
8820 if MCMD>0 then quick screen$ M8,80,72,MFRAME$(MTYPE(MCMD),RELFACE(FACE(1),MFACE(MCMD)),2),1
8821 if OBJFHL>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFHL))),OBJSAUCEX(OBJFAR(OBJFHL)),0,OBJSAUCEX(OBJFAR(OBJFHL))+32,16,M8,72,132,4096
8822 if OBJFHR>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFHR))),OBJSAUCEX(OBJFAR(OBJFHR)),0,OBJSAUCEX(OBJFAR(OBJFHR))+32,16,M8,120,132,4096 : rem The closer we get, the more important that the objects "brace" the monsters
8830 if LMD=0 then 8970
8840 if LMD=1 and LD<3 then quick screen$ M8,-16,48,CLDB$(2),1
8850 if LMD=2 and LD<3 then quick screen$ M8,-16,48,CLD$(2),1
8860 if LMD=-1 and LD<3 then quick screen$ M8,-16,48,OPDB$(2),1
8870 if LMD=-2 and LD<3 then quick screen$ M8,-16,48,OPD$(2),1
8880 if LMD=-7 and LD<3 then wash M8,0,64,64,128 : quick screen$ M8,0,48,SDN$(2),1
8890 if LMD=-8 and LD<3 then wash M8,0,64,64,128 : quick screen$ M8,0,48,SUP$(2),1
8900 if LMD>=10 and LMD<=12 then quick screen$ M8,-16,48,DCR$(LMD-9,2),1
8910 if LMD=8 then quick screen$ M8,-16,96,CHOPN$(2),1
8920 if LMD=9 then quick screen$ M8,-16,96,CHSHUT$(2),1
8930 if A=4 and LMD>=3 and LMD<=6 then dreg(7)=3 : areg(0)=varptr(WALL6A$) : areg(1)=M8 : dreg(0)=16 : dreg(1)=48 : dreg(2)=0 : call PODGE : goto 8950
8940 if LMD>=3 and LMD<=6 then dreg(7)=3 : areg(0)=varptr(WALL2A$) : areg(1)=M8 : dreg(0)=16 : dreg(1)=48 : dreg(2)=0 : call PODGE
8950 if LMD=4 then quick screen$ M8,0,80,PLAC$(2),1
8960 if LMD=5 then DIST=2 : OFS=-1 : gosub 13020
8961 if OBJFDVL>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDVL))),OBJSAUCEX(OBJFAR(OBJFDVL)),0,OBJSAUCEX(OBJFAR(OBJFDVL))+32,16,M8,16,124,4096
8962 if OBJFDLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDLL))),OBJSAUCEX(OBJFAR(OBJFDLL)),0,OBJSAUCEX(OBJFAR(OBJFDLL))+32,16,M8,48,124,4096
8970 if MLMD>0 then quick screen$ M8,0,72,MFRAME$(MTYPE(MLMD),RELFACE(FACE(1),MFACE(MLMD)),2),1
8971 if OBJFHLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFHLL))),OBJSAUCEX(OBJFAR(OBJFHLL)),0,OBJSAUCEX(OBJFAR(OBJFHLL))+32,16,M8,36,132,4096
8980 if RMD=0 then 9140
8990 if RMD=1 and RD<3 then quick screen$ M8,144,48,CLDB$(2),1
9000 if RMD=2 and RD<3 then quick screen$ M8,144,48,CLD$(2),1
9010 if RMD=-1 and RD<3 then quick screen$ M8,144,48,OPDB$(2),1
9020 if RMD=-2 and RD<3 then quick screen$ M8,144,48,OPD$(2),1
9030 if RMD=-7 and RD<3 then wash M8,160,64,224,128 : quick screen$ M8,144,48,SDN$(2),1
9040 if RMD=-8 and RD<3 then wash M8,160,64,224,128 : quick screen$ M8,144,48,SUP$(2),1
9050 if A=4 and RMD>=3 and RMD<=6 then dreg(7)=3 : areg(0)=varptr(WALL6B$) : areg(1)=M8 : dreg(0)=160 : dreg(1)=48 : dreg(2)=0 : call PODGE : goto 9070
9060 if RMD>=3 and RMD<=6 then dreg(7)=3 : areg(0)=varptr(WALL2B$) : areg(1)=M8 : dreg(0)=160 : dreg(1)=48 : dreg(2)=0 : call PODGE
9070 if RMD=4 then quick screen$ M8,192,80,PLAC$(2),1
9080 if RMD=5 then DIST=2 : OFS=1 : gosub 13020
9090 if RMD=-7 then wash M8,160,64,224,128 : quick screen$ M8,144,48,SDN$(2),1
9100 if RMD=-8 then wash M8,160,64,224,128 : quick screen$ M8,144,48,SUP$(2),1
9110 if RMD>=10 and RMD<=12 then quick screen$ M8,144,48,DCR$(RMD-9,2),1
9120 if RMD=8 then quick screen$ M8,144,96,CHOPN$(2),1
9130 if RMD=9 then quick screen$ M8,144,96,CHSHUT$(2),1
9131 if OBJFDVR>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDVR))),OBJSAUCEX(OBJFAR(OBJFDVR)),0,OBJSAUCEX(OBJFAR(OBJFDVR))+32,16,M8,176,124,4096
9132 if OBJFDRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFDRR))),OBJSAUCEX(OBJFAR(OBJFDRR)),0,OBJSAUCEX(OBJFAR(OBJFDRR))+32,16,M8,144,124,4096
9140 if MRMD>0 then quick screen$ M8,160,72,MFRAME$(MTYPE(MRMD),RELFACE(FACE(1),MFACE(MRMD)),2),1
9141 if OBJFHRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJFAR(OBJFHRR))),OBJSAUCEX(OBJFAR(OBJFHRR)),0,OBJSAUCEX(OBJFAR(OBJFHRR))+32,16,M8,156,132,4096
9150 if A=4 and LD>=3 and LD<=6 then dreg(7)=3 : areg(0)=varptr(WALL5A$) : areg(1)=M8 : dreg(0)=16 : dreg(1)=16 : dreg(2)=0 : call PODGE : goto 9170
9160 if LD>=3 and LD<=6 then dreg(7)=3 : areg(0)=varptr(WALL1A$) : areg(1)=M8 : dreg(0)=16 : dreg(1)=16 : dreg(2)=0 : call PODGE
9170 if LD>=10 and LD<=12 then quick screen$ M8,-96,16,DCR$(LD-9,1),1
9180 if LD=8 then quick screen$ M8,-96,96,CHOPN$(1),1
9190 if LD=9 then quick screen$ M8,-96,96,CHSHUT$(1),1
9191 if LS>=3 and LS<=7 then 9260
9200 if LD=1 and AHEAD>=3 then quick screen$ M8,-112,24,CLDB$(1),1
9210 if LD=2 and AHEAD>=3 then quick screen$ M8,-112,24,CLD$(1),1
9220 if LD=-1 and AHEAD>=3 then quick screen$ M8,-112,24,OPDB$(1),1
9230 if LD=-2 and AHEAD>=3 then quick screen$ M8,-112,24,OPD$(1),1
9240 if LD=-7 and AHEAD>=3 then dreg(7)=3 : areg(0)=varptr(SDN$(1)) : areg(1)=M8 : dreg(0)=-112 : dreg(1)=24 : dreg(2)=0 : call PODGE
9250 if LD=-8 and AHEAD>=3 then dreg(7)=3 : areg(0)=varptr(SUP$(1)) : areg(1)=M8 : dreg(0)=-112 : dreg(1)=24 : dreg(2)=0 : call PODGE
9260 if A=4 and RD>=3 and RD<=6 then dreg(7)=3 : areg(0)=varptr(WALL5B$) : areg(1)=M8 : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : goto 9280
9270 if RD>=3 and RD<=6 then dreg(7)=3 : areg(0)=varptr(WALL1B$) : areg(1)=M8 : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE
9280 if RD>=10 and RD<=12 then quick screen$ M8,176,16,DCR$(RD-9,1),1
9290 if RD=8 then quick screen$ M8,176,96,CHOPN$(1),1
9300 if RD=9 then quick screen$ M8,176,96,CHSHUT$(1),1
9301 if RS>=3 and RS<=7 then 9380
9310 if RD=1 or RD=2 and AHEAD>=3 then quick screen$ M8,176,24,CLD$(1),1
9320 if RD=-1 or RD=-2 and AHEAD>=3 then quick screen$ M8,176,24,OPD$(1),1
9330 if RD=-7 and AHEAD>=3 then dreg(7)=3 : areg(0)=varptr(SDN$(1)) : areg(1)=M8 : dreg(0)=176 : dreg(1)=24 : dreg(2)=0 : call PODGE
9340 if RD=-8 and AHEAD>=3 then dreg(7)=3 : areg(0)=varptr(SUP$(1)) : areg(1)=M8 : dreg(0)=176 : dreg(1)=24 : dreg(2)=0 : call PODGE
9380 if LD>=3 and LD<=6 and AHEAD<3 then quick screen$ M8,32,0,LSW$(2+B),1 : goto 9400
9390 if LD>=3 and LD<=6 and AHEAD>=7 then quick screen$ M8,32,0,LSW$(2+B),1
9400 if LD=4 and AHEAD<3 then quick screen$ M8,32,72,PLACL$(1),1
9410 if RD>=3 and RD<=6 and AHEAD<3 then quick screen$ M8,160,0,RSW$(2+B),1 : goto 9430
9420 if RD>=3 and RD<=6 and AHEAD>=7 then quick screen$ M8,160,0,RSW$(2+B),1
9430 if RD=4 and AHEAD<3 then quick screen$ M8,160,72,PLACR$(1),1
9431 if OBJADLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJNEAR(OBJADLL))),OBJSAUCEX(OBJNEAR(OBJADLL)),0,OBJSAUCEX(OBJNEAR(OBJADLL))+48,20,M8,16,140,4096
9432 if MLD>0 then quick screen$ M8,-64,48,MFRAME$(MTYPE(MLD),RELFACE(FACE(1),MFACE(MLD)),1),1
9433 if OBJADRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJNEAR(OBJADRR))),OBJSAUCEX(OBJNEAR(OBJADRR)),0,OBJSAUCEX(OBJNEAR(OBJADRR))+48,20,M8,160,140,4096
9434 if MRD>0 then quick screen$ M8,160,48,MFRAME$(MTYPE(MRD),RELFACE(FACE(1),MFACE(MRD)),1),1
9435 if OBJAHLL>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJAHLL))),OBJSAUCEX(OBJHERE(OBJAHLL)),0,OBJSAUCEX(OBJHERE(OBJAHLL))+64,20,M8,0,156,4096
9436 if OBJAHRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJAHRR))),OBJSAUCEX(OBJHERE(OBJAHRR)),0,OBJSAUCEX(OBJHERE(OBJAHRR))+64,20,M8,176,156,4096
9437 if AHEAD>=3 and AHEAD<=7 then dreg(7)=3 : areg(0)=varptr(WALL$(1+A)) : areg(1)=M8 : dreg(0)=32 : dreg(1)=16 : dreg(2)=0 : call PODGE
9438 if AHEAD=4 then quick screen$ M8,80,80,PLAC$(1),1
9439 if AHEAD=5 then DIST=1 : OFS=0 : gosub 13020
9440 if AHEAD=1 or AHEAD=-1 or AHEAD=2 or AHEAD=-2 then gosub 10780
9450 if AHEAD=-7 then wash M8,48,24,172,168 : quick screen$ M8,32,24,SDN$(1),1
9460 if AHEAD=-8 then wash M8,48,24,172,168 : quick screen$ M8,32,24,SUP$(1),1
9470 if AHEAD>=10 and AHEAD<=12 then quick screen$ M8,32,16,DCR$(AHEAD-9,1),1
9480 if AHEAD=8 then quick screen$ M8,32,96,CHOPN$(1),1
9490 if AHEAD=9 then quick screen$ M8,32,96,CHSHUT$(1),1
9500 if AHEAD>=3 and HERE=-1 then quick screen$ M8,96,12,GATEPOST$,0 : goto 9543
9510 if AHEAD>=3 and HERE=-2 then quick screen$ M8,96,12,GATEPOST$,0 : goto 9543
9511 if OBJADL>0 then blitter merge M2+(160*OBJSAUCEY(OBJNEAR(OBJADL))),OBJSAUCEX(OBJNEAR(OBJADL)),0,OBJSAUCEX(OBJNEAR(OBJADL))+48,20,M8,64,140,4096
9512 if OBJADR>0 then blitter merge M2+(160*OBJSAUCEY(OBJNEAR(OBJADR))),OBJSAUCEX(OBJNEAR(OBJADR)),0,OBJSAUCEX(OBJNEAR(OBJADR))+48,20,M8,112,140,4096
9520 if MAHEAD>0 then quick screen$ M8,48,48,MFRAME$(MTYPE(MAHEAD),RELFACE(FACE(1),MFACE(MAHEAD)),1),1
9543 OBJBGR$=screen$(8,16,156 to 208,192) : rem This is to prevent object trails
9544 gosub 12473
9550 if LS>=3 and LS<=6 then quick screen$ M8,16,0,LSW$(1+B),1
9560 if RS>=3 and RS<=6 then quick screen$ M8,192,0,RSW$(1+B),1
9566 if THROWN>0 then gosub 13850
9580 wait vbl : areg(0)=M8 : dreg(0)=16 : dreg(1)=189 : dreg(2)=304 : dreg(3)=200 : dreg(7)=1 : call PODGE : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=16 : dreg(1)=0 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=0 : dreg(7)=0 : call PODGE
9590 if INH=-2 then ZZ=STDM else ZZ=OBJICN(INH)+3
9610 change mouse ZZ : show on : for QQ=0 to 7 : dreg(QQ)=0 : next QQ
9620 dreg(7)=3 : areg(0)=varptr(OBJTMP$) : areg(1)=back : dreg(0)=16 : dreg(1)=160 : dreg(2)=0 : call PODGE : dreg(7)=3 : areg(0)=varptr(OBJTMP$) : areg(1)=physic : dreg(0)=16 : dreg(1)=160 : dreg(2)=0 : call PODGE
9750 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call PODGE
9760 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
9770 rem
9780 rem            THE MAIN LOOP
9790 rem
9800 rem -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
9810 if INH>0 then ZZ$=left$(OBJNAME$(INH),72)+chr$(0) : rem Don't default to what's in hand; only do that when sth picked up.
9820 dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=back : call 15 : dreg(7)=1 : dreg(0)=16 : dreg(1)=192 : dreg(2)=304 : dreg(3)=200 : areg(0)=physic : call 15 : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call 15 : skopy 1,back,16,192,304,200,physic,16,192
9830 set zone 21,256,88 to 272,104 : set zone 22,256,104 to 272,120 : rem 21=fwd, 22=back
9840 set zone 23,240,104 to 256,120 : set zone 24,272,104 to 288,120 : rem 23=lt strafe, 24=rt strafe
9850 set zone 25,240,88 to 256,104 : set zone 26,272,88 to 288,104 : rem 25=lt turn, 26=rt turn
9860 set zone 71,0,36 to 16,60 : rem 71=pause menu
9870 set zone 72,0,68 to 16,92 : rem 72=automap
9880 set zone 73,0,100 to 16,124 : rem 73=magic
9890 set zone 74,0,132 to 16,156 : rem 74=rest
9900 repeat : MB=mouse key : dreg(7)=7 : call 15 : KK=dreg(0) : Z=zone(0)
9920 until KK<>0 or MB<>0 or rtim>=20 or DAMAGE>0
9930 if DAMAGE>0 then gosub 14050
9940 if DEAD=true then goto 14140
9950 if T0CS>=65535 then T0CS=0
9960 if rtim>=23 then setrtim 0 : inc TICS : goto 13440
9970 if TICS>=10 then TICS=0 : inc T0CS : gosub 13781
9980 rem Don't clear ZZ$ here
9990 if KK=CTL(5) then goto 10230 : rem TURN LEFT
10000 if MB=1 and Z=25 then goto 10230
10010 if KK=CTL(7) then goto 10280 : rem TURN RIGHT
10020 if MB=1 and Z=26 then goto 10280
10030 if KK=CTL(1) then goto 10320
10040 if MB=1 and Z=21 then goto 10320
10050 if KK=CTL(9) then goto 10400
10060 if MB=1 and Z=23 then goto 10400
10070 if KK=CTL(11) then goto 10480
10080 if MB=1 and Z=24 then goto 10480
10090 if KK=CTL(3) then goto 10560
10100 if MB=1 and Z=22 then goto 10560
10110 if MB<>0 and Z=9 and AHEAD=1 then goto 10650
10120 if MB<>0 and Z=9 and AHEAD=-1 then goto 10840
10130 if MB<>0 and Z=10 then goto 10960 : rem Inventory screen
10140 if KK=CTL(13) then goto 10960
10150 if MB=1 and Z<=4 and Z>0 then goto 11980 : rem Pick up or drop
10160 if MB=1 and Z=94 then gosub 12600 : rem All interactions
10170 if MB=1 and Z=54 and INH>0 then gosub 13380 : rem Throw something
10180 rem if MB=2 then gosub 15000 : rem Attack something
10190 if MB<>0 and Z=71 then gosub 13140 : rem Pause menu
10200 if KK=CTL(19) then gosub 13140
10210 if INH<>-2 then 9810 else 9820
10220 rem ********** Left turn *********
10230 dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=88 : dreg(2)=16 : call PODGE : wait vbl 
10240 dec FACE(1)
10250 if FACE(1)<1 then FACE(1)=4
10260 dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=88 : dreg(2)=16 : call PODGE : wait vbl : goto 5590
10270 rem ********** Right turn *********
10280 dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=88 : dreg(2)=16 : call PODGE : wait vbl 
10290 inc FACE(1)
10300 if FACE(1)>4 then FACE(1)=1
10310 dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=88 : dreg(2)=16 : call PODGE : wait vbl : goto 5590
10320 rem ********** Forward *********
10330 dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : wait vbl 
10340 if AHEAD>0 or MAHEAD>0 then ZZ$="You cannot go that way."+chr$(0) : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192 : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : goto 9900
10350 on FACE(1) goto 10360,10370,10380,10390
10360 dec YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : goto 5590
10370 inc XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : goto 5590
10380 inc YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : goto 5590
10390 dec XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=88 : dreg(2)=16 : call PODGE : goto 5590
10400 rem ********** Strafe Left ******
10410 dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : wait vbl 
10420 if LS>0 or MLS>0 then ZZ$="You cannot go that way."+chr$(0) : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192 : dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 9900
10430 on FACE(1) goto 10440,10450,10460,10470
10440 dec XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10450 dec YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10460 inc XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10470 inc YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=240 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10480 rem ********** Strafe Right ******
10490 dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : wait vbl 
10500 if RS>0 or MRS>0 then ZZ$="You cannot go that way."+chr$(0) : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192 : dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 9900
10510 on FACE(1) goto 10520,10530,10540,10550
10520 inc XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10530 inc YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10540 dec XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10550 dec YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=272 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10560 rem ********** Back up *********
10570 dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : wait vbl 
10580 if BHIND>0 or MBHIND>0 then ZZ$="You cannot go that way."+chr$(0) : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192 : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 9900
10590 on FACE(1) goto 10600,10610,10620,10630
10600 inc YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10610 dec XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10620 dec YT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10630 inc XT(1) : dreg(7)=8 : areg(0)=back : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : dreg(7)=8 : areg(0)=physic : dreg(0)=256 : dreg(1)=104 : dreg(2)=16 : call PODGE : goto 5590
10640 rem ********** Open door *******
10650 screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL1$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10670 cls 8,0,32,16 to 192,176 : screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL2$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10690 cls 8,0,32,16 to 192,176 : screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL3$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10700 shoot 
10710 cls 8,0,32,16 to 192,176 : screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : wait vbl : areg(0)=M8 : areg(1)=back : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10720 AHEAD=-1
10730 if FACE(1)=1 then DPOS(XT(1),YT(1)-1)=-1
10740 if FACE(1)=2 then DPOS(XT(1)+1,YT(1))=-1
10750 if FACE(1)=3 then DPOS(XT(1),YT(1)+1)=-1
10760 if FACE(1)=4 then DPOS(XT(1)-1,YT(1))=-1
10770 goto 7330
10780 rem ******* Compose a door *******
10790 TMP$=screen$(8,32,16 to 192,176)
10800 if abs(AHEAD)=1 then screen$(8,32,24)=OPDB$(1) else screen$(8,32,24)=OPD$(1)
10810 if AHEAD>0 then screen$(8,32,24)=DSL1$
10820 return 
10830 rem ********** Shut door *******
10840 screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL3$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10860 screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL2$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10880 screen$(8,32,16)=TMP$ : screen$(8,32,24)=OPDB$(1) : screen$(8,32,26)=DSL1$ : wait vbl : areg(0)=M8 : areg(1)=back : dreg(0)=16 : dreg(1)=1 : dreg(2)=208 : dreg(3)=189 : dreg(4)=16 : dreg(5)=1 : dreg(7)=0 : call PODGE : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE
10890 shoot 
10900 AHEAD=1
10910 if FACE(1)=1 then DPOS(XT(1),YT(1)-1)=1
10920 if FACE(1)=2 then DPOS(XT(1)+1,YT(1))=1
10930 if FACE(1)=3 then DPOS(XT(1),YT(1)+1)=1
10940 if FACE(1)=4 then DPOS(XT(1)-1,YT(1))=1
10950 goto 7330
10960 rem ********* Inventory *********
10970 H$=screen$(back,16,0 to 208,190)
10980 reset zone : wash back,16,0,208,190 : wash physic,16,0,208,190
10984 dreg(7)=3 : areg(0)=varptr(INV$) : areg(1)=back : dreg(0)=16 : dreg(1)=0 : dreg(2)=0 : call PODGE : dreg(7)=3 : areg(0)=varptr(INV$) : areg(1)=physic : dreg(0)=16 : dreg(1)=0 : dreg(2)=0 : call PODGE
10990 if INH=-2 then ZZ=STDM else ZZ=OBJICN(INH)+3
11000 change mouse ZZ
11010 set zone 1,161,38 to 177,54 : set zone 2,161,57 to 177,73 : set zone 3,161,76 to 177,92 : set zone 4,161,95 to 177,111 : set zone 5,161,114 to 177,130 : rem HEAD=1, NECK=2, ARMR=3, BELT=4, FEET=5
11020 set zone 6,180,76 to 196,92 : set zone 7,142,76 to 158,92 : set zone 8,114,114 to 130,130 : set zone 9,133,114 to 149,130 : rem WEPN=6, SHLD=7, QS1=8, QS2=9
11030 for VZ=1 to 16 : set zone VZ+9,INVX(VZ),INVY(VZ) to INVX(VZ)+16,INVY(VZ)+16 : next VZ
11070 dreg(7)=3 : areg(0)=varptr(INV$) : areg(1)=back : dreg(0)=16 : dreg(1)=0 : dreg(2)=0 : call PODGE : dreg(7)=3 : areg(0)=varptr(INV$) : areg(1)=physic : dreg(0)=16 : dreg(1)=0 : dreg(2)=0 : call PODGE
11080 for M=1 to 16
11090 if INVE(M)>0 then dreg(0)=34 : dreg(1)=INVX(M) : dreg(2)=INVY(M) : dreg(3)=OBJICN(INVE(M)) : areg(0)=M1 : trap 5
11100 next M
11110 if QS1>0 then dreg(1)=114 : dreg(2)=114 : dreg(0)=34 : dreg(3)=OBJICN(QS1) : areg(0)=M1 : trap 5
11120 if QS2>0 then dreg(1)=133 : dreg(2)=113 : dreg(0)=34 : dreg(3)=OBJICN(QS2) : areg(0)=M1 : trap 5
11130 if HELM>0 then dreg(1)=161 : dreg(2)=38 : dreg(0)=34 : dreg(3)=OBJICN(HELM) : areg(0)=M1 : trap 5
11140 if NECK>0 then dreg(1)=161 : dreg(2)=57 : dreg(0)=34 : dreg(3)=OBJICN(NECK) : areg(0)=M1 : trap 5
11150 if ARMR>0 then dreg(1)=161 : dreg(2)=76 : dreg(0)=34 : dreg(3)=OBJICN(ARMR) : areg(0)=M1 : trap 5
11160 if BELT>0 then dreg(1)=161 : dreg(2)=95 : dreg(0)=34 : dreg(3)=OBJICN(BELT) : areg(0)=M1 : trap 5
11170 if WEPN>0 then dreg(1)=180 : dreg(2)=76 : dreg(0)=34 : dreg(3)=OBJICN(WEPN) : areg(0)=M1 : trap 5
11180 if SHLD>0 then dreg(1)=142 : dreg(2)=76 : dreg(0)=34 : dreg(3)=OBJICN(SHLD) : areg(0)=M1 : trap 5
11190 if FEET>0 then dreg(1)=161 : dreg(2)=114 : dreg(0)=34 : dreg(3)=OBJICN(FEET) : areg(0)=M1 : trap 5
11200 if INH>0 then ZZ=OBJICN(INH)+3 else ZZ=STDM : change mouse ZZ
11210 MB=0
11219 V1$="   "+NAME$+chr$(0)
11220 dreg(7)=6 : dreg(0)=32 : dreg(1)=16 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : skopy 1,back,16,32,144,40,physic,16,32
11229 V1$="   LV:  "+str$(LV)+"     XP:  "+str$(XP)+chr$(0)
11230 dreg(7)=6 : dreg(0)=40 : dreg(1)=16 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : skopy 1,back,16,40,144,48,physic,16,40
11232 gosub 16000 : rem Apply buffs and nerfs
11233 V1$="   " : MALADIES=0 : for QKT=0 to 7
11234 if btst(QKT,STATUSFX) and MALADIES=0 then V1$=V1$+BADSTUFF$(QKT) : inc MALADIES
11235 if btst(QKT,STATUSFX) and MALADIES>0 then V1$=V1$+", "+BADSTUFF$(QKT) : inc MALADIES
11236 next QKT : if V1$="   " then V1$="   Perfect Health"
11237 V1$=left$(V1$,47) : V1$=V1$+chr$(0)
11238 dreg(7)=6 : dreg(0)=133 : dreg(1)=16 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=133 : dreg(1)=16 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE : 
11239 V1$=str$(ST+STBUFF)+chr$(0)
11240 dreg(7)=6 : dreg(0)=56 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=56 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11249 V1$=str$(DE+DEBUFF)+chr$(0)
11250 dreg(7)=6 : dreg(0)=64 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=64 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11259 V1$=str$(RV+REBUFF)+chr$(0)
11260 dreg(7)=6 : dreg(0)=72 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=72 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11269 V1$=str$(SA+SABUFF)+chr$(0)
11270 dreg(7)=6 : dreg(0)=80 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=80 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11279 V1$=str$(IN+INBUFF)+chr$(0)
11280 dreg(7)=6 : dreg(0)=88 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=88 : dreg(1)=112 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11290 V1$=" "+str$(CHP)+" /"+str$(MXHP)+chr$(0) : dreg(7)=6 : dreg(0)=105 : dreg(1)=48 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=105 : dreg(1)=48 : dreg(2)=0 : areg(1)=physic : areg(0)=varptr(V1$) : call PODGE
11295 V1$=" "+str$(CMANA)+" /"+str$(MXMANA)+chr$(0) : dreg(7)=6 : dreg(0)=113 : dreg(1)=48 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=back : call PODGE : dreg(7)=6 : dreg(0)=113 : dreg(1)=48 : dreg(2)=0 : areg(0)=varptr(V1$) : areg(1)=physic : call PODGE
11300 if INH>0 then ZZ$=left$(OBJNAME$(INH),72)+chr$(0) else ZZ$=""+chr$(0)
11310 wash back,16,192,320,200 : wash physic,16,192,320,200 : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
11320 repeat : dreg(7)=7 : call PODGE : KK=dreg(0) : MB=mouse key : Z=zone(0)
11330 until KK=CTL(13) or MB<>0
11340 if x mouse<16 or x mouse>208 then quick screen$ back,16,0,H$,0 : quick screen$ physic,16,0,H$,0 : goto 7330
11350 if KK=CTL(13) then quick screen$ back,16,0,H$,0 : fastcopy back,physic : goto 7330
11359 on Z goto 11630,11730,11680,11830,11930,11780,11880,11530,11580,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470,11470 : rem If blocks are for losers
11460 goto 11300
11470 IS=Z-9 : if INVE(IS)=0 and INH<=0 then goto 11320
11480 if INVE(IS)=0 and INH>0 then INVE(IS)=INH : INH=-2 : goto 11510
11490 if INH=-2 and INVE(IS)>0 then INH=INVE(IS) : INVE(IS)=0 : goto 11510
11500 if INH>0 and INVE(IS)>0 then ZZ=INH : INH=INVE(IS) : INVE(IS)=ZZ : goto 11510
11510 if INH=-2 then ZZ=STDM else ZZ=OBJICN(INH)+3 : change mouse ZZ
11515 repeat : MB=mouse key : until MB=0
11520 goto 11070
11530 if INH<=0 then goto 11550
11531 if INH>0 and OBJTYPE$(INH)="THROWN" then 11550
11532 if INH>0 and OBJTYPE$(INH)="MULTIMODE" then 11550
11540 if INH>0 and OBJTYPE$(INH)<>"CONS" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11550 if QS1>0 and INH<=0 then INH=QS1 : QS1=0 : goto 11510
11560 if QS1=0 and INH>0 then QS1=INH : INH=-2 : goto 11510
11570 if QS1>0 and INH>0 then ZZ=INH : INH=QS1 : QS1=ZZ : goto 11510
11580 if INH<=0 then goto 11600
11581 if INH>0 and OBJTYPE$(INH)="THROWN" then 11600
11582 if INH>0 and OBJTYPE$(INH)="MULTIMODE" then 11600
11590 if INH>0 and OBJTYPE$(INH)<>"CONS" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11600 if QS2>0 and INH<=0 then INH=QS2 : QS2=0 : goto 11510
11610 if QS2=0 and INH>0 then QS2=INH : INH=-2 : goto 11510
11620 if QS2>0 and INH>0 then ZZ=INH : INH=QS2 : QS2=ZZ : goto 11510
11630 if INH<=0 then goto 11650
11640 if INH>0 and OBJTYPE$(INH)<>"HELM" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11650 if HELM>0 and INH<=0 then INH=HELM : HELM=0 : goto 11510
11660 if HELM=0 and INH>0 then HELM=INH : INH=-2 : goto 11510
11670 if HELM>0 and INH>0 then ZZ=INH : INH=HELM : HELM=ZZ : goto 11510
11680 if INH<=0 then goto 11700
11690 if INH>0 and OBJTYPE$(INH)<>"NECK" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11700 if NECK>0 and INH<=0 then INH=NECK : NECK=0 : goto 11510
11710 if NECK=0 and INH>0 then NECK=INH : INH=-2 : goto 11510
11720 if NECK>0 and INH>0 then ZZ=INH : INH=NECK : NECK=ZZ : goto 11510
11730 if INH<=0 then goto 11750
11740 if INH>0 and OBJTYPE$(INH)<>"ARMR" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11750 if ARMR>0 and INH<=0 then INH=ARMR : ARMR=0 : goto 11510
11760 if ARMR=0 and INH>0 then ARMR=INH : INH=-2 : goto 11510
11770 if ARMR>0 and INH>0 then ZZ=INH : INH=ARMR : ARMR=ZZ : goto 11510
11780 if INH<=0 then goto 11801
11781 if INH>0 and OBJTYPE$(INH)="MULTIMODE" then 11800
11790 if INH>0 and OBJTYPE$(INH)<>"WEPN" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11800 if INH>0 and PAWS(INH)<>1 and SHLD>0 then ZZ$="Cannot use two handed weapon with a shield."+chr$(0) : goto 11300
11801 if WEPN>0 and INH<=0 then INH=WEPN : WEPN=0 : goto 11510
11810 if WEPN=0 and INH>0 then WEPN=INH : INH=-2 : goto 11510
11820 if WEPN>0 and INH>0 then ZZ=INH : INH=WEPN : WEPN=ZZ : goto 11510
11830 if INH<=0 then goto 11850
11840 if INH>0 and OBJTYPE$(INH)<>"BELT" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11850 if BELT>0 and INH<=0 then INH=BELT : BELT=0 : goto 11510
11860 if BELT=0 and INH>0 then BELT=INH : INH=-2 : goto 11510
11870 if BELT>0 and INH>0 then ZZ=INH : INH=BELT : BELT=ZZ : goto 11510
11880 if INH<=0 then goto 11900
11890 if INH>0 and OBJTYPE$(INH)<>"SHLD" then ZZ$="This doesn't go here."+chr$(0) : goto 11310
11900 if PAWS(WEPN)<>1 then ZZ$="Cannot use shield with two handed weapon."+chr$(0) : goto 11510
11901 if SHLD>0 and INH<=0 then INH=SHLD : SHLD=0 : goto 11510
11910 if SHLD=0 and INH>0 then SHLD=INH : INH=-2 : goto 11510
11920 if SHLD>0 and INH>0 then ZZ=INH : INH=SHLD : SHLD=ZZ : goto 11510
11930 if INH<=0 then goto 11950
11940 if INH>0 and OBJTYPE$(INH)<>"FEET" then ZZ$="This doesn't go here."+chr$(0) : goto 11300
11950 if FEET>0 and INH<=0 then INH=FEET : FEET=0 : goto 11510
11960 if FEET=0 and INH>0 then FEET=INH : INH=-2 : goto 11510
11970 if FEET>0 and INH>0 then ZZ=INH : INH=FEET : FEET=ZZ : goto 11510
11980 rem ********** Pick up / drop **********
11990 if INH=-2 then goto 12230
12000 on Z goto 12010,12070,12130,12180
12010 if AHEAD>0 then goto 9900
12020 OBJAHL=INH : if FACE(1)=1 then swap OBJGRID(XT(1),YT(1)-1,3),INH
12030 if FACE(1)=2 then swap OBJGRID(XT(1)+1,YT(1),1),INH
12040 if FACE(1)=3 then swap OBJGRID(XT(1),YT(1)+1,2),INH
12050 if FACE(1)=4 then swap OBJGRID(XT(1)-1,YT(1),4),INH
12060 if INH<1 then INH=-2
12061 goto 12472
12070 if AHEAD>0 then goto 9900
12080 OBJAHR=INH : if FACE(1)=1 then swap OBJGRID(XT(1),YT(1)-1,4),INH
12090 if FACE(1)=2 then swap OBJGRID(XT(1)+1,YT(1),3),INH
12100 if FACE(1)=3 then swap OBJGRID(XT(1),YT(1)+1,1),INH
12110 if FACE(1)=4 then swap OBJGRID(XT(1)-1,YT(1),2),INH
12120 if INH<1 then INH=-2
12121 goto 12472
12130 OBJHRL=INH : if FACE(1)=1 then swap OBJGRID(XT(1),YT(1),1),INH
12140 if FACE(1)=2 then swap OBJGRID(XT(1),YT(1),2),INH
12150 if FACE(1)=3 then swap OBJGRID(XT(1),YT(1),4),INH
12160 if FACE(1)=4 then swap OBJGRID(XT(1),YT(1),3),INH
12170 if INH<1 then INH=-2
12171 goto 12472
12180 OBJHRR=INH : if FACE(1)=1 then swap OBJGRID(XT(1),YT(1),2),INH
12190 if FACE(1)=2 then swap OBJGRID(XT(1),YT(1),4),INH
12200 if FACE(1)=3 then swap OBJGRID(XT(1),YT(1),3),INH
12210 if FACE(1)=4 then swap OBJGRID(XT(1),YT(1),1),INH
12220 if INH<1 then INH=-2
12221 goto 12472
12230 if OBJAHL+OBJAHR+OBJHRR+OBJHRL=0 then goto 9590
12240 on Z goto 12250,12310,12370,12430
12250 if OBJAHL=0 then goto 9900
12260 if FACE(1)=1 then INH=OBJGRID(XT(1),YT(1)-1,3) : OBJGRID(XT(1),YT(1)-1,3)=0
12270 if FACE(1)=2 then INH=OBJGRID(XT(1)+1,YT(1),1) : OBJGRID(XT(1)+1,YT(1),1)=0
12280 if FACE(1)=3 then INH=OBJGRID(XT(1),YT(1)+1,2) : OBJGRID(XT(1),YT(1)+1,2)=0
12290 if FACE(1)=4 then INH=OBJGRID(XT(1)-1,YT(1),4) : OBJGRID(XT(1)-1,YT(1),4)=0
12300 OBJAHL=0 : goto 12472
12310 if OBJAHR=0 then goto 9900
12320 if FACE(1)=1 then INH=OBJGRID(XT(1),YT(1)-1,4) : OBJGRID(XT(1),YT(1)-1,4)=0
12330 if FACE(1)=2 then INH=OBJGRID(XT(1)+1,YT(1),3) : OBJGRID(XT(1)+1,YT(1),3)=0
12340 if FACE(1)=3 then INH=OBJGRID(XT(1),YT(1)+1,1) : OBJGRID(XT(1),YT(1)+1,1)=0
12350 if FACE(1)=4 then INH=OBJGRID(XT(1)-1,YT(1),2) : OBJGRID(XT(1)-1,YT(1),2)=0
12360 OBJAHR=0 : goto 12472
12370 if OBJHRL=0 then goto 9900
12380 if FACE(1)=1 then INH=OBJGRID(XT(1),YT(1),1) : OBJGRID(XT(1),YT(1),1)=0
12390 if FACE(1)=2 then INH=OBJGRID(XT(1),YT(1),2) : OBJGRID(XT(1),YT(1),2)=0
12400 if FACE(1)=3 then INH=OBJGRID(XT(1),YT(1),4) : OBJGRID(XT(1),YT(1),4)=0
12410 if FACE(1)=4 then INH=OBJGRID(XT(1),YT(1),3) : OBJGRID(XT(1),YT(1),3)=0
12420 OBJHRL=0 : goto 12472
12430 if OBJHRR=0 then goto 9900
12440 if FACE(1)=1 then INH=OBJGRID(XT(1),YT(1),2) : OBJGRID(XT(1),YT(1),2)=0
12450 if FACE(1)=2 then INH=OBJGRID(XT(1),YT(1),4) : OBJGRID(XT(1),YT(1),4)=0
12460 if FACE(1)=3 then INH=OBJGRID(XT(1),YT(1),3) : OBJGRID(XT(1),YT(1),3)=0
12470 if FACE(1)=4 then INH=OBJGRID(XT(1),YT(1),1) : OBJGRID(XT(1),YT(1),1)=0
12471 OBJHRR=0 : goto 12472
12472 repeat : MB=mouse key : until MB=0 : gosub 12473 : goto 9590 : rem This should stop the mouse running away by making it wait until the mouse button is up.
12473 rem ******** Redraw just area near player *******
12474 dreg(7)=3 : areg(0)=varptr(OBJBGR$) : areg(1)=M8 : dreg(0)=16 : dreg(1)=156 : dreg(2)=0 : call PODGE
12475 if OBJAHL>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJAHL))),OBJSAUCEX(OBJHERE(OBJAHL)),0,OBJSAUCEX(OBJHERE(OBJAHL))+64,24,M8,48,155,4096
12476 if OBJAHR>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJAHR))),OBJSAUCEX(OBJHERE(OBJAHR)),0,OBJSAUCEX(OBJHERE(OBJAHR))+64,24,M8,112,155,4096
12477 if OBJHRL>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJHRL))),OBJSAUCEX(OBJHERE(OBJHRL)),0,OBJSAUCEX(OBJHERE(OBJHRL))+64,24,M8,32,171,4096
12478 if OBJHRR>0 then blitter merge M2+(160*OBJSAUCEY(OBJHERE(OBJHRR))),OBJSAUCEX(OBJHERE(OBJHRR)),0,OBJSAUCEX(OBJHERE(OBJHRR))+64,24,M8,128,171,4096
12480 return 
12490 rem ******** Change level ********
12500 wash back,16,1,208,189 : change mouse WT : hide on 
12510 wash physic,16,1,208,189 : ZZ$="Entering new level..."+chr$(0) : dreg(7)=6 : areg(0)=varptr(ZZ$) : areg(1)=back : dreg(0)=192 : dreg(1)=16 : dreg(2)=0 : call PODGE : skopy 1,back,16,192,304,200,physic,16,192
12520 fill varptr(OBJGRID(0,0,0)) to varptr(OBJGRID(0,0,0))+25920,0
12530 fill varptr(MGRID(0,0)) to varptr(MGRID(0,0))+5184,0 : fill varptr(DPOS(0,0)) to varptr(DPOS(0,0))+5184,0
12540 rem Time to break out my assembler functions rawwipe, flatpack, and inflate to get all this into the player journal and similar.
12550 for ZZ=1 to 4
12560 if XT(1)=EXTX(ZZ) and YT(1)=EXTX(ZZ) then N=ZZ
12570 next ZZ
12580 CURLOC$(1)=EXTLOC$(N) : XT(1)=ENTRX(N) : YT(1)=ENTRY(N)
12590 goto 3820
12600 rem ******** Interaction *********
12610 if AHEAD<=3 then return 
12620 if FACE(1)=1 then AHX=XT(1) : AHY=YT(1)-1 : goto 12660
12630 if FACE(1)=2 then AHX=XT(1)+1 : AHY=YT(1) : goto 12660
12640 if FACE(1)=3 then AHX=XT(1) : AHY=YT(1)+1 : goto 12660
12650 if FACE(1)=4 then AHX=XT(1)-1 : AHY=YT(1) : goto 12660
12660 AAA=AHEAD-3 : on AAA goto 12680,12720,12810,12810,12880,12850,13000,13000,13000
12670 return 
12680 rem Sign text
12690 for ZZ=1 to NUMPLACS : if AHX=PLACX(ZZ) and AHY=PLACY(ZZ) then ZZ$=left$(PLACTXT$(ZZ),72)+chr$(0)
12700 next ZZ
12710 return 
12720 rem Lock interaction
12730 for ZZ=1 to NUMLOCKS : if AHX=LOCKX(ZZ) and AHY=LOCKY(ZZ) then F=ZZ
12740 next ZZ
12750 if LOCKSTAT(F)>0 then ZZ$="This is already unlocked."+chr$(0) : return 
12760 G=KTYPE(LOCKTYPE(F)) : if INH=G then goto 12790
12770 if INH>0 then ZZ$="That doesn't fit."+chr$(0) else ZZ$="A key is needed for this lock."+chr$(0)
12775 if LOCKTYPE(F)=10 then ZZ$="This lock looks mind-bendingly complex; only a truly unique key will open it."+chr$(0)
12780 return 
12790 INH=-2 : change mouse STDM : inc LOCKSTAT(F) : DPOS(LTARGX(F),LTARGY(F))=-2 : shoot 
12800 return 
12810 rem Button pushing
12820 rem Lever toggle (up to down)
12830 return : rem Lever toggle (down to up)
12840 rem Chesticles, closed
12850 for ZZ=1 to NUMCHESTS : if AHX=CHESTX(ZZ) and AHY=CHESTY(ZZ) then F=ZZ
12860 next ZZ : rem Insert a nice creaky chest opening sound here.
12870 DPOS(CHESTX(F),CHESTY(F))=8 : CHESTSTAT(F)=1 : return 
12880 rem Chesticles, open
12890 for ZZ=1 to NUMCHESTS : if AHX=CHESTX(ZZ) and AHY=CHESTY(ZZ) then F=ZZ
12900 next ZZ
12910 if INH<=0 then 12920 else 12960
12920 if NCHEST(F)=0 then ZZ$="The chest appears to be empty."+chr$(0) : return : rem IF NOTHING IN HAND
12930 INH=CNTENTS(F,NCHEST(F)) : CNTENTS(F,NCHEST(F))=-1
12940 for ZZ=1 to NCHEST(F)-1 : CNTENTS(F,ZZ)=CNTENTS(F,ZZ+1) : next ZZ : dec NCHEST(F)
12950 return 
12960 if NCHEST(F)=8 then ZZ$="The chest appears to be full."+chr$(0) : return : rem IF SOMETHING IN HAND
12970 CNTENTS(F,NCHEST(F)+1)=INH : INH=-2 : change mouse STDM : rem Last in, first out
12980 inc NCHEST(F)
12990 return 
13000 rem Decor
13010 ZZ$=DCRDESC$(AHEAD-9)+chr$(0) : return 
13020 rem ******* Lock compositing *******
13030 if FACE(1)=1 then LOCKPOSX=XT(1)+OFS : LOCKPOSY=YT(1)-DIST
13040 if FACE(1)=2 then LOCKPOSX=XT(1)+DIST : LOCKPOSY=YT(1)+OFS
13050 if FACE(1)=3 then LOCKPOSX=XT(1)-OFS : LOCKPOSY=YT(1)+DIST
13060 if FACE(1)=4 then LOCKPOSX=XT(1)-DIST : LOCKPOSY=YT(1)-OFS
13070 for ZZ=1 to NUMLOCKS
13080 if LOCKX(ZZ)=LOCKPOSX and LOCKY(ZZ)=LOCKPOSY then LTT=LOCKTYPE(ZZ)
13090 next ZZ
13100 screen$(8,XLL(DIST,OFS+2),80)=LOCKPANEL$(LTT,DIST)
13110 if OFS<0 and DIST<4 then screen$(8,XLS(DIST,OFS+2),80)=LOCKL$(LTT,DIST/2)
13120 if OFS>0 and DIST<4 then screen$(8,XLS(DIST,OFS+2),80)=LOCKR$(LTT,DIST/2)
13130 return 
13140 rem ******** Pause Menu *********
13150 off : GRB$=screen$(back,16,16 to 192,176) : NOW=rtim
13160 ink 0 : polygon 32,28 to 40,20 to 104,20 to 112,16 to 120,20 to 176,20 to 184,28 to 184,164 to 176,172 to 120,172 to 112,176 to 104,172 to 40,172 to 32,164 to 32,28 : ink 13 : polyline 32,28 to 40,20 to 104,20 to 112,16 to 120,20 to 176,20 to 184,28 to 184,164 to 176,172 to 120,172 to 112,176 to 104,172 to 40,172 to 32,164 to 32,28
13164 reset zone 
13170 V1$="P A U S E"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=32 : dreg(1)=96 : dreg(2)=1 : call PODGE : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=32 : dreg(1)=96 : dreg(2)=2 : call PODGE : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=32 : dreg(1)=96 : dreg(2)=0 : call PODGE
13180 ink 7 : draw 96,42 to 130,42 : draw 96,44 to 130,44 : ink 13
13190 V1$=" Save Game"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=56 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,54 to 102,66 : set zone 110,46,54 to 102,66
13191 V1$=" Load Game"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=72 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,70 to 102,82 : set zone 111,46,70 to 102,82
13192 V1$=" Format Disk"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=88 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,86 to 102,98 : set zone 112,46,86 to 102,98
13193 V1$=" Game Stats"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=104 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,102 to 102,114 : set zone 113,46,102 to 102,114
13194 V1$=" Options"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=120 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,118 to 102,130 : set zone 114,46,118 to 102,130
13196 V1$=" Quit Game"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=136 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,134 to 102,146 : set zone 115,46,134 to 102,146
13197 V1$=" Resume Game"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=152 : dreg(1)=48 : dreg(2)=0 : call PODGE : box 46,150 to 102,162 : set zone 116,46,150 to 102,162
13200 V1$="  ver. "+VER$+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=163 : dreg(1)=128 : dreg(2)=0 : call PODGE : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=163 : dreg(1)=128 : dreg(2)=2 : call PODGE : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=163 : dreg(1)=128 : dreg(2)=3 : call PODGE
13210 fastcopy back,physic
13260 repeat : K$=inkey$ : M=scancode : Z=zone(0) : MB=mouse key : until K$<>"" or MB>0
13270 if MB=1 and Z>100 then goto 13300
13280 rem if M=CTL(20) then goto 13320
13290 goto 13260
13300 QZ=Z-109 : on QZ goto 13340,13350,13360,13370,13379,1150,13320
13310 goto 13260
13320 quick screen$ back,16,16,GRB$,0 : areg(0)=back : areg(1)=physic : dreg(0)=0 : dreg(1)=0 : dreg(2)=320 : dreg(3)=200 : dreg(4)=0 : dreg(5)=0 : dreg(7)=0 : call PODGE : setrtim NOW : goto 9780
13340 bell : goto 13260
13350 bell : goto 13260
13360 bell : goto 13260
13370 bell : goto 13260
13379 bell : goto 13260
13380 rem ******* Throw something *******
13390 if INH<=0 then return 
13400 inc THROWN : MEH=INH
13410 THROWX(THROWN)=XT(1) : THROWY(THROWN)=YT(1) : THROBJ(THROWN)=INH : THRVECT(THROWN)=FACE(1) : INH=-2
13420 change mouse STDM : rem areg(0)=M1 : dreg(0)=34 : dreg(1)=PROJPOSX(0,2) : dreg(2)=PROJPOSY(0,2) : dreg(3)=OBJBIG(MEH) : trap 5 : RECOMP=true : We don't need to do this any more
13430 return 
13440 rem ******* Housekeeping - every tick ******
13450 RECOMP=true : rem Always redraw; the idea of a redraw flag is stupid
13460 rem if btst(0,TICS) then MSHUF=5 else MSHUF=0 : rem Do we really need this?
13470 if THROWN=0 and NUMCRIT=0 then goto 9810
13480 if NUMCRIT>0 then gosub 14320
13490 for MM=1 to NUMCRIT : MOFS=-3 : MDIST=-1 : if MSTAT(MM)=0 then goto 13570
13500 if RECOMP=true then MM=NUMCRIT : goto 13570 : rem We aren't filling the subgrid any more so let's get rid of that maybe?
13510 on FACE(1) goto 13520,13530,13540,13550
13520 MDIST=YT(1)-MY(MM) : MOFS=XT(1)-MX(MM) : goto 13560
13530 MDIST=MX(MM)-XT(1) : MOFS=MY(MM)-YT(1) : goto 13560
13540 MDIST=MY(MM)-YT(1) : MOFS=MX(MM)-XT(1) : goto 13560
13550 MDIST=XT(1)-MX(MM) : MOFS=YT(1)-MY(MM) : goto 13560
13560 if MDIST<=5 and MDIST>0 and MOFS>=-2 and MOFS<=2 then RECOMP=true : XX=MOFS+3 : YY=MDIST : rem SUBGRIDM(XX,YY)=MM
13570 next MM
13580 if THROWN=0 then goto 13780
13590 for ZF=1 to THROWN : THRDIST=-1 : THROFS=-2
13600 on THRVECT(ZF) goto 13610,13630,13650,13670
13610 if DPOS(THROWX(ZF),THROWY(ZF)-1)>0 then gosub 13790
13620 dec THROWY(ZF) : goto 13710
13630 if DPOS(THROWX(ZF)+1,THROWY(ZF))>0 then gosub 13790
13640 inc THROWX(ZF) : goto 13710
13650 if DPOS(THROWX(ZF),THROWY(ZF)+1)>0 then gosub 13790
13660 inc THROWY(ZF) : goto 13710
13670 if DPOS(THROWX(ZF)-1,THROWY(ZF))>0 then gosub 13790
13680 dec THROWX(ZF) : goto 13710
13690 rem Whoooaaaaaaa, demons are a girl's best friend
13700 rem Let's garbage-collect regularly but not every tick
13710 if FACE(1)=1 then THRDIST=YT(1)-THROWY(ZF) : THROFS=XT(1)-THROWX(ZF)
13720 if FACE(1)=2 then THRDIST=THROWX(ZF)-XT(1) : THROFS=THROWY(ZF)-YT(1)
13730 if FACE(1)=3 then THRDIST=THROWY(ZF)-YT(1) : THROFS=THROWX(ZF)-XT(1)
13740 if FACE(1)=4 then THRDIST=XT(1)-THROWX(ZF) : THROFS=YT(1)-THROWY(ZF)
13750 if THRDIST>0 and THRDIST<=5 and THROFS>=-1 and THROFS<=1 then RECOMP=true
13760 next ZF
13770 rem gosub 16350 : rem This is where the scripting is checked from.
13780 if RECOMP=true then goto 5590 else goto 9810
13781 rem ******* Housekeeping - every tock *******
13782 QQ=free : rem Garbage Collection
13783 wash back,16,192,320,200 : wash physic,16,192,320,200 : rem Clear the text bar
13789 return 
13790 rem ******* Land thrown object *******
13800 AA=1 : while OBJGRID(THROWX(ZF),THROWY(ZF),AA)>0 : inc AA : wend 
13810 OBJGRID(THROWX(ZF),THROWY(ZF),AA)=THROBJ(ZF)
13820 for QZ=ZF to THROWN-1 : THROWX(QZ)=THROWX(QZ+1) : THROWY(QZ)=THROWY(QZ+1) : THROBJ(QZ)=THROBJ(QZ+1) : THRVECT(QZ)=THRVECT(QZ+1) : next QZ
13830 dec THROWN : RECOMP=true
13840 return 
13850 rem ******* Draw objects in flight *******
13855 rem From here onwards (0.66) this is called at drawing time.
13860 if THROWN<=0 then return 
13870 on FACE(1) goto 13880,13890,13900,13910
13880 for ZQZ=1 to THROWN : THRDIST=YT(1)-THROWY(ZQZ) : THROFS=XT(1)-THROWX(ZQZ) : gosub 13920 : next ZQZ : return 
13890 for ZQZ=1 to THROWN : THRDIST=THROWX(ZQZ)-XT(1) : THROFS=THROWY(ZQZ)-YT(1) : gosub 13920 : next ZQZ : return 
13900 for ZQZ=1 to THROWN : THRDIST=THROWY(ZQZ)-YT(1) : THROFS=THROWX(ZQZ)-XT(1) : gosub 13920 : next ZQZ : return 
13910 for ZQZ=1 to THROWN : THRDIST=XT(1)-THROWX(ZQZ) : THROFS=YT(1)-THROWY(ZQZ) : gosub 13920 : next ZQZ : return 
13920 CLP=4
13930 if VFAHD>2 then CLP=3
13940 if CCFD>2 then CLP=2
13950 if CMD>2 then CLP=1
13960 if AHEAD>2 then CLP=0
13970 if THRDIST>CLP or THRDIST<0 then return 
13980 if THROFS<-1 or THROFS>1 then return 
13981 on THRDIST goto 13982,13983,13984,13985
13982 MEH=OBJNEAR(THROBJ(ZQZ)) : goto 14020
13983 MEH=OBJFAR(THROBJ(ZQZ)) : goto 14020
13984 MEH=OBJVFAR(THROBJ(ZQZ)) : goto 14020
13985 MEH=OBJVVFAR(THROBJ(ZQZ)) : goto 14020
14020 blitter merge M2+(160*OBJSAUCEY(MEH)),OBJSAUCEX(MEH),0,OBJSAUCEX(MEH)+32,16,M8,PROJPOSX(THRDIST,THROFS+2),PROJPOSY(THRDIST,THROFS+2),4096 : rem That command took far too long for me to work out
14030 return 
14050 rem ******* Damage Player ********
14060 CHP=CHP-DAMAGE : ZZ$="Damage Taken: "+str$(DAMAGE)+chr$(0)
14070 I=DAMAGE/8 : IN10SE=($100*I) : if IN10SE>$700 then IN10SE=$700
14080 colour 0,IN10SE :  : DAMAGE=0 : if CHP<0 then CHP=0
14090 TCH#=CHP : TMH#=MXHP : R#=(TCH#/TMH#)*49.0 : RR=int(R#) : RRR=49-RR
14100 rem Play the sample numbered I+N+K where N is the start of the "run" of seven samples for increasing damage, plus a further 7 if player is female
14105 blit M9,256,7+RR,272,56,back,208,127+RR : blit M9,256,71,272,71+RRR,back,208,127 : blit back,208,127,224,176,physic,208,127
14110 DAMAGE=0 : wait vbl : fade 4,$0
14120 if CHP<=0 then DEAD=true else DEAD=false
14130 return 
14140 rem ******* You Died *******
14150 hide on : mouseoff : fade 12,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400,$400
14160 dreg(0)=0 : call 14
14170 dreg(0)=5 : dreg(1)=4 : call 14
14180 dreg(0)=1 : areg(0)=start(7) : areg(1)=start(3) : call 14
14190 colour 1,$0
14200 wait vbl : wipe back : wipe physic : clw 
14210 V1$="                            Y O U   A R E   D E A D"+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=72 : dreg(1)=0 : dreg(2)=0 : call PODGE
14220 V1$=CAUSE$(CAUSE)+chr$(0) : dreg(7)=6 : areg(0)=varptr(V1$) : areg(1)=back : dreg(0)=96 : dreg(1)=16 : dreg(2)=0 : call PODGE
14230 quick screen$ back,32,120,RES$,0 : quick screen$ back,128,120,REL$,0 : quick screen$ back,224,120,Q$,0
14240 fastcopy back,physic
14250 for ZZ=0 to 110 : wait vbl : next ZZ
14260 dreg(0)=2 : call 14 : dreg(0)=3 : call 14 : change mouse WT : mouseon : show on : erase 7
14270 reset zone 
14280 set zone 1,32,120 to 96,152 : set zone 2,128,120 to 192,152 : set zone 3,224,120 to 288,152
14290 repeat : Z=zone(0) : MB=mouse key : until MB=1
14300 on Z gosub 3080,1898,1150
14310 goto 14290
14320 rem ******* Monster Upkeep *******
14330 if btst(0,TICS) then VM=1 else VM=2
14340 MM=VM
14350 rem Begin goto loop
14360 if MSTAT(MM)=0 then MGRID(MX(MM),MY(MM))=0 : MX(MM)=-99 : MY(MM)=-99 : goto 14560 : rem Skip it if it's dead and pull it off the board
14370 if TSLM(MM)<=MSPD(MTYPE(MM)) then goto 14540
14380 ALIGNMENT=false : if XT(1)=MX(MM) or YT(1)=MY(MM) then ALIGNMENT=true
14390 CANVECT(1)=true : CANVECT(2)=true : CANVECT(3)=true : CANVECT(4)=true : ADJACENCY=0 : ATK(MM)=false
14400 if MY(MM)<=0 then CANVECT(1)=false
14410 if MX(MM)>=35 then CANVECT(2)=false
14420 if MY(MM)>=35 then CANVECT(3)=false
14430 if MX(MM)<=0 then CANVECT(4)=false
14440 if DPOS(MX(MM),MY(MM)-1)>0 or MGRID(MX(MM),MY(MM)-1)>0 then CANVECT(1)=false
14450 if DPOS(MX(MM)+1,MY(MM))>0 or MGRID(MX(MM)+1,MY(MM))>0 then CANVECT(2)=false
14460 if DPOS(MX(MM),MY(MM)+1)>0 or MGRID(MX(MM),MY(MM)+1)>0 then CANVECT(3)=false
14470 if DPOS(MX(MM)-1,MY(MM))>0 or MGRID(MX(MM)-1,MY(MM))>0 then CANVECT(4)=false
14480 if MY(MM)-1=YT(1) and MX(MM)=XT(1) then CANVECT(1)=false : ADJACENCY=1
14490 if MX(MM)+1=XT(1) and MY(MM)=YT(1) then CANVECT(2)=false : ADJACENCY=2
14500 if MY(MM)+1=YT(1) and MX(MM)=XT(1) then CANVECT(3)=false : ADJACENCY=3
14510 if MX(MM)-1=XT(1) and MY(MM)=YT(1) then CANVECT(4)=false : ADJACENCY=4
14520 TSLM(MM)=0 : rem RESET THE CLOCK
14530 on MBEHAV(M(MTYPE(MM))) gosub 14580,14720,14910,15100,14580,14580,14580,14580,14580 : rem Change this as we design and plug in more behaviours
14540 inc TSLM(MM)
14550 rem This line does not exist (yet)
14560 inc MM : inc MM : if MM>NUMCRIT then 14570 else 14350 : rem Faster than a for/next, I'm told
14570 return 
14580 rem ******* Monster Behaviour - wander *******
14590 MV=rnd(3)+1 : inc MTIC(MM)
14600 if MV=MFACE(MM) then goto 14650
14610 if MV>MFACE(MM) then inc MFACE(MM)
14620 if MV<MFACE(MM) then dec MFACE(MM)
14630 if MFACE(MM)<1 then MFACE(MM)=4 : goto 14650
14640 if MFACE(MM)>4 then MFACE(MM)=4 : goto 14650
14650 if CANVECT(MFACE(MM))=true then goto 14660 else goto 14710 : rem If it can't move that way, don't move at all (this avoids getting stuck in RND loops)
14660 on MV goto 14670,14680,14690,14700
14670 MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14680 MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14690 MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14700 MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14710 return : rem This is a backstop
14720 rem ******* Monster Behaviour - guard *******
14730 if ADJACENCY>0 then goto 15700
14740 dreg(7)=9 : dreg(0)=MX(MM) : dreg(1)=MY(MM) : dreg(2)=XT(1) : dreg(3)=YT(1) : call PODGE : inc MTIC(MM)
14750 if dreg(0)>9 then 14860 : rem If player not in range, return to point of origin
14760 if ALIGNMENT=true then 15760
14770 if btst(0,MTIC(MM)) then goto 14790 : rem Alternate horz and vert movement
14780 if MX(MM)>XT(1) then MV=4 : goto 14800 : else MV=2 : goto 14800
14790 if MY(MM)>YT(1) then MV=1 : goto 14800 : else MV=3 : goto 14800
14800 MFACE(MM)=MV : if CANVECT(MV)=true then goto 14810 else goto 14900
14810 on MV goto 14820,14830,14840,14850
14820 MFACE(MM)=1 : MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14830 MFACE(MM)=2 : MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14840 MFACE(MM)=3 : MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14850 MFACE(MM)=4 : MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
14860 if MX(MM)=M0RIGX(MM) and MY(MM)=M0RIGY(MM) then return 
14870 if btst(0,MTIC(MM)) then goto 14890 : rem Alternate horz and vert movement
14880 if MX(MM)>M0RIGX(MM) then MV=4 : goto 14800 : else MV=2 : goto 14800
14890 if MY(MM)>M0RIGX(MM) then MV=1 : goto 14800 : else MV=3 : goto 14800
14900 return : rem In this behaviour the monster stays in place and only attacks the player or moves if the player comes within 3 squares
14910 rem ******* Monster Behaviour - area guard *******
14920 if ADJACENCY>0 then goto 15700
14930 dreg(7)=9 : dreg(0)=MX(MM) : dreg(1)=MY(MM) : dreg(2)=XT(1) : dreg(3)=YT(1) : call PODGE : inc MTIC(MM)
14940 if dreg(0)>36 then 15050 : rem If player not in range, return to point of origin - also, must insert logic for attacking the player
14950 if ALIGNMENT=true then 15760
14960 if btst(0,MTIC(MM)) then goto 14980 : rem Alternate horz and vert movement
14970 if MX(MM)>XT(1) then MV=4 : goto 14990 : else MV=2 : goto 14990
14980 if MY(MM)>YT(1) then MV=1 : goto 14990 : else MV=3 : goto 14990
14990 MFACE(MM)=MV : if CANVECT(MV)=true then goto 15000 else goto 15090
15000 on MV goto 15010,15020,15030,15040
15010 MFACE(MM)=1 : MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15020 MFACE(MM)=2 : MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15030 MFACE(MM)=3 : MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15040 MFACE(MM)=4 : MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15050 if MX(MM)=M0RIGX(MM) and MY(MM)=M0RIGY(MM) then return 
15060 if btst(0,MTIC(MM)) then goto 15090 : rem Alternate horz and vert movement
15070 if MX(MM)>M0RIGX(MM) then MV=4 : goto 14970 : else MV=2 : goto 14970
15080 if MY(MM)>M0RIGX(MM) then MV=1 : goto 14970 : else MV=3 : goto 14970
15090 return : rem In this behaviour the monster stays in place but sallies out up to 6 squares to attack the player
15100 rem ******* Monster Behaviour - hug left wall *******
15110 inc MTIC(MM) : if ADJACENCY>0 then goto 15700
15120 if CANVECT(4)=false and CANVECT(1)=false and CANVECT(2)=false and CANVECT(3)=false then return 
15130 dreg(7)=9 : dreg(0)=MX(MM) : dreg(1)=MY(MM) : dreg(2)=XT(1) : dreg(3)=YT(1) : call PODGE : if dreg(0)<4 then 14960 : rem Sally out if player near
15140 if CURVECT(MM)=0 then inc CURVECT(MM)
15150 on CURVECT(MM) goto 15160,15200,15240,15280
15160 if CANVECT(4)=true then CURVECT(MM)=4 : goto 15320
15170 if CANVECT(4)=false and CANVECT(1)=true then CURVECT(MM)=1 : goto 15320
15180 if CANVECT(4)=false and CANVECT(1)=false and CANVECT(2)=true then CURVECT(MM)=2 : goto 15320
15190 if CANVECT(4)=false and CANVECT(1)=false and CANVECT(2)=false and CANVECT(3)=true then CURVECT(MM)=3 : goto 15320
15200 if CANVECT(1)=true then CURVECT(MM)=1 : goto 15320
15210 if CANVECT(1)=false and CANVECT(2)=true then CURVECT(MM)=2 : goto 15320
15220 if CANVECT(1)=false and CANVECT(2)=false and CANVECT(3)=true then CURVECT(MM)=3 : goto 15320
15230 if CANVECT(1)=false and CANVECT(2)=false and CANVECT(3)=false and CANVECT(4)=true then CURVECT(MM)=4 : goto 15320
15240 if CANVECT(2)=true then CURVECT(MM)=2 : goto 15320
15250 if CANVECT(2)=false and CANVECT(3)=true then CURVECT(MM)=3 : goto 15320
15260 if CANVECT(2)=false and CANVECT(3)=false and CANVECT(4)=true then CURVECT(MM)=4 : goto 15320
15270 if CANVECT(2)=false and CANVECT(3)=false and CANVECT(4)=false and CANVECT(1)=true then CURVECT(MM)=1 : goto 15320
15280 if CANVECT(3)=true then CURVECT(MM)=3 : goto 15320
15290 if CANVECT(3)=false and CANVECT(4)=true then CURVECT(MM)=4 : goto 15320
15300 if CANVECT(3)=false and CANVECT(4)=false and CANVECT(1)=true then CURVECT(MM)=1 : goto 15320
15310 if CANVECT(3)=false and CANVECT(4)=false and CANVECT(1)=false and CANVECT(2)=true then CURVECT(MM)=2 : goto 15320
15320 MFACE(MM)=CURVECT(MM) : on CURVECT(MM) goto 15330,15340,15350,15360
15330 MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15340 MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15350 MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15360 MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15370 return : rem This behaviour is what it sounds like, but with a slightly aggressive twist. 
15380 rem ******* Monster Behaviour - patrol *******
15390 return : rem This behaviour has the monster walk forward until it can't, then turn left, and attack the player if they come within 3 squares
15400 rem ******* Monster Behaviour - prowl *******
15410 return : rem As wander, but if the player comes within 6 squares it will attempt to get as close to the player as it can and attack. This would be good for a quiet but deadly critter like the Baelon to sneak up on players in the forest
15420 rem ******* Monster Behaviour - run away *******
15430 return : rem This is imposed on a monster by spells or effects that cause fear; the monster tries to get as far away from the player as possible and will not attack even if cornered
15440 rem ******* Monster Behaviour - mob *******
15450 return : rem In this behaviour the monster will try to get as close to another monster as possible then act as prowl. With a bit of luck creatures with this setting will form packs.
15460 rem ******* Monster Behaviour - flank *******
15470 if ADJACENCY>0 then 15700
15480 dreg(7)=9 : dreg(0)=MX(MM) : dreg(1)=MY(MM) : dreg(2)=XT(1) : dreg(3)=YT(1) : call PODGE : inc MTIC(MM)
15490 if dreg(0)>25 then return : rem If player not in range, stay put
15500 MHDIST=abs(XT(1)-MX(MM)) : MVDIST=abs(YT(1)-MY(MM))
15510 if RELFACE(FACE(1),MFACE(MM))=3 and ALIGNMENT=true then 15760 : rem Only charge if the player is not facing them
15520 if ALIGNMENT=true then BB=btst(0,TICS) : goto 15580
15530 on VECTGRID(MFACE(MM),MHDIST,MVDIST) goto 15540,15550,15560,15570
15540 if CANVECT(1)=true then MFACE(MM)=1 : MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : return 
15550 if CANVECT(2)=true then MFACE(MM)=2 : MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : return 
15560 if CANVECT(3)=true then MFACE(MM)=3 : MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : return 
15570 if CANVECT(4)=true then MFACE(MM)=4 : MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : return 
15580 if BB then on MFACE(MM) goto 15590,15600,15610,15620 : else on MFACE(MM) goto 15610,15620,15590,15600
15590 if CANVECT(2)=true then MFACE(MM)=2 : MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15600 if CANVECT(3)=true then MFACE(MM)=3 : MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15610 if CANVECT(4)=true then MFACE(MM)=4 : MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15620 if CANVECT(1)=true then MFACE(MM)=1 : MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15630 return : rem In this behaviour a monster will try to get round behind the player. 50% of the time it'll go to the left and the other 50% to the right. This can be achieved by having its move determined by the relative positions of the player and monster within 6 squares. If it is adjacent to the player it will always turn and attack. 
15640 rem ******* Monster Behaviour - coward *******
15650 return : rem This is where the monster advances on you only from behind or the side, otherwise tries to run away. If cornered, though, it'll attack.
15660 rem ******* Monster Behaviour - snipe *******
15661 dreg(7)=9 : dreg(0)=MX(MM) : dreg(1)=MY(MM) : dreg(2)=XT(1) : dreg(3)=YT(1) : call PODGE : inc MTIC(MM) : if dreg(0)>25 then return : rem If player not in range, do nothing
15662 if ADJACENCY>0 then 15700
15663 if ALIGNMENT>0 then 15730
15664 AA=MX(MM)-XT(1) : BB=MY(MM)-YT(1)
15665 if AA>BB then 15667
15666 if BB>0 then MV=1 else MV=3 : goto 15668
15667 if AA>0 then MV=4 else MV=2
15668 if CANVECT(MV)=true then on MV goto 15673,15670,15671,15672 : else if MV<4 then inc MV : goto 15667
15670 if CANVECT(2)=true then MFACE(MM)=2 : inc MX(MM) : return 
15671 if CANVECT(3)=true then MFACE(MM)=3 : inc MY(MM) : return 
15672 if CANVECT(4)=true then MFACE(MM)=4 : dec MX(MM) : return 
15673 if CANVECT(1)=true then MFACE(MM)=1 : dec MY(MM) : return 
15679 return : rem This is where the monster tries to get in line with the player in a limited 3-square range and then fire at them. Use only on monsters with magical attacks to avoid filling the level with crap.
15680 rem ******* Monster Behaviour - track *******
15690 return : rem This is where the monster looks to each square it could get to in three moves and then makes the move that will allow it to get to the three-away square closest to the player. Might want to use this in the boss arena of the last caves level so the Baelon appears to hunt the player.
15700 rem ******* Monster Sub-Behaviour - attack the player if adjacent *******
15710 if ADJACENCY=MFACE(MM) then 15720 else MFACE(MM)=ADJACENCY : return 
15720 ATK(MM)=true : return 
15730 rem ******* Monster Sub-Behaviour - ranged attack ********
15740 return : rem This is where a monster with a ranged attack is in line with the player and there are no interposing entities. The RATK flag is set and the appropriate projectile or item is created and added to the thrown object list. Might want to be careful with what projectiles are used otherwise dungeon levels might get filled up with spent knives and chakrams. 
15750 rem This is only jumped to in behaviours OTHER than wander and run away and half the time in coward.
15760 rem ******* Monster Sub-Behaviour - charge! *******
15770 on MFACE(MM) goto 15780,15790,15800,15810
15780 if CANVECT(1)=true then MGRID(MX(MM),MY(MM))=0 : dec MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15790 if CANVECT(2)=true then MGRID(MX(MM),MY(MM))=0 : inc MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15800 if CANVECT(3)=true then MGRID(MX(MM),MY(MM))=0 : inc MY(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15810 if CANVECT(4)=true then MGRID(MX(MM),MY(MM))=0 : dec MX(MM) : MGRID(MX(MM),MY(MM))=MM : return 
15820 return : rem When a monster is inline with the player with this sub-behaviour it should always advance. Maybe have a behaviour where it will charge if the player's back is turned otherwise it'll try to flank?
15830 rem ******* Wrangling the Player Journal *******
15840 rem A bit of explanation - this is a memory bank that is reserved to store a full record of the EXACT state of the entire game at any given time.
15850 rem It is a flatpacked version of each level map (1 byte/square for all layers) as it actually stands, and can be bsaved and bloaded.
15860 rem It goes into bank 6 so PLEASE DON'T USE THIS FOR ANYTHING ELSE!!!!!!!!!!!
15870 rem The player journal should not be fiddled with other than at level transitions or loading and saving a game. 
15880 rem Saved games are called "wolsave.n" where n is from 1 to 6. Sorry, only 6 save slots as that's as many times this can fit on a floppy.
15890 return 
16000 rem ******* Apply Buffs and Nerfs *******
16010 STBUFF=0 : DEBUFF=0 : INBUFF=0 : SABUFF=0 : REBUFF=0 : HPBUFF=0 : MANABUFF=0
16020 ZZX=HELM : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16030 ZZX=NECK : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16040 ZZX=ARMR : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16060 ZZX=BELT : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16070 ZZX=WEPN : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16080 ZZX=SHLD : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16090 ZZX=FEET : on BUFF(ZZX) gosub 16100,16110,16120,16130,16140,16150,16160
16096 return 
16100 STBUFF=STBUFF+BUFFAMOUNT(ZZX) : return 
16110 DEBUFF=DEBUFF+BUFFAMOUNT(ZZX) : return 
16120 INBUFF=INBUFF+BUFFAMOUNT(ZZX) : return 
16130 SABUFF=SABUFF+BUFFAMOUNT(ZZX) : return 
16140 REBUFF=REBUFF+BUFFAMOUNT(ZZX) : return 
16150 HPBUFF=HPBUFF+BUFFAMOUNT(ZZX) : return 
16160 MANABUFF=MANABUFF+BUFFAMOUNT(ZZX) : return 
16200 rem ******* Formatting a Save Disk *******
16210 rem This has to be in and it has to be drive agnostic. ST User had an article about how to set up the trap call within STOS to do this - dig it out? 80 tracks, 10 sectors, double sided, so 807,396 bytes. 
16220 return 
16230 rem ******* Sound Subsystem *******
16240 return : rem Ask Neil about poking the L/R balance and volumes to have real directional stereo sound. Also get a stock sound effects set.
16250 rem Also there needs to be a table of volume percentages for left and right channels. 
16260 rem ******* Combat Wrangling *******
16270 return 
16310 rem ******* Map Debug Information *******
16320 QQ=free
16330 MU=QQQ-QQ : ZZ$="CurPos: ("+str$(XT(1))+","+str$(YT(1))+")  Mem: "+str$(MU)+" used,"+str$(QQ)+" free"+chr$(0)
16340 return : rem Do we want a fuller debug window as well?
16350 rem ******* Scripting Interface *******
16360 return : rem Scripts are checked every tock, and on entering any square. 
40830 rem ******* Relative facings table *******
40840 data 3,2,1,4
40850 data 4,3,2,1
40860 data 1,4,3,2
40870 data 2,1,4,3
40880 rem 1 front facing, 2 to the right, 3 backwards, 4 to the left, 5 is attack frame, and 6 is attack frame 2 (I have taken out alternate front face; we'll just flip 1 and paste that.)
40890 rem ******* Flank move table *******
40900 rem  Need to think of a way to translate this to other orientations. Maybe four tables in an array (face,rel-X,rel-Y) or something like that?
40910 data 3,2,2,2,2
40920 data 4,3,2,2,2
40930 data 3,3,3,2,2
40940 data 4,3,3,3,2
40950 data 4,4,3,3,3
40960 data 4,3,3,3,3
40970 data 1,4,3,3,3
40980 data 4,4,4,3,3
40990 data 1,4,4,4,2
41000 data 1,1,4,4,3
41010 data 1,4,4,4,4
41020 data 2,1,4,4,4
41030 data 1,1,1,4,4
41040 data 2,1,1,1,4
41050 data 2,2,1,1,1
41060 data 2,1,1,1,1
41070 data 3,2,1,1,1
41080 data 2,2,2,1,1
41090 data 3,2,2,2,1
41100 data 3,3,2,2,2
49999 rem ******* Credits Scroller Text *******
50000 data ""
50001 data ""
50002 data ""
50003 data "                  (C)  W O N D E R F U L   I N D U S T R I E S "
50004 data ""
50005 data "                                    M M X X I I"
50006 data ""
50007 data ""
50008 data "                               (the year of the war)"
50009 data ""
50010 data ""
50011 data ""
50012 data ""
50013 data ""
50014 data ""
50015 data "          Concept, Design, and STOS Coding        JON S. STOCK"
50016 data ""
50017 data ""
50018 data ""
50019 data "                        Graphical Wizardry        MICHAEL KEENLEYSIDE"
50020 data "                                                  JON S. STOCK"
50021 data ""
50022 data ""
50023 data "                   68000 Assembler Sorcery        TOM WALKER"
50024 data ""
50025 data ""
50026 data ""
50027 data "                          Sound Subsystems        NEIL HALLIDAY"
50028 data ""
50029 data ""
50030 data ""
50031 data "              Music and Musical Interludes        JON S. STOCK"
50032 data "                                                  in QUARTET"
50033 data ""
50034 data ""
50035 data "                              Level Design        [YOUR NAME HERE]"
50036 data ""
50037 data ""
50038 data ""
50039 data ""
50040 data ""
50041 data ""
50042 data ""
50043 data "                          CAST in ORDER OF APPEARANCE"
50044 data ""
50045 data ""
50046 data ""
50047 data "                           The Protagonist        YOU"
50048 data ""
50049 data "     Haephaestia, Gorgon Sorceress of Mars        SOME BIRD JON MET"
50050 data "                                                  DOWN THE PUB"
50051 data ""
50052 data ""
50053 data ""
50054 data ""
50055 data ""
50056 data "                      Filmed On Location in Maldon, Essex"
50057 data ""
50058 data ""
50059 data ""
50060 data ""
50061 data ""
50062 data "                            Location Scout        JON'S BATTERED OLD"
50063 data "                                                  VAUXHALL VECTRA"
50064 data ""
50065 data "                      Dungeon Construction        MIXOM INDUSTRIAL"
50066 data ""
50067 data "                        Insectoid Breeding        JOSEPH BUGMAN"
50068 data ""
50069 data "                           Manticore Tamer        CAROLE BASKIN"
50070 data ""
50071 data "                                 Costumier        VARIOUS CHARITY SHOPS"
50072 data ""
50073 data "                           Arms and Armour        ESSEX COUNTY COUNCIL TIP,"
50074 data "                                                  COLCHESTER"
50075 data ""
50076 data "                         Stunt Coordinator        SOME DRUNK FROM TIPTREE"
50077 data ""
50078 data ""
50079 data ""
50080 data ""
50081 data "                         WARRIORS OF LIGHT WAS CREATED USING"
50082 data ""
50083 data ""
50084 data ""
50085 data ""
50086 data "             STOS Basic 'The Game Creator'        FRANCOIS LIONET"
50087 data "                   Development Environment        CONSTANTIN SOTIROPOULOS"
50088 data ""
50089 data "   Missing Link & Stevie Wonder Extensions        TOP NOTCH SOFTWARE"
50090 data ""
50091 data "                         Control Extension        L. J. GREENHALGH"
50092 data ""
50093 data "                   Quartet Music Sequencer        MICRODEAL LTD"
50094 data ""
50095 data "                     DevPac ST 2 Assembler        HISOFT LTD"
50096 data ""
50097 data "                     Neochrome Master 2.28        ATARI & DELTA FORCE"
50098 data ""
50099 data "                            Ice Packer 2.4        AXE/SUPERIOR"
50100 data ""
50101 data ""
50102 data ""
50103 data ""
50104 data "                 Soundtrack not available on LP, 8 Track, or CD"
50105 data "            (but there's a TDK MA-R cassette tape with its name on it)"
50106 data ""
50107 data ""
50108 data "                          Novelisation also not available"
50109 data ""
50110 data ""
50111 data ""
50112 data "               No Giant Insects were squashed during the production"
50113 data "                                   of this game."
50114 data ""
50115 data ""
50116 data ""
50117 data "            This is a work of fiction. Any resemblance to real persons"
50118 data "            or events of any type whatsoever is entirely coincidental."
50119 data ""
50120 data ""
50121 data ""
50122 data ""
50123 data "                                  THANKS TO . . . . . "
50124 data ""
50125 data ""
50126 data ""
50127 data ""
50128 data "             Jon would like to thank: Chris 'Exxos' Swinson for keeping"
50129 data "           all our STs trucking along 30 years down the line; Francois for"
50130 data "            the creation of STOS; Mike and Neil for the STOS Coders group"
50131 data "             on Facebook; various heavy metal acts for inspiration incl:"
50132 data "              Freedom Call, Visigoth, Powerwolf, Battle Beast, Alestorm,"
50133 data "            Rhapsody (of Fire), Blind Guardian, The Kovenant, Iced Earth,"
50134 data "             =T= MANOWAR =T=, Imperial Age, Immortal, Jenner, Crucified "
50135 data "           Barbara, Lee Aaron, Doro Pesch (Metal Queen), Pantera, Slayer,"
50136 data "             Kreator, Warbringer, Eternal Champion, Exodus, Crazy Lixx,"
50137 data "            and many others; televisual inspirations from Robert Tapert,"
50138 data "             Lucy Lawless, Sam Raimi et al; Henry Cavill, Joey Batey, and"
50139 data "            similar (I can't stop humming 'Toss a Coin to Your Witcher' -"
50140 data "            thanks lads!); Rockne S. O'Bannon, Ben Browder, Claudia Black,"
50141 data "              Gigi Edgley, Wayne Pygram and the rest of the crew of Moya;"
50142 data "            the inimitable Steve Ritchie for the greatest pinball machines"
50143 data "                ever to exist; various Youtube personalities including"
50144 data "            but not limited to Techmoan, LGR, Nostalgia Nerd, Kim Justice,"
50145 data "               JimPlaysGames, The Critical Drinker, LTT, and VWestlife;"
50146 data "            and various Atari ST coders and doyens past and present, whose"
50147 data "            effect on making the system we love what it is are as diverse"
50148 data "                                  as they are amusing."
50149 data ""
50150 data ""
50151 data ""
50152 data ""
50153 data ""
50154 data ""
50155 data ""
50156 data ""
50157 data ""
50158 data ""
50159 data ""
50160 data ""
50161 data ""
50162 data ""
50163 data ""
50164 data ""
50165 data ""
50166 data ""
50167 data ""
50168 data ""
50169 data ""
50170 data ""
50171 data ""
50172 data ""
50173 data ""
50174 data ""
50175 data ""
50176 data "                            That's all! Nothing to see here."
50177 data ""
50178 data ""
50179 data ""
50180 data ""
50181 data ""
50182 data ""
50183 data ""
50184 data ""
50185 data ""
50186 data ""
50187 data ""
50188 data ""
50189 data ""
50190 data ""
50191 data ""
50192 data ""
50193 data ""
50194 data ""
50195 data ""
50196 data ""
50197 data ""
50198 data ""
50199 data ""
50200 data ""
50201 data ""
50202 data ""
50203 data ""
50204 data "                                      No, really."
50205 data ""
50206 data ""
50207 data ""
50208 data ""
50209 data ""
50210 data ""
50211 data ""
50212 data ""
50213 data ""
50214 data ""
50215 data ""
50216 data ""
50217 data ""
50218 data ""
50219 data ""
50220 data ""
50221 data ""
50222 data ""
50223 data ""
50224 data ""
50225 data ""
50226 data ""
50227 data ""
50228 data ""
50229 data ""
50230 data ""
50231 data ""
50232 data "                           Honestly, you're wasting your time."
50233 data ""
50234 data ""
50235 data ""
50236 data ""
50237 data ""
50238 data ""
50239 data ""
50240 data ""
50241 data ""
50242 data ""
50243 data ""
50244 data ""
50245 data ""
50246 data ""
50247 data ""
50248 data ""
50249 data ""
50250 data ""
50251 data ""
50252 data ""
50253 data ""
50254 data ""
50255 data ""
50256 data ""
50257 data ""
50258 data ""
50259 data ""
50260 data "               There's probably no stinger. Now go away and enjoy your life."
50261 data ""
50262 data ""
50263 data ""
50264 data ""
50265 data ""
50266 data ""
50267 data ""
50268 data ""
50269 data ""
50270 data ""
50271 data ""
50272 data ""
50273 data ""
50274 data ""
50275 data ""
50276 data ""
50277 data ""
50278 data ""
50279 data ""
50280 data ""
50281 data ""
50282 data ""
50283 data ""
50284 data ""
50285 data ""
50286 data ""
50287 data "                                   ...You still here?"
50288 data ""
50289 data ""
50290 data ""
50291 data ""
50292 data ""
50293 data ""
50294 data ""
50295 data ""
50296 data ""
50297 data ""
50298 data ""
50299 data ""
50300 data ""
50301 data ""
50302 data ""
50303 data ""
50304 data ""
50305 data ""
50306 data ""
50307 data ""
50308 data ""
50309 data ""
50310 data ""
50311 data ""
50312 data ""
50313 data ""
50314 data ""
50315 data "              You are wasting your time. Take it from me. I wrote this."
50316 data ""
50317 data ""
50318 data ""
50319 data ""
50320 data ""
50321 data ""
50322 data ""
50323 data ""
50324 data ""
50325 data ""
50326 data ""
50327 data ""
50328 data ""
50329 data ""
50330 data ""
50331 data ""
50332 data ""
50333 data ""
50334 data ""
50335 data ""
50336 data ""
50337 data ""
50338 data ""
50339 data ""
50340 data ""
50341 data ""
50342 data ""
50343 data "                         Sigh. Okay then. If you must."
50344 data ""
50345 data "         Enter the following as your character name for fun surprises:"
50346 data ""
50347 data "           VESEMIR, LGR, ABBY, ALPACA, MEMELORD, SLAANESH, GANYMEDE"
50348 data "           MAPAAAAAAAJ, CYKOPHOX, KOTAKU, BARBRA STREISAND, UNIPORN"
50349 data ""
50350 data "                                 Satisfied now?"
50351 data ""
50352 data ""
50353 data ""
50354 data "                              Good. Then FUCK OFF."
50500 rem ******* Volume Table for Directional Stereo Sound *******
50501 rem Left channel, right channel, x17 (8 squares in all directions from the player), expressed as n/100
51000 rem ******* Causes of Death *******
51001 data "You bit the dust in a truly novel and unexpected way."
51002 data "You were slain in combat."
51003 data "You tumbled down a pit to your death."
51004 data "You collapsed and died from poison."
51005 data "You bled out from wounds."
51006 data "You starved."
51007 data "You were fatally wounded by an arrow, chakram, or other ranged weapon."
51008 data "You were struck down by lightning."
51009 data "You were burned alive."
51010 data "You meddled with magic too powerful for you to grasp and died of an aneurysm."
51011 data "You were melted by acid or some other corrosive substance."
51012 data "You got stoned."
51013 data "You unwisely dabbled in teleportation and embedded yourself in solid rock."
51014 data "You died of blunt force trauma."
52000 rem ******* Object locations in bank M2 *******
52001 data 0,0,64,0,128,0,192,0,256,0
52002 data 0,24,64,24,128,24,192,24,256,24
52003 data 0,48,64,48,128,48,192,48,256,48
52004 data 0,72,64,72,128,72,192,72,256,72
52005 data 0,96,64,96,128,96,192,96,256,96
52006 data 0,120,64,120,128,120,192,120,256,120
52007 data 0,144,64,144,128,144,192,144,256,144
52008 data 0,168,64,168,128,168,192,168,256,168
52009 data 0,192,64,192,128,192,192,192,256,192
52010 data 0,216,64,216,128,216,192,216,256,216
52011 data 0,240,64,240,128,240,192,240,256,240
52012 data 0,264,64,264,128,264,192,264,256,264
52013 data 0,288,64,288,128,288,192,288,256,288
52014 data 0,312,64,312,128,312,192,312,256,312
52015 data 0,336,64,336,128,336,192,336,256,336
52016 data 0,360,64,360,128,360,192,360,256,360
52017 data 0,384,64,384,128,384,192,384,256,384
52018 data 0,408,64,408,128,408,192,408,256,408
52019 data 0,432,64,432,128,432,192,432,256,432
52020 data 0,456,64,456,128,456,192,456,256,456
52021 data 0,480,64,480,128,480,192,480,256,480
52022 data 0,504,64,504,128,504,192,504,256,504
52023 data 0,528,64,528,128,528,192,528,256,528
52024 data 0,552,64,552,128,552,192,552,256,552
52025 data 0,576,64,576,128,576,192,576,256,576
52026 data 0,600,64,600,128,600,192,600,256,600
52027 data 0,624,64,624,128,624,192,624,256,624
52028 data 0,648,64,648,128,648,192,648,256,648
52029 data 0,672,64,672,128,672,192,672,256,672
52030 data 0,696,64,696,128,696,192,696,256,696
52031 data 0,720,64,720,128,720,192,720,256,720
52032 data 0,744,64,744,128,744,192,744,256,744
52033 data 0,768,64,768,128,768,192,768,256,768
52034 data 0,792,64,792,128,792,192,792,256,792
52035 data 0,816,64,816,128,816,192,816,256,816
52036 data 0,840,64,840,128,840,192,840,256,840
52037 data 0,864,64,864,128,864,192,864,256,864
52038 data 0,888,64,888,128,888,192,888,256,888
52039 data 0,912,64,912,128,912,192,912,256,912
52040 data 0,936,64,936,128,936,192,936,256,936
52041 data 0,960,64,960,128,960,192,960,256,960
52042 data 0,984,64,984,128,984,192,984,256,984
52043 data 0,1008,64,1008,128,1008,192,1008,256,1008
52044 data 0,1032,64,1032,128,1032,192,1032,256,1032
52045 data 0,1056,64,1056,128,1056,192,1056,256,1056
52046 data 0,1080,64,1080,128,1080,192,1080,256,1080
52047 data 0,1104,64,1104,128,1104,192,1104,256,1104
52048 data 0,1128,64,1128,128,1128,192,1128,256,1128
52049 data 0,1152,64,1152,128,1152,192,1152,256,1152
52050 data 0,1176,64,1176,128,1176,192,1176,256,1176
52051 data 0,1200,64,1200,128,1200,192,1200,256,1200
52052 data 0,1224,64,1224,128,1224,192,1224,256,1224
52053 data 0,1248,64,1248,128,1248,192,1248,256,1248
52054 data 0,1272,64,1272,128,1272,192,1272,256,1272
52055 data 0,1296,64,1296,128,1296,192,1296,256,1296
52056 data 0,1320,64,1320,128,1320,192,1320,256,1320
52057 data 0,1344,64,1344,128,1344,192,1344,256,1344
52058 data 0,1368,64,1368,128,1368,192,1368,256,1368
52059 data 0,1392,64,1392,128,1392,192,1392,256,1392
52060 data 0,1416,64,1416,128,1416,192,1416,256,1416
52061 data 0,1440,64,1440,128,1440,192,1440,256,1440
52062 data 0,1464,64,1464,128,1464,192,1464,256,1464
52063 data 0,1488,64,1488,128,1488,192,1488,256,1488
52064 data 0,1512,64,1512,128,1512,192,1512,256,1512
54000 rem ******* Dialogue Wodge (for readables, cutscenes, etc.) *******
54001 data "I take a look at my enormous penis..."
54002 data "...and my troubles go a-meltin' away!"
